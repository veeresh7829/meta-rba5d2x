From 81510a076a7743a03371595487e907fc28fa7d40 Mon Sep 17 00:00:00 2001
From: Ganesh K <ganesh.k@phytec.in>
Date: Mon, 24 Jun 2019 18:53:09 +0530
Subject: [PATCH 12/12] starting with noprs files

---
 src/nlgpio16/CMakeLists.txt            |    5 -
 src/nlgpio16/nlgpio16.cxx              |  344 -----
 src/nlgpio16/nlgpio16.hpp              |  239 ----
 src/nlgpio16/nlgpio16.i                |   16 -
 src/nlgpio16/nlgpio16.json             |   58 -
 src/nmea_gps/CMakeLists.txt            |    9 -
 src/nmea_gps/nmea_gps.c                |  345 -----
 src/nmea_gps/nmea_gps.cxx              |  625 ---------
 src/nmea_gps/nmea_gps.h                |  155 ---
 src/nmea_gps/nmea_gps.hpp              |  453 -------
 src/nmea_gps/nmea_gps.i                |   28 -
 src/nmea_gps/nmea_gps.json             |   49 -
 src/nmea_gps/nmea_gps_fti.c            |   96 --
 src/nrf24l01/CMakeLists.txt            |    5 -
 src/nrf24l01/Callback.hpp              |   20 -
 src/nrf24l01/nrf24l01.cxx              |  524 --------
 src/nrf24l01/nrf24l01.hpp              |  417 ------
 src/nrf24l01/nrf24l01.i                |   35 -
 src/nrf24l01/nrf24l01.json             |   74 --
 src/nrf8001/CMakeLists.txt             |    8 -
 src/nrf8001/aci.h                      |  672 ----------
 src/nrf8001/aci_cmds.h                 |  433 -------
 src/nrf8001/aci_evts.h                 |  397 ------
 src/nrf8001/aci_protocol_defines.h     |  192 ---
 src/nrf8001/aci_queue.cpp              |  201 ---
 src/nrf8001/aci_queue.h                |   76 --
 src/nrf8001/aci_setup.cpp              |  177 ---
 src/nrf8001/aci_setup.h                |   53 -
 src/nrf8001/acilib.cpp                 |  616 ---------
 src/nrf8001/acilib.h                   |   61 -
 src/nrf8001/acilib_defs.h              |   37 -
 src/nrf8001/acilib_if.h                |  471 -------
 src/nrf8001/acilib_types.h             |   33 -
 src/nrf8001/boards.h                   |   36 -
 src/nrf8001/dtm.h                      |   63 -
 src/nrf8001/hal_aci_tl.cpp             |  460 -------
 src/nrf8001/hal_aci_tl.h               |  189 ---
 src/nrf8001/hal_platform.h             |   78 --
 src/nrf8001/lib_aci.cpp                |  742 -----------
 src/nrf8001/lib_aci.h                  |  569 ---------
 src/nrf8001/nrf8001.cxx                |   77 --
 src/nrf8001/nrf8001.hpp                |   62 -
 src/nrf8001/nrf8001.json               |   55 -
 src/nrf8001/uart_over_ble.h            |   79 --
 src/nunchuck/CMakeLists.txt            |    9 -
 src/nunchuck/nunchuck.c                |  207 ---
 src/nunchuck/nunchuck.cxx              |   59 -
 src/nunchuck/nunchuck.h                |  123 --
 src/nunchuck/nunchuck.hpp              |  134 --
 src/nunchuck/nunchuck.i                |   16 -
 src/nunchuck/nunchuck.json             |   47 -
 src/nunchuck/nunchuck_fti.c            |  190 ---
 src/o2/CMakeLists.txt                  |    8 -
 src/o2/o2.c                            |  139 --
 src/o2/o2.cxx                          |   56 -
 src/o2/o2.h                            |  143 ---
 src/o2/o2.hpp                          |   75 --
 src/o2/o2.json                         |   39 -
 src/o2/o2_fti.c                        |  116 --
 src/otp538u/CMakeLists.txt             |    9 -
 src/otp538u/otp538u.c                  |  374 ------
 src/otp538u/otp538u.cxx                |   67 -
 src/otp538u/otp538u.h                  |  153 ---
 src/otp538u/otp538u.hpp                |  177 ---
 src/otp538u/otp538u.json               |   67 -
 src/otp538u/otp538u_fti.c              |  116 --
 src/otp538u/thermister_rt_table.h      |   45 -
 src/otp538u/thermopile_vt_table.h      |  103 --
 src/ozw/CMakeLists.txt                 |   16 -
 src/ozw/aeotecdsb09104.cxx             |   87 --
 src/ozw/aeotecdsb09104.hpp             |  147 ---
 src/ozw/aeotecdw2e.cxx                 |   77 --
 src/ozw/aeotecdw2e.hpp                 |  132 --
 src/ozw/aeotecsdg2.cxx                 |   95 --
 src/ozw/aeotecsdg2.hpp                 |  164 ---
 src/ozw/aeotecss6.cxx                  |   86 --
 src/ozw/aeotecss6.hpp                  |  138 --
 src/ozw/ozw.cxx                        |  996 ---------------
 src/ozw/ozw.hpp                        |  613 ---------
 src/ozw/ozw.i                          |   34 -
 src/ozw/ozw.json                       |  107 --
 src/ozw/ozwdump.cxx                    |   42 -
 src/ozw/ozwdump.hpp                    |   63 -
 src/ozw/ozwinterface.cxx               |   75 --
 src/ozw/ozwinterface.hpp               |  216 ----
 src/ozw/tzemt400.cxx                   |  148 ---
 src/ozw/tzemt400.hpp                   |  159 ---
 src/ozw/zwNode.cxx                     |  197 ---
 src/ozw/zwNode.hpp                     |  142 ---
 src/p9813/CMakeLists.txt               |    7 -
 src/p9813/p9813.c                      |  150 ---
 src/p9813/p9813.cxx                    |  146 ---
 src/p9813/p9813.h                      |  106 --
 src/p9813/p9813.hpp                    |  135 --
 src/p9813/p9813.i                      |   14 -
 src/p9813/p9813.json                   |   58 -
 src/p9813/p9813_fti.c                  |   67 -
 src/pca9685/CMakeLists.txt             |    5 -
 src/pca9685/pca9685.cxx                |  302 -----
 src/pca9685/pca9685.hpp                |  320 -----
 src/pca9685/pca9685.i                  |   14 -
 src/pca9685/pca9685.json               |   56 -
 src/pn532/CMakeLists.txt               |    5 -
 src/pn532/license.txt                  |   26 -
 src/pn532/pn532.cxx                    | 1573 -----------------------
 src/pn532/pn532.hpp                    |  505 --------
 src/pn532/pn532.i                      |   32 -
 src/pn532/pn532.json                   |   50 -
 src/ppd42ns/CMakeLists.txt             |    9 -
 src/ppd42ns/ppd42ns.c                  |  196 ---
 src/ppd42ns/ppd42ns.cxx                |   51 -
 src/ppd42ns/ppd42ns.h                  |   82 --
 src/ppd42ns/ppd42ns.hpp                |   86 --
 src/ppd42ns/ppd42ns.i                  |   15 -
 src/ppd42ns/ppd42ns.json               |   70 --
 src/ppd42ns/ppd42ns_data.h             |   48 -
 src/pulsensor/CMakeLists.txt           |    5 -
 src/pulsensor/Callback.hpp             |   12 -
 src/pulsensor/pulsensor.cxx            |  160 ---
 src/pulsensor/pulsensor.hpp            |  106 --
 src/pulsensor/pulsensor.i              |   27 -
 src/pulsensor/pulsensor.json           |   43 -
 src/relay/CMakeLists.txt               |    8 -
 src/relay/relay.c                      |   83 --
 src/relay/relay.cxx                    |   68 -
 src/relay/relay.h                      |   93 --
 src/relay/relay.hpp                    |  102 --
 src/relay/relay.json                   |   68 -
 src/relay/relay_fti.c                  |   97 --
 src/rf22/CMakeLists.txt                |    5 -
 src/rf22/rf22.cxx                      |  756 -----------
 src/rf22/rf22.hpp                      |  987 ---------------
 src/rf22/rf22.i                        |   34 -
 src/rf22/rf22.json                     |   63 -
 src/rfr359f/CMakeLists.txt             |    5 -
 src/rfr359f/rfr359f.cxx                |   54 -
 src/rfr359f/rfr359f.hpp                |   82 --
 src/rfr359f/rfr359f.json               |   57 -
 src/rgbringcoder/CMakeLists.txt        |    5 -
 src/rgbringcoder/rgbringcoder.cxx      |  187 ---
 src/rgbringcoder/rgbringcoder.hpp      |  152 ---
 src/rgbringcoder/rgbringcoder.i        |   14 -
 src/rgbringcoder/rgbringcoder.json     |   48 -
 src/rhusb/CMakeLists.txt               |    6 -
 src/rhusb/rhusb.cxx                    |  173 ---
 src/rhusb/rhusb.hpp                    |  118 --
 src/rhusb/rhusb.i                      |   16 -
 src/rhusb/rhusb.json                   |   60 -
 src/rn2903/CMakeLists.txt              |    8 -
 src/rn2903/rn2903.c                    | 1162 -----------------
 src/rn2903/rn2903.cxx                  |  334 -----
 src/rn2903/rn2903.h                    |  718 -----------
 src/rn2903/rn2903.hpp                  |  640 ----------
 src/rn2903/rn2903.i                    |   16 -
 src/rn2903/rn2903.json                 |   53 -
 src/rn2903/rn2903_defs.h               |  147 ---
 src/rotary/CMakeLists.txt              |    8 -
 src/rotary/rotary.c                    |   78 --
 src/rotary/rotary.cxx                  |   78 --
 src/rotary/rotary.h                    |   88 --
 src/rotary/rotary.hpp                  |  115 --
 src/rotary/rotary.json                 |   52 -
 src/rotary/rotary_fti.c                |  126 --
 src/rotaryencoder/CMakeLists.txt       |    9 -
 src/rotaryencoder/rotaryencoder.c      |  132 --
 src/rotaryencoder/rotaryencoder.cxx    |   56 -
 src/rotaryencoder/rotaryencoder.h      |   84 --
 src/rotaryencoder/rotaryencoder.hpp    |   99 --
 src/rotaryencoder/rotaryencoder.i      |   16 -
 src/rotaryencoder/rotaryencoder.json   |   58 -
 src/rotaryencoder/rotaryencoder_fti.c  |  106 --
 src/rpr220/CMakeLists.txt              |    9 -
 src/rpr220/rpr220.c                    |  107 --
 src/rpr220/rpr220.cxx                  |   62 -
 src/rpr220/rpr220.h                    |   98 --
 src/rpr220/rpr220.hpp                  |  111 --
 src/rpr220/rpr220.i                    |   15 -
 src/rpr220/rpr220.json                 |   64 -
 src/rpr220/rpr220_fti.c                |   94 --
 src/rsc/CMakeLists.txt                 |    8 -
 src/rsc/rsc.c                          |  534 --------
 src/rsc/rsc.cxx                        |  182 ---
 src/rsc/rsc.h                          |  219 ----
 src/rsc/rsc.hpp                        |  251 ----
 src/rsc/rsc.json                       |   84 --
 src/rsc/rsc_regs.h                     |  249 ----
 src/scam/CMakeLists.txt                |    5 -
 src/scam/scam.cxx                      |  490 --------
 src/scam/scam.hpp                      |  195 ---
 src/scam/scam.i                        |   16 -
 src/scam/scam.json                     |   53 -
 src/sensortemplate/CMakeLists.txt      |    5 -
 src/sensortemplate/sensortemplate.cxx  |   32 -
 src/sensortemplate/sensortemplate.hpp  |   95 --
 src/sensortemplate/sensortemplate.i    |   29 -
 src/sensortemplate/sensortemplate.json |  251 ----
 src/servo/CMakeLists.txt               |    9 -
 src/servo/es08a.c                      |  116 --
 src/servo/es08a.cxx                    |   41 -
 src/servo/es08a.h                      |  122 --
 src/servo/es08a.hpp                    |   68 -
 src/servo/es08a_fti.c                  |   89 --
 src/servo/es9257.c                     |  117 --
 src/servo/es9257.cxx                   |   41 -
 src/servo/es9257.h                     |  119 --
 src/servo/es9257.hpp                   |   65 -
 src/servo/es9257_fti.c                 |   89 --
 src/servo/servo.cxx                    |  164 ---
 src/servo/servo.hpp                    |  168 ---
 src/servo/servo.i                      |   18 -
 src/servo/servo.json                   |  137 --
 src/sht1x/CMakeLists.txt               |    9 -
 src/sht1x/sht1x.c                      |  394 ------
 src/sht1x/sht1x.cxx                    |  116 --
 src/sht1x/sht1x.h                      |  207 ---
 src/sht1x/sht1x.hpp                    |  187 ---
 src/sht1x/sht1x.i                      |   16 -
 src/sht1x/sht1x.json                   |   81 --
 src/sht1x/sht1x_defs.h                 |   68 -
 src/sht1x/sht1x_fti.c                  |  125 --
 src/si1132/CMakeLists.txt              |    5 -
 src/si1132/si1132.cxx                  |  223 ----
 src/si1132/si1132.hpp                  |  101 --
 src/si1132/si1132.i                    |   21 -
 src/si1132/si1132.json                 |   50 -
 src/si114x/CMakeLists.txt              |    5 -
 src/si114x/si114x.cxx                  |  200 ---
 src/si114x/si114x.hpp                  |  323 -----
 src/si114x/si114x.i                    |   14 -
 src/si114x/si114x.json                 |   69 -
 src/si7005/CMakeLists.txt              |    5 -
 src/si7005/mraa-utils.cxx              |   74 --
 src/si7005/mraa-utils.hpp              |   37 -
 src/si7005/si7005.cxx                  |  201 ---
 src/si7005/si7005.hpp                  |  143 ---
 src/si7005/si7005.i                    |   21 -
 src/si7005/si7005.json                 |   54 -
 src/slide/CMakeLists.txt               |    8 -
 src/slide/slide.c                      |  136 --
 src/slide/slide.cxx                    |   67 -
 src/slide/slide.h                      |  141 ---
 src/slide/slide.hpp                    |   99 --
 src/slide/slide.json                   |   63 -
 src/slide/slide_fti.c                  |  119 --
 src/sm130/CMakeLists.txt               |    5 -
 src/sm130/sm130.cxx                    |  878 -------------
 src/sm130/sm130.hpp                    |  467 -------
 src/sm130/sm130.json                   |   43 -
 src/smartdrive/CMakeLists.txt          |    5 -
 src/smartdrive/smartdrive.cxx          |  430 -------
 src/smartdrive/smartdrive.hpp          |  302 -----
 src/smartdrive/smartdrive.i            |   14 -
 src/smartdrive/smartdrive.json         |   42 -
 src/speaker/CMakeLists.txt             |    9 -
 src/speaker/speaker.c                  |  349 ------
 src/speaker/speaker.cxx                |   87 --
 src/speaker/speaker.h                  |  171 ---
 src/speaker/speaker.hpp                |  152 ---
 src/speaker/speaker.json               |   53 -
 src/ssd1351/CMakeLists.txt             |    5 -
 src/ssd1351/license.txt                |   24 -
 src/ssd1351/ssd1351.cxx                |  223 ----
 src/ssd1351/ssd1351.hpp                |  193 ---
 src/ssd1351/ssd1351.i                  |   19 -
 src/ssd1351/ssd1351.json               |   49 -
 src/ssd1351/ssd1351_gfx.cxx            |  220 ----
 src/ssd1351/ssd1351_gfx.hpp            |  455 -------
 src/st7735/CMakeLists.txt              |    5 -
 src/st7735/license.txt                 |   24 -
 src/st7735/st7735.cxx                  |  270 ----
 src/st7735/st7735.hpp                  |  639 ----------
 src/st7735/st7735.i                    |   59 -
 src/st7735/st7735.json                 |   51 -
 src/st7735/st7735_gfx.cxx              |  233 ----
 src/st7735/st7735_gfx.hpp              |  221 ----
 src/stepmotor/CMakeLists.txt           |    9 -
 src/stepmotor/stepmotor.cxx            |  182 ---
 src/stepmotor/stepmotor.hpp            |  176 ---
 src/stepmotor/stepmotor.i              |   14 -
 src/stepmotor/stepmotor.json           |   48 -
 src/sx1276/CMakeLists.txt              |    5 -
 src/sx1276/LICENSE.txt                 |   25 -
 src/sx1276/sx1276.cxx                  | 2160 --------------------------------
 src/sx1276/sx1276.hpp                  | 2036 ------------------------------
 src/sx1276/sx1276.i                    |   22 -
 src/sx1276/sx1276.json                 |   68 -
 src/sx6119/CMakeLists.txt              |    5 -
 src/sx6119/sx6119.cxx                  |   80 --
 src/sx6119/sx6119.hpp                  |   90 --
 src/sx6119/sx6119.json                 |   55 -
 290 files changed, 46220 deletions(-)
 delete mode 100644 src/nlgpio16/CMakeLists.txt
 delete mode 100644 src/nlgpio16/nlgpio16.cxx
 delete mode 100644 src/nlgpio16/nlgpio16.hpp
 delete mode 100644 src/nlgpio16/nlgpio16.i
 delete mode 100644 src/nlgpio16/nlgpio16.json
 delete mode 100644 src/nmea_gps/CMakeLists.txt
 delete mode 100644 src/nmea_gps/nmea_gps.c
 delete mode 100644 src/nmea_gps/nmea_gps.cxx
 delete mode 100644 src/nmea_gps/nmea_gps.h
 delete mode 100644 src/nmea_gps/nmea_gps.hpp
 delete mode 100644 src/nmea_gps/nmea_gps.i
 delete mode 100644 src/nmea_gps/nmea_gps.json
 delete mode 100644 src/nmea_gps/nmea_gps_fti.c
 delete mode 100644 src/nrf24l01/CMakeLists.txt
 delete mode 100644 src/nrf24l01/Callback.hpp
 delete mode 100644 src/nrf24l01/nrf24l01.cxx
 delete mode 100644 src/nrf24l01/nrf24l01.hpp
 delete mode 100644 src/nrf24l01/nrf24l01.i
 delete mode 100644 src/nrf24l01/nrf24l01.json
 delete mode 100644 src/nrf8001/CMakeLists.txt
 delete mode 100644 src/nrf8001/aci.h
 delete mode 100644 src/nrf8001/aci_cmds.h
 delete mode 100644 src/nrf8001/aci_evts.h
 delete mode 100644 src/nrf8001/aci_protocol_defines.h
 delete mode 100644 src/nrf8001/aci_queue.cpp
 delete mode 100644 src/nrf8001/aci_queue.h
 delete mode 100644 src/nrf8001/aci_setup.cpp
 delete mode 100644 src/nrf8001/aci_setup.h
 delete mode 100644 src/nrf8001/acilib.cpp
 delete mode 100644 src/nrf8001/acilib.h
 delete mode 100644 src/nrf8001/acilib_defs.h
 delete mode 100644 src/nrf8001/acilib_if.h
 delete mode 100644 src/nrf8001/acilib_types.h
 delete mode 100644 src/nrf8001/boards.h
 delete mode 100644 src/nrf8001/dtm.h
 delete mode 100644 src/nrf8001/hal_aci_tl.cpp
 delete mode 100644 src/nrf8001/hal_aci_tl.h
 delete mode 100644 src/nrf8001/hal_platform.h
 delete mode 100644 src/nrf8001/lib_aci.cpp
 delete mode 100644 src/nrf8001/lib_aci.h
 delete mode 100644 src/nrf8001/nrf8001.cxx
 delete mode 100644 src/nrf8001/nrf8001.hpp
 delete mode 100644 src/nrf8001/nrf8001.json
 delete mode 100644 src/nrf8001/uart_over_ble.h
 delete mode 100644 src/nunchuck/CMakeLists.txt
 delete mode 100644 src/nunchuck/nunchuck.c
 delete mode 100644 src/nunchuck/nunchuck.cxx
 delete mode 100644 src/nunchuck/nunchuck.h
 delete mode 100644 src/nunchuck/nunchuck.hpp
 delete mode 100644 src/nunchuck/nunchuck.i
 delete mode 100644 src/nunchuck/nunchuck.json
 delete mode 100644 src/nunchuck/nunchuck_fti.c
 delete mode 100644 src/o2/CMakeLists.txt
 delete mode 100644 src/o2/o2.c
 delete mode 100644 src/o2/o2.cxx
 delete mode 100644 src/o2/o2.h
 delete mode 100644 src/o2/o2.hpp
 delete mode 100644 src/o2/o2.json
 delete mode 100644 src/o2/o2_fti.c
 delete mode 100644 src/otp538u/CMakeLists.txt
 delete mode 100644 src/otp538u/otp538u.c
 delete mode 100644 src/otp538u/otp538u.cxx
 delete mode 100644 src/otp538u/otp538u.h
 delete mode 100644 src/otp538u/otp538u.hpp
 delete mode 100644 src/otp538u/otp538u.json
 delete mode 100644 src/otp538u/otp538u_fti.c
 delete mode 100644 src/otp538u/thermister_rt_table.h
 delete mode 100644 src/otp538u/thermopile_vt_table.h
 delete mode 100644 src/ozw/CMakeLists.txt
 delete mode 100644 src/ozw/aeotecdsb09104.cxx
 delete mode 100644 src/ozw/aeotecdsb09104.hpp
 delete mode 100644 src/ozw/aeotecdw2e.cxx
 delete mode 100644 src/ozw/aeotecdw2e.hpp
 delete mode 100644 src/ozw/aeotecsdg2.cxx
 delete mode 100644 src/ozw/aeotecsdg2.hpp
 delete mode 100644 src/ozw/aeotecss6.cxx
 delete mode 100644 src/ozw/aeotecss6.hpp
 delete mode 100644 src/ozw/ozw.cxx
 delete mode 100644 src/ozw/ozw.hpp
 delete mode 100644 src/ozw/ozw.i
 delete mode 100644 src/ozw/ozw.json
 delete mode 100644 src/ozw/ozwdump.cxx
 delete mode 100644 src/ozw/ozwdump.hpp
 delete mode 100644 src/ozw/ozwinterface.cxx
 delete mode 100644 src/ozw/ozwinterface.hpp
 delete mode 100644 src/ozw/tzemt400.cxx
 delete mode 100644 src/ozw/tzemt400.hpp
 delete mode 100644 src/ozw/zwNode.cxx
 delete mode 100644 src/ozw/zwNode.hpp
 delete mode 100644 src/p9813/CMakeLists.txt
 delete mode 100644 src/p9813/p9813.c
 delete mode 100644 src/p9813/p9813.cxx
 delete mode 100644 src/p9813/p9813.h
 delete mode 100644 src/p9813/p9813.hpp
 delete mode 100644 src/p9813/p9813.i
 delete mode 100644 src/p9813/p9813.json
 delete mode 100644 src/p9813/p9813_fti.c
 delete mode 100644 src/pca9685/CMakeLists.txt
 delete mode 100644 src/pca9685/pca9685.cxx
 delete mode 100644 src/pca9685/pca9685.hpp
 delete mode 100644 src/pca9685/pca9685.i
 delete mode 100644 src/pca9685/pca9685.json
 delete mode 100644 src/pn532/CMakeLists.txt
 delete mode 100644 src/pn532/license.txt
 delete mode 100644 src/pn532/pn532.cxx
 delete mode 100644 src/pn532/pn532.hpp
 delete mode 100644 src/pn532/pn532.i
 delete mode 100644 src/pn532/pn532.json
 delete mode 100644 src/ppd42ns/CMakeLists.txt
 delete mode 100644 src/ppd42ns/ppd42ns.c
 delete mode 100644 src/ppd42ns/ppd42ns.cxx
 delete mode 100644 src/ppd42ns/ppd42ns.h
 delete mode 100644 src/ppd42ns/ppd42ns.hpp
 delete mode 100644 src/ppd42ns/ppd42ns.i
 delete mode 100644 src/ppd42ns/ppd42ns.json
 delete mode 100644 src/ppd42ns/ppd42ns_data.h
 delete mode 100644 src/pulsensor/CMakeLists.txt
 delete mode 100644 src/pulsensor/Callback.hpp
 delete mode 100644 src/pulsensor/pulsensor.cxx
 delete mode 100644 src/pulsensor/pulsensor.hpp
 delete mode 100644 src/pulsensor/pulsensor.i
 delete mode 100644 src/pulsensor/pulsensor.json
 delete mode 100644 src/relay/CMakeLists.txt
 delete mode 100644 src/relay/relay.c
 delete mode 100644 src/relay/relay.cxx
 delete mode 100644 src/relay/relay.h
 delete mode 100644 src/relay/relay.hpp
 delete mode 100644 src/relay/relay.json
 delete mode 100644 src/relay/relay_fti.c
 delete mode 100644 src/rf22/CMakeLists.txt
 delete mode 100644 src/rf22/rf22.cxx
 delete mode 100644 src/rf22/rf22.hpp
 delete mode 100644 src/rf22/rf22.i
 delete mode 100644 src/rf22/rf22.json
 delete mode 100644 src/rfr359f/CMakeLists.txt
 delete mode 100644 src/rfr359f/rfr359f.cxx
 delete mode 100644 src/rfr359f/rfr359f.hpp
 delete mode 100644 src/rfr359f/rfr359f.json
 delete mode 100644 src/rgbringcoder/CMakeLists.txt
 delete mode 100644 src/rgbringcoder/rgbringcoder.cxx
 delete mode 100644 src/rgbringcoder/rgbringcoder.hpp
 delete mode 100644 src/rgbringcoder/rgbringcoder.i
 delete mode 100644 src/rgbringcoder/rgbringcoder.json
 delete mode 100644 src/rhusb/CMakeLists.txt
 delete mode 100644 src/rhusb/rhusb.cxx
 delete mode 100644 src/rhusb/rhusb.hpp
 delete mode 100644 src/rhusb/rhusb.i
 delete mode 100644 src/rhusb/rhusb.json
 delete mode 100644 src/rn2903/CMakeLists.txt
 delete mode 100644 src/rn2903/rn2903.c
 delete mode 100644 src/rn2903/rn2903.cxx
 delete mode 100644 src/rn2903/rn2903.h
 delete mode 100644 src/rn2903/rn2903.hpp
 delete mode 100644 src/rn2903/rn2903.i
 delete mode 100644 src/rn2903/rn2903.json
 delete mode 100644 src/rn2903/rn2903_defs.h
 delete mode 100644 src/rotary/CMakeLists.txt
 delete mode 100644 src/rotary/rotary.c
 delete mode 100644 src/rotary/rotary.cxx
 delete mode 100644 src/rotary/rotary.h
 delete mode 100644 src/rotary/rotary.hpp
 delete mode 100644 src/rotary/rotary.json
 delete mode 100644 src/rotary/rotary_fti.c
 delete mode 100644 src/rotaryencoder/CMakeLists.txt
 delete mode 100644 src/rotaryencoder/rotaryencoder.c
 delete mode 100644 src/rotaryencoder/rotaryencoder.cxx
 delete mode 100644 src/rotaryencoder/rotaryencoder.h
 delete mode 100644 src/rotaryencoder/rotaryencoder.hpp
 delete mode 100644 src/rotaryencoder/rotaryencoder.i
 delete mode 100644 src/rotaryencoder/rotaryencoder.json
 delete mode 100644 src/rotaryencoder/rotaryencoder_fti.c
 delete mode 100644 src/rpr220/CMakeLists.txt
 delete mode 100644 src/rpr220/rpr220.c
 delete mode 100644 src/rpr220/rpr220.cxx
 delete mode 100644 src/rpr220/rpr220.h
 delete mode 100644 src/rpr220/rpr220.hpp
 delete mode 100644 src/rpr220/rpr220.i
 delete mode 100644 src/rpr220/rpr220.json
 delete mode 100644 src/rpr220/rpr220_fti.c
 delete mode 100644 src/rsc/CMakeLists.txt
 delete mode 100644 src/rsc/rsc.c
 delete mode 100644 src/rsc/rsc.cxx
 delete mode 100644 src/rsc/rsc.h
 delete mode 100644 src/rsc/rsc.hpp
 delete mode 100644 src/rsc/rsc.json
 delete mode 100644 src/rsc/rsc_regs.h
 delete mode 100644 src/scam/CMakeLists.txt
 delete mode 100644 src/scam/scam.cxx
 delete mode 100644 src/scam/scam.hpp
 delete mode 100644 src/scam/scam.i
 delete mode 100644 src/scam/scam.json
 delete mode 100644 src/sensortemplate/CMakeLists.txt
 delete mode 100644 src/sensortemplate/sensortemplate.cxx
 delete mode 100644 src/sensortemplate/sensortemplate.hpp
 delete mode 100644 src/sensortemplate/sensortemplate.i
 delete mode 100644 src/sensortemplate/sensortemplate.json
 delete mode 100644 src/servo/CMakeLists.txt
 delete mode 100644 src/servo/es08a.c
 delete mode 100644 src/servo/es08a.cxx
 delete mode 100644 src/servo/es08a.h
 delete mode 100644 src/servo/es08a.hpp
 delete mode 100644 src/servo/es08a_fti.c
 delete mode 100644 src/servo/es9257.c
 delete mode 100644 src/servo/es9257.cxx
 delete mode 100644 src/servo/es9257.h
 delete mode 100644 src/servo/es9257.hpp
 delete mode 100644 src/servo/es9257_fti.c
 delete mode 100644 src/servo/servo.cxx
 delete mode 100644 src/servo/servo.hpp
 delete mode 100644 src/servo/servo.i
 delete mode 100644 src/servo/servo.json
 delete mode 100644 src/sht1x/CMakeLists.txt
 delete mode 100644 src/sht1x/sht1x.c
 delete mode 100644 src/sht1x/sht1x.cxx
 delete mode 100644 src/sht1x/sht1x.h
 delete mode 100644 src/sht1x/sht1x.hpp
 delete mode 100644 src/sht1x/sht1x.i
 delete mode 100644 src/sht1x/sht1x.json
 delete mode 100644 src/sht1x/sht1x_defs.h
 delete mode 100644 src/sht1x/sht1x_fti.c
 delete mode 100644 src/si1132/CMakeLists.txt
 delete mode 100644 src/si1132/si1132.cxx
 delete mode 100644 src/si1132/si1132.hpp
 delete mode 100644 src/si1132/si1132.i
 delete mode 100644 src/si1132/si1132.json
 delete mode 100644 src/si114x/CMakeLists.txt
 delete mode 100644 src/si114x/si114x.cxx
 delete mode 100644 src/si114x/si114x.hpp
 delete mode 100644 src/si114x/si114x.i
 delete mode 100644 src/si114x/si114x.json
 delete mode 100644 src/si7005/CMakeLists.txt
 delete mode 100644 src/si7005/mraa-utils.cxx
 delete mode 100644 src/si7005/mraa-utils.hpp
 delete mode 100644 src/si7005/si7005.cxx
 delete mode 100644 src/si7005/si7005.hpp
 delete mode 100644 src/si7005/si7005.i
 delete mode 100644 src/si7005/si7005.json
 delete mode 100644 src/slide/CMakeLists.txt
 delete mode 100644 src/slide/slide.c
 delete mode 100644 src/slide/slide.cxx
 delete mode 100644 src/slide/slide.h
 delete mode 100644 src/slide/slide.hpp
 delete mode 100644 src/slide/slide.json
 delete mode 100644 src/slide/slide_fti.c
 delete mode 100644 src/sm130/CMakeLists.txt
 delete mode 100644 src/sm130/sm130.cxx
 delete mode 100644 src/sm130/sm130.hpp
 delete mode 100644 src/sm130/sm130.json
 delete mode 100644 src/smartdrive/CMakeLists.txt
 delete mode 100644 src/smartdrive/smartdrive.cxx
 delete mode 100644 src/smartdrive/smartdrive.hpp
 delete mode 100644 src/smartdrive/smartdrive.i
 delete mode 100644 src/smartdrive/smartdrive.json
 delete mode 100644 src/speaker/CMakeLists.txt
 delete mode 100644 src/speaker/speaker.c
 delete mode 100644 src/speaker/speaker.cxx
 delete mode 100644 src/speaker/speaker.h
 delete mode 100644 src/speaker/speaker.hpp
 delete mode 100644 src/speaker/speaker.json
 delete mode 100644 src/ssd1351/CMakeLists.txt
 delete mode 100644 src/ssd1351/license.txt
 delete mode 100644 src/ssd1351/ssd1351.cxx
 delete mode 100644 src/ssd1351/ssd1351.hpp
 delete mode 100644 src/ssd1351/ssd1351.i
 delete mode 100644 src/ssd1351/ssd1351.json
 delete mode 100644 src/ssd1351/ssd1351_gfx.cxx
 delete mode 100644 src/ssd1351/ssd1351_gfx.hpp
 delete mode 100644 src/st7735/CMakeLists.txt
 delete mode 100644 src/st7735/license.txt
 delete mode 100644 src/st7735/st7735.cxx
 delete mode 100644 src/st7735/st7735.hpp
 delete mode 100644 src/st7735/st7735.i
 delete mode 100644 src/st7735/st7735.json
 delete mode 100644 src/st7735/st7735_gfx.cxx
 delete mode 100644 src/st7735/st7735_gfx.hpp
 delete mode 100644 src/stepmotor/CMakeLists.txt
 delete mode 100644 src/stepmotor/stepmotor.cxx
 delete mode 100644 src/stepmotor/stepmotor.hpp
 delete mode 100644 src/stepmotor/stepmotor.i
 delete mode 100644 src/stepmotor/stepmotor.json
 delete mode 100644 src/sx1276/CMakeLists.txt
 delete mode 100644 src/sx1276/LICENSE.txt
 delete mode 100644 src/sx1276/sx1276.cxx
 delete mode 100644 src/sx1276/sx1276.hpp
 delete mode 100644 src/sx1276/sx1276.i
 delete mode 100644 src/sx1276/sx1276.json
 delete mode 100644 src/sx6119/CMakeLists.txt
 delete mode 100644 src/sx6119/sx6119.cxx
 delete mode 100644 src/sx6119/sx6119.hpp
 delete mode 100644 src/sx6119/sx6119.json

diff --git a/src/nlgpio16/CMakeLists.txt b/src/nlgpio16/CMakeLists.txt
deleted file mode 100644
index 9df9e78..0000000
--- a/src/nlgpio16/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "nlgpio16")
-set (libdescription "16-channel USB GPIO Module")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/nlgpio16/nlgpio16.cxx b/src/nlgpio16/nlgpio16.cxx
deleted file mode 100644
index 466af88..0000000
--- a/src/nlgpio16/nlgpio16.cxx
+++ /dev/null
@@ -1,344 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <time.h>
-
-#include "nlgpio16.hpp"
-
-using namespace upm;
-using namespace std;
-
-static const int maxBuffer = 1024;
-static const int baudRate = 115200;
-
-static char num2Hex(int i, bool upcase)
-{
-  char temp;
-
-  switch (i)
-    {
-    case 0: return '0';
-    case 1: return '1';
-    case 2: return '2';
-    case 3: return '3';
-    case 4: return '4';
-    case 5: return '5';
-    case 6: return '6';
-    case 7: return '7';
-    case 8: return '8';
-    case 9: return '9';
-    case 10: temp = (upcase) ? 'A' : 'a'; return temp;
-    case 11: temp = (upcase) ? 'B' : 'b'; return temp;
-    case 12: temp = (upcase) ? 'C' : 'c'; return temp;
-    case 13: temp = (upcase) ? 'D' : 'd'; return temp;
-    case 14: temp = (upcase) ? 'E' : 'e'; return temp;
-    case 15: temp = (upcase) ? 'F' : 'f'; return temp;
-
-    default:
-      throw std::out_of_range(std::string(__FUNCTION__) +
-                              ": number must be between 0 and 15");
-      return '0';
-    }
-}
-
-NLGPIO16::NLGPIO16(string uart) :
-  m_uart(uart)
-{
-  m_uart.setBaudRate(baudRate);
-}
-
-NLGPIO16::~NLGPIO16()
-{
-}
-
-bool NLGPIO16::dataAvailable(unsigned int millis)
-{
-  return m_uart.dataAvailable(millis);
-}
-
-std::string NLGPIO16::readStr(int len)
-{
-  return m_uart.readStr(len);
-}
-
-int NLGPIO16::writeStr(std::string data)
-{
-  m_uart.flush();
-  return m_uart.writeStr(data);
-}
-
-string NLGPIO16::sendCommand(string cmd)
-{
-  // make sure we got a command
-  if (cmd.empty())
-    {
-      throw std::invalid_argument(std::string(__FUNCTION__) +
-                                  ": cmd is empty!");
-      return "";
-    }
-
-  // make sure string is CR terminated
-  if (cmd.at(cmd.size() - 1) != '\r')
-    cmd.append("\r");
-
-  writeStr(cmd);
-
-  string resp;
-  while (dataAvailable(10))
-    {
-      resp += readStr(maxBuffer);
-    }
-
-  if (resp.empty())
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": timed out waiting for response");
-      return "";
-    }
-
-  // check that the last character is the prompt
-  if (resp.at(resp.size() - 1) != '>')
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": read from device corrupted");
-      return "";
-    }
-
-  // delete the last 3 characters, which should be '\n\r>'
-  resp.erase(resp.size() - 3, 3);
-
-  // find first delimeter (second should already be erased)
-  size_t pos = resp.find("\n\r");
-
-  // if we didn't find one, then the command was invalid.  This
-  // shouldn't happen, but we check for it anyway
-  if (pos == string::npos)
-    return "";
-
-  pos += 2;                     // skip past them.
-
-  // now we should have the value (or an empty string in the case of a
-  // write command).  Erase everything else and return the result.
-  resp.erase(0, pos);
-
-  return resp;
-}
-
-void NLGPIO16::gpioSet(int gpio)
-{
-  if (gpio < 0 || gpio > 15)
-    {
-      throw std::out_of_range(std::string(__FUNCTION__) +
-                              ": gpio must be between 0 and 15");
-      return;
-    }
-
-  string cmd("gpio set ");
-  cmd += num2Hex(gpio, true);
-
-  // set commands don't return anything useful
-  sendCommand(cmd);
-  return;
-}
-
-void NLGPIO16::gpioClear(int gpio)
-{
-  if (gpio < 0 || gpio > 15)
-    {
-      throw std::out_of_range(std::string(__FUNCTION__) +
-                              ": gpio must be between 0 and 15");
-      return;
-    }
-
-  string cmd("gpio clear ");
-  cmd += num2Hex(gpio, true);
-
-  // set commands don't return anything useful
-  sendCommand(cmd);
-  return;
-}
-
-bool NLGPIO16::gpioRead(int gpio)
-{
-  if (gpio < 0 || gpio > 15)
-    {
-      throw std::out_of_range(std::string(__FUNCTION__) +
-                              ": gpio must be between 0 and 15");
-      return false;
-    }
-
-  string cmd("gpio read ");
-  cmd += num2Hex(gpio, true);
-
-  string resp = sendCommand(cmd);
-  if (resp.empty())
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": invalid empty response from device");
-      return false;
-    }
-
-  // c++11 toString() would be handy...
-  return ( (atoi(resp.c_str()) == 0) ? false : true );
-}
-
-unsigned int NLGPIO16::gpioReadAll()
-{
-  string cmd("gpio readall");
-
-  string resp = sendCommand(cmd);
-  if (resp.empty())
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": invalid empty response from device");
-      return false;
-    }
-
-  //  Convert to unsigned int (but mask out everything but the lower 16bits)
-  unsigned int value = strtoul(resp.c_str(), NULL, 16);
-  value &= 0xffff;
-
-  return value;
-}
-
-void NLGPIO16::gpioSetIOMask(int mask)
-{
-  if (mask < 0 || mask > 65535)
-    {
-      throw std::out_of_range(std::string(__FUNCTION__) +
-                              ": mask must be between 0 and 65535");
-      return;
-    }
-
-  string cmd("gpio iomask ");
-  cmd += num2Hex( ((mask & 0xf000) >> 12), false);
-  cmd += num2Hex( ((mask & 0x0f00) >> 8), false);
-  cmd += num2Hex( ((mask & 0x00f0) >> 4), false);
-  cmd += num2Hex( ((mask & 0x000f) >> 0), false);
-
-  sendCommand(cmd);
-
-  return;
-}
-
-void NLGPIO16::gpioSetIODir(int mask)
-{
-  if (mask < 0 || mask > 65535)
-    {
-      throw std::out_of_range(std::string(__FUNCTION__) +
-                              ": mask must be between 0 and 65535");
-      return;
-    }
-
-  string cmd("gpio iodir ");
-  cmd += num2Hex( ((mask & 0xf000) >> 12), false);
-  cmd += num2Hex( ((mask & 0x0f00) >> 8), false);
-  cmd += num2Hex( ((mask & 0x00f0) >> 4), false);
-  cmd += num2Hex( ((mask & 0x000f) >> 0), false);
-
-  sendCommand(cmd);
-
-  return;
-}
-
-void NLGPIO16::gpioWriteAll(int mask)
-{
-  if (mask < 0 || mask > 65535)
-    {
-      throw std::out_of_range(std::string(__FUNCTION__) +
-                              ": mask must be between 0 and 65535");
-      return;
-    }
-
-  string cmd("gpio writeall ");
-  cmd += num2Hex( ((mask & 0xf000) >> 12), false);
-  cmd += num2Hex( ((mask & 0x0f00) >> 8), false);
-  cmd += num2Hex( ((mask & 0x00f0) >> 4), false);
-  cmd += num2Hex( ((mask & 0x000f) >> 0), false);
-
-  sendCommand(cmd);
-
-  return;
-}
-
-string NLGPIO16::getVersion()
-{
-  return sendCommand("vers");
-}
-
-string NLGPIO16::getID()
-{
-  return sendCommand("id get");
-}
-
-void NLGPIO16::setID(string id)
-{
-  if (id.size() != 8)
-    {
-      throw std::out_of_range(std::string(__FUNCTION__) +
-                              ": ID must be exactly 8 characters in length");
-      return;
-    }
-
-  string cmd("id set ");
-  cmd += id;
-
-  sendCommand(cmd);
-
-  return;
-}
-
-int NLGPIO16::analogReadValue(int adc)
-{
-  // Only ports 0-6 are ADC capable
-  if (adc < 0 || adc > 6)
-    {
-      throw std::out_of_range(std::string(__FUNCTION__) +
-                              ": adc must be between 0 and 6");
-      return false;
-    }
-
-  string cmd("adc read ");
-  cmd += num2Hex(adc, true);
-
-  string resp = sendCommand(cmd);
-  if (resp.empty())
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": invalid empty response from device");
-      return false;
-    }
-
-  // c++11 stoi() would be handy...
-  return atoi(resp.c_str());
-}
-
-float NLGPIO16::analogReadVolts(int adc)
-{
-  float value = float(analogReadValue(adc));
-
-  return ( value * (ADC_AREF / float(1 << ADC_PRECISION)) );
-}
-
diff --git a/src/nlgpio16/nlgpio16.hpp b/src/nlgpio16/nlgpio16.hpp
deleted file mode 100644
index 1be892d..0000000
--- a/src/nlgpio16/nlgpio16.hpp
+++ /dev/null
@@ -1,239 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Thanks to Adafruit for supplying a google translated version of the
- * Chinese datasheet and some clues in their code.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <iostream>
-
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-
-#include <mraa/common.hpp>
-#include <mraa/uart.hpp>
-
-#define NLGPIO16_DEFAULT_UART_DEV "/dev/ttyACM0"
-
-// ADC analog ref voltage is 3.3v
-#define ADC_AREF 3.3
-
-// 10-bit precision (0-1023)
-#define ADC_PRECISION 10
-
-namespace upm {
-    /**
-     * @brief NLGPIO16 Module
-     * @defgroup nlgpio16 libupm-nlgpio16
-     * @ingroup sparkfun uart gpio ainput
-     */
-
-    /**
-     * @library nlgpio16
-     * @sensor nlgpio16
-     * @comname 16-channel USB GPIO Module
-     * @type other
-     * @man numatolabs
-     * @con uart
-     * @web http://numato.com/16-channel-usb-gpio-module-with-analog-inputs/
-     *
-     * @brief API for the NLGPIO16 16 channel USB GPIO Module
-     *
-     * The NLGPIO16 is a USB adapter providing access to 16 GPIO's, 7
-     * of which can be used as analog inputs.  The GPIO's are 3.3v
-     * only.  An external power supply can be connected to provide
-     * more current if the need arises.
-     *
-     * It is recommended to use a series resistor with the GPIO/ADC
-     * pins when interfacing with other circuits. In output mode,
-     * GPIOs can source up to 8mA (gpio8-gpio15). So no additional
-     * circuitry is needed to drive regular LEDs. A 470 Ohms series
-     * resistor is recommended for current limiting when connecting an
-     * LED to a GPIO. In contrast to GPIOs, analog inputs can read
-     * voltages at any level between 0 to 3.3V volts. It is
-     * recommended to use a series resistor to protect the input from
-     * stray voltages and spikes. The internal Analog to Digital
-     * converter supports 10 bits resolution which is adequate for
-     * most applications.
-     *
-     * Maximum IO source/sink current on GPIO 0-7 is 2mA
-     * Maximum IO source/sink current on GPIO 8-15 is 8mA
-     *
-     * @snippet nlgpio16.cxx Interesting
-     */
-
-  class NLGPIO16 {
-  public:
-
-    /**
-     * NLGPIO16 object constructor
-     *
-     * @param uart UART device path to use. Default is /dev/ttyACM0.
-     */
-    NLGPIO16(std::string uart=NLGPIO16_DEFAULT_UART_DEV);
-
-    /**
-     * NLGPIO16 object destructor
-     */
-    ~NLGPIO16();
-
-    /**
-     * Get the version of the device
-     *
-     * @return String containing device revision
-     */
-    std::string getVersion();
-
-    /**
-     * Get the device ID.  The device ID is an 8 character
-     * alpha-numeric string.
-     *
-     * @return String containing device ID
-     */
-    std::string getID();
-
-    /**
-     * Set the device ID.  The device ID is an 8 character
-     * alpha-numeric string.  The supplied ID must be exactly 8
-     * characters in length.
-     *
-     * @param id String containing a new 8 character device ID
-     */
-    void setID(std::string id);
-
-    /**
-     * Set a gpio output to the HIGH (1) state.  The gpio is
-     * automatically set as an output when this call is made,
-     * regardless of it's previous mode.
-     *
-     * @param gpio The gpio to set.  Valid values are between 0-15
-     */
-    void gpioSet(int gpio);
-
-    /**
-     * Set a gpio output to the LOW (0) state.  The gpio is
-     * automatically set as an output when this call is made,
-     * regardless of it's previous mode.
-     *
-     * @param gpio The gpio to clear.  Valid values are between 0-15
-     */
-    void gpioClear(int gpio);
-
-    /**
-     * Read the state of a gpio.  The gpio is automatically set as an
-     * input when this call is made, regardless of it's previous
-     * mode.
-     *
-     * @param gpio The gpio to read.  Valid values are between 0-15
-     * @return true if the gpio is in the HIGH state, false otherwise
-     */
-    bool gpioRead(int gpio);
-
-    /**
-     * Read the state of all gpios.  The returned integer is a bitmask
-     * of all 16 gpios, where a 0 bit means the gpio is in the LOW
-     * state, whereas a 1 bit means the gpio is in a HIGH state.
-     *
-     * @return bitmask of the state of all 16 gpios. The LSB is gpio0.
-     */
-    unsigned int gpioReadAll();
-
-    /**
-     * Set a mask for selectively updating multiple gpios with the
-     * gpioIODir() and gpioWriteAll() methods.  Each bit set in the 16
-     * bit argument (LSB = gpio0) represents whether the two previously
-     * mentioned methods will act on a given gpio or not.  A 0 in a
-     * given bit position will cause any update to that gpio via
-     * gpioIODir() and gpioWriteAll() to be ignored, while a 1 bit
-     * enables that gpio to be affected by those two methods.
-     *
-     * @param mask A bitmask of the 16 gpios affected by gpioIODir() and
-     * gpioWriteAll()
-     */
-    void gpioSetIOMask(int mask);
-
-    /**
-     * Set the driection mode (input or output) for all gpios enabled
-     * by gpioSetIOMask().  A 0 in a given bit position (LSB = gpio0)
-     * configures the gpio as an output, and a 1 bit configures the
-     * gpio as an input.  Only the gpios enabled by gpioSetMask() are
-     * affected by this call.
-     *
-     * @param mask A bitmask of the 16 gpios whose direction mode is
-     * to be set
-     */
-    void gpioSetIODir(int mask);
-
-    /**
-     * Write all enabled gpios (set via gpioSetIOMask()) to a given
-     * value.  A 1 bit (LSB = gpio0) sets the given output to HIGH, a
-     * zero sets the given output to LOW.  Only the gpios enabled by
-     * gpioSetMask() are affected by this call.
-     *
-     * @param mask The values to set for the 16 gpios (LSB = gpio0)
-     */
-    void gpioWriteAll(int mask);
-
-    /**
-     * Read the raw analog input value present at the given gpio.  The
-     * gpio is switched to analog input mode by this call, regardless of
-     * any previous mode.  The returned value will be a number between
-     * 0-1023 (10 bit resolution). Only the first 7 gpios (0-6) can be
-     * used for analog input.
-     *
-     * @param adc The gpio number to read (0-6)
-     * @return The raw integer value from the ADC (0-1023)
-     */
-    int analogReadValue(int adc);
-
-    /**
-     * Read the raw analog input value present at the given gpio and
-     * return the corresponding voltage value at the pin.  The gpio is
-     * switched to analog input mode by this call, regardless of any
-     * previous mode.  The returned value will be a number between
-     * 0.0-3.3, depending on the voltage present at the pin.  Only the
-     * first 7 gpios (0-6) can be used for analog input.
-     *
-     * @param adc The gpio number to read (0-6)
-     * @return The voltage present at the pin
-     */
-    float analogReadVolts(int adc);
-
-
-  protected:
-    mraa::Uart m_uart;
-
-    // UART helpers
-    bool dataAvailable(unsigned int millis);
-    std::string readStr(int len);
-    int writeStr(std::string data);
-
-    // does most of the work for sending commands and getting responses
-    std::string sendCommand(std::string cmd);
-
-  private:
-  };
-}
diff --git a/src/nlgpio16/nlgpio16.i b/src/nlgpio16/nlgpio16.i
deleted file mode 100644
index 00a55bb..0000000
--- a/src/nlgpio16/nlgpio16.i
+++ /dev/null
@@ -1,16 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_nlgpio16)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%include "carrays.i"
-%{
-#include "nlgpio16.hpp"
-%}
-%include "nlgpio16.hpp"
-%array_class(char, charArray);
-/* END Common SWIG syntax */
diff --git a/src/nlgpio16/nlgpio16.json b/src/nlgpio16/nlgpio16.json
deleted file mode 100644
index 4cc77eb..0000000
--- a/src/nlgpio16/nlgpio16.json
+++ /dev/null
@@ -1,58 +0,0 @@
-{
-    "Library": "nlgpio16",
-    "Description": "Numato NLGPIO16 16 Channel USB GPIO Module Library",
-    "Sensor Class": {
-        "NLGPIO16": {
-            "Name": "API for the Numato NLGPIO16 16 channel USB GPIO Module",
-            "Description": "This is the UPM Module for the Numato NLGPIO16 16 channel USB GPIO Module. The NLGPIO16 is a USB adapter providing access to 16 GPIO's, 7 of which can be used as analog inputs.  The GPIO's are 3.3v only.  An external power supply can be connected to provide more current if the need arises. It is recommended to use a series resistor with the GPIO/ADC pins when interfacing with other circuits. In output mode, GPIOs can source up to 8mA (gpio8-gpio15). So no additional circuitry is needed to drive regular LEDs. A 470 Ohms series resistor is recommended for current limiting when connecting an LED to a GPIO. In contrast to GPIOs, analog inputs can read voltages at any level between 0 to 3.3V volts. It is recommended to use a series resistor to protect the input from stray voltages and spikes. The internal Analog to Digital converter supports 10 bits resolution which is adequate for most applications.",
-            "Aliases": ["nlgpio16", "Numato 16 Channel USB GPIO Module With Analog Inputs"],
-            "Categories": ["other"],
-            "Connections": ["uart"],
-            "Project Type": ["prototyping"],
-            "Manufacturers": ["Numato Lab"],
-            "Examples": {
-                "Python": ["nlgpio16.py"],
-                "Node.js": ["nlgpio16.js"],
-                "C++": ["nlgpio16.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "usb" : 5.0
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Analog Inputs": {
-                    "unit": "inputs",
-                    "inputs": 7
-                },
-                "TTL Inputs": {
-                    "unit": "TTL 3.3V inputs",
-                    "inputs": 16
-                },
-                "ADC Resolution": {
-                    "unit": "bit",
-                    "bits": 10
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need pull up resistors"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://numato.com/16-channel-usb-gpio-module-with-analog-inputs/"],
-                "Datasheets": ["https://docs.numato.com/doc/16-channel-usb-gpio-module-with-analog-inputs/"]
-            }
-        }
-    }
-}
diff --git a/src/nmea_gps/CMakeLists.txt b/src/nmea_gps/CMakeLists.txt
deleted file mode 100644
index b3fb659..0000000
--- a/src/nmea_gps/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME nmea_gps
-    DESCRIPTION "Generic Serial Interface for GPS NMEA Devices"
-    C_HDR nmea_gps.h
-    C_SRC nmea_gps.c
-    CPP_HDR nmea_gps.hpp
-    CPP_SRC nmea_gps.cxx
-    FTI_SRC nmea_gps_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c ${CMAKE_THREAD_LIBS_INIT})
diff --git a/src/nmea_gps/nmea_gps.c b/src/nmea_gps/nmea_gps.c
deleted file mode 100644
index 2e9b902..0000000
--- a/src/nmea_gps/nmea_gps.c
+++ /dev/null
@@ -1,345 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string.h>
-#include <assert.h>
-
-#include "nmea_gps.h"
-
-#include "upm_utilities.h"
-
-// For ublox6 and compatible I2C communications (see the u-blox6
-// Receiver Description Protocol Specification datasheet for details).
-
-#define UBLOX6_I2C_BYTES_AVAIL_H                0xfd
-#define UBLOX6_I2C_BYTES_AVAIL_L                0xfe
-#define UBLOX6_I2C_BYTE_STREAM                  0xff
-
-#define UBLOX6_I2C_BYTE_NONE                    0xff // read if no data avail
-
-// static helpers for i2c reading
-static uint8_t readReg(const nmea_gps_context dev, uint8_t reg)
-{
-  assert(dev != NULL);
-  assert(dev->i2c != NULL);
-
-  int rv;
-  if ((rv = mraa_i2c_read_byte_data(dev->i2c, reg)) < 0)
-    printf("%s: mraa_i2c_read_byte_data() failed.\n", __FUNCTION__);
-
-  // This will return 0xff on errors, which is invalid NMEA data anyway.
-  return (uint8_t)rv;
-}
-
-static int readRegs(const nmea_gps_context dev, uint8_t reg,
-                    uint8_t *buffer, int len)
-{
-  assert(dev != NULL);
-  assert(dev->i2c != NULL);
-
-  int rv;
-  if ((rv = mraa_i2c_read_bytes_data(dev->i2c, reg, buffer, len)) < 0)
-    {
-      printf("%s: mraa_i2c_read_bytes_data() failed.\n", __FUNCTION__);
-    }
-
-  return rv;
-}
-
-nmea_gps_context nmea_gps_init_raw(const char* uart, unsigned int baudrate)
-{
-  // make sure MRAA is initialized
-  int mraa_rv;
-  if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-  {
-      printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-      return NULL;
-  }
-
-  nmea_gps_context dev =
-    (nmea_gps_context)malloc(sizeof(struct _nmea_gps_context));
-
-  if (!dev)
-    return NULL;
-
-  // zero out context
-  memset((void *)dev, 0, sizeof(struct _nmea_gps_context));
-
-  dev->uart = NULL;
-  dev->i2c = NULL;
-  dev->gpio_en = NULL;
-
-  // initialize the MRAA contexts
-
-  // uart, default should be 8N1
-  if (!(dev->uart = mraa_uart_init_raw(uart)))
-    {
-      printf("%s: mraa_uart_init_raw() failed.\n", __FUNCTION__);
-      nmea_gps_close(dev);
-      return NULL;
-    }
-
-  if (nmea_gps_set_baudrate(dev, baudrate))
-    {
-      printf("%s: nmea_gps_set_baudrate() failed.\n", __FUNCTION__);
-      nmea_gps_close(dev);
-      return NULL;
-    }
-
-  mraa_uart_set_flowcontrol(dev->uart, false, false);
-
-  return dev;
-}
-
-// uart init
-nmea_gps_context nmea_gps_init(unsigned int uart, unsigned int baudrate,
-                               int enable_pin)
-{
-  // make sure MRAA is initialized
-  int mraa_rv;
-  if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-  {
-      printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-      return NULL;
-  }
-
-  nmea_gps_context dev =
-    (nmea_gps_context)malloc(sizeof(struct _nmea_gps_context));
-
-  if (!dev)
-    return NULL;
-
-  // zero out context
-  memset((void *)dev, 0, sizeof(struct _nmea_gps_context));
-
-  dev->uart = NULL;
-  dev->i2c = NULL;
-  dev->gpio_en = NULL;
-
-  // initialize the MRAA contexts
-
-  // uart, default should be 8N1
-  if (!(dev->uart = mraa_uart_init(uart)))
-    {
-      printf("%s: mraa_uart_init() failed.\n", __FUNCTION__);
-      nmea_gps_close(dev);
-      return NULL;
-    }
-
-  if (nmea_gps_set_baudrate(dev, baudrate))
-    {
-      printf("%s: nmea_gps_set_baudrate() failed.\n", __FUNCTION__);
-      nmea_gps_close(dev);
-      return NULL;
-    }
-
-  mraa_uart_set_flowcontrol(dev->uart, false, false);
-
-  // now the gpio_en, if enabled
-  if (enable_pin >= 0)
-    {
-      if (!(dev->gpio_en = mraa_gpio_init(enable_pin)))
-        {
-          printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
-          nmea_gps_close(dev);
-          return NULL;
-        }
-
-      mraa_gpio_dir(dev->gpio_en, MRAA_GPIO_OUT);
-
-      // wake up
-      nmea_gps_enable(dev, true);
-    }
-
-  return dev;
-}
-
-// i2c ublox init
-nmea_gps_context nmea_gps_init_ublox_i2c(unsigned int bus, uint8_t addr)
-{
-  nmea_gps_context dev =
-    (nmea_gps_context)malloc(sizeof(struct _nmea_gps_context));
-
-  if (!dev)
-    return NULL;
-
-  // zero out context
-  memset((void *)dev, 0, sizeof(struct _nmea_gps_context));
-
-  dev->uart = NULL;
-  dev->i2c = NULL;
-  dev->gpio_en = NULL;
-
-  // initialize the MRAA contexts
-
-  if (!(dev->i2c = mraa_i2c_init(bus)))
-    {
-      printf("%s: mraa_i2c_init() failed.\n", __FUNCTION__);
-      nmea_gps_close(dev);
-      return NULL;
-    }
-
-  // This device cannot operate at more than 100Khz, so we set that
-  // here and bail if it fails.
-
-  if (mraa_i2c_frequency(dev->i2c, MRAA_I2C_STD))
-    {
-      printf("%s: mraa_i2c_frequency(MRAA_I2C_STD) failed.\n", __FUNCTION__);
-      nmea_gps_close(dev);
-      return NULL;
-    }
-
-  if (mraa_i2c_address(dev->i2c, addr))
-    {
-      printf("%s: mraa_i2c_address() failed.\n", __FUNCTION__);
-      nmea_gps_close(dev);
-      return NULL;
-    }
-
-  return dev;
-}
-
-void nmea_gps_close(nmea_gps_context dev)
-{
-  assert(dev != NULL);
-
-  // sleepy-time
-  nmea_gps_enable(dev, false);
-
-  if (dev->uart)
-    mraa_uart_stop(dev->uart);
-  if (dev->i2c)
-    mraa_i2c_stop(dev->i2c);
-  if (dev->gpio_en)
-    mraa_gpio_close(dev->gpio_en);
-
-  free(dev);
-}
-
-upm_result_t nmea_gps_enable(const nmea_gps_context dev, bool enable)
-{
-  assert(dev != NULL);
-
-  if (!dev->gpio_en)
-    return UPM_ERROR_NO_RESOURCES;
-
-  if (enable)
-    mraa_gpio_write(dev->gpio_en, 1);
-  else
-    mraa_gpio_write(dev->gpio_en, 0);
-
-  return UPM_SUCCESS;
-}
-
-int nmea_gps_read(const nmea_gps_context dev, char *buffer, size_t len)
-{
-  assert(dev != NULL);
-
-  // i2c ublox
-  if (dev->i2c)
-    {
-      int rv;
-      if ((rv = readRegs(dev, UBLOX6_I2C_BYTE_STREAM, (uint8_t *)buffer,
-                         len)) < 0)
-        return rv;
-
-      // now we need to go through the bytes returned, and stop
-      // counting "real" bytes when we hit any character with the high
-      // bit set.  The documentation implies that only a 0xff will be
-      // sent when no new data is available, but it seems sometimes
-      // the return contains 0xbf and 0xc3 bytes.  So we stop counting
-      // as soon as we see any "8 bit" character (which isn't allowed
-      // by NMEA anyway).
-      int realBytes = 0;
-      int i;
-
-      for (i=0; i<rv; i++)
-        {
-          if (buffer[i] & 0x80)
-            break;
-
-          realBytes++;
-        }
-
-      return realBytes;
-    }
-
-  // uart
-  return mraa_uart_read(dev->uart, buffer, len);
-}
-
-int nmea_gps_write(const nmea_gps_context dev, char *buffer, size_t len)
-{
-  assert(dev != NULL);
-
-  if (!dev->uart)
-    return UPM_ERROR_NO_RESOURCES;
-
-  return mraa_uart_write(dev->uart, buffer, len);
-}
-
-bool nmea_gps_data_available(const nmea_gps_context dev, unsigned int millis)
-{
-  assert(dev != NULL);
-
-  // i2c ublox
-  if (dev->i2c)
-    {
-      // here millis is ignored
-      uint8_t h, l;
-
-      h = readReg(dev, UBLOX6_I2C_BYTES_AVAIL_H);
-      l = readReg(dev, UBLOX6_I2C_BYTES_AVAIL_L);
-
-      uint16_t total = (h << 8) | l;
-      // 0 means no data available, 0xffff means read errors
-      if (total == 0x0000 || total == 0xffff)
-        return false;
-      else
-        return true;
-    }
-
-  // uart
-  if (mraa_uart_data_available(dev->uart, millis))
-    return true;
-  else
-    return false;
-}
-
-upm_result_t nmea_gps_set_baudrate(const nmea_gps_context dev,
-                                   unsigned int baudrate)
-{
-  assert(dev != NULL);
-
-  if (!dev->uart)
-    return UPM_ERROR_NO_RESOURCES;
-
-  if (mraa_uart_set_baudrate(dev->uart, baudrate))
-    {
-      printf("%s: mraa_uart_set_baudrate() failed.\n", __FUNCTION__);
-      return UPM_ERROR_OPERATION_FAILED;
-    }
-
-  return UPM_SUCCESS;
-}
diff --git a/src/nmea_gps/nmea_gps.cxx b/src/nmea_gps/nmea_gps.cxx
deleted file mode 100644
index 2e8a09c..0000000
--- a/src/nmea_gps/nmea_gps.cxx
+++ /dev/null
@@ -1,625 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <chrono>
-#include <ctime>
-#include <iomanip>
-#include <iostream>
-#include <regex>
-#include <sstream>
-#include <stdexcept>
-
-#include "upm_utilities.h"
-#include "nmea_gps.hpp"
-
-using namespace upm;
-using namespace std;
-
-NMEAGPS::NMEAGPS(unsigned int uart, unsigned int baudrate,
-                 int enable_pin) :
-  m_nmea_gps(nmea_gps_init(uart, baudrate, enable_pin)),
-    _running(false),
-    _maxQueueDepth(10),
-    _sentences_since_start(0),
-    _bytes_since_start(0),
-    _seconds_since_start(0.0)
-{
-  if (!m_nmea_gps)
-    throw std::runtime_error(string(__FUNCTION__)
-                             + ": nmea_gps_init() failed");
-}
-
-NMEAGPS::NMEAGPS(const std::string& uart, unsigned int baudrate) :
-  m_nmea_gps(nmea_gps_init_raw(uart.c_str(), baudrate)),
-    _running(false),
-    _maxQueueDepth(10),
-    _sentences_since_start(0),
-    _bytes_since_start(0),
-    _seconds_since_start(0.0)
-{
-  if (!m_nmea_gps)
-    throw std::runtime_error(string(__FUNCTION__)
-                             + ": nmea_gps_init() failed");
-}
-
-NMEAGPS::NMEAGPS(unsigned int bus, uint8_t addr) :
-  m_nmea_gps(nmea_gps_init_ublox_i2c(bus, addr)),
-    _running(false),
-    _maxQueueDepth(10),
-    _sentences_since_start(0),
-    _bytes_since_start(0),
-    _seconds_since_start(0.0)
-{
-  if (!m_nmea_gps)
-    throw std::runtime_error(string(__FUNCTION__)
-                             + ": nmea_gps_init() failed");
-}
-
-NMEAGPS::~NMEAGPS()
-{
-  _running = false;
-  if (_parser.joinable())
-    _parser.join();
-  nmea_gps_close(m_nmea_gps);
-}
-
-std::string NMEAGPS::readStr(size_t size)
-{
-  char buffer[size];
-
-  int rv;
-
-  if ((rv = nmea_gps_read(m_nmea_gps, buffer, size)) < 0)
-    throw std::runtime_error(string(__FUNCTION__)
-                             + ": nmea_gps_read() failed");
-
-  /* Keep track of bytes read */
-  _bytes_since_start += rv;
-  return buffer;
-}
-
-int NMEAGPS::writeStr(const std::string& buffer)
-{
-  int rv;
-
-  /* The write takes a char*.  This should be OK since it's known that the mraa
-   * write call does not change buffer */
-  if ((rv = nmea_gps_write(m_nmea_gps, const_cast<char*>(buffer.c_str()),
-                           buffer.size())) < 0)
-    throw std::runtime_error(string(__FUNCTION__)
-                             + ": nmea_gps_write() failed");
-
-  return rv;
-}
-
-void NMEAGPS::enable(bool enable)
-{
-  if (nmea_gps_enable(m_nmea_gps, enable))
-    throw std::runtime_error(string(__FUNCTION__)
-                             + ": nmea_gps_enable() failed");
-}
-
-void NMEAGPS::setBaudrate(unsigned int baudrate)
-{
-  if (nmea_gps_set_baudrate(m_nmea_gps, baudrate))
-    throw std::runtime_error(string(__FUNCTION__)
-                             + ": nmea_gps_baudrate() failed");
-}
-
-bool NMEAGPS::dataAvailable(unsigned int millis)
-{
-  return nmea_gps_data_available(m_nmea_gps, millis);
-}
-
-size_t NMEAGPS::getMaxQueueDepth()
-{
-    return _maxQueueDepth;
-}
-
-size_t NMEAGPS::setMaxQueueDepth(size_t depth)
-{
-    /* 1 <= depth <= 1000 */
-    if (depth > 1000) depth = 1000;
-    if (depth == 0) depth = 1;
-
-    _maxQueueDepth = depth;
-    return _maxQueueDepth;
-}
-
-/* Given a NMEA sentence, return a checksum which is calculated on
- * all characters between the '$' and the '*' */
-static uint8_t checksum(const std::string& sentence)
-{
-    uint8_t chksum = 0;
-    std::string::const_iterator it = sentence.begin();
-    /* Skip the '$' */
-    if (*it == '$') ++it;
-
-    /* Calculate the checksum on all characters */
-    while ((*it != '*') && (it != sentence.end()))
-        chksum ^= *it++;
-    return chksum;
-}
-
-/* Regex for matching NMEA GGA coordinates
- * Unfortunately these sentences appear-non standard between the devices tested
- * so it can be expected that these would need updating to match additional
- * devices.
- * GPGGA,164800.00,4532.52680,N,12257.59972,W,1,10,0.93,73.3,M,-21.3,M,,*5E
- */
-static std::regex rex_gga(R"(^\$GPGGA,(\d+\.\d+),(\d+)(\d{2}\.\d+),([NS]),(\d+)(\d{2}.\d+),([WE]),(\d+),(\d+),(\d+\.\d+),(\d+\.\d+),M,([+-]?\d+\.\d+),M,([+-]?\d+\.\d+)?,?(\S+)?[*]([A-Z0-9]{2}))");
-void NMEAGPS::_parse_gpgga(const std::string& sentence)
-{
-    /* Parse the GGA message */
-    std::smatch m;
-    if (!std::regex_search(sentence, m, rex_gga))
-        return;
-
-    gps_fix fix;
-    fix.valid = true;
-    fix.time_utc = m[1];
-    int deg = std::stoi(m[2]);
-    fix.coordinates.latitude = (deg + std::stof(m[3])/60.0) *
-        (m[4] == "N" ? 1.0 : m[4] == "S" ? -1.0 : fix.valid = false );
-    deg = std::stoi(m[5]);
-    fix.coordinates.longitude = (deg + std::stof(m[6])/60.0) *
-        (m[7] == "E" ? 1.0 : m[7] == "W" ? -1.0 : fix.valid = false );
-    fix.quality = static_cast<gps_fix_quality>(std::stoi(m[8]));
-    fix.satellites = std::stoi(m[9]);
-    fix.hdop = std::stof(m[10]);
-    fix.altitude_meters = std::stof(m[11]);
-    fix.geoid_height_meters = std::stof(m[12]);
-    fix.age_seconds = m[13].str().empty() ? 0.0 : std::stof(m[13]);
-    fix.station_id = m[14];
-    fix.chksum_match = std::stoi(m[15], nullptr, 16) == checksum(sentence);
-    fix.valid &= fix.chksum_match;
-
-    /* Throw away oldest if full, push to queue */
-    _mtx_fix.lock();
-    if (_queue_fix.size() == _maxQueueDepth)
-        _queue_fix.pop();
-    _queue_fix.push(fix);
-    _mtx_fix.unlock();
-}
-
-/* Regex for matching NMEA GSV satellite sentences
- * Unfortunately these sentences appear-non standard between the devices tested
- * so it can be expected that these would need updating to match additional
- * devices.
- *
- * Example sentence:
- *
- * $GPGSV,3,3,12,28,75,028,20,30,55,116,28,48,37,194,41,51,35,159,32*7A
- */
-static std::regex rex_gsv_hdr(R"(^\$GPGSV,(\d+),(\d+),(\d\d),)");
-static std::regex rex_gsv_sat(R"((\d{2}),(\d{2}),(\d{3}),(\d+)?,?)");
-static std::regex rex_gsv_ftr("[*]([A-Z0-9]{2})$");
-void NMEAGPS::_parse_gpgsv(const std::string& sentence)
-{
-    /* Parse the GSV header message */
-    std::smatch mhdr;
-    std::smatch mftr;
-    /* No further parsing if this message doesn't match the header
-     * or footer or the checksum is bad */
-    if (!std::regex_search(sentence, mhdr, rex_gsv_hdr) ||
-            !std::regex_search(sentence, mftr, rex_gsv_ftr) ||
-            (std::stoi(mftr[1], nullptr, 16) != checksum(sentence)))
-        return;
-
-    size_t total_svs = std::stoi(mhdr[3]);
-
-    /* Match each satellite */
-    std::sregex_iterator next(sentence.begin(), sentence.end(), rex_gsv_sat);
-    std::sregex_iterator end;
-    while (next != end)
-    {
-        std::smatch satmatches = *next++;
-
-        /* Add these satellites.  Only keep a max total_svs satellites at any
-         * one time.  The latest are the most current */
-        satellite sat = {
-            satmatches[1].str(),
-            std::stoi(satmatches[2].str()),
-            std::stoi(satmatches[3].str()),
-            satmatches[4].str().empty() ? 0 :
-            std::stoi(satmatches[4].str())
-        };
-
-        /* Add to the back of satmap, remove any matching prn */
-        _mtx_satlist.lock();
-        auto sit = _satlist.begin();
-        while(sit != _satlist.end())
-        {
-            /* Remove */
-            if ((*sit).prn == sat.prn)
-            {
-                sit = _satlist.erase(sit);
-                break;
-            }
-            ++sit;
-        }
-        /* Add satellite to the end */
-        _satlist.push_back(sat);
-
-        /* If more sats exist than current sat count, remove them */
-        while (_satlist.size() > total_svs) _satlist.pop_front();
-        _mtx_satlist.unlock();
-    }
-}
-
-/*
- * Regex for matching NMEA GLL coordinates
- * Unfortunately these sentences appear-non standard between the devices tested
- * so it can be expected that these would need updating to match additional
- * devices.
- *
- * For example, the HJ GPS compass returned GLL sentences
- * with a duplicate ,A,A at the end :(
- *      "$GPGLL,4532.55107,N,12257.68422,W,170004.20,A,A*74"
- */
-static std::regex rex_gll(R"(^\$GPGLL,(\d+)(\d{2}\.\d+),([NS]),(\d+)(\d{2}.\d+),([WE]),(\d+\.\d+)(,A)?,A[*]([A-Z0-9]{2}))");
-void NMEAGPS::_parse_gpgll(const std::string& sentence)
-{
-    /* Parse the GLL message */
-    std::smatch m;
-    if (!std::regex_search(sentence, m, rex_gll))
-        return;
-
-    gps_fix fix;
-    fix.valid = true;
-    fix.time_utc = m[7];
-    int deg = std::stoi(m[1]);
-    fix.coordinates.latitude = (deg + std::stof(m[2])/60.0) *
-        (m[3] == "N" ? 1.0 : m[3] == "S" ? -1.0 : fix.valid = false );
-    deg = std::stoi(m[4]);
-    fix.coordinates.longitude = (deg + std::stof(m[5])/60.0) *
-        (m[6] == "E" ? 1.0 : m[6] == "W" ? -1.0 : fix.valid = false );
-    fix.chksum_match = std::stoi(m[9], nullptr, 16) == checksum(sentence);
-    fix.valid &= fix.chksum_match;
-
-    /* Throw away oldest if full, push to queue */
-    _mtx_fix.lock();
-    if (_queue_fix.size() == _maxQueueDepth) _queue_fix.pop();
-    _queue_fix.push(fix);
-    _mtx_fix.unlock();
-}
-
-/*
- * Regex for matching NMEA TXT messages
- * Grab-bag of messages coming from a GPS device.  Can basically be any
- * additional information that the manufacture wants to send out.
- *
- * For example, the ublox GPS compass writes out data about itself:
- *      $GPTXT,01,01,02,u-blox ag - www.u-blox.com*50
- *      $GPTXT,01,01,02,HW  UBX-G60xx  00040007 *52
- *      $GPTXT,01,01,02,EXT CORE 7.03 (45970) Mar 17 2011 16:26:24*44
- *      $GPTXT,01,01,02,ROM BASE 6.02 (36023) Oct 15 2009 16:52:08*58
- *      $GPTXT,01,01,02,MOD LEA-6H-0*2D
- *      $GPTXT,01,01,02,ANTSUPERV=AC SD PDoS SR*20
- *      $GPTXT,01,01,02,ANTSTATUS=OK*3B
- */
-static std::regex rex_txt(R"(^\$GPTXT,(\d{2}),(\d{2}),(\d{2}),(.*)[*]([A-Z0-9]{2}))");
-void NMEAGPS::_parse_gptxt(const std::string& sentence)
-{
-    /* Parse the GLL message */
-    std::smatch m;
-    if (!std::regex_search(sentence, m, rex_txt) ||
-            (std::stoi(m[5], nullptr, 16) != checksum(sentence)) )
-        return;
-
-    /* Throw away oldest if full, push to queue */
-    _mtx_txt.lock();
-    if (_queue_txt.size() == _maxQueueDepth) _queue_txt.pop();
-    _queue_txt.push({std::stoi(m[3]), m[4]});
-    _mtx_txt.unlock();
-}
-
-void NMEAGPS::parseNMEASentence(const std::string& sentence)
-{
-    /* Needs to start with $GP... and be (at least 6 characters
-     * long to call a parser.  Otherwise skip parsing and put into
-     * raw sentence queue for debug */
-    size_t msgsz = sentence.size();
-    if ((sentence.find("$GP") == 0) &&
-            (msgsz >= 5) && (msgsz <=100))
-    {
-        auto cit = nmea_2_parser.find(sentence.substr(1, 5));
-        if (cit != nmea_2_parser.end())
-        {
-            fp parser = cit->second;
-            /* Call the corresponding parser */
-            (this->*parser)(sentence);
-        }
-
-        /* Keep track of total number of sentences */
-        _sentences_since_start++;
-    }
-
-    /* Throw away oldest if full, push to raw sentence queue */
-    _mtx_nmea_sentence.lock();
-    if (_queue_nmea_sentence.size() == _maxQueueDepth)
-        _queue_nmea_sentence.pop();
-    _queue_nmea_sentence.push(sentence);
-    _mtx_nmea_sentence.unlock();
-}
-
-void NMEAGPS::_parse_thread()
-{
-    /* NMEA 0183 max sentence length is 82 characters.  There seems to be
-     * varying specs out there.  Using 94 characters between the $GP and
-     * the checksum as a max length for a basic max length sanity check.
-     *   $GP(94 chars max)*XX length = 100 characters total
-     */
-    std::regex rex(R"((\$GP.{5,94}\*[a-fA-F0-9][a-fA-F0-9])\r\n)");
-    while (_running)
-    {
-        /* While data is available, read from the GPS.  A 5s
-         * timeout appears long, but UARTS can be slow with minimal
-         * data getting returned, possible slow UART speeds, and it's
-         * better to maximize the UART buffer.  This currently
-         * assumes whole sentences are returned each read.
-         * TODO: Handle leftover uart data
-         */
-        if (dataAvailable(5000))
-        {
-            /* Read a block */
-            std::string buf = readStr(4095);
-
-            std::sregex_iterator next(buf.begin(), buf.end(), rex);
-            std::sregex_iterator end;
-            while (next != end)
-            {
-                std::smatch matches = *next++;
-                parseNMEASentence(matches[1].str());
-            }
-
-            /* Let this thread do other stuff */
-            upm_delay_us(100);
-        }
-    }
-}
-
-static double getTimeSinceEpoch_s()
-{
-    auto now = std::chrono::system_clock::now();
-    auto now_s = std::chrono::time_point_cast<std::chrono::seconds>(now);
-    auto epoch = now_s.time_since_epoch();
-    auto value = std::chrono::duration_cast<std::chrono::milliseconds>(epoch);
-    return value.count()/1000.0;
-}
-
-void NMEAGPS::parseStart()
-{
-    /* Don't create multiple running threads */
-    if (_running) return;
-
-    /* Set running flag */
-    _running = true;
-
-    /* Reset total number of bytes/sentences parsed */
-    _sentences_since_start = 0;
-    _bytes_since_start = 0;
-
-    /* Reset the total number of seconds */
-    _seconds_since_start = getTimeSinceEpoch_s();
-
-    /* Start the thread */
-    _parser = std::thread(&NMEAGPS::_parse_thread, this);
-}
-
-void NMEAGPS::parseStop()
-{
-    /* Only stop if running */
-    if (!_running) return;
-
-    _running = false;
-    if (_parser.joinable())
-        _parser.join();
-
-    /* Zero number of bytes/sentences parsed */
-    _sentences_since_start = 0;
-}
-
-gps_fix NMEAGPS::getFix()
-{
-    gps_fix x;
-    _mtx_fix.lock();
-    if (!_queue_fix.empty())
-    {
-        /* Get a copy of the structure, pop an element */
-        x = _queue_fix.front();
-        _queue_fix.pop();
-    }
-    _mtx_fix.unlock();
-    return x;
-}
-
-std::string NMEAGPS::getRawSentence()
-{
-    std::string ret;
-    _mtx_nmea_sentence.lock();
-    if (!_queue_nmea_sentence.empty())
-    {
-        /* Get a copy of the sentence, pop an element */
-        ret = _queue_nmea_sentence.front();
-        _queue_nmea_sentence.pop();
-    }
-    _mtx_nmea_sentence.unlock();
-    return ret;
-}
-
-nmeatxt NMEAGPS::getTxtMessage()
-{
-    nmeatxt ret;
-    _mtx_txt.lock();
-    if (!_queue_txt.empty())
-    {
-        /* Get a copy of the sentence, pop an element */
-        ret = _queue_txt.front();
-        _queue_txt.pop();
-    }
-    _mtx_txt.unlock();
-    return ret;
-}
-
-size_t NMEAGPS::fixQueueSize()
-{
-    _mtx_fix.lock();
-    size_t x =_queue_fix.size();
-    _mtx_fix.unlock();
-    return x;
-}
-
-size_t NMEAGPS::rawSentenceQueueSize()
-{
-    _mtx_nmea_sentence.lock();
-    size_t x =_queue_nmea_sentence.size();
-    _mtx_nmea_sentence.unlock();
-    return x;
-}
-
-size_t NMEAGPS::txtMessageQueueSize()
-{
-    _mtx_txt.lock();
-    size_t x =_queue_txt.size();
-    _mtx_txt.unlock();
-    return x;
-}
-
-std::string gps_fix::__str__()
-{
-    std::ostringstream oss;
-    oss << "valid:" << (valid ? "T" : "F") << ", ";
-    if (time_utc.size() < 6) oss << "UNKNOWN UTC, ";
-    else
-        oss << time_utc.substr(0, 2) << ":" << time_utc.substr(2,2) << ":"
-            << time_utc.substr(4,2) << time_utc.substr(6) << " UTC, ";
-    oss << coordinates.latitude << ", " << coordinates.longitude << ", "
-        << "quality: " << static_cast<int>(quality) << ", "
-        << "sats: " << static_cast<int>(satellites) << ", "
-        << "hdop: " << hdop << ", "
-        << "alt (m): " << altitude_meters << ", "
-        << "geoid_ht (m): " << geoid_height_meters << ", "
-        << "age (s): " << age_seconds << ", "
-        << "dgps sid: " << station_id << ", "
-        << "chksum match: " << (chksum_match ? "T" : "F");
-    return oss.str();
-}
-
-std::vector<satellite> NMEAGPS::satellites()
-{
-    /* Create a new set for now */
-    _mtx_satlist.lock();
-    std::vector<satellite> sats(_satlist.begin(), _satlist.end());
-    _mtx_satlist.unlock();
-
-    return sats;
-}
-
-std::string satellite::__str__()
-{
-    std::ostringstream oss;
-    oss << "id:" << std::setw(3) << prn << ", "
-        << "elevation (d):" << std::setw(3) << elevation_deg
-        << ", " << "azimuth (d):" << std::setw(3) << azimuth_deg
-        << ", " << "snr:" << std::setw(3) << snr;
-    return oss.str();
-}
-
-std::string nmeatxt::__str__()
-{
-    /* Return an emty string */
-    if (!severity && message.empty()) return "";
-
-    std::ostringstream oss;
-    oss << "[";
-    switch (severity)
-    {
-        case 0:
-            oss << "ERROR";
-            break;
-        case 1:
-            oss << "WARNING";
-            break;
-        case 2:
-            oss << "NOTICE";
-            break;
-        case 7:
-            oss << "USER";
-            break;
-        default:
-            oss << "UNKNOWN";
-            break;
-    }
-    oss << "] " << message;
-
-    return oss.str();
-}
-
-double NMEAGPS::sentencesPerSecond()
-{
-    double now_s = getTimeSinceEpoch_s();
-    return _sentences_since_start/(now_s - _seconds_since_start);
-}
-
-double NMEAGPS::bytesPerSecond()
-{
-    double now_s = getTimeSinceEpoch_s();
-    return _bytes_since_start/(now_s - _seconds_since_start);
-}
-
-std::string NMEAGPS::__str__()
-{
-    std::ostringstream oss;
-    std::vector<satellite> sats = satellites();
-    size_t msgs = txtMessageQueueSize();
-    size_t qsz = getMaxQueueDepth();
-    oss << "NMEA GPS Instance" << std::endl
-        << "  Parsing: " << (isRunning() ? "T" : "F") << std::endl
-        << "  NMEA sentences/second: " << std::fixed << std::setprecision(2)
-        << sentencesPerSecond()
-        << "  (" << bytesPerSecond() << " bps)" << std::endl
-        << "  Available satellites: " << sats.size() << std::endl;
-    for(auto sat : sats)
-        oss << "    " << sat.__str__() << std::endl;
-    oss << "  Queues" << std::endl
-        << "    Raw sentence Q: " << std::setw(4) << rawSentenceQueueSize() << "/" << qsz << std::endl
-        << "    GPS fix      Q: " << std::setw(4) << fixQueueSize() << "/" << qsz << std::endl
-        << "    Messages     Q: " << std::setw(4) << msgs << "/" << qsz;
-    if (msgs > 0)
-    {
-        oss << std::endl << "  Messages" << std::endl;
-        for (size_t i = 0; i < msgs; i++)
-            oss << "    " << getTxtMessage().__str__() << std::endl;
-    }
-
-    return oss.str();
-}
-
-std::string coord_DD::__str__()
-{
-    std::ostringstream oss;
-    oss << latitude << ", " << longitude;
-    return oss.str();
-}
diff --git a/src/nmea_gps/nmea_gps.h b/src/nmea_gps/nmea_gps.h
deleted file mode 100644
index a01c1f7..0000000
--- a/src/nmea_gps/nmea_gps.h
+++ /dev/null
@@ -1,155 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <stdint.h>
-#include "upm.h"
-#include "mraa/uart.h"
-#include "mraa/i2c.h"
-#include "mraa/gpio.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-  /**
-   * @file nmea-gps.h
-   * @library nmea-gps
-   * @brief C API for NMEA GPS Sensors
-   *
-   * An example using the UART.
-   * @include nmea_gps.c
-   * An example using I2C.
-   * @include nmea_gps_i2c.c
-   */
-
-  /**
-   * Device context
-   */
-  typedef struct _nmea_gps_context {
-    mraa_uart_context        uart;
-    mraa_gpio_context        gpio_en;
-    mraa_i2c_context         i2c;
-  } *nmea_gps_context;
-
-  /**
-   * NMEA_GPS Initializer for generic UART operation
-   *
-   * @param uart Specify which mraa uart index to use.
-   * @param baudrate Specify the baudrate to use.  The device defaults
-   * to 9600 baud.
-   * @param enable_pin Specify the GPIO pin to use for the enable pin,
-   * -1 to not use an enable pin.
-   * @return an initialized device context on success, NULL on error.
-   */
-  nmea_gps_context nmea_gps_init(unsigned int uart, unsigned int baudrate,
-                                 int enable_pin);
-
-  /**
-   * NMEA_GPS Initializer for generic UART operation
-   *
-   * @param uart Specify which uart (fs device path) to use.
-   * @param baudrate Specify the baudrate to use.  The device defaults
-   * to 9600 baud.
-   * @return an initialized device context on success, NULL on error.
-   */
-  nmea_gps_context nmea_gps_init_raw(const char* uart, unsigned int baudrate);
-
-  /**
-   * NMEA_GPS Initializer for UBLOX I2C operation
-   *
-   * @param bus Specify which the I2C bus to use.
-   * @param addr Specify the I2C address to use.  For UBLOX devices,
-   * this typically defaults to 0x42.
-   * @return an initialized device context on success, NULL on error.
-   */
-  nmea_gps_context nmea_gps_init_ublox_i2c(unsigned int bus, uint8_t addr);
-
-  /**
-   * NMEA_GPS sensor close function
-   */
-  void nmea_gps_close(nmea_gps_context dev);
-
-  /**
-   * Read character data from the device.
-   *
-   * @param dev sensor context
-   * @param buffer The character buffer to read data into.
-   * @param len The maximum size of the buffer
-   * @return The number of bytes successfully read, or -1 on error
-   */
-  int nmea_gps_read(const nmea_gps_context dev, char *buffer, size_t len);
-
-  /**
-   * Write character data to the device.  This is only valid for a
-   * UART device.
-   *
-   * @param dev sensor context
-   * @param buffer The character buffer containing data to write.
-   * @param len The number of bytes to write.
-   * @return The number of bytes successfully written, or -1 on error.
-   */
-  int nmea_gps_write(const nmea_gps_context dev, char *buffer, size_t len);
-
-  /**
-   * Enable or disable the device.  When disabled, the device enters a
-   * low power mode and does not emit NMEA data.  It will still
-   * maintain location data however.
-   *
-   * @param dev sensor context
-   * @param enable true to enable the device, false otherwise.
-   * @return UPM result
-   */
-  upm_result_t nmea_gps_enable(const nmea_gps_context dev, bool enable);
-
-  /**
-   * Set the baudrate of the device.  By default, nmea_gps_init() will
-   * set the baudrate to 9600.  This is only valid for UART devices.
-   *
-   * @param dev sensor context
-   * @param baudrate The baud rate to set for the device.
-   * @return UPM result
-   */
-  upm_result_t nmea_gps_set_baudrate(const nmea_gps_context dev,
-                                     unsigned int baudrate);
-
-  /**
-   * Determine whether there is data available to be read.  In the
-   * case of a UART, this function will wait up to "millis"
-   * milliseconds for data to become available.  In the case of an I2C
-   * device, the millis argument is ignored and the function will
-   * return immediately, indicating whether data is available.
-   *
-   * @param dev sensor context
-   * @param millis The number of milliseconds to wait for data to
-   * become available.
-   * @return true if data is available to be read, false otherwise.
-   */
-  bool nmea_gps_data_available(const nmea_gps_context dev,
-                               unsigned int millis);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/nmea_gps/nmea_gps.hpp b/src/nmea_gps/nmea_gps.hpp
deleted file mode 100644
index b16bde8..0000000
--- a/src/nmea_gps/nmea_gps.hpp
+++ /dev/null
@@ -1,453 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <atomic>
-#include <iostream>
-#include <map>
-#include <list>
-#include <mutex>
-#include <queue>
-#include <cstdlib>
-#include <string>
-#include <thread>
-#include <unistd.h>
-#include <utility>
-#include <vector>
-
-#include "nmea_gps.h"
-
-namespace upm {
-    /**
-     * @brief Generic NMEA GPS Serial Device Library
-     * @defgroup nmea_gps libupm-nmea_gps
-     * @ingroup uart gpio gps
-     */
-
-    /**
-     * @file nmea_gps.hpp
-     * @library nmea_gps
-     * @sensor nmea_gps
-     * @comname Generic Serial Interface for GPS NMEA Devices
-     * @type gps
-     * @man dfrobot seeed
-     * @con uart gpio
-     * @altname VK2828u7 ublox LEA-6H
-     *
-     * @brief API for the NMEA GPS Module
-     *
-     * This driver was tested with a number of GPS devices that emit
-     * NMEA data via a serial interface of some sort (typically a UART).
-     *
-     * The I2C capablity was tested with a UBLOX LEA-6H based GPS shield
-     * from DFRobot.  Currently, the I2C capability is only supported
-     * for UBLOX devices (or compatibles) that conform to the
-     * specifications outlined in the u-blox6 Receiver Description
-     * Protocol Specification, Chapter 4, DDC Port.
-     *
-     * An example using the UART.
-     * @snippet nmea_gps.cxx Interesting
-     * An example using I2C.
-     * @snippet nmea_gps-i2c.cxx Interesting
-     */
-    class NMEAGPS;
-
-    /** Coordinates for lat/long as decimal degrees (DD) */
-    struct coord_DD {
-        /** Latitude in decimal degrees */
-        double latitude = 0.0;
-        /** Longitude in decimal degrees */
-        double longitude = 0.0;
-        /**
-         * Provide a string representation of this structure.
-         * @return String representing coordinates
-         */
-        std::string __str__();
-    };
-
-    /** Satellite structure definition */
-    struct satellite {
-        /** PRN pseudo-random-noise value which identifies a satellite */
-        std::string prn;
-        /** Satellite elevation angle in degrees */
-        int elevation_deg;
-        /** Satellite azimuth angle in degrees */
-        int azimuth_deg;
-        /** Satellite signal-to-noise ratio */
-        int snr;
-        /** Default constructor */
-        satellite():satellite("", 0, 0, 0){}
-        /**
-         * Create a satellite from arguments constructor
-         * @param sprn Target PRN string
-         * @param elevation Target elevation angle in degrees
-         * @param azimuth Target azimuth angle in degrees
-         * @param snr Target signal to noise ratio (usually in dB,
-         * unfortunately non-standard)
-         */
-        satellite(const std::string& sprn, int elevation, int azimuth, int snr):
-            prn(sprn), elevation_deg(elevation), azimuth_deg(azimuth), snr(snr) {}
-        /**
-         * Provide a string representation of this structure.
-         * @return String representing a satellite
-         */
-        std::string __str__();
-    };
-
-    /** Text structure definition */
-    struct nmeatxt {
-        /** Message severity */
-        int severity;
-        /** Message text */
-        std::string message;
-        /** Default constructor */
-        nmeatxt():nmeatxt(0, "") {}
-        /**
-         * Create a nmeatxt from arguments constructor
-         * @param severity Message severity
-         * @param message Target message
-         */
-        nmeatxt(int severity, const std::string& message):
-                severity(severity), message(message){}
-        /**
-         * Provide a string representation of this structure.
-         * @return String representing a nmeatxt
-         */
-        std::string __str__();
-    };
-
-    /** GPS fix quality values */
-    enum class gps_fix_quality {
-        /** No fix available or invalid */
-        no_fix = 0,
-        /** Fix - single point */
-        fix_sp,
-        /** Fix - differential point */
-        fix_dp,
-        /** Fix - pulse per second */
-        fix_pps,
-        /** Fix - real time kinematic */
-        fix_rtk,
-        /** Fix - float real time kinematic */
-        fix_frtk,
-        /** Fix - dead reckoning */
-        fix_dr,
-        /** Fix - manual input */
-        fix_manual,
-        /** Fix - simulation mode */
-        fix_simulation
-    };
-
-    /** GPS fix definition.  A GPS fix structure should only be used if
-     * valid == true
-     */
-    struct gps_fix {
-        /** Fix coordinates */
-        coord_DD coordinates;
-        /** UTC time string as HHMMSS.mS */
-        std::string time_utc = std::string("");
-        /** GPS fix signal quality */
-        gps_fix_quality quality = gps_fix_quality::no_fix;
-        /** Number of satellites in use */
-        uint8_t satellites = 0;
-        /** Horizontal dilution of precision, unitless, lower is better */
-        float hdop = 0.0;
-        /** Altitude above mean sea level in meters */
-        float altitude_meters = 0.0;
-        /** Difference between the WGS-84 earth ellipsoid and mean-sea-level */
-        float geoid_height_meters = 0.0;
-        /** Time in seconds since last differential GPS fix */
-        float age_seconds = 0.0;
-        /** Differential GPS station ID */
-        std::string station_id = std::string("");
-        /** True if this gps_fix structure is valid to use */
-        bool valid = false;
-        /** True if the checksum matched, valid is set to false on mismatch */
-        bool chksum_match = false;
-        /**
-         * Provide a string representation of this structure.
-         * @return String representing a GPS Fix
-         */
-        std::string __str__();
-    };
-
-    class NMEAGPS {
-        public:
-
-            /**
-             * NMEAGPS object constructor for a UART
-             *
-             * @param uart Specify which mraa uart index to use.
-             * @param baudrate Specify the baudrate to use.  The device defaults
-             * to 9600 baud.
-             * @param enable_pin Specify the GPIO pin to use for the enable pin,
-             * -1 to not use an enable pin.
-             */
-            NMEAGPS(unsigned int uart, unsigned int baudrate,
-                    int enable_pin);
-
-            /**
-             * NMEAGPS object constructor for a UART
-             *
-             * @param uart Specify which uart to use (fs device path)
-             * @param baudrate Specify the baudrate to use.  The device defaults
-             * to 9600 baud.
-             */
-            NMEAGPS(const std::string& uart, unsigned int baudrate);
-
-            /**
-             * NMEAGPS object constructor for a UBLOX I2C interface
-             *
-             * @param bus Specify which the I2C bus to use.
-             * @param addr Specify the I2C address to use.  For UBLOX devices,
-             * this typically defaults to 0x42.
-             */
-            NMEAGPS(unsigned int bus, uint8_t addr);
-
-            /**
-             * NMEAGPS object destructor
-             */
-            ~NMEAGPS();
-
-            /**
-             * Read character data from the device.
-             *
-             * @param size The maximum number of characters to read.
-             * @return string containing the data read.
-             */
-            std::string readStr(size_t size);
-
-            /**
-             * Write character data to the device.  This is only valid for a
-             * UART device.
-             *
-             * @param buffer The string containing the data to write.
-             * @return The number of bytes written.
-             */
-            int writeStr(const std::string& buffer);
-
-            /**
-             * Enable or disable the device.  When disabled, the device enters a
-             * low power mode and does not emit NMEA data.  It will still
-             * maintain location data however.
-             *
-             * @param enable true to enable the device, false otherwise.
-             */
-            void enable(bool enable);
-
-            /**
-             * Set the baudrate of the device.  By default, the constructor
-             * will set the baudrate to 9600.  This is only valid for UART
-             * devices.
-             *
-             * @param baudrate The baud rate to set for the device.
-             */
-            void setBaudrate(unsigned int baudrate);
-
-            /**
-             * Determine whether there is data available to be read.  In the
-             * case of a UART, this function will wait up to "millis"
-             * milliseconds for data to become available.  In the case of an I2C
-             * device, the millis argument is ignored and the function will
-             * return immediately, indicating whether data is available.
-             *
-             * @param millis The number of milliseconds to wait for data to
-             * become available.
-             * @return true if data is available to be read, false otherwise.
-             */
-            bool dataAvailable(unsigned int millis);
-
-            /**
-             * Return the current maximum queue depth.
-             * @return Maximum queue depth
-             */
-            size_t getMaxQueueDepth();
-
-            /**
-             * Set the current maximum queue depth.
-             * @param depth New target queue depth
-             *      1 <= depth <= 1000
-             * @return Actual maximum queue depth
-             */
-            size_t setMaxQueueDepth(size_t depth);
-
-            /**
-             * Start a NMEA parsing thread for reading/parsing NMEA sentences.  The
-             * thread calls the readStr method, parsing NMEA sentences as they are
-             * encountered.  Each sentence type is pushed into a corresponding queue
-             * of size
-             */
-            void parseStart();
-
-            /**
-             * Stop a running NMEA parsing thread
-             */
-            void parseStop();
-
-            /**
-             * Is the parsing thread currently running?
-             * @return True if parsing
-             */
-            bool isRunning() {return _running;}
-
-            /**
-             * Pop and return a GPS fix structure from the GPS fix queue.
-             * A GPS fix should only be used if valid is true.
-             * @return GPS fix structure
-             */
-            gps_fix getFix();
-
-            /**
-             * Pop and return a raw NMEA sentence from the NMEA sentence queue.
-             * If the queue contains no elements, an empty string is returned
-             * @return NMEA raw sentence
-             */
-            std::string getRawSentence();
-
-            /**
-             * Pop and return a message from the message queue (GPTXT sentences)
-             * If the queue contains no elements, an empty string is returned
-             * @return NMEA text message
-             */
-            nmeatxt getTxtMessage();
-
-            /**
-             * Get the number of elements in the GPS fix queue.
-             * @return Number of fixes in the GPS fix queue
-             */
-            size_t fixQueueSize();
-
-            /**
-             * Get the number of elements in the NMEA raw sentence queue.
-             * @return Number of sentences in the raw NMEA sentence queue
-             */
-            size_t rawSentenceQueueSize();
-
-            /**
-             * Get the number of messages in the NMEA message queue.
-             * @return Number of messages in the message queue
-             */
-            size_t txtMessageQueueSize();
-
-            /**
-             * Parse NMEA sentences.
-             * Raw sentence is placed into sentence queue.  Additional structures are
-             * parsed depending on sentence type
-             * @param sentence NMEA raw sentence ($...\r\n) inclusive
-             */
-            void parseNMEASentence(const std::string& sentence);
-
-            /**
-             * Return a vector of the current satellites
-             * @return Current satellites
-             */
-            std::vector<satellite> satellites();
-
-            /**
-             * Get the number of sentences parsed per second
-             * @return Sentences parsed per second
-             */
-            double sentencesPerSecond();
-
-            /**
-             * Get the throughput of the device.  This number shows a rough
-             * data-rate as well as provides a bit of debug since it will show
-             * bps even if sentences are not getting parsed correctly.
-
-             * @return Total bytes read from the device/second (bps)
-             */
-            double bytesPerSecond();
-
-            /**
-             * Provide a string representation of this class
-             * @return String representing this instance
-             */
-            std::string __str__();
-        protected:
-            /** nmeaGPS device context */
-            nmea_gps_context m_nmea_gps;
-
-        private:
-            /** Disable implicit copy and assignment operators */
-            NMEAGPS(const NMEAGPS&) = delete;
-            NMEAGPS &operator=(const NMEAGPS&) = delete;
-
-            /** Handle reading/parsing NMEA data */
-            std::thread _parser;
-
-            /** Method runs in a spawned thread for parsing NMEA sentences */
-            void _parse_thread();
-
-            /** Helper for thread syncronization */
-            std::atomic<bool> _running;
-
-            /** Parse GPGGA sentences, place in GPS fix queue */
-            void _parse_gpgga(const std::string& string);
-            /** Parse GPGSV sentences, place in satellite collection */
-            void _parse_gpgsv(const std::string& string);
-            /** Parse GPGLL sentences, place in satellite collection */
-            void _parse_gpgll(const std::string& string);
-            /** Parse GPTXT sentences, place in text collection */
-            void _parse_gptxt(const std::string& string);
-
-            /** Provide function pointer typedef for handling NMEA chunks */
-            using fp = void (NMEAGPS::*)(const std::string &);
-            /** Map of NMEA type to parser method */
-            const std::map<std::string, fp> nmea_2_parser =
-            {
-                {"GPGGA", &NMEAGPS::_parse_gpgga},
-                {"GPGSV", &NMEAGPS::_parse_gpgsv},
-                {"GPGLL", &NMEAGPS::_parse_gpgll},
-                {"GPTXT", &NMEAGPS::_parse_gptxt},
-            };
-
-            /** Raw NMEA sentence fix queue */
-            std::queue<std::string> _queue_nmea_sentence;
-            std::mutex _mtx_nmea_sentence;
-
-            /** GPS fix queue */
-            std::queue<gps_fix> _queue_fix;
-            std::mutex _mtx_fix;
-
-            /** Message queue */
-            std::queue<nmeatxt> _queue_txt;
-            std::mutex _mtx_txt;
-
-            /** Specify a queue size for parsed objects */
-            std::atomic<size_t> _maxQueueDepth;
-
-            /** Count # of parsed sentences each time thread is started */
-            std::atomic<size_t> _sentences_since_start;
-
-            /** Count # oharacters read each time thread is started */
-            std::atomic<size_t> _bytes_since_start;
-
-            /** Count # of parsed sentences each time thread is started */
-            std::atomic<double> _seconds_since_start;
-
-            /** Set of current satellites */
-            std::list<satellite> _satlist;
-            std::mutex _mtx_satlist;
-    };
-}
diff --git a/src/nmea_gps/nmea_gps.i b/src/nmea_gps/nmea_gps.i
deleted file mode 100644
index 97529ef..0000000
--- a/src/nmea_gps/nmea_gps.i
+++ /dev/null
@@ -1,28 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_nmea_gps)
-#endif
-/* END Java syntax */
-
-/* BEGIN Python syntax  ------------------------------------------------------- */
-#ifdef SWIGPYTHON
-/* Attach pythons __str__ method to a similar method in C++ */
-%feature("python:slot", "tp_str", functype="reprfunc") upm::gps_fix::__str__;
-%feature("python:slot", "tp_str", functype="reprfunc") upm::satellite::__str__;
-%feature("python:slot", "tp_str", functype="reprfunc") upm::nmeatxt::__str__;
-%feature("python:slot", "tp_str", functype="reprfunc") upm::NMEAGPS::__str__;
-%feature("python:slot", "tp_str", functype="reprfunc") upm::coord_DD::__str__;
-#endif
-/* END Python syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%include "std_vector.i"
-
-%{
-#include "nmea_gps.hpp"
-%}
-%template(satellitevec) std::vector<upm::satellite>;
-%include "nmea_gps.hpp"
-/* END Common SWIG syntax */
diff --git a/src/nmea_gps/nmea_gps.json b/src/nmea_gps/nmea_gps.json
deleted file mode 100644
index e895fde..0000000
--- a/src/nmea_gps/nmea_gps.json
+++ /dev/null
@@ -1,49 +0,0 @@
-{
-    "Library": "nmea_gps",
-    "Description": "UPM C++ API for a generic GPS serial device reporting NMEA data",
-    "Sensor Class": {
-        "NMEAGPS": {
-            "Name": "API for the NMEA GPS Module",
-            "Description": "This is the UPM Module for a generic GPS serial device reporting NMEA data. This driver was tested with a number of GPS devices that emit NMEA data via a serial interface of some sort (typically a UART). The I2C capablity was tested with a UBLOX LEA-6H based GPS shield from DFRobot.  Currently, the I2C capability is only supported for UBLOX devices (or compatibles) that conform to the specifications outlined in the u-blox6 Receiver Description Protocol Specification, Chapter 4, DDC Port.",
-            "Aliases": ["VK2828u7", "ublox", "LEA-6H"],
-            "Categories": ["gps"],
-            "Connections": ["uart", "gpio"],
-            "Project Type": ["prototyping", "industrial", "commercial"],
-            "Manufacturers": ["DFRobot", "Seeed"],
-            "Examples": {
-                "Java": ["NMEAGPS_Example.java", "NMEAGPS_I2C_Example.java"],
-                "Python": ["nmea_gps.py", "nmea_gps_i2c.py"],
-                "Node.js": ["nmea_gps.js", "nmea_gps_i2c.js"],
-                "C++": ["nmea_gps.cxx", "nmea_gps-i2c.cxx"],
-                "C": ["nmea_gps.c", "nmea_gps-i2c.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.3,
-                    "max": 5.0
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -40,
-                    "max": 85
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need pull up resistors", "Might need Grove base shield", "Might need DFRobot breakout board"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need pull up resistors", "Might need Grove base shield", "Might need DFRobot breakout board"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/grove-gps-p-959.html", "https://www.dfrobot.com/product-481.html"],
-                "Datasheets": ["https://raw.githubusercontent.com/SeeedDocument/Grove-GPS/master/res/E-1612-UB_Datasheets_Sheet.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/nmea_gps/nmea_gps_fti.c b/src/nmea_gps/nmea_gps_fti.c
deleted file mode 100644
index 86f17b1..0000000
--- a/src/nmea_gps/nmea_gps_fti.c
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "nmea_gps.h"
-#include "upm_fti.h"
-
-/** 
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_nmea_gps_name[] = "NMEA_GPS";
-const char upm_nmea_gps_description[] = "Serial GPS (providing NMEA data)";
-const upm_protocol_t upm_nmea_gps_protocol[] = {UPM_UART, UPM_GPIO};
-const upm_sensor_t upm_nmea_gps_category[] = {UPM_STREAM};
-
-// forward declarations
-const void* upm_nmea_gps_get_ft(upm_sensor_t sensor_type);
-void* upm_nmea_gps_init_name();
-void upm_nmea_gps_close(void *dev);
-int upm_nmea_gps_read(void *dev, char *buffer, int len);
-int upm_nmea_gps_write(void *dev, char *buffer, int len);
-bool upm_nmea_gps_data_available(void *dev, unsigned int timeout);
-
-static const upm_sensor_ft ft =
-{
-  .upm_sensor_init_name = &upm_nmea_gps_init_name,
-  .upm_sensor_close = &upm_nmea_gps_close,
-};
-
-static const upm_stream_ft sft =
-{
-  .upm_stream_read = upm_nmea_gps_read,
-  .upm_stream_write = upm_nmea_gps_write,
-  .upm_stream_data_available = upm_nmea_gps_data_available
-};
-
-const void* upm_nmea_gps_get_ft(upm_sensor_t sensor_type)
-{
-  switch(sensor_type)
-    {
-    case UPM_SENSOR:
-      return &ft;
-      
-    case UPM_STREAM:
-      return &sft;
-      
-    default:
-      return NULL;
-    }
-}
-
-void* upm_nmea_gps_init_name()
-{
-  return NULL;
-}
-
-void upm_nmea_gps_close(void *dev)
-{
-  nmea_gps_close((nmea_gps_context)dev);
-}
-
-int upm_nmea_gps_read(void *dev, char *buffer, int len)
-{
-  return nmea_gps_read((nmea_gps_context)dev, buffer, len);
-}
-
-int upm_nmea_gps_write(void *dev, char *buffer, int len)
-{
-  return nmea_gps_write((nmea_gps_context)dev, buffer, len);
-}
-
-bool upm_nmea_gps_data_available(void *dev, unsigned int timeout)
-{
-  return nmea_gps_data_available((nmea_gps_context)dev, timeout);
-}
diff --git a/src/nrf24l01/CMakeLists.txt b/src/nrf24l01/CMakeLists.txt
deleted file mode 100644
index 87da4bd..0000000
--- a/src/nrf24l01/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "nrf24l01")
-set (libdescription "NRF Transceiver")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/nrf24l01/Callback.hpp b/src/nrf24l01/Callback.hpp
deleted file mode 100644
index 2295215..0000000
--- a/src/nrf24l01/Callback.hpp
+++ /dev/null
@@ -1,20 +0,0 @@
-#pragma once
-
-class Callback
-{
-  public:
-    virtual ~Callback()
-    {
-    }
-    virtual void run()
-    { /* empty, overloaded in Java*/
-    }
-};
-
-
-void generic_callback (Callback* callback)
-{
-    if (callback == NULL)
-        return;
-    callback->run();
-}
diff --git a/src/nrf24l01/nrf24l01.cxx b/src/nrf24l01/nrf24l01.cxx
deleted file mode 100644
index fcbe457..0000000
--- a/src/nrf24l01/nrf24l01.cxx
+++ /dev/null
@@ -1,524 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- * BLE Beaconing based on http://dmitry.gr/index.php?r=05.Projects&proj=11.%20Bluetooth%20LE%20fakery
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <unistd.h>
-#include <string>
-#include <stdexcept>
-#include <stdlib.h>
-
-#include "nrf24l01.hpp"
-
-using namespace upm;
-
-
-NRF24L01::NRF24L01 (int cs, int ce)
-    : m_callback_obj(NULL), m_spi(0), m_csnPinCtx(cs), m_cePinCtx(ce)
-{
-    init (cs, ce);
-}
-
-void
-NRF24L01::init (int chip_select, int chip_enable) {
-    mraa::Result error = mraa::SUCCESS;
-
-    m_csn       = chip_select;
-    m_ce        = chip_enable;
-    m_channel   = 99;
-
-    error = m_csnPinCtx.dir(mraa::DIR_OUT);
-    if (error != mraa::SUCCESS) {
-        mraa::printError (error);
-    }
-
-    error = m_cePinCtx.dir(mraa::DIR_OUT);
-    if (error != mraa::SUCCESS) {
-        mraa::printError (error);
-    }
-
-    ceLow();
-    csOff ();
-}
-
-void
-NRF24L01::configure () {
-    /* Set RF channel */
-    setRegister (RF_CH, m_channel);
-
-    /* Set length of incoming payload */
-    setRegister (RX_PW_P0, m_payload);
-
-    /* Set length of incoming payload for broadcast */
-    setRegister (RX_PW_P1, m_payload);
-
-    /* Start receiver */
-    rxPowerUp ();
-    rxFlushBuffer ();
-}
-
-void
-NRF24L01::send (uint8_t * value) {
-    uint8_t status;
-    status = getStatus();
-
-    while (m_ptx) {
-        status = getStatus();
-
-        if((status & ((1 << TX_DS)  | (1 << MAX_RT)))){
-            m_ptx = 0;
-            break;
-        }
-    } // Wait until last paket is send
-
-    ceLow ();
-    txPowerUp (); // Set to transmitter mode , Power up
-    txFlushBuffer ();
-
-    csOn ();
-    m_spi.writeByte(W_TX_PAYLOAD); // Write cmd to write payload
-    writeBytes (value, NULL, m_payload); // Write payload
-    csOff ();
-    ceHigh(); // Start transmission
-
-    while (dataSending ()) { }
-
-    usleep (10000);
-}
-
-void
-NRF24L01::send () {
-    send (m_txBuffer);
-}
-
-void
-NRF24L01::setSourceAddress (uint8_t * addr) {
-    ceLow ();
-    writeRegister (RX_ADDR_P0, addr, ADDR_LEN);
-    ceHigh ();
-}
-
-void
-NRF24L01::setDestinationAddress (uint8_t * addr) {
-    writeRegister (TX_ADDR, addr, ADDR_LEN);
-}
-
-void
-NRF24L01::setBroadcastAddress (uint8_t * addr) {
-    writeRegister (RX_ADDR_P1, addr, ADDR_LEN);
-}
-
-void
-NRF24L01::setPayload (uint8_t payload) {
-    m_payload = payload;
-}
-
-void
-NRF24L01::setDataReceivedHandler (Callback *call_obj)
-{
-    m_callback_obj = call_obj;
-    dataReceivedHandler = &generic_callback;
-}
-
-bool
-NRF24L01::dataReady () {
-    /* See note in getData() function - just checking RX_DR isn't good enough */
-    uint8_t status = getStatus();
-    /* We can short circuit on RX_DR, but if it's not set, we still need
-     * to check the FIFO for any pending packets */
-    if ( status & (1 << RX_DR) ) {
-        return 1;
-    }
-
-    return !rxFifoEmpty();
-}
-
-bool
-NRF24L01::dataSending () {
-    uint8_t status;
-    if(m_ptx)   { // Sending mode.
-        status = getStatus();
-        /* if sending successful (TX_DS) or max retries exceded (MAX_RT). */
-        if((status & ((1 << TX_DS)  | (1 << MAX_RT)))){
-            rxPowerUp ();
-            return false;
-        }
-        return true;
-    }
-    return false;
-}
-
-void
-NRF24L01::getData (uint8_t * data)  {
-    csOn ();
-    /* Send cmd to read rx payload */
-    m_spi.writeByte(R_RX_PAYLOAD);
-    /* Read payload */
-    writeBytes (data, data, m_payload);
-    csOff ();
-    /* NVI: per product spec, p 67, note c:
-     * "The RX_DR IRQ is asserted by a new packet arrival event. The procedure
-     * for handling this interrupt should be: 1) read payload through SPI,
-     * 2) clear RX_DR IRQ, 3) read FIFO_STATUS to check if there are more
-     * payloads available in RX FIFO, 4) if there are more data in RX FIFO,
-     * repeat from step 1)."
-     * So if we're going to clear RX_DR here, we need to check the RX FIFO
-     * in the dataReady() function */
-    /* Reset status register */
-    setRegister (STATUS, (1<<RX_DR));
-}
-
-uint8_t
-NRF24L01::getStatus() {
-    return getRegister (STATUS);
-}
-
-bool
-NRF24L01::rxFifoEmpty () {
-    uint8_t fifoStatus = getRegister (FIFO_STATUS);
-    return (fifoStatus & (1 << RX_EMPTY));
-}
-
-void
-NRF24L01::rxPowerUp () {
-    m_ptx = 0;
-    ceLow ();
-    setRegister (CONFIG, _CONFIG | ( (1 << PWR_UP) | (1 << PRIM_RX) ));
-    ceHigh ();
-    setRegister (STATUS, (1 << TX_DS) | (1 << MAX_RT));
-}
-
-void
-NRF24L01::rxFlushBuffer () {
-    sendCommand (FLUSH_RX);
-}
-
-void
-NRF24L01::txPowerUp () {
-    m_ptx = 1;
-    setRegister (CONFIG, _CONFIG | ( (1 << PWR_UP) | (0 << PRIM_RX) ));
-}
-
-void
-NRF24L01::powerDown(){
-    ceLow ();
-    setRegister (CONFIG, _CONFIG);
-}
-
-void
-NRF24L01::setChannel (uint8_t channel) {
-    m_channel = channel;
-    setRegister (RF_CH, channel);
-}
-
-void
-NRF24L01::setPower (power_t power) {
-    uint8_t setupRegisterData = 0;
-
-    switch (power) {
-        case NRF_0DBM:
-            m_power = 3;
-        break;
-        case NRF_6DBM:
-            m_power = 2;
-        break;
-        case NRF_12DBM:
-            m_power = 1;
-        break;
-        case NRF_18DBM:
-            m_power = 0;
-        break;
-    }
-
-    setupRegisterData = getRegister (RF_SETUP); // Read current value.
-    setupRegisterData &= 0xFC; // Erase the old value;
-    setupRegisterData |= (m_power & 0x3);
-    setRegister (RF_SETUP, setupRegisterData); // Write the new value.
-}
-
-uint8_t
-NRF24L01::setSpeedRate (speed_rate_t rate) {
-    uint8_t setupRegisterData = 0;
-
-    setupRegisterData = getRegister (RF_SETUP); // Read current value.
-    setupRegisterData &= ~((1 << RF_DR_LOW) | (1 << RF_DR_HIGH));
-
-    switch (rate) {
-        case NRF_250KBPS:
-            setupRegisterData |= (1 << RF_DR_LOW) ;
-        break;
-        case NRF_1MBPS:
-        break;
-        case NRF_2MBPS:
-            setupRegisterData |= (1 << RF_DR_HIGH);
-        break;
-    }
-
-    setRegister (RF_SETUP, setupRegisterData); // Write the new value.
-
-    if (setupRegisterData == getRegister (RF_SETUP)) {
-        return 0x0;
-    }
-
-    return 0x1;
-}
-
-mraa::Result
-NRF24L01::ceHigh () {
-    return m_cePinCtx.write(HIGH);
-}
-
-mraa::Result
-NRF24L01::ceLow () {
-    return m_cePinCtx.write(LOW);
-}
-
-mraa::Result
-NRF24L01::csOn () {
-    return m_csnPinCtx.write(LOW);
-}
-
-mraa::Result
-NRF24L01::csOff () {
-    return m_csnPinCtx.write(HIGH);
-}
-
-void
-NRF24L01::pollListener() {
-    if (dataReady()) {
-        getData (m_rxBuffer);
-
-        dataReceivedHandler (m_callback_obj); /* let know that data arrived */
-    }
-}
-
-void
-NRF24L01::txFlushBuffer () {
-    sendCommand (FLUSH_TX);
-}
-
-void
-NRF24L01::setBeaconingMode () {
-    setRegister (CONFIG,     0x12); // on, no crc, int on RX/TX done
-    setRegister (EN_AA,      0x00); // no auto-acknowledge
-    setRegister (EN_RXADDR,  0x00); // no RX
-    setRegister (SETUP_AW,   0x02); // 5-byte address
-    setRegister (SETUP_RETR, 0x00); // no auto-retransmit
-    setRegister (RF_SETUP,   0x06); // 1MBps at 0dBm
-    setRegister (STATUS,     0x3E); // clear various flags
-    setRegister (DYNPD,      0x00); // no dynamic payloads
-    setRegister (FEATURE,    0x00); // no features
-    setRegister (RX_PW_P0,   32);   // always RX 32 bytes
-    setRegister (EN_RXADDR,  0x01); // RX on pipe 0
-
-    uint8_t addr[4] = { swapbits(0x8E), swapbits(0x89), swapbits(0xBE), swapbits(0xD6)};
-    writeRegister (TX_ADDR,     addr, 4);
-    writeRegister (RX_ADDR_P0,  addr, 4);
-
-    uint8_t index = 0;
-    m_bleBuffer[index++] = 0x42;        // PDU type, given address is random
-    m_bleBuffer[index++] = 0x1B;        // 6+3+2+16 = 27 bytes of payload
-
-    m_bleBuffer[index++] = BLE_MAC_0;
-    m_bleBuffer[index++] = BLE_MAC_1;
-    m_bleBuffer[index++] = BLE_MAC_2;
-    m_bleBuffer[index++] = BLE_MAC_3;
-    m_bleBuffer[index++] = BLE_MAC_4;
-    m_bleBuffer[index++] = BLE_MAC_5;
-
-    m_bleBuffer[index++] = 2;           // flags (LE-only, limited discovery mode)
-    m_bleBuffer[index++] = 0x01;
-    m_bleBuffer[index++] = 0x05;
-
-    m_bleBuffer[index++] = 17;
-    m_bleBuffer[index++] = 0x08;
-}
-
-void
-NRF24L01::sendBeaconingMsg (uint8_t * msg) {
-    const uint8_t   chRf[] = {2, 26,80};
-    const uint8_t   chLe[] = {37,38,39};
-    uint8_t         index = BLE_PAYLOAD_OFFSET + 16;
-
-    memcpy (&m_bleBuffer[BLE_PAYLOAD_OFFSET], msg, 16);
-    m_bleBuffer[index++] = 0x55;
-    m_bleBuffer[index++] = 0x55;
-    m_bleBuffer[index++] = 0x55;
-
-    uint8_t channel = 0;
-    while (++channel != sizeof(chRf)) {
-        setRegister (RF_CH,     chRf[channel]);
-        setRegister (STATUS,    0x6E);          //clear flags
-
-        blePacketEncode (m_bleBuffer, index, chLe[channel]);
-
-        sendCommand (FLUSH_TX); // Clear RX Fifo
-        sendCommand (FLUSH_RX); // Clear TX Fifo
-
-        csOn ();
-        m_spi.writeByte(W_TX_PAYLOAD);        // Write cmd to write payload
-        writeBytes (m_bleBuffer, NULL, 32);     // Write payload
-        csOff ();
-
-        setRegister (CONFIG, 0x12);             // tx on
-        ceHigh ();                              // Start transmission
-        usleep (10000);
-        ceLow ();
-    }
-}
-
-/*
- * ---------------
- * PRIVATE SECTION
- * ---------------
- */
-
-void
-NRF24L01::writeBytes (uint8_t * dataout, uint8_t * datain, uint8_t len) {
-    if(len > MAX_BUFFER){
-        len = MAX_BUFFER;
-    }
-    for (uint8_t i = 0; i < len; i++) {
-        if (datain != NULL) {
-            datain[i] = m_spi.writeByte(dataout[i]);
-        } else {
-            m_spi.writeByte(dataout[i]);
-        }
-    }
-}
-
-void
-NRF24L01::setRegister (uint8_t reg, uint8_t value) {
-    csOn ();
-    m_spi.writeByte(W_REGISTER | (REGISTER_MASK & reg));
-    m_spi.writeByte(value);
-    csOff ();
-}
-
-uint8_t
-NRF24L01::getRegister (uint8_t reg) {
-    uint8_t data = 0;
-
-    csOn ();
-    m_spi.writeByte(R_REGISTER | (REGISTER_MASK & reg));
-    data = m_spi.writeByte(data);
-    csOff ();
-
-    return data;
-}
-
-void
-NRF24L01::readRegister (uint8_t reg, uint8_t * value, uint8_t len) {
-    csOn ();
-    m_spi.writeByte(R_REGISTER | (REGISTER_MASK & reg));
-    writeBytes (value, value, len);
-    csOff ();
-}
-
-void
-NRF24L01::writeRegister (uint8_t reg, uint8_t * value, uint8_t len) {
-    csOn ();
-    m_spi.writeByte(W_REGISTER | (REGISTER_MASK & reg));
-    writeBytes (value, NULL, len);
-    csOff ();
-}
-
-void
-NRF24L01::sendCommand (uint8_t cmd) {
-    csOn ();
-    m_spi.writeByte(cmd);
-    csOff ();
-}
-
-void
-NRF24L01::bleCrc (const uint8_t* data, uint8_t len, uint8_t* dst) {
-    uint8_t v, t, d;
-    while(len--) {
-        d = *data++;
-        for(v = 0; v < 8; v++, d >>= 1){
-            t = dst[0] >> 7;
-            dst[0] <<= 1;
-            if(dst[1] & 0x80) dst[0] |= 1;
-            dst[1] <<= 1;
-            if(dst[2] & 0x80) dst[1] |= 1;
-            dst[2] <<= 1;
-
-            if(t != (d & 1)) {
-                dst[2] ^= 0x5B;
-                dst[1] ^= 0x06;
-            }
-        }
-    }
-}
-
-void
-NRF24L01::bleWhiten (uint8_t* data, uint8_t len, uint8_t whitenCoeff) {
-    uint8_t  m;
-    while(len--) {
-        for(m = 1; m; m <<= 1) {
-            if(whitenCoeff & 0x80){
-                whitenCoeff ^= 0x11;
-                (*data) ^= m;
-            }
-            whitenCoeff <<= 1;
-        }
-        data++;
-    }
-}
-
-void
-NRF24L01::blePacketEncode(uint8_t* packet, uint8_t len, uint8_t chan) {
-    if(len > MAX_BUFFER){
-        len = MAX_BUFFER;
-    }
-    
-    //length is of packet, including crc. pre-populate crc in packet with initial crc value!
-    uint8_t i, dataLen = len - 3;
-
-    bleCrc(packet, dataLen, packet + dataLen);
-    for(i = 0; i < 3; i++, dataLen++) {
-        packet[dataLen] = swapbits(packet[dataLen]);
-    }
-
-    bleWhiten(packet, len, (swapbits(chan) | 2));
-    for(i = 0; i < len; i++) {
-        packet[i] = swapbits(packet[i]);
-    }
-}
-
-uint8_t
-NRF24L01::swapbits(uint8_t a) {
-    uint8_t v = 0;
-
-    if(a & 0x80) v |= 0x01;
-    if(a & 0x40) v |= 0x02;
-    if(a & 0x20) v |= 0x04;
-    if(a & 0x10) v |= 0x08;
-    if(a & 0x08) v |= 0x10;
-    if(a & 0x04) v |= 0x20;
-    if(a & 0x02) v |= 0x40;
-    if(a & 0x01) v |= 0x80;
-
-    return v;
-}
diff --git a/src/nrf24l01/nrf24l01.hpp b/src/nrf24l01/nrf24l01.hpp
deleted file mode 100644
index 3272c43..0000000
--- a/src/nrf24l01/nrf24l01.hpp
+++ /dev/null
@@ -1,417 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- * BLE Beaconing based on http://dmitry.gr/index.php?r=05.Projects&proj=11.%20Bluetooth%20LE%20fakery
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/aio.hpp>
-#include <mraa/common.hpp>
-
-#include <mraa/gpio.hpp>
-
-#include <mraa/spi.hpp>
-#include <cstring>
-
-#include "Callback.hpp"
-
-/* Memory Map */
-#define CONFIG              0x00
-#define EN_AA               0x01
-#define EN_RXADDR           0x02
-#define SETUP_AW            0x03
-#define SETUP_RETR          0x04
-#define RF_CH               0x05
-#define RF_SETUP            0x06
-#define STATUS              0x07
-#define OBSERVE_TX          0x08
-#define CD                  0x09
-#define RX_ADDR_P0          0x0A
-#define RX_ADDR_P1          0x0B
-#define RX_ADDR_P2          0x0C
-#define RX_ADDR_P3          0x0D
-#define RX_ADDR_P4          0x0E
-#define RX_ADDR_P5          0x0F
-#define TX_ADDR             0x10
-#define RX_PW_P0            0x11
-#define RX_PW_P1            0x12
-#define RX_PW_P2            0x13
-#define RX_PW_P3            0x14
-#define RX_PW_P4            0x15
-#define RX_PW_P5            0x16
-#define FIFO_STATUS         0x17
-#define DYNPD               0x1C
-#define FEATURE             0x1D
-
-/* Bit Mnemonics */
-#define MASK_RX_DR          6
-#define MASK_TX_DS          5
-#define MASK_MAX_RT         4
-#define EN_CRC              3
-#define CRCO                2
-#define PWR_UP              1
-#define PRIM_RX             0
-#define ENAA_P5             5
-#define ENAA_P4             4
-#define ENAA_P3             3
-#define ENAA_P2             2
-#define ENAA_P1             1
-#define ENAA_P0             0
-#define ERX_P5              5
-#define ERX_P4              4
-#define ERX_P3              3
-#define ERX_P2              2
-#define ERX_P1              1
-#define ERX_P0              0
-#define AW                  0
-#define ARD                 4
-#define ARC                 0
-#define PLL_LOCK            4
-#define RF_DR               3
-#define RF_PWR              1
-#define LNA_HCURR           0
-#define RX_DR               6
-#define TX_DS               5
-#define MAX_RT              4
-#define RX_P_NO             1
-#define TX_FULL             0
-#define PLOS_CNT            4
-#define ARC_CNT             0
-#define TX_REUSE            6
-#define FIFO_FULL           5
-#define TX_EMPTY            4
-#define RX_FULL             1
-#define RX_EMPTY            0
-
-/* Instruction Mnemonics */
-#define R_REGISTER            0x00
-#define W_REGISTER            0x20
-#define REGISTER_MASK         0x1F
-#define R_RX_PAYLOAD          0x61
-#define W_TX_PAYLOAD          0xA0
-#define FLUSH_TX              0xE1
-#define FLUSH_RX              0xE2
-#define REUSE_TX_PL           0xE3
-#define NOP                   0xFF
-
-#define RF_DR_LOW   5
-#define RF_DR_HIGH  3
-#define RF_PWR_LOW  1
-#define RF_PWR_HIGH 2
-
-/* Nrf24l settings */
-#define ADDR_LEN        5
-#define _CONFIG         ((1<<EN_CRC) | (0<<CRCO) )
-
-#define MAX_BUFFER            32
-
-#define HIGH                  1
-#define LOW                    0
-
-/* BLE beaconing */
-#define BLE_MAC_0           0xEF
-#define BLE_MAC_1           0xFF
-#define BLE_MAC_2           0xC0
-#define BLE_MAC_3           0xAA
-#define BLE_MAC_4           0x18
-#define BLE_MAC_5           0x00
-
-#define BLE_PAYLOAD_OFFSET  13
-
-namespace upm {
-
-typedef void (* funcPtrVoidVoid) (Callback *);
-
-typedef enum {
-    NRF_250KBPS = 0,
-    NRF_1MBPS   = 1,
-    NRF_2MBPS   = 2,
-} speed_rate_t;
-
-typedef enum {
-    NRF_0DBM    = 0,
-    NRF_6DBM    = 1,
-    NRF_12DBM   = 2,
-    NRF_18DBM   = 3,
-} power_t;
-
-/**
- * @brief NRF24L01 Transceiver Module
- * @defgroup nrf24l01 libupm-nrf24l01
- * @ingroup seeed sparkfun spi wifi
- */
-/**
- * @library nrf24l01
- * @sensor nrf24l01
- * @comname NRF Transceiver
- * @type wifi
- * @man seeed sparkfun
- * @web http://www.seeedstudio.com/depot/nRF24L01Module-p-1394.html
- * @con spi
- *
- * id
- * @brief API for the NRF24L01 Transceiver Module
- *
- * This module defines the NRF24L01 interface for libnrf24l01
- *
- * @image html nrf24l01.jpg
- * @snippet nrf24l01-receiver.cxx Interesting
- * @snippet nrf24l01-transmitter.cxx Interesting
- * @snippet nrf24l01-broadcast.cxx Interesting
- */
-class NRF24L01 {
-    public:
-        /**
-         * Instantiates an NRF24l01 object
-         *
-         * @param cs Chip select pin
-         */
-        NRF24L01 (int cs, int ce);
-
-        /**
-         * Returns the name of the component
-         */
-        std::string name()
-        {
-            return m_name;
-        }
-
-        /**
-         * Initializes needed GPIO pins and SPI
-         *
-         * @param chipSelect Sets up the chip select pin
-         * @param chipEnable Sets up the chip enable pin
-         */
-        void    init (int chipSelect, int chipEnable);
-
-        /**
-         * Configures the NRF24L01 transceiver
-         */
-        void    configure ();
-
-        /**
-         * Sends the buffer data
-         *
-         * @param value Pointer to the buffer
-         */
-        void    send (uint8_t * value);
-
-        /**
-         * Sends the data located in an inner bufer; the user must fill the
-         * m_txBuffer buffer
-         */
-        void    send ();
-
-        /**
-         * Sets a receiving address of the device
-         *
-         * @param addr 5-byte address
-         */
-        void    setSourceAddress (uint8_t * addr);
-
-        /**
-         * Sets a recipient address. The nrfSend method sends the data buffer
-         * to this address
-         *
-         * @param addr 5-byte address
-         */
-        void    setDestinationAddress (uint8_t * addr);
-
-        /**
-         * Sets a broadcasting address
-         *
-         * @param addr 5-byte address
-         */
-        void    setBroadcastAddress (uint8_t * addr);
-
-        /**
-         * Sets the payload size
-         *
-         * @param load Size of the payload (MAX 32)
-         */
-        void    setPayload (uint8_t load);
-
-        /**
-         * Sets the handler to be called when data has been
-         * received
-         * @param call_obj Object used for callback - Java
-         */
-        void setDataReceivedHandler (Callback *call_obj);
-
-        /**
-         * Checks if the data has arrived
-         */
-        bool    dataReady ();
-
-        /**
-         * Checks if the transceiver is in the sending mode
-         */
-        bool    dataSending ();
-
-        /**
-         * Sinks all the arrived data into a provided buffer
-         *
-         * @param data Pointer to the buffer
-         */
-        void    getData (uint8_t * data);
-
-        /**
-         * Checks the transceiver state
-         */
-        uint8_t getStatus ();
-
-        /**
-         * Checks if the receive stack is empty
-         */
-        bool    rxFifoEmpty ();
-
-        /**
-         * Powers the receiver up
-         */
-        void    rxPowerUp ();
-
-        /**
-         * Flushes the receive stack
-         */
-        void    rxFlushBuffer ();
-
-        /**
-         * Powers the transmitter up
-         */
-        void    txPowerUp ();
-
-        /**
-         * Powers everything down
-         */
-        void    powerDown ();
-
-        void    setChannel (uint8_t channel);
-
-        void    setPower (power_t power);
-
-        uint8_t setSpeedRate (speed_rate_t rate);
-
-        /**
-         * Flushes the transmit stack
-         */
-        void    txFlushBuffer ();
-
-        /**
-         * Pulling the method listening for the arrived data,
-         * dataRecievedHandler is triggered if data arrives
-         */
-        void    pollListener ();
-
-        /**
-         * Sets the chip enable pin to HIGH
-         */
-        mraa::Result ceHigh ();
-
-        /**
-         * Sets the chip enable pin to LOW
-         */
-        mraa::Result ceLow ();
-
-        /**
-         * Sets the chip select pin to LOW
-         */
-        mraa::Result csOn ();
-
-        /**
-         * Sets the chip select pin to HIGH
-         */
-        mraa::Result csOff ();
-
-        /**
-         * Configures the NRF24L01 transceiver to behave as a BLE
-         * (Bluetooth Low Energy) beaconing devcie.
-         */
-        void setBeaconingMode ();
-
-        /**
-         * Beacons the provided message to BLE scanners.
-         *
-         * @param msg Beacons the provided message (max length is 16 bytes)
-         */
-        void sendBeaconingMsg (uint8_t * msg);
-
-        uint8_t     m_rxBuffer[MAX_BUFFER]; /**< Receive buffer */
-        uint8_t     m_txBuffer[MAX_BUFFER]; /**< Transmit buffer */
-        uint8_t     m_bleBuffer [32];       /**< BLE buffer */
-
-    private:
-
-        /* Callback object to use for setting the handler from Java */
-        Callback *m_callback_obj;
-
-        /** Data arrived handler */
-        funcPtrVoidVoid dataReceivedHandler;
-
-        /**
-         * Writes bytes to an SPI device
-         */
-        void    writeBytes (uint8_t * dataout, uint8_t * datain, uint8_t len);
-        /**
-         * Sets the register value on an SPI device [one byte]
-         */
-        void    setRegister (uint8_t reg, uint8_t value);
-        /**
-         * Gets the register value from an SPI device [one byte]
-         */
-        uint8_t getRegister (uint8_t reg);
-        /**
-         * Reads an array of bytes from the given starting position in NRF24L01 registers
-         */
-        void    readRegister (uint8_t reg, uint8_t * value, uint8_t len);
-        /**
-         * Writes an array of bytes into NRF24L01 registers
-         */
-        void    writeRegister (uint8_t reg, uint8_t * value, uint8_t len);
-        /**
-         * Sends a command to NRF24L01
-         */
-        void    sendCommand (uint8_t cmd);
-
-        void bleCrc (const uint8_t* data, uint8_t len, uint8_t* dst);
-
-        void bleWhiten (uint8_t* data, uint8_t len, uint8_t whitenCoeff);
-
-        void blePacketEncode(uint8_t* packet, uint8_t len, uint8_t chan);
-
-        uint8_t swapbits (uint8_t a);
-
-        mraa::Spi               m_spi;
-        uint8_t                 m_ce;
-        uint8_t                 m_csn;
-        uint8_t                 m_channel;
-        uint8_t                 m_power;
-        uint8_t                 m_ptx;
-        uint8_t                 m_payload;
-
-        mraa::Gpio              m_csnPinCtx;
-        mraa::Gpio              m_cePinCtx;
-
-        std::string             m_name;
-};
-
-}
diff --git a/src/nrf24l01/nrf24l01.i b/src/nrf24l01/nrf24l01.i
deleted file mode 100644
index 20c2dfe..0000000
--- a/src/nrf24l01/nrf24l01.i
+++ /dev/null
@@ -1,35 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-#ifndef ANDROID
-%module(directors="1") javaupm_nrf24l01
-%feature("director") Callback;
-SWIG_DIRECTOR_OWNED(Callback)
-#endif
-%include "arrays_java.i";
-%apply signed char[] {uint8_t *};
-
-JAVA_JNI_LOADLIBRARY(javaupm_nrf24l01)
-#endif
-/* END Java syntax */
-
-/* BEGIN Javascript syntax  ------------------------------------------------- */
-#ifdef SWIGJAVASCRIPT
-%include "../carrays_uint8_t.i"
-#endif
-/* END Javascript syntax */
-
-/* BEGIN Python syntax  ----------------------------------------------------- */
-#ifdef SWIGPYTHON
-%include "../carrays_uint8_t.i"
-#endif
-/* END Python syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "nrf24l01.hpp"
-%}
-%include "Callback.hpp"
-%include "nrf24l01.hpp"
-/* END Common SWIG syntax */
diff --git a/src/nrf24l01/nrf24l01.json b/src/nrf24l01/nrf24l01.json
deleted file mode 100644
index 229d385..0000000
--- a/src/nrf24l01/nrf24l01.json
+++ /dev/null
@@ -1,74 +0,0 @@
-{
-    "Library": "nrf24l01",
-    "Description": "Nordic Semiconductor NRF24L01 Transceiver library",
-    "Sensor Class": {
-        "NRF24L01": {
-            "Name": "API for the Nordic Semiconductor NRF24L01 Transceiver Module",
-            "Description": "This is the UPM Module for the Nordic Semiconductor NRF24L01 Transceiver Module. This transceiver IC operates in the 2.4GHz band and has many new features! Take all the coolness of the nRF2401A and add some extra pipelines, buffers, and an auto-retransmit feature.",
-            "Aliases": ["nrf24l01", "SparkFun Transceiver Breakout - nRF24L01+"],
-            "Categories": ["wifi"],
-            "Connections": ["spi"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["Nordic Semiconductor", "SparkFun"],
-            "Image": "nrf24l01.jpg",
-            "Examples": {
-                "Java": ["NRF24L01_receiver_Example.java", "NRF24L01_transmitter_Example.java"],
-                "C++": ["nrf24l01-broadcast.cxx", "nrf24l01-receiver.cxx", "nrf24l01-transmitter.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.3,
-                    "max": 7.0
-                },
-                "Supply Current": {
-                    "Idle Mode Supply": {
-                        "unit": "uA",
-                        "min" : 0.9,
-                        "max" : 320
-                    },
-                    "Transmit Mode Supply": {
-                        "unit": "mA",
-                        "min" : 0.12,
-                        "max" : 11.3
-                    },
-                    "Recieve Mode Supply": {
-                        "unit": "mA",
-                        "min" : 8.4,
-                        "max" : 12.3
-                    }
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Operating Frequency": {
-                    "unit": "MHz",
-                    "min": 2400,
-                    "max": 2525
-                },
-                "Data Rate": {
-                    "unit": "kbps",
-                    "min": 250,
-                    "max": 2000
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need pull up resistors"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.sparkfun.com/products/691"],
-                "Datasheets": ["file:///D:/Downloads/nRF24L01_Product_Specification_v2_0.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/nrf8001/CMakeLists.txt b/src/nrf8001/CMakeLists.txt
deleted file mode 100644
index c1c195a..0000000
--- a/src/nrf8001/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-upm_mixed_module_init (NAME nrf8001
-    DESCRIPTION "Bluetooth Low Energy (BLE) Module"
-    CPP_HDR aci.h aci_cmds.h aci_evts.h acilib_defs.h acilib.h acilib_if.h
-            acilib_types.h aci_protocol_defines.h aci_queue.h aci_setup.h
-            boards.h dtm.h hal_aci_tl.h hal_platform.h lib_aci.h uart_over_ble.h
-    CPP_SRC acilib.cpp aci_queue.cpp aci_setup.cpp hal_aci_tl.cpp lib_aci.cpp
-            nrf8001.cxx
-    REQUIRES mraa)
diff --git a/src/nrf8001/aci.h b/src/nrf8001/aci.h
deleted file mode 100644
index 33d48a6..0000000
--- a/src/nrf8001/aci.h
+++ /dev/null
@@ -1,672 +0,0 @@
-/* Copyright (c) 2014, Nordic Semiconductor ASA
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-/**
- * @file
- * @ingroup aci
- */
-
-/**
- * @defgroup aci aci
- * @{
- * @ingroup aci-lib
- *
- * @brief Definitions for the ACI (Application Control Interface)
- * @remarks
- *
- * Flow control from application mcu to nRF8001
- *
- * Data flow control:
- * The flow control is credit based and the credit is initally given using the "device started" event.
- * A credit of more than 1 is given to the application mcu.
- * These credits are used only after the "ACI Connected Event" is sent to the application mcu.
- *
- * every send_data that is used decrements the credit available by 1. This is to be tracked by the application mcu.
- * When the credit available reaches 0, the application mcu shall not send any more send_data.
- * Credit is returned using the "credit event", this returned credit can then be used to send more send_data.
- * This flow control is not necessary and not available for Broadcast.
- * The entire credit available with the external mcu expires when a "disconnected" event arrives.
- *
- * Command flow control:
- * When a command is sent over the ACI, the next command shall not be sent until after a response
- * for the command sent has arrived.
- *
- */
-
-#ifndef ACI_H__
-#define ACI_H__
-
-/**
- * Define an _aci_packed_ macro we can use in structure and enumerated type
- * declarations so that the types are sized consistently across different
- * platforms. In particular Arduino platforms using the GCC compiler and the
- * Nordic processors using the Keil compiler.
- *
- * It's really the GNU compiler platforms that need a special keyword to get
- * tight packing of values. On GNU platforms we can use the keyword:
- *     __attribute__((__packed__))
- * The thing is that while this keyword does the right thing with old and new
- * versions of the gcc (C) compiler it only works right with g++ (C++) compiler
- * versions that are version 4 or newer.
- */
-#ifdef __GNUC__
-#  if __GNUC__ >= 4
-#    define _aci_packed_ __attribute__((__packed__))
-#  else
-#    error "older g++ versions don't handle packed attribute in typedefs"
-#  endif
-#else
-#  define _aci_packed_
-#endif
-
-#include <stdint.h>
-#include <cstddef>
-#include <string.h>
-#include <unistd.h>
-
-/*
- * Define a macro that compares the size of the first parameter to the integer
- * value of the second parameter. If they do not match, a compile time error
- * for negative array size occurs (even gnu chokes on negative array size).
- *
- * This compare is done by creating a typedef for an array. No variables are
- * created and no memory is consumed with this check. The created type is
- * used for checking only and is not for use by any other code. The value
- * of 10 in this macro is arbitrary, it just needs to be a value larger
- * than one to result in a positive number for the array size.
- */
-#define ACI_ASSERT_SIZE(x,y) typedef char x ## _assert_size_t[-1+10*(sizeof(x) == (y))]
-
-/**
- * @def ACI_VERSION
- * @brief Current ACI protocol version. 0 means a device that is not yet released.
- * A numer greater than 0 refers to a specific ACI version documented and released.
- * The ACI consists of the ACI commands, ACI events and error codes.
- */
-#define ACI_VERSION   (0x02)
-/**
- * @def BTLE_DEVICE_ADDRESS_SIZE
- * @brief Size in bytes of a Bluetooth Address
- */
-#define BTLE_DEVICE_ADDRESS_SIZE                 (6)
-/**
- * @def ACI_PACKET_MAX_LEN
- * @brief Maximum length in bytes of a full ACI packet, including length prefix, opcode and payload
- */
-#define ACI_PACKET_MAX_LEN                       (32)
-/**
- * @def ACI_ECHO_DATA_MAX_LEN
- * @brief Maximum length in bytes of the echo data portion
- */
-#define ACI_ECHO_DATA_MAX_LEN                    (ACI_PACKET_MAX_LEN - 3)
-/**
- * @def ACI_DEVICE_MAX_PIPES
- * @brief Maximum number of ACI pipes
- */
-#define ACI_DEVICE_MAX_PIPES                       (62)
-/**
- * @def ACI_PIPE_TX_DATA_MAX_LEN
- * @brief Maximum length in bytes of a transmission data pipe packet
- */
-#define ACI_PIPE_TX_DATA_MAX_LEN                   (20)
-/**
- * @def ACI_PIPE_RX_DATA_MAX_LEN
- * @brief Maximum length in bytes of a reception data pipe packet
- */
-#define ACI_PIPE_RX_DATA_MAX_LEN                   (22)
-/**
- * @def ACI_GAP_DEVNAME_MAX_LEN
- * @brief Maximum length in bytes of the GAP device name
- */
-#define ACI_GAP_DEVNAME_MAX_LEN                 (20)
-/**
- * @def ACI_AD_PACKET_MAX_LEN
- * @brief Maximum length in bytes of an AD packet
- */
-#define ACI_AD_PACKET_MAX_LEN                   (31)
-/**
- * @def ACI_AD_PACKET_MAX_USER_LEN
- * @brief Maximum usable length in bytes of an AD packet
- */
-#define ACI_AD_PACKET_MAX_USER_LEN              (31 - 3)
-/**
- * @def ACI_PIPE_INVALID
- * @brief Invalid pipe number
- */
-#define ACI_PIPE_INVALID                        (0xFF)
-
-/**
- * @enum aci_pipe_store_t
- * @brief Storage type identifiers: local and remote
- */
-typedef enum
-{
-  ACI_STORE_INVALID = 0x0,
-  ACI_STORE_LOCAL= 0x01,
-  ACI_STORE_REMOTE= 0x02
-} _aci_packed_ aci_pipe_store_t;
-
-/**
- * @enum aci_pipe_type_t
- * @brief Pipe types
- */
-typedef enum
-{
-  ACI_TX_BROADCAST = 0x0001,
-  ACI_TX           = 0x0002,
-  ACI_TX_ACK       = 0x0004,
-  ACI_RX           = 0x0008,
-  ACI_RX_ACK       = 0x0010,
-  ACI_TX_REQ       = 0x0020,
-  ACI_RX_REQ       = 0x0040,
-  ACI_SET          = 0x0080,
-  ACI_TX_SIGN      = 0x0100,
-  ACI_RX_SIGN      = 0x0200,
-  ACI_RX_ACK_AUTO  = 0x0400
-} _aci_packed_ aci_pipe_type_t;
-
-ACI_ASSERT_SIZE(aci_pipe_type_t, 2);
-
-/**
- * @enum aci_bd_addr_type_t
- * @brief Bluetooth Address types
- */
-typedef enum
-{
-  ACI_BD_ADDR_TYPE_INVALID  = 0x00,
-  ACI_BD_ADDR_TYPE_PUBLIC  = 0x01,
-  ACI_BD_ADDR_TYPE_RANDOM_STATIC  = 0x02,
-  ACI_BD_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE  = 0x03,
-  ACI_BD_ADDR_TYPE_RANDOM_PRIVATE_UNRESOLVABLE  = 0x04
-} _aci_packed_ aci_bd_addr_type_t;
-
-/**
- * @enum aci_device_output_power_t
- * @brief Radio output power levels
- */
-typedef enum
-{
-  ACI_DEVICE_OUTPUT_POWER_MINUS_18DBM = 0x00, /**< Output power set to -18dBm */
-  ACI_DEVICE_OUTPUT_POWER_MINUS_12DBM = 0x01, /**< Output power set to -12dBm */
-  ACI_DEVICE_OUTPUT_POWER_MINUS_6DBM  = 0x02, /**< Output power set to -6dBm  */
-  ACI_DEVICE_OUTPUT_POWER_0DBM  = 0x03  /**< Output power set to 0dBm   - DEFAULT*/
-} _aci_packed_ aci_device_output_power_t;
-
-/**
- * @enum aci_device_operation_mode_t
- * @brief Device operation modes
- */
-typedef enum
-{
-  ACI_DEVICE_INVALID   =0x00,
-  ACI_DEVICE_TEST      =0x01,
-  ACI_DEVICE_SETUP     =0x02,
-  ACI_DEVICE_STANDBY   =0x03,
-  ACI_DEVICE_SLEEP     =0x04
-} _aci_packed_ aci_device_operation_mode_t;
-
-/**
- * @enum aci_disconnect_reason_t
- * @brief Reason enumeration for ACI_CMD_DISCONNECT
- */
-typedef enum
-{
-  ACI_REASON_TERMINATE      =0x01, /**< Use this to disconnect (does a terminate request), you need to wait for the "disconnected" event */
-  ACI_REASON_BAD_TIMING     =0x02 /*<Use this to disconnect and inform the peer, that the timing on the link is not acceptable for the device, you need to wait for the "disconnected" event */
-} _aci_packed_ aci_disconnect_reason_t;
-
-/**
- * @enum aci_test_mode_change_t
- * @brief Device test mode control
- */
-typedef enum
-{
-  ACI_TEST_MODE_DTM_UART    = 0x01,
-  ACI_TEST_MODE_DTM_ACI     = 0x02,
-  ACI_TEST_MODE_EXIT        = 0xFF
-
-} _aci_packed_ aci_test_mode_change_t;
-
-ACI_ASSERT_SIZE(aci_test_mode_change_t, 1);
-
-/**
- * @enum aci_permissions_t
- * @brief Data store permissions
- */
-typedef enum
-{
-  ACI_PERMISSIONS_NONE               =0x00,
-  ACI_PERMISSIONS_LINK_AUTHENTICATED =0x01
-} _aci_packed_ aci_permissions_t;
-
-/**
- * @def ACI_VS_UUID_128_MAX_COUNT
- * @brief Maximum number of 128-bit Vendor Specific
- *        UUIDs that can be set
- */
-#define ACI_VS_UUID_128_MAX_COUNT  64 /** #0 reserved for invalid, #1 reservered for BT SIG and a maximum of 1024 bytes (16*64) */
-
-/**
- * @struct aci_ll_conn_params_t
- * @brief Link Layer Connection Parameters
- */
-typedef struct
-{
-  uint16_t min_conn_interval;   /**< Minimum connection interval requested from peer */
-    #define ACI_PPCP_MIN_CONN_INTVL_NONE  0xFFFF
-    #define ACI_PPCP_MIN_CONN_INTVL_MIN   0x0006
-    #define ACI_PPCP_MIN_CONN_INTVL_MAX   0x0C80
-  uint16_t max_conn_interval;   /**< Maximum connection interval requested from peer */
-    #define ACI_PPCP_MAX_CONN_INTVL_NONE  0xFFFF
-    #define ACI_PPCP_MAX_CONN_INTVL_MIN   0x0006
-    #define ACI_PPCP_MAX_CONN_INTVL_MAX   0x0C80
-  uint16_t slave_latency;       /**< Connection interval latency requested from peer */
-    #define ACI_PPCP_SLAVE_LATENCY_MAX    0x03E8
-  uint16_t timeout_mult;        /**< Link supervisor timeout multiplier requested from peer */
-    #define ACI_PPCP_TIMEOUT_MULT_NONE    0xFFFF
-    #define ACI_PPCP_TIMEOUT_MULT_MIN     0x000A
-    #define ACI_PPCP_TIMEOUT_MULT_MAX     0x0C80
-} _aci_packed_ aci_ll_conn_params_t;
-
-/**
- * @def aci_gap_ppcp_t
- * @brief GAP Peripheral Preferred Connection Parameters
- */
-#define aci_gap_ppcp_t aci_ll_conn_params_t
-
-/**
- * @def ACI_AD_LOC_SVCUUID_16_MAX_COUNT
- * @brief Maximum number of 16-bit UUIDs that can
- *        be inserted in the Services tag of AD
- */
-#define ACI_AD_LOC_SVCUUID_16_MAX_COUNT  5
-
-/**
- * @def ACI_AD_LOC_SVCUUID_128_MAX_COUNT
- * @brief Maximum number of 128-bit UUIDs that can
- *        be inserted in the Services tag of AD
- */
-#define ACI_AD_LOC_SVCUUID_128_MAX_COUNT  1
-
-/**
- * @def ACI_AD_SOL_SVCUUID_16_MAX_COUNT
- * @brief Maximum number of UUIDs that can
- *        be inserted in the Solicited Services tag of AD
- */
-#define ACI_AD_SOL_SVCUUID_16_MAX_COUNT  5
-
-/**
- * @def ACI_AD_SOL_SVCUUID_128_MAX_COUNT
- * @brief Maximum number of UUIDs that can
- *        be inserted in the Solicited Services tag of AD
- */
-#define ACI_AD_SOL_SVCUUID_128_MAX_COUNT  1
-
-/**
- * @def ACI_SEC_ENCKEY_SIZE_MIN
- * @brief Minimum encryption key size
- */
-#define ACI_SEC_ENCKEY_SIZE_MIN        7
-/**
- * @def ACI_SEC_ENCKEY_SIZE_MAX
- * @brief Maximum encryption key size
- */
-#define ACI_SEC_ENCKEY_SIZE_MAX        16
-/**
- * @def ACI_CUSTOM_AD_TYPE_MAX_COUNT
- * @brief Maximum number of custom ad types
- */
-#define ACI_CUSTOM_AD_TYPE_MAX_COUNT 8
-/**
- * @def ACI_CUSTOM_AD_TYPE_MAX_DATA_LENGTH
- * @brief Maximum custom ad type data size
- */
-#define ACI_CUSTOM_AD_TYPE_MAX_DATA_LENGTH 20
-
-/**
- * @struct aci_tx_data_t
- * @brief Generic ACI transmit data structure
- */
-typedef struct
-{
-  uint8_t pipe_number;
-  uint8_t aci_data[ACI_PIPE_TX_DATA_MAX_LEN];
-} _aci_packed_ aci_tx_data_t;
-
-ACI_ASSERT_SIZE(aci_tx_data_t, ACI_PIPE_TX_DATA_MAX_LEN + 1);
-
-/**
- * @struct aci_rx_data_t
- * @brief Generic ACI receive data structure
- */
-typedef struct
-{
-  uint8_t pipe_number;
-  uint8_t aci_data[ACI_PIPE_RX_DATA_MAX_LEN];
-} _aci_packed_ aci_rx_data_t;
-
-ACI_ASSERT_SIZE(aci_rx_data_t, ACI_PIPE_RX_DATA_MAX_LEN + 1);
-
-/**
- * @enum aci_hw_error_t
- * @brief Hardware Error codes
- */
-typedef enum
-{
-  ACI_HW_ERROR_NONE     = 0x00,
-  ACI_HW_ERROR_FATAL    = 0x01
-} _aci_packed_ aci_hw_error_t;
-
-/**
- * @enum aci_clock_accuracy_t
- * @brief Bluetooth Low Energy Clock Accuracy
- */
-typedef enum
-{
-  ACI_CLOCK_ACCURACY_500_PPM = 0x00,
-  ACI_CLOCK_ACCURACY_250_PPM = 0x01,
-  ACI_CLOCK_ACCURACY_150_PPM = 0x02,
-  ACI_CLOCK_ACCURACY_100_PPM = 0x03,
-  ACI_CLOCK_ACCURACY_75_PPM  = 0x04,
-  ACI_CLOCK_ACCURACY_50_PPM  = 0x05,
-  ACI_CLOCK_ACCURACY_30_PPM  = 0x06,
-  ACI_CLOCK_ACCURACY_20_PPM  = 0x07
-} _aci_packed_ aci_clock_accuracy_t;
-
-/**
- * @enum aci_app_latency_mode_t
- * @brief Application latency modes
- */
-typedef enum
-{
-  ACI_APP_LATENCY_DISABLE = 0,
-  ACI_APP_LATENCY_ENABLE = 1
-} _aci_packed_ aci_app_latency_mode_t;
-
-/**
- * @enum gatt_format_t
- * @brief GATT format definitions
- */
-typedef enum
-{
-  ACI_GATT_FORMAT_NONE        = 0x00, /**< No characteristic format available */
-  ACI_GATT_FORMAT_BOOLEAN     = 0x01, /**< Not Supported */
-  ACI_GATT_FORMAT_2BIT        = 0x02, /**< Not Supported */
-  ACI_GATT_FORMAT_NIBBLE      = 0x03, /**< Not Supported */
-  ACI_GATT_FORMAT_UINT8       = 0x04,
-  ACI_GATT_FORMAT_UINT12      = 0x05,
-  ACI_GATT_FORMAT_UINT16      = 0x06,
-  ACI_GATT_FORMAT_UINT24      = 0x07,
-  ACI_GATT_FORMAT_UINT32      = 0x08,
-  ACI_GATT_FORMAT_UINT48      = 0x09,
-  ACI_GATT_FORMAT_UINT64      = 0x0A,
-  ACI_GATT_FORMAT_UINT128     = 0x0B,
-  ACI_GATT_FORMAT_SINT8       = 0x0C,
-  ACI_GATT_FORMAT_SINT12      = 0x0D,
-  ACI_GATT_FORMAT_SINT16      = 0x0E,
-  ACI_GATT_FORMAT_SINT24      = 0x0F,
-  ACI_GATT_FORMAT_SINT32      = 0x10,
-  ACI_GATT_FORMAT_SINT48      = 0x11,
-  ACI_GATT_FORMAT_SINT64      = 0x12,
-  ACI_GATT_FORMAT_SINT128     = 0x13,
-  ACI_GATT_FORMAT_FLOAT32     = 0x14,
-  ACI_GATT_FORMAT_FLOAT64     = 0x15,
-  ACI_GATT_FORMAT_SFLOAT      = 0x16,
-  ACI_GATT_FORMAT_FLOAT       = 0x17,
-  ACI_GATT_FORMAT_DUINT16     = 0x18,
-  ACI_GATT_FORMAT_UTF8S       = 0x19,
-  ACI_GATT_FORMAT_UTF16S      = 0x1A,
-  ACI_GATT_FORMAT_STRUCT      = 0x1B
-} _aci_packed_ aci_gatt_format_t;
-
-/**
- * @brief GATT Bluetooth namespace
- */
-typedef enum
-{
-  ACI_GATT_NAMESPACE_INVALID  = 0x00,
-  ACI_GATT_NAMESPACE_BTSIG    = 0x01 /**< Bluetooth SIG */
-} _aci_packed_ aci_gatt_namespace_t;
-
-/**
- * @brief Security key types
- */
-typedef enum
-{
-  ACI_KEY_TYPE_INVALID  = 0x00,
-  ACI_KEY_TYPE_PASSKEY  = 0x01
-} _aci_packed_ aci_key_type_t;
-
-/**
- * @enum aci_bond_status_code_t
- * @brief Bond status code
- */
-typedef enum
-{
- /**
-  * Bonding succeeded
-  */
-  ACI_BOND_STATUS_SUCCESS                             = 0x00,
- /**
-  * Bonding failed
-  */
-  ACI_BOND_STATUS_FAILED                              = 0x01,
- /**
-  * Bonding error: Timeout can occur when link termination is unexpected or did not get connected OR SMP timer expired
-  */
-  ACI_BOND_STATUS_FAILED_TIMED_OUT                    = 0x02,
- /**
-  * Bonding error: Passkey entry failed
-  */
-  ACI_BOND_STATUS_FAILED_PASSKEY_ENTRY_FAILED        = 0x81,
- /**
-  * Bonding error: OOB unavailable
-  */
-  ACI_BOND_STATUS_FAILED_OOB_UNAVAILABLE             = 0x82,
- /**
-  * Bonding error: Authentication request failed
-  */
-  ACI_BOND_STATUS_FAILED_AUTHENTICATION_REQ          = 0x83,
- /**
-  * Bonding error: Confirm value failed
-  */
-  ACI_BOND_STATUS_FAILED_CONFIRM_VALUE               = 0x84,
- /**
-  * Bonding error: Pairing unsupported
-  */
-  ACI_BOND_STATUS_FAILED_PAIRING_UNSUPPORTED         = 0x85,
- /**
-  * Bonding error: Invalid encryption key size
-  */
-  ACI_BOND_STATUS_FAILED_ENCRYPTION_KEY_SIZE         = 0x86,
- /**
-  * Bonding error: Unsupported SMP command
-  */
-  ACI_BOND_STATUS_FAILED_SMP_CMD_UNSUPPORTED         = 0x87,
- /**
-  * Bonding error: Unspecified reason
-  */
-  ACI_BOND_STATUS_FAILED_UNSPECIFIED_REASON          = 0x88,
- /**
-  * Bonding error: Too many attempts
-  */
-  ACI_BOND_STATUS_FAILED_REPEATED_ATTEMPTS           = 0x89,
- /**
-  * Bonding error: Invalid parameters
-  */
-  ACI_BOND_STATUS_FAILED_INVALID_PARAMETERS          = 0x8A
-
-} _aci_packed_ aci_bond_status_code_t;
-
-ACI_ASSERT_SIZE(aci_bond_status_code_t, 1);
-
-/**
- * @enum aci_bond_status_source_t
- * @brief Source of a bond status code
- */
-typedef enum
-{
-  ACI_BOND_STATUS_SOURCE_INVALID                  = 0x00,
-  ACI_BOND_STATUS_SOURCE_LOCAL                    = 0x01,
-  ACI_BOND_STATUS_SOURCE_REMOTE                   = 0x02
-
-} _aci_packed_ aci_bond_status_source_t;
-
-/**
- * @enum aci_status_code_t
- * @brief ACI status codes
- */
-typedef enum
-{
- /**
-  * Success
-  */
-  ACI_STATUS_SUCCESS                                        = 0x00,
- /**
-  * Transaction continuation status
-  */
-  ACI_STATUS_TRANSACTION_CONTINUE                           = 0x01,
- /**
-  * Transaction completed
-  */
-  ACI_STATUS_TRANSACTION_COMPLETE                           = 0x02,
- /**
-  * Extended status, further checks needed
-  */
-  ACI_STATUS_EXTENDED                                       = 0x03,
- /**
-  * Unknown error.
-  */
-  ACI_STATUS_ERROR_UNKNOWN                                  = 0x80,
- /**
-  * Internal error.
-  */
-  ACI_STATUS_ERROR_INTERNAL                                 = 0x81,
- /**
-  * Unknown command
-  */
-  ACI_STATUS_ERROR_CMD_UNKNOWN                              = 0x82,
- /**
-  * Command invalid in the current device state
-  */
-  ACI_STATUS_ERROR_DEVICE_STATE_INVALID                     = 0x83,
- /**
-  * Invalid length
-  */
-  ACI_STATUS_ERROR_INVALID_LENGTH                           = 0x84,
- /**
-  * Invalid input parameters
-  */
-  ACI_STATUS_ERROR_INVALID_PARAMETER                        = 0x85,
- /**
-  * Busy
-  */
-  ACI_STATUS_ERROR_BUSY                                     = 0x86,
- /**
-  * Invalid data format or contents
-  */
-  ACI_STATUS_ERROR_INVALID_DATA                             = 0x87,
- /**
-  * CRC mismatch
-  */
-  ACI_STATUS_ERROR_CRC_MISMATCH                             = 0x88,
- /**
-  * Unsupported setup format
-  */
-  ACI_STATUS_ERROR_UNSUPPORTED_SETUP_FORMAT                 = 0x89,
- /**
-  * Invalid sequence number during a write dynamic data sequence
-  */
-  ACI_STATUS_ERROR_INVALID_SEQ_NO                           = 0x8A,
- /**
-  * Setup data is locked and cannot be modified
-  */
-  ACI_STATUS_ERROR_SETUP_LOCKED                             = 0x8B,
- /**
-  * Setup error due to lock verification failure
-  */
-  ACI_STATUS_ERROR_LOCK_FAILED                              = 0x8C,
- /**
-  * Bond required: Local Pipes need bonded/trusted peer
-  */
-  ACI_STATUS_ERROR_BOND_REQUIRED                            = 0x8D,
- /**
-  * Command rejected as a transaction is still pending
-  */
-  ACI_STATUS_ERROR_REJECTED                                 = 0x8E,
-  /**
-  * Pipe Error Event : Data size exceeds size specified for pipe : Transmit failed
-  */
-  ACI_STATUS_ERROR_DATA_SIZE                                = 0x8F,
- /**
-  * Pipe Error Event : Invalid pipe
-  */
-  ACI_STATUS_ERROR_PIPE_INVALID                             = 0x90,
- /**
-  * Pipe Error Event : Credit not available
-  */
-  ACI_STATUS_ERROR_CREDIT_NOT_AVAILABLE                     = 0x91,
- /**
-  * Pipe Error Event : Peer device has sent an error on an pipe operation on the remote characteristic
-  */
-  ACI_STATUS_ERROR_PEER_ATT_ERROR                           = 0x92,
- /**
-  * Connection was not established before the BTLE advertising was stopped
-  */
-  ACI_STATUS_ERROR_ADVT_TIMEOUT                             = 0x93,
- /**
-  * Peer has triggered a Security Manager Protocol Error
-  */
-  ACI_STATUS_ERROR_PEER_SMP_ERROR                           = 0x94,
- /**
-  * Pipe Error Event : Pipe type invalid for the selected operation
-  */
-  ACI_STATUS_ERROR_PIPE_TYPE_INVALID                        = 0x95,
- /**
-  * Pipe Error Event : Pipe state invalid for the selected operation
-  */
-  ACI_STATUS_ERROR_PIPE_STATE_INVALID                       = 0x96,
- /**
-  * Invalid key size provided
-  */
-  ACI_STATUS_ERROR_INVALID_KEY_SIZE                         = 0x97,
- /**
-  * Invalid key data provided
-  */
-  ACI_STATUS_ERROR_INVALID_KEY_DATA                         = 0x98,
- /**
-  * Reserved range start
-  */
-  ACI_STATUS_RESERVED_START                                 = 0xF0,
- /**
-  * Reserved range end
-  */
-  ACI_STATUS_RESERVED_END                                   = 0xFF
-
-} _aci_packed_ aci_status_code_t;
-
-ACI_ASSERT_SIZE(aci_status_code_t, 1);
-
-/**
- * @}
- */
-
-#endif // ACI_H__
diff --git a/src/nrf8001/aci_cmds.h b/src/nrf8001/aci_cmds.h
deleted file mode 100644
index 62d49c0..0000000
--- a/src/nrf8001/aci_cmds.h
+++ /dev/null
@@ -1,433 +0,0 @@
-/* Copyright (c) 2014, Nordic Semiconductor ASA
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-/**
- * @file
- * @ingroup aci
- * @brief Definitions for the ACI (Application Control Interface) commands
- * @remarks
- *
- */
-
-#ifndef ACI_CMDS_H__
-#define ACI_CMDS_H__
-
-#include "aci.h"
-
-/**
- * @enum aci_cmd_opcode_t
- * @brief ACI command opcodes
- */
-typedef enum
-{
- /**
-  * Enter test mode
-  */
-  ACI_CMD_TEST                    = 0x01,
- /**
-  * Echo (loopback) test command
-  */
-  ACI_CMD_ECHO                    = 0x02,
- /**
-  * Send a BTLE DTM command to the radio
-  */
-  ACI_CMD_DTM_CMD                 = 0x03,
-  /**
-  * Put the device to sleep
-  */
-  ACI_CMD_SLEEP                   = 0x04,
- /**
-  * Wakeup the device from deep sleep
-  */
-  ACI_CMD_WAKEUP                  = 0x05,
- /**
-  * Replace the contents of the internal database with
-  * user provided data
-  */
-  ACI_CMD_SETUP                   = 0x06,
- /**
-  * Read the portions of memory required to be restored after a power cycle
-  */
-  ACI_CMD_READ_DYNAMIC_DATA       = 0x07,
- /**
-  * Write back the data retrieved using ACI_CMD_READ_DYNAMIC_DATA
-  */
-  ACI_CMD_WRITE_DYNAMIC_DATA      = 0x08,
-  /**
-  * Retrieve the device's version information
-  */
-  ACI_CMD_GET_DEVICE_VERSION      = 0x09,
- /**
-  * Request the Bluetooth address and its type
-  */
-  ACI_CMD_GET_DEVICE_ADDRESS      = 0x0A,
-  /**
-  * Request the battery level measured by nRF8001
-  */
-  ACI_CMD_GET_BATTERY_LEVEL       = 0x0B,
- /**
-  * Request the temperature value measured by nRF8001
-  */
-  ACI_CMD_GET_TEMPERATURE         = 0x0C,
- /**
-  * Write to the local Attribute Database
-  */
-  ACI_CMD_SET_LOCAL_DATA          = 0x0D,
- /**
-  * Reset the baseband and radio and go back to idle
-  */
-  ACI_CMD_RADIO_RESET          = 0x0E,
- /**
-  * Start advertising and wait for a master connection
-  */
-  ACI_CMD_CONNECT                 = 0x0F,
- /**
-  * Start advertising and wait for a master connection
-  */
-  ACI_CMD_BOND                    = 0x10,
- /**
-  * Start advertising and wait for a master connection
-  */
-  ACI_CMD_DISCONNECT              = 0x11,
- /**
-  * Throttles the Radio transmit power
-  */
-  ACI_CMD_SET_TX_POWER            = 0x12,
- /**
-  * Trigger a connection parameter update
-  */
-  ACI_CMD_CHANGE_TIMING           = 0x13,
- /**
-  * Open a remote pipe for data reception
-  */
-  ACI_CMD_OPEN_REMOTE_PIPE        = 0x14,
- /**
-  * Transmit data over an open pipe
-  */
-  ACI_CMD_SEND_DATA               = 0x15,
- /**
-  * Send an acknowledgment of received data
-  */
-  ACI_CMD_SEND_DATA_ACK           = 0x16,
- /**
-  * Request data over an open pipe
-  */
-  ACI_CMD_REQUEST_DATA            = 0x17,
- /**
-  * NACK a data reception
-  */
-  ACI_CMD_SEND_DATA_NACK          = 0x18,
- /**
-  * Set application latency
-  */
-  ACI_CMD_SET_APP_LATENCY         = 0x19,
- /**
-  * Set a security key
-  */
-  ACI_CMD_SET_KEY                 = 0x1A,
- /**
-  * Open Advertising Pipes
-  */
-  ACI_CMD_OPEN_ADV_PIPE           = 0x1B,
- /**
-  * Start non-connectable advertising
-  */
-  ACI_CMD_BROADCAST               = 0x1C,
- /**
-  * Start a security request in bonding mode
-  */
-  ACI_CMD_BOND_SECURITY_REQUEST   = 0x1D,
- /**
-  * Start Directed advertising towards a Bonded Peer
-  */
-  ACI_CMD_CONNECT_DIRECT          = 0x1E,
- /**
-  * Close a previously opened remote pipe
-  */
-  ACI_CMD_CLOSE_REMOTE_PIPE       = 0x1F,
- /**
-  * Invalid ACI command opcode
-  */
-  ACI_CMD_INVALID                 = 0xFF
-
-} _aci_packed_ aci_cmd_opcode_t;
-
-ACI_ASSERT_SIZE(aci_cmd_opcode_t, 1);
-
-/**
- * @struct aci_cmd_params_test_t
- * @brief  Structure for the ACI_CMD_TEST ACI command parameters
- */
-typedef struct
-{
-  aci_test_mode_change_t test_mode_change; /**< enum aci_test_mode_change_t */
-} _aci_packed_ aci_cmd_params_test_t;
-
-ACI_ASSERT_SIZE(aci_cmd_params_test_t, 1);
-
-/**
- * @struct aci_cmd_params_echo_t
- * @brief  Structure for the ACI_CMD_ECHO ACI command parameters
- */
-typedef struct
-{
-  uint8_t echo_data[ACI_ECHO_DATA_MAX_LEN];
-} _aci_packed_ aci_cmd_params_echo_t;
-
-ACI_ASSERT_SIZE(aci_cmd_params_echo_t, ACI_ECHO_DATA_MAX_LEN);
-
-/**
- * @struct aci_cmd_params_dtm_cmd_t
- * @brief  Structure for the ACI_CMD_DTM_CMD ACI command parameters
- */
-typedef struct
-{
-  uint8_t                 cmd_msb;
-  uint8_t                 cmd_lsb;
-} _aci_packed_ aci_cmd_params_dtm_cmd_t;
-
-/**
- * @struct aci_cmd_params_setup_t
- * @brief  Structure for the ACI_CMD_SETUP ACI command parameters
- */
-typedef struct
-{
-  uint8_t                 setup_data[1];
-} _aci_packed_ aci_cmd_params_setup_t;
-
-ACI_ASSERT_SIZE(aci_cmd_params_setup_t, 1);
-
-/**
- * @struct aci_cmd_params_write_dynamic_data_t
- * @brief  Structure for the ACI_CMD_WRITE_DYNAMIC_DATA ACI command parameters
- * @note Dynamic data chunk size in this command is defined to go up to ACI_PACKET_MAX_LEN - 3
- */
-typedef struct
-{
-  uint8_t                 seq_no;
-  uint8_t                 dynamic_data[1];
-} _aci_packed_ aci_cmd_params_write_dynamic_data_t;
-
-/**
- * @define aci_cmd_params_set_local_data_t
- * @brief  Structure for the ACI_CMD_SET_LOCAL_DATA ACI command parameters
- */
-typedef struct
-{
-  aci_tx_data_t tx_data;
-} _aci_packed_ aci_cmd_params_set_local_data_t;
-
-/**
- * @struct aci_cmd_params_connect_t
- * @brief  Structure for the ACI_CMD_CONNECT ACI command parameters
- */
-typedef struct
-{
-  uint16_t        timeout;  /**< 0x0000 (no timeout) to 0x3FFF */
-  uint16_t        adv_interval;     /**< 16 bits of advertising interval for general discovery */
-} _aci_packed_ aci_cmd_params_connect_t;
-
-ACI_ASSERT_SIZE(aci_cmd_params_connect_t, 4);
-
-/**
- * @define aci_cmd_params_bond_t
- * @brief  Structure for the ACI_CMD_BOND ACI command parameters
- */
-typedef struct
-{
-  uint16_t        timeout;  /**< 0x0000 (no timeout) to 0x3FFF */
-  uint16_t        adv_interval;     /**< 16 bits of advertising interval for general discovery */
-} _aci_packed_ aci_cmd_params_bond_t;
-
-ACI_ASSERT_SIZE(aci_cmd_params_bond_t, 4);
-
-/**
- * @struct aci_cmd_params_disconnect_t
- * @brief  Structure for the ACI_CMD_DISCONNECT ACI command parameters
- */
-typedef struct
-{
-  aci_disconnect_reason_t         reason; /**< enum aci_disconnect_reason_t */
-} _aci_packed_ aci_cmd_params_disconnect_t;
-
-ACI_ASSERT_SIZE(aci_cmd_params_disconnect_t, 1);
-
-/**
- * @struct aci_cmd_params_set_tx_power_t
- * @brief  Structure for the ACI_CMD_SET_TX_POWER ACI command parameters
- */
-typedef struct
-{
-  aci_device_output_power_t   device_power; /**< enum aci_device_output_power_t */
-} _aci_packed_ aci_cmd_params_set_tx_power_t;
-
-ACI_ASSERT_SIZE(aci_cmd_params_set_tx_power_t, 1);
-/**
- * @struct aci_cmd_params_change_timing_t
- * @brief  Structure for the ACI_CMD_CHANGE_TIMING ACI command parameters
- */
-typedef struct
-{
-  aci_ll_conn_params_t    conn_params;
-} _aci_packed_ aci_cmd_params_change_timing_t;
-
-ACI_ASSERT_SIZE(aci_cmd_params_change_timing_t, 8);
-
-/**
- * @struct aci_cmd_params_open_remote_pipe_t
- * @brief  Structure for the ACI_CMD_OPEN_REMOTE_PIPE ACI command parameters
- */
-typedef struct
-{
-  uint8_t pipe_number;
-} _aci_packed_ aci_cmd_params_open_remote_pipe_t;
-
-/**
- * @struct aci_cmd_params_send_data_t
- * @brief  Structure for the ACI_CMD_SEND_DATA ACI command parameters
- */
-typedef struct
-{
-  aci_tx_data_t tx_data;
-} _aci_packed_ aci_cmd_params_send_data_t;
-
-/**
- * @define aci_cmd_params_send_data_ack_t
- * @brief  Structure for the ACI_CMD_SEND_DATA_ACK ACI command parameters
- */
-typedef struct
-{
-  uint8_t pipe_number;
-} _aci_packed_ aci_cmd_params_send_data_ack_t;
-
-/**
- * @struct aci_cmd_params_send_data_t
- * @brief  Structure for the ACI_CMD_SEND_DATA ACI command parameters
- */
-typedef struct
-{
-  uint8_t pipe_number;
-} _aci_packed_ aci_cmd_params_request_data_t;
-
-/**
- * @define aci_cmd_params_send_data_nack_t
- * @brief  Structure for the ACI_CMD_SEND_DATA_NACK ACI command parameters
- */
-typedef struct
-{
-  uint8_t pipe_number;
-  uint8_t error_code;
-} _aci_packed_ aci_cmd_params_send_data_nack_t;
-
-ACI_ASSERT_SIZE(aci_cmd_params_send_data_nack_t, 2);
-
-/**
- * @define aci_cmd_params_set_app_latency_t
- * @brief  Structure for the ACI_CMD_SET_APP_LATENCY ACI command parameters
- */
-typedef struct
-{
-  aci_app_latency_mode_t mode;
-  uint16_t latency;
-} _aci_packed_ aci_cmd_params_set_app_latency_t;
-
-ACI_ASSERT_SIZE(aci_cmd_params_set_app_latency_t, 3);
-/**
- * @define aci_cmd_params_set_key_t
- * @brief  Structure for the ACI_CMD_SET_KEY ACI command parameters
- */
-typedef struct
-{
-  aci_key_type_t key_type;
-  union
-  {
-    uint8_t passkey[6];
-    uint8_t oob_key[16];
-  } key;
-} _aci_packed_ aci_cmd_params_set_key_t;
-
-ACI_ASSERT_SIZE(aci_cmd_params_set_key_t, 17);
-/**
- * @define aci_cmd_params_open_adv_pipe_t
- * @brief  Structure for the ACI_CMD_OPEN_ADV_PIPE ACI command parameters
- */
-typedef struct
-{
-  uint8_t pipes[8];
-} _aci_packed_ aci_cmd_params_open_adv_pipe_t;
-
-/**
- * @define aci_cmd_params_broadcast_t
- * @brief  Structure for the ACI_CMD_BROADCAST ACI command parameters
- */
-typedef struct
-{
-  uint16_t        timeout;  /**< 0x0000 (no timeout) to 0x3FFF */
-  uint16_t        adv_interval;     /**< 16 bits of advertising interval for general discovery */
-} _aci_packed_ aci_cmd_params_broadcast_t;
-
-/**
- * @struct aci_cmd_params_close_remote_pipe_t
- * @brief  Structure for the ACI_CMD_CLOSE_REMOTE_PIPE ACI command parameters
- */
-typedef struct
-{
-  uint8_t pipe_number;
-} _aci_packed_ aci_cmd_params_close_remote_pipe_t;
-
-/**
- * @struct aci_cmd_t
- * @brief  Encapsulates a generic ACI command
- */
-typedef struct
-{
-  uint8_t len;        /**< Length of the ACI command */
-  aci_cmd_opcode_t cmd_opcode; /**< enum aci_cmd_opcode_t -> Opcode of the ACI command */
-  union
-  {
-    aci_cmd_params_test_t                       test;
-    aci_cmd_params_echo_t                       echo;
-    aci_cmd_params_dtm_cmd_t                    dtm_cmd;
-    aci_cmd_params_setup_t                      setup;
-    aci_cmd_params_write_dynamic_data_t         write_dynamic_data;
-    aci_cmd_params_set_local_data_t             set_local_data;
-    aci_cmd_params_connect_t                    connect;
-    aci_cmd_params_bond_t                       bond;
-    aci_cmd_params_disconnect_t                 disconnect;
-    aci_cmd_params_set_tx_power_t               set_tx_power;
-    aci_cmd_params_change_timing_t              change_timing;
-    aci_cmd_params_open_remote_pipe_t           open_remote_pipe;
-    aci_cmd_params_send_data_t                  send_data;
-    aci_cmd_params_send_data_ack_t              send_data_ack;
-    aci_cmd_params_request_data_t               request_data;
-    aci_cmd_params_send_data_nack_t             send_data_nack;
-    aci_cmd_params_set_app_latency_t            set_app_latency;
-    aci_cmd_params_set_key_t                    set_key;
-    aci_cmd_params_open_adv_pipe_t              open_adv_pipe;
-    aci_cmd_params_broadcast_t                  broadcast;
-    aci_cmd_params_close_remote_pipe_t          close_remote_pipe;
-
-  } params;
-} _aci_packed_ aci_cmd_t;
-
-#endif // ACI_CMDS_H__
-
-
diff --git a/src/nrf8001/aci_evts.h b/src/nrf8001/aci_evts.h
deleted file mode 100644
index 48ead50..0000000
--- a/src/nrf8001/aci_evts.h
+++ /dev/null
@@ -1,397 +0,0 @@
-/* Copyright (c) 2014, Nordic Semiconductor ASA
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-/**
- * @file
- *
- * @ingroup aci
- *
- * @brief Definitions for the ACI (Application Control Interface) events
- */
-
-#ifndef ACI_EVTS_H__
-#define ACI_EVTS_H__
-
-#include "aci.h"
-
-/**
- * @enum aci_evt_opcode_t
- * @brief ACI event opcodes
- */
-typedef enum
-{
- /**
-  * Invalid event code
-  */
-  ACI_EVT_INVALID                     = 0x00,
- /**
-  * Sent every time the device starts
-  */
-  ACI_EVT_DEVICE_STARTED              = 0x81,
- /**
-  * Mirrors the ACI_CMD_ECHO
-  */
-  ACI_EVT_ECHO                        = 0x82,
- /**
-  * Asynchronous hardware error event
-  */
-  ACI_EVT_HW_ERROR                  = 0x83,
- /**
-  * Event opcode used as a event response for all commands
-  */
-  ACI_EVT_CMD_RSP                     = 0x84,
- /**
-  * Link connected
-  */
-  ACI_EVT_CONNECTED                   = 0x85,
- /**
-  * Link disconnected
-  */
-  ACI_EVT_DISCONNECTED                = 0x86,
- /**
-  * Bond completion result
-  */
-  ACI_EVT_BOND_STATUS                 = 0x87,
-  /**
-  * Pipe bitmap for available pipes
-  */
-  ACI_EVT_PIPE_STATUS             = 0x88,
- /**
-  * Sent to the application when the radio enters a connected state
-  * or when the timing of the radio connection changes
-  */
-  ACI_EVT_TIMING                      = 0x89,
- /**
-  * Notification to the application that transmit credits are
-  * available
-  */
-  ACI_EVT_DATA_CREDIT                 = 0x8A,
- /**
-  * Data acknowledgement event
-  */
-  ACI_EVT_DATA_ACK                    = 0x8B,
- /**
-  * Data received notification event
-  */
-  ACI_EVT_DATA_RECEIVED               = 0x8C,
- /**
-  * Error notification event
-  */
-  ACI_EVT_PIPE_ERROR                  = 0x8D,
- /**
-  * Display Passkey Event
-  */
-  ACI_EVT_DISPLAY_PASSKEY             = 0x8E,
- /**
-  * Security Key request
-  */
-  ACI_EVT_KEY_REQUEST                 = 0x8F
-
-} _aci_packed_ aci_evt_opcode_t;
-
-ACI_ASSERT_SIZE(aci_evt_opcode_t, 1);
-
-/**
- * @struct aci_evt_params_device_started_t
- * @brief Structure for the ACI_EVT_DEVICE_STARTED event return parameters
- */
-typedef struct
-{
-  aci_device_operation_mode_t device_mode; /**< Mode in which the device is being started */
-  aci_hw_error_t hw_error;  /**< Hardware Error if available for the start */
-  uint8_t credit_available; /**< Flow control credit available for this specific FW build */
-} _aci_packed_ aci_evt_params_device_started_t;
-
-ACI_ASSERT_SIZE(aci_evt_params_device_started_t, 3);
-
-/**
- * @struct aci_evt_params_hw_error_t
- * @brief Structure for the ACI_EVT_HW_ERROR event return parameters
- */
-typedef struct
-{
-  uint16_t line_num;
-  uint8_t file_name[20];
-} _aci_packed_ aci_evt_params_hw_error_t;
-
-ACI_ASSERT_SIZE(aci_evt_params_hw_error_t, 22);
-
-/**
- * @struct aci_evt_cmd_rsp_params_dtm_cmd_t
- * @brief Structure for the ACI_EVT_CMD_RSP event with opcode=ACI_CMD_DTM_CMD event return parameters
- */
-typedef struct
-{
-  uint8_t  evt_msb;
-  uint8_t  evt_lsb;
-} _aci_packed_ aci_evt_cmd_rsp_params_dtm_cmd_t;
-
-/**
- * @struct aci_evt_cmd_rsp_read_dynamic_data_t
- * @brief Structure for the ACI_EVT_CMD_RSP event with opcode=ACI_CMD_READ_DYNAMIC_DATA event return parameters
- * @note Dynamic data chunk size in this event is defined to go up to ACI_PACKET_MAX_LEN - 5
- */
-typedef struct
-{
-  uint8_t seq_no;
-  uint8_t dynamic_data[1];
-} _aci_packed_ aci_evt_cmd_rsp_read_dynamic_data_t;
-
-/**
- * @struct aci_evt_cmd_rsp_params_get_device_version_t
- * @brief Structure for the ACI_EVT_CMD_RSP event with opcode=ACI_CMD_GET_DEVICE_VERSION event return parameters
- */
-typedef struct
-{
-  uint16_t  configuration_id;
-  uint8_t   aci_version;
-  uint8_t   setup_format;
-  uint32_t  setup_id;
-  uint8_t   setup_status;
-} _aci_packed_ aci_evt_cmd_rsp_params_get_device_version_t;
-
-ACI_ASSERT_SIZE(aci_evt_cmd_rsp_params_get_device_version_t, 9);
-
-/**
- * @struct aci_evt_cmd_rsp_params_get_device_address_t
- * @brief Structure for the ACI_EVT_CMD_RSP event with opcode=ACI_CMD_GET_DEVICE_ADDRESS event return parameters
- */
-typedef struct
-{
-  uint8_t  bd_addr_own[BTLE_DEVICE_ADDRESS_SIZE];
-  aci_bd_addr_type_t bd_addr_type;
-} _aci_packed_ aci_evt_cmd_rsp_params_get_device_address_t;
-
-ACI_ASSERT_SIZE(aci_evt_cmd_rsp_params_get_device_address_t, BTLE_DEVICE_ADDRESS_SIZE + 1);
-
-/**
- * @struct aci_evt_cmd_rsp_params_get_battery_level_t
- * @brief Structure for the ACI_EVT_CMD_RSP event with opcode=ACI_CMD_GET_BATTERY_LEVEL event return parameters
- */
-typedef struct
-{
-  uint16_t battery_level;
-} _aci_packed_ aci_evt_cmd_rsp_params_get_battery_level_t;
-
-/**
- * @struct aci_evt_cmd_rsp_params_get_temperature_t
- * @brief Structure for the ACI_EVT_CMD_RSP event with opcode=ACI_CMD_GET_TEMPERATURE event return parameters
- */
-typedef struct
-{
-  int16_t temperature_value;
-} _aci_packed_ aci_evt_cmd_rsp_params_get_temperature_t;
-
-/**
- * @struct aci_evt_params_cmd_rsp_t
- * @brief Structure for the ACI_EVT_CMD_RSP event return parameters
- */
-typedef struct
-{
-  aci_cmd_opcode_t cmd_opcode; /**< Command opcode for which the event response is being sent */
-  aci_status_code_t cmd_status; /**< Status of the command that was sent. Used in the context of the command. */
-  union
-  {
-    aci_evt_cmd_rsp_params_dtm_cmd_t dtm_cmd;
-    aci_evt_cmd_rsp_read_dynamic_data_t read_dynamic_data;
-    aci_evt_cmd_rsp_params_get_device_version_t get_device_version;
-    aci_evt_cmd_rsp_params_get_device_address_t get_device_address;
-    aci_evt_cmd_rsp_params_get_battery_level_t  get_battery_level;
-    aci_evt_cmd_rsp_params_get_temperature_t    get_temperature;
-    uint8_t                                     padding[29];
-  } params;
-} _aci_packed_ aci_evt_params_cmd_rsp_t;
-
-ACI_ASSERT_SIZE(aci_evt_params_cmd_rsp_t, 31);
-
-/**
- * @struct aci_evt_params_connected_t
- * @brief Structure for the ACI_EVT_CONNECTED event return parameters
- */
-typedef struct
-{
-  aci_bd_addr_type_t dev_addr_type;
-  uint8_t  dev_addr[BTLE_DEVICE_ADDRESS_SIZE];
-  uint16_t conn_rf_interval;  /**< rf_interval = conn_rf_interval * 1.25 ms Range:0x0006 to 0x0C80 */
-  uint16_t conn_slave_rf_latency; /**< Number of RF events the slave can skip */
-  uint16_t conn_rf_timeout; /**< Timeout as a multiple of 10ms i.e timeout = conn_rf_timeout * 10ms Range: 0x000A to 0x0C80 */
-  aci_clock_accuracy_t master_clock_accuracy; /**< Clock accuracy of Bluetooth master: Enumerated list of values from 500 ppm to 20 ppm */
-} _aci_packed_ aci_evt_params_connected_t;
-
-ACI_ASSERT_SIZE(aci_evt_params_connected_t, 14);
-
-/**
- * @struct aci_evt_params_disconnected_t
- * @brief Structure for the ACI_EVT_DISCONNECTED event return parameters
- */
-typedef struct
-{
-  aci_status_code_t   aci_status;
-  uint8_t btle_status;
-} _aci_packed_ aci_evt_params_disconnected_t;
-
-ACI_ASSERT_SIZE(aci_evt_params_disconnected_t, 2);
-
-/**
- * @struct aci_evt_params_bond_status_t
- * @brief Structure for the ACI_EVT_BOND_STATUS event return parameters
- */
-typedef struct
-{
-  aci_bond_status_code_t status_code;
-  aci_bond_status_source_t status_source;
-  uint8_t secmode1_bitmap;
-  uint8_t secmode2_bitmap;
-  uint8_t keys_exchanged_slave;
-  uint8_t keys_exchanged_master;
-} _aci_packed_ aci_evt_params_bond_status_t;
-
-ACI_ASSERT_SIZE(aci_evt_params_bond_status_t, 6);
-
-/**
- * @struct aci_evt_params_pipe_status_t
- * @brief Structure for the ACI_EVT_PIPE_STATUS event return parameters
- */
-typedef struct
-{
-  uint8_t  pipes_open_bitmap[8];
-  uint8_t  pipes_closed_bitmap[8];
-} _aci_packed_ aci_evt_params_pipe_status_t;
-
-ACI_ASSERT_SIZE(aci_evt_params_pipe_status_t, 16);
-
-/**
- * @struct aci_evt_params_timing_t
- * @brief Structure for the ACI_EVT_TIMING event return parameters
- */
-typedef struct
-{
-  uint16_t conn_rf_interval;  /**< rf_interval = conn_rf_interval * 1.25 ms Range:0x0006 to 0x0C80 */
-  uint16_t conn_slave_rf_latency; /**< Number of RF events the slave can skip */
-  uint16_t conn_rf_timeout; /**< Timeout as a multiple of 10ms i.e timeout = conn_rf_timeout * 10ms Range: 0x000A to 0x0C80 */
-} _aci_packed_ aci_evt_params_timing_t;
-
-ACI_ASSERT_SIZE(aci_evt_params_timing_t, 6);
-
-/**
- * @struct aci_evt_params_data_credit_t
- * @brief Structure for the ACI_EVT_DATA_CREDIT event return parameters
- */
-typedef struct
-{
-  uint8_t credit;
-} _aci_packed_ aci_evt_params_data_credit_t;
-
-/**
- * @struct aci_evt_params_data_ack_t
- * @brief Structure for the ACI_EVT_DATA_ACK event return parameters
- */
-typedef struct
-{
-  uint8_t pipe_number;
-} _aci_packed_ aci_evt_params_data_ack_t;
-
-/**
- * @struct aci_evt_params_data_received_t
- * @brief Structure for the ACI_EVT_DATA_RECEIVED event return parameters
- */
-typedef struct
-{
-  aci_rx_data_t rx_data;
-} _aci_packed_ aci_evt_params_data_received_t;
-
-typedef struct
-{
-  uint8_t content[1];
-} _aci_packed_ error_data_t;
-
-/**
- * @struct aci_evt_params_pipe_error_t
- * @brief Structure for the ACI_EVT_PIPE_ERROR event return parameters
- */
-typedef struct
-{
-  uint8_t pipe_number;
-  uint8_t error_code;
-  union
-  {
-    error_data_t  error_data;
-  } params;
-} _aci_packed_ aci_evt_params_pipe_error_t;
-
-/**
- * @struct aci_evt_params_display_passkey_t
- * @brief Structure for the ACI_EVT_DISPLAY_PASSKEY event return parameters
- */
-typedef struct
-{
-  uint8_t passkey[6];
-} _aci_packed_ aci_evt_params_display_passkey_t;
-
-/**
- * @struct aci_evt_params_key_request_t
- * @brief Structure for the ACI_EVT_KEY_REQUEST event return parameters
- */
-typedef struct
-{
-  aci_key_type_t key_type;
-} _aci_packed_ aci_evt_params_key_request_t;
-
-/**
- * @struct aci_event_params_echo_t
- * @brief  Structure for the ACI_EVT_ECHO ACI event parameters
- */
-typedef struct
-{
-  uint8_t echo_data[ACI_ECHO_DATA_MAX_LEN];
-} _aci_packed_ aci_evt_params_echo_t;
-
-/**
- * @struct aci_evt_t
- * @brief  Encapsulates a generic ACI event
- */
-typedef struct
-{
-  uint8_t len;
-  aci_evt_opcode_t evt_opcode;
-  union
-  {
-    aci_evt_params_device_started_t                     device_started;
-    aci_evt_params_echo_t                               echo;
-    aci_evt_params_hw_error_t                           hw_error;
-    aci_evt_params_cmd_rsp_t                            cmd_rsp;
-    aci_evt_params_connected_t                          connected;
-    aci_evt_params_disconnected_t                       disconnected;
-    aci_evt_params_bond_status_t                        bond_status;
-    aci_evt_params_pipe_status_t                        pipe_status;
-    aci_evt_params_timing_t                             timing;
-    aci_evt_params_data_credit_t                        data_credit;
-    aci_evt_params_data_ack_t                           data_ack;
-    aci_evt_params_data_received_t                      data_received;
-    aci_evt_params_pipe_error_t                         pipe_error;
-    aci_evt_params_display_passkey_t                    display_passkey;
-    aci_evt_params_key_request_t                        key_request;
-  } params;
-} _aci_packed_ aci_evt_t;
-
-ACI_ASSERT_SIZE(aci_evt_t, 33);
-
-#endif // ACI_EVTS_H__
diff --git a/src/nrf8001/aci_protocol_defines.h b/src/nrf8001/aci_protocol_defines.h
deleted file mode 100644
index 3d70ca4..0000000
--- a/src/nrf8001/aci_protocol_defines.h
+++ /dev/null
@@ -1,192 +0,0 @@
-/* Copyright (c) 2014, Nordic Semiconductor ASA
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-/**
- * @file
- *
- * @ingroup aci
- *
- * @brief This file contents defines for the position of all the fields of ACI
- * command or event messages
- */
-
-#ifndef ACI_OFFSET_H__
-#define ACI_OFFSET_H__
-
-
-    #define OFFSET_ACI_LL_CONN_PARAMS_T_MIN_CONN_INTERVAL_LSB 0
-    #define OFFSET_ACI_LL_CONN_PARAMS_T_MIN_CONN_INTERVAL_MSB 1
-    #define OFFSET_ACI_LL_CONN_PARAMS_T_MAX_CONN_INTERVAL_LSB 2
-    #define OFFSET_ACI_LL_CONN_PARAMS_T_MAX_CONN_INTERVAL_MSB 3
-    #define OFFSET_ACI_LL_CONN_PARAMS_T_SLAVE_LATENCY_LSB 4
-    #define OFFSET_ACI_LL_CONN_PARAMS_T_SLAVE_LATENCY_MSB 5
-    #define OFFSET_ACI_LL_CONN_PARAMS_T_TIMEOUT_MULT_LSB 6
-    #define OFFSET_ACI_LL_CONN_PARAMS_T_TIMEOUT_MULT_MSB 7
-    #define OFFSET_ACI_TX_DATA_T_PIPE_NUMBER 0
-    #define OFFSET_ACI_TX_DATA_T_ACI_DATA 1
-    #define OFFSET_ACI_RX_DATA_T_PIPE_NUMBER 0
-    #define OFFSET_ACI_RX_DATA_T_ACI_DATA 1
-    #define OFFSET_ACI_CMD_PARAMS_TEST_T_TEST_MODE_CHANGE 0
-    #define OFFSET_ACI_CMD_PARAMS_ECHO_T_ECHO_DATA 0
-    #define OFFSET_ACI_CMD_PARAMS_DTM_CMD_T_CMD_MSB 0
-    #define OFFSET_ACI_CMD_PARAMS_DTM_CMD_T_CMD_LSB 1
-    #define OFFSET_ACI_CMD_PARAMS_SETUP_T_SETUP_DATA 0
-    #define OFFSET_ACI_CMD_PARAMS_WRITE_DYNAMIC_DATA_T_SEQ_NO 0
-    #define OFFSET_ACI_CMD_PARAMS_WRITE_DYNAMIC_DATA_T_DYNAMIC_DATA 1
-    #define OFFSET_ACI_CMD_PARAMS_SET_LOCAL_DATA_T_TX_DATA 0
-    #define OFFSET_ACI_CMD_PARAMS_CONNECT_T_TIMEOUT_LSB 0
-    #define OFFSET_ACI_CMD_PARAMS_CONNECT_T_TIMEOUT_MSB 1
-    #define OFFSET_ACI_CMD_PARAMS_CONNECT_T_ADV_INTERVAL_LSB 2
-    #define OFFSET_ACI_CMD_PARAMS_CONNECT_T_ADV_INTERVAL_MSB 3
-    #define OFFSET_ACI_CMD_PARAMS_BOND_T_TIMEOUT_LSB 0
-    #define OFFSET_ACI_CMD_PARAMS_BOND_T_TIMEOUT_MSB 1
-    #define OFFSET_ACI_CMD_PARAMS_BOND_T_ADV_INTERVAL_LSB 2
-    #define OFFSET_ACI_CMD_PARAMS_BOND_T_ADV_INTERVAL_MSB 3
-    #define OFFSET_ACI_CMD_PARAMS_DISCONNECT_T_REASON 0
-    #define OFFSET_ACI_CMD_PARAMS_SET_TX_POWER_T_DEVICE_POWER 0
-    #define OFFSET_ACI_CMD_PARAMS_CHANGE_TIMING_T_CONN_PARAMS 0
-    #define OFFSET_ACI_CMD_PARAMS_OPEN_REMOTE_PIPE_T_PIPE_NUMBER 0
-    #define OFFSET_ACI_CMD_PARAMS_SEND_DATA_T_TX_DATA 0
-    #define OFFSET_ACI_CMD_PARAMS_SEND_DATA_ACK_T_PIPE_NUMBER 0
-    #define OFFSET_ACI_CMD_PARAMS_REQUEST_DATA_T_PIPE_NUMBER 0
-    #define OFFSET_ACI_CMD_PARAMS_SEND_DATA_NACK_T_PIPE_NUMBER 0
-    #define OFFSET_ACI_CMD_PARAMS_SEND_DATA_NACK_T_ERROR_CODE 1
-    #define OFFSET_ACI_CMD_PARAMS_SET_APP_LATENCY_T_MODE 0
-    #define OFFSET_ACI_CMD_PARAMS_SET_APP_LATENCY_T_LATENCY_LSB 1
-    #define OFFSET_ACI_CMD_PARAMS_SET_APP_LATENCY_T_LATENCY_MSB 2
-    #define OFFSET_ACI_CMD_PARAMS_SET_KEY_T_KEY_TYPE 0
-    #define OFFSET_ACI_CMD_PARAMS_SET_KEY_T_PASSKEY 1
-    #define OFFSET_ACI_CMD_PARAMS_SET_KEY_T_OOB_KEY 1
-    #define OFFSET_ACI_CMD_PARAMS_OPEN_ADV_PIPE_T_PIPES 0
-    #define OFFSET_ACI_CMD_PARAMS_BROADCAST_T_TIMEOUT_LSB 0
-    #define OFFSET_ACI_CMD_PARAMS_BROADCAST_T_TIMEOUT_MSB 1
-    #define OFFSET_ACI_CMD_PARAMS_BROADCAST_T_ADV_INTERVAL_LSB 2
-    #define OFFSET_ACI_CMD_PARAMS_BROADCAST_T_ADV_INTERVAL_MSB 3
-    #define OFFSET_ACI_CMD_PARAMS_CLOSE_REMOTE_PIPE_T_PIPE_NUMBER 0
-    #define OFFSET_ACI_CMD_T_LEN 0
-    #define OFFSET_ACI_CMD_T_CMD_OPCODE 1
-    #define OFFSET_ACI_CMD_T_TEST 2
-    #define OFFSET_ACI_CMD_T_ECHO 2
-    #define OFFSET_ACI_CMD_T_DTM_CMD 2
-    #define OFFSET_ACI_CMD_T_SETUP 2
-    #define OFFSET_ACI_CMD_T_WRITE_DYNAMIC_DATA 2
-    #define OFFSET_ACI_CMD_T_SET_LOCAL_DATA 2
-    #define OFFSET_ACI_CMD_T_CONNECT 2
-    #define OFFSET_ACI_CMD_T_BOND 2
-    #define OFFSET_ACI_CMD_T_DISCONNECT 2
-    #define OFFSET_ACI_CMD_T_SET_TX_POWER 2
-    #define OFFSET_ACI_CMD_T_CHANGE_TIMING 2
-    #define OFFSET_ACI_CMD_T_OPEN_REMOTE_PIPE 2
-    #define OFFSET_ACI_CMD_T_SEND_DATA 2
-    #define OFFSET_ACI_CMD_T_SEND_DATA_ACK 2
-    #define OFFSET_ACI_CMD_T_REQUEST_DATA 2
-    #define OFFSET_ACI_CMD_T_SEND_DATA_NACK 2
-    #define OFFSET_ACI_CMD_T_SET_APP_LATENCY 2
-    #define OFFSET_ACI_CMD_T_SET_KEY 2
-    #define OFFSET_ACI_CMD_T_OPEN_ADV_PIPE 2
-    #define OFFSET_ACI_CMD_T_BROADCAST 2
-    #define OFFSET_ACI_CMD_T_CLOSE_REMOTE_PIPE 2
-    #define OFFSET_ACI_EVT_PARAMS_DEVICE_STARTED_T_DEVICE_MODE 0
-    #define OFFSET_ACI_EVT_PARAMS_DEVICE_STARTED_T_HW_ERROR 1
-    #define OFFSET_ACI_EVT_PARAMS_DEVICE_STARTED_T_CREDIT_AVAILABLE 2
-    #define OFFSET_ACI_EVT_PARAMS_HW_ERROR_T_LINE_NUM_LSB 0
-    #define OFFSET_ACI_EVT_PARAMS_HW_ERROR_T_LINE_NUM_MSB 1
-    #define OFFSET_ACI_EVT_PARAMS_HW_ERROR_T_FILE_NAME 2
-    #define OFFSET_ACI_EVT_CMD_RSP_PARAMS_DTM_CMD_T_EVT_MSB 0
-    #define OFFSET_ACI_EVT_CMD_RSP_PARAMS_DTM_CMD_T_EVT_LSB 1
-    #define OFFSET_ACI_EVT_CMD_RSP_READ_DYNAMIC_DATA_T_SEQ_NO 0
-    #define OFFSET_ACI_EVT_CMD_RSP_READ_DYNAMIC_DATA_T_DYNAMIC_DATA 1
-    #define OFFSET_ACI_EVT_CMD_RSP_PARAMS_GET_DEVICE_VERSION_T_CONFIGURATION_ID_LSB 0
-    #define OFFSET_ACI_EVT_CMD_RSP_PARAMS_GET_DEVICE_VERSION_T_CONFIGURATION_ID_MSB 1
-    #define OFFSET_ACI_EVT_CMD_RSP_PARAMS_GET_DEVICE_VERSION_T_ACI_VERSION 2
-    #define OFFSET_ACI_EVT_CMD_RSP_PARAMS_GET_DEVICE_VERSION_T_SETUP_FORMAT 3
-    #define OFFSET_ACI_EVT_CMD_RSP_PARAMS_GET_DEVICE_VERSION_T_SETUP_ID_LSB0 4
-    #define OFFSET_ACI_EVT_CMD_RSP_PARAMS_GET_DEVICE_VERSION_T_SETUP_ID_LSB1 5
-    #define OFFSET_ACI_EVT_CMD_RSP_PARAMS_GET_DEVICE_VERSION_T_SETUP_ID_MSB0 6
-    #define OFFSET_ACI_EVT_CMD_RSP_PARAMS_GET_DEVICE_VERSION_T_SETUP_ID_MSB1 7
-    #define OFFSET_ACI_EVT_CMD_RSP_PARAMS_GET_DEVICE_VERSION_T_SETUP_STATUS 8
-    #define OFFSET_ACI_EVT_CMD_RSP_PARAMS_GET_DEVICE_ADDRESS_T_BD_ADDR_OWN 0
-    #define OFFSET_ACI_EVT_CMD_RSP_PARAMS_GET_DEVICE_ADDRESS_T_BD_ADDR_TYPE 6
-    #define OFFSET_ACI_EVT_CMD_RSP_PARAMS_GET_BATTERY_LEVEL_T_BATTERY_LEVEL_LSB 0
-    #define OFFSET_ACI_EVT_CMD_RSP_PARAMS_GET_BATTERY_LEVEL_T_BATTERY_LEVEL_MSB 1
-    #define OFFSET_ACI_EVT_CMD_RSP_PARAMS_GET_TEMPERATURE_T_TEMPERATURE_VALUE_LSB 0
-    #define OFFSET_ACI_EVT_CMD_RSP_PARAMS_GET_TEMPERATURE_T_TEMPERATURE_VALUE_MSB 1
-    #define OFFSET_ACI_EVT_PARAMS_CMD_RSP_T_CMD_OPCODE 0
-    #define OFFSET_ACI_EVT_PARAMS_CMD_RSP_T_CMD_STATUS 1
-    #define OFFSET_ACI_EVT_PARAMS_CMD_RSP_T_DTM_CMD 2
-    #define OFFSET_ACI_EVT_PARAMS_CMD_RSP_T_READ_DYNAMIC_DATA 2
-    #define OFFSET_ACI_EVT_PARAMS_CMD_RSP_T_GET_DEVICE_VERSION 2
-    #define OFFSET_ACI_EVT_PARAMS_CMD_RSP_T_GET_DEVICE_ADDRESS 2
-    #define OFFSET_ACI_EVT_PARAMS_CMD_RSP_T_GET_BATTERY_LEVEL 2
-    #define OFFSET_ACI_EVT_PARAMS_CMD_RSP_T_GET_TEMPERATURE 2
-    #define OFFSET_ACI_EVT_PARAMS_CONNECTED_T_DEV_ADDR_TYPE 0
-    #define OFFSET_ACI_EVT_PARAMS_CONNECTED_T_DEV_ADDR 1
-    #define OFFSET_ACI_EVT_PARAMS_CONNECTED_T_CONN_RF_INTERVAL_LSB 7
-    #define OFFSET_ACI_EVT_PARAMS_CONNECTED_T_CONN_RF_INTERVAL_MSB 8
-    #define OFFSET_ACI_EVT_PARAMS_CONNECTED_T_CONN_SLAVE_RF_LATENCY_LSB 9
-    #define OFFSET_ACI_EVT_PARAMS_CONNECTED_T_CONN_SLAVE_RF_LATENCY_MSB 10
-    #define OFFSET_ACI_EVT_PARAMS_CONNECTED_T_CONN_RF_TIMEOUT_LSB 11
-    #define OFFSET_ACI_EVT_PARAMS_CONNECTED_T_CONN_RF_TIMEOUT_MSB 12
-    #define OFFSET_ACI_EVT_PARAMS_CONNECTED_T_MASTER_CLOCK_ACCURACY 13
-    #define OFFSET_ACI_EVT_PARAMS_DISCONNECTED_T_ACI_STATUS 0
-    #define OFFSET_ACI_EVT_PARAMS_DISCONNECTED_T_BTLE_STATUS 1
-    #define OFFSET_ACI_EVT_PARAMS_BOND_STATUS_T_STATUS_CODE 0
-    #define OFFSET_ACI_EVT_PARAMS_BOND_STATUS_T_STATUS_SOURCE 1
-    #define OFFSET_ACI_EVT_PARAMS_BOND_STATUS_T_SECMODE1_BITMAP 2
-    #define OFFSET_ACI_EVT_PARAMS_BOND_STATUS_T_SECMODE2_BITMAP 3
-    #define OFFSET_ACI_EVT_PARAMS_BOND_STATUS_T_KEYS_EXCHANGED_SLAVE 4
-    #define OFFSET_ACI_EVT_PARAMS_BOND_STATUS_T_KEYS_EXCHANGED_MASTER 5
-    #define OFFSET_ACI_EVT_PARAMS_PIPE_STATUS_T_PIPES_OPEN_BITMAP 0
-    #define OFFSET_ACI_EVT_PARAMS_PIPE_STATUS_T_PIPES_CLOSED_BITMAP 8
-    #define OFFSET_ACI_EVT_PARAMS_TIMING_T_CONN_RF_INTERVAL_LSB 0
-    #define OFFSET_ACI_EVT_PARAMS_TIMING_T_CONN_RF_INTERVAL_MSB 1
-    #define OFFSET_ACI_EVT_PARAMS_TIMING_T_CONN_SLAVE_RF_LATENCY_LSB 2
-    #define OFFSET_ACI_EVT_PARAMS_TIMING_T_CONN_SLAVE_RF_LATENCY_MSB 3
-    #define OFFSET_ACI_EVT_PARAMS_TIMING_T_CONN_RF_TIMEOUT_LSB 4
-    #define OFFSET_ACI_EVT_PARAMS_TIMING_T_CONN_RF_TIMEOUT_MSB 5
-    #define OFFSET_ACI_EVT_PARAMS_DATA_CREDIT_T_CREDIT 0
-    #define OFFSET_ACI_EVT_PARAMS_DATA_ACK_T_PIPE_NUMBER 0
-    #define OFFSET_ACI_EVT_PARAMS_DATA_RECEIVED_T_RX_DATA 0
-    #define OFFSET_ERROR_DATA_T_CONTENT 0
-    #define OFFSET_ACI_EVT_PARAMS_PIPE_ERROR_T_PIPE_NUMBER 0
-    #define OFFSET_ACI_EVT_PARAMS_PIPE_ERROR_T_ERROR_CODE 1
-    #define OFFSET_ACI_EVT_PARAMS_PIPE_ERROR_T_ERROR_DATA 2
-    #define OFFSET_ACI_EVT_PARAMS_DISPLAY_PASSKEY_T_PASSKEY 0
-    #define OFFSET_ACI_EVT_PARAMS_KEY_REQUEST_T_KEY_TYPE 0
-    #define OFFSET_ACI_EVT_T_LEN 0
-    #define OFFSET_ACI_EVT_T_EVT_OPCODE 1
-    #define OFFSET_ACI_EVT_T_DEVICE_STARTED 2
-    #define OFFSET_ACI_EVT_T_HW_ERROR 2
-    #define OFFSET_ACI_EVT_T_CMD_RSP 2
-    #define OFFSET_ACI_EVT_T_CONNECTED 2
-    #define OFFSET_ACI_EVT_T_DISCONNECTED 2
-    #define OFFSET_ACI_EVT_T_BOND_STATUS 2
-    #define OFFSET_ACI_EVT_T_PIPE_STATUS 2
-    #define OFFSET_ACI_EVT_T_TIMING 2
-    #define OFFSET_ACI_EVT_T_DATA_CREDIT 2
-    #define OFFSET_ACI_EVT_T_DATA_ACK 2
-    #define OFFSET_ACI_EVT_T_DATA_RECEIVED 2
-    #define OFFSET_ACI_EVT_T_PIPE_ERROR 2
-    #define OFFSET_ACI_EVT_T_DISPLAY_PASSKEY 2
-    #define OFFSET_ACI_EVT_T_KEY_REQUEST 2
-
-#endif //ACI_OFFSET_H__
-
diff --git a/src/nrf8001/aci_queue.cpp b/src/nrf8001/aci_queue.cpp
deleted file mode 100644
index 86b8549..0000000
--- a/src/nrf8001/aci_queue.cpp
+++ /dev/null
@@ -1,201 +0,0 @@
-/* Copyright (c) 2014, Nordic Semiconductor ASA
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
- /** @file
-@brief Implementation of a circular queue for ACI data
-*/
-
-#include "hal_aci_tl.h"
-#include "aci_queue.h"
-
-void aci_queue_init(aci_queue_t *aci_q)
-{
-  uint8_t loop;
-
-  // ble_assert(NULL != aci_q);
-
-  aci_q->head = 0;
-  aci_q->tail = 0;
-  for(loop=0; loop<ACI_QUEUE_SIZE; loop++)
-  {
-    aci_q->aci_data[loop].buffer[0] = 0x00;
-    aci_q->aci_data[loop].buffer[1] = 0x00;
-  }
-}
-
-bool aci_queue_dequeue(aci_queue_t *aci_q, hal_aci_data_t *p_data)
-{
-  // ble_assert(NULL != aci_q);
-  // ble_assert(NULL != p_data);
-
-  if (aci_queue_is_empty(aci_q))
-  {
-    return false;
-  }
-
-  memcpy((uint8_t *)p_data, (uint8_t *)&(aci_q->aci_data[aci_q->head]), sizeof(hal_aci_data_t));
-  aci_q->head = (aci_q->head + 1) % ACI_QUEUE_SIZE;
-
-  return true;
-}
-
-bool aci_queue_dequeue_from_isr(aci_queue_t *aci_q, hal_aci_data_t *p_data)
-{
-  // ble_assert(NULL != aci_q);
-  // ble_assert(NULL != p_data);
-
-  if (aci_queue_is_empty_from_isr(aci_q))
-  {
-    return false;
-  }
-
-  memcpy((uint8_t *)p_data, (uint8_t *)&(aci_q->aci_data[aci_q->head]), sizeof(hal_aci_data_t));
-  aci_q->head = (aci_q->head + 1) % ACI_QUEUE_SIZE;
-
-  return true;
-}
-
-bool aci_queue_enqueue(aci_queue_t *aci_q, hal_aci_data_t *p_data)
-{
-  const uint8_t length = p_data->buffer[0];
-
-  // ble_assert(NULL != aci_q);
-  // ble_assert(NULL != p_data);
-
-  if (aci_queue_is_full(aci_q))
-  {
-    return false;
-  }
-
-  aci_q->aci_data[aci_q->tail].status_byte = 0;
-  memcpy((uint8_t *)&(aci_q->aci_data[aci_q->tail].buffer[0]), (uint8_t *)&p_data->buffer[0], length + 1);
-  aci_q->tail = (aci_q->tail + 1) % ACI_QUEUE_SIZE;
-
-  return true;
-}
-
-bool aci_queue_enqueue_from_isr(aci_queue_t *aci_q, hal_aci_data_t *p_data)
-{
-  const uint8_t length = p_data->buffer[0];
-
-  // ble_assert(NULL != aci_q);
-  // ble_assert(NULL != p_data);
-
-  if (aci_queue_is_full_from_isr(aci_q))
-  {
-    return false;
-  }
-
-  aci_q->aci_data[aci_q->tail].status_byte = 0;
-  memcpy((uint8_t *)&(aci_q->aci_data[aci_q->tail].buffer[0]), (uint8_t *)&p_data->buffer[0], length + 1);
-  aci_q->tail = (aci_q->tail + 1) % ACI_QUEUE_SIZE;
-
-  return true;
-}
-
-bool aci_queue_is_empty(aci_queue_t *aci_q)
-{
-  bool state = false;
-
-  // ble_assert(NULL != aci_q);
-
-  //Critical section
-  // noInterrupts();
-  if (aci_q->head == aci_q->tail)
-  {
-    state = true;
-  }
-  // interrupts();
-
-  return state;
-}
-
-bool aci_queue_is_empty_from_isr(aci_queue_t *aci_q)
-{
-  // ble_assert(NULL != aci_q);
-
-  return aci_q->head == aci_q->tail;
-}
-
-bool aci_queue_is_full(aci_queue_t *aci_q)
-{
-  uint8_t next;
-  bool state;
-
-  // ble_assert(NULL != aci_q);
-
-  //This should be done in a critical section
-  // noInterrupts();
-  next = (aci_q->tail + 1) % ACI_QUEUE_SIZE;
-
-  if (next == aci_q->head)
-  {
-    state = true;
-  }
-  else
-  {
-    state = false;
-  }
-
-  // interrupts();
-  //end
-
-  return state;
-}
-
-bool aci_queue_is_full_from_isr(aci_queue_t *aci_q)
-{
-  const uint8_t next = (aci_q->tail + 1) % ACI_QUEUE_SIZE;
-
-  // ble_assert(NULL != aci_q);
-
-  return next == aci_q->head;
-}
-
-bool aci_queue_peek(aci_queue_t *aci_q, hal_aci_data_t *p_data)
-{
-  // ble_assert(NULL != aci_q);
-  // ble_assert(NULL != p_data);
-
-  if (aci_queue_is_empty(aci_q))
-  {
-    return false;
-  }
-
-  memcpy((uint8_t *)p_data, (uint8_t *)&(aci_q->aci_data[aci_q->head]), sizeof(hal_aci_data_t));
-
-  return true;
-}
-
-bool aci_queue_peek_from_isr(aci_queue_t *aci_q, hal_aci_data_t *p_data)
-{
-  // ble_assert(NULL != aci_q);
-  // ble_assert(NULL != p_data);
-
-  if (aci_queue_is_empty_from_isr(aci_q))
-  {
-    return false;
-  }
-
-  memcpy((uint8_t *)p_data, (uint8_t *)&(aci_q->aci_data[aci_q->head]), sizeof(hal_aci_data_t));
-
-  return true;
-}
diff --git a/src/nrf8001/aci_queue.h b/src/nrf8001/aci_queue.h
deleted file mode 100644
index 564b8dc..0000000
--- a/src/nrf8001/aci_queue.h
+++ /dev/null
@@ -1,76 +0,0 @@
-/* Copyright (c) 2014, Nordic Semiconductor ASA
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-/** 
- * @file
- * @brief Interface for buffer.
- * @ingroup aci
- */
-
-/**
-@{
-*/
-
-#ifndef ACI_QUEUE_H__
-#define ACI_QUEUE_H__
-
-#include "aci.h"
-#include "hal_aci_tl.h"
-
-/***********************************************************************    */
-/* The ACI_QUEUE_SIZE determines the memory usage of the system.            */
-/* Successfully tested to a ACI_QUEUE_SIZE of 4 (interrupt) and 4 (polling) */
-/***********************************************************************    */
-#define ACI_QUEUE_SIZE  4
-
-/** Data type for queue of data packets to send/receive from radio.
- *
- *  A FIFO queue is maintained for packets. New packets are added (enqueued)
- *  at the tail and taken (dequeued) from the head. The head variable is the
- *  index of the next packet to dequeue while the tail variable is the index of
- *  where the next packet should be queued.
- */
-
-typedef struct {
-    hal_aci_data_t           aci_data[ACI_QUEUE_SIZE];
-    uint8_t                  head;
-    uint8_t                  tail;
-} aci_queue_t;
-
-void aci_queue_init(aci_queue_t *aci_q);
-
-bool aci_queue_dequeue(aci_queue_t *aci_q, hal_aci_data_t *p_data);
-bool aci_queue_dequeue_from_isr(aci_queue_t *aci_q, hal_aci_data_t *p_data);
-
-bool aci_queue_enqueue(aci_queue_t *aci_q, hal_aci_data_t *p_data);
-bool aci_queue_enqueue_from_isr(aci_queue_t *aci_q, hal_aci_data_t *p_data);
-
-bool aci_queue_is_empty(aci_queue_t *aci_q);
-bool aci_queue_is_empty_from_isr(aci_queue_t *aci_q);
-
-bool aci_queue_is_full(aci_queue_t *aci_q);
-bool aci_queue_is_full_from_isr(aci_queue_t *aci_q);
-
-bool aci_queue_peek(aci_queue_t *aci_q, hal_aci_data_t *p_data);
-bool aci_queue_peek_from_isr(aci_queue_t *aci_q, hal_aci_data_t *p_data);
-
-#endif /* ACI_QUEUE_H__ */
-/** @} */
diff --git a/src/nrf8001/aci_setup.cpp b/src/nrf8001/aci_setup.cpp
deleted file mode 100644
index 1546e8f..0000000
--- a/src/nrf8001/aci_setup.cpp
+++ /dev/null
@@ -1,177 +0,0 @@
-/* Copyright (c) 2014, Nordic Semiconductor ASA
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-
-#include "aci.h"
-#include "hal_aci_tl.h"
-#include "lib_aci.h"
-#include "aci_setup.h"
-
-
-// aci_struct that will contain
-// total initial credits
-// current credit
-// current state of the aci (setup/standby/active/sleep)
-// open remote pipe pending
-// close remote pipe pending
-// Current pipe available bitmap
-// Current pipe closed bitmap
-// Current connection interval, slave latency and link supervision timeout
-// Current State of the the GATT client (Service Discovery status)
-
-
-// hal_aci_data_t msg_to_send;
-extern hal_aci_data_t msg_to_send;
-
-
-/**************************************************************************                */
-/* Utility function to fill the the ACI command queue                                      */
-/* aci_stat               Pointer to the ACI state                                         */
-/* num_cmd_offset(in/out) Offset in the Setup message array to start from                  */
-/*                        offset is updated to the new index after the queue is filled     */
-/*                        or the last message us placed in the queue                       */
-/* Returns                true if at least one message was transferred                     */
-/***************************************************************************/
-bool aci_setup_fill(aci_state_t *aci_stat, uint8_t *num_cmd_offset)
-{
-  bool ret_val = false;
-
-  while (*num_cmd_offset < aci_stat->aci_setup_info.num_setup_msgs)
-  {
-    //Board dependent defines
-    /*#if defined (__AVR__)
-        //For Arduino copy the setup ACI message from Flash to RAM.
-        memcpy_P(&msg_to_send, &(aci_stat->aci_setup_info.setup_msgs[*num_cmd_offset]),
-                  pgm_read_byte_near(&(aci_stat->aci_setup_info.setup_msgs[*num_cmd_offset].buffer[0]))+2);
-    #elif defined(__PIC32MX__)
-        //In ChipKit we store the setup messages in RAM
-        //Add 2 bytes to the length byte for status byte, length for the total number of bytes
-        memcpy(&msg_to_send, &(aci_stat->aci_setup_info.setup_msgs[*num_cmd_offset]),
-                  (aci_stat->aci_setup_info.setup_msgs[*num_cmd_offset].buffer[0]+2));
-    #endif*/
-
-    memcpy(&msg_to_send, &(aci_stat->aci_setup_info.setup_msgs[*num_cmd_offset]),
-                  (aci_stat->aci_setup_info.setup_msgs[*num_cmd_offset].buffer[0]+2));
-
-    //Put the Setup ACI message in the command queue
-    if (!hal_aci_tl_send(&msg_to_send))
-    {
-      //ACI Command Queue is full
-      // *num_cmd_offset is now pointing to the index of the Setup command that did not get sent
-      return ret_val;
-   }
-
-    ret_val = true;
-
-    (*num_cmd_offset)++;
-  }
-
-  return ret_val;
-}
-
-uint8_t do_aci_setup(aci_state_t *aci_stat)
-{
-  uint8_t setup_offset         = 0;
-  uint32_t i                   = 0x0000;
-  aci_evt_t * aci_evt          = NULL;
-  aci_status_code_t cmd_status = ACI_STATUS_ERROR_CRC_MISMATCH;
-
-  /*
-  We are using the same buffer since we are copying the contents of the buffer
-  when queuing and immediately processing the buffer when receiving
-  */
-  hal_aci_evt_t  *aci_data = (hal_aci_evt_t *)&msg_to_send;
-
-  /* Messages in the outgoing queue must be handled before the Setup routine can run.
-   * If it is non-empty we return. The user should then process the messages before calling
-   * do_aci_setup() again.
-   */
-  if (!lib_aci_command_queue_empty())
-  {
-    return SETUP_FAIL_COMMAND_QUEUE_NOT_EMPTY;
-  }
-
-  /* If there are events pending from the device that are not relevant to setup, we return false
-   * so that the user can handle them. At this point we don't care what the event is,
-   * as any event is an error.
-   */
-  if (lib_aci_event_peek(aci_data))
-  {
-    return SETUP_FAIL_EVENT_QUEUE_NOT_EMPTY;
-  }
-
-  /* Fill the ACI command queue with as many Setup messages as it will hold. */
-  aci_setup_fill(aci_stat, &setup_offset);
-
-  while (cmd_status != ACI_STATUS_TRANSACTION_COMPLETE)
-  {
-    /* This counter is used to ensure that this function does not loop forever. When the device
-     * returns a valid response, we reset the counter.
-     */
-    if (i++ > 0xFFFFE)
-    {
-      return SETUP_FAIL_TIMEOUT;
-    }
-
-    if (lib_aci_event_peek(aci_data))
-    {
-      aci_evt = &(aci_data->evt);
-
-      if (ACI_EVT_CMD_RSP != aci_evt->evt_opcode)
-      {
-        //Receiving something other than a Command Response Event is an error.
-        return SETUP_FAIL_NOT_COMMAND_RESPONSE;
-      }
-
-      cmd_status = (aci_status_code_t) aci_evt->params.cmd_rsp.cmd_status;
-      switch (cmd_status)
-      {
-        case ACI_STATUS_TRANSACTION_CONTINUE:
-          //As the device is responding, reset guard counter
-          i = 0;
-
-          /* As the device has processed the Setup messages we put in the command queue earlier,
-           * we can proceed to fill the queue with new messages
-           */
-          aci_setup_fill(aci_stat, &setup_offset);
-          break;
-
-        case ACI_STATUS_TRANSACTION_COMPLETE:
-          //Break out of the while loop when this status code appears
-          break;
-
-        default:
-          //An event with any other status code should be handled by the application
-          return SETUP_FAIL_NOT_SETUP_EVENT;
-      }
-
-      /* If we haven't returned at this point, the event was either ACI_STATUS_TRANSACTION_CONTINUE
-       * or ACI_STATUS_TRANSACTION_COMPLETE. We don't need the event itself, so we simply
-       * remove it from the queue.
-       */
-       lib_aci_event_get (aci_stat, aci_data);
-    }
-  }
-
-  return SETUP_SUCCESS;
-}
-
-
diff --git a/src/nrf8001/aci_setup.h b/src/nrf8001/aci_setup.h
deleted file mode 100644
index b267dea..0000000
--- a/src/nrf8001/aci_setup.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/* Copyright (c) 2014, Nordic Semiconductor ASA
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-/** 
- * @file
- * @brief ACI setup functions
- * @ingroup aci
- */
-
-#include <stdint.h>
-#include "lib_aci.h"
-
-#ifndef H_ACI_SETUP
-#define H_ACI_SETUP
-
-#define SETUP_SUCCESS                        0
-#define SETUP_FAIL_COMMAND_QUEUE_NOT_EMPTY   1
-#define SETUP_FAIL_EVENT_QUEUE_NOT_EMPTY     2
-#define SETUP_FAIL_TIMEOUT                   3
-#define SETUP_FAIL_NOT_SETUP_EVENT           4
-#define SETUP_FAIL_NOT_COMMAND_RESPONSE      5
-
-bool aci_setup_fill(aci_state_t *aci_stat, uint8_t *num_cmd_offset);
-/** @brief Setup the nRF8001 device
- *  @details
- *  Performs ACI Setup by transmitting the setup messages generated by nRFgo Studio to the
- *  nRF8001, and should be called when the nRF8001 starts or resets.
- *  Once all messages are sent, the nRF8001 will send a Device Started Event.
- *  The function requires that the Command queue is empty when it is invoked, and will fail
- *  otherwise.
- *  @returns An integer indicating the reason the function terminated
- */
-uint8_t do_aci_setup(aci_state_t *aci_stat);
-
-#endif
diff --git a/src/nrf8001/acilib.cpp b/src/nrf8001/acilib.cpp
deleted file mode 100644
index 6ded058..0000000
--- a/src/nrf8001/acilib.cpp
+++ /dev/null
@@ -1,616 +0,0 @@
-/* Copyright (c) 2014, Nordic Semiconductor ASA
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-/**
- * @file
- *
- * @ingroup group_acilib
- *
- * @brief Implementation of the acilib module.
- */
-
-#include <stdexcept>
-#include <string>
-#include <syslog.h>
-
-#include "hal_platform.h"
-#include "aci.h"
-#include "aci_cmds.h"
-#include "aci_evts.h"
-#include "acilib.h"
-#include "aci_protocol_defines.h"
-#include "acilib_defs.h"
-#include "acilib_if.h"
-#include "acilib_types.h"
-
-
-void acil_encode_cmd_set_test_mode(uint8_t *buffer, aci_cmd_params_test_t *p_aci_cmd_params_test)
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = 2;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_TEST;
-  *(buffer + OFFSET_ACI_CMD_T_TEST + OFFSET_ACI_CMD_PARAMS_TEST_T_TEST_MODE_CHANGE) = p_aci_cmd_params_test->test_mode_change;
-}
-
-void acil_encode_cmd_sleep(uint8_t *buffer)
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = 1;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_SLEEP;
-}
-
-void acil_encode_cmd_get_device_version(uint8_t *buffer)
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = 1;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_GET_DEVICE_VERSION;
-}
-
-void acil_encode_cmd_set_local_data(uint8_t *buffer, aci_cmd_params_set_local_data_t *p_aci_cmd_params_set_local_data, uint8_t data_size)
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = MSG_SET_LOCAL_DATA_BASE_LEN + data_size;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_SET_LOCAL_DATA;
-  *(buffer + OFFSET_ACI_CMD_T_SET_LOCAL_DATA + OFFSET_ACI_CMD_PARAMS_SEND_DATA_T_TX_DATA + OFFSET_ACI_TX_DATA_T_PIPE_NUMBER) = p_aci_cmd_params_set_local_data->tx_data.pipe_number;
-  memcpy(buffer + OFFSET_ACI_CMD_T_SET_LOCAL_DATA + OFFSET_ACI_CMD_PARAMS_SEND_DATA_T_TX_DATA + OFFSET_ACI_TX_DATA_T_ACI_DATA,  &(p_aci_cmd_params_set_local_data->tx_data.aci_data[0]), data_size);
-}
-
-void acil_encode_cmd_connect(uint8_t *buffer, aci_cmd_params_connect_t *p_aci_cmd_params_connect)
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = MSG_CONNECT_LEN;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_CONNECT;
-  *(buffer + OFFSET_ACI_CMD_T_CONNECT + OFFSET_ACI_CMD_PARAMS_CONNECT_T_TIMEOUT_MSB) = (uint8_t)(p_aci_cmd_params_connect->timeout >> 8);
-  *(buffer + OFFSET_ACI_CMD_T_CONNECT + OFFSET_ACI_CMD_PARAMS_CONNECT_T_TIMEOUT_LSB) = (uint8_t)(p_aci_cmd_params_connect->timeout);
-  *(buffer + OFFSET_ACI_CMD_T_CONNECT + OFFSET_ACI_CMD_PARAMS_CONNECT_T_ADV_INTERVAL_MSB) = (uint8_t)(p_aci_cmd_params_connect->adv_interval >> 8);
-  *(buffer + OFFSET_ACI_CMD_T_CONNECT + OFFSET_ACI_CMD_PARAMS_CONNECT_T_ADV_INTERVAL_LSB) = (uint8_t)(p_aci_cmd_params_connect->adv_interval);
-}
-
-void acil_encode_cmd_bond(uint8_t *buffer, aci_cmd_params_bond_t *p_aci_cmd_params_bond)
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = MSG_BOND_LEN;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_BOND;
-  *(buffer + OFFSET_ACI_CMD_T_BOND + OFFSET_ACI_CMD_PARAMS_BOND_T_TIMEOUT_MSB) = (uint8_t)(p_aci_cmd_params_bond->timeout >> 8);
-  *(buffer + OFFSET_ACI_CMD_T_BOND + OFFSET_ACI_CMD_PARAMS_BOND_T_TIMEOUT_LSB) = (uint8_t)(p_aci_cmd_params_bond->timeout);
-  *(buffer + OFFSET_ACI_CMD_T_BOND + OFFSET_ACI_CMD_PARAMS_BOND_T_ADV_INTERVAL_MSB) = (uint8_t)(p_aci_cmd_params_bond->adv_interval >> 8);
-  *(buffer + OFFSET_ACI_CMD_T_BOND + OFFSET_ACI_CMD_PARAMS_BOND_T_ADV_INTERVAL_LSB) = (uint8_t)(p_aci_cmd_params_bond->adv_interval);
-}
-
-void acil_encode_cmd_disconnect(uint8_t *buffer, aci_cmd_params_disconnect_t *p_aci_cmd_params_disconnect)
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = MSG_DISCONNECT_LEN;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_DISCONNECT;
-  *(buffer + OFFSET_ACI_CMD_T_DISCONNECT + OFFSET_ACI_CMD_PARAMS_DISCONNECT_T_REASON) = (uint8_t)(p_aci_cmd_params_disconnect->reason);
-}
-
-void acil_encode_baseband_reset(uint8_t *buffer)
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = MSG_BASEBAND_RESET_LEN;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_RADIO_RESET;
-}
-
-void acil_encode_direct_connect(uint8_t *buffer)
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = MSG_DIRECT_CONNECT_LEN;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_CONNECT_DIRECT;
-}
-
-void acil_encode_cmd_wakeup(uint8_t *buffer)
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = MSG_WAKEUP_LEN;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_WAKEUP;
-}
-
-void acil_encode_cmd_set_radio_tx_power(uint8_t *buffer, aci_cmd_params_set_tx_power_t *p_aci_cmd_params_set_tx_power)
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = MSG_SET_RADIO_TX_POWER_LEN;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_SET_TX_POWER;
-  *(buffer + OFFSET_ACI_CMD_T_SET_TX_POWER + OFFSET_ACI_CMD_PARAMS_SET_TX_POWER_T_DEVICE_POWER) = (uint8_t)p_aci_cmd_params_set_tx_power->device_power;
-}
-
-void acil_encode_cmd_get_address(uint8_t *buffer)
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = MSG_GET_DEVICE_ADDR_LEN;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_GET_DEVICE_ADDRESS;
-}
-
-void acil_encode_cmd_send_data(uint8_t *buffer, aci_cmd_params_send_data_t *p_aci_cmd_params_send_data_t, uint8_t data_size)
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = MSG_SEND_DATA_BASE_LEN + data_size;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_SEND_DATA;
-  *(buffer + OFFSET_ACI_CMD_T_SEND_DATA + OFFSET_ACI_CMD_PARAMS_SEND_DATA_T_TX_DATA + OFFSET_ACI_TX_DATA_T_PIPE_NUMBER) = p_aci_cmd_params_send_data_t->tx_data.pipe_number;
-  memcpy((buffer + OFFSET_ACI_CMD_T_SEND_DATA + OFFSET_ACI_CMD_PARAMS_SEND_DATA_T_TX_DATA + OFFSET_ACI_TX_DATA_T_ACI_DATA), &(p_aci_cmd_params_send_data_t->tx_data.aci_data[0]), data_size);
-}
-
-void acil_encode_cmd_request_data(uint8_t *buffer, aci_cmd_params_request_data_t *p_aci_cmd_params_request_data)
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = MSG_DATA_REQUEST_LEN;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_REQUEST_DATA;
-  *(buffer + OFFSET_ACI_CMD_T_REQUEST_DATA + OFFSET_ACI_CMD_PARAMS_REQUEST_DATA_T_PIPE_NUMBER) = p_aci_cmd_params_request_data->pipe_number;
-}
-
-void acil_encode_cmd_open_remote_pipe(uint8_t *buffer, aci_cmd_params_open_remote_pipe_t *p_aci_cmd_params_open_remote_pipe)
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = MSG_OPEN_REMOTE_PIPE_LEN;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_OPEN_REMOTE_PIPE;
-  *(buffer + OFFSET_ACI_CMD_T_OPEN_REMOTE_PIPE + OFFSET_ACI_CMD_PARAMS_OPEN_REMOTE_PIPE_T_PIPE_NUMBER) = p_aci_cmd_params_open_remote_pipe->pipe_number;
-}
-
-void acil_encode_cmd_close_remote_pipe(uint8_t *buffer, aci_cmd_params_close_remote_pipe_t *p_aci_cmd_params_close_remote_pipe)
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = MSG_CLOSE_REMOTE_PIPE_LEN;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_CLOSE_REMOTE_PIPE;
-  *(buffer + OFFSET_ACI_CMD_T_CLOSE_REMOTE_PIPE + OFFSET_ACI_CMD_PARAMS_CLOSE_REMOTE_PIPE_T_PIPE_NUMBER) = p_aci_cmd_params_close_remote_pipe->pipe_number;
-}
-
-void acil_encode_cmd_echo_msg(uint8_t *buffer, aci_cmd_params_echo_t *p_cmd_params_echo, uint8_t msg_size)
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = MSG_ECHO_MSG_CMD_BASE_LEN + msg_size;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_ECHO;
-  memcpy((buffer + OFFSET_ACI_CMD_T_ECHO + OFFSET_ACI_CMD_PARAMS_ECHO_T_ECHO_DATA), &(p_cmd_params_echo->echo_data[0]), msg_size);
-}
-
-void acil_encode_cmd_battery_level(uint8_t *buffer)
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = 1;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_GET_BATTERY_LEVEL;
-}
-
-void acil_encode_cmd_temparature(uint8_t *buffer)
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = 1;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_GET_TEMPERATURE;
-}
-
-void acil_encode_cmd_read_dynamic_data(uint8_t *buffer)
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = 1;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_READ_DYNAMIC_DATA;
-}
-
-void acil_encode_cmd_write_dynamic_data(uint8_t *buffer, uint8_t seq_no, uint8_t* dynamic_data, uint8_t dynamic_data_size)
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = MSG_WRITE_DYNAMIC_DATA_BASE_LEN + dynamic_data_size;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_WRITE_DYNAMIC_DATA;
-  *(buffer + OFFSET_ACI_CMD_T_WRITE_DYNAMIC_DATA + OFFSET_ACI_CMD_PARAMS_WRITE_DYNAMIC_DATA_T_SEQ_NO) = seq_no;
-  memcpy((buffer + OFFSET_ACI_CMD_T_WRITE_DYNAMIC_DATA + OFFSET_ACI_CMD_PARAMS_WRITE_DYNAMIC_DATA_T_DYNAMIC_DATA), dynamic_data, dynamic_data_size);
-}
-
-void acil_encode_cmd_change_timing_req(uint8_t *buffer, aci_cmd_params_change_timing_t *p_aci_cmd_params_change_timing)
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = MSG_CHANGE_TIMING_LEN;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_CHANGE_TIMING;
-  *(buffer + OFFSET_ACI_CMD_T_CHANGE_TIMING + OFFSET_ACI_CMD_PARAMS_CHANGE_TIMING_T_CONN_PARAMS + OFFSET_ACI_LL_CONN_PARAMS_T_MIN_CONN_INTERVAL_MSB) = (uint8_t)(p_aci_cmd_params_change_timing->conn_params.min_conn_interval >> 8);
-  *(buffer + OFFSET_ACI_CMD_T_CHANGE_TIMING + OFFSET_ACI_CMD_PARAMS_CHANGE_TIMING_T_CONN_PARAMS + OFFSET_ACI_LL_CONN_PARAMS_T_MIN_CONN_INTERVAL_LSB) = (uint8_t)(p_aci_cmd_params_change_timing->conn_params.min_conn_interval);
-  *(buffer + OFFSET_ACI_CMD_T_CHANGE_TIMING + OFFSET_ACI_CMD_PARAMS_CHANGE_TIMING_T_CONN_PARAMS + OFFSET_ACI_LL_CONN_PARAMS_T_MAX_CONN_INTERVAL_MSB) = (uint8_t)(p_aci_cmd_params_change_timing->conn_params.max_conn_interval >> 8);
-  *(buffer + OFFSET_ACI_CMD_T_CHANGE_TIMING + OFFSET_ACI_CMD_PARAMS_CHANGE_TIMING_T_CONN_PARAMS + OFFSET_ACI_LL_CONN_PARAMS_T_MAX_CONN_INTERVAL_LSB) = (uint8_t)(p_aci_cmd_params_change_timing->conn_params.max_conn_interval);
-  *(buffer + OFFSET_ACI_CMD_T_CHANGE_TIMING + OFFSET_ACI_CMD_PARAMS_CHANGE_TIMING_T_CONN_PARAMS + OFFSET_ACI_LL_CONN_PARAMS_T_SLAVE_LATENCY_MSB    ) = (uint8_t)(p_aci_cmd_params_change_timing->conn_params.slave_latency >> 8);
-  *(buffer + OFFSET_ACI_CMD_T_CHANGE_TIMING + OFFSET_ACI_CMD_PARAMS_CHANGE_TIMING_T_CONN_PARAMS + OFFSET_ACI_LL_CONN_PARAMS_T_SLAVE_LATENCY_LSB    ) = (uint8_t)(p_aci_cmd_params_change_timing->conn_params.slave_latency);
-  *(buffer + OFFSET_ACI_CMD_T_CHANGE_TIMING + OFFSET_ACI_CMD_PARAMS_CHANGE_TIMING_T_CONN_PARAMS + OFFSET_ACI_LL_CONN_PARAMS_T_TIMEOUT_MULT_MSB     ) = (uint8_t)(p_aci_cmd_params_change_timing->conn_params.timeout_mult >> 8);
-  *(buffer + OFFSET_ACI_CMD_T_CHANGE_TIMING + OFFSET_ACI_CMD_PARAMS_CHANGE_TIMING_T_CONN_PARAMS + OFFSET_ACI_LL_CONN_PARAMS_T_TIMEOUT_MULT_LSB     ) = (uint8_t)(p_aci_cmd_params_change_timing->conn_params.timeout_mult);
-}
-
-void acil_encode_cmd_set_app_latency(uint8_t *buffer, aci_cmd_params_set_app_latency_t *p_aci_cmd_params_set_app_latency)
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = MSG_SET_APP_LATENCY_LEN;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_SET_APP_LATENCY;
-  *(buffer + OFFSET_ACI_CMD_T_SET_APP_LATENCY + OFFSET_ACI_CMD_PARAMS_SET_APP_LATENCY_T_MODE) = (uint8_t)( p_aci_cmd_params_set_app_latency->mode);
-  *(buffer + OFFSET_ACI_CMD_T_SET_APP_LATENCY + OFFSET_ACI_CMD_PARAMS_SET_APP_LATENCY_T_LATENCY_MSB) = (uint8_t)( p_aci_cmd_params_set_app_latency->latency>>8);
-  *(buffer + OFFSET_ACI_CMD_T_SET_APP_LATENCY + OFFSET_ACI_CMD_PARAMS_SET_APP_LATENCY_T_LATENCY_LSB) = (uint8_t)( p_aci_cmd_params_set_app_latency->latency);
-}
-
-void acil_encode_cmd_change_timing_req_GAP_PPCP(uint8_t *buffer)
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = MSG_CHANGE_TIMING_LEN_GAP_PPCP;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_CHANGE_TIMING;
-}
-
-
-void acil_encode_cmd_setup(uint8_t *buffer, aci_cmd_params_setup_t *p_aci_cmd_params_setup, uint8_t setup_data_size)
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = setup_data_size + MSG_SETUP_CMD_BASE_LEN;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_SETUP;
-  memcpy((buffer + OFFSET_ACI_CMD_T_SETUP), &(p_aci_cmd_params_setup->setup_data[0]), setup_data_size);
-}
-
-void acil_encode_cmd_dtm_cmd(uint8_t *buffer, aci_cmd_params_dtm_cmd_t *p_aci_cmd_params_dtm_cmd)
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = MSG_DTM_CMD;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_DTM_CMD;
-  *(buffer + OFFSET_ACI_CMD_T_DTM_CMD) = p_aci_cmd_params_dtm_cmd->cmd_msb;
-  *(buffer + OFFSET_ACI_CMD_T_DTM_CMD + 1) = p_aci_cmd_params_dtm_cmd->cmd_lsb;
-}
-
-void acil_encode_cmd_send_data_ack(uint8_t *buffer, const uint8_t pipe_number )
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = MSG_ACK_LEN;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_SEND_DATA_ACK;
-  *(buffer + OFFSET_ACI_CMD_T_SEND_DATA_ACK + OFFSET_ACI_CMD_PARAMS_SEND_DATA_ACK_T_PIPE_NUMBER) = pipe_number;
-}
-
-void acil_encode_cmd_send_data_nack(uint8_t *buffer, const uint8_t pipe_number, const uint8_t err_code )
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = MSG_NACK_LEN;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_SEND_DATA_NACK;
-  *(buffer + OFFSET_ACI_CMD_T_SEND_DATA_NACK + OFFSET_ACI_CMD_PARAMS_SEND_DATA_NACK_T_PIPE_NUMBER) = pipe_number;
-  *(buffer + OFFSET_ACI_CMD_T_SEND_DATA_NACK + OFFSET_ACI_CMD_PARAMS_SEND_DATA_NACK_T_ERROR_CODE) = err_code;
-}
-
-void acil_encode_cmd_bond_security_request(uint8_t *buffer)
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = 1;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_BOND_SECURITY_REQUEST;
-}
-
-void acil_encode_cmd_broadcast(uint8_t *buffer, aci_cmd_params_broadcast_t * p_aci_cmd_params_broadcast)
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = MSG_BROADCAST_LEN;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_BROADCAST;
-  *(buffer + OFFSET_ACI_CMD_T_BROADCAST + OFFSET_ACI_CMD_PARAMS_BROADCAST_T_TIMEOUT_LSB) = (p_aci_cmd_params_broadcast->timeout & 0xff);
-  *(buffer + OFFSET_ACI_CMD_T_BROADCAST + OFFSET_ACI_CMD_PARAMS_BROADCAST_T_TIMEOUT_MSB) = (uint8_t)(p_aci_cmd_params_broadcast->timeout >> 8);
-  *(buffer + OFFSET_ACI_CMD_T_BROADCAST + OFFSET_ACI_CMD_PARAMS_BROADCAST_T_ADV_INTERVAL_LSB) = (p_aci_cmd_params_broadcast->adv_interval & 0xff);
-  *(buffer + OFFSET_ACI_CMD_T_BROADCAST + OFFSET_ACI_CMD_PARAMS_BROADCAST_T_ADV_INTERVAL_MSB) = (uint8_t)(p_aci_cmd_params_broadcast->adv_interval >> 8);
-}
-
-void acil_encode_cmd_open_adv_pipes(uint8_t *buffer, aci_cmd_params_open_adv_pipe_t * p_aci_cmd_params_open_adv_pipe)
-{
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = MSG_OPEN_ADV_PIPES_LEN;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_OPEN_ADV_PIPE;
-  memcpy(buffer + OFFSET_ACI_CMD_T_OPEN_ADV_PIPE + OFFSET_ACI_CMD_PARAMS_OPEN_ADV_PIPE_T_PIPES, p_aci_cmd_params_open_adv_pipe->pipes, 8);
-}
-
-
-void acil_encode_cmd_set_key(uint8_t *buffer, aci_cmd_params_set_key_t *p_aci_cmd_params_set_key)
-{
-  /*
-  The length of the key is computed based on the type of key transaction.
-  - Key Reject
-  - Key type is passkey
-  */
-  uint8_t len;
-
-  switch (p_aci_cmd_params_set_key->key_type)
-  {
-    case ACI_KEY_TYPE_INVALID:
-    len = MSG_SET_KEY_REJECT_LEN;
-    break;
-    case ACI_KEY_TYPE_PASSKEY:
-    len = MSG_SET_KEY_PASSKEY_LEN;
-    break;
-    default:
-    len=0;
-    break;
-  }
-  *(buffer + OFFSET_ACI_CMD_T_LEN) = len;
-  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_SET_KEY;
-  *(buffer + OFFSET_ACI_CMD_T_SET_KEY + OFFSET_ACI_CMD_PARAMS_SET_KEY_T_KEY_TYPE) = p_aci_cmd_params_set_key->key_type;
-  memcpy((buffer + OFFSET_ACI_CMD_T_SET_KEY + OFFSET_ACI_CMD_PARAMS_SET_KEY_T_PASSKEY), (uint8_t * )&(p_aci_cmd_params_set_key->key), len-2);//Reducing 2 for the opcode byte and type
-}
-
-bool acil_encode_cmd(uint8_t *buffer, aci_cmd_t *p_aci_cmd)
-{
-  bool ret_val = false;
-
-  switch(p_aci_cmd->cmd_opcode)
-  {
-    case ACI_CMD_TEST:
-      acil_encode_cmd_set_test_mode(buffer, &(p_aci_cmd->params.test));
-      break;
-    case ACI_CMD_SLEEP:
-      acil_encode_cmd_sleep(buffer);
-      break;
-    case ACI_CMD_GET_DEVICE_VERSION:
-      acil_encode_cmd_get_device_version(buffer);
-      break;
-    case ACI_CMD_WAKEUP:
-      acil_encode_cmd_wakeup(buffer);
-      break;
-    case ACI_CMD_ECHO:
-      acil_encode_cmd_echo_msg(buffer, &(p_aci_cmd->params.echo), (p_aci_cmd->len - MSG_ECHO_MSG_CMD_BASE_LEN));
-      break;
-    case ACI_CMD_GET_BATTERY_LEVEL:
-      acil_encode_cmd_battery_level(buffer);
-      break;
-    case ACI_CMD_GET_TEMPERATURE:
-      acil_encode_cmd_temparature(buffer);
-      break;
-    case ACI_CMD_GET_DEVICE_ADDRESS:
-      acil_encode_cmd_get_address(buffer);
-      break;
-    case ACI_CMD_SET_TX_POWER:
-      acil_encode_cmd_set_radio_tx_power(buffer, &(p_aci_cmd->params.set_tx_power));
-      break;
-    case ACI_CMD_CONNECT:
-      acil_encode_cmd_connect(buffer, &(p_aci_cmd->params.connect));
-      break;
-    case ACI_CMD_BOND:
-      acil_encode_cmd_bond(buffer, &(p_aci_cmd->params.bond));
-      break;
-    case ACI_CMD_DISCONNECT:
-      acil_encode_cmd_disconnect(buffer, &(p_aci_cmd->params.disconnect));
-      break;
-    case ACI_CMD_RADIO_RESET:
-      acil_encode_baseband_reset(buffer);
-      break;
-    case ACI_CMD_CHANGE_TIMING:
-      acil_encode_cmd_change_timing_req(buffer, &(p_aci_cmd->params.change_timing));
-      break;
-    case ACI_CMD_SETUP:
-      acil_encode_cmd_setup(buffer, &(p_aci_cmd->params.setup), (p_aci_cmd->len - MSG_SETUP_CMD_BASE_LEN));
-      break;
-    case ACI_CMD_DTM_CMD:
-      acil_encode_cmd_dtm_cmd(buffer, &(p_aci_cmd->params.dtm_cmd));
-      break;
-    case ACI_CMD_READ_DYNAMIC_DATA:
-      acil_encode_cmd_read_dynamic_data(buffer);
-      break;
-    case ACI_CMD_WRITE_DYNAMIC_DATA:
-      acil_encode_cmd_write_dynamic_data(buffer, p_aci_cmd->params.write_dynamic_data.seq_no, &(p_aci_cmd->params.write_dynamic_data.dynamic_data[0]), (p_aci_cmd->len - MSG_WRITE_DYNAMIC_DATA_BASE_LEN));
-      break;
-    case ACI_CMD_OPEN_REMOTE_PIPE:
-      acil_encode_cmd_open_remote_pipe(buffer, &(p_aci_cmd->params.open_remote_pipe));
-      break;
-    case ACI_CMD_SEND_DATA:
-      acil_encode_cmd_send_data(buffer, &(p_aci_cmd->params.send_data), (p_aci_cmd->len - MSG_SEND_DATA_BASE_LEN));
-      break;
-    case ACI_CMD_SEND_DATA_ACK:
-      acil_encode_cmd_send_data_ack(buffer, p_aci_cmd->params.send_data_ack.pipe_number );
-      break;
-    case ACI_CMD_REQUEST_DATA:
-      acil_encode_cmd_request_data(buffer, &(p_aci_cmd->params.request_data));
-      break;
-    case ACI_CMD_SET_LOCAL_DATA:
-      acil_encode_cmd_set_local_data(buffer, (aci_cmd_params_set_local_data_t *)(&(p_aci_cmd->params.send_data)), (p_aci_cmd->len - MSG_SET_LOCAL_DATA_BASE_LEN));
-      break;
-    case ACI_CMD_BOND_SECURITY_REQUEST:
-      acil_encode_cmd_bond_security_request(buffer);
-      break;
-    default:
-      break;
-  }
-  return ret_val;
-}
-
-void acil_decode_evt_command_response(uint8_t *buffer_in, aci_evt_params_cmd_rsp_t *p_evt_params_cmd_rsp)
-{
-  aci_evt_cmd_rsp_params_get_device_version_t *p_device_version;
-  aci_evt_cmd_rsp_params_get_device_address_t *p_device_address;
-  aci_evt_cmd_rsp_params_get_temperature_t    *p_temperature;
-  aci_evt_cmd_rsp_params_get_battery_level_t  *p_batt_lvl;
-  aci_evt_cmd_rsp_read_dynamic_data_t         *p_read_dyn_data;
-  aci_evt_cmd_rsp_params_dtm_cmd_t            *p_dtm_evt;
-
-  p_evt_params_cmd_rsp->cmd_opcode = (aci_cmd_opcode_t)*(buffer_in + OFFSET_ACI_EVT_T_CMD_RSP + OFFSET_ACI_EVT_PARAMS_CMD_RSP_T_CMD_OPCODE);
-  p_evt_params_cmd_rsp->cmd_status = (aci_status_code_t)*(buffer_in + OFFSET_ACI_EVT_T_CMD_RSP + OFFSET_ACI_EVT_PARAMS_CMD_RSP_T_CMD_STATUS);
-
-  switch (p_evt_params_cmd_rsp->cmd_opcode)
-  {
-    case ACI_CMD_GET_DEVICE_VERSION:
-      p_device_version = &(p_evt_params_cmd_rsp->params.get_device_version);
-      p_device_version->configuration_id  = (uint16_t)*(buffer_in + OFFSET_ACI_EVT_T_CMD_RSP + OFFSET_ACI_EVT_PARAMS_CMD_RSP_T_GET_DEVICE_VERSION + OFFSET_ACI_EVT_CMD_RSP_PARAMS_GET_DEVICE_VERSION_T_CONFIGURATION_ID_LSB);
-      p_device_version->configuration_id |= (uint16_t)*(buffer_in + OFFSET_ACI_EVT_T_CMD_RSP + OFFSET_ACI_EVT_PARAMS_CMD_RSP_T_GET_DEVICE_VERSION + OFFSET_ACI_EVT_CMD_RSP_PARAMS_GET_DEVICE_VERSION_T_CONFIGURATION_ID_MSB) << 8;
-      p_device_version->aci_version       = *(buffer_in + OFFSET_ACI_EVT_T_CMD_RSP + OFFSET_ACI_EVT_PARAMS_CMD_RSP_T_GET_DEVICE_VERSION + OFFSET_ACI_EVT_CMD_RSP_PARAMS_GET_DEVICE_VERSION_T_ACI_VERSION);
-      p_device_version->setup_format      = *(buffer_in + OFFSET_ACI_EVT_T_CMD_RSP + OFFSET_ACI_EVT_PARAMS_CMD_RSP_T_GET_DEVICE_VERSION + OFFSET_ACI_EVT_CMD_RSP_PARAMS_GET_DEVICE_VERSION_T_SETUP_FORMAT);
-      p_device_version->setup_id          = (uint32_t)*(buffer_in + OFFSET_ACI_EVT_T_CMD_RSP + OFFSET_ACI_EVT_PARAMS_CMD_RSP_T_GET_DEVICE_VERSION + OFFSET_ACI_EVT_CMD_RSP_PARAMS_GET_DEVICE_VERSION_T_SETUP_ID_LSB0);
-      p_device_version->setup_id         |= (uint32_t)*(buffer_in + OFFSET_ACI_EVT_T_CMD_RSP + OFFSET_ACI_EVT_PARAMS_CMD_RSP_T_GET_DEVICE_VERSION + OFFSET_ACI_EVT_CMD_RSP_PARAMS_GET_DEVICE_VERSION_T_SETUP_ID_LSB1) << 8;
-      p_device_version->setup_id         |= (uint32_t)*(buffer_in + OFFSET_ACI_EVT_T_CMD_RSP + OFFSET_ACI_EVT_PARAMS_CMD_RSP_T_GET_DEVICE_VERSION + OFFSET_ACI_EVT_CMD_RSP_PARAMS_GET_DEVICE_VERSION_T_SETUP_ID_MSB0) << 16;
-      p_device_version->setup_id         |= (uint32_t)*(buffer_in + OFFSET_ACI_EVT_T_CMD_RSP + OFFSET_ACI_EVT_PARAMS_CMD_RSP_T_GET_DEVICE_VERSION + OFFSET_ACI_EVT_CMD_RSP_PARAMS_GET_DEVICE_VERSION_T_SETUP_ID_MSB1) << 24;
-      p_device_version->setup_status      = *(buffer_in + OFFSET_ACI_EVT_T_CMD_RSP + OFFSET_ACI_EVT_PARAMS_CMD_RSP_T_GET_DEVICE_VERSION + OFFSET_ACI_EVT_CMD_RSP_PARAMS_GET_DEVICE_VERSION_T_SETUP_STATUS);
-      break;
-
-    case ACI_CMD_GET_DEVICE_ADDRESS:
-      p_device_address = &(p_evt_params_cmd_rsp->params.get_device_address);
-      memcpy((uint8_t *)(p_device_address->bd_addr_own), (buffer_in + OFFSET_ACI_EVT_T_CMD_RSP+OFFSET_ACI_EVT_PARAMS_CMD_RSP_T_GET_DEVICE_ADDRESS+OFFSET_ACI_EVT_CMD_RSP_PARAMS_GET_DEVICE_ADDRESS_T_BD_ADDR_OWN), BTLE_DEVICE_ADDRESS_SIZE);
-      p_device_address->bd_addr_type = (aci_bd_addr_type_t) *(buffer_in + OFFSET_ACI_EVT_T_CMD_RSP+OFFSET_ACI_EVT_PARAMS_CMD_RSP_T_GET_DEVICE_ADDRESS+OFFSET_ACI_EVT_CMD_RSP_PARAMS_GET_DEVICE_ADDRESS_T_BD_ADDR_TYPE);
-      break;
-
-    case ACI_CMD_GET_TEMPERATURE:
-      p_temperature = &(p_evt_params_cmd_rsp->params.get_temperature);
-      p_temperature->temperature_value =  (int16_t)*(buffer_in + OFFSET_ACI_EVT_T_CMD_RSP + OFFSET_ACI_EVT_PARAMS_CMD_RSP_T_GET_TEMPERATURE + OFFSET_ACI_EVT_CMD_RSP_PARAMS_GET_TEMPERATURE_T_TEMPERATURE_VALUE_LSB);
-      p_temperature->temperature_value |= (int16_t)*(buffer_in + OFFSET_ACI_EVT_T_CMD_RSP + OFFSET_ACI_EVT_PARAMS_CMD_RSP_T_GET_TEMPERATURE + OFFSET_ACI_EVT_CMD_RSP_PARAMS_GET_TEMPERATURE_T_TEMPERATURE_VALUE_MSB) << 8;
-      break;
-
-    case ACI_CMD_GET_BATTERY_LEVEL:
-      p_batt_lvl = &(p_evt_params_cmd_rsp->params.get_battery_level);
-      p_batt_lvl->battery_level =  (int16_t)*(buffer_in + OFFSET_ACI_EVT_T_CMD_RSP + OFFSET_ACI_EVT_PARAMS_CMD_RSP_T_GET_BATTERY_LEVEL + OFFSET_ACI_EVT_CMD_RSP_PARAMS_GET_BATTERY_LEVEL_T_BATTERY_LEVEL_LSB);
-      p_batt_lvl->battery_level |= (int16_t)*(buffer_in + OFFSET_ACI_EVT_T_CMD_RSP + OFFSET_ACI_EVT_PARAMS_CMD_RSP_T_GET_BATTERY_LEVEL + OFFSET_ACI_EVT_CMD_RSP_PARAMS_GET_BATTERY_LEVEL_T_BATTERY_LEVEL_MSB) << 8;
-      break;
-
-    case ACI_CMD_READ_DYNAMIC_DATA:
-      p_read_dyn_data = &(p_evt_params_cmd_rsp->params.read_dynamic_data);
-      p_read_dyn_data->seq_no =  (uint8_t)*(buffer_in + OFFSET_ACI_EVT_T_CMD_RSP + OFFSET_ACI_EVT_PARAMS_CMD_RSP_T_READ_DYNAMIC_DATA + OFFSET_ACI_EVT_CMD_RSP_READ_DYNAMIC_DATA_T_SEQ_NO);
-      memcpy((uint8_t *)(p_read_dyn_data->dynamic_data), (buffer_in + OFFSET_ACI_EVT_T_CMD_RSP + OFFSET_ACI_EVT_PARAMS_CMD_RSP_T_READ_DYNAMIC_DATA + OFFSET_ACI_CMD_PARAMS_WRITE_DYNAMIC_DATA_T_DYNAMIC_DATA), ACIL_DECODE_EVT_GET_LENGTH(buffer_in) - 3); // 3 bytes subtracted account for EventCode, CommandOpCode and Status bytes.
-      // Now that the p_read_dyn_data->dynamic_data will be pointing to memory location with enough space to accommodate upto 27 bytes of dynamic data received. This is because of the padding element in aci_evt_params_cmd_rsp_t
-      break;
-
-    case ACI_CMD_DTM_CMD:
-      p_dtm_evt = &(p_evt_params_cmd_rsp->params.dtm_cmd);
-      p_dtm_evt->evt_msb = (uint8_t)*(buffer_in + OFFSET_ACI_EVT_T_CMD_RSP + OFFSET_ACI_EVT_PARAMS_CMD_RSP_T_DTM_CMD + OFFSET_ACI_EVT_CMD_RSP_PARAMS_DTM_CMD_T_EVT_MSB);
-      p_dtm_evt->evt_lsb = (uint8_t)*(buffer_in + OFFSET_ACI_EVT_T_CMD_RSP + OFFSET_ACI_EVT_PARAMS_CMD_RSP_T_DTM_CMD + OFFSET_ACI_EVT_CMD_RSP_PARAMS_DTM_CMD_T_EVT_LSB);
-      break;
-    default:
-      syslog(LOG_WARNING, "%s: switch case not defined",
-        std::string(__FUNCTION__).c_str());
-  }
-}
-
-void acil_decode_evt_device_started(uint8_t *buffer_in, aci_evt_params_device_started_t *p_evt_params_device_started)
-{
-  p_evt_params_device_started->device_mode = (aci_device_operation_mode_t) *(buffer_in + OFFSET_ACI_EVT_T_DEVICE_STARTED+OFFSET_ACI_EVT_PARAMS_DEVICE_STARTED_T_DEVICE_MODE);
-  p_evt_params_device_started->hw_error = (aci_hw_error_t) *(buffer_in + OFFSET_ACI_EVT_T_DEVICE_STARTED+OFFSET_ACI_EVT_PARAMS_DEVICE_STARTED_T_HW_ERROR);
-  p_evt_params_device_started->credit_available = *(buffer_in + OFFSET_ACI_EVT_T_DEVICE_STARTED+OFFSET_ACI_EVT_PARAMS_DEVICE_STARTED_T_CREDIT_AVAILABLE);
-}
-
-void acil_decode_evt_pipe_status(uint8_t *buffer_in, aci_evt_params_pipe_status_t *p_aci_evt_params_pipe_status)
-{
-  memcpy((uint8_t *)p_aci_evt_params_pipe_status->pipes_open_bitmap, (buffer_in + OFFSET_ACI_EVT_T_PIPE_STATUS + OFFSET_ACI_EVT_PARAMS_PIPE_STATUS_T_PIPES_OPEN_BITMAP), 8);
-  memcpy((uint8_t *)p_aci_evt_params_pipe_status->pipes_closed_bitmap, (buffer_in + OFFSET_ACI_EVT_T_PIPE_STATUS + OFFSET_ACI_EVT_PARAMS_PIPE_STATUS_T_PIPES_CLOSED_BITMAP), 8);
-}
-
-void acil_decode_evt_disconnected(uint8_t *buffer_in, aci_evt_params_disconnected_t *p_aci_evt_params_disconnected)
-{
-  p_aci_evt_params_disconnected->aci_status = (aci_status_code_t)*(buffer_in + OFFSET_ACI_EVT_T_DISCONNECTED + OFFSET_ACI_EVT_PARAMS_DISCONNECTED_T_ACI_STATUS);
-  p_aci_evt_params_disconnected->btle_status = *(buffer_in + OFFSET_ACI_EVT_T_DISCONNECTED + OFFSET_ACI_EVT_PARAMS_DISCONNECTED_T_BTLE_STATUS);
-}
-
-void acil_decode_evt_bond_status(uint8_t *buffer_in, aci_evt_params_bond_status_t *p_aci_evt_params_bond_status)
-{
-  p_aci_evt_params_bond_status->status_code = (aci_bond_status_code_t)*(buffer_in + OFFSET_ACI_EVT_T_BOND_STATUS + OFFSET_ACI_EVT_PARAMS_BOND_STATUS_T_STATUS_CODE);
-  p_aci_evt_params_bond_status->status_source = (aci_bond_status_source_t)*(buffer_in + OFFSET_ACI_EVT_T_BOND_STATUS + OFFSET_ACI_EVT_PARAMS_BOND_STATUS_T_STATUS_SOURCE);
-  p_aci_evt_params_bond_status->secmode1_bitmap = *(buffer_in + OFFSET_ACI_EVT_T_BOND_STATUS + OFFSET_ACI_EVT_PARAMS_BOND_STATUS_T_SECMODE1_BITMAP);
-  p_aci_evt_params_bond_status->secmode2_bitmap = *(buffer_in + OFFSET_ACI_EVT_T_BOND_STATUS + OFFSET_ACI_EVT_PARAMS_BOND_STATUS_T_SECMODE2_BITMAP);
-  p_aci_evt_params_bond_status->keys_exchanged_slave = *(buffer_in + OFFSET_ACI_EVT_T_BOND_STATUS + OFFSET_ACI_EVT_PARAMS_BOND_STATUS_T_KEYS_EXCHANGED_SLAVE);
-  p_aci_evt_params_bond_status->keys_exchanged_master = *(buffer_in + OFFSET_ACI_EVT_T_BOND_STATUS + OFFSET_ACI_EVT_PARAMS_BOND_STATUS_T_KEYS_EXCHANGED_MASTER);
-}
-
-uint8_t acil_decode_evt_data_received(uint8_t *buffer_in, aci_evt_params_data_received_t *p_evt_params_data_received)
-{
-  uint8_t size = *( buffer_in + OFFSET_ACI_EVT_T_LEN) - (OFFSET_ACI_EVT_T_DATA_RECEIVED + OFFSET_ACI_RX_DATA_T_ACI_DATA) + 1 ;
-  p_evt_params_data_received->rx_data.pipe_number = *(buffer_in + OFFSET_ACI_EVT_T_DATA_RECEIVED + OFFSET_ACI_RX_DATA_T_PIPE_NUMBER);
-  memcpy((uint8_t *)p_evt_params_data_received->rx_data.aci_data, (buffer_in + OFFSET_ACI_EVT_T_DATA_RECEIVED + OFFSET_ACI_RX_DATA_T_ACI_DATA), size);
-  return size;
-}
-
-void acil_decode_evt_data_ack(uint8_t *buffer_in, aci_evt_params_data_ack_t *p_evt_params_data_ack)
-{
-  p_evt_params_data_ack->pipe_number = *(buffer_in + OFFSET_ACI_EVT_T_DATA_ACK + OFFSET_ACI_EVT_PARAMS_DATA_ACK_T_PIPE_NUMBER);
-}
-
-uint8_t acil_decode_evt_hw_error(uint8_t *buffer_in, aci_evt_params_hw_error_t *p_aci_evt_params_hw_error)
-{
-  uint8_t size = *(buffer_in + OFFSET_ACI_EVT_T_LEN) - (OFFSET_ACI_EVT_T_HW_ERROR + OFFSET_ACI_EVT_PARAMS_HW_ERROR_T_FILE_NAME) + 1;
-  p_aci_evt_params_hw_error->line_num = (uint16_t)(*(buffer_in + OFFSET_ACI_EVT_T_HW_ERROR + OFFSET_ACI_EVT_PARAMS_HW_ERROR_T_LINE_NUM_MSB)) << 8;
-  p_aci_evt_params_hw_error->line_num |= (uint16_t)*(buffer_in + OFFSET_ACI_EVT_T_HW_ERROR + OFFSET_ACI_EVT_PARAMS_HW_ERROR_T_LINE_NUM_LSB);
-  memcpy((uint8_t *)p_aci_evt_params_hw_error->file_name, (buffer_in + OFFSET_ACI_EVT_T_HW_ERROR + OFFSET_ACI_EVT_PARAMS_HW_ERROR_T_FILE_NAME), size);
-  return size;
-}
-
-void acil_decode_evt_credit(uint8_t *buffer_in, aci_evt_params_data_credit_t *p_evt_params_data_credit)
-{
-  p_evt_params_data_credit->credit = *(buffer_in + OFFSET_ACI_EVT_T_DATA_CREDIT + OFFSET_ACI_EVT_PARAMS_DATA_CREDIT_T_CREDIT);
-}
-
-void acil_decode_evt_connected(uint8_t *buffer_in, aci_evt_params_connected_t *p_aci_evt_params_connected)
-{
-  p_aci_evt_params_connected->dev_addr_type = (aci_bd_addr_type_t)*(buffer_in + OFFSET_ACI_EVT_T_CONNECTED + OFFSET_ACI_EVT_PARAMS_CONNECTED_T_DEV_ADDR_TYPE);
-  memcpy(&(p_aci_evt_params_connected->dev_addr[0]), (buffer_in + OFFSET_ACI_EVT_T_CONNECTED + OFFSET_ACI_EVT_PARAMS_CONNECTED_T_DEV_ADDR), BTLE_DEVICE_ADDRESS_SIZE);
-  p_aci_evt_params_connected->conn_rf_interval       = (uint16_t)*(buffer_in + OFFSET_ACI_EVT_T_CONNECTED + OFFSET_ACI_EVT_PARAMS_CONNECTED_T_CONN_RF_INTERVAL_MSB) << 8;
-  p_aci_evt_params_connected->conn_rf_interval      |= (uint16_t)*(buffer_in + OFFSET_ACI_EVT_T_CONNECTED + OFFSET_ACI_EVT_PARAMS_CONNECTED_T_CONN_RF_INTERVAL_LSB);
-  p_aci_evt_params_connected->conn_slave_rf_latency  = (uint16_t)*(buffer_in + OFFSET_ACI_EVT_T_CONNECTED + OFFSET_ACI_EVT_PARAMS_CONNECTED_T_CONN_SLAVE_RF_LATENCY_MSB) << 8;
-  p_aci_evt_params_connected->conn_slave_rf_latency |= (uint16_t)*(buffer_in + OFFSET_ACI_EVT_T_CONNECTED + OFFSET_ACI_EVT_PARAMS_CONNECTED_T_CONN_SLAVE_RF_LATENCY_LSB);
-  p_aci_evt_params_connected->conn_rf_timeout        = (uint16_t)*(buffer_in + OFFSET_ACI_EVT_T_CONNECTED + OFFSET_ACI_EVT_PARAMS_CONNECTED_T_CONN_RF_TIMEOUT_MSB) << 8;
-  p_aci_evt_params_connected->conn_rf_timeout       |= (uint16_t)*(buffer_in + OFFSET_ACI_EVT_T_CONNECTED + OFFSET_ACI_EVT_PARAMS_CONNECTED_T_CONN_RF_TIMEOUT_LSB);
-  p_aci_evt_params_connected->master_clock_accuracy  = (aci_clock_accuracy_t)*(buffer_in + OFFSET_ACI_EVT_T_CONNECTED + OFFSET_ACI_EVT_PARAMS_CONNECTED_T_MASTER_CLOCK_ACCURACY);
-
-}
-
-void acil_decode_evt_timing(uint8_t *buffer_in, aci_evt_params_timing_t *p_evt_params_timing)
-{
-  p_evt_params_timing->conn_rf_interval       = *(buffer_in + OFFSET_ACI_EVT_T_TIMING + OFFSET_ACI_EVT_PARAMS_TIMING_T_CONN_RF_INTERVAL_MSB) << 8;
-  p_evt_params_timing->conn_rf_interval      |= (uint16_t)*(buffer_in + OFFSET_ACI_EVT_T_TIMING + OFFSET_ACI_EVT_PARAMS_TIMING_T_CONN_RF_INTERVAL_LSB);
-  p_evt_params_timing->conn_slave_rf_latency  = (uint16_t)*(buffer_in + OFFSET_ACI_EVT_T_TIMING + OFFSET_ACI_EVT_PARAMS_TIMING_T_CONN_SLAVE_RF_LATENCY_MSB) << 8;
-  p_evt_params_timing->conn_slave_rf_latency |= (uint16_t)*(buffer_in + OFFSET_ACI_EVT_T_TIMING + OFFSET_ACI_EVT_PARAMS_TIMING_T_CONN_SLAVE_RF_LATENCY_LSB);
-  p_evt_params_timing->conn_rf_timeout        = (uint16_t)*(buffer_in + OFFSET_ACI_EVT_T_TIMING + OFFSET_ACI_EVT_PARAMS_TIMING_T_CONN_RF_TIMEOUT_MSB) << 8;
-  p_evt_params_timing->conn_rf_timeout       |= *(buffer_in + OFFSET_ACI_EVT_T_TIMING + OFFSET_ACI_EVT_PARAMS_TIMING_T_CONN_RF_TIMEOUT_LSB);
-}
-
-void acil_decode_evt_pipe_error(uint8_t *buffer_in, aci_evt_params_pipe_error_t *p_evt_params_pipe_error)
-{
-  //volatile uint8_t size = *(buffer_in + OFFSET_ACI_EVT_T_LEN) - (OFFSET_ACI_EVT_T_PIPE_ERROR + OFFSET_ACI_EVT_PARAMS_PIPE_ERROR_T_ERROR_DATA) + 1;
-  p_evt_params_pipe_error->pipe_number = *(buffer_in + OFFSET_ACI_EVT_T_PIPE_ERROR + OFFSET_ACI_EVT_PARAMS_PIPE_ERROR_T_PIPE_NUMBER);
-  p_evt_params_pipe_error->error_code = *(buffer_in + OFFSET_ACI_EVT_T_PIPE_ERROR + OFFSET_ACI_EVT_PARAMS_PIPE_ERROR_T_ERROR_CODE);
-  p_evt_params_pipe_error->params.error_data.content[0] = *(buffer_in + OFFSET_ACI_EVT_T_PIPE_ERROR + OFFSET_ACI_EVT_PARAMS_PIPE_ERROR_T_ERROR_DATA + OFFSET_ERROR_DATA_T_CONTENT);
-}
-
-void acil_decode_evt_key_request(uint8_t *buffer_in, aci_evt_params_key_request_t *p_evt_params_key_request)
-{
-  p_evt_params_key_request->key_type = (aci_key_type_t)*(buffer_in + OFFSET_ACI_EVT_T_KEY_REQUEST + OFFSET_ACI_EVT_PARAMS_KEY_REQUEST_T_KEY_TYPE);
-}
-
-uint8_t acil_decode_evt_echo(uint8_t *buffer_in, aci_evt_params_echo_t *aci_evt_params_echo)
-{
-  uint8_t size = *(buffer_in + OFFSET_ACI_EVT_T_LEN) - 1;
-  memcpy(&aci_evt_params_echo->echo_data[0], (buffer_in + OFFSET_ACI_EVT_T_EVT_OPCODE + 1), size);
-  return size;
-}
-
-void acil_decode_evt_display_passkey(uint8_t *buffer_in, aci_evt_params_display_passkey_t *p_aci_evt_params_display_passkey)
-{
-  p_aci_evt_params_display_passkey->passkey[0] = *(buffer_in + OFFSET_ACI_EVT_T_DISPLAY_PASSKEY +  OFFSET_ACI_EVT_PARAMS_DISPLAY_PASSKEY_T_PASSKEY + 0);
-  p_aci_evt_params_display_passkey->passkey[1] = *(buffer_in + OFFSET_ACI_EVT_T_DISPLAY_PASSKEY +  OFFSET_ACI_EVT_PARAMS_DISPLAY_PASSKEY_T_PASSKEY + 1);
-  p_aci_evt_params_display_passkey->passkey[2] = *(buffer_in + OFFSET_ACI_EVT_T_DISPLAY_PASSKEY +  OFFSET_ACI_EVT_PARAMS_DISPLAY_PASSKEY_T_PASSKEY + 2);
-  p_aci_evt_params_display_passkey->passkey[3] = *(buffer_in + OFFSET_ACI_EVT_T_DISPLAY_PASSKEY +  OFFSET_ACI_EVT_PARAMS_DISPLAY_PASSKEY_T_PASSKEY + 3);
-  p_aci_evt_params_display_passkey->passkey[4] = *(buffer_in + OFFSET_ACI_EVT_T_DISPLAY_PASSKEY +  OFFSET_ACI_EVT_PARAMS_DISPLAY_PASSKEY_T_PASSKEY + 4);
-  p_aci_evt_params_display_passkey->passkey[5] = *(buffer_in + OFFSET_ACI_EVT_T_DISPLAY_PASSKEY +  OFFSET_ACI_EVT_PARAMS_DISPLAY_PASSKEY_T_PASSKEY + 5);
-}
-
-bool acil_decode_evt(uint8_t *buffer_in, aci_evt_t *p_aci_evt)
-{
-  bool ret_val = true;
-
-  p_aci_evt->len = ACIL_DECODE_EVT_GET_LENGTH(buffer_in);
-  p_aci_evt->evt_opcode = (aci_evt_opcode_t)ACIL_DECODE_EVT_GET_OPCODE(buffer_in);
-
-  switch(p_aci_evt->evt_opcode)
-  {
-    case ACI_EVT_DEVICE_STARTED:
-      acil_decode_evt_device_started(buffer_in, &(p_aci_evt->params.device_started));
-      break;
-    case ACI_EVT_HW_ERROR:
-      acil_decode_evt_hw_error(buffer_in, &(p_aci_evt->params.hw_error));
-      break;
-    case ACI_EVT_CMD_RSP:
-      acil_decode_evt_command_response(buffer_in, &(p_aci_evt->params.cmd_rsp));
-      break;
-    case ACI_EVT_DATA_CREDIT:
-      acil_decode_evt_credit(buffer_in, &(p_aci_evt->params.data_credit));
-      break;
-    case ACI_EVT_CONNECTED:
-      acil_decode_evt_connected(buffer_in, &(p_aci_evt->params.connected));
-      break;
-    case ACI_EVT_PIPE_STATUS:
-      acil_decode_evt_pipe_status(buffer_in, &(p_aci_evt->params.pipe_status));
-      break;
-    case ACI_EVT_DISCONNECTED:
-      acil_decode_evt_disconnected(buffer_in, &(p_aci_evt->params.disconnected));
-      break;
-    case ACI_EVT_BOND_STATUS:
-      acil_decode_evt_bond_status(buffer_in, &(p_aci_evt->params.bond_status));
-      break;
-    case ACI_EVT_TIMING:
-      acil_decode_evt_timing(buffer_in, &(p_aci_evt->params.timing));
-      break;
-    case ACI_EVT_DATA_ACK:
-      acil_decode_evt_data_ack(buffer_in, &(p_aci_evt->params.data_ack));
-      break;
-    case ACI_EVT_DATA_RECEIVED:
-      acil_decode_evt_data_received(buffer_in, &(p_aci_evt->params.data_received));
-      break;
-    case ACI_EVT_PIPE_ERROR:
-      acil_decode_evt_pipe_error(buffer_in, &(p_aci_evt->params.pipe_error));
-      break;
-    case ACI_EVT_KEY_REQUEST:
-      acil_decode_evt_key_request(buffer_in, &(p_aci_evt->params.key_request));
-      break;
-    case ACI_EVT_DISPLAY_PASSKEY:
-      acil_decode_evt_display_passkey(buffer_in, &(p_aci_evt->params.display_passkey));
-      break;
-    default:
-      ret_val = false;
-      break;
-  }
-  return ret_val;
-}
diff --git a/src/nrf8001/acilib.h b/src/nrf8001/acilib.h
deleted file mode 100644
index 924fba9..0000000
--- a/src/nrf8001/acilib.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/* Copyright (c) 2014, Nordic Semiconductor ASA
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-/**
- * @file
- *
- * @ingroup aci-lib
- *
- * @brief Internal prototype for acilib module.
- */
-
-#ifndef _acilib_H_
-#define _acilib_H_
-
-#define MSG_SET_LOCAL_DATA_BASE_LEN              2
-#define MSG_CONNECT_LEN                          5
-#define MSG_BOND_LEN                             5
-#define MSG_DISCONNECT_LEN                       2
-#define MSG_BASEBAND_RESET_LEN                   1
-#define MSG_WAKEUP_LEN                           1
-#define MSG_SET_RADIO_TX_POWER_LEN               2
-#define MSG_GET_DEVICE_ADDR_LEN                  1
-#define MSG_SEND_DATA_BASE_LEN                   2
-#define MSG_DATA_REQUEST_LEN                     2
-#define MSG_OPEN_REMOTE_PIPE_LEN                 2
-#define MSG_CLOSE_REMOTE_PIPE_LEN                2
-#define MSG_DTM_CMD                              3
-#define MSG_WRITE_DYNAMIC_DATA_BASE_LEN          2
-#define MSG_SETUP_CMD_BASE_LEN                   1
-#define MSG_ECHO_MSG_CMD_BASE_LEN                1
-#define MSG_CHANGE_TIMING_LEN                    9
-#define MSG_SET_APP_LATENCY_LEN                  4
-#define MSG_CHANGE_TIMING_LEN_GAP_PPCP           1
-#define MSG_DIRECT_CONNECT_LEN                   1
-#define MSG_SET_KEY_REJECT_LEN                   2
-#define MSG_SET_KEY_PASSKEY_LEN                  8
-#define MSG_SET_KEY_OOB_LEN                      18
-#define MSG_ACK_LEN                              2
-#define MSG_NACK_LEN                             3
-#define MSG_BROADCAST_LEN                        5
-#define MSG_OPEN_ADV_PIPES_LEN                   9
-
-#endif /* _acilib_H_ */
diff --git a/src/nrf8001/acilib_defs.h b/src/nrf8001/acilib_defs.h
deleted file mode 100644
index 503114a..0000000
--- a/src/nrf8001/acilib_defs.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/* Copyright (c) 2014, Nordic Semiconductor ASA
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-/**
- * @file
- *
- * @ingroup aci-lib
- *
- * @brief Definitions for the acilib interfaces
- */
-
-#ifndef _acilib_DEFS_H_
-#define _acilib_DEFS_H_
-
-#define ACIL_DECODE_EVT_GET_LENGTH(buffer_in) (*(buffer_in + OFFSET_ACI_EVT_T_LEN))
-
-#define ACIL_DECODE_EVT_GET_OPCODE(buffer_in) (*(buffer_in + OFFSET_ACI_EVT_T_EVT_OPCODE))
-
-#endif /* _acilib_DEFS_H_ */
diff --git a/src/nrf8001/acilib_if.h b/src/nrf8001/acilib_if.h
deleted file mode 100644
index 37879aa..0000000
--- a/src/nrf8001/acilib_if.h
+++ /dev/null
@@ -1,471 +0,0 @@
-/* Copyright (c) 2014, Nordic Semiconductor ASA
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-/**
- * @file
- *
- * @ingroup aci-lib
- *
- * @brief Prototypes for the acilib interfaces.
- */
-
-#ifndef _acilib_IF_H_
-#define _acilib_IF_H_
-
-/** @brief Encode the ACI message for set test mode command
- *
- *  @param[in,out]  buffer      Pointer to ACI message buffer
- *  @param[in]      test_mode   Pointer to the test mode in ::aci_cmd_params_test_t
- *
- *  @return         None
- */
-void acil_encode_cmd_set_test_mode(uint8_t *buffer, aci_cmd_params_test_t *p_aci_cmd_params_test);
-
-/** @brief Encode the ACI message for sleep command
- *
- *  @param[in,out]  buffer      Pointer to ACI message buffer
- *
- *  @return         None
- */
-void acil_encode_cmd_sleep(uint8_t *buffer);
-
-/** @brief Encode the ACI message for get device version
- *
- *  @param[in,out]  buffer      Pointer to ACI message buffer
- *
- *  @return         None
- */
-void acil_encode_cmd_get_device_version(uint8_t *buffer);
-
-/** @brief Encode the ACI message for set local data
- *
- *  @param[in,out]  buffer                           Pointer to ACI message buffer
- *  @param[in]      p_aci_cmd_params_set_local_data  Pointer to the local data parameters in ::aci_cmd_params_set_local_data_t
- *  @param[in]      data_size                        Size of data message
- *
- *  @return         None
- */
-void acil_encode_cmd_set_local_data(uint8_t *buffer, aci_cmd_params_set_local_data_t *p_aci_cmd_params_set_local_data, uint8_t data_size);
-
-/** @brief Encode the ACI message to connect
- *
- *  @param[in,out]  buffer                    Pointer to ACI message buffer
- *  @param[in]      p_aci_cmd_params_connect  Pointer to the run parameters in ::aci_cmd_params_connect_t
- *
- *  @return         None
- */
-void acil_encode_cmd_connect(uint8_t *buffer, aci_cmd_params_connect_t *p_aci_cmd_params_connect);
-
-/** @brief Encode the ACI message to bond
- *
- *  @param[in,out]  buffer                 Pointer to ACI message buffer
- *  @param[in]      p_aci_cmd_params_bond  Pointer to the run parameters in ::aci_cmd_params_bond_t
- *
- *  @return         None
- */
-void acil_encode_cmd_bond(uint8_t *buffer, aci_cmd_params_bond_t *p_aci_cmd_params_bond);
-
-/** @brief Encode the ACI message to disconnect
- *
- *  @param[in,out]  buffer                       Pointer to ACI message buffer
- *  @param[in]      p_aci_cmd_params_disconnect  Pointer to the run parameters in ::aci_cmd_params_disconnect_t
- *
- *  @return         None
- */
-void acil_encode_cmd_disconnect(uint8_t *buffer, aci_cmd_params_disconnect_t *p_aci_cmd_params_disconnect);
-
-/** @brief Encode the ACI message to baseband reset
- *
- *  @param[in,out]  buffer        Pointer to ACI message buffer
- *
- *  @return         None
- */
- void acil_encode_baseband_reset(uint8_t *buffer);
-
- /** @brief Encode the ACI message for Directed Advertising
- *
- *  @param[in,out]  buffer        Pointer to ACI message buffer
- *
- *  @return         None
- */
- void acil_encode_direct_connect(uint8_t *buffer);
-
-/** @brief Encode the ACI message to wakeup
- *
- *  @param[in,out]  buffer        Pointer to ACI message buffer
- *
- *  @return         None
- */
-void acil_encode_cmd_wakeup(uint8_t *buffer);
-
-/** @brief Encode the ACI message for set radio Tx power
- *
- *  @param[in,out]  buffer                         Pointer to ACI message buffer
- *  @param[in]      p_aci_cmd_params_set_tx_power  Pointer to the set Tx power parameters in ::aci_cmd_params_set_tx_power_t
- *
- *  @return         None
- */
-void acil_encode_cmd_set_radio_tx_power(uint8_t *buffer, aci_cmd_params_set_tx_power_t *p_aci_cmd_params_set_tx_power);
-
-/** @brief Encode the ACI message for get device address
- *
- *  @param[in,out]  buffer            Pointer to ACI message buffer
- *
- *  @return         None
- */
-void acil_encode_cmd_get_address(uint8_t *buffer);
-
-/** @brief Encode the ACI message for send data
- *
- *  @param[in,out]  buffer                        Pointer to ACI message buffer
- *  @param[in]      p_aci_cmd_params_send_data_t  Pointer to the data parameters in ::aci_cmd_params_send_data_t
- *  @param[in]      data_size                     Size of data message
- *
- *  @return         None
- */
-void acil_encode_cmd_send_data(uint8_t *buffer, aci_cmd_params_send_data_t *p_aci_cmd_params_send_data_t, uint8_t data_size);
-
-/** @brief Encode the ACI message for request data
- *
- *  @param[in,out]  buffer                          Pointer to ACI message buffer
- *  @param[in]      p_aci_cmd_params_request_data   Pointer to the request data parameters in ::aci_cmd_params_request_data_t
- *
- *  @return         None
- */
-void acil_encode_cmd_request_data(uint8_t *buffer, aci_cmd_params_request_data_t *p_aci_cmd_params_request_data);
-
-/** @brief Encode the ACI message for open remote pipe
- *
- *  @param[in,out]  buffer                              Pointer to ACI message buffer
- *  @param[in]      p_aci_cmd_params_open_remote_pipe   Pointer to the dynamic data parameters in ::aci_cmd_params_open_remote_pipe_t
- *
- *  @return         None
- */
-void acil_encode_cmd_open_remote_pipe(uint8_t *buffer, aci_cmd_params_open_remote_pipe_t *p_aci_cmd_params_open_remote_pipe);
-
-/** @brief Encode the ACI message for close remote pipe
- *
- *  @param[in,out]  buffer                              Pointer to ACI message buffer
- *  @param[in]      p_aci_cmd_params_close_remote_pipe   Pointer to the dynamic data parameters in ::aci_cmd_params_close_remote_pipe_t
- *
- *  @return         None
- */
-void acil_encode_cmd_close_remote_pipe(uint8_t *buffer, aci_cmd_params_close_remote_pipe_t *p_aci_cmd_params_close_remote_pipe);
-
-/** @brief Encode the ACI message for echo message
- *
- *  @param[in,out]  buffer             Pointer to ACI message buffer
- *  @param[in]      p_cmd_params_echo  Pointer to the dynamic data parameters in ::aci_cmd_params_echo_t
- *  @param[in]      msg_size           Size of the message
- *
- *  @return         None
- */
-void acil_encode_cmd_echo_msg(uint8_t *buffer, aci_cmd_params_echo_t *p_cmd_params_echo, uint8_t msg_size);
-
-/** @brief Encode the ACI message to battery level
- *
- *  @param[in,out]  buffer  Pointer to ACI message buffer
- *
- *  @return         None
- */
-void acil_encode_cmd_battery_level(uint8_t *buffer);
-
-/** @brief Encode the ACI message to temparature
- *
- *  @param[in,out]  buffer  Pointer to ACI message buffer
- *
- *  @return         None
- */
-void acil_encode_cmd_temparature(uint8_t *buffer);
-
-/** @brief Encode the ACI message to read dynamic data
- *
- *  @param[in,out]  buffer  Pointer to ACI message buffer
- *
- *  @return         None
- */
-void acil_encode_cmd_read_dynamic_data(uint8_t *buffer);
-
-/** @brief Encode the ACI message to change timing request
- *
- *  @param[in,out]  buffer  Pointer to ACI message buffer
- *  @param[in]      p_aci_cmd_params_change_timing  Pointer to the change timing parameters in ::aci_cmd_params_change_timing_t
- *
- *  @return         None
- */
-void acil_encode_cmd_change_timing_req(uint8_t *buffer, aci_cmd_params_change_timing_t *p_aci_cmd_params_change_timing);
-
-/** @brief Encode the ACI message to change timing request using the timing parameters from GAP PPCP
- *
- *  @param[in,out]  buffer  Pointer to ACI message buffer
- *  @param[in]      p_aci_cmd_params_change_timing  Pointer to the change timing parameters in ::aci_cmd_params_change_timing_t
- *
- *  @return         None
- */
-void acil_encode_cmd_change_timing_req_GAP_PPCP(uint8_t *buffer);
-
-
-/** @brief Encode the ACI message for write dynamic data
- *
- *  @param[in,out]  buffer                          Pointer to ACI message buffer
- *  @param[in]      seq_no                          Sequence number of the dynamic data (as received in the response to @c Read Dynamic Data)
- *  @param[in]      dynamic_data                    Pointer to the dynamic data
- *  @param[in]      dynamic_data_size               Size of dynamic data
- *
- *  @return         None
- */
-void acil_encode_cmd_write_dynamic_data(uint8_t *buffer, uint8_t seq_no, uint8_t* dynamic_data, uint8_t dynamic_data_size);
-
-/** @brief Encode the ACI message to send data acknowledgement
- *
- *  @param[in,out]  buffer  Pointer to ACI message buffer
- *  @param[in]      pipe_number Pipe number for which the ack is to be sent
- *
- *  @return         None
- */
-void acil_encode_cmd_send_data_ack(uint8_t *buffer, const uint8_t pipe_number);
-
-/** @brief Encode the ACI message to send negative acknowledgement
- *
- *  @param[in,out]  buffer  Pointer to ACI message buffer
- *  @param[in]    pipe_number Pipe number for which the nack is to be sent
- *  @param[in]    error_code Error code that has to be sent in the NACK
- *
- *  @return         None
- */
-void acil_encode_cmd_send_data_nack(uint8_t *buffer, const uint8_t pipe_number,const uint8_t error_code);
-
-/** @brief Encode the ACI message to set the application latency
- *
- *  @param[in,out]  buffer  Pointer to ACI message buffer
- *  @param[in]      p_aci_cmd_params_set_app_latency  Pointer to the set_application_latency command parameters in ::aci_cmd_params_dtm_cmd_t
- *
- *  @return         None
- */
-void acil_encode_cmd_set_app_latency(uint8_t *buffer, aci_cmd_params_set_app_latency_t *p_aci_cmd_params_set_app_latency);
-
-/** @brief Encode the ACI message for setup
- *
- *  @param[in,out]  buffer                          Pointer to ACI message buffer
- *  @param[in]      p_cmd_params_set_run_behaviour  Pointer to the setup data in ::aci_cmd_params_setup_t
- *  @param[in]      setup_data_size                 Size of setup message
- *
- *  @return         None
- */
-void acil_encode_cmd_setup(uint8_t *buffer, aci_cmd_params_setup_t *p_aci_cmd_params_setup, uint8_t setup_data_size);
-
-/** @brief Encode the ACI message for DTM command
- *
- *  @param[in,out]  buffer                          Pointer to ACI message buffer
- *  @param[in]      p_cmd_params_set_run_behaviour  Pointer to the DTM command parameters in ::aci_cmd_params_dtm_cmd_t
- *
- *  @return         None
- */
-void acil_encode_cmd_dtm_cmd(uint8_t *buffer, aci_cmd_params_dtm_cmd_t *p_aci_cmd_params_dtm_cmd);
-
-/** @brief Encode the ACI message for Set Key Request command
- *
- *  @param[in,out]  buffer      Pointer to ACI message buffer
- *
- *  @return         None
- */
-void acil_encode_cmd_set_key(uint8_t *buffer, aci_cmd_params_set_key_t *p_aci_cmd_params_set_key);
-
-/** @brief Encode the ACI message for Bond Security Request command
- *
- *  @param[in,out]  buffer      Pointer to ACI message buffer
- *
- *  @return         None
- */
-void acil_encode_cmd_bond_security_request(uint8_t *buffer);
-
-/** @brief Encode the ACI message
- *
- *  @param[in,out]  buffer      Pointer to ACI message buffer
- *  @param[in]      p_aci_cmd   Pointer to ACI command data in ::aci_cmd_t
- *  @param[in]      bool
- *
- *  @return         bool         true, if succesful, else returns false
- */
-bool acil_encode_cmd(uint8_t *buffer, aci_cmd_t *p_aci_cmd);
-
-/** @brief Encode the ACI message for Broadcast command
- *
- *  @param[in,out]  buffer      Pointer to ACI message buffer
- *  @param[in]      p_aci_cmd   Pointer to ACI command data in ::aci_cmd_params_broadcast_t
- *
- *  @return         None
- */
-void acil_encode_cmd_broadcast(uint8_t *buffer,  aci_cmd_params_broadcast_t * p_aci_cmd_params_broadcast);
-
-/** @brief Encode the ACI message for Open Adv Pipes
- *
- *  @param[in,out]  buffer      Pointer to ACI message buffer
- *  @param[in]      p_aci_cmd   Pointer to ACI command data in ::aci_cmd_params_open_adv_pipe_t
- *
- *  @return         None
- */
-void acil_encode_cmd_open_adv_pipes(uint8_t *buffer, aci_cmd_params_open_adv_pipe_t * p_aci_cmd_params_set_adv_svc_data);
-
-/** @brief Decode the ACI event command response
- *
- *  @param[in]      buffer_in  Pointer to message received
- *  @param[in,out]  buffer     Pointer to the decoded message in ::aci_evt_params_cmd_rsp_t
- *
- *  @return         None
- */
-void acil_decode_evt_command_response(uint8_t *buffer_in, aci_evt_params_cmd_rsp_t *p_evt_params_cmd_rsp);
-
-/** @brief Decode the ACI event device started
- *
- *  @param[in]      buffer_in  Pointer to message received
- *  @param[in,out]  p_aci_evt  Pointer to the decoded message in ::aci_evt_params_device_started_t
- *
- *  @return         None
- */
-void acil_decode_evt_device_started(uint8_t *buffer_in, aci_evt_params_device_started_t *p_evt_params_device_started);
-
-/** @brief Decode the ACI event pipe status
- *
- *  @param[in]      buffer_in  Pointer to message received
- *  @param[in,out]  p_aci_evt_params_pipe_status  Pointer to the decoded message in ::aci_evt_params_pipe_status_t
- *
- *  @return         None
- */
-void acil_decode_evt_pipe_status(uint8_t *buffer_in, aci_evt_params_pipe_status_t *p_aci_evt_params_pipe_status);
-
-/** @brief Decode the ACI event for disconnected
- *
- *  @param[in]      buffer_in                      Pointer to message received
- *  @param[in,out]  p_aci_evt_params_disconnected  Pointer to the decoded message in ::aci_evt_params_disconnected_t
- *
- *  @return         None
- */
-void acil_decode_evt_disconnected(uint8_t *buffer_in, aci_evt_params_disconnected_t *p_aci_evt_params_disconnected);
-
-/** @brief Decode the ACI event for bond status
- *
- *  @param[in]      buffer_in                     Pointer to message received
- *  @param[in,out]  p_aci_evt_params_bond_status  Pointer to the decoded message in ::aci_evt_params_bond_status_t
- *
- *  @return         None
- */
-void acil_decode_evt_bond_status(uint8_t *buffer_in, aci_evt_params_bond_status_t *p_aci_evt_params_bond_status);
-
-/** @brief Decode the ACI event for data received
- *
- *  @param[in]      buffer_in                   Pointer to message received
- *  @param[in,out]  p_evt_params_data_received  Pointer to the decoded message in ::aci_evt_params_data_received_t
- *
- *  @return         size                        Received data size
- */
-uint8_t acil_decode_evt_data_received(uint8_t *buffer_in, aci_evt_params_data_received_t *p_evt_params_data_received);
-
-/** @brief Decode the ACI event data acknowledgement
- *
- *  @param[in]      buffer_in               Pointer to message received
- *  @param[in,out]  p_evt_params_data_ack   Pointer to the decoded message in ::aci_evt_params_data_ack_t
- *
- *  @return         None
- */
-void acil_decode_evt_data_ack(uint8_t *buffer_in, aci_evt_params_data_ack_t *p_evt_params_data_ack);
-
-/** @brief Decode the ACI event for hardware error
- *
- *  @param[in]      buffer_in                  Pointer to message received
- *  @param[in,out]  p_aci_evt_params_hw_error  Pointer to the decoded message in ::aci_evt_params_hw_error_t
- *
- *  @return         size                     Size of debug information
- */
-uint8_t acil_decode_evt_hw_error(uint8_t *buffer_in, aci_evt_params_hw_error_t *p_aci_evt_params_hw_error);
-
-/** @brief Decode the ACI event data credit
- *
- *  @param[in]      buffer_in                 Pointer to message received
- *  @param[in,out]  p_evt_params_data_credit  Pointer to the decoded message in ::aci_evt_params_data_credit_t
- *
- *  @return         None
- */
-void acil_decode_evt_credit(uint8_t *buffer_in, aci_evt_params_data_credit_t *p_evt_params_data_credit);
-
-/** @brief Decode the ACI event for connected
- *
- *  @param[in]      buffer_in                   Pointer to message received
- *  @param[in,out]  p_aci_evt_params_connected  Pointer to the decoded message in ::aci_evt_params_connected_t
- *
- *  @return         None
- */
-void acil_decode_evt_connected(uint8_t *buffer_in, aci_evt_params_connected_t *p_aci_evt_params_connected);
-
-/** @brief Decode the ACI event for timing
- *
- *  @param[in]      buffer_in             Pointer to message received
- *  @param[in,out]  p_evt_params_timing   Pointer to the decoded message in ::aci_evt_params_timing_t
- *
- *  @return         None
- */
-void acil_decode_evt_timing(uint8_t *buffer_in, aci_evt_params_timing_t *p_evt_params_timing);
-
-/** @brief Decode the ACI event for pipe error
- *
- *  @param[in]      buffer_in                 Pointer to message received
- *  @param[in,out]  p_evt_params_pipe_error   Pointer to the decoded message in ::aci_evt_params_pipe_error_t
- *
- */
-void acil_decode_evt_pipe_error(uint8_t *buffer_in, aci_evt_params_pipe_error_t *p_evt_params_pipe_error);
-
-/** @brief Decode the ACI event for key request
- *
- *  @param[in]      buffer_in               Pointer to message received
- *  @param[in,out]  p_evt_params_key_type   Pointer to the decoded message in ::aci_evt_params_key_type_t
- *
- *  @return         None
- */
-void acil_decode_evt_key_request(uint8_t *buffer_in, aci_evt_params_key_request_t *p_evt_params_key_request);
-
-/** @brief Decode the ACI event for echo
- *
- *  @param[in]      buffer_in    Pointer to message received
- *  @param[in,out]  buffer_out   Pointer to the echo message (max size of buffer ::ACI_ECHO_DATA_MAX_LEN)
- *
- *  @return         size         Received echo message size
- */
-uint8_t acil_decode_evt_echo(uint8_t *buffer_in, aci_evt_params_echo_t *buffer_out);
-
-/** @brief Decode the ACI event
- *
- *  @param[in]      buffer_in   Pointer to message received
- *  @param[in,out]  p_aci_evt   Pointer to the decoded message in ::aci_evt_t
- *
- *  @return         bool         true, if succesful, else returns false
- */
-bool acil_decode_evt(uint8_t *buffer_in, aci_evt_t *p_aci_evt);
-
-/** @brief Decode the Display Key Event
- *
- *  @param[in]      buffer_in   Pointer to message received
- *  @param[in,out]  p_aci_evt   Pointer to the decoded message in ::aci_evt_params_display_passkey_t
- *
- *  @return         None
- */
-void acil_decode_evt_display_passkey(uint8_t *buffer_in, aci_evt_params_display_passkey_t *p_aci_evt_params_display_passkey);
-
-#endif /* _acilib_IF_H_ */
diff --git a/src/nrf8001/acilib_types.h b/src/nrf8001/acilib_types.h
deleted file mode 100644
index 5c42739..0000000
--- a/src/nrf8001/acilib_types.h
+++ /dev/null
@@ -1,33 +0,0 @@
-/* Copyright (c) 2014, Nordic Semiconductor ASA
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-/**
- * @file
- *
- * @ingroup aci-lib
- *
- * @brief Type used in the acilib interfaces
- */
-
-#ifndef _acilib_TYPES_H_
-#define _acilib_TYPES_H_
-
-#endif /* _acilib_TYPES_H_ */
diff --git a/src/nrf8001/boards.h b/src/nrf8001/boards.h
deleted file mode 100644
index 64bb4cb..0000000
--- a/src/nrf8001/boards.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/* Copyright (c) 2014, Nordic Semiconductor ASA
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-/** 
- * @file
- * @brief Defines for the different Bluetooth low energy boards
- * @ingroup nrf8001
- */
-
-#ifndef _BLE_BOARDS_H_
-#define _BLE_BOARDS_H_
-
-#define BOARD_DEFAULT               0 /**< Use this if you do not know the board you are using or you are creating a new one */
-#define REDBEARLAB_SHIELD_V1_1      1 /**< Redbearlab Bluetooth low energy shield v1.1 */
-#define REDBEARLAB_SHIELD_V2012_07  1 /**< Identical to Redbearlab v1.1 shield */
-#define REDBEARLAB_SHIELD_V2        0 /**< Redbearlab Bluetooth low energy shield v2.x - No special handling required for pin reset same as default */
-
-#endif
diff --git a/src/nrf8001/dtm.h b/src/nrf8001/dtm.h
deleted file mode 100644
index b6ddf56..0000000
--- a/src/nrf8001/dtm.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/* Copyright (c) 2014, Nordic Semiconductor ASA
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-/**
- * @file
- *
- * @ingroup aci-lib
- *
- * @brief Internal prototype for acilib module.
- */
-
-#ifndef DTM_H__
-#define DTM_H__
-
-/** @brief DTM command codes (upper two bits in the DTM command), use a bitwise OR with the frequency N = 0x00 - 0x27: N = (F-2402)/2 Frequency Range 2402 MHz
-to 2480 MHz*/
-#define DTM_LE_CMD_RESET            0x00 /**< DTM reset command code */
-#define DTM_LE_CMD_RECEIVER_TEST    0x40 /**< DTM receiver test command code */
-#define DTM_LE_CMD_TRANSMITTER_TEST 0x80 /**< DTM transmitter test command code */
-#define DTM_LE_CMD_TEST_END         0xC0 /**< DTM test end command code */
-
-
-/** @brief Defined packet types for DTM */
-#define DTM_LE_PKT_PRBS9      0x00       /**< Bit pattern PRBS9.    */
-#define DTM_LE_PKT_0X0F       0x01       /**< Bit pattern 11110000 (LSB is the leftmost bit). */
-#define DTM_LE_PKT_0X55       0x02       /**< Bit pattern 10101010 (LSB is the leftmost bit). */
-#define DTM_LE_PKT_VENDOR     0x03       /**< Vendor specific. Nordic: continous carrier test */
-
-/** @brief Defined bit fields for DTM responses. */
-#define LE_PACKET_REPORTING_EVENT_MSB_BIT   0x80 /**< Bit field for most significant bit */
-#define LE_TEST_STATUS_EVENT_LSB_BIT        0x01 /**< Bit field for least significant bit */
-
-/** @brief DTM response types. */
-#define LE_TEST_STATUS_EVENT                0x00 /**< DTM event response */
-#define LE_TEST_PACKET_REPORT_EVENT         0x80 /**< DTM packet report reponse */
-
-/** @brief DTM return values. */
-#define LE_TEST_STATUS_SUCCESS              0x00 /**< DTM success return value */
-#define LE_TEST_STATUS_FAILURE              0x01 /**< DTM failure return value */
-
-
-
-#endif //DTM_H__
-
-/** @} */
diff --git a/src/nrf8001/hal_aci_tl.cpp b/src/nrf8001/hal_aci_tl.cpp
deleted file mode 100644
index e029109..0000000
--- a/src/nrf8001/hal_aci_tl.cpp
+++ /dev/null
@@ -1,460 +0,0 @@
-/* Copyright (c) 2014, Nordic Semiconductor ASA
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-/** @file
-@brief Implementation of the ACI transport layer module
-*/
-
-#include <string>
-#include <stdexcept>
-#include <stdio.h>
-
-#include "hal_platform.h"
-#include "hal_aci_tl.h"
-#include "aci_queue.h"
-
-#define HIGH                    1
-#define LOW                     0
-
-#define REVERSE_BITS(byte) (((reverse_lookup[(byte & 0x0F)]) << 4) + reverse_lookup[((byte & 0xF0) >> 4)])
-static const uint8_t reverse_lookup[] = { 0, 8,  4, 12, 2, 10, 6, 14,1, 9, 5, 13,3, 11, 7, 15 };
-
-static void m_aci_data_print(hal_aci_data_t *p_data);
-static void m_aci_event_check(void);
-//static void m_aci_isr(void);
-static void m_aci_pins_set(aci_pins_t *a_pins_ptr);
-static inline void m_aci_reqn_disable (void);
-static inline void m_aci_reqn_enable (void);
-static void m_aci_q_flush(void);
-static bool m_aci_spi_transfer(hal_aci_data_t * data_to_send, hal_aci_data_t * received_data);
-
-static uint8_t        spi_readwrite(uint8_t aci_byte);
-
-static bool           aci_debug_print = false;
-
-aci_queue_t    aci_tx_q;
-aci_queue_t    aci_rx_q;
-
-static aci_pins_t    *a_pins_local_ptr;
-
-void m_aci_data_print(hal_aci_data_t *p_data)
-{
-  const uint8_t length = p_data->buffer[0];
-  uint8_t i;
-  printf("%d\n", length);
-  printf(" :\n");
-  for (i=0; i<=length; i++)
-  {
-    printf("%x", p_data->buffer[i]);
-    printf(", ");
-  }
-  printf("\n");
-}
-
-/*
-  Interrupt service routine called when the RDYN line goes low. Runs the SPI transfer.
-*/
-// Not used, commenting out.  Noel Eck 2016/11/02
-//static void m_aci_isr(void)
-//{
-//  hal_aci_data_t data_to_send;
-//  hal_aci_data_t received_data;
-//
-//  // Receive from queue
-//  if (!aci_queue_dequeue_from_isr(&aci_tx_q, &data_to_send))
-//  {
-//    /* queue was empty, nothing to send */
-//    data_to_send.status_byte = 0;
-//    data_to_send.buffer[0] = 0;
-//  }
-//
-//  // Receive and/or transmit data
-//  m_aci_spi_transfer(&data_to_send, &received_data);
-//
-//  if (!aci_queue_is_full_from_isr(&aci_rx_q) && !aci_queue_is_empty_from_isr(&aci_tx_q))
-//  {
-//    m_aci_reqn_enable();
-//  }
-//
-//  // Check if we received data
-//  if (received_data.buffer[0] > 0)
-//  {
-//    if (!aci_queue_enqueue_from_isr(&aci_rx_q, &received_data))
-//    {
-//      /* Receive Buffer full.
-//         Should never happen.
-//         Spin in a while loop.
-//      */
-//      while(1);
-//    }
-//
-//    // Disable ready line interrupt until we have room to store incoming messages
-//    if (aci_queue_is_full_from_isr(&aci_rx_q))
-//    {
-//      // detachInterrupt(a_pins_local_ptr->interrupt_number);
-//    }
-//  }
-//
-//  return;
-//}
-
-/*
-  Checks the RDYN line and runs the SPI transfer if required.
-*/
-static void m_aci_event_check(void)
-{
-  hal_aci_data_t data_to_send;
-  hal_aci_data_t received_data;
-
-  // No room to store incoming messages
-  if (aci_queue_is_full(&aci_rx_q))
-  {
-    return;
-  }
-
-  // If the ready line is disabled and we have pending messages outgoing we enable the request line
-  if (HIGH == mraa_gpio_read (a_pins_local_ptr->m_rdy_ctx))
-  // if (HIGH == digitalRead(a_pins_local_ptr->rdyn_pin))
-  {
-    if (!aci_queue_is_empty(&aci_tx_q))
-    {
-      m_aci_reqn_enable();
-    }
-
-    return;
-  }
-
-  // Receive from queue
-  if (!aci_queue_dequeue(&aci_tx_q, &data_to_send))
-  {
-    /* queue was empty, nothing to send */
-    data_to_send.status_byte = 0;
-    data_to_send.buffer[0] = 0;
-  }
-
-  // Receive and/or transmit data
-  m_aci_spi_transfer(&data_to_send, &received_data);
-
-  /* If there are messages to transmit, and we can store the reply, we request a new transfer */
-  if (!aci_queue_is_full(&aci_rx_q) && !aci_queue_is_empty(&aci_tx_q))
-  {
-    m_aci_reqn_enable();
-  }
-
-  // Check if we received data
-  if (received_data.buffer[0] > 0)
-  {
-    if (!aci_queue_enqueue(&aci_rx_q, &received_data))
-    {
-      /* Receive Buffer full.
-         Should never happen.
-         Spin in a while loop.
-      */
-      while(1);
-    }
-  }
-
-  return;
-}
-
-/** @brief Point the low level library at the ACI pins specified
- *  @details
- *  The ACI pins are specified in the application and a pointer is made available for
- *  the low level library to use
- */
-static void m_aci_pins_set(aci_pins_t *a_pins_ptr)
-{
-  a_pins_local_ptr = a_pins_ptr;
-}
-
-static inline void m_aci_reqn_disable (void)
-{
-    mraa_gpio_write (a_pins_local_ptr->m_req_ctx, HIGH);
-}
-
-static inline void m_aci_reqn_enable (void)
-{
-    mraa_gpio_write (a_pins_local_ptr->m_req_ctx, LOW);
-}
-
-static void m_aci_q_flush(void)
-{
-  // noInterrupts();
-  /* re-initialize aci cmd queue and aci event queue to flush them*/
-  aci_queue_init(&aci_tx_q);
-  aci_queue_init(&aci_rx_q);
-  // interrupts();
-}
-
-static bool m_aci_spi_transfer(hal_aci_data_t * data_to_send, hal_aci_data_t * received_data)
-{
-  uint8_t byte_cnt;
-  uint8_t byte_sent_cnt;
-  uint8_t max_bytes;
-
-  m_aci_reqn_enable();
-
-  // Send length, receive header
-  byte_sent_cnt = 0;
-  received_data->status_byte = spi_readwrite(data_to_send->buffer[byte_sent_cnt++]);
-  // Send first byte, receive length from slave
-  received_data->buffer[0] = spi_readwrite(data_to_send->buffer[byte_sent_cnt++]);
-  if (0 == data_to_send->buffer[0])
-  {
-    max_bytes = received_data->buffer[0];
-  }
-  else
-  {
-    // Set the maximum to the biggest size. One command byte is already sent
-    max_bytes = (received_data->buffer[0] > (data_to_send->buffer[0] - 1))
-                                          ? received_data->buffer[0]
-                                          : (data_to_send->buffer[0] - 1);
-  }
-
-  if (max_bytes > HAL_ACI_MAX_LENGTH)
-  {
-    max_bytes = HAL_ACI_MAX_LENGTH;
-  }
-
-  // Transmit/receive the rest of the packet (skip first byte - cmd)
-  for (byte_cnt = 1; byte_cnt < max_bytes; byte_cnt++)
-  {
-    received_data->buffer[byte_cnt] =  spi_readwrite(data_to_send->buffer[byte_sent_cnt++]);
-  }
-
-  // RDYN should follow the REQN line in approx 100ns
-  m_aci_reqn_disable();
-
-  return (max_bytes > 0);
-}
-
-void hal_aci_tl_debug_print(bool enable)
-{
-    aci_debug_print = enable;
-}
-
-void hal_aci_tl_pin_reset(void)
-{
-    if (UNUSED != a_pins_local_ptr->reset_pin)
-    {
-        // pinMode(a_pins_local_ptr->reset_pin, OUTPUT);
-
-        if ((REDBEARLAB_SHIELD_V1_1     == a_pins_local_ptr->board_name) ||
-            (REDBEARLAB_SHIELD_V2012_07 == a_pins_local_ptr->board_name))
-        {
-            //The reset for the Redbearlab v1.1 and v2012.07 boards are inverted and has a Power On Reset
-            //circuit that takes about 100ms to trigger the reset
-            mraa_gpio_write (a_pins_local_ptr->m_rst_ctx, HIGH);
-            usleep (100000);
-            mraa_gpio_write (a_pins_local_ptr->m_rst_ctx, LOW);
-        }
-        else
-        {
-            mraa_gpio_write (a_pins_local_ptr->m_rst_ctx, HIGH);
-            mraa_gpio_write (a_pins_local_ptr->m_rst_ctx, LOW);
-            mraa_gpio_write (a_pins_local_ptr->m_rst_ctx, HIGH);
-        }
-    }
-}
-
-bool hal_aci_tl_event_peek(hal_aci_data_t *p_aci_data)
-{
-  if (!a_pins_local_ptr->interface_is_interrupt)
-  {
-    m_aci_event_check();
-  }
-
-  if (aci_queue_peek(&aci_rx_q, p_aci_data))
-  {
-    return true;
-  }
-
-  return false;
-}
-
-bool hal_aci_tl_event_get(hal_aci_data_t *p_aci_data)
-{
-  bool was_full;
-
-  if (!a_pins_local_ptr->interface_is_interrupt && !aci_queue_is_full(&aci_rx_q))
-  {
-    m_aci_event_check();
-  }
-
-  was_full = aci_queue_is_full(&aci_rx_q);
-
-  if (aci_queue_dequeue(&aci_rx_q, p_aci_data))
-  {
-    if (aci_debug_print)
-    {
-      printf(" E");
-      m_aci_data_print(p_aci_data);
-    }
-
-    if (was_full && a_pins_local_ptr->interface_is_interrupt)
-    {
-      /* Enable RDY line interrupt again */
-      // attachInterrupt(a_pins_local_ptr->interrupt_number, m_aci_isr, LOW);
-    }
-
-    /* Attempt to pull REQN LOW since we've made room for new messages */
-    if (!aci_queue_is_full(&aci_rx_q) && !aci_queue_is_empty(&aci_tx_q))
-    {
-      m_aci_reqn_enable();
-    }
-
-    return true;
-  }
-
-  return false;
-}
-
-void hal_aci_tl_init(aci_pins_t *a_pins, bool debug)
-{
-    mraa_result_t error = MRAA_SUCCESS;
-    aci_debug_print = debug;
-
-    /* Needs to be called as the first thing for proper intialization*/
-    m_aci_pins_set(a_pins);
-
-    /*
-     * Init SPI
-     */
-    a_pins->m_spi = mraa_spi_init (0);
-    if (a_pins->m_spi == NULL) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_spi_init() failed");
-    }
-
-    mraa_spi_frequency (a_pins->m_spi, 2000000);
-    mraa_spi_mode (a_pins->m_spi, MRAA_SPI_MODE0);
-
-    /* Initialize the ACI Command queue. This must be called after the delay above. */
-    aci_queue_init(&aci_tx_q);
-    aci_queue_init(&aci_rx_q);
-
-    // Configure the IO lines
-    a_pins->m_rdy_ctx = mraa_gpio_init (a_pins->rdyn_pin);
-    if (a_pins->m_rdy_ctx == NULL) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_gpio_init(rdyn) failed, invalid pin?");
-    }
-
-    a_pins->m_req_ctx = mraa_gpio_init (a_pins->reqn_pin);
-    if (a_pins->m_req_ctx == NULL) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_gpio_init(reqn) failed, invalid pin?");
-    }
-
-    a_pins->m_rst_ctx = mraa_gpio_init (a_pins->reset_pin);
-    if (a_pins->m_rst_ctx == NULL) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_gpio_init(reset) failed, invalid pin?");
-    }
-
-    error = mraa_gpio_dir (a_pins->m_rdy_ctx, MRAA_GPIO_IN);
-    if (error != MRAA_SUCCESS) {
-        printf ("[ERROR] GPIO failed to initialize \n");
-    }
-
-    error = mraa_gpio_dir (a_pins->m_req_ctx, MRAA_GPIO_OUT);
-    if (error != MRAA_SUCCESS) {
-        printf ("[ERROR] GPIO failed to initialize \n");
-    }
-
-    error = mraa_gpio_dir (a_pins->m_rst_ctx, MRAA_GPIO_OUT);
-    if (error != MRAA_SUCCESS) {
-        printf ("[ERROR] GPIO failed to initialize \n");
-    }
-
-    if (UNUSED != a_pins->active_pin) {
-    }
-
-  /* Pin reset the nRF8001, required when the nRF8001 setup is being changed */
-  hal_aci_tl_pin_reset();
-
-  /* Set the nRF8001 to a known state as required by the datasheet*/
-  mraa_gpio_write (a_pins->m_req_ctx, LOW);
-
-  usleep(30000); //Wait for the nRF8001 to get hold of its lines - the lines float for a few ms after the reset
-
-    /* Attach the interrupt to the RDYN line as requested by the caller */
-    if (a_pins->interface_is_interrupt) {
-        // We use the LOW level of the RDYN line as the atmega328 can wakeup from sleep only on LOW
-        // attachInterrupt(a_pins->interrupt_number, m_aci_isr, LOW);
-    }
-}
-
-bool hal_aci_tl_send(hal_aci_data_t *p_aci_cmd)
-{
-  const uint8_t length = p_aci_cmd->buffer[0];
-  bool ret_val = false;
-
-  if (length > HAL_ACI_MAX_LENGTH)
-  {
-    return false;
-  }
-
-  ret_val = aci_queue_enqueue(&aci_tx_q, p_aci_cmd);
-  if (ret_val)
-  {
-    if(!aci_queue_is_full(&aci_rx_q))
-    {
-      // Lower the REQN only when successfully enqueued
-      m_aci_reqn_enable();
-    }
-  }
-
-  return ret_val;
-}
-
-static uint8_t spi_readwrite(const uint8_t aci_byte)
-{
-    uint8_t reversed, ret;
-    reversed = mraa_spi_write (a_pins_local_ptr->m_spi, REVERSE_BITS (aci_byte));
-    ret = REVERSE_BITS (reversed);
-    return ret;
-}
-
-bool hal_aci_tl_rx_q_empty (void)
-{
-  return aci_queue_is_empty(&aci_rx_q);
-}
-
-bool hal_aci_tl_rx_q_full (void)
-{
-  return aci_queue_is_full(&aci_rx_q);
-}
-
-bool hal_aci_tl_tx_q_empty (void)
-{
-  return aci_queue_is_empty(&aci_tx_q);
-}
-
-bool hal_aci_tl_tx_q_full (void)
-{
-  return aci_queue_is_full(&aci_tx_q);
-}
-
-void hal_aci_tl_q_flush (void)
-{
-  m_aci_q_flush();
-}
diff --git a/src/nrf8001/hal_aci_tl.h b/src/nrf8001/hal_aci_tl.h
deleted file mode 100644
index e2a12a6..0000000
--- a/src/nrf8001/hal_aci_tl.h
+++ /dev/null
@@ -1,189 +0,0 @@
-/* Copyright (c) 2014, Nordic Semiconductor ASA
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-/** 
- * @file
- * @brief Interface for hal_aci_tl.
- * @ingroup nrf8001
- */
-
-/**
-@{
-
-@brief Module for the ACI Transport Layer interface
-@details This module is responsible for sending and receiving messages over the ACI interface of the nRF8001 chip.
- The hal_aci_tl_send_cmd() can be called directly to send ACI commands.
-
-
-The RDYN line is hooked to an interrupt on the MCU when the level is low.
-The SPI master clocks in the interrupt context.
-The ACI Command is taken from the head of the command queue is sent over the SPI
-and the received ACI event is placed in the tail of the event queue.
-
-*/
-
-#ifndef HAL_ACI_TL_H__
-#define HAL_ACI_TL_H__
-
-#include "hal_platform.h"
-#include "aci.h"
-#include "boards.h"
-
-#include <mraa/aio.h>
-#include <mraa/gpio.h>
-#include <mraa/spi.h>
-
-#ifndef HAL_ACI_MAX_LENGTH
-#define HAL_ACI_MAX_LENGTH 31
-#endif
-
-/************************************************************************/
-/* Unused nRF8001 pin                                                    */
-/************************************************************************/
-#define UNUSED          255
-
-/** Data type for ACI commands and events */
-typedef struct {
-  uint8_t status_byte;
-  uint8_t buffer[HAL_ACI_MAX_LENGTH+1];
-} _aci_packed_ hal_aci_data_t;
-
-ACI_ASSERT_SIZE(hal_aci_data_t, HAL_ACI_MAX_LENGTH + 2);
-
-/** Datatype for ACI pins and interface (polling/interrupt)*/
-typedef struct aci_pins_t
-{
-    mraa_spi_context        m_spi;
-    mraa_gpio_context       m_rdy_ctx;
-    mraa_gpio_context       m_req_ctx;
-    mraa_gpio_context       m_rst_ctx;
-
-    uint8_t board_name;             //Optional : Use BOARD_DEFAULT if you do not know. See boards.h
-    uint8_t reqn_pin;               //Required
-    uint8_t rdyn_pin;               //Required
-    uint8_t mosi_pin;               //Required
-    uint8_t miso_pin;               //Required
-    uint8_t sck_pin;                //Required
-
-    uint8_t spi_clock_divider;      //Required : Clock divider on the SPI clock : nRF8001 supports a maximum clock of 3MHz
-
-    uint8_t reset_pin;              //Recommended but optional - Set it to UNUSED when not connected
-    uint8_t active_pin;             //Optional - Set it to UNUSED when not connected
-    uint8_t optional_chip_sel_pin;  //Optional - Used only when the reqn line is required to be separate from the SPI chip select. Eg. Arduino DUE
-
-    bool    interface_is_interrupt; //Required - true = Uses interrupt on RDYN pin. false - Uses polling on RDYN pin
-
-    uint8_t interrupt_number;       //Required when using interrupts, otherwise ignored
-} aci_pins_t;
-
-/** @brief ACI Transport Layer initialization.
- *  @details
- *  This function initializes the transport layer, including configuring the SPI, creating
- *  message queues for Commands and Events and setting up interrupt if required.
- *  @param a_pins Pins on the MCU used to connect to the nRF8001
- *  @param bool True if debug printing should be enabled on the Serial.
- */
-void hal_aci_tl_init(aci_pins_t *a_pins, bool debug);
-
-/** @brief Sends an ACI command to the radio.
- *  @details
- *  This function sends an ACI command to the radio. This queue up the message to send and
- *  lower the request line. When the device lowers the ready line, @ref m_aci_spi_transfer()
- *  will send the data.
- *  @param aci_buffer Pointer to the message to send.
- *  @return True if the data was successfully queued for sending,
- *  false if there is no more space to store messages to send.
- */
-bool hal_aci_tl_send(hal_aci_data_t *aci_buffer);
-
-/** @brief Process pending transactions.
- *  @details
- *  The library code takes care of calling this function to check if the nRF8001 RDYN line indicates a
- *  pending transaction. It will send a pending message if there is one and return any receive message
- *  that was pending.
- *  @return Points to data buffer for received data. Length byte in buffer is 0 if no data received.
- */
-//hal_aci_data_t * hal_aci_tl_poll_get(void);
-
-/** @brief Get an ACI event from the event queue
- *  @details
- *  Call this function from the main context to get an event from the ACI event queue
- *  This is called by lib_aci_event_get
- */
-bool hal_aci_tl_event_get(hal_aci_data_t *p_aci_data);
-
-/** @brief Peek an ACI event from the event queue
- *  @details
- *  Call this function from the main context to peek an event from the ACI event queue.
- *  This is called by lib_aci_event_peek
- */
-bool hal_aci_tl_event_peek(hal_aci_data_t *p_aci_data);
-
-/** @brief Enable debug printing of all ACI commands sent and ACI events received
- *  @details
- *  when the enable parameter is true. The debug printing is enabled on the Serial.
- *  When the enable parameter is false. The debug printing is disabled on the Serial.
- *  By default the debug printing is disabled.
- */
-void hal_aci_tl_debug_print(bool enable);
-
-
-/** @brief Pin reset the nRF8001
- *  @details
- *  The reset line of the nF8001 needs to kept low for 200 ns.
- *  Redbearlab shield v1.1 and v2012.07 are exceptions as they
- *  have a Power ON Reset circuit that works differently.
- *  The function handles the exceptions based on the board_name in aci_pins_t
- */
-void hal_aci_tl_pin_reset(void);
-
-/** @brief Return full status of transmit queue
- *  @details
- *
- */
- bool hal_aci_tl_rx_q_full(void);
-
- /** @brief Return empty status of receive queue
- *  @details
- *
- */
- bool hal_aci_tl_rx_q_empty(void);
-
-/** @brief Return full status of receive queue
- *  @details
- *
- */
- bool hal_aci_tl_tx_q_full(void);
-
- /** @brief Return empty status of transmit queue
- *  @details
- *
- */
- bool hal_aci_tl_tx_q_empty(void);
-
-/** @brief Flush the ACI command Queue and the ACI Event Queue
- *  @details
- *  Call this function in the main thread
- */
-void hal_aci_tl_q_flush(void);
-
-#endif // HAL_ACI_TL_H__
-/** @} */
diff --git a/src/nrf8001/hal_platform.h b/src/nrf8001/hal_platform.h
deleted file mode 100644
index 9ef7fbe..0000000
--- a/src/nrf8001/hal_platform.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/* Copyright (c) 2014, Nordic Semiconductor ASA
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-/**
- * @file
- * @brief HAL specific macros
- * @ingroup nrf8001
- */
- 
-#ifndef PLATFORM_H__
-#define PLATFORM_H__
-
-//Board dependent defines
-#if defined (__AVR__)
-    //For Arduino this AVR specific library has to be used for reading from Flash memory
-    #include <avr/pgmspace.h>
-    #include "Arduino.h"
-    #ifdef PROGMEM
-        #undef PROGMEM
-        #define PROGMEM __attribute__(( section(".progmem.data") ))
-        #endif
-#elif defined(__PIC32MX__)
-    //For Chipkit add the following libraries.
-    #include <stdint.h>
-    #include <stdbool.h>
-    #include <string.h>
-    #include <wiring.h>
-    #include <WProgram.h>
-
-    //For making the Serial.Print compatible between Arduino and Chipkit
-    #define F(X) (X)
-
-    //For ChipKit neither PROGMEM or PSTR are needed for PIC32
-    #define PROGMEM
-    #define PSTR(s) (s)
-
-    #define pgm_read_byte(x)            (*((char *)x))
-    #define pgm_read_byte_near(x)   (*((char *)x))
-    #define pgm_read_byte_far(x)        (*((char *)x))
-    #define pgm_read_word(x)            (*((short *)x))
-    #define pgm_read_word_near(x)   (*((short *)x))
-    #define pgm_read_workd_far(x)   (*((short *)x))
-
-    #define prog_void       const void
-    #define prog_char       const char
-    #define prog_uchar      const unsigned char
-    #define prog_int8_t     const int8_t
-    #define prog_uint8_t    const uint8_t
-    #define prog_int16_t    const int16_t
-    #define prog_uint16_t   const uint16_t
-    #define prog_int32_t    const int32_t
-    #define prog_uint32_t   const uint32_t
-    #define prog_int64_t    const int64_t
-    #define prog_uint64_t   const uint64_t
-
-    //Redefine the function for reading from flash in ChipKit
-    #define memcpy_P        memcpy
-#endif
-
-#endif /* PLATFORM_H__ */
diff --git a/src/nrf8001/lib_aci.cpp b/src/nrf8001/lib_aci.cpp
deleted file mode 100644
index 5655f61..0000000
--- a/src/nrf8001/lib_aci.cpp
+++ /dev/null
@@ -1,742 +0,0 @@
-/* Copyright (c) 2014, Nordic Semiconductor ASA
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-/** @file
-  @brief Implementation of the ACI library.
- */
-
-#include "hal_platform.h"
-#include "aci.h"
-#include "aci_cmds.h"
-#include "aci_evts.h"
-#include "aci_protocol_defines.h"
-#include "acilib_defs.h"
-#include "acilib_if.h"
-#include "hal_aci_tl.h"
-#include "aci_queue.h"
-#include "lib_aci.h"
-
-
-#define LIB_ACI_DEFAULT_CREDIT_NUMBER   1
-
-/*
-Global additionally used used in aci_setup
-*/
-hal_aci_data_t  msg_to_send;
-
-
-static services_pipe_type_mapping_t * p_services_pipe_type_map;
-static hal_aci_data_t *               p_setup_msgs;
-
-
-
-
-static bool is_request_operation_pending;
-static bool is_indicate_operation_pending;
-static bool is_open_remote_pipe_pending;
-static bool is_close_remote_pipe_pending;
-
-static uint8_t request_operation_pipe = 0;
-static uint8_t indicate_operation_pipe = 0;
-
-
-// The following structure (aci_cmd_params_open_adv_pipe) will be used to store the complete command
-// including the pipes to be opened.
-static aci_cmd_params_open_adv_pipe_t aci_cmd_params_open_adv_pipe;
-
-
-
-extern aci_queue_t    aci_rx_q;
-extern aci_queue_t    aci_tx_q;
-
-bool lib_aci_is_pipe_available(aci_state_t *aci_stat, uint8_t pipe)
-{
-  uint8_t byte_idx;
-
-  byte_idx = pipe / 8;
-  if (aci_stat->pipes_open_bitmap[byte_idx] & (0x01 << (pipe % 8)))
-  {
-    return(true);
-  }
-  return(false);
-}
-
-
-bool lib_aci_is_pipe_closed(aci_state_t *aci_stat, uint8_t pipe)
-{
-  uint8_t byte_idx;
-
-  byte_idx = pipe / 8;
-  if (aci_stat->pipes_closed_bitmap[byte_idx] & (0x01 << (pipe % 8)))
-  {
-    return(true);
-  }
-  return(false);
-}
-
-
-bool lib_aci_is_discovery_finished(aci_state_t *aci_stat)
-{
-  return(aci_stat->pipes_open_bitmap[0]&0x01);
-}
-
-void lib_aci_board_init(aci_state_t *aci_stat)
-{
-    hal_aci_evt_t *aci_data = NULL;
-    aci_data = (hal_aci_evt_t *)&msg_to_send;
-
-    if (REDBEARLAB_SHIELD_V1_1 == aci_stat->aci_pins.board_name)
-    {
-      /*
-      The Bluetooth low energy Arduino shield v1.1 requires about 100ms to reset.
-      This is not required for the nRF2740, nRF2741 modules
-      */
-      usleep(100000);
-
-      /*
-      Send the soft reset command to the nRF8001 to get the nRF8001 to a known state.
-      */
-      lib_aci_radio_reset();
-
-      while (1)
-      {
-        /*Wait for the command response of the radio reset command.
-        as the nRF8001 will be in either SETUP or STANDBY after the ACI Reset Radio is processed
-        */
-
-
-        if (true == lib_aci_event_get(aci_stat, aci_data))
-        {
-          aci_evt_t * aci_evt;
-          aci_evt = &(aci_data->evt);
-
-          if (ACI_EVT_CMD_RSP == aci_evt->evt_opcode)
-          {
-                if (ACI_STATUS_ERROR_DEVICE_STATE_INVALID == aci_evt->params.cmd_rsp.cmd_status) //in SETUP
-                {
-                    //Inject a Device Started Event Setup to the ACI Event Queue
-                    msg_to_send.buffer[0] = 4;    //Length
-                    msg_to_send.buffer[1] = 0x81; //Device Started Event
-                    msg_to_send.buffer[2] = 0x02; //Setup
-                    msg_to_send.buffer[3] = 0;    //Hardware Error -> None
-                    msg_to_send.buffer[4] = 2;    //Data Credit Available
-                    aci_queue_enqueue(&aci_rx_q, &msg_to_send);
-                }
-                else if (ACI_STATUS_SUCCESS == aci_evt->params.cmd_rsp.cmd_status) //We are now in STANDBY
-                {
-                    //Inject a Device Started Event Standby to the ACI Event Queue
-                    msg_to_send.buffer[0] = 4;    //Length
-                    msg_to_send.buffer[1] = 0x81; //Device Started Event
-                    msg_to_send.buffer[2] = 0x03; //Standby
-                    msg_to_send.buffer[3] = 0;    //Hardware Error -> None
-                    msg_to_send.buffer[4] = 2;    //Data Credit Available
-                    aci_queue_enqueue(&aci_rx_q, &msg_to_send);
-                }
-                else if (ACI_STATUS_ERROR_CMD_UNKNOWN == aci_evt->params.cmd_rsp.cmd_status) //We are now in TEST
-                {
-                    //Inject a Device Started Event Test to the ACI Event Queue
-                    msg_to_send.buffer[0] = 4;    //Length
-                    msg_to_send.buffer[1] = 0x81; //Device Started Event
-                    msg_to_send.buffer[2] = 0x01; //Test
-                    msg_to_send.buffer[3] = 0;    //Hardware Error -> None
-                    msg_to_send.buffer[4] = 0;    //Data Credit Available
-                    aci_queue_enqueue(&aci_rx_q, &msg_to_send);
-                }
-
-                printf ("BREAK\n");
-                //Break out of the while loop
-                break;
-          }
-          else
-          {
-            //Serial.println(F("Discard any other ACI Events"));
-          }
-
-        }
-      }
-    }
-}
-
-
-void lib_aci_init(aci_state_t *aci_stat, bool debug)
-{
-    uint8_t i;
-
-    for (i = 0; i < PIPES_ARRAY_SIZE; i++) {
-        aci_stat->pipes_open_bitmap[i]          = 0;
-        aci_stat->pipes_closed_bitmap[i]        = 0;
-        aci_cmd_params_open_adv_pipe.pipes[i]   = 0;
-    }
-
-    is_request_operation_pending     = false;
-    is_indicate_operation_pending    = false;
-    is_open_remote_pipe_pending      = false;
-    is_close_remote_pipe_pending     = false;
-
-    request_operation_pipe           = 0;
-    indicate_operation_pipe          = 0;
-
-    p_services_pipe_type_map = aci_stat->aci_setup_info.services_pipe_type_mapping;
-    p_setup_msgs             = aci_stat->aci_setup_info.setup_msgs;
-
-    hal_aci_tl_init (&aci_stat->aci_pins, debug);
-    lib_aci_board_init (aci_stat);
-}
-
-
-uint8_t lib_aci_get_nb_available_credits(aci_state_t *aci_stat)
-{
-  return aci_stat->data_credit_available;
-}
-
-uint16_t lib_aci_get_cx_interval_ms(aci_state_t *aci_stat)
-{
-  uint32_t cx_rf_interval_ms_32bits;
-  uint16_t cx_rf_interval_ms;
-
-  cx_rf_interval_ms_32bits  = aci_stat->connection_interval;
-  cx_rf_interval_ms_32bits *= 125;                      // the connection interval is given in multiples of 0.125 milliseconds
-  cx_rf_interval_ms         = cx_rf_interval_ms_32bits / 100;
-
-  return cx_rf_interval_ms;
-}
-
-
-uint16_t lib_aci_get_cx_interval(aci_state_t *aci_stat)
-{
-  return aci_stat->connection_interval;
-}
-
-
-uint16_t lib_aci_get_slave_latency(aci_state_t *aci_stat)
-{
-  return aci_stat->slave_latency;
-}
-
-
-bool lib_aci_set_app_latency(uint16_t latency, aci_app_latency_mode_t latency_mode)
-{
-  aci_cmd_params_set_app_latency_t aci_set_app_latency;
-
-  aci_set_app_latency.mode    = latency_mode;
-  aci_set_app_latency.latency = latency;
-  acil_encode_cmd_set_app_latency(&(msg_to_send.buffer[0]), &aci_set_app_latency);
-
-  return hal_aci_tl_send(&msg_to_send);
-}
-
-
-bool lib_aci_test(aci_test_mode_change_t enter_exit_test_mode)
-{
-  aci_cmd_params_test_t aci_cmd_params_test;
-  aci_cmd_params_test.test_mode_change = enter_exit_test_mode;
-  acil_encode_cmd_set_test_mode(&(msg_to_send.buffer[0]), &aci_cmd_params_test);
-  return hal_aci_tl_send(&msg_to_send);
-}
-
-
-bool lib_aci_sleep()
-{
-  acil_encode_cmd_sleep(&(msg_to_send.buffer[0]));
-  return hal_aci_tl_send(&msg_to_send);
-}
-
-
-bool lib_aci_radio_reset()
-{
-  acil_encode_baseband_reset(&(msg_to_send.buffer[0]));
-  return hal_aci_tl_send(&msg_to_send);
-}
-
-
-bool lib_aci_direct_connect()
-{
-  acil_encode_direct_connect(&(msg_to_send.buffer[0]));
-  return hal_aci_tl_send(&msg_to_send);
-}
-
-
-bool lib_aci_device_version()
-{
-  acil_encode_cmd_get_device_version(&(msg_to_send.buffer[0]));
-  return hal_aci_tl_send(&msg_to_send);
-}
-
-
-bool lib_aci_set_local_data(aci_state_t *aci_stat, uint8_t pipe, uint8_t *p_value, uint8_t size)
-{
-  aci_cmd_params_set_local_data_t aci_cmd_params_set_local_data;
-
-  if ((p_services_pipe_type_map[pipe-1].location != ACI_STORE_LOCAL)
-      ||
-      (size > ACI_PIPE_TX_DATA_MAX_LEN))
-  {
-    return false;
-  }
-
-  aci_cmd_params_set_local_data.tx_data.pipe_number = pipe;
-  memcpy(&(aci_cmd_params_set_local_data.tx_data.aci_data[0]), p_value, size);
-  acil_encode_cmd_set_local_data(&(msg_to_send.buffer[0]), &aci_cmd_params_set_local_data, size);
-  return hal_aci_tl_send(&msg_to_send);
-}
-
-bool lib_aci_connect(uint16_t run_timeout, uint16_t adv_interval)
-{
-  aci_cmd_params_connect_t aci_cmd_params_connect;
-  aci_cmd_params_connect.timeout      = run_timeout;
-  aci_cmd_params_connect.adv_interval = adv_interval;
-  acil_encode_cmd_connect(&(msg_to_send.buffer[0]), &aci_cmd_params_connect);
-  return hal_aci_tl_send(&msg_to_send);
-}
-
-
-bool lib_aci_disconnect(aci_state_t *aci_stat, aci_disconnect_reason_t reason)
-{
-  bool ret_val;
-  uint8_t i;
-  aci_cmd_params_disconnect_t aci_cmd_params_disconnect;
-  aci_cmd_params_disconnect.reason = reason;
-  acil_encode_cmd_disconnect(&(msg_to_send.buffer[0]), &aci_cmd_params_disconnect);
-  ret_val = hal_aci_tl_send(&msg_to_send);
-  // If we have actually sent the disconnect
-  if (ret_val)
-  {
-    // Update pipes immediately so that while the disconnect is happening,
-    // the application can't attempt sending another message
-    // If the application sends another message before we updated this
-    //    a ACI Pipe Error Event will be received from nRF8001
-    for (i=0; i < PIPES_ARRAY_SIZE; i++)
-    {
-      aci_stat->pipes_open_bitmap[i] = 0;
-      aci_stat->pipes_closed_bitmap[i] = 0;
-    }
-  }
-  return ret_val;
-}
-
-
-bool lib_aci_bond(uint16_t run_timeout, uint16_t adv_interval)
-{
-  aci_cmd_params_bond_t aci_cmd_params_bond;
-  aci_cmd_params_bond.timeout = run_timeout;
-  aci_cmd_params_bond.adv_interval = adv_interval;
-  acil_encode_cmd_bond(&(msg_to_send.buffer[0]), &aci_cmd_params_bond);
-  return hal_aci_tl_send(&msg_to_send);
-}
-
-
-bool lib_aci_wakeup()
-{
-  acil_encode_cmd_wakeup(&(msg_to_send.buffer[0]));
-  return hal_aci_tl_send(&msg_to_send);
-}
-
-
-bool lib_aci_set_tx_power(aci_device_output_power_t tx_power)
-{
-  aci_cmd_params_set_tx_power_t aci_cmd_params_set_tx_power;
-  aci_cmd_params_set_tx_power.device_power = tx_power;
-  acil_encode_cmd_set_radio_tx_power(&(msg_to_send.buffer[0]), &aci_cmd_params_set_tx_power);
-  return hal_aci_tl_send(&msg_to_send);
-}
-
-
-bool lib_aci_get_address()
-{
-  acil_encode_cmd_get_address(&(msg_to_send.buffer[0]));
-  return hal_aci_tl_send(&msg_to_send);
-}
-
-
-bool lib_aci_get_temperature()
-{
-  acil_encode_cmd_temparature(&(msg_to_send.buffer[0]));
-  return hal_aci_tl_send(&msg_to_send);
-}
-
-
-bool lib_aci_get_battery_level()
-{
-  acil_encode_cmd_battery_level(&(msg_to_send.buffer[0]));
-  return hal_aci_tl_send(&msg_to_send);
-}
-
-
-bool lib_aci_send_data(uint8_t pipe, uint8_t *p_value, uint8_t size)
-{
-  bool ret_val = false;
-  aci_cmd_params_send_data_t aci_cmd_params_send_data;
-
-
-  if(!((p_services_pipe_type_map[pipe-1].pipe_type == ACI_TX) ||
-      (p_services_pipe_type_map[pipe-1].pipe_type == ACI_TX_ACK)))
-  {
-    return false;
-  }
-
-  if (size > ACI_PIPE_TX_DATA_MAX_LEN)
-  {
-    return false;
-  }
-  {
-      aci_cmd_params_send_data.tx_data.pipe_number = pipe;
-      memcpy(&(aci_cmd_params_send_data.tx_data.aci_data[0]), p_value, size);
-      acil_encode_cmd_send_data(&(msg_to_send.buffer[0]), &aci_cmd_params_send_data, size);
-
-      ret_val = hal_aci_tl_send(&msg_to_send);
-  }
-  return ret_val;
-}
-
-
-bool lib_aci_request_data(aci_state_t *aci_stat, uint8_t pipe)
-{
-  bool ret_val = false;
-  aci_cmd_params_request_data_t aci_cmd_params_request_data;
-
-  if(!((p_services_pipe_type_map[pipe-1].location == ACI_STORE_REMOTE)&&(p_services_pipe_type_map[pipe-1].pipe_type == ACI_RX_REQ)))
-  {
-    return false;
-  }
-
-
-  {
-
-    {
-
-
-
-      aci_cmd_params_request_data.pipe_number = pipe;
-      acil_encode_cmd_request_data(&(msg_to_send.buffer[0]), &aci_cmd_params_request_data);
-
-      ret_val = hal_aci_tl_send(&msg_to_send);
-    }
-  }
-  return ret_val;
-}
-
-
-bool lib_aci_change_timing(uint16_t minimun_cx_interval, uint16_t maximum_cx_interval, uint16_t slave_latency, uint16_t timeout)
-{
-  aci_cmd_params_change_timing_t aci_cmd_params_change_timing;
-  aci_cmd_params_change_timing.conn_params.min_conn_interval = minimun_cx_interval;
-  aci_cmd_params_change_timing.conn_params.max_conn_interval = maximum_cx_interval;
-  aci_cmd_params_change_timing.conn_params.slave_latency     = slave_latency;
-  aci_cmd_params_change_timing.conn_params.timeout_mult      = timeout;
-  acil_encode_cmd_change_timing_req(&(msg_to_send.buffer[0]), &aci_cmd_params_change_timing);
-  return hal_aci_tl_send(&msg_to_send);
-}
-
-
-bool lib_aci_change_timing_GAP_PPCP()
-{
-  acil_encode_cmd_change_timing_req_GAP_PPCP(&(msg_to_send.buffer[0]));
-  return hal_aci_tl_send(&msg_to_send);
-}
-
-
-bool lib_aci_open_remote_pipe(aci_state_t *aci_stat, uint8_t pipe)
-{
-  bool ret_val = false;
-  aci_cmd_params_open_remote_pipe_t aci_cmd_params_open_remote_pipe;
-
-  if(!((p_services_pipe_type_map[pipe-1].location == ACI_STORE_REMOTE)&&
-                ((p_services_pipe_type_map[pipe-1].pipe_type == ACI_RX)||
-                (p_services_pipe_type_map[pipe-1].pipe_type == ACI_RX_ACK_AUTO)||
-                (p_services_pipe_type_map[pipe-1].pipe_type == ACI_RX_ACK))))
-  {
-    return false;
-  }
-
-
-  {
-
-    is_request_operation_pending = true;
-    is_open_remote_pipe_pending = true;
-    request_operation_pipe = pipe;
-    aci_cmd_params_open_remote_pipe.pipe_number = pipe;
-    acil_encode_cmd_open_remote_pipe(&(msg_to_send.buffer[0]), &aci_cmd_params_open_remote_pipe);
-    ret_val = hal_aci_tl_send(&msg_to_send);
-  }
-  return ret_val;
-}
-
-
-bool lib_aci_close_remote_pipe(aci_state_t *aci_stat, uint8_t pipe)
-{
-  bool ret_val = false;
-  aci_cmd_params_close_remote_pipe_t aci_cmd_params_close_remote_pipe;
-
-  if(!((p_services_pipe_type_map[pipe-1].location == ACI_STORE_REMOTE)&&
-        ((p_services_pipe_type_map[pipe-1].pipe_type == ACI_RX)||
-         (p_services_pipe_type_map[pipe-1].pipe_type == ACI_RX_ACK_AUTO)||
-         (p_services_pipe_type_map[pipe-1].pipe_type == ACI_RX_ACK))))
-  {
-    return false;
-  }
-
-
-  {
-
-    is_request_operation_pending = true;
-    is_close_remote_pipe_pending = true;
-    request_operation_pipe = pipe;
-    aci_cmd_params_close_remote_pipe.pipe_number = pipe;
-    acil_encode_cmd_close_remote_pipe(&(msg_to_send.buffer[0]), &aci_cmd_params_close_remote_pipe);
-    ret_val = hal_aci_tl_send(&msg_to_send);
-  }
-  return ret_val;
-}
-
-
-bool lib_aci_set_key(aci_key_type_t key_rsp_type, uint8_t *key, uint8_t len)
-{
-  aci_cmd_params_set_key_t aci_cmd_params_set_key;
-  aci_cmd_params_set_key.key_type = key_rsp_type;
-  memcpy((uint8_t*)&(aci_cmd_params_set_key.key), key, len);
-  acil_encode_cmd_set_key(&(msg_to_send.buffer[0]), &aci_cmd_params_set_key);
-  return hal_aci_tl_send(&msg_to_send);
-}
-
-
-bool lib_aci_echo_msg(uint8_t msg_size, uint8_t *p_msg_data)
-{
-  aci_cmd_params_echo_t aci_cmd_params_echo;
-  if(msg_size > (ACI_ECHO_DATA_MAX_LEN))
-  {
-    return false;
-  }
-
-  if (msg_size > (ACI_ECHO_DATA_MAX_LEN))
-  {
-    msg_size = ACI_ECHO_DATA_MAX_LEN;
-  }
-
-  memcpy(&(aci_cmd_params_echo.echo_data[0]), p_msg_data, msg_size);
-  acil_encode_cmd_echo_msg(&(msg_to_send.buffer[0]), &aci_cmd_params_echo, msg_size);
-
-  return hal_aci_tl_send(&msg_to_send);
-}
-
-
-bool lib_aci_bond_request()
-{
-  acil_encode_cmd_bond_security_request(&(msg_to_send.buffer[0]));
-  return hal_aci_tl_send(&msg_to_send);
-}
-
-bool lib_aci_event_peek(hal_aci_evt_t *p_aci_evt_data)
-{
-  return hal_aci_tl_event_peek((hal_aci_data_t *)p_aci_evt_data);
-}
-
-bool lib_aci_event_get(aci_state_t *aci_stat, hal_aci_evt_t *p_aci_evt_data)
-{
-  bool status = false;
-
-  status = hal_aci_tl_event_get((hal_aci_data_t *)p_aci_evt_data);
-
-  /**
-  Update the state of the ACI with the
-  ACI Events -> Pipe Status, Disconnected, Connected, Bond Status, Pipe Error
-  */
-  if (true == status)
-  {
-    aci_evt_t * aci_evt;
-
-    aci_evt = &p_aci_evt_data->evt;
-
-    switch(aci_evt->evt_opcode)
-    {
-        case ACI_EVT_PIPE_STATUS:
-            {
-                uint8_t i=0;
-
-                for (i=0; i < PIPES_ARRAY_SIZE; i++)
-                {
-                  aci_stat->pipes_open_bitmap[i]   = aci_evt->params.pipe_status.pipes_open_bitmap[i];
-                  aci_stat->pipes_closed_bitmap[i] = aci_evt->params.pipe_status.pipes_closed_bitmap[i];
-                }
-            }
-            break;
-
-        case ACI_EVT_DISCONNECTED:
-            {
-                uint8_t i=0;
-
-                for (i=0; i < PIPES_ARRAY_SIZE; i++)
-                {
-                  aci_stat->pipes_open_bitmap[i] = 0;
-                  aci_stat->pipes_closed_bitmap[i] = 0;
-                }
-                aci_stat->confirmation_pending = false;
-                aci_stat->data_credit_available = aci_stat->data_credit_total;
-
-            }
-            break;
-
-        case ACI_EVT_TIMING:
-                aci_stat->connection_interval = aci_evt->params.timing.conn_rf_interval;
-                aci_stat->slave_latency       = aci_evt->params.timing.conn_slave_rf_latency;
-                aci_stat->supervision_timeout = aci_evt->params.timing.conn_rf_timeout;
-            break;
-
-        default:
-            /* Need default case to avoid compiler warnings about missing enum
-             * values on some platforms.
-             */
-            break;
-
-
-
-    }
-  }
-  return status;
-}
-
-
-bool lib_aci_send_ack(aci_state_t *aci_stat, const uint8_t pipe)
-{
-  bool ret_val = false;
-  {
-    acil_encode_cmd_send_data_ack(&(msg_to_send.buffer[0]), pipe);
-
-    ret_val = hal_aci_tl_send(&msg_to_send);
-  }
-  return ret_val;
-}
-
-
-bool lib_aci_send_nack(aci_state_t *aci_stat, const uint8_t pipe, const uint8_t error_code)
-{
-  bool ret_val = false;
-
-  {
-
-    acil_encode_cmd_send_data_nack(&(msg_to_send.buffer[0]), pipe, error_code);
-    ret_val = hal_aci_tl_send(&msg_to_send);
-  }
-  return ret_val;
-}
-
-
-bool lib_aci_broadcast(const uint16_t timeout, const uint16_t adv_interval)
-{
-  aci_cmd_params_broadcast_t aci_cmd_params_broadcast;
-  if (timeout > 16383)
-  {
-    return false;
-  }
-
-  // The adv_interval should be between 160 and 16384 (which translates to the advertisement
-  // interval values 100 ms and 10.24 s.
-  if ((160 > adv_interval) || (adv_interval > 16384))
-  {
-    return false;
-  }
-
-  aci_cmd_params_broadcast.timeout = timeout;
-  aci_cmd_params_broadcast.adv_interval = adv_interval;
-  acil_encode_cmd_broadcast(&(msg_to_send.buffer[0]), &aci_cmd_params_broadcast);
-  return hal_aci_tl_send(&msg_to_send);
-}
-
-
-bool lib_aci_open_adv_pipes(const uint8_t * const adv_service_data_pipes)
-{
-  uint8_t i;
-
-  for (i = 0; i < PIPES_ARRAY_SIZE; i++)
-  {
-    aci_cmd_params_open_adv_pipe.pipes[i] = adv_service_data_pipes[i];
-  }
-
-  acil_encode_cmd_open_adv_pipes(&(msg_to_send.buffer[0]), &aci_cmd_params_open_adv_pipe);
-  return hal_aci_tl_send(&msg_to_send);
-}
-
-bool lib_aci_open_adv_pipe(const uint8_t pipe)
-{
-  uint8_t byte_idx = pipe / 8;
-
-  aci_cmd_params_open_adv_pipe.pipes[byte_idx] |= (0x01 << (pipe % 8));
-  acil_encode_cmd_open_adv_pipes(&(msg_to_send.buffer[0]), &aci_cmd_params_open_adv_pipe);
-  return hal_aci_tl_send(&msg_to_send);
-}
-
-
-bool lib_aci_read_dynamic_data()
-{
-  acil_encode_cmd_read_dynamic_data(&(msg_to_send.buffer[0]));
-  return hal_aci_tl_send(&msg_to_send);
-}
-
-
-bool lib_aci_write_dynamic_data(uint8_t sequence_number, uint8_t* dynamic_data, uint8_t length)
-{
-  acil_encode_cmd_write_dynamic_data(&(msg_to_send.buffer[0]), sequence_number, dynamic_data, length);
-  return hal_aci_tl_send(&msg_to_send);
-}
-
-bool lib_aci_dtm_command(uint8_t dtm_command_msbyte, uint8_t dtm_command_lsbyte)
-{
-  aci_cmd_params_dtm_cmd_t aci_cmd_params_dtm_cmd;
-  aci_cmd_params_dtm_cmd.cmd_msb = dtm_command_msbyte;
-  aci_cmd_params_dtm_cmd.cmd_lsb = dtm_command_lsbyte;
-  acil_encode_cmd_dtm_cmd(&(msg_to_send.buffer[0]), &aci_cmd_params_dtm_cmd);
-  return hal_aci_tl_send(&msg_to_send);
-}
-
-void lib_aci_flush(void)
-{
-  hal_aci_tl_q_flush();
-}
-
-void lib_aci_debug_print(bool enable)
-{
-  hal_aci_tl_debug_print(enable);
-
-}
-
-void lib_aci_pin_reset(void)
-{
-    hal_aci_tl_pin_reset();
-}
-
-bool lib_aci_event_queue_empty(void)
-{
-  return hal_aci_tl_rx_q_empty();
-}
-
-bool lib_aci_event_queue_full(void)
-{
-  return hal_aci_tl_rx_q_full();
-}
-
-bool lib_aci_command_queue_empty(void)
-{
-  return hal_aci_tl_tx_q_empty();
-}
-
-bool lib_aci_command_queue_full(void)
-{
-  return hal_aci_tl_tx_q_full();
-}
diff --git a/src/nrf8001/lib_aci.h b/src/nrf8001/lib_aci.h
deleted file mode 100644
index 557536b..0000000
--- a/src/nrf8001/lib_aci.h
+++ /dev/null
@@ -1,569 +0,0 @@
-/* Copyright (c) 2014, Nordic Semiconductor ASA
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-/** 
- * @file
- * @defgroup aci-lib aci-library
- * @brief ACI library
- *
- * Library for the logical part of the Application Controller Interface (ACI)
- * 
- * @ingroup nrf8001
- */
- 
-#ifndef LIB_ACI_H__
-#define LIB_ACI_H__
-
-/**
-* @{
-*/
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include "hal_platform.h"
-#include "hal_aci_tl.h"
-#include "aci_queue.h"
-#include "aci.h"
-#include "aci_cmds.h"
-#include "aci_evts.h"
-
-#define EVT_CMD_RESPONSE_MIN_LENGTH              3
-
-#define PIPES_ARRAY_SIZE                ((ACI_DEVICE_MAX_PIPES + 7)/8)
-
-/* Same size as a hal_aci_data_t */
-typedef struct {
-  uint8_t   debug_byte;
-  aci_evt_t evt;
-} _aci_packed_ hal_aci_evt_t;
-
-ACI_ASSERT_SIZE(hal_aci_evt_t, 34);
-
-typedef struct
-{
-  uint8_t  location; /**< enum aci_pipe_store_t */
-  aci_pipe_type_t   pipe_type;
-} services_pipe_type_mapping_t;
-
-typedef struct aci_setup_info_t
-{
-  services_pipe_type_mapping_t *services_pipe_type_mapping;
-  uint8_t                       number_of_pipes;
-  hal_aci_data_t               *setup_msgs;
-  uint8_t                       num_setup_msgs;
-} aci_setup_info_t;
-
-
-
-// aci_struct that will contain
-// total initial credits
-// current credit
-// current state of the aci (setup/standby/active/sleep)
-// open remote pipe pending
-// close remote pipe pending
-// Current pipe available bitmap
-// Current pipe closed bitmap
-// Current connection interval, slave latency and link supervision timeout
-// Current State of the the GATT client (Service Discovery status)
-// Relationship of bond to peer address
-typedef struct aci_state_t
-{
-    aci_pins_t                    aci_pins;                               /* Pins on the MCU used to connect to the nRF8001 */
-    aci_setup_info_t              aci_setup_info;                         /* Data structures that are created from nRFgo Studio */
-    uint8_t                       bonded;                                 /* ( aci_bond_status_code_t ) Is the nRF8001 bonded to a peer device */
-    uint8_t                       data_credit_total;                      /* Total data credit available for the specific version of the nRF8001, total equals available when a link is established */
-    aci_device_operation_mode_t   device_state;                           /* Operating mode of the nRF8001 */
-
-    /* */
-
-    /* Start : Variables that are valid only when in a connection */
-    uint8_t                       data_credit_available;                  /* Available data credits at a specific point of time, ACI_EVT_DATA_CREDIT updates the available credits */
-
-    uint16_t                      connection_interval;                    /* Multiply by 1.25 to get the connection interval in milliseconds*/
-    uint16_t                      slave_latency;                          /* Number of consecutive connection intervals that the nRF8001 is not required to transmit. Use this to save power */
-    uint16_t                      supervision_timeout;                    /* Multiply by 10 to get the supervision timeout in milliseconds */
-
-    uint8_t                       pipes_open_bitmap[PIPES_ARRAY_SIZE];    /* Bitmap -> pipes are open and can be used for sending data over the air */
-    uint8_t                       pipes_closed_bitmap[PIPES_ARRAY_SIZE];  /* Bitmap -> pipes are closed and cannot be used for sending data over the air */
-    bool                          confirmation_pending;                   /* Attribute protocol Handle Value confirmation is pending for a Handle Value Indication
-                                                                        (ACK is pending for a TX_ACK pipe) on local GATT Server*/
-    /* End : Variables that are valid only when in a connection */
-
-} aci_state_t;
-
-
-
-#define DISCONNECT_REASON_CX_TIMEOUT                 0x08
-#define DISCONNECT_REASON_CX_CLOSED_BY_PEER_DEVICE   0x13
-#define DISCONNECT_REASON_POWER_LOSS                 0x14
-#define DISCONNECT_REASON_CX_CLOSED_BY_LOCAL_DEVICE  0x16
-#define DISCONNECT_REASON_ADVERTISER_TIMEOUT         0x50
-
-
-/** @name Functions for library management */
-//@{
-
-/** @brief Function to enable printing of all ACI commands sent and ACI events received
- *  @details This function shall be used to enable or disable the debug printing.
-              Debug printing is disabled by default.
- */
-void lib_aci_debug_print(bool enable);
-
-/** @brief Function to pin reset the nRF8001
- *  @details Pin resets the nRF8001 also handles differences between development boards
- */
-void lib_aci_pin_reset(void);
-
-/** @brief Initialization function.
- *  @details This function shall be used to initialize/reset ACI Library and also Resets the
- *           nRF8001 by togging the reset pin of the nRF8001. This function will reset
- *           all the variables locally used by ACI library to their respective default values.
- *  @param bool True if the data was successfully queued for sending,
- *  false if there is no more space to store messages to send.
- */
-void lib_aci_init(aci_state_t *aci_stat, bool debug);
-
-
-/** @brief Gets the number of currently available ACI credits.
- *  @return Number of ACI credits.
- */
-uint8_t lib_aci_get_nb_available_credits(aci_state_t *aci_stat);
-
-/** @brief Gets the connection interval in milliseconds.
- *  @return Connection interval in milliseconds.
- */
-uint16_t lib_aci_get_cx_interval_ms(aci_state_t *aci_stat);
-
-/** @brief Gets the connection interval in multiple of 1.25&nbsp;ms.
- *  @return Connection interval in multiple of 1.25&nbsp;ms.
- */
-uint16_t lib_aci_get_cx_interval(aci_state_t *aci_stat);
-
-/** @brief Gets the current slave latency.
- *  @return Current slave latency.
- */
-uint16_t lib_aci_get_slave_latency(aci_state_t *aci_stat);
-
-/** @brief Checks if a given pipe is available.
- *  @param pipe Pipe to check.
- *  @return True if the pipe is available, otherwise false.
- */
-bool lib_aci_is_pipe_available(aci_state_t *aci_stat, uint8_t pipe);
-
-/** @brief Checks if a given pipe is closed.
- *  @param pipe Pipe to check.
- *  @return True if the pipe is closed, otherwise false.
- */
-bool lib_aci_is_pipe_closed(aci_state_t *aci_stat, uint8_t pipe);
-
-/** @brief Checks if the discovery operation is finished.
- *  @return True if the discovery is finished.
- */
-bool lib_aci_is_discovery_finished(aci_state_t *aci_stat);
-
-
-
-//@}
-
-/** @name ACI Commands available in all modes */
-//@{
-
-/** @brief Sets the radio in sleep mode.
- *  @details The function sends a @c sleep command to the radio.
- *  If the radio is advertising or connected, it sends back an error, then use lib_aci_radio_reset
- *  if advertising or disconnect if in a connection.
- *  @return True if the transaction is successfully initiated.
- */
-bool lib_aci_sleep(void);
-
-/** @brief Resets the radio.
- *  @details The function sends a @c BasebandReset command to the radio.
- *  @return True if the transaction is successfully initiated.
- */
-bool lib_aci_radio_reset(void);
-
-/** @brief Radio starts directed advertising to bonded device.
- *  @details The function sends a @c DirectedConnect command to the radio.
- *  @return True if the transaction is successfully initiated.
- */
-bool lib_aci_direct_connect(void);
-
-/** @brief Gets the radio's version.
- *  @details This function sends a @c GetDeviceVersion command.
- *  @return True if the transaction is successfully initiated.
- */
-bool lib_aci_device_version(void);
-
-/** @brief Gets the device address.
- *  @details This function sends a @c GetDeviceAddress command.
- *  @return True if the transaction is successfully initiated.
- */
-bool lib_aci_get_address(void);
-
-/** @brief Gets the temperature.
- *  @details This function sends a @c GetTemperature command. lib_aci
- *  calls the @ref lib_aci_transaction_finished_hook() function when the temperature is received.
- *  @return True if the transaction is successfully initiated.
- */
-bool lib_aci_get_temperature(void);
-
-/** @brief Gets the battery level.
- *  @details This function sends a @c GetBatteryLevel command.
- *  @return True if the transaction is successfully initiated.
- */
-bool lib_aci_get_battery_level(void);
-
-//@}
-
-/** @name ACI commands available in Sleep mode */
-//@{
-
-/** @brief Wakes up the radio.
- *  @details This function sends a @c Wakeup command to wake up the radio from
- *  sleep mode. When woken up the radio sends a @c DeviceStartedEvent and
- *  a @c CommandResponseEvent.
- *  @return True if the transaction is successfully initiated.
- */
-bool lib_aci_wakeup(void);
-
-//@}
-
-/** @name ACI commands available in Active mode */
-//@{
-
-/** @brief Sets the radio in test mode.
- *  @details This function sends a @c Test command to the radio. There are two
- *  Test modes available:
- *  - UART: DTM commands are received over UART.
- *  - ACI: DTM commands are received over ACI.
- *  The same command is used to exit the test mode When receiving
- *  a @c DeviceStartedEvent the radio has entered the new mode.
- *  @param enter_exit_test_mode Enter a Test mode, or exit Test mode.
- *  @return True if the transaction is successfully initiated.
- */
-bool lib_aci_test(aci_test_mode_change_t enter_exit_test_mode);
-
-/** @brief Sets the radio's TX power.
- *  @details This function sends a @c SetTxPower command.
- *  @param tx_power TX power to be used by the radio.
- *  @return True if the transaction is successfully initiated.
- */
-bool lib_aci_set_tx_power(aci_device_output_power_t tx_power);
-
-/** @brief Tries to connect to a peer device.
- *  @details This function sends a @c Connect command to the radio.
- *  @param run_timeout Maximum advertising time in seconds (0 means infinite).
- *  @param adv_interval Advertising interval (in multiple of 0.625&nbsp;ms).
- *  @return True if the transaction is successfully initiated.
- */
-bool lib_aci_connect(uint16_t run_timeout, uint16_t adv_interval);
-
-/** @brief Tries to bond with a peer device.
- *  @details This function sends a @c Bond command to the radio.
- *  @param run_timeout Maximum advertising time in seconds (0 means infinite).
- *  @param adv_interval Advertising interval (in multiple of 0.625&nbsp;ms).
- *  @return True if the transaction is successfully initiated.
- */
-bool lib_aci_bond(uint16_t run_timeout, uint16_t adv_interval);
-
-/** @brief Disconnects from peer device.
- *  @details This function sends a @c Disconnect command to the radio.
- *  @param reason Reason for disconnecting.
- *  @return True if the transaction is successfully initiated.
- */
-bool lib_aci_disconnect(aci_state_t *aci_stat, aci_disconnect_reason_t reason);
-
-/**@brief Sets Local Data.
- *  @details
- *  This command updates the value of the characteristic value or the characteristic descriptor stored locally on the device.
- *  Can be called for all types of pipes as long as the data is stored locally.
- *  @param ACI state structure
- *  @param pipe Pipe number on which the data should be set.
- *  @param value Pointer to the data to set.
- *  @param size Size of the data to set.
- *  @return True if the transaction is successfully initiated.
-*/
-bool lib_aci_set_local_data(aci_state_t *aci_stat, uint8_t pipe, uint8_t *value, uint8_t size);
-
-/** @brief Sends Broadcast message to the radio.
- *  @details The Broadcast message starts advertisement procedure
- *  using the given interval with the intention of broadcasting data to a peer device.
- *  @param timeout Time, in seconds, to advertise before exiting to standby mode (0 means infinite).
- *  Valid values: 0 to 16383.
- *  @param adv_interval Advertising interval (in multiple of 0.625&nbsp;ms).
- *  Valid values: 160 to 16384 (which corresponds to an interval from 100 ms to 10.24 s).
- *  @return True if the broadcast message is sent successfully to the radio.
-*/
-bool lib_aci_broadcast(const uint16_t timeout, const uint16_t adv_interval);
-
-/** @name Open Advertising Pipes.  */
-
-/** @brief Sends a command to the radio to set the input pipe to be placed in Advertisement Service Data.
- *  @details This function sends a command to the radio that places the pipe in
- *  advertisement service data.  To start advertising service data, call this function before
- *  Connecting, Broadcasting or Bonding to peer. The data that should be sent in the advertisement packets
- *  must be set using the @c lib_aci_set_local_data function. This function can be called during
- *  advertising to enable/disable broadcast pipes.
- *  @param pipe The pipe that has to be placed in advertising service data.
- *  @return True if the Open Adv Pipe message is sent successfully to the radio.
-*/
-bool lib_aci_open_adv_pipe(const uint8_t pipe);
-
-
-/** @name Open Advertising Pipes  */
-
-/** @brief Sends a command to the radio to set the pipes to be placed in Advertisement Service Data.
- *  @details This function will send a command to the radio that will set the pipes to be placed in
- *  advertisement Service Data.  To start advertising service data, this function should be called before
- *  Connecting, Broadcasting or Bonding to peer. This function can be called during
- *  advertising to enable/disable broadcast pipes. Use this as an alternative to @ref lib_aci_open_adv_pipe
- *  to avoid multiple function calls for placing multiple pipes in the adv data.
- *  @param adv_service_data_pipes Pipe bitmap, where '1' indicates that the corresponding
- *  Valid Values: 0000000000000000 to FEFFFFFFFFFFFF7F (See the ACI Pipe Status Evt bitmap in the nRF8001 datasheet
- *  TX_BROADCAST pipe data is to be placed in Advertising Service Data fields
- *  @return true if the Open Adv Pipe message was sent successfully to the radio.
-*/
-bool lib_aci_open_adv_pipes(const uint8_t * const adv_service_data_pipes);
-
-
-//@}
-
-/** @name ACI commands available in Connected mode */
-//@{
-
-
-/** @brief Sets a given application latency.
- *  @details This function sends a @c setApplicationLatency command.
- *  @return True if the transaction is successfully initiated.
- */
-bool lib_aci_set_app_latency(uint16_t latency, aci_app_latency_mode_t latency_mode);
-
-/** @brief Opens a remote pipe.
- *  @details This function sends an @c OpenRemotePipe command.
- *  @param pipe Number of the pipe to open.
- *  @return True if the transaction is successfully initiated.
- */
-bool lib_aci_open_remote_pipe(aci_state_t *aci_stat, uint8_t pipe);
-
-/** @brief Closes a remote pipe.
- *  @details This function sends an @c CloseRemotePipe command.
- *  @param pipe Pipe number to close.
- *  @return True if the transaction is successfully initiated.
- */
-bool lib_aci_close_remote_pipe(aci_state_t *aci_stat, uint8_t pipe);
-
-/** @brief Sends data on a given pipe.
- *  @details This function sends a @c SendData command with application data to
- *  the radio. This function memorizes credit use, and checks that
- *  enough credits are available.
- *  @param pipe Pipe number on which the data should be sent.
- *  @param value Pointer to the data to send.
- *  @param size Size of the data to send.
- *  @return True if the transaction is successfully initiated.
- */
-bool lib_aci_send_data(uint8_t pipe, uint8_t *value, uint8_t size);
-
-/** @brief Requests data from a given pipe.
- *  @details This function sends a @c RequestData command to the radio. This
- *  function memorizes credit uses, and check that enough credits are available.
- *  After this command, the radio sends back either a @c DataReceivedEvent
- *  or a @c PipeErrorEvent.
- *  @param pipe Pipe number on which the data is requested.
- *  @return True if the transaction is successfully initiated.
- */
-bool lib_aci_request_data(aci_state_t *aci_stat, uint8_t pipe);
-
-/** @brief Sends a L2CAP change connection parameters request.
- *  @details This function sends a @c ChangeTiming command to the radio.  This command triggers a "L2CAP change connection parameters" request
- *  to the master. If the master rejects or accepts but doesn't change the connection parameters within
- *  30 seconds, a timing event with the unchanged connection parameters is sent by the radio.
- *  If the request is accepted and the master changes connection parameters, a timing event with
- *  the new connection parameters is sent by the radio.
- *  If the master doesn't reply to the request within 60 seconds, the radio disconnects.
- *  @param minimun_cx_interval Minimum connection interval requested, in multiple of 1.25&nbsp;ms.
- *  @param maximum_cx_interval Maximum connection interval requested, in multiple of 1.25&nbsp;ms.
- *  @param slave_latency requested slave latency.
- *  @param timeout requested slave timeout, in multiple of 10&nbsp;ms.
- *  @return True if the transaction is successfully initiated.
- */
-bool lib_aci_change_timing(uint16_t minimun_cx_interval, uint16_t maximum_cx_interval, uint16_t slave_latency, uint16_t timeout);
-
-/** @brief Sends a L2CAP change connection parameters request with the connection predefined preffered connection parameters.
- *  @details This function sends a @c ChangeTiming command to the radio. This command triggers a "L2CAP change connection parameters" request
- *  to the master. If the master rejects or accepts but doesn't change the connection parameters within
- *  30 seconds, a timing event with the unchanged connection parameters is sent by the radio.
- *  If the request is accepted and the master changes connection parameters, a timing event with
- *  the new connection parameters is sent by the radio.
- *  If the master doesn't reply to the request within 60 seconds, the radio disconnects.
- *  The timing parameters used are the Timing parameters in the GAP settings in the nRFgo Studio.
- *  The Timing parameters as stored as the GAP Preferred Peripheral Connection Parameters.
- *  @return True if the transaction is successfully initiated.
- */
-bool lib_aci_change_timing_GAP_PPCP(void);
-
-/** @brief Sends acknowledgement message to peer.
- *  @details This function sends @c SendDataAck command to radio. The radio is expected
- *  to send either Handle Value Confirmation or Write response depending
- *  on whether the data is stored remotely or locally.
- *  @param pipe Pipe number for which the acknowledgement is to be sent.
- *  @return True if the ack was sent successfully. False otherwise.
-*/
-bool lib_aci_send_ack(aci_state_t *aci_stat, const uint8_t pipe);
-
-/** @brief Sends negative acknowledgement message to peer.
- *  @details This function sends @c SendDataNack command to radio. The radio is expected
- *  to send Error Response to the peer.
- *  @param pipe Pipe number for which the nack is to be sent.
- *  @param error_code Error code to be sent in the NACk.
- *  @return True if the nack was sent successfully. False otherwise.
-*/
-bool lib_aci_send_nack(aci_state_t *aci_stat, const uint8_t pipe, const uint8_t error_code);
-
-/** @brief Sends ReadDynamicData command to the host.
- *  @details This function sends @c ReadDynamicData command to host. The host is expected
- *  to send @c CommandResponse back with the dynamic data. The application is expected to
- *  call this function in a loop until all the dynamic data is read out from the host.
- *  As long as there is dynamic data to be read from the host, the command response
- *  for this message has its status field set to ACI_STATUS_TRANSACTION_CONTINUE (0x01).
- *  The application may chose to store this read out data in a non-volatile memory location
- *  and later chose to write it back using the function lib_aci_write_dynamic_data.
- *  @return True if the command was sent successfully through the ACI. False otherwise.
-*/
-bool lib_aci_read_dynamic_data(void);
-
-/** @brief Sends WriteDynamicData command to the host.
- *  @details This function sends @c WriteDynamicData command to host. The host is expected
- *  to send @c CommandResponse with the status of this operation. As long as the status field
- *  in the @c CommandResponse is ACI_STATUS_TRANSACTION_CONTINUE (0x01), the hosts expects
- *  more dynamic data to be written. This function should ideally be called in a cycle,
- *  until all the stored dynamic data is sent to the host. This function should be
- *  called with the dynamic data obtained from the response to a @c ReadDynamicData
- *  (see @c lib_aci_read_dynamic_data) command.
- *  @param sequence_number Sequence number of the dynamic data to be sent.
- *  @param dynamic_data Pointer to the dynamic data.
- *  @param length Length of the dynamic data.
- *  @return True if the command was sent successfully through the ACI. False otherwise.
-*/
-bool lib_aci_write_dynamic_data(uint8_t sequence_number, uint8_t* dynamic_data, uint8_t length);
-//@}
-
-/** @name ACI commands available while connected in Bond mode */
-//@{
-
-/** @brief Sends a SMP Security Request.
- *  @details This function send a @c BondRequest command to the radio.
- *  This command triggers a SMP Security Request to the master. If the
- *  master rejects with a pairing failed or if the bond timer expires the connection is closed.
- *  @return True if the transaction is successfully initiated.
- */
-bool lib_aci_bond_request(void);
-
-/** @brief Set the key requested by the 8001.
- *  @details This function sends an @c SetKey command to the radio.
- *  @param key_rsp_type Type of key.
- *  @param key Pointer to the key to set.
- *  @param len Length of the key.
- *  @return True if the transaction is successfully initiated.
-*/
-bool lib_aci_set_key(aci_key_type_t key_rsp_type, uint8_t *key, uint8_t len);
-
-//@}
-
-
-
-/** @name ACI commands available in Test mode */
-//@{
-
-/** @brief Sends an echo message
- *  @details This function sends an @c Echo command to the radio. lib_aci
- *  places the Echp ACI command in the ACI command queue
- *  @param message_size Length of the data to send.
- *  @param message_data Pointer to the data to send.
- *  @return True if the transaction is successfully initiated.
-*/
-bool lib_aci_echo_msg(uint8_t message_size, uint8_t *message_data);
-
-/** @brief Sends an DTM command
- *  @details This function sends an @c DTM command to the radio.
- *  @param dtm_command_msbyte Most significant byte of the DTM command.
- *  @param dtm_command_lsbyte Least significant byte of the DTM command.
- *  @return True if the transaction is successfully initiated.
-*/
-bool lib_aci_dtm_command(uint8_t dtm_command_msbyte, uint8_t dtm_command_lsbyte);
-
-/** @brief Gets an ACI event from the ACI Event Queue
- *  @details This function gets an ACI event from the ACI event queue.
- *  The queue is updated by the SPI driver for the ACI running in the interrupt context
- *  @param aci_stat pointer to the state of the ACI.
- *  @param p_aci_data pointer to the ACI Event. The ACI Event received will be copied into this pointer.
- *  @return True if an ACI Event was copied to the pointer.
-*/
-bool lib_aci_event_get(aci_state_t *aci_stat, hal_aci_evt_t * aci_evt);
-
-/** @brief Peeks an ACI event from the ACI Event Queue
- * @details This function peeks at the top event in the ACI event queue.
- * In polling mode, this function will query the nRF8001 for pending events, but unlike
- * lib_aci_event_get() it will not dequeue the event from the local queue, but will instead
- * only peek at it.
- * @return True if an ACI Event was copied to the pointer.
-*/
-bool lib_aci_event_peek(hal_aci_evt_t *p_aci_evt_data);
-
-/** @brief Flushes the events in the ACI command queues and ACI Event queue
- *
-*/
-void lib_aci_flush(void);
-
-/** @brief Return full status of the Event queue
- *  @details
- *
- */
- bool lib_aci_event_queue_full(void);
-
- /** @brief Return empty status of the Event queue
- *  @details
- *
- */
- bool lib_aci_event_queue_empty(void);
-
-/** @brief Return full status of Command queue
- *  @details
- *
- */
- bool lib_aci_command_queue_full(void);
-
- /** @brief Return empty status of Command queue
- *  @details
- *
- */
- bool lib_aci_command_queue_empty(void);
-
-//@}
-
-/** @} */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LIB_ACI_H__ */
diff --git a/src/nrf8001/nrf8001.cxx b/src/nrf8001/nrf8001.cxx
deleted file mode 100644
index d7b111b..0000000
--- a/src/nrf8001/nrf8001.cxx
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <stdlib.h>
-#include <stdint.h>
-
-#include "nrf8001.hpp"
-
-/**
- * Include the services_lock.h to put the setup in the OTP memory of the nRF8001.
- * This would mean that the setup cannot be changed once put in.
- * However this removes the need to do the setup of the nRF8001 on every reset.
-*/
-
-void
-init_local_interfaces (aci_state_t* aci, uint8_t reqn, uint8_t rdyn, uint8_t rst) {
-    /**
-     * Tell the ACI library, the MCU to nRF8001 pin connections.
-     * The Active pin is optional and can be marked UNUSED
-     */
-    aci->aci_pins.board_name                = BOARD_DEFAULT;    // See board.h for details REDBEARLAB_SHIELD_V1_1 or BOARD_DEFAULT
-    aci->aci_pins.reqn_pin                  = reqn;             // SS for Nordic board, 9 for REDBEARLAB_SHIELD_V1_1
-    aci->aci_pins.rdyn_pin                  = rdyn;             // 3 for Nordic board, 8 for REDBEARLAB_SHIELD_V1_1
-
-    aci->aci_pins.reset_pin                 = rst;              // 4 for Nordic board, UNUSED for REDBEARLAB_SHIELD_V1_1
-    aci->aci_pins.active_pin                = UNUSED;
-    aci->aci_pins.optional_chip_sel_pin     = UNUSED;
-
-    aci->aci_pins.interface_is_interrupt    = false;            // Interrupts still not available in Chipkit
-    aci->aci_pins.interrupt_number          = 1;
-
-    lib_aci_init (aci, false);
-}
-
-void
-close_local_interfaces (aci_state_t* aci) {
-    mraa_result_t error = MRAA_SUCCESS;
-
-    error = mraa_spi_stop(aci->aci_pins.m_spi);
-    if (error != MRAA_SUCCESS) {
-
-    }
-    error = mraa_gpio_close (aci->aci_pins.m_rdy_ctx);
-    if (error != MRAA_SUCCESS) {
-
-    }
-    error = mraa_gpio_close (aci->aci_pins.m_req_ctx);
-    if (error != MRAA_SUCCESS) {
-
-    }
-    error = mraa_gpio_close (aci->aci_pins.m_rst_ctx);
-    if (error != MRAA_SUCCESS) {
-
-    }
-}
diff --git a/src/nrf8001/nrf8001.hpp b/src/nrf8001/nrf8001.hpp
deleted file mode 100644
index 0d242e9..0000000
--- a/src/nrf8001/nrf8001.hpp
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/**
- * @brief NRF8001 Bluetooth Low Energy Module
- * @defgroup nrf8001 libupm-nrf8001
- * @ingroup adafruit wifi analog gpio spi
- */
-/**
- * @library nrf8001
- * @sensor nrf8001
- * @comname Bluetooth Low Energy (BLE) Module
- * @type wifi
- * @man adafruit
- * @web https://learn.adafruit.com/getting-started-with-the-nrf8001-bluefruit-le-breakout/introduction
- * @con spi gpio analog
- *
- * @brief NRF8001 Bluetooth Low Energy library
- *
- * These files define the NRF8001 interface for lib-nrf8001. Interaction
- * with this device is done through the ACI routines included with the library.
- * You can use the nRF UART app in Apple* App Store and Google* Play* on
- * Samsung* Galaxy S*4 running Android* 4.3 to interact with a microcontroller running
- * the 'hello world' example.
- *
- * @image html nrf8001.jpg
- * @snippet nrf8001-helloworld.cxx Interesting
- * @snippet nrf8001-broadcast.cxx Interesting
- */
-#pragma once
-
-#include <string>
-#include <mraa/aio.h>
-#include <mraa/gpio.h>
-#include <mraa/spi.h>
-
-#include "lib_aci.h"
-#include "aci_setup.h"
-
-void init_local_interfaces (aci_state_t* aci, uint8_t reqn, uint8_t rdyn, uint8_t rst);
-void close_local_interfaces (aci_state_t* aci);
diff --git a/src/nrf8001/nrf8001.json b/src/nrf8001/nrf8001.json
deleted file mode 100644
index 169d15d..0000000
--- a/src/nrf8001/nrf8001.json
+++ /dev/null
@@ -1,55 +0,0 @@
-{
-    "Library": "nrf8001",
-    "Description": "Nordic Semiconductor NRF8001 Bluetooth Low Energy library",
-    "Sensor Class": {
-        "nrf8001": {
-            "Name": "API for the Nordic Semiconductor NRF8001 Bluetooth Low Energy Module",
-            "Description": "This is the UPM Module for the Nordic Semiconductor NRF8001 Bluetooth Low Energy Module. These files define the NRF8001 interface for lib-nrf8001. Interaction with this device is done through the ACI routines included with the library. You can use the nRF UART app in Apple* App Store and Google* Play* on Samsung* Galaxy S*4 running Android* 4.3 to interact with a microcontroller running the 'hello world' example.",
-            "Aliases": ["nrf8001", "Bluefruit LE - Bluetooth Low Energy (BLE 4.0) - nRF8001 Breakout - v1.0"],
-            "Categories": ["wifi"],
-            "Connections": ["spi", "gpio", "analog"],
-            "Project Type": ["prototyping"],
-            "Manufacturers": ["Nordic Semiconductor", "Adafruit"],
-            "Image": "nrf8001.jpg",
-            "Examples": {
-                "C++": ["nrf8001-broadcast.cxx", "nrf8001-helloworld.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 1.9,
-                    "max": 3.6
-                },
-                "Supply Current": {
-                    "unit": "uA",
-                    "min" : 2,
-                    "max" : 14000
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Bluetooth Version": {
-                    "unit": "version number",
-                    "version": "BLE V4.0"
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need pull up resistors"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.adafruit.com/product/1697", "http://www.nordicsemi.com/eng/Products/Bluetooth-low-energy/nRF8001"],
-                "Datasheets": ["https://learn.adafruit.com/getting-started-with-the-nrf8001-bluefruit-le-breakout/introduction", "http://www.nordicsemi.com/eng/nordic/download_resource/17534/16/64902106/2981"]
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/nrf8001/uart_over_ble.h b/src/nrf8001/uart_over_ble.h
deleted file mode 100644
index fe2709a..0000000
--- a/src/nrf8001/uart_over_ble.h
+++ /dev/null
@@ -1,79 +0,0 @@
-/*  Copyright (c) 2013, Nordic Semiconductor ASA
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without modification,
- *  are permitted provided that the following conditions are met:
- *
- *  Redistributions of source code must retain the above copyright notice, this
- *  list of conditions and the following disclaimer.
- *
- *  Redistributions in binary form must reproduce the above copyright notice, this
- *  list of conditions and the following disclaimer in the documentation and/or
- *  other materials provided with the distribution.
- *
- *  Neither the name of Nordic Semiconductor ASA nor the names of its
- *  contributors may be used to endorse or promote products derived from
- *  this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
- *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
- *  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- *  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/**
- * @file
- * @brief BLE specific macros
- * @ingroup nrf8001
- */
-
-#ifndef UART_OVER_BLE_H__
-#define UART_OVER_BLE_H__
-
-/**
- * @def UART_OVER_BLE_DISCONNECT
- * @brief
- * Command to queue a ACI Disconnect to the nRF8001
- */
-#define UART_OVER_BLE_DISCONNECT      (0x01)
-
-
-/**
- * @def UART_OVER_BLE_LINK_TIMING_REQ
- * @brief
- * Command to queue a ACI Change Timing to the nRF8001
- */
-#define UART_OVER_BLE_LINK_TIMING_REQ (0x02)
-
-/**
- * @def UART_OVER_BLE_TRANSMIT_STOP
- * @brief
- * Command to stop sending UART over BLE packets
- */
-#define UART_OVER_BLE_TRANSMIT_STOP   (0x03)
-
-
-/**
- * @def UART_OVER_BLE_TRANSMIT_OK
- * @brief
- * Command to allow sending UART over BLE packets
- */
-#define UART_OVER_BLE_TRANSMIT_OK     (0x04)
-
-/**
- * @struct uart_over_ble_t
- * @brief State of the UART RTS over Bluetooth Low Energy(BLE)
- */
-typedef struct
-{
-    uint8_t uart_rts_local;  /**< State of the local UART RTS  */
-    uint8_t uart_rts_remote; /**< State of the remote UART RTS */
-} uart_over_ble_t;
-
-#endif // UART_OVER_BLE_H__
diff --git a/src/nunchuck/CMakeLists.txt b/src/nunchuck/CMakeLists.txt
deleted file mode 100644
index 9c86fe5..0000000
--- a/src/nunchuck/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME nunchuck
-    DESCRIPTION "Wii Nunchuk"
-    C_HDR nunchuck.h
-    C_SRC nunchuck.c
-    CPP_HDR nunchuck.hpp
-    CPP_SRC nunchuck.cxx
-    FTI_SRC nunchuck_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/nunchuck/nunchuck.c b/src/nunchuck/nunchuck.c
deleted file mode 100644
index 0b82329..0000000
--- a/src/nunchuck/nunchuck.c
+++ /dev/null
@@ -1,207 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <stdio.h>
-#include <string.h>
-#include <unistd.h>
-#include <assert.h>
-
-#include "nunchuck.h"
-#include "upm_utilities.h"
-
-// This is not changeable
-#define NUNCHUCK_I2C_ADDR    0x52
-
-// static functions for r/w the device.  No user-serviceable parts
-// inside.
-
-static upm_result_t nunchuck_write_byte(const nunchuck_context dev,
-                                        uint8_t reg, uint8_t byte)
-{
-    assert(dev != NULL);
-
-    if (mraa_i2c_write_byte_data(dev->i2c, byte, reg))
-    {
-        printf("%s: mraa_i2c_write_byte_data() failed\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-static int nunchuck_read_bytes(const nunchuck_context dev, uint8_t reg,
-                               uint8_t *buffer, int len)
-{
-    assert(dev != NULL);
-
-    if (!len || !buffer)
-        return 0;
-
-    if (mraa_i2c_write_byte(dev->i2c, reg))
-    {
-        printf("%s: mraa_i2c_write_byte() failed\n", __FUNCTION__);
-        return -1;
-    }
-
-    return mraa_i2c_read(dev->i2c, buffer, len);
-}
-
-// init
-nunchuck_context nunchuck_init(int bus)
-{
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        return NULL;
-    }
-
-    nunchuck_context dev =
-        (nunchuck_context)malloc(sizeof(struct _nunchuck_context));
-
-    if (!dev)
-        return NULL;
-
-    memset((void *)dev, 0, sizeof(struct _nunchuck_context));
-
-    // setup our i2c link
-    if ( !(dev->i2c = mraa_i2c_init(bus)) )
-    {
-        printf("%s: mraa_i2c_init() failed\n", __FUNCTION__);
-        nunchuck_close(dev);
-        return NULL;
-    }
-
-    if (mraa_i2c_address(dev->i2c, NUNCHUCK_I2C_ADDR))
-    {
-        printf("%s: mraa_i2c_address() failed\n", __FUNCTION__);
-        nunchuck_close(dev);
-        return NULL;
-    }
-
-    // sleep for a second to let things settle
-    upm_delay(1);
-
-    // disable encryption
-    if (nunchuck_write_byte(dev, 0xf0, 0x55)
-        || nunchuck_write_byte(dev, 0xfb, 0x00))
-    {
-        printf("%s: nunchuck_write_byte() failed\n", __FUNCTION__);
-        nunchuck_close(dev);
-        return NULL;
-    }
-
-    return dev;
-}
-
-void nunchuck_close(nunchuck_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->i2c)
-        mraa_i2c_stop(dev->i2c);
-
-    free(dev);
-}
-
-upm_result_t nunchuck_update(const nunchuck_context dev)
-{
-    assert(dev != NULL);
-
-    const int bufsize = 6;
-    uint8_t buf[bufsize];
-    int rv;
-
-    rv = nunchuck_read_bytes(dev, 0x00, buf, bufsize);
-
-    if (rv != bufsize)
-    {
-        printf("%s: nunchuck_read_bytes() failed.  Expected %d, got %d.\n",
-               __FUNCTION__, bufsize, rv);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // analog stick X
-    dev->stickX = buf[0];
-
-    // analog stick Y
-    dev->stickY = buf[1];
-
-    // accelerometer X
-    dev->accelX = ( (buf[2] << 2) | ((buf[5] & 0x0c) >> 2) );
-
-    // accelerometer Y
-    dev->accelY = ( (buf[3] << 2) | ((buf[5] & 0x30) >> 4) );
-
-    // accelerometer Z
-    dev->accelZ = ( (buf[4] << 2) | ((buf[5] & 0xc0) >> 6) );
-
-    // buttonC
-    if (buf[5] & 0x02)
-        dev->buttonC = false;
-    else
-        dev->buttonC = true;
-
-    // buttonZ
-    if (buf[5] & 0x01)
-        dev->buttonZ = false;
-    else
-        dev->buttonZ = true;
-
-    return UPM_SUCCESS;
-}
-
-void nunchuck_get_stick(const nunchuck_context dev, int *x, int *y)
-{
-    assert(dev != NULL);
-
-    if (x)
-        *x = dev->stickX;
-    if (y)
-        *y = dev->stickY;
-}
-
-void nunchuck_get_acceleration(const nunchuck_context dev,
-                               int *x, int *y, int *z)
-{
-    assert(dev != NULL);
-
-    if (x)
-        *x = dev->accelX;
-    if (y)
-        *y = dev->accelY;
-    if (z)
-        *z = dev->accelZ;
-}
-
-void nunchuck_get_buttons(const nunchuck_context dev, bool *c, bool *z)
-{
-    assert(dev != NULL);
-
-    if (c)
-        *c = dev->buttonC;
-    if (z)
-        *z = dev->buttonZ;
-}
diff --git a/src/nunchuck/nunchuck.cxx b/src/nunchuck/nunchuck.cxx
deleted file mode 100644
index 2eebc61..0000000
--- a/src/nunchuck/nunchuck.cxx
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015-2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-#include <unistd.h>
-
-#include "nunchuck.hpp"
-
-using namespace upm;
-using namespace std;
-
-
-NUNCHUCK::NUNCHUCK(int bus) :
-    m_nunchuck(nunchuck_init(bus))
-{
-    if (!m_nunchuck)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": nunchuck_init() failed");
-}
-
-NUNCHUCK::~NUNCHUCK()
-{
-    nunchuck_close(m_nunchuck);
-}
-
-void NUNCHUCK::update()
-{
-    if (nunchuck_update(m_nunchuck))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": nunchuck_update() failed");
-
-    nunchuck_get_stick(m_nunchuck, &stickX, &stickY);
-    nunchuck_get_acceleration(m_nunchuck, &accelX, &accelY, &accelZ);
-    nunchuck_get_buttons(m_nunchuck, &buttonC, &buttonZ);
-}
-
diff --git a/src/nunchuck/nunchuck.h b/src/nunchuck/nunchuck.h
deleted file mode 100644
index 1b0aa55..0000000
--- a/src/nunchuck/nunchuck.h
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <upm.h>
-
-#include <mraa/i2c.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    /**
-     * @file nunchuck.h
-     * @library nunchuck
-     * @brief C API for the nunchuck driver
-     *
-     * @include nunchuck.c
-     */
-
-    /**
-     * Device context
-     */
-    typedef struct _nunchuck_context {
-        mraa_i2c_context  i2c;
-
-        // sticks - x, y
-        int stickX;
-        int stickY;
-
-        // accel
-        int accelX;
-        int accelY;
-        int accelZ;
-
-        // buttons
-        bool buttonC;
-        bool buttonZ;
-
-    } *nunchuck_context;
-
-    /**
-     * NUNCHUCK constructor
-     *
-     * @param bus I2C bus to use
-     * @return A Device context, or NULL on error
-     */
-    nunchuck_context nunchuck_init(int bus);
-
-    /**
-     * Close the device and deallocate all resources.
-     *
-     * @param dev Device context
-     */
-    void nunchuck_close(nunchuck_context dev);
-
-    /**
-     * Reads and updates the current state of the controller.
-     *
-     * @param dev Device context
-     * @return UPM result
-     */
-    upm_result_t nunchuck_update(const nunchuck_context dev);
-
-    /**
-     * Returns the current analog stick X and Y positions.
-     * nunchuck_update() must have been called prior to calling this
-     * function.
-     *
-     * @param dev Device context
-     * @param x Pointer in which the X value will be stored
-     * @param y Pointer in which the Y value will be stored
-     */
-    void nunchuck_get_stick(const nunchuck_context dev, int *x, int *y);
-
-    /**
-     * Returns the current accelerometer values.  nunchuck_update()
-     * must have been called prior to calling this function.
-     *
-     * @param dev Device context
-     * @param x Pointer in which the X value will be stored
-     * @param y Pointer in which the Y value will be stored
-     * @param z Pointer in which the Z value will be stored
-     */
-    void nunchuck_get_acceleration(const nunchuck_context dev,
-                                   int *x, int *y, int *z);
-
-    /**
-     * Returns the current button values values.  nunchuck_update()
-     * must have been called prior to calling this function.
-     *
-     * @param dev Device context
-     * @param c Pointer in which the C button value will be stored
-     * @param z Pointer in which the Z button value will be stored
-     */
-    void nunchuck_get_buttons(const nunchuck_context dev, bool *c, bool *z);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/nunchuck/nunchuck.hpp b/src/nunchuck/nunchuck.hpp
deleted file mode 100644
index fe85655..0000000
--- a/src/nunchuck/nunchuck.hpp
+++ /dev/null
@@ -1,134 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015-2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include "nunchuck.h"
-
-
-namespace upm {
-
-  /**
-   * @brief Wii Nunchuk Controller
-   * @defgroup nunchuck libupm-nunchuck
-   * @ingroup generic i2c accelerometer robok
-   */
-  /**
-   * @library nunchuck
-   * @sensor nunchuck
-   * @comname Wii Nunchuk
-   * @type accelerometer
-   * @man generic
-   * @web http://wiibrew.org/wiki/Wiimote/Extension_Controllers
-   * @con i2c
-   * @kit robok
-   *
-   * @brief API for the Wii* Nunchuk controller
-   *
-   * UPM module for the Wii Nunchuk controller. This module was tested with
-   * Wii Nunchuck connected to I2C via a Grove Wii Nunchuck adapter.
-   *
-   * See http://wiibrew.org/wiki/Wiimote/Extension_Controllers and
-   * http://wiibrew.org/wiki/Wiimote/Extension_Controllers/Nunchuck
-   * for more details on the controller and its protocol.
-   *
-   * A warning for the Grove Wii Nunchuk adapter: it has 2 traces on
-   * one side, and 3 traces on the other.  Do not match these up with
-   * the Nunchuk connector's traces. The connector's 'groove' should
-   * be on the same side as the Grove interface socket on the adapter.
-   *
-   * @image html nunchuck.jpg
-   * @snippet nunchuck.cxx Interesting
-   */
-  class NUNCHUCK {
-  public:
-    /**
-     * NUNCHUCK constructor
-     *
-     * @param bus I2C bus to use
-     */
-    NUNCHUCK(int bus);
-
-    /**
-     * NUNCHUCK destructor
-     */
-    virtual ~NUNCHUCK();
-
-    /**
-     * Reads and updates the current state of the controller.
-     *
-     */
-    void update();
-
-    /**
-     * Current analog stick X position
-     *
-     */
-    int stickX;
-
-    /**
-     * Current analog stick Y position
-     *
-     */
-    int stickY;
-
-    /**
-     * Current accelerometer X value
-     *
-     */
-    int accelX;
-
-    /**
-     * Current accelerometer Y value
-     *
-     */
-    int accelY;
-
-    /**
-     * Current accelerometer Z value
-     *
-     */
-    int accelZ;
-
-    /**
-     * Button C pressed?
-     *
-     */
-    bool buttonC;
-
-    /**
-     * Button Z pressed?
-     *
-     */
-    bool buttonZ;
-
-  protected:
-    nunchuck_context m_nunchuck;
-
-  private:
-    /* Disable implicit copy and assignment operators */
-    NUNCHUCK(const NUNCHUCK&) = delete;
-    NUNCHUCK &operator=(const NUNCHUCK&) = delete;
-  };
-}
diff --git a/src/nunchuck/nunchuck.i b/src/nunchuck/nunchuck.i
deleted file mode 100644
index 77caf86..0000000
--- a/src/nunchuck/nunchuck.i
+++ /dev/null
@@ -1,16 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "../java_buffer.i"
-
-JAVA_JNI_LOADLIBRARY(javaupm_nunchuck)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "nunchuck.hpp"
-%}
-%include "nunchuck.hpp"
-/* END Common SWIG syntax */
diff --git a/src/nunchuck/nunchuck.json b/src/nunchuck/nunchuck.json
deleted file mode 100644
index f93c285..0000000
--- a/src/nunchuck/nunchuck.json
+++ /dev/null
@@ -1,47 +0,0 @@
-{
-    "Library": "nunchuck",
-    "Description": "Wii Nunchuk library",
-    "Sensor Class": {
-        "NUNCHUCK": {
-            "Name": "API for the Wii* Nunchuk controller",
-            "Description": "UPM module for the Wii Nunchuk controller. This module was tested with Wii Nunchuck connected to I2C via a Grove Wii Nunchuck adapter. See http://wiibrew.org/wiki/Wiimote/Extension_Controllers and http://wiibrew.org/wiki/Wiimote/Extension_Controllers/Nunchuck for more details on the controller and its protocol. A warning for the Grove Wii Nunchuk adapter: it has 2 traces on one side, and 3 traces on the other. Do not match these up with the Nunchuk connector's traces. The connector's 'groove' should be on the same side as the Grove interface socket on the adapter.",
-            "Aliases": ["nunchuck", "Wii nunchuck", "Grove - Nunchuck"],
-            "Categories": ["accelerometer"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping"],
-            "Manufacturers": ["generic"],
-            "Kits": ["robok"],
-            "Image": "nunchuck.jpg",
-            "Examples": {
-                "Java": ["NUNCHUCK_Example.java"],
-                "Python": ["nunchuck.py"],
-                "Node.js": ["nunchuck.js"],
-                "C++": ["nunchuck.cxx"],
-                "C": ["nunchuck.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "typ": 5.0
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -40,
-                    "max": 85
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-Nunchuck-p-1474.html", "http://wiibrew.org/wiki/Wiimote/Extension_Controllers", "http://wiibrew.org/wiki/Wiimote/Extension_Controllers/Nunchuck"],
-                "Datasheets": ["http://wiki.seeed.cc/Grove-NunChuck/"]
-            }
-        }
-    }
-}
diff --git a/src/nunchuck/nunchuck_fti.c b/src/nunchuck/nunchuck_fti.c
deleted file mode 100644
index 31c9cb5..0000000
--- a/src/nunchuck/nunchuck_fti.c
+++ /dev/null
@@ -1,190 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "nunchuck.h"
-
-#include "upm_fti.h"
-
-/**
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_nunchuck_name[] = "NUNCHUCK";
-const char upm_nunchuck_description[] = "Nunchuck controller";
-const upm_protocol_t upm_nunchuck_protocol[] = {UPM_I2C};
-const upm_sensor_t upm_nunchuck_category[] =
-{ UPM_ACCELEROMETER, UPM_JOYSTICK, UPM_BUTTONS};
-
-// forward declarations
-const void* upm_nunchuck_get_ft(upm_sensor_t sensor_type);
-void* upm_nunchuck_init_name();
-void upm_nunchuck_close(void *dev);
-upm_result_t upm_nunchuck_get_accel_values(void *dev, float *value, upm_acceleration_u unit);
-upm_result_t upm_nunchuck_get_joystick_value_x(const void *dev, float *value);
-upm_result_t upm_nunchuck_get_joystick_value_y(const void *dev, float *value);
-upm_result_t upm_nunchuck_get_num_buttons(const void *dev,
-                                          unsigned int *num_buttons);
-upm_result_t upm_nunchuck_get_button_values(const void *dev,
-                                            bool *values);
-
-const upm_sensor_descriptor_t upm_nunchuck_get_descriptor()
-{
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_nunchuck_name;
-    usd.description = upm_nunchuck_description;
-    usd.protocol_size = 1;
-    usd.protocol = upm_nunchuck_protocol;
-    usd.category_size = 3;
-    usd.category = upm_nunchuck_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = upm_nunchuck_init_name,
-    .upm_sensor_close = upm_nunchuck_close,
-};
-
-static const upm_acceleration_ft aft =
-{
-    .upm_acceleration_get_value = upm_nunchuck_get_accel_values
-};
-
-static const upm_joystick_ft jft =
-{
-    .upm_joystick_get_value_x = upm_nunchuck_get_joystick_value_x,
-    .upm_joystick_get_value_y = upm_nunchuck_get_joystick_value_y
-};
-
-static const upm_buttons_ft bft =
-{
-    .upm_buttons_get_num_buttons = upm_nunchuck_get_num_buttons,
-    .upm_buttons_get_values = upm_nunchuck_get_button_values
-};
-
-const void* upm_nunchuck_get_ft(upm_sensor_t sensor_type)
-{
-  switch(sensor_type)
-    {
-    case UPM_SENSOR:
-      return &ft;
-
-    case UPM_ACCELEROMETER:
-      return &aft;
-
-    case UPM_JOYSTICK:
-      return &jft;
-
-    case UPM_BUTTONS:
-      return &bft;
-
-    default:
-      return NULL;
-    }
-}
-
-void* upm_nunchuck_init_name()
-{
-    return NULL;
-}
-
-void upm_nunchuck_close(void *dev)
-{
-    nunchuck_close((nunchuck_context)dev);
-}
-
-upm_result_t upm_nunchuck_get_accel_values(void *dev,
-                                           float *value,
-                                           upm_acceleration_u unit)
-{
-    if (nunchuck_update((nunchuck_context)dev))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    int x, y, z;
-    nunchuck_get_acceleration((nunchuck_context)dev, &x, &y, &z);
-    value[0] = (float)x;
-    value[1] = (float)y;
-    value[2] = (float)z;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t upm_nunchuck_get_joystick_value_x(const void *dev, float *value)
-{
-    // This is bad - separating getting X and Y stick values... You
-    // can't be sure when updating for one axis whether the other
-    // changed... Should be fixed by having a single function return
-    // both values from the same sampletime.  Same goes for the rest
-    // of the values reported.
-    if (nunchuck_update((nunchuck_context)dev))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    int x;
-    nunchuck_get_stick((nunchuck_context)dev, &x, NULL);
-    *value = (float)x;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t upm_nunchuck_get_joystick_value_y(const void *dev, float *value)
-{
-    // This is bad - separating getting X and Y stick values... You
-    // can't be sure when updating for one axis whether the other
-    // changed... Should be fixed by having a single function return
-    // both values from the same sampletime.  Same goes for the rest
-    // of the values reported.
-    if (nunchuck_update((nunchuck_context)dev))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    int y;
-    nunchuck_get_stick((nunchuck_context)dev, NULL, &y);
-    *value = (float)y;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t upm_nunchuck_get_num_buttons(const void *dev,
-                                          unsigned int *num_buttons)
-{
-    // always 2 buttons (C and Z)
-
-    *num_buttons = 2;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t upm_nunchuck_get_button_values(const void *dev,
-                                            bool *values)
-{
-    if (nunchuck_update((nunchuck_context)dev))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    bool bc, bz;
-    nunchuck_get_buttons((nunchuck_context)dev, &bc, &bz);
-    // hope they passed a bool[2]....
-    values[0] = bc;
-    values[1] = bz;
-
-    return UPM_SUCCESS;
-}
diff --git a/src/o2/CMakeLists.txt b/src/o2/CMakeLists.txt
deleted file mode 100644
index 1d36e44..0000000
--- a/src/o2/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-upm_mixed_module_init (NAME o2
-    DESCRIPTION "Oxygen (O2) Concentration Sensor"
-    C_HDR o2.h
-    C_SRC o2.c
-    CPP_HDR o2.hpp
-    CPP_SRC o2.cxx
-    FTI_SRC o2_fti.c
-    REQUIRES mraa)
diff --git a/src/o2/o2.c b/src/o2/o2.c
deleted file mode 100644
index 9cb8036..0000000
--- a/src/o2/o2.c
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- * Author: Noel Eck <noel.eck@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string.h>
-#include <stdlib.h>
-
-#include "o2.h"
-o2_context o2_init(int16_t pin)
-{
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        return NULL;
-    }
-
-    o2_context dev = (o2_context)malloc(sizeof(struct _o2_context));
-
-    if(dev == NULL) return NULL;
-
-    /* Init aio pin */
-    dev->aio = mraa_aio_init(pin);
-    if(dev->aio == NULL) {
-        free(dev);
-        return NULL;
-    }
-
-    /* Set defaults */
-    dev->m_aRef = 5.0;
-    dev->m_offset = 0.0;
-    dev->m_scale = 1.0;
-
-    return dev;
-}
-
-void o2_close(o2_context dev)
-{
-    mraa_aio_close(dev->aio);
-    free(dev);
-}
-
-upm_result_t o2_set_aref(const o2_context dev, float aref)
-{
-    dev->m_aRef = aref;
-    return UPM_SUCCESS;
-}
-
-float o2_get_aref(const o2_context dev)
-{
-    return dev->m_aRef;
-}
-
-upm_result_t o2_set_offset(const o2_context dev, float offset)
-{
-    dev->m_offset = offset;
-    return UPM_SUCCESS;
-}
-
-float o2_get_offset(const o2_context dev)
-{
-    return dev->m_offset;
-}
-
-upm_result_t o2_set_scale(const o2_context dev, float scale)
-{
-    dev->m_scale = scale;
-    return UPM_SUCCESS;
-}
-
-float o2_get_scale(const o2_context dev)
-{
-    return dev->m_scale;
-}
-
-upm_result_t o2_get_counts(const o2_context dev, int *value)
-{
-    /* Read counts */
-    *value = mraa_aio_read(dev->aio);
-    if (*value < 0) return UPM_ERROR_OPERATION_FAILED;
-    return UPM_SUCCESS;
-}
-
-upm_result_t o2_get_raw_volts(const o2_context dev, float *value)
-{
-    /* Read normalized adc value */
-    *value = mraa_aio_read_float(dev->aio);
-    if (*value < 0.0) return UPM_ERROR_OPERATION_FAILED;
-
-    /* Convert normalized value to voltage via aRef */
-    *value *= dev->m_aRef;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t o2_get_value(const o2_context dev, float *value)
-{
-    /* Read normalized value */
-    *value = mraa_aio_read_float(dev->aio);
-    if (*value < 0.0)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    /* Apply raw scale */
-    *value *= dev->m_scale;
-
-    /* Convert to %oxygen
-       Datasheet for grove o2 shows a linear response for the sensor.  Assuming
-       20.5% oxygen @ 25 celsius, with an gain = 1 + 12k/100 = 121, a
-       dynamic range of 0->25% oxygen, and opamp rails of 0->3.3v (the grove o2
-       sensor uses a high-accuracy 3.3v regulator),
-     */
-    *value *= 25 * dev->m_aRef/3.3;
-
-    *value += dev->m_offset;
-
-    return UPM_SUCCESS;
-}
-
diff --git a/src/o2/o2.cxx b/src/o2/o2.cxx
deleted file mode 100644
index 30c0f2d..0000000
--- a/src/o2/o2.cxx
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Author: Zion Orent <zorent@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "o2.hpp"
-
-using namespace upm;
-using namespace std;
-
-O2::O2(int pin)
-{
-    if ( !(m_aio = mraa_aio_init(pin)) )
-    {
-      throw std::invalid_argument(std::string(__FUNCTION__) +
-                                  ": mraa_aio_init() failed, invalid pin?");
-      return;
-    }
-}
-
-O2::~O2()
-{
-  mraa_aio_close(m_aio);
-}
-
-float O2::voltageValue()
-{
-	int val = mraa_aio_read(m_aio);
-	if (val == -1) return -1.0f;
-	float sensorVoltage = (val/1024.0) * 5.0;
-	sensorVoltage = (sensorVoltage/201.0) * 10000.0;
-	return sensorVoltage;
-}
diff --git a/src/o2/o2.h b/src/o2/o2.h
deleted file mode 100644
index 3202f33..0000000
--- a/src/o2/o2.h
+++ /dev/null
@@ -1,143 +0,0 @@
-/*
- * Author: Noel Eck <noel.eck@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include "upm.h"
-#include "mraa/aio.h"
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @file o2.h
- * @library o2
- * @brief C API for the O2 Oxygen Gas Sensor
- *
- * @include o2.c
- */
-
-/**
- * device context
- */
-typedef struct _o2_context {
-    /* mraa aio pin context */
-    mraa_aio_context aio;
-    /* Analog voltage reference */
-    float m_aRef;
-    /* Scale */
-    float m_scale;
-    /* Offset in sensor units */
-    float m_offset;
-} *o2_context;
-
-/**
- * Initialize analog sensor
- * @param pin is Analog pin
- * @return sensor context as void pointer
- */
-o2_context o2_init(int16_t pin);
-
-/**
- * Analog sensor destructor
- * @param sensor context pointer deallocate memory
- */
-void o2_close(o2_context dev);
-
-/**
- * Set sensor adc vref.
- * @param dev sensor context pointer
- * @param aref Voltage reference routed to ADC ref pin
- * @return Function result code
- */
-upm_result_t o2_set_aref(const o2_context dev, float aref);
-
-/**
- * Get sensor adc vref
- * @param dev sensor context pointer
- * @return Current adc vref
- */
-float o2_get_aref(const o2_context dev);
-
-/**
- * Set sensor offset.  This offset is applied to the return value:
- *     counts = counts * scale + offset * scale
- * @param dev sensor context pointer
- * @param offset count offset value used
- * @return Function result code
- */
-upm_result_t o2_set_offset(const o2_context dev, float offset);
-
-/**
- * Get sensor offset
- * @param dev sensor context pointer
- * @return Current sensor offset
- */
-float o2_get_offset(const o2_context dev);
-
-/**
- * Set sensor scale.  This scale is applied to the return value:
- *     counts = counts * scale + offset * scale
- * @param dev sensor context pointer
- * @param scale count scale value used
- * @return Function result code
- */
-upm_result_t o2_set_scale(const o2_context dev, float scale);
-
-/**
- * Get sensor scale
- * @param dev sensor context pointer
- * @return Current sensor scale
- */
-float o2_get_scale(const o2_context dev);
-
-/**
- * Read raw adc counts from sensor
- * @param dev sensor context pointer
- * @param *value Raw adc value
- * @return Function result code
- */
-upm_result_t o2_get_counts(const o2_context dev, int *value);
-
-/**
- * Read voltage from sensor
- * @param dev sensor context pointer
- * @param *value Voltage (v)
- * @return Function result code
- */
-upm_result_t o2_get_raw_volts(const o2_context dev, float *value);
-
-/**
- * Read value from sensor
- * @param dev sensor context pointer
- * @param *value O2 percentage
- * @return Function result code
- */
-upm_result_t o2_get_value(const o2_context dev, float *value);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/o2/o2.hpp b/src/o2/o2.hpp
deleted file mode 100644
index 0c94795..0000000
--- a/src/o2/o2.hpp
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Author: Zion Orent <zorent@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/aio.h>
-
-namespace upm {
-  /**
-   * @brief Oxygen Gas Sensor
-   * @defgroup o2 libupm-o2
-   * @ingroup seeed analog gaseous
-   */
-
-  /**
-   * @library o2
-   * @sensor o2
-   * @comname Oxygen (O2) Concentration Sensor
-   * @altname Grove O2 Sensor
-   * @type gaseous
-   * @man seeed
-   * @con analog
-   * @web http://wiki.seeed.cc/Grove-Gas_Sensor-O2/
-   *
-   * @brief API for the Grove O2 Oxygen Gas Sensor
-   *
-   * The Grove O2 Oxygen Gas sensor measures the oxygen concentration in the air
-   *
-   * @image html o2.jpg
-   * @snippet o2.cxx Interesting
-   */
-  class O2 {
-  public:
-    /**
-     * Grove O2 Oxygen Gas sensor constructor
-     *
-     * @param pin Analog pin to use
-     */
-    O2(int pin);
-    /**
-     * O2 destructor
-     */
-    ~O2();
-    /**
-     * Measures O2 from the sensor
-     *
-     * @return Oxygen concentration as voltage
-     */
-    float voltageValue();
-
-  private:
-    mraa_aio_context m_aio;
-  };
-}
diff --git a/src/o2/o2.json b/src/o2/o2.json
deleted file mode 100644
index 9a44c5c..0000000
--- a/src/o2/o2.json
+++ /dev/null
@@ -1,39 +0,0 @@
-{
-    "Library": "o2",
-    "Description": "O2 Oxygen Gas Sensor Library",
-    "Sensor Class":
-    {
-        "O2":
-        {
-            "Name": "Oxygen (O2) Concentration Sensor",
-            "Description": "The Grove O2 Oxygen Gas sensor measures the oxygen concentration in the air.",
-            "Aliases": ["o2"],
-            "Categories": ["gas", "oxygen"],
-            "Connections": ["analog"],
-            "Project Type": ["environmental", "prototyping"],
-            "Manufacturers": ["seeed"],
-            "Kits": [],
-            "Image": "o2.jpg",
-            "Examples":
-            {
-                "Java": ["O2_Example.java"],
-                "Python": ["o2.py"],
-                "Node.js": ["o2.js"],
-                "C++": ["o2.cxx"],
-                "C": ["o2.c"]
-            },
-            "Specifications":
-            {
-                "Measurement Range": {"unit": "% Vol", "low": 0, "high": 25},
-                "Sensitivity": {"unit": "mA (in air)", "low": 0.1, "high": 0.3},
-                "Operating Temperature": {"unit": "degC", "low": -20, "high": 50}
-            },
-            "Urls" :
-            {
-                "Product Pages": ["https://www.seeedstudio.com/grove-gas-sensoro2-p-1541.html"],
-                "Datasheets": ["http://wiki.seeed.cc/Grove-Gas_Sensor-O2/"],
-                "Schematics": ["https://github.com/SeeedDocument/Grove_Gas_Sensor_O2/raw/master/resources/Schematics_O2.zip"]
-            }
-        }
-    }
-}
diff --git a/src/o2/o2_fti.c b/src/o2/o2_fti.c
deleted file mode 100644
index 2179b02..0000000
--- a/src/o2/o2_fti.c
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Author: Noel Eck <noel.eck@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "o2.h"
-#include "upm_fti.h"
-#include "fti/upm_sensor.h"
-#include "fti/upm_raw.h"
-
-/** 
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_o2_name[] = "O2";
-const char upm_o2_description[] = "Analog oxygen sensor";
-const upm_protocol_t upm_o2_protocol[] = {UPM_ANALOG};
-const upm_sensor_t upm_o2_category[] = {UPM_RAW};
-
-// forward declarations
-const void* upm_o2_get_ft(upm_sensor_t sensor_type);
-void* upm_o2_init_str(const char* protocol, const char* params);
-void upm_o2_close(void* dev);
-const upm_sensor_descriptor_t upm_o2_get_descriptor();
-upm_result_t upm_o2_set_offset(const void* dev, float offset);
-upm_result_t upm_o2_set_scale(const void* dev, float scale);
-upm_result_t upm_o2_get_value(const void* dev, float *value);
-
-/* This sensor implementes 2 function tables */
-/* 1. Generic base function table */
-static const upm_sensor_ft ft_gen =
-{
-    .upm_sensor_init_name = &upm_o2_init_str,
-    .upm_sensor_close = &upm_o2_close,
-    .upm_sensor_get_descriptor = &upm_o2_get_descriptor
-};
-
-/* 2. RAW function table */
-static const upm_raw_ft ft_raw =
-{
-    .upm_raw_set_offset = &upm_o2_set_offset,
-    .upm_raw_set_scale = &upm_o2_set_scale,
-    .upm_raw_get_value = &upm_o2_get_value
-};
-
-const void* upm_o2_get_ft(upm_sensor_t sensor_type)
-{
-    switch(sensor_type)
-    {
-        case UPM_SENSOR:
-            return &ft_gen;
-        case UPM_RAW:
-            return &ft_raw;
-        default:
-            return NULL;
-    }
-}
-
-void* upm_o2_init_str(const char* protocol, const char* params)
-{
-    fprintf(stderr, "String initialization - not implemented, using ain0: %s\n", __FILE__);
-    return o2_init(0);
-}
-
-void upm_o2_close(void* dev)
-{
-    o2_close((o2_context)dev);
-}
-
-const upm_sensor_descriptor_t upm_o2_get_descriptor()
-{
-    /* Fill in the descriptor */
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_o2_name;
-    usd.description = upm_o2_description;
-    usd.protocol_size = 1;
-    usd.protocol = upm_o2_protocol;
-    usd.category_size = 1;
-    usd.category = upm_o2_category;
-
-    return usd;
-}
-
-upm_result_t upm_o2_set_offset(const void* dev, float offset)
-{
-    return o2_set_offset((o2_context)dev, offset);
-}
-
-upm_result_t upm_o2_set_scale(const void* dev, float scale)
-{
-    return o2_set_scale((o2_context)dev, scale);
-}
-
-upm_result_t upm_o2_get_value(const void* dev, float *value)
-{
-    return o2_get_value((o2_context)dev, value);
-}
diff --git a/src/otp538u/CMakeLists.txt b/src/otp538u/CMakeLists.txt
deleted file mode 100644
index 2a01bd6..0000000
--- a/src/otp538u/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME otp538u
-    DESCRIPTION "Analog IR Temperature Sensor"
-    C_HDR otp538u.h
-    C_SRC otp538u.c
-    CPP_HDR otp538u.hpp
-    CPP_SRC otp538u.cxx
-    FTI_SRC otp538u_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/otp538u/otp538u.c b/src/otp538u/otp538u.c
deleted file mode 100644
index 6576766..0000000
--- a/src/otp538u/otp538u.c
+++ /dev/null
@@ -1,374 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <assert.h>
-#include <string.h>
-
-#include <upm_utilities.h>
-#include <upm_platform.h>
-
-#include "otp538u.h"
-
-#include "thermopile_vt_table.h"
-#include "thermister_rt_table.h"
-
-
-// To save memory space, we disable debugging on non-linux platforms
-// by default (Zephyr).  For other systems, enable as desired/possible.
-#if defined(UPM_PLATFORM_LINUX)
-# define OTP538U_DEBUG_ENABLED
-#endif // UPM_PLATFORM_LINUX
-
-otp538u_context otp538u_init(int pinA, int pinO, float aref)
-{
-    otp538u_context dev =
-        (otp538u_context)malloc(sizeof(struct _otp538u_context));
-
-    if (!dev)
-        return NULL;
-
-    memset((void *)dev, 0, sizeof(struct _otp538u_context));
-
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        otp538u_close(dev);
-        return NULL;
-    }
-
-    // initialize the MRAA contexts
-
-    if (!(dev->aioA = mraa_aio_init(pinA)))
-    {
-        printf("%s: mraa_aio_init(pinA) failed.\n", __FUNCTION__);
-        otp538u_close(dev);
-
-        return NULL;
-    }
-
-    if (!(dev->aioO = mraa_aio_init(pinO)))
-    {
-        printf("%s: mraa_aio_init(pinO) failed.\n", __FUNCTION__);
-        otp538u_close(dev);
-
-        return NULL;
-    }
-
-    // for subplatforms like the Arduino 101 with Firmata, we need to
-    // limit ADC resolution to 10b currently.  For this sensor
-    // unfortunately, this means readings will be less accurate.  This
-    // sensor really does need to measure with about 1mV accuracy.
-    const int adcHighRes = 4095;
-    const int adcLowRes = 1023;
-
-    bool isSubplatform = false;
-
-    dev->debug = false;
-
-    if (pinA >= 512 || pinO >= 512)
-        isSubplatform = true;
-
-    // this is the internal voltage reference on the Grove IR temp
-    // sensor module for the thermistor.
-
-    dev->internalVRef = 2.5;
-
-    // analog reference in use
-    dev->aref = aref;
-
-    // This is the value of the output resistor of the Grove IR
-    // temp sensor's SIG2 output (ambient)
-    dev->vResistance = 2000000;      // 2M ohms
-
-    // This was the default offset voltage in the seeedstudio code.  You
-    // can adjust as neccessary depending on your calibration.
-    dev->offsetVoltage = 0.014;
-
-    // We need around 1mV resolution (preferred), so use 12 bit
-    // resolution (4096) if we can.
-    //
-    // This logic is over complicated due to the fact that it is
-    // currently difficult to determine exactly what the capabilities of
-    // the platform (sub or otherwise) actually are.  So for
-    // subplatforms, we always limit to 1024.  Otherwise, we try 12b if
-    // the mraa_adc_raw_bits() says we can, though this isn't
-    // particularly accurate either, as it reports that the G2 can do
-    // 12b, when in reality it can not.  We are just lucky that it works
-    // anyway (ie: will give 12b resolution, though underneath it's just
-    // scaling the real 10b value.).  Sigh.  But trying 12b resolution
-    // on the 101 via firmata will definitely break things, so don't
-    // even try until whatever the problem it has with 12b is fixed.
-    if (isSubplatform)
-    {
-        dev->adcResolution = adcLowRes; // 10b
-    }
-    else
-    {
-        if (mraa_adc_raw_bits() == 12)
-            dev->adcResolution = adcHighRes; // 12b
-        else
-            dev->adcResolution = adcLowRes; // 10b
-    }
-
-    // notify the user
-    if (dev->adcResolution == adcLowRes)
-        printf("Using 10 bit ADC resolution.  Values will be less accurate.\n");
-
-    // enable 12 bit resolution, if we can
-    if (dev->adcResolution == adcHighRes)
-        mraa_aio_set_bit(dev->aioA, 12);
-
-    if (dev->adcResolution == adcHighRes)
-        mraa_aio_set_bit(dev->aioO, 12);
-
-    if (isSubplatform)
-    {
-        // The first analog read always seems to return 0 on the 101
-        // with firmata, so just do a couple of reads here and discard
-        // them.  Then sleep for half a second.  THIS IS A HACK.  The
-        // real problem should be fixed elsewhere (Firmata?).
-        mraa_aio_read(dev->aioA);
-        mraa_aio_read(dev->aioO);
-
-        upm_delay_ms(500);
-    }
-
-    return dev;
-}
-
-void otp538u_close(otp538u_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->aioA)
-        mraa_aio_close(dev->aioA);
-    if (dev->aioO)
-        mraa_aio_close(dev->aioO);
-
-    free(dev);
-}
-
-upm_result_t otp538u_get_ambient_temperature(const otp538u_context dev,
-                                             float *temperature)
-{
-    assert(dev != NULL);
-
-    const int samples = 5;
-    int val = 0;
-    float temp = 0;
-    float res = 0;
-
-    for (int i=0; i<samples; i++)
-    {
-        val = mraa_aio_read(dev->aioA);
-        if (val == -1)
-        {
-            printf("%s: mraa_aio_read() failed.\n", __FUNCTION__);
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-
-        temp += (float)val;
-        upm_delay_ms(10);
-    }
-    temp = temp / samples;
-
-    float volts = temp * dev->aref / dev->adcResolution;
-
-#if defined(OTP538U_DEBUG_ENABLED)
-    if (dev->debug)
-    {
-        printf("\tAMB sample %f aref %f volts %f\n", temp, dev->aref,
-               volts);
-    }
-#endif // OTP538U_DEBUG_ENABLED
-
-    // compute the resistance of the thermistor
-    res = dev->vResistance * volts / (dev->internalVRef - volts);
-
-#if defined(OTP538U_DEBUG_ENABLED)
-    if (dev->debug)
-    {
-        printf("\tAMB computed resistance: %f\n", res);
-    }
-#endif // OTP538U_DEBUG_ENABLED
-
-    // look it up in the thermistor (RT) resistence/temperature table
-    int rawslot;
-    int j;
-    for (j=0; j<otp538u_rt_table_max; j++)
-        if (otp538u_rt_table[j] < res)
-        {
-            rawslot = j;
-            break;
-        }
-
-    if (j >= otp538u_rt_table_max)
-    {
-        printf("%s: Ambient temperature out of range (high)\n", __FUNCTION__);
-        return UPM_ERROR_OUT_OF_RANGE;
-    }
-
-    // we need to compensate for the fact that we are supporting
-    // temperature values less than 0 (-20C), so adjust correspondingly
-    // so that we obtain the correct temperature 'slot'.  This will be
-    // our base temperature.
-    int slot = rawslot - 20;
-
-    // too cold
-    if (slot < 0)
-    {
-        printf("%s: Ambient temperature out of range (low)\n", __FUNCTION__);
-        return UPM_ERROR_OUT_OF_RANGE;
-    }
-
-    // now compute the ambient temperature
-    float ambientTemp = slot - 1 +
-        (otp538u_rt_table[rawslot - 1]-res) / (otp538u_rt_table[rawslot - 1] -
-                                               otp538u_rt_table[rawslot]);
-
-    *temperature = ambientTemp;
-    return UPM_SUCCESS;
-}
-
-upm_result_t otp538u_get_object_temperature(const otp538u_context dev,
-                                            float *temperature)
-{
-    assert(dev != NULL);
-
-    const int samples = 5;
-    const float reference_vol = 0.5; // what is this value? (from seeedstudio)
-    const float tempIncrement = 10.0;
-    int val = 0;
-    float temp = 0;
-
-    float ambTemp = 0.0;
-    if (otp538u_get_ambient_temperature(dev, &ambTemp))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    for (int i=0; i<samples; i++)
-    {
-        val = mraa_aio_read(dev->aioO);
-        if (val == -1)
-        {
-            printf("%s: mraa_aio_read() failed.\n", __FUNCTION__);
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-        temp += val;
-        upm_delay_ms(10);
-    }
-
-    temp = temp / samples;
-
-#if defined(OTP538U_DEBUG_ENABLED)
-    if (dev->debug)
-        printf("\tOBJ sample %f ", temp);
-#endif // OTP538U_DEBUG_ENABLED
-
-    float volts = temp * dev->aref / dev->adcResolution;
-
-#if defined(OTP538U_DEBUG_ENABLED)
-    if (dev->debug)
-        printf("VOLTS: %f ", volts);
-#endif // OTP538U_DEBUG_ENABLED
-
-    float sensorVolts = volts - (reference_vol + dev->offsetVoltage);
-
-#if defined(OTP538U_DEBUG_ENABLED)
-    if (dev->debug)
-        printf("Sensor Voltage (computed): %f\n", sensorVolts);
-#endif // OTP538U_DEBUG_ENABLED
-
-    // search the VT (voltage/temperature) table to find the object
-    // temperature.
-    int slot;
-    // add +2 to compensate for the -20C and -10C slots below zero
-    int voltOffset = (int)(ambTemp / 10) + 1 + 2;
-    float voltage = sensorVolts * 10.0;
-    for (slot=0; slot<(otp538u_vt_table_max - 1); slot++)
-    {
-        if ( (voltage > otp538u_vt_table[slot][voltOffset]) &&
-             (voltage < otp538u_vt_table[slot+1][voltOffset]) )
-        {
-            break;
-        }
-    }
-
-    if (slot >= (otp538u_vt_table_max - 1))
-    {
-        printf("%s: Object temperature out of range (high)\n", __FUNCTION__);
-        return UPM_ERROR_OUT_OF_RANGE;
-    }
-
-    float objTemp = ((float)tempIncrement * voltage) /
-        ( otp538u_vt_table[slot + 1][voltOffset] -
-          otp538u_vt_table[slot][voltOffset] );
-
-#if defined(OTP538U_DEBUG_ENABLED)
-    if (dev->debug)
-    {
-        printf("\tVoltage (%f): TABLE VALUE [%d][%d] = %f\n", voltage,
-               slot, voltOffset, otp538u_vt_table[slot][voltOffset]);
-    }
-#endif // OTP538U_DEBUG_ENABLED
-
-    *temperature = ambTemp + objTemp;
-    return UPM_SUCCESS;
-}
-
-void otp538u_set_voltage_offset(const otp538u_context dev, float offset)
-{
-    assert(dev != NULL);
-
-    dev->offsetVoltage = offset;
-}
-
-void otp538u_set_output_resistence(const otp538u_context dev,
-                                   int resistance)
-{
-    assert(dev != NULL);
-
-    dev->vResistance = resistance;
-}
-
-void otp538u_set_ivref(const otp538u_context dev, float vref)
-{
-    assert(dev != NULL);
-
-    dev->internalVRef = vref;
-}
-
-void otp538u_set_debug(const otp538u_context dev, bool enable)
-{
-    assert(dev != NULL);
-
-    dev->debug = enable;
-
-#if !defined(UPM_PLATFORM_LINUX) && !defined(OTP538U_DEBUG_ENABLED)
-    if (enable)
-        printf("%s: Debugging not enabled at compilation time.\n",
-               __FUNCTION__);
-#endif // !UPM_PLATFORM_LINUX && !OTP538U_DEBUG_ENABLED
-}
diff --git a/src/otp538u/otp538u.cxx b/src/otp538u/otp538u.cxx
deleted file mode 100644
index 5bf9391..0000000
--- a/src/otp538u/otp538u.cxx
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015-2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "otp538u.hpp"
-
-using namespace upm;
-using namespace std;
-
-OTP538U::OTP538U(int pinA, int pinO, float aref) :
-    m_otp538u(otp538u_init(pinA, pinO, aref))
-{
-    if (!m_otp538u)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": otp538u_init() failed");
-}
-
-OTP538U::~OTP538U()
-{
-    otp538u_close(m_otp538u);
-}
-
-float OTP538U::ambientTemperature()
-{
-    float temp = 0;
-
-    if (otp538u_get_ambient_temperature(m_otp538u, &temp))
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": otp538u_get_ambient_temperature() failed");
-
-    return temp;
-}
-
-float OTP538U::objectTemperature()
-{
-    float temp = 0;
-
-    if (otp538u_get_object_temperature(m_otp538u, &temp))
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": otp538u_get_object_temperature() failed");
-
-    return temp;
-}
diff --git a/src/otp538u/otp538u.h b/src/otp538u/otp538u.h
deleted file mode 100644
index 09e4fc9..0000000
--- a/src/otp538u/otp538u.h
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <upm.h>
-#include <mraa/aio.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    /**
-     * @file otp538u.h
-     * @library otp538u
-     * @brief C API for the OTP538U IR Temperature Sensor
-     *
-     * @include otp538u.c
-     */
-
-    /**
-     * device context
-     */
-    typedef struct _otp538u_context
-    {
-        mraa_aio_context aioA;
-        mraa_aio_context aioO;
-
-        bool             debug;
-        float            internalVRef;
-        float            aref;
-        int              vResistance;
-        float            offsetVoltage;
-        int              adcResolution;
-    } *otp538u_context;
-
-
-    /**
-     * OTP538U constructor
-     *
-     * @param pinA Analog pin to use for the ambient temperature
-     * @param pinO Analog pin to use for the object temperature
-     * @param aref Analog reference voltage
-     * @return intialized context, or NULL if error
-     */
-    otp538u_context otp538u_init(int pinA, int pinO, float aref);
-
-    /**
-     * OTP538U destructor
-     *
-     * @param dev Device context
-     */
-    void otp538u_close(otp538u_context dev);
-
-    /**
-     * Gets the ambient temperature in Celsius
-     *
-     * @param dev Device context
-     * @param temp Ambient temperature
-     * @return UPM status
-     */
-    upm_result_t otp538u_get_ambient_temperature(const otp538u_context dev,
-                                                 float *temperature);
-
-    /**
-     * Gets the object temperature in Celsius
-     *
-     * @param dev Device context
-     * @param temp Object temperature
-     * @return UPM status
-     */
-    upm_result_t otp538u_get_object_temperature(const otp538u_context dev,
-                                                float *temperature);
-
-    /**
-     * Sets the offset voltage
-     *
-     * The Seeed Studio wiki gives an example of calibrating the sensor
-     * and calculating the offset voltage to apply. Currently, the
-     * default value is set, but you can use the function to set one
-     * of your own.
-     *
-     * @param dev Device context
-     * @param vOffset Desired offset voltage
-     */
-    void otp538u_set_voltage_offset(const otp538u_context dev, float offset);
-
-    /**
-     * Sets the output resistance value
-     *
-     * The Seeed Studio wiki example uses a value of 2,000,000 in one of
-     * the equations used to calculate voltage. The value is the
-     * resistance of a resistor they use in the output stage of their
-     * SIG2 output. This was 'decoded' by looking at the EAGLE* files
-     * containing their schematics for this device.
-     *
-     * @param dev Device context
-     * @param outResistance Value of the output resistor; default is 2M Ohm
-     */
-    void otp538u_set_output_resistence(const otp538u_context dev,
-                                       int resistance);
-
-    /**
-     * Sets the reference voltage of the internal Seeed Studio voltage
-     * regulator on the sensor board.
-     *
-     * The Seeed Studio wiki example uses a value of 2.5 in one of the
-     * equations used to calculate the resistance of the ambient
-     * thermistor. The value is the voltage of an internal voltage
-     * regulator used on the sensor board. This was 'decoded' by
-     * looking at the EAGLE files containing their schematics for this
-     * device.
-     *
-     * @param dev Device context
-     * @param vref Reference voltage of the internal sensor; default
-     * is 2.5
-     */
-    void otp538u_set_ivref(const otp538u_context dev, float vref);
-
-    /**
-     * Enable debugging output (linux platforms only).
-     *
-     * @param dev Device context
-     * @param enable true to enable some debug output, false otherwise
-     */
-    void otp538u_set_debug(const otp538u_context dev, bool enable);
-
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/otp538u/otp538u.hpp b/src/otp538u/otp538u.hpp
deleted file mode 100644
index 2c2be59..0000000
--- a/src/otp538u/otp538u.hpp
+++ /dev/null
@@ -1,177 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015-2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <otp538u.h>
-
-namespace upm {
-
-    /**
-     * @brief OTP538U IR Temperature Sensor
-     * @defgroup otp538u libupm-otp538u
-     * @ingroup seeed analog light hak
-     */
-    /**
-     * @library otp538u
-     * @sensor otp538u
-     * @comname Analog IR Temperature Sensor
-     * @altname Grove IR Temperature Sensor
-     * @type light
-     * @man generic
-     * @con analog
-     * @web http://wiki.seeed.cc/Grove-Infrared_Temperature_Sensor/
-     * @kit hak
-     *
-     * @brief API for the OTP538U IR Temperature Sensor
-     *
-     * UPM module for the OTP538U IR temperature sensor
-     *
-     * This module was tested with the Grove IR non-contact temperature
-     * sensor.
-     *
-     * The sensor provides 2 analog outputs: one for the thermistor
-     * that measures the ambient temperature, and the other for the thermopile
-     * that measures the object temperature.
-     *
-     * Much of the code depends on analyzing Seeed Studio* examples
-     * and the circuit design. As a result, there are several 'magic'
-     * numbers derived from their circuit design. These values are used
-     * by default.
-     *
-     * The tables used came from the "538U VT
-     * Table__20_200(v1.3).pdf" and "538RT_table.pdf" datasheets.
-     *
-     * These tables assume the object to be measured is 9 cm (3.54
-     * inches) from the sensor.
-     *
-     * This sensor will not work at 3.3v on the Edsion or the Galileo 2.
-     * It works fine on both systems at 5v.  It will work at 3.3v on the
-     * Arduino 101 (tested via firmata subplatform on edison).
-     *
-     * @image html otp538u.jpg
-     * @snippet otp538u.cxx Interesting
-     */
-    class OTP538U {
-    public:
-        /**
-         * OTP538U constructor
-         *
-         * @param pinA Analog pin to use for the ambient temperature
-         * @param pinO Analog pin to use for the object temperature
-         * @param aref Analog reference voltage; default is 5.0 V
-         */
-        OTP538U(int pinA, int pinO, float aref = 5.0);
-
-        /**
-         * OTP538U destructor
-         */
-        ~OTP538U();
-
-        /**
-         * Gets the ambient temperature in Celsius
-         *
-         * @return Ambient temperature
-         */
-        float ambientTemperature();
-
-        /**
-         * Gets the object temperature in Celsius
-         *
-         * @return Object temperature
-         */
-        float objectTemperature();
-
-        /**
-         * Sets the offset voltage
-         *
-         * The Seeed Studio wiki gives an example of calibrating the sensor
-         * and calculating the offset voltage to apply. Currently, the
-         * default value is set, but you can use the function to set one
-         * of your own.
-         *
-         * @param vOffset Desired offset voltage
-         */
-        void setVoltageOffset(float vOffset)
-        {
-            otp538u_set_voltage_offset(m_otp538u, vOffset);
-        };
-
-        /**
-         * Sets the output resistance value
-         *
-         * The Seeed Studio wiki example uses a value of 2,000,000 in one of
-         * the equations used to calculate voltage. The value is the
-         * resistance of a resistor they use in the output stage of their
-         * SIG2 output. This was 'decoded' by looking at the EAGLE* files
-         * containing their schematics for this device.
-         *
-         * @param outResistance Value of the output resistor; default is 2M Ohm
-         */
-        void setOutputResistence(int outResistance)
-        {
-            otp538u_set_output_resistence(m_otp538u, outResistance);
-        };
-
-        /**
-         * Sets the reference voltage of the internal Seeed Studio voltage
-         * regulator on the sensor board.
-         *
-         * The Seeed Studio wiki example uses a value of 2.5 in one of the
-         * equations used to calculate the resistance of the ambient
-         * thermistor. The value is the voltage of an internal voltage
-         * regulator used on the sensor board. This was 'decoded' by
-         * looking at the EAGLE files containing their schematics for this
-         * device.
-         *
-         * @param vref Reference voltage of the internal sensor; default
-         * is 2.5
-         */
-        void setVRef(float vref)
-        {
-            otp538u_set_ivref(m_otp538u, vref);
-        };
-
-        /**
-         * Enable debugging output.
-         *
-         * @param enable true to enable some debug output, false otherwise
-         */
-        void setDebug(bool enable)
-        {
-            otp538u_set_debug(m_otp538u, enable);
-        };
-
-
-    protected:
-        otp538u_context m_otp538u;
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        OTP538U(const OTP538U&) = delete;
-        OTP538U &operator=(const OTP538U&) = delete;
-    };
-}
-
-
diff --git a/src/otp538u/otp538u.json b/src/otp538u/otp538u.json
deleted file mode 100644
index 0b00b0d..0000000
--- a/src/otp538u/otp538u.json
+++ /dev/null
@@ -1,67 +0,0 @@
-{
-    "Library": "otp538u",
-    "Description": "Oriental System Technology OTP538U IR Temperature Sensor library",
-    "Sensor Class": {
-        "OTP538U": {
-            "Name": "API for the Oriental System Technology OTP538U IR Temperature Sensor",
-            "Description": "This is the UPM Module for the Oriental System Technology OTP538U IR Temperature Sensor. This Grove-Infrared temperature sensor is a non-contact temperature measure model.The sensor is composed of 116 elements of thermocouple in series on a floating micro-membrane having an active diameter of 545Î¼m and with blacken surface to absorb the incident thermal infrared radiation, which induces a voltage response at output terminals.",
-            "Aliases": ["otp538u", "Grove - Infrared Temperature Sensor"],
-            "Categories": ["light", "temperature"],
-            "Connections": ["analog"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["Oriental System Technology", "Seeed"],
-            "Kits": ["hak"],
-            "Image": "otp538u.jpg",
-            "Examples": {
-                "Java": ["OTP538U_Example.java"],
-                "Python": ["otp538u.py"],
-                "Node.js": ["otp538u.js"],
-                "C++": ["otp538u.cxx"],
-                "C": ["otp538u.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.0,
-                    "max": 5.0
-                },
-                "Supply Current": {
-                    "unit": "uA",
-                    "min" : 160,
-                    "max" : 200
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -10,
-                    "max": 80
-                },
-                "Effective Temperature Range": {
-                    "unit": "Â°C",
-                    "min" : -10,
-                    "max" : 100
-                },
-                "Accuracy": {
-                    "unit": "Â°C",
-                    "min" : -2,
-                    "max" : 2
-                },
-                "Holding Time": {
-                    "unit": "s",
-                    "time": 2
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield", "Will NOT work on 3.3V"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-Infrared-Temperature-Sensor-p-1058.html", "http://wiki.seeed.cc/Grove-Infrared_Temperature_Sensor/"],
-                "Datasheets": ["http://wiki.seeedstudio.com/images/f/f2/OTP-538Udatasheet.zip"]
-            }
-        }
-    }
-}
diff --git a/src/otp538u/otp538u_fti.c b/src/otp538u/otp538u_fti.c
deleted file mode 100644
index 27373ff..0000000
--- a/src/otp538u/otp538u_fti.c
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-
-#include "otp538u.h"
-
-#include "upm_fti.h"
-#include "fti/upm_sensor.h"
-
-/**
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_otp538u_name[] = "OTP538U";
-const char upm_otp538u_description[] = "IR Temperature Sensor";
-const upm_protocol_t upm_otp538u_protocol[] = {UPM_ANALOG, UPM_ANALOG};
-const upm_sensor_t upm_otp538u_category[] = {UPM_TEMPERATURE};
-
-// forward declarations
-const upm_sensor_descriptor_t upm_otp538u_get_descriptor();
-const void* upm_otp538u_get_ft(upm_sensor_t sensor_type);
-upm_result_t upm_otp538u_get_value_temperature(void* dev, float* tempval,
-                                               upm_temperature_u unit);
-void* upm_otp538u_init_name();
-void upm_otp538u_close(void* dev);
-
-const upm_sensor_descriptor_t upm_otp538u_get_descriptor() {
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_otp538u_name;
-    usd.description = upm_otp538u_description;
-    usd.protocol_size = 2;
-    usd.protocol = upm_otp538u_protocol;
-    usd.category_size = 1;
-    usd.category = upm_otp538u_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = &upm_otp538u_init_name,
-    .upm_sensor_close = &upm_otp538u_close,
-    .upm_sensor_get_descriptor = &upm_otp538u_get_descriptor
-};
-
-static const upm_temperature_ft tft =
-{
-    .upm_temperature_get_value = &upm_otp538u_get_value_temperature
-};
-
-const void* upm_otp538u_get_ft(upm_sensor_t sensor_type) {
-    if(sensor_type == UPM_SENSOR) {
-        return &ft;
-    }
-    if(sensor_type == UPM_TEMPERATURE) {
-        return &tft;
-    }
-    return NULL;
-}
-
-void* upm_otp538u_init_name(){
-    return NULL;
-}
-
-void upm_otp538u_close(void* dev)
-{
-    otp538u_close((otp538u_context)dev);
-}
-
-upm_result_t upm_otp538u_get_value_temperature(void* dev, float* tempval,
-                                               upm_temperature_u unit)
-{
-    float temp = 0.0;
-    upm_result_t rv = otp538u_get_object_temperature((otp538u_context)dev,
-                                                     &temp);
-
-    if (rv != UPM_SUCCESS)
-        return rv;
-
-    switch (unit)
-        {
-        case CELSIUS:
-            *tempval = temp;
-            return UPM_SUCCESS;
-
-        case KELVIN:
-            *tempval = temp + 273.15;
-            return UPM_SUCCESS;
-
-        case FAHRENHEIT:
-            *tempval = temp * (9.0/5.0) + 32.0;
-            return UPM_SUCCESS;
-        }
-
-    return UPM_ERROR_INVALID_PARAMETER;
-}
diff --git a/src/otp538u/thermister_rt_table.h b/src/otp538u/thermister_rt_table.h
deleted file mode 100644
index 478a747..0000000
--- a/src/otp538u/thermister_rt_table.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-// This table was taken from the '538RT_table.pdf' datasheet. It maps
-// resistance values to ambient temperatures starting at -20C and
-// going up to 200C in increments of 1C
-
-static const int otp538u_rt_table_max = 121;
-
-static int otp538u_rt_table[121] = {
-  919730, 869299, 821942, 777454, 735644, 696336, 659365, 624578, 591834,
-  561002, 531958, 504588, 478788, 454457, 431504, 409843, 389394, 370082,
-  351839, 334598, 318300, 302903, 288329, 274533, 261471, 249100, 237381,
-  226276, 215750, 205768, 196300, 187316, 178788, 170691, 163002, 155700,
-  148766, 142183, 135936, 130012, 124400, 119038, 113928, 109059, 104420,
-  100000, 95788, 91775, 87950, 84305, 80830, 77517, 74357, 71342, 68466,
-  65720, 63098, 60595, 58202, 55916, 53730, 51645, 49652, 47746, 45924,
-  44180, 42511, 40912, 39380, 37910, 36500, 35155, 33866, 32631, 31446,
-  30311, 29222, 28177, 27175, 26213, 25290, 24403, 23554, 22738, 21955,
-  21202, 20479, 19783, 19115, 18472, 17854, 17260, 16688, 16138, 15608,
-  15098, 14608, 14135, 13680, 13242, 12819, 12412, 12020, 11642, 11278,
-  10926, 10587, 10260, 9945, 9641, 9347, 9063, 8789, 8525, 8270, 8023,
-  7785, 7555, 7333, 7118, 6911
-};
diff --git a/src/otp538u/thermopile_vt_table.h b/src/otp538u/thermopile_vt_table.h
deleted file mode 100644
index c6b49ee..0000000
--- a/src/otp538u/thermopile_vt_table.h
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-// This table was taken from the '538U VT Table__20_200(v1.3).pdf'
-// datasheet, but the 25C column has been removed for consistency.
-
-static const int otp538u_vt_table_max = 23;
-
-// Thermistor temperature (C)
-// { -20 -10 0 10 20 30 40 50 60 70 80 90 100 }
-
-static float otp538u_vt_table[23][13] = {
-                                                  // object temp (C)
-  {0.000, -0.246, -0.523, -0.832, -1.177, -1.559, // -20C
-   -1.981, -2.446, -2.957, -3.516, -4.126, -4.791, -5.513},
-
-  {0.243, 0.000, -0.274, -0.580, -0.922, -1.301, // -10
-   -1.721, -2.183, -2.691, -3.247, -3.854, -4.516, -5.236},
-
-  {0.511, 0.271, 0.000, -0.303, -0.642, -1.018, // 0
-   -1.434, -1.894, -2.398, -2.951, -3.556, -4.215, -4.931},
-
-  {0.804, 0.567, 0.300, 0.000, -0.335, -0.708, // 10
-   -1.121, -1.577, -2.078, -2.628, -3.229, -3.884, -4.597},
-
-  {1.125, 0.891, 0.628, 0.331, 0.000, -0.369, // 20
-   -0.778, -1.230, -1.728, -2.274, -2.871, -3.523, -4.232},
-
-  {1.474, 1.244, 0.985, 0.692, 0.365, 0.000, // 30
-   -0.405, -0.853, -1.347, -1.889, -2.482, -3.130, -3.835},
-
-  {1.852, 1.628, 1.372, 1.084, 0.761, 0.401, // 40
-   0.000, -0.444, -0.933, -1.470, -2.059, -2.702, -3.403},
-
-  {2.263, 2.043, 1.792, 1.509, 1.191, 0.835, // 50
-   0.439, 0.000, -0.484, -1.017, -1.601, -2.240, -2.936},
-
-  {2.706, 2.491, 2.246, 1.968, 1.655, 1.304, // 60
-   0.913, 0.479, 0.000, -0.528, -1.107, -1.740, -2.431},
-
-  {3.184, 2.975, 2.735, 2.462, 2.155, 1.809, // 70
-   1.424, 0.996, 0.522, 0.000, -0.573, -1.201, -1.887},
-
-  {3.698, 3.495, 3.261, 2.994, 2.692, 2.353, // 80
-   1.974, 1.552, 1.084, 0.568, 0.000, -0.622, -1.301},
-
-  {4.250, 4.053, 3.825, 3.565, 3.270, 2.937, // 90
-   2.564, 2.148, 1.687, 1.177, 0.616, 0.000, -0.673},
-
-  {4.841, 4.651, 4.430, 4.177, 3.888, 3.562, // 100
-   3.196, 2.787, 2.332, 1.829, 1.275, 0.666, 0.000},
-
-  {5.473, 5.290, 5.076, 4.830, 4.549, 4.231, // 110
-   3.872, 3.470, 3.023, 2.527, 1.980, 1.379, 0.720},
-
-  {6.147, 5.972, 5.767, 5.528, 5.255, 4.944, // 120
-   4.593, 4.199, 3.760, 3.272, 2.733, 2.139, 1.488},
-
-  {6.866, 6.699, 6.502, 6.272, 6.007, 5.705, // 130
-   5.362, 4.976, 4.545, 4.066, 3.535, 2.950, 2.307},
-
-  {7.631, 7.473, 7.285, 7.064, 6.808, 6.514, // 140
-   6.180, 5.803, 5.381, 4.910, 4.388, 3.812, 3.178},
-
-  {8.444, 8.295, 8.116, 7.905, 7.658, 7.373, // 150
-   7.049, 6.682, 6.269, 5.807, 5.295, 4.728, 4.103},
-
-  {9.306, 9.167, 8.998, 8.796, 8.560, 8.285, // 160
-   7.971, 7.613, 7.211, 6.759, 6.257, 5.700, 5.085},
-
-  {10.219, 10.091, 9.933, 9.741, 9.515, 9.251, // 170
-   8.947, 8.601, 8.208, 7.768, 7.276, 6.729, 6.125},
-
-  {11.185, 11.068, 10.921, 10.741, 10.526, 10.274, // 180
-   9.981, 9.645, 9.264, 8.835, 8.354, 7.818, 7.226},
-
-  {12.206, 12.101, 11.966, 11.798, 11.595, 11.354, // 190
-   11.073, 10.749, 10.380, 9.962, 9.493, 8.969, 8.388},
-
-  {13.284, 13.191, 13.068, 12.913, 12.722, 12.494, // 200
-   12.225, 11.914, 11.557, 11.152, 10.695, 10.184, 9.616}
-};
diff --git a/src/ozw/CMakeLists.txt b/src/ozw/CMakeLists.txt
deleted file mode 100644
index 353c7c0..0000000
--- a/src/ozw/CMakeLists.txt
+++ /dev/null
@@ -1,16 +0,0 @@
-if (OPENZWAVE_FOUND)
-  set (libname "ozw")
-  set (libdescription "Module for the OpenZWave Library Interface")
-  set (module_src ${libname}.cxx zwNode.cxx ozwinterface.cxx ozwdump.cxx aeotecss6.cxx aeotecsdg2.cxx aeotecdw2e.cxx aeotecdsb09104.cxx tzemt400.cxx)
-  set (module_hpp ${libname}.hpp ozwinterface.hpp ozwdump.hpp aeotecss6.hpp aeotecsdg2.hpp aeotecdw2e.hpp aeotecdsb09104.hpp tzemt400.hpp)
-
-  set (reqlibname "libopenzwave")
-  upm_module_init(${OPENZWAVE_LIBRARIES} ${CMAKE_THREAD_LIBS_INIT})
-  target_include_directories(${libname} PUBLIC ${OPENZWAVE_INCLUDE_DIRS})
-
-  # openzwave/aes/aes.h has unknown pragmas, disable warning -Wunknown-pragmas
-  compiler_flag_supported(CXX is_supported -Wno-unknown-pragmas)
-  if (is_supported)
-      target_compile_options(${libname} PUBLIC -Wno-unknown-pragmas)
-  endif (is_supported)
-endif ()
diff --git a/src/ozw/aeotecdsb09104.cxx b/src/ozw/aeotecdsb09104.cxx
deleted file mode 100644
index 844fe07..0000000
--- a/src/ozw/aeotecdsb09104.cxx
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <iostream>
-#include <stdexcept>
-
-#include "aeotecdsb09104.hpp"
-
-using namespace upm;
-using namespace std;
-
-
-AeotecDSB09104::AeotecDSB09104(int nodeID) :
-  ozwInterface(nodeID)
-{
-}
-
-AeotecDSB09104::~AeotecDSB09104()
-{
-}
-
-float AeotecDSB09104::getWattsC1()
-{
-  return m_instance->getValueAsFloat(m_nodeID, INDEX_PowerC1);
-}
-
-float AeotecDSB09104::getWattsC2()
-{
-  return m_instance->getValueAsFloat(m_nodeID, INDEX_PowerC2);
-}
-
-float AeotecDSB09104::getWattsC3()
-{
-  return m_instance->getValueAsFloat(m_nodeID, INDEX_PowerC3);
-}
-
-float AeotecDSB09104::getEnergyC1()
-{
-  return m_instance->getValueAsFloat(m_nodeID, INDEX_EnergyC1);
-}
-
-float AeotecDSB09104::getEnergyC2()
-{
-  return m_instance->getValueAsFloat(m_nodeID, INDEX_EnergyC2);
-}
-
-float AeotecDSB09104::getEnergyC3()
-{
-  return m_instance->getValueAsFloat(m_nodeID, INDEX_EnergyC3);
-}
-
-int AeotecDSB09104::getBatteryLevel()
-{
-  return (int)m_instance->getValueAsByte(m_nodeID, INDEX_BatteryLevel);
-}
-void AeotecDSB09104::update()
-{
-  m_instance->refreshValue(m_nodeID, INDEX_PowerC1);
-  m_instance->refreshValue(m_nodeID, INDEX_PowerC2);
-  m_instance->refreshValue(m_nodeID, INDEX_PowerC3);
-  m_instance->refreshValue(m_nodeID, INDEX_EnergyC1);
-  m_instance->refreshValue(m_nodeID, INDEX_EnergyC2);
-  m_instance->refreshValue(m_nodeID, INDEX_EnergyC3);
-  m_instance->refreshValue(m_nodeID, INDEX_BatteryLevel);
-}
diff --git a/src/ozw/aeotecdsb09104.hpp b/src/ozw/aeotecdsb09104.hpp
deleted file mode 100644
index 74f0a53..0000000
--- a/src/ozw/aeotecdsb09104.hpp
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-
-#include "ozwinterface.hpp"
-
-namespace upm {
-
-  /**
-   * @library ozw
-   * @comname Aeotec Home Energy Meter Gen 1
-   * @sensor dsb09104
-   * @type wifi
-   * @con uart
-   * @man aeon
-   * @web http://aeotec.com/z-wave-home-energy-measure/918-home-energy-meter-instructions.html
-   *
-   * @brief UPM API for Aeotec Home Energy Meter Gen 1
-   *
-   * This module allows for monitoring certain elements of an Aeotec
-   * Home Energy Meter Gen 1.
-   *
-   * @snippet ozw-aeotecdsb09104.cxx Interesting
-   */
-
-  class AeotecDSB09104 : public ozwInterface {
-  public:
-
-    /**
-     * These values correspond to the index values of the given node
-     *
-     */
-    typedef enum : int {
-      INDEX_PowerC1                    = 0,
-      INDEX_PowerC2                    = 1,
-      INDEX_PowerC3                    = 2,
-      INDEX_EnergyC1                   = 3,
-      INDEX_EnergyC2                   = 4,
-      INDEX_EnergyC3                   = 5,
-      INDEX_BatteryLevel               = 18
-    } INDEX_VALUES_T;
-
-    /**
-     * AeotecDSB09104 constructor
-     *
-     * @param nodeID The ZWave node number of the device we are
-     * interested in.  Use the ozwdump example to see what nodes you
-     * have available.
-     */
-    AeotecDSB09104(int nodeID);
-
-    /**
-     * AeotecDSB09104 Destructor
-     */
-    ~AeotecDSB09104();
-
-    /**
-     * Get the current Watts reading from Channel 1.
-     *
-     * @return The Watts reading.
-     */
-    float getWattsC1();
-
-    /**
-     * Get the current Watts reading from Channel 2.
-     *
-     * @return The Watts reading.
-     */
-    float getWattsC2();
-
-    /**
-     * Get the current Watts reading from Channel 3.
-     *
-     * @return The Watts reading.
-     */
-    float getWattsC3();
-
-    /**
-     * Get the current Energy reading from Channel 1.  The value is in
-     * kWh.
-     *
-     * @return The Energy reading.
-     */
-    float getEnergyC1();
-
-    /**
-     * Get the current Energy reading from Channel 2.  The value is in
-     * kWh.
-     *
-     * @return The Energy reading.
-     */
-    float getEnergyC2();
-
-    /**
-     * Get the current Energy reading from Channel 3.  The value is in
-     * kWh.
-     *
-     * @return The Energy reading.
-     */
-    float getEnergyC3();
-
-    /**
-     * Query the device and update internal state.  Strictly speaking,
-     * this is not really neccessary -- a device may send this data on
-     * it's own at periodic intervals if configured to do so.  This
-     * method causes OZW to specifically query the device for it's
-     * current Energy, Watts, and Battery Level status.  The device
-     * may take some time to respond.
-     */
-    void update();
-
-    /**
-     * Return the current bettery level of the meter as a percentage.
-     * The number returned will be between 0-100.
-     *
-     * @return The Battery power level.
-     */
-    int getBatteryLevel();
-
-
-  protected:
-  private:
-  };
-}
diff --git a/src/ozw/aeotecdw2e.cxx b/src/ozw/aeotecdw2e.cxx
deleted file mode 100644
index ab4b493..0000000
--- a/src/ozw/aeotecdw2e.cxx
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <iostream>
-#include <stdexcept>
-
-#include "aeotecdw2e.hpp"
-
-using namespace upm;
-using namespace std;
-
-
-AeotecDW2E::AeotecDW2E(int nodeID) :
-  ozwInterface(nodeID)
-{
-}
-
-AeotecDW2E::~AeotecDW2E()
-{
-}
-
-bool AeotecDW2E::isDeviceAvailable()
-{
-  return m_instance->isNodeInfoReceived(m_nodeID);
-
-}
-
-bool AeotecDW2E::isAlarmTripped()
-{
-  if (isDeviceAvailable())
-    return m_instance->getValueAsBool(m_nodeID, INDEX_Alarm);
-  else
-    return false;
-}
-
-bool AeotecDW2E::isTamperTripped()
-{
-  if (isDeviceAvailable())
-    {
-      if (m_instance->getValueAsByte(m_nodeID, INDEX_AlarmLevel) > 0)
-        return true;
-      else
-        return false;
-    }
-  else
-    return false;
-}
-
-int AeotecDW2E::getBatteryLevel()
-{
-  if (isDeviceAvailable())
-    return (int)m_instance->getValueAsByte(m_nodeID, INDEX_BatteryLevel);
-  else
-    return 0;
-}
diff --git a/src/ozw/aeotecdw2e.hpp b/src/ozw/aeotecdw2e.hpp
deleted file mode 100644
index 3708a85..0000000
--- a/src/ozw/aeotecdw2e.hpp
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-
-#include "ozwinterface.hpp"
-
-namespace upm {
-
-  /**
-   * @library ozw
-   * @sensor DSB29
-   * @comname Aeotec Door/Window Sensor 2nd Edition
-   * @altname DSB29
-   * @type wifi
-   * @con uart
-   * @man aeon
-   * @web http://aeotec.com/z-wave-door-window-sensor
-   *
-   * @brief UPM API for Aeotec Door/Window Sensor 2nd Edition
-   *
-   * This module allows for monitoring certain elements of an Aeotec
-   * Door/Window Sensor 2nd Edition Z-Wave device.
-   *
-   * NOTE: This is a battery powered device that spends most of it's
-   * time sleeping (sort of like a cat). This means that on initial
-   * startup, there is not enough information known about the device
-   * to reliably query anything.  Use isDeviceAvailable() to test
-   * whether the device has responded to OZW's probe request before
-   * requesting information for it.
-   *
-   * The device information should become known once the device has
-   * awakened, either via it's configuration, or manually via the
-   * include button on the device.  By default the device will never
-   * wake on it's own, so you should use the openzwave control panel
-   * or similar software to configure a periodic wakeup time.
-   *
-   * @snippet ozw-aeotecdw2e.cxx Interesting
-   */
-
-  class AeotecDW2E : public ozwInterface {
-  public:
-
-    /**
-     * These values correspond to the index values of the given node
-     *
-     */
-    typedef enum : int {
-      INDEX_Alarm                      = 0, // alarm
-      INDEX_AlarmLevel                 = 2, // tamper switch
-      INDEX_BatteryLevel               = 3
-    } INDEX_VALUES_T;
-
-    /**
-     * AeotecDW2E constructor
-     *
-     * @param nodeID The ZWave node number of the device we are
-     * interested in.  Use the ozwdump example to see what nodes you
-     * have available.
-     */
-    AeotecDW2E(int nodeID);
-
-    /**
-     * AeotecDW2E Destructor
-     */
-    ~AeotecDW2E();
-
-    /**
-     * Returns true if the node (device) information has been
-     * received yet, false otherwise.  A sleeping node (like this
-     * device) will not be available for monitoring until all node
-     * info has been received.  This will occur once the device has
-     * been awakened and has responded to OZW's probe request.
-     *
-     * @return true if the node is available, false otherwise.
-     */
-    bool isDeviceAvailable();
-
-    /**
-     * Return the alarm value.  If the device is not available yet
-     * (see isDeviceAvailable()), false will always be returned.
-     *
-     * @return true if in the tripped state, false otherwise.
-     */
-    bool isAlarmTripped();
-
-    /**
-     * Return the alarm's tamper switch valu.  If the device is not
-     * available yet (see isDeviceAvailable()), false will always be
-     * returned.
-     *
-     * @return true if in the tripped state, false otherwise.
-     */
-    bool isTamperTripped();
-
-    /**
-     * Return the current bettery level of the sensor as a percentage.
-     * The number returned will be between 0-100.  If the device is
-     * not available yet (see isDeviceAvailable()), 0 will always be
-     * returned.
-     *
-     * @return The Battery power level.
-     */
-    int getBatteryLevel();
-
-
-  protected:
-  private:
-  };
-}
diff --git a/src/ozw/aeotecsdg2.cxx b/src/ozw/aeotecsdg2.cxx
deleted file mode 100644
index c6ff1c5..0000000
--- a/src/ozw/aeotecsdg2.cxx
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <iostream>
-#include <stdexcept>
-
-#include "aeotecsdg2.hpp"
-
-using namespace upm;
-using namespace std;
-
-
-AeotecSDG2::AeotecSDG2(int nodeID) :
-  ozwInterface(nodeID)
-{
-}
-
-AeotecSDG2::~AeotecSDG2()
-{
-}
-
-void AeotecSDG2::setLevel(int level)
-{
-  // level must be between 0-99, so we clamp it
-  if (level < 0)
-    level = 0;
-  if (level > 99)
-    level = 99;
-
-  m_instance->setValueAsByte(m_nodeID, INDEX_Level, level);
-}
-
-int AeotecSDG2::getLevel()
-{
-  return m_instance->getValueAsByte(m_nodeID, INDEX_Level);
-}
-
-bool AeotecSDG2::isOn()
-{
-  if (m_instance->getValueAsByte(m_nodeID, INDEX_Level) > 0)
-    return true;
-  else
-    return false;
-}
-
-float AeotecSDG2::getEnergy()
-{
-  return m_instance->getValueAsFloat(m_nodeID, INDEX_Energy_kWh);
-}
-
-float AeotecSDG2::getWatts()
-{
-  return m_instance->getValueAsFloat(m_nodeID, INDEX_Power_Watts);
-}
-
-float AeotecSDG2::getVolts()
-{
-  return m_instance->getValueAsFloat(m_nodeID, INDEX_Volts);
-}
-
-float AeotecSDG2::getCurrent()
-{
-  return m_instance->getValueAsFloat(m_nodeID, INDEX_Current);
-}
-
-void AeotecSDG2::update()
-{
-  m_instance->refreshValue(m_nodeID, INDEX_Level);
-  m_instance->refreshValue(m_nodeID, INDEX_Energy_kWh);
-  m_instance->refreshValue(m_nodeID, INDEX_Power_Watts);
-  m_instance->refreshValue(m_nodeID, INDEX_Volts);
-  m_instance->refreshValue(m_nodeID, INDEX_Current);
-}
diff --git a/src/ozw/aeotecsdg2.hpp b/src/ozw/aeotecsdg2.hpp
deleted file mode 100644
index 976dad7..0000000
--- a/src/ozw/aeotecsdg2.hpp
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-
-#include "ozwinterface.hpp"
-
-namespace upm {
-
-  /**
-   * @library ozw
-   * @sensor dg2
-   * @comname Aeotec Smart Dimmer Gen 2
-   * @con uart
-   * @type wifi
-   * @man aeon
-   * @web http://aeotec.com/z-wave-in-wall-switches/877-micro-sei-2e-manual-instructions.html
-   *
-   * @brief UPM API for Aeotec Smart Dimmer Gen 2
-   *
-   * This module allows for controlling and monitoring certain
-   * elements of an Aeotec Smart Dimmer Gen 2.
-   *
-   * @snippet ozw-aeotecsdg2.cxx Interesting
-   */
-
-  class AeotecSDG2 : public ozwInterface {
-  public:
-
-    /**
-     * These values correspond to the index values of the given node
-     *
-     */
-    typedef enum : int {
-      INDEX_Level                      = 0,
-      INDEX_Energy_kWh                 = 3,
-      INDEX_Power_Watts                = 6,
-      INDEX_Volts                      = 9,
-      INDEX_Current                    = 12
-    } INDEX_VALUES_T;
-
-    /**
-     * AeotecSDG2 constructor
-     *
-     * @param nodeID The ZWave node number of the device we are
-     * interested in.  Use the ozwdump example to see what nodes you
-     * have available.
-     */
-    AeotecSDG2(int nodeID);
-
-    /**
-     * AeotecSDG2 Destructor
-     */
-    ~AeotecSDG2();
-
-    /**
-     * Set the output level of the dimmer switch.  This is a value
-     * between 0 (fully off) and 99 (fully on).
-     *
-     * @param level The desired output level of the dimmer switch.
-     * Valid values are between 0-99.
-     */
-    void setLevel(int level);
-
-    /**
-     * Return the current output level of the dimmer switch.  This
-     * will be a number between 0 (fully off) and 99 (fully on).
-     *
-     * @return the current dimmer output level.
-     */
-    int getLevel();
-
-    /**
-     * Turn the switch fully on by setting the highest level (99).
-     * This is equivalent to calling setLevel(99).
-     */
-    void on()
-    {
-      setLevel(99);
-    }
-
-    /**
-     * Turn the switch off by setting the lowest level (0).  This is
-     * equivalent to calling setLevel(0).
-     */
-    void off()
-    {
-      setLevel(0);
-    }
-
-    /**
-     * Check to see if the switch is on or off.  Any dimmer level
-     * greater that 0 is considered 'on'.
-     *
-     * @return true if the dimmer switch is on, false otherwise.
-     */
-    bool isOn();
-
-    /**
-     * Query the device and update internal state.  Strictly speaking,
-     * this is not really neccessary -- a device may send this data on
-     * it's own at periodic intervals.  This method causes OZW to
-     * specifically query the device for it's current Energy, Watts,
-     * Volts, Current, and dimmer Level status.  The device may take
-     * some time to respond.
-     */
-    void update();
-
-    /**
-     * Return the device's accumulated energy usage in kilo-watt-hours
-     * (kWh).
-     *
-     * @return The energy usage in kWh.
-     */
-    float getEnergy();
-
-    /**
-     * Return the device's current power consumption in Watts.
-     *
-     * @return The current power consumption in Watts.
-     */
-    float getWatts();
-
-    /**
-     * Return the device's current voltage measurement in Volts.
-     *
-     * @return The volts measurement.
-     */
-    float getVolts();
-
-    /**
-     * Return the device's current consumption in Amps.
-     *
-     * @return The current consumption measurement in Amps.
-     */
-    float getCurrent();
-
-
-  protected:
-  private:
-  };
-}
diff --git a/src/ozw/aeotecss6.cxx b/src/ozw/aeotecss6.cxx
deleted file mode 100644
index 3f9ad45..0000000
--- a/src/ozw/aeotecss6.cxx
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <iostream>
-#include <stdexcept>
-
-#include "aeotecss6.hpp"
-
-using namespace upm;
-using namespace std;
-
-
-AeotecSS6::AeotecSS6(int nodeID) :
-  ozwInterface(nodeID)
-{
-}
-
-AeotecSS6::~AeotecSS6()
-{
-}
-
-void AeotecSS6::on()
-{
-  m_instance->setValueAsBool(m_nodeID, INDEX_SwitchCtrl, true);
-}
-
-void AeotecSS6::off()
-{
-  m_instance->setValueAsBool(m_nodeID, INDEX_SwitchCtrl, false);
-}
-
-bool AeotecSS6::isOn()
-{
-  return m_instance->getValueAsBool(m_nodeID, INDEX_SwitchCtrl);
-}
-
-float AeotecSS6::getEnergy()
-{
-  return m_instance->getValueAsFloat(m_nodeID, INDEX_Energy_kWh);
-}
-
-float AeotecSS6::getWatts()
-{
-  return m_instance->getValueAsFloat(m_nodeID, INDEX_Power_Watts);
-}
-
-float AeotecSS6::getVolts()
-{
-  return m_instance->getValueAsFloat(m_nodeID, INDEX_Volts);
-}
-
-float AeotecSS6::getCurrent()
-{
-  return m_instance->getValueAsFloat(m_nodeID, INDEX_Current);
-}
-
-void AeotecSS6::update()
-{
-  m_instance->refreshValue(m_nodeID, INDEX_SwitchCtrl);
-  m_instance->refreshValue(m_nodeID, INDEX_Energy_kWh);
-  m_instance->refreshValue(m_nodeID, INDEX_Power_Watts);
-  m_instance->refreshValue(m_nodeID, INDEX_Volts);
-  m_instance->refreshValue(m_nodeID, INDEX_Current);
-}
diff --git a/src/ozw/aeotecss6.hpp b/src/ozw/aeotecss6.hpp
deleted file mode 100644
index 7d3fdfc..0000000
--- a/src/ozw/aeotecss6.hpp
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-
-#include "ozwinterface.hpp"
-
-namespace upm {
-
-  /**
-   * @library ozw
-   * @sensor ss6
-   * @comname Aeotec Smart Switch 6
-   * @con uart
-   * @type wifi
-   * @man aeon
-   * @web http://aeotec.com/z-wave-plug-in-switch
-   *
-   * @brief UPM API for Aeotec Smart Switch 6
-   *
-   * This module allows for controlling and monitoring certain
-   * elements of an Aeotec Smart Switch 6.
-   *
-   * @snippet ozw-aeotecss6.cxx Interesting
-   */
-
-  class AeotecSS6 : public ozwInterface {
-  public:
-
-    /**
-     * These values correspond to the index values of the given node
-     *
-     */
-    typedef enum : int {
-      INDEX_SwitchCtrl                 = 0,
-      INDEX_Energy_kWh                 = 4,
-      INDEX_Power_Watts                = 7,
-      INDEX_Volts                      = 8,
-      INDEX_Current                    = 9
-    } INDEX_VALUES_T;
-
-    /**
-     * AeotecSS6 constructor
-     *
-     * @param nodeID The ZWave node number of the device we are
-     * interested in.  Use the ozwdump example to see what nodes you
-     * have available.
-     */
-    AeotecSS6(int nodeID);
-
-    /**
-     * AeotecSS6 Destructor
-     */
-    ~AeotecSS6();
-
-    /**
-     * Turn the switch on.
-     */
-    void on();
-
-    /**
-     * Turn the switch off.
-     */
-    void off();
-
-    /**
-     * Check to see if the switch is on or off.
-     *
-     * @return true if the switch is on, false otherwise.
-     */
-    bool isOn();
-
-    /**
-     * Query the device and update internal state.  Strictly speaking,
-     * this is not really neccessary -- a device may send this data on
-     * it's own at periodic intervals.  This method causes OZW to
-     * specifically query the device for it's current Energy, Watts,
-     * Volts, Current, and Switch status.  The device may take some
-     * time to respond.
-     */
-    void update();
-
-    /**
-     * Return the device's accumulated energy usage in kilo-watt-hours
-     * (kWh).
-     *
-     * @return The energy usage in kWh.
-     */
-    float getEnergy();
-
-    /**
-     * Return the device's current power consumption in Watts.
-     *
-     * @return The current power consumption in Watts.
-     */
-    float getWatts();
-
-    /**
-     * Return the device's current voltage measurement in Volts.
-     *
-     * @return The volts measurement.
-     */
-    float getVolts();
-
-    /**
-     * Return the device's current consumption in Amps.
-     *
-     * @return The current consumption measurement in Amps.
-     */
-    float getCurrent();
-
-
-  protected:
-  private:
-  };
-}
diff --git a/src/ozw/ozw.cxx b/src/ozw/ozw.cxx
deleted file mode 100644
index d21aa34..0000000
--- a/src/ozw/ozw.cxx
+++ /dev/null
@@ -1,996 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015-2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <iostream>
-#include <stdexcept>
-#include <string>
-#include <pthread.h>
-
-#include "platform/Log.h"
-
-#include "zwNode.hpp"
-
-#include "ozw.hpp"
-
-using namespace upm;
-using namespace std;
-using namespace OpenZWave;
-
-// our singleton instance
-OZW* OZW::m_instance = 0;
-
-OZW::OZW()
-{
-  m_initialized = false;
-  m_mgrCreated = false;
-  m_driverFailed = false;
-  m_homeId = 0;
-
-  pthread_mutexattr_t mutexAttrib;
-  pthread_mutexattr_init(&mutexAttrib);
-  pthread_mutexattr_settype(&mutexAttrib, PTHREAD_MUTEX_RECURSIVE);
-
-  if (pthread_mutex_init(&m_nodeLock, &mutexAttrib))
-    {
-      pthread_mutexattr_destroy(&mutexAttrib);
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": pthread_mutex_init(nodeLock) failed");
-    }
-
-  pthread_mutexattr_destroy(&mutexAttrib);
-
-  if (pthread_mutex_init(&m_initLock, NULL))
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": pthread_mutex_init(initLock) failed");
-    }
-
-  // initialize our init conditional
-  if (pthread_cond_init(&m_initCond, NULL))
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": pthread_cond_init() failed");
-    }
-
-  setDebug(false);
-}
-
-OZW::~OZW()
-{
-  if (m_mgrCreated)
-    {
-      // remove the driver
-      if (m_driverIsHID)
-        Manager::Get()->RemoveDriver("HID");
-      else
-        Manager::Get()->RemoveDriver(m_devicePath);
-        
-      // remove the notification handler
-      Manager::Get()->RemoveWatcher(notificationHandler, this);
-
-      // now destroy Manager and Options.  Options must be destroyed
-      // after the Manager is destroyed.
-      Manager::Destroy();
-      Options::Destroy();
-    }
-
-  pthread_mutex_destroy(&m_nodeLock);
-  pthread_mutex_destroy(&m_initLock);
-  pthread_cond_destroy(&m_initCond);
-
-  // delete any nodes.  This should be safe after deleting the node
-  // mutex since the handler is no longer registered.
-  for (auto it = m_zwNodeMap.cbegin();
-       it != m_zwNodeMap.cend(); ++it)
-    {
-      // delete the zwNode pointer
-      delete (*it).second;
-    }
-  // empty the map
-  m_zwNodeMap.clear();
-}
-
-OZW* OZW::instance()
-{
-  if (!m_instance)
-    m_instance = new OZW;
-
-  return m_instance;
-}
-
-void OZW::optionsCreate(std::string configPath, 
-                        std::string userConfigDir,
-                        std::string cmdLine)
-{
-  Options::Create(configPath, userConfigDir, cmdLine);
-}
-
-void OZW::optionAddInt(std::string name, int val)
-{
-  if (!Options::Get()->AreLocked())
-    Options::Get()->AddOptionInt(name, val);
-}
-
-void OZW::optionAddBool(std::string name, bool val)
-{
-  if (!Options::Get()->AreLocked())
-    Options::Get()->AddOptionBool(name, val);
-}
-
-void OZW::optionAddString(std::string name, std::string val, bool append)
-{
-  if (!Options::Get()->AreLocked())
-    Options::Get()->AddOptionString(name, val, append);
-}
-
-void OZW::optionsLock()
-{
-  // lock the options if not already locked
-  if (!Options::Get()->AreLocked())
-    Options::Get()->Lock();
-}
-
-bool OZW::init(string devicePath, bool isHID)
-{
-  if (m_initialized)
-    {
-      // we are already initialized...
-      if (m_debugging)
-        cerr << __FUNCTION__ << ": Already initialized, continuing..."
-             << endl;
-
-      return true;
-    }
-
-  // make sure options are locked
-  optionsLock();
-
-  pthread_mutex_lock(&m_initLock);
-
-  // the fun begins
-  Manager::Create();
-
-  // add our event handler
-  Manager::Get()->AddWatcher(notificationHandler, this);
-
-  // now add the driver
-  m_devicePath = devicePath;
-  if (isHID)
-    {
-      m_driverIsHID = true;
-      Manager::Get()->AddDriver("HID",
-                                Driver::ControllerInterface_Hid);
-    }
-  else
-    Manager::Get()->AddDriver(devicePath);
-
-  m_mgrCreated = true;
-
-  // now we block here waiting for the driver to get far enough along
-  // (or fail) to proceed further
-  pthread_cond_wait(&m_initCond, &m_initLock);
-
-  if (m_driverFailed)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": driver initialization failed");
-      return false;
-    }
-
-  // if we succeeded, update (sort) all of the VIDs in each zwNode, and
-  // enable autoupdating from here on out.
-
-  lockNodes();
-  for (auto it = m_zwNodeMap.cbegin();
-       it != m_zwNodeMap.cend(); ++it)
-    {
-      (*it).second->updateVIDMap();
-      (*it).second->setAutoUpdate(true);
-    }
-  unlockNodes();
-
-  m_initialized = true;
-  return true;
-}
-
-void OZW::notificationHandler(Notification const* notification, void *ctx)
-{
-  upm::OZW *This = (upm::OZW *)ctx;
-  
-  This->lockNodes();
-
-  if (This->m_debugging)
-    fprintf(stderr, "### %s: homeId %08x, nodeId %d, type %x\n",
-            __FUNCTION__,
-            notification->GetHomeId(),
-            notification->GetNodeId(),
-            notification->GetType());
-  
-  const uint32_t homeId = notification->GetHomeId();
-  const uint8_t nodeId = notification->GetNodeId();
-
-  switch (notification->GetType()) 
-    {
-
-    case Notification::Type_NodeAdded:
-    case Notification::Type_NodeNew:
-      {
-        if (This->m_debugging)
-          cerr << "### ### ADDING NODE: " << int(nodeId) << endl;
-        zwNode *node = new zwNode(homeId, nodeId);
-        This->m_zwNodeMap.insert(std::pair<uint8_t, zwNode *>(nodeId, node));
-
-        break;
-      }
-
-    case Notification::Type_NodeRemoved:
-      { 
-        if (This->m_debugging)
-          cerr << "### ### REMOVING NODE: " << int(nodeId) << endl;
-        if (This->m_zwNodeMap.count(nodeId) != 0)
-          {
-            delete This->m_zwNodeMap[nodeId];
-            This->m_zwNodeMap.erase(nodeId);
-          }
-
-        break;
-      }
-
-    case Notification::Type_ValueAdded:
-      {
-        if (This->m_debugging)
-          cerr << "### ### VALUE ADDED " << endl;
-        This->m_zwNodeMap[nodeId]->addValueID(notification->GetValueID());
-
-        break;
-      }
-      
-    case Notification::Type_ValueRemoved:
-      {
-        if (This->m_debugging)
-          cerr << "### ### VALUE DELETED " << endl;
-        This->m_zwNodeMap[nodeId]->removeValueID(notification->GetValueID());
-
-        break;
-      }
-
-    case Notification::Type_ValueChanged:
-      {
-        // might be able to do something with this someday...
-        break;
-      }
-
-    case Notification::Type_DriverReset:
-      {
-        // all nodes deleted.  According to OZW docs, this happens
-        // when a driver is reset, instead of sending potentially
-        // hundreds of ValueRemoved/NodeRemoved events.
-        for (auto it = This->m_zwNodeMap.begin();
-             it != This->m_zwNodeMap.end(); ++it)
-          {
-            // delete the zwNode pointer
-            delete (*it).second;
-          }
-        // empty the map
-        This->m_zwNodeMap.clear();
-
-        break;
-      }
-
-    case Notification::Type_DriverReady:
-      {
-        if (This->m_debugging)
-          fprintf(stderr, "### DriverReady, homeID = %08x\n", This->m_homeId);
-        This->m_homeId = notification->GetHomeId();
-        break;
-      }
-
-    case Notification::Type_DriverFailed:
-      {
-        if (This->m_debugging)
-          cerr << "### Driver FAILED" << endl;
-        This->m_driverFailed = true;
-        // wake up init()
-        pthread_cond_broadcast(&(This->m_initCond));
-        break;
-      }
-
-    case Notification::Type_AwakeNodesQueried:
-    case Notification::Type_AllNodesQueried:
-    case Notification::Type_AllNodesQueriedSomeDead:
-      {
-        if (This->m_debugging)
-          cerr << "### Awake/All/SomeDead complete" << endl;
-        // wake up init()
-        pthread_cond_broadcast(&(This->m_initCond));
-        break;
-      }
-
-      // might be able to do something with these someday too
-    case Notification::Type_Notification:
-    case Notification::Type_NodeNaming:
-    case Notification::Type_NodeProtocolInfo:
-    case Notification::Type_NodeQueriesComplete:
-    case Notification::Type_PollingEnabled:
-    case Notification::Type_PollingDisabled:
-    case Notification::Type_NodeEvent:
-    case Notification::Type_Group:
-    default:
-      {
-        break;
-      }
-    }
-
-  This->unlockNodes();
-}
-
-void OZW::dumpNodes(bool all)
-{
-  // iterate through all the nodes and dump various info on them
-
-  lockNodes();
-
-  for (auto it = m_zwNodeMap.cbegin();
-       it != m_zwNodeMap.cend(); ++it)
-    {
-      uint8_t nodeId = (*it).first;
-
-      cerr << "Node " << int(nodeId)
-           << ": "
-           << Manager::Get()->GetNodeProductName(m_homeId, nodeId)
-           << endl;
-      cerr << "\t"
-           << "Type: "
-           << Manager::Get()->GetNodeType(m_homeId, nodeId)
-           << endl;
-      cerr << "\t"
-           << "Product Type: "
-           << Manager::Get()->GetNodeProductType(m_homeId, nodeId)
-           << endl;
-      cerr << "\t"
-           << "Manufacturer ID: "
-           << Manager::Get()->GetNodeManufacturerId(m_homeId, nodeId)
-           << endl;
-      cerr << "\t"
-           << "Product ID: "
-           << Manager::Get()->GetNodeProductId(m_homeId, nodeId)
-           << endl;
-      cerr << "\t"
-           << "Generic Type: "
-           << (int)Manager::Get()->GetNodeGeneric(m_homeId, nodeId)
-           << endl;
-      cerr << "\t"
-           << "Device Type: "
-           << (int)Manager::Get()->GetNodeDeviceType(m_homeId, nodeId)
-           << endl;
-      cerr << "\t"
-           << "Node Basic: "
-           << (int)Manager::Get()->GetNodeBasic(m_homeId, nodeId)
-           << endl;
-      cerr << "\t"
-           << "Node Query Stage: "
-           << Manager::Get()->GetNodeQueryStage(m_homeId, nodeId)
-           << endl;
-      cerr << "\t"
-           << "Is Node Info Rcvd: "
-           << Manager::Get()->IsNodeInfoReceived(m_homeId, nodeId)
-           << endl;
-
-      (*it).second->dumpNode(all);
-    }
-
-  unlockNodes();
-}
-
-bool OZW::getValueID(int nodeId, int index, ValueID *vid)
-{
-  // nodeId's are uint8_t's in OpenZWave, but we want to use int's to
-  // avoid hassles when dealing with SWIG, so here we just throw away
-  // everything except the first byte.
-  nodeId &= 0xff;
-
-  lockNodes();
-
-  zwNodeMap_t::iterator it;
-
-  it = m_zwNodeMap.find(nodeId);
-
-  if (it == m_zwNodeMap.end())
-    {
-      cerr << __FUNCTION__ << ": Node " << nodeId 
-           << " does not exist" << endl;
-      unlockNodes();
-      return false;
-    }
-
-  // now get the ValueID
-  if (!(*it).second->indexToValueID(index, vid))
-    {
-      cerr << __FUNCTION__ << ": Index " << index 
-           << " for node " << nodeId 
-           << " does not exist" << endl;
-      unlockNodes();
-      return false;
-    }
-
-  unlockNodes();
-  return true;
-}
-
-string OZW::getValueAsString(int nodeId, int index)
-{
-  // we have to play this game since there is no default ctor for ValueID
-  ValueID vid(m_homeId, (uint64)0);
-
-  string rv;
-
-  lockNodes();
-
-  if (getValueID(nodeId, index, &vid))
-    Manager::Get()->GetValueAsString(vid, &rv);
-
-  unlockNodes();
-
-  return rv;
-}
-
-string OZW::getValueUnits(int nodeId, int index)
-{
-  ValueID vid(m_homeId, (uint64)0);
-
-  lockNodes();
-
-  string rv;
-  if (getValueID(nodeId, index, &vid))
-    rv = Manager::Get()->GetValueUnits(vid);
-
-  unlockNodes();
-
-  return rv;
-}
-
-void OZW::setValueUnits(int nodeId, int index, string text)
-{
-  ValueID vid(m_homeId, (uint64)0);
-
-  lockNodes();
-
-  if (getValueID(nodeId, index, &vid))
-    Manager::Get()->SetValueUnits(vid, text);
-
-  unlockNodes();
-}
-
-string OZW::getValueLabel(int nodeId, int index)
-{
-  ValueID vid(m_homeId, (uint64)0);
-
-  lockNodes();
-
-  string rv;
-  if (getValueID(nodeId, index, &vid))
-    rv = Manager::Get()->GetValueLabel(vid);
-
-  unlockNodes();
-
-  return rv;
-}
-
-void OZW::setValueLabel(int nodeId, int index, string text)
-{
-  ValueID vid(m_homeId, (uint64)0);
-
-  lockNodes();
-
-  if (getValueID(nodeId, index, &vid))
-    Manager::Get()->SetValueLabel(vid, text);
-
-  unlockNodes();
-}
-
-string OZW::getValueHelp(int nodeId, int index)
-{
-  ValueID vid(m_homeId, (uint64)0);
-
-  lockNodes();
-
-  string rv;
-  if (getValueID(nodeId, index, &vid))
-    rv = Manager::Get()->GetValueHelp(vid);
-
-  unlockNodes();
-
-  return rv;
-}
-
-void OZW::setValueHelp(int nodeId, int index, string text)
-{
-  ValueID vid(m_homeId, (uint64)0);
-
-  lockNodes();
-
-  if (getValueID(nodeId, index, &vid))
-    Manager::Get()->SetValueHelp(vid, text);
-
-  unlockNodes();
-}
-
-void OZW::setValueAsBool(int nodeId, int index, bool val)
-{
-  if (isValueReadOnly(nodeId, index))
-    {
-      cerr << __FUNCTION__ << ": Node " << nodeId << " index " << index
-           << " is ReadOnly" << endl;
-      return;
-    }
-
-  ValueID vid(m_homeId, (uint64)0);
-
-  lockNodes();
-
-  if (getValueID(nodeId, index, &vid))
-    {
-      if (!Manager::Get()->SetValue(vid, val))
-        {
-          cerr << __FUNCTION__ << ": Value is not a bool type" << endl;
-        }
-    }
-
-  unlockNodes();
-}
-
-void OZW::setValueAsByte(int nodeId, int index, uint8_t val)
-{
-  if (isValueReadOnly(nodeId, index))
-    {
-      cerr << __FUNCTION__ << ": Node " << nodeId << " index " << index
-           << " is ReadOnly" << endl;
-      return;
-    }
-
-  ValueID vid(m_homeId, (uint64)0);
-
-  lockNodes();
-
-  if (getValueID(nodeId, index, &vid))
-    {
-      if (!Manager::Get()->SetValue(vid, val))
-        {
-          cerr << __FUNCTION__ << ": Value is not a byte type" << endl;
-        }
-    }
-
-  unlockNodes();
-}
-
-void OZW::setValueAsFloat(int nodeId, int index, float val)
-{
-  if (isValueReadOnly(nodeId, index))
-    {
-      cerr << __FUNCTION__ << ": Node " << nodeId << " index " << index
-           << " is ReadOnly" << endl;
-      return;
-    }
-
-  ValueID vid(m_homeId, (uint64)0);
-
-  lockNodes();
-
-  if (getValueID(nodeId, index, &vid))
-    {
-      if (!Manager::Get()->SetValue(vid, val))
-        {
-          cerr << __FUNCTION__ << ": Value is not a float type" << endl;
-        }
-    }
-
-  unlockNodes();
-}
-
-void OZW::setValueAsInt32(int nodeId, int index, int32_t val)
-{
-  if (isValueReadOnly(nodeId, index))
-    {
-      cerr << __FUNCTION__ << ": Node " << nodeId << " index " << index
-           << " is ReadOnly" << endl;
-      return;
-    }
-
-  ValueID vid(m_homeId, (uint64)0);
-
-  lockNodes();
-
-  if (getValueID(nodeId, index, &vid))
-    {
-      if (!Manager::Get()->SetValue(vid, val))
-        {
-          cerr << __FUNCTION__ << ": Value is not a int32 type" << endl;
-        }
-    }
-
-  unlockNodes();
-}
-
-void OZW::setValueAsInt16(int nodeId, int index, int16_t val)
-{
-  if (isValueReadOnly(nodeId, index))
-    {
-      cerr << __FUNCTION__ << ": Node " << nodeId << " index " << index
-           << " is ReadOnly" << endl;
-      return;
-    }
-
-  ValueID vid(m_homeId, (uint64)0);
-
-  lockNodes();
-
-  if (getValueID(nodeId, index, &vid))
-    {
-      if (!Manager::Get()->SetValue(vid, val))
-        {
-          cerr << __FUNCTION__ << ": Value is not a int16 type" << endl;
-        }
-    }
-
-  unlockNodes();
-}
-
-void OZW::setValueAsBytes(int nodeId, int index, uint8_t *val, uint8_t len)
-{
-  if (isValueReadOnly(nodeId, index))
-    {
-      cerr << __FUNCTION__ << ": Node " << nodeId << " index " << index
-           << " is ReadOnly" << endl;
-      return;
-    }
-
-  ValueID vid(m_homeId, (uint64)0);
-
-  lockNodes();
-
-  if (getValueID(nodeId, index, &vid))
-    {
-      if (!Manager::Get()->SetValue(vid, val, len))
-        {
-          cerr << __FUNCTION__ << ": Value is not a bytes type" << endl;
-        }
-    }
-
-  unlockNodes();
-}
-
-void OZW::setValueAsString(int nodeId, int index, string val)
-{
-  if (isValueReadOnly(nodeId, index))
-    {
-      cerr << __FUNCTION__ << ": Node " << nodeId << " index " << index
-           << " is ReadOnly" << endl;
-      return;
-    }
-
-  ValueID vid(m_homeId, (uint64)0);
-
-  lockNodes();
-
-  if (getValueID(nodeId, index, &vid))
-    {
-      if (!Manager::Get()->SetValue(vid, val))
-        {
-          // this should always succeed, but for consistancy...
-          cerr << __FUNCTION__ << ": Value is not a string type" << endl;
-        }
-    }
-
-  unlockNodes();
-}
-
-void OZW::refreshValue(int nodeId, int index)
-{
-  ValueID vid(m_homeId, (uint64)0);
-
-  lockNodes();
-
-  if (getValueID(nodeId, index, &vid))
-    Manager::Get()->RefreshValue(vid);
-
-  unlockNodes();
-}
-
-int OZW::getValueMin(int nodeId, int index)
-{
-  ValueID vid(m_homeId, (uint64)0);
-
-  lockNodes();
-
-  int rv = 0;
-  if (getValueID(nodeId, index, &vid))
-    rv = Manager::Get()->GetValueMin(vid);
-
-  unlockNodes();
-  return rv;
-}
-
-int OZW::getValueMax(int nodeId, int index)
-{
-  ValueID vid(m_homeId, (uint64)0);
-
-  lockNodes();
-
-  int rv = 0;
-  if (getValueID(nodeId, index, &vid))
-    rv = Manager::Get()->GetValueMax(vid);
-
-  unlockNodes();
-  return rv;
-}
-
-bool OZW::isValueReadOnly(int nodeId, int index)
-{
-  ValueID vid(m_homeId, (uint64)0);
-
-  lockNodes();
-
-  bool rv = false;
-  if (getValueID(nodeId, index, &vid))
-    rv = Manager::Get()->IsValueReadOnly(vid);
-
-  unlockNodes();
-  return rv;
-}
-
-bool OZW::isValueWriteOnly(int nodeId, int index)
-{
-  ValueID vid(m_homeId, (uint64)0);
-
-  lockNodes();
-
-  bool rv = false;
-  if (getValueID(nodeId, index, &vid))
-    rv = Manager::Get()->IsValueWriteOnly(vid);
-
-  unlockNodes();
-  return rv;
-}
-
-bool OZW::isValueSet(int nodeId, int index)
-{
-  ValueID vid(m_homeId, (uint64)0);
-
-  lockNodes();
-
-  bool rv = false;
-  if (getValueID(nodeId, index, &vid))
-    rv = Manager::Get()->IsValueSet(vid);
-
-  unlockNodes();
-  return rv;
-}
-
-bool OZW::isValuePolled(int nodeId, int index)
-{
-  ValueID vid(m_homeId, (uint64)0);
-
-  lockNodes();
-
-  bool rv = false;
-  if (getValueID(nodeId, index, &vid))
-    rv = Manager::Get()->IsValuePolled(vid);
-
-  unlockNodes();
-  return rv;
-}
-
-bool OZW::getValueAsBool(int nodeId, int index)
-{
-  if (isValueWriteOnly(nodeId, index))
-    {
-      cerr << __FUNCTION__ << ": Node " << nodeId << " index " << index
-           << " is WriteOnly" << endl;
-      return false;
-    }
-
-  ValueID vid(m_homeId, (uint64)0);
-
-  lockNodes();
-
-  bool rv = false;
-  if (getValueID(nodeId, index, &vid))
-    {
-      if (!Manager::Get()->GetValueAsBool(vid, &rv))
-        {
-          cerr << __FUNCTION__ << ": Value is not a bool type, returning " 
-               << rv << endl;
-        }
-    }
-
-  unlockNodes();
-  return rv;
-}
-
-uint8_t OZW::getValueAsByte(int nodeId, int index)
-{
-  if (isValueWriteOnly(nodeId, index))
-    {
-      cerr << __FUNCTION__ << ": Node " << nodeId << " index " << index
-           << " is WriteOnly" << endl;
-      return 0;
-    }
-
-  ValueID vid(m_homeId, (uint64)0);
-
-  lockNodes();
-
-  uint8_t rv = false;
-  if (getValueID(nodeId, index, &vid))
-    {
-      if (!Manager::Get()->GetValueAsByte(vid, &rv))
-        {
-          cerr << __FUNCTION__ << ": Value is not a byte type, returning " 
-               << int(rv) << endl;
-        }
-    }
-
-  unlockNodes();
-  return rv;
-}
-
-float OZW::getValueAsFloat(int nodeId, int index)
-{
-  if (isValueWriteOnly(nodeId, index))
-    {
-      cerr << __FUNCTION__ << ": Node " << nodeId << " index " << index
-           << " is WriteOnly" << endl;
-      return 0.0;
-    }
-
-  ValueID vid(m_homeId, (uint64)0);
-
-  lockNodes();
-
-  float rv = 0.0;
-  if (getValueID(nodeId, index, &vid))
-    {
-      if (!Manager::Get()->GetValueAsFloat(vid, &rv))
-        {
-          cerr << __FUNCTION__ << ": Value is not a float type, returning " 
-               << rv << endl;
-        }
-    }
-
-  unlockNodes();
-  return rv;
-}
-
-int OZW::getValueAsInt32(int nodeId, int index)
-{
-  if (isValueWriteOnly(nodeId, index))
-    {
-      cerr << __FUNCTION__ << ": Node " << nodeId << " index " << index
-           << " is WriteOnly" << endl;
-      return 0;
-    }
-
-  ValueID vid(m_homeId, (uint64)0);
-
-  lockNodes();
-
-  int32_t rv = 0;
-  if (getValueID(nodeId, index, &vid))
-    {
-      if (!Manager::Get()->GetValueAsInt(vid, &rv))
-        {
-          cerr << __FUNCTION__ << ": Value is not an int32 type, returning " 
-               << rv << endl;
-        }
-    }
-
-  unlockNodes();
-  return int(rv);
-}
-
-int OZW::getValueAsInt16(int nodeId, int index)
-{
-  if (isValueWriteOnly(nodeId, index))
-    {
-      cerr << __FUNCTION__ << ": Node " << nodeId << " index " << index
-           << " is WriteOnly" << endl;
-      return 0;
-    }
-
-  ValueID vid(m_homeId, (uint64)0);
-
-  lockNodes();
-
-  int16_t rv = 0;
-  if (getValueID(nodeId, index, &vid))
-    {
-      if (!Manager::Get()->GetValueAsShort(vid, &rv))
-        {
-          cerr << __FUNCTION__ << ": Value is not an int16 type, returning " 
-               << rv << endl;
-        }
-    }
-
-  unlockNodes();
-  return int(rv);
-}
-
-bool OZW::isNodeListeningDevice(int nodeId)
-{
-  nodeId &= 0xff;
-
-  lockNodes();
-
-  bool rv = Manager::Get()->IsNodeListeningDevice(m_homeId, nodeId);
-
-  unlockNodes();
-  return rv;
-}
-
-bool OZW::isNodeFrequentListeningDevice(int nodeId)
-{
-  nodeId &= 0xff;
-
-  lockNodes();
-
-  bool rv = Manager::Get()->IsNodeFrequentListeningDevice(m_homeId, nodeId);
-
-  unlockNodes();
-  return rv;
-}
-
-bool OZW::isNodeAwake(int nodeId)
-{
-  nodeId &= 0xff;
-
-  lockNodes();
-
-  bool rv = Manager::Get()->IsNodeAwake(m_homeId, nodeId);
-
-  unlockNodes();
-  return rv;
-}
-
-bool OZW::isNodeInfoReceived(int nodeId)
-{
-  nodeId &= 0xff;
-
-  lockNodes();
-
-  bool rv = Manager::Get()->IsNodeInfoReceived(m_homeId, nodeId);
-
-  unlockNodes();
-  return rv;
-}
-
-void OZW::setDebug(bool enable)
-{ 
-  m_debugging = enable; 
-
-  // To bad the following does not seem to affect anything.  The only
-  // way I've found to control it is via the options.xml file.
-
-  //  Log::SetLoggingState(enable);
-}
diff --git a/src/ozw/ozw.hpp b/src/ozw/ozw.hpp
deleted file mode 100644
index 5daadbe..0000000
--- a/src/ozw/ozw.hpp
+++ /dev/null
@@ -1,613 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015-2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <map>
-
-#include "Manager.h"
-#include "Notification.h"
-#include "Options.h"
-#include "Driver.h"
-#include "Node.h"
-#include "Group.h"
-#include "platform/Log.h"
-
-namespace upm {
-  
-  /**
-   * @brief OpenZWave Devices Library
-   * @defgroup ozw libupm-ozw
-   * @ingroup uart wifi
-   */
-
-  /**
-   * @library ozw
-   * @sensor ozw
-   * @comname Wrapper for the OpenZWave Library
-   * @type wifi
-   * @man other
-   * @con uart
-   * @web http://www.openzwave.com/
-   *
-   * @brief UPM API for the OpenZWave library
-   *
-   * This module implements a singleton wrapper around the OpenZWave
-   * library.  OpenZWave must be compiled and installed on your
-   * machine in order to use this library.
-   *
-   * This module was developed with OpenZWave 1.3/1.4, and an Aeon
-   * Z-Stick Gen5 configured as a Primary Controller.  It provides the
-   * ability to query and set various values that can be used to
-   * control ZWave devices.  It does not concern itself with
-   * configuration of devices.  It is assumed that you have already
-   * setup your ZWave network using a tool like the OpenZWave control
-   * panel, and have already configured your devices as appropriate.
-   *
-   * To avoid exposing some of the internals of OpenZWave, devices
-   * (nodes) and their values, are accessed via a nodeId and a value
-   * index number.  The ozwdump example will run dumpNodes() which
-   * will list the currently connected devices and the values that are
-   * available to them, along with an index number for that value.  It
-   * is through these values (nodeId and index) that you can query and
-   * set device values at a low level.
-   *
-   * In addition to querying values from a device (such as state
-   * (on/off), or temperature, etc), methods are provided to allow you
-   * to control these devices to the extent they allow, for example,
-   * using a ZWave connected switch to turn on a lamp.
-   *
-   * Access to this class by OZW drivers is handled by the
-   * ozwInterface class.  It is that class that drivers use for access
-   * to ozw, and therefore the Z-Wave network.
-   *
-   * This class is not intended to be used directly by end users.
-   * When writing an OZW driver, the ozwInterface class should be used
-   * (inherited) by your driver, and your driver should wrap and
-   * expose only those methods needed by the user.  Take a look at
-   * some of the drivers (like aeotecss6) to see how this works.
-   */
-
-  // forward declaration of private zwNode data
-  class zwNode;
-
-  class OZW {
-  public:
-
-    typedef std::map<uint8_t, zwNode *> zwNodeMap_t;
-
-    /**
-     * Get our singleton instance, initializing it if neccessary.  All
-     * requests to this class should be done through this instance
-     * accessor.
-     *
-     * @return static pointer to our class instance
-     */
-    static OZW* instance();
-
-    /**
-     * Start configuration with basic options.  This must be called
-     * prior to init(), after the OZW() constructor is called.
-     *
-     * @param configPath Set the location of the OpenZWave config
-     * directory, default is /etc/openzwave
-     * @param userConfigDir Set the path to the user configuration
-     * directory.  This is the location of the zwcfg*.xml and
-     * option.xml files for the user (probably created by the
-     * OpenZWave Control Panel example application).  The default is
-     * the current directory ("").
-     * @param cmdLine Specify command line formatted options to
-     * OpenZWave.  The default is "".
-     */
-    void optionsCreate(std::string configPath="/etc/openzwave", 
-                       std::string userConfigDir="",
-                       std::string cmdLine="");
-    
-    /**
-     * Add an integer Option.  See the OpenZWave documentation for
-     * valid values.
-     *
-     * @param name The name of the configuration option
-     * @param val The value to set it to
-     */
-    void optionAddInt(std::string name, int val);
-
-    /**
-     * Add a boolean Option.  See the OpenZWave documentation for
-     * valid values.
-     *
-     * @param name The name of the configuration option
-     * @param val The value to set it to
-     */
-    void optionAddBool(std::string name, bool val);
-
-    /**
-     * Add a string Option.  See the OpenZWave documentation for valid
-     * values.
-     *
-     * @param name The name of the configuration option
-     * @param val The value to set it to
-     * @append true to append to the option, false to override
-     */
-    void optionAddString(std::string name, std::string val, bool append);
-
-    /**
-     * Lock the Options.  This must be called after all options have
-     * been set, and before init() is called.  If init() is called
-     * without locking the Options, init() will lock them itself.
-     * After the options have been locked, no further options can be
-     * specified.
-     */
-    void optionsLock();
-
-    /**
-     * Initialize the ZWave network.  This method will start a probe
-     * of all defined devices on the ZWave network and query essential
-     * information about them.  This function will not return until
-     * either initialization has failed, or has succeeded far enough
-     * along for the following methods to work.  Depending on the size
-     * an complexity of the ZWave network, this may take anywhere from
-     * seconds to several minutes to complete.
-     *
-     * All Options (via option*()) must have been specified before
-     * this function is called.  If the Options have not been locked
-     * via optionsLock() prior to calling init(), this method will
-     * lock them for you before proceeding.
-     *
-     * @param devicePath The device path for the ZWave controller,
-     * typically something like /dev/ttyACM0, or similiar
-     * @param isHID true if this is a HID device, false otherwise (ie:
-     * a serial port like /dev/ttyACM0, /dev/ttyUSB0, etc).  Default
-     * is false.
-     * @return true if init succeeded, false otherwise
-     */
-    bool init(std::string devicePath, bool isHID=false);
-
-    /**
-     * Dump information about all configured nodes (devices) and their
-     * available values to stdout.  This is useful to determine what
-     * nodes are available, and the index (used for querying and
-     * seting values for them).  In addition, it includes information
-     * about each value (type, current value, etc).
-     *
-     * @param all set to true to dump information about all values
-     * available for each node.  If false, only information about
-     * 'user' values (ignoring 'system' and 'configuration') are
-     * output.  The default is false ('user' values only).
-     */
-    void dumpNodes(bool all=false);
-
-    /**
-     * Return a string (which may be empty) indicating the Units of
-     * measure for a given value.  For example, querying a temperature
-     * value may return "F" to indicate Fahrenheit.
-     *
-     * @param nodeId The node ID to query
-     * @param index The value index (see dumpNodes()) of the value to query.
-     * @return A string containing the Unit of measure for the value
-     */
-    std::string getValueUnits(int nodeId, int index);
-
-    /**
-     * Set the text for the Units of measure for a value.
-     *
-     * @param nodeId The node ID to query
-     * @param index The value index (see dumpNodes()) of the value to query.
-     * @param text The text to set
-     */
-    void setValueUnits(int nodeId, int index, std::string text);
-
-    /**
-     * Return a string (which may be empty) containing the
-     * user-freindly Label for a value.
-     *
-     * @param nodeId The node ID to query
-     * @param index The value index (see dumpNodes()) of the value to query.
-     * @return A string containing the Value's label
-     */
-    std::string getValueLabel(int nodeId, int index);
-
-    /**
-     * Set the text for a Value's label.
-     *
-     * @param nodeId The node ID to query
-     * @param index The value index (see dumpNodes()) of the value to query.
-     * @param text The text to set
-     */
-    void setValueLabel(int nodeId, int index, std::string text);
-
-    /**
-     * Return a string (which may be empty) indicating the Help text
-     * of a value, if available.
-     *
-     * @param nodeId The node ID to query
-     * @param index The value index (see dumpNodes()) of the value to query.
-     * @return A string containing the Help text, if available
-     */
-    std::string getValueHelp(int nodeId, int index);
-
-    /**
-     * Set the text for a Value's help text.
-     *
-     * @param nodeId The node ID to query
-     * @param index The value index (see dumpNodes()) of the value to query.
-     * @param text The text to set
-     */
-    void setValueHelp(int nodeId, int index, std::string text);
-
-    /**
-     * Set the contents of a Value to a string.  This should always
-     * succeed if the supplied content makes sense for a given value,
-     * regardless of the value's actual type.
-     *
-     * @param nodeId The node ID
-     * @param index The value index (see dumpNodes()) of the value to query.
-     * @param val the content to assign to the value referenced by
-     * nodeId, and index.
-     */
-    void setValueAsString(int nodeId, int index, std::string val);
-
-    /**
-     * Set the contents of a Value, to a bool.  This will fail, and an
-     * error message printed if the value type is not a boolean value.
-     *
-     * @param nodeId The node ID
-     * @param index The value index (see dumpNodes()) of the value to query.
-     * @param val the boolean content to assign to the value referenced
-     * by nodeId, and index.
-     */
-    void setValueAsBool(int nodeId, int index, bool val);
-
-    /**
-     * Set the contents of a Value, to a byte.  This will fail, and an
-     * error message printed if the value type is not a byte value.
-     *
-     * @param nodeId The node ID
-     * @param index The value index (see dumpNodes()) of the value to query.
-     * @param val the byte content to assign to the value referenced
-     * by nodeId, and index.
-     */
-    void setValueAsByte(int nodeId, int index, uint8_t val);
-
-    /**
-     * Set the contents of a Value, to a float.  This will fail, and an
-     * error message printed if the value type is not a float value.
-     *
-     * @param nodeId The node ID
-     * @param index The value index (see dumpNodes()) of the value to query.
-     * @param val the float content to assign to the value referenced
-     * by nodeId, and index.
-     */
-    void setValueAsFloat(int nodeId, int index, float val);
-
-    /**
-     * Set the contents of a Value, to a 32 bit integer (int32).  This
-     * will fail, and an error message printed if the value type is
-     * not an int32.
-     *
-     * @param nodeId The node ID
-     * @param index The value index (see dumpNodes()) of the value to query.
-     * @param val the int32 content to assign to the value referenced
-     * by nodeId, and index.
-     */
-    void setValueAsInt32(int nodeId, int index, int32_t val);
-
-    /**
-     * Set the contents of a Value, to a 16 bit integer (int16).  This
-     * will fail, and an error message printed if the value type is
-     * not an int16.
-     *
-     * @param nodeId The node ID
-     * @param index The value index (see dumpNodes()) of the value to query.
-     * @param val the int16 content to assign to the value referenced
-     * by nodeId, and index.
-     */
-    void setValueAsInt16(int nodeId, int index, int16_t val);
-
-    /**
-     * Set the contents of a Value, to an array of bytes.  This will
-     * fail, and an error message printed if the value type is not
-     * settable as an array of bytes.
-     *
-     * @param nodeId The node ID
-     * @param index The value index (see dumpNodes()) of the value to query.
-     * @param val the byte array content to assign to the value referenced
-     * by nodeId, and index.
-     * @param len The length of the byte array
-     */
-    void setValueAsBytes(int nodeId, int index, uint8_t *val, uint8_t len);
-
-    /**
-     * Get the minimum allowed value for a node's Value.
-     *
-     * @param nodeId The node ID
-     * @param index The value index (see dumpNodes()) of the value to query.
-     * @return The minumum allowed value
-     */
-    int getValueMin(int nodeId, int index);
-
-    /**
-     * Get the maximum allowed value for a node's Value.
-     *
-     * @param nodeId The node ID
-     * @param index The value index (see dumpNodes()) of the value to query.
-     * @return The maximum allowed value
-     */
-    int getValueMax(int nodeId, int index);
-
-    /**
-     * Test whether a value is read-only.
-     *
-     * @param nodeId The node ID
-     * @param index The value index (see dumpNodes()) of the value to query.
-     * @return true if the value is read-only, false otherwise
-     */
-    bool isValueReadOnly(int nodeId, int index);
-
-    /**
-     * Test whether a value is write only.
-     *
-     * @param nodeId The node ID
-     * @param index The value index (see dumpNodes()) of the value to query.
-     * @return true if the value is write-only, false otherwise
-     */
-    bool isValueWriteOnly(int nodeId, int index);
-
-    /**
-     * Test whether a value is really set on a node, and not a default
-     * value chosen by the OpenZWave library.
-     *
-     * @param nodeId The node ID
-     * @param index The value index (see dumpNodes()) of the value to query.
-     * @return true if the value is really set, false if a default value is
-     * being reported
-     */
-    bool isValueSet(int nodeId, int index);
-
-    /**
-     * Test whether a value is being manually polled by the OpenZWave
-     * library.  Most modern devices are never polled, rather they are
-     * configured to report changing values to the controller on their
-     * own at device specific intervals or when appropriate events
-     * (depending the device) have occurred.
-     *
-     * @param nodeId The node ID
-     * @param index The value index (see dumpNodes()) of the value to query.
-     * @return true if the value is being maually polled, false otherwise
-     * being reported
-     */
-    bool isValuePolled(int nodeId, int index);
-
-    /**
-     * Return the content of a value as a string.  This should always
-     * succeed, regardless of the actual value type.
-     *
-     * @param nodeId The node ID
-     * @param index The value index (see dumpNodes()) of the value to query.
-     * @return A string representing the current contents of a value.
-     */
-    std::string getValueAsString(int nodeId, int index);
-
-    /**
-     * Return the content of a value as a booleang.  This will fail,
-     * and an error message printed if the value type is not boolean.
-     *
-     * @param nodeId The node ID
-     * @param index The value index (see dumpNodes()) of the value to query.
-     * @return A boolean representing the current contents of a value.
-     */
-    bool getValueAsBool(int nodeId, int index);
-
-    /**
-     * Return the content of a value as a byte.  This will fail, and
-     * an error message printed if the value type is not a byte.
-     *
-     * @param nodeId The node ID
-     * @param index The value index (see dumpNodes()) of the value to query.
-     * @return A byte representing the current contents of a value.
-     */
-    uint8_t getValueAsByte(int nodeId, int index);
-
-    /**
-     * Return the content of a value as a float.  This will fail, and
-     * an error message printed if the value type is not a floating
-     * point value.
-     *
-     * @param nodeId The node ID
-     * @param index The value index (see dumpNodes()) of the value to query.
-     * @return A float representing the current contents of a value.
-     */
-    float getValueAsFloat(int nodeId, int index);
-
-    /**
-     * Return the content of a value as an int32.  This will fail, and
-     * an error message printed if the value type is not an int32.
-     *
-     * @param nodeId The node ID
-     * @param index The value index (see dumpNodes()) of the value to query.
-     * @return An int32 representing the current contents of a value.
-     */
-    int getValueAsInt32(int nodeId, int index);
-
-    /**
-     * Return the content of a value as an int16.  This will fail, and
-     * an error message printed if the value type is not an int16.
-     *
-     * @param nodeId The node ID
-     * @param index The value index (see dumpNodes()) of the value to query.
-     * @return An int16 representing the current contents of a value.
-     */
-    int getValueAsInt16(int nodeId, int index);
-
-    /**
-     * Issue a refresh request for a value on a node.  OpenZWave will
-     * query the value and update it's internal state when the device
-     * responds.  Note, this happens asynchronously - it may take some
-     * time before the current value is reported to OpenZWave by the
-     * node.  If the node is asleep, you may not get a current value
-     * for some time (or at all, depending on the device).  This
-     * method will return immediately after the request has been
-     * queued.
-     *
-     * @param nodeId The node ID
-     * @param index The value index (see dumpNodes()) of the value to query.
-     */
-    void refreshValue(int nodeId, int index);
-
-    /**
-     * Enable or disable some debugging output.  Note, this will not
-     * affect OpenZWave's own debugging, which is usually set in the
-     * option.xml file.
-     *
-     * @param enable true to enable debugging, false otherwise
-     */
-    void setDebug(bool enable);
-
-    /**
-     * Determine if a node is a listening device -- in other words, the
-     * node never sleeps.
-     *
-     * @param nodeId The node ID
-     * @return true if the node never sleeps, false otherwise
-     */
-    bool isNodeListeningDevice(int nodeId);
-
-    /**
-     * Determine if a node is a frequent listening device -- in other
-     * words, if the node is asleep, can it be woken by a beam.
-     *
-     * @param nodeId The node ID
-     * @return true if the node is a frequent listening device, false
-     * otherwise
-     */
-    bool isNodeFrequentListeningDevice(int nodeId);
-
-    /**
-     * Determine if a node is awake.
-     *
-     * @param nodeId The node ID
-     * @return true if the node is awake, false otherwise
-     */
-    bool isNodeAwake(int nodeId);
-
-    /**
-     * Determine whether a Node's information has been received.  For
-     * sleeping nodes, this may take a while (until the node wakes).
-     *
-     * @param nodeId The node ID
-     * @return true if the node information is known, false otherwise
-     */
-    bool isNodeInfoReceived(int nodeId);
-
-    /**
-     * Determine if the Z-Wave network has been initialized yet.
-     *
-     * @return true if the network is initialized, false otherwise
-     */
-    bool isInitialized()
-    {
-      return m_initialized;
-    }
-
-  protected:
-    /**
-     * OZW constructor
-     */
-    OZW();
-
-    /**
-     * OZW Destructor
-     */
-    ~OZW();
-
-    /**
-     * Based on a nodeId and a value index, lookup the corresponding
-     * OpenZWave ValueID.
-     *
-     * @param nodeId The node ID
-     * @param index The value index (see dumpNodes()) of the value to query.
-     * @param A pointer to a ValueID that will be returned if successful
-     * @return true of the nodeId and index was found, false otherwise
-     */
-    bool getValueID(int nodeId, int index, OpenZWave::ValueID *vid);
-
-    /**
-     * Return the Home ID of the network.
-     *
-     * @return The Home ID.
-     */
-    uint32_t getHomeID()
-    {
-      return m_homeId;
-    }
-
-    /**
-     * Lock the m_zwNodeMap mutex to protect against changes made to
-     * the the the map by the OpenZWave notification handler.  Always
-     * lock this mutex when acessing anything in the zwNodeMap map.
-     */
-    void lockNodes() { pthread_mutex_lock(&m_nodeLock); };
-
-    /**
-     * Unlock the m_zwNodeMap mutex after lockNodes() has been called.
-     */
-    void unlockNodes() { pthread_mutex_unlock(&m_nodeLock); };
-
-  private:
-    // prevent copying and assignment
-    OZW(OZW const &) = delete;
-    OZW& operator=(OZW const&) = delete;
-
-    // our class instance
-    static OZW* m_instance;
-
-    uint32_t m_homeId;
-    bool m_mgrCreated;
-    bool m_driverFailed;
-    bool m_debugging;
-    bool m_initialized;
-
-    bool m_driverIsHID;
-    std::string m_devicePath;
-
-    // our notification handler, called by OpenZWave for events on the
-    // network.
-    static void notificationHandler(OpenZWave::Notification 
-                                    const* notification, 
-                                    void *ctx);
-
-    // a map of added nodes
-    zwNodeMap_t m_zwNodeMap;
-
-    // for coordinating access to the node list
-    pthread_mutex_t m_nodeLock;
-
-    // We use these to determine init failure or success (if OpenZWave
-    // has successfully queried essential data about the network).
-    pthread_mutex_t m_initLock;
-    pthread_cond_t m_initCond;
-  };
-}
-
-
diff --git a/src/ozw/ozw.i b/src/ozw/ozw.i
deleted file mode 100644
index 8dc6f23..0000000
--- a/src/ozw/ozw.i
+++ /dev/null
@@ -1,34 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "arrays_java.i";
-%include "../java_buffer.i"
-%apply unsigned char *OUTPUT { uint8_t *val };
-
-JAVA_JNI_LOADLIBRARY(javaupm_ozw)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%pointer_functions(float, floatp);
-
-%{
-#include "ozwinterface.hpp"
-#include "ozw.hpp"
-#include "aeotecdsb09104.hpp"
-#include "aeotecdw2e.hpp"
-#include "aeotecsdg2.hpp"
-#include "aeotecss6.hpp"
-#include "ozwdump.hpp"
-#include "tzemt400.hpp"
-%}
-%include "ozwinterface.hpp"
-%include "ozw.hpp"
-%include "aeotecdsb09104.hpp"
-%include "aeotecdw2e.hpp"
-%include "aeotecsdg2.hpp"
-%include "aeotecss6.hpp"
-%include "ozwdump.hpp"
-%include "tzemt400.hpp"
-/* END Common SWIG syntax */
diff --git a/src/ozw/ozw.json b/src/ozw/ozw.json
deleted file mode 100644
index 430e996..0000000
--- a/src/ozw/ozw.json
+++ /dev/null
@@ -1,107 +0,0 @@
-{
-    "Library": "ozw",
-    "Description": "UPM OpenZWave library",
-    "Sensor Class": {
-        "OZW": {
-            "Name": "API for the OpenZWave library",
-            "Description": "This module implements a singleton wrapper around the OpenZWave library. OpenZWave must be compiled and installed on your machine in order to use this library. This module was developed with OpenZWave 1.3/1.4, and an Aeon Z-Stick Gen5 configured as a Primary Controller. It provides the ability to query and set various values that can be used to control ZWave devices. It does not concern itself with configuration of devices. It is assumed that you have already setup your ZWave network using a tool like the OpenZWave control panel, and have already configured your devices as appropriate. To avoid exposing some of the internals of OpenZWave, devices (nodes) and their values, are accessed via a nodeId and a value index number. The ozwdump example will run dumpNodes() which will list the currently connected devices and the values that are available to them, along with an index number for that value. It is through these values (nodeId and index) that you can query and set device values at a low level. In addition to querying values from a device (such as state (on/off), or temperature, etc), methods are provided to allow you to control these devices to the extent they allow, for example, using a ZWave connected switch to turn on a lamp. Access to this class by OZW drivers is handled by the ozwInterface class. It is that class that drivers use for access to ozw, and therefore the Z-Wave network. This class is not intended to be used directly by end users. When writing an OZW driver, the ozwInterface class should be used (inherited) by your driver, and your driver should wrap and expose only those methods needed by the user. Take a look at some of the drivers (like aeotecss6) to see how this works.",
-            "Aliases": ["ozw"],
-            "Categories": ["wifi"],
-            "Connections": ["uart"],
-            "Project Type": ["commercial"],
-            "Manufacturers": ["Aeon Labs"],
-            "Examples": {
-                "Java": ["AeotecDSB09104_Example.java", "AeotecDW2E_Example.java", "AeotecSDG2_Example.java", "AeotecSS6_Example.java"],
-                "Python": ["aeotecdsb09104.py", "aeotecdw2e.py", "aeotecsdg2.py", "aeotecss6.py"],
-                "Node.js": ["aeotecdsb09104.js", "aeotecdw2e.js", "aeotecsdg2.js", "aeotecss6.js"],
-                "C++": ["ozw-aeotecdsb09104.cxx", "ozw-aeotecdw2e.cxx", "ozw-aeotecsdg2.cxx", "ozw-aeotecss6.cxx", "ozw-ozwdump.cxx", "ozw-tzemt400.cxx"]
-            },
-            "Urls": {
-                "Product Pages": ["http://www.openzwave.com/"]
-            }
-        },
-        "dsb09104": {
-            "Name": "API for Aeon Labs Aeotec Home Energy Meter Gen 1",
-            "Description": "This is the UPM Module for the Aeon Labs Aeotec Home Energy Meter Gen 1. This module allows for monitoring certain elements of an Aeotec Home Energy Meter Gen 1.",
-            "Aliases": ["dsb09104"],
-            "Categories": ["wifi"],
-            "Connections": ["uart"],
-            "Project Type": ["commercial"],
-            "Manufacturers": ["Aeon Labs"],
-            "Examples": {
-                "Java": ["AeotecDSB09104_Example.java"],
-                "Python": ["aeotecdsb09104.py"],
-                "Node.js": ["aeotecdsb09104.js"],
-                "C++": ["ozw-aeotecdsb09104.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 220,
-                    "max": 400
-                },
-                "Supply Current":{
-                    "unit": "A",
-                    "max" : 200
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://aeotec.freshdesk.com/support/solutions/articles/6000161943-home-energy-meter-gen5-user-guide-"]
-            }
-        },
-        "DSB29": {
-            "Name": "API for the Aeon Labs Aeotec Door/Window Sensor 2nd Edition",
-            "Description": "This is the UPM Module for the Aeon Labs Aeotec Door/Window Sensor 2nd Edition. This module allows for monitoring certain elements of an Aeotec Door/Window Sensor 2nd Edition Z-Wave device. NOTE: This is a battery powered device that spends most of it's time sleeping (sort of like a cat). This means that on initial startup, there is not enough information known about the device to reliably query anything.  Use isDeviceAvailable() to test whether the device has responded to OZW's probe request before requesting information for it.",
-            "Aliases": ["dsb29"],
-            "Categories": ["wifi"],
-            "Connections": ["uart"],
-            "Project Type": ["commercial"],
-            "Manufacturers": ["Aeon Labs"],
-            "Examples": {
-                "Java": ["AeotecDW2E_Example.java"],
-                "Python": ["aeotecdw2e.py"],
-                "Node.js": ["aeotecdw2e.js"],
-                "C++": ["ozw-aeotecdw2e.cxx"]
-            },
-            "Urls": {
-                "Product Pages": ["https://aeotec.com/z-wave-door-window-sensor"]
-            }
-        },
-        "dg2": {
-            "Name": "API for Aeon Labs Aeotec Smart Dimmer Gen 2",
-            "Description": "This is the UPM Module for the Aeon Labs Aeotec Smart Dimmer Gen 2. This module allows for controlling and monitoring certain elements of an Aeotec Smart Dimmer Gen 2.",
-            "Aliases": ["dg2"],
-            "Categories": ["wifi"],
-            "Connections": ["uart"],
-            "Project Type": ["commercial"],
-            "Manufacturers": ["Aeon Labs"],
-            "Examples": {
-                "Java": ["AeotecSDG2_Example.java"],
-                "Python": ["aeotecsdg2.py"],
-                "Node.js": ["aeotecsdg2.js"],
-                "C++": ["ozw-aeotecsdg2.cxx"]
-            },
-            "Urls": {
-                "Product Pages": ["https://aeotec.freshdesk.com/support/solutions/articles/6000053613-micro-dimmer-g2-and-micro-smart-dimmer-g2-user-guide-"]
-            }
-        },
-        "ss6": {
-            "Name": "API for the Aeon Labs Aeotec Smart Switch 6",
-            "Description": "This is the UPM Module for the Aeon Labs Aeotec Smart Switch 6. This module allows for controlling and monitoring certain elements of an Aeotec Smart Switch 6.",
-            "Aliases": ["ss6"],
-            "Categories": ["wifi"],
-            "Connections": ["uart"],
-            "Project Type": ["commercial"],
-            "Manufacturers": ["Aeon Labs"],
-            "Examples": {
-                "Java": ["AeotecSS6_Example.java"],
-                "Python": ["aeotecss6.py"],
-                "Node.js": ["aeotecss6.js"],
-                "C++": ["ozw-aeotecss6.cxx"]
-            },
-            "Urls": {
-                "Product Pages": ["https://aeotec.com/z-wave-plug-in-switch"]
-            }
-        }
-    }
-}
diff --git a/src/ozw/ozwdump.cxx b/src/ozw/ozwdump.cxx
deleted file mode 100644
index 95d534b..0000000
--- a/src/ozw/ozwdump.cxx
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <iostream>
-#include <stdexcept>
-
-#include "ozwdump.hpp"
-
-using namespace upm;
-using namespace std;
-
-
-OZWDUMP::OZWDUMP() :
-  ozwInterface(0) // nodeID is not used
-{
-}
-
-OZWDUMP::~OZWDUMP()
-{
-}
diff --git a/src/ozw/ozwdump.hpp b/src/ozw/ozwdump.hpp
deleted file mode 100644
index fec0ce3..0000000
--- a/src/ozw/ozwdump.hpp
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-
-#include "ozwinterface.hpp"
-
-namespace upm {
-
-  /**
-   * @library ozw
-   * @comname Interface API for Ozwdump
-   * @con uart
-   *
-   * @brief UPM Utility driver for OZW.
-   *
-   * This "driver" does not actually control any device.  It is meant
-   * as an example.  It's only purpose is to support it's example
-   * (ozwdump), which initializes OZW on a Z-Wave network, and then
-   * prints out all Nodes (devices) and their associated valueids.
-   *
-   * @snippet ozw-ozwdump.cxx Interesting
-   */
-
-  class OZWDUMP : public ozwInterface {
-  public:
-
-    /**
-     * ozwdump constructor
-     */
-    OZWDUMP();
-
-    /**
-     * OZWDUMP Destructor
-     */
-    ~OZWDUMP();
-
-  protected:
-  private:
-  };
-}
diff --git a/src/ozw/ozwinterface.cxx b/src/ozw/ozwinterface.cxx
deleted file mode 100644
index 08b3c35..0000000
--- a/src/ozw/ozwinterface.cxx
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <assert.h>
-#include <errno.h>
-#include <iostream>
-#include <stdexcept>
-#include <string>
-
-#include "ozwinterface.hpp"
-
-using namespace upm;
-using namespace std;
-
-
-ozwInterface::ozwInterface(int nodeID) :
-  m_instance(0)
-{
-  // Save our device's ID
-  m_nodeID = nodeID;
-
-  // create the OZW instance here if it does not already exist, and
-  // store the pointer in our class to save on some typing.
-  m_instance = OZW::instance();
-
-  // now see if it has been initialized yet for init()
-  m_initialized = m_instance->isInitialized();
-
-  setDebug(false);
-}
-
-ozwInterface::~ozwInterface()
-{
-}
-
-void ozwInterface::init(string devicePath, bool isHID)
-{
-  // if we are already intitialized, don't try to do it again...
-
-  if (!m_initialized)
-    m_instance->init(devicePath, isHID);
-
-  // either it threw, or we are initialized now...
-  m_initialized = true;
-}
-
-void ozwInterface::setDebug(bool enable)
-{
-  m_debugging = enable;
-
-  // we also enable/disable debugging in OZW
-  m_instance->setDebug(enable);
-}
diff --git a/src/ozw/ozwinterface.hpp b/src/ozw/ozwinterface.hpp
deleted file mode 100644
index d1412db..0000000
--- a/src/ozw/ozwinterface.hpp
+++ /dev/null
@@ -1,216 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-
-#include "ozw.hpp"
-
-namespace upm {
-
-  /**
-   * @library ozw
-   * @comname UPM Interface API for OpenZWave (OZW)
-   * @con uart
-   *
-   * @brief UPM Interface API for OpenZWave (OZW)
-   *
-   * This class implements some common access functions that are
-   * useful to any driver making use of the ozw driver.
-   *
-   * It is intended to be inherited by device-specific ozw drivers,
-   * and provides some basic public methods all ozw drivers need to
-   * have, as well as protected access to other OZW facilities that
-   * are needed by a driver, but should not be exposed to the
-   * end-user.
-   */
-
-  class ozwInterface {
-  public:
-
-    /**
-     * ozwInterface constructor
-     *
-     * @param nodeID The ZWave node number of the device we are
-     * interested in.
-     */
-    ozwInterface(int nodeID);
-
-    /**
-     * ozwInterface Destructor
-     */
-    virtual ~ozwInterface();
-
-    /**
-     * Enable some debugging output in this module as well as the
-     * OZW module.  Debugging is disabled by default.
-     *
-     * @param enable true to enable, false to disable.
-     */
-    virtual void setDebug(bool enable);
-
-    /**
-     * Start configuration with basic options.  This must be called
-     * prior to init(), after the OZW() constructor is called.
-     *
-     * @param configPath Set the location of the OpenZWave config
-     * directory, default is /etc/openzwave
-     * @param userConfigDir Set the path to the user configuration
-     * directory.  This is the location of the zwcfg*.xml and
-     * option.xml files for the user (probably created by the
-     * OpenZWave Control Panel example application).  The default is
-     * the current directory ("").
-     * @param cmdLine Specify command line formatted options to
-     * OpenZWave.  The default is "".
-     */
-    virtual void optionsCreate(std::string configPath="/etc/openzwave",
-                               std::string userConfigDir="",
-                               std::string cmdLine="")
-    {
-      m_instance->optionsCreate(configPath, userConfigDir, cmdLine);
-    }
-
-    /**
-     * Add an integer Option.  See the OpenZWave documentation for
-     * valid values.
-     *
-     * @param name The name of the configuration option
-     * @param val The value to set it to
-     */
-    virtual void optionAddInt(std::string name, int val)
-    {
-      m_instance->optionAddInt(name, val);
-    }
-
-    /**
-     * Add a boolean Option.  See the OpenZWave documentation for
-     * valid values.
-     *
-     * @param name The name of the configuration option
-     * @param val The value to set it to
-     */
-    virtual void optionAddBool(std::string name, bool val)
-    {
-      m_instance->optionAddBool(name, val);
-    }
-
-    /**
-     * Add a string Option.  See the OpenZWave documentation for valid
-     * values.
-     *
-     * @param name The name of the configuration option
-     * @param val The value to set it to
-     * @append true to append to the option, false to override
-     */
-    virtual void optionAddString(std::string name, std::string val,
-                                 bool append)
-    {
-      m_instance->optionAddString(name, val, append);
-    }
-
-    /**
-     * Lock the Options.  This must be called after all options have
-     * been set, and before init() is called.  If init() is called
-     * without locking the Options, init() will lock them itself.
-     * After the options have been locked, no further options can be
-     * specified.
-     */
-    virtual void optionsLock()
-    {
-      m_instance->optionsLock();
-    }
-
-    /**
-     * This function initializes the underlying OZW Master singleton
-     * and the openzwave library in the event it has not already been
-     * initialized.  If the OZW Master singleton has already been
-     * initialized, then this call will be ignored.
-     *
-     * @param devicePath The path to the device, typically something
-     * like /dev/ttyACM0.
-     * @param isHID true if this is an HID device, false if it's a
-     * serial device.  The default is false.
-     */
-    virtual void init(std::string devicePath, bool isHID=false);
-
-    /**
-     * Dump information about all configured nodes and their valueids
-     * to stderr.  This is useful to determine what nodes are
-     * available, and the index (used for querying and seting values
-     * for them).  In addition, it includes information about each
-     * value (type, current value, etc).
-     *
-     * @param all set to true to dump information about all values
-     * available for each node.  If false, only information about
-     * 'user' values (ignoring 'system' and 'configuration') are
-     * output.  The default is false ('user' values only).
-     */
-    virtual void dumpNodes(bool all=false)
-    {
-      m_instance->dumpNodes(all);
-    }
-
-    /**
-     * Return a string (which may be empty) indicating the Units of
-     * measure for a given value.  For example, querying a temperature
-     * value may return "F" to indicate Fahrenheit.
-     *
-     * @param index The value index (see dumpNodes()) of the value to query.
-     * @return A string containing the Unit of measure for the value
-     */
-    virtual std::string getValueUnits(int index)
-    {
-      return m_instance->getValueUnits(m_nodeID, index);
-    }
-
-    /**
-     * Return a string (which may be empty) indicating the Label set
-     * for a given value.  For example, querying a temperature value
-     * may return "Temperature" to indicate what it is.
-     *
-     * @param index The value index (see dumpNodes()) of the value to query.
-     * @return A string containing the Label for the value
-     */
-    virtual std::string getValueLabel(int index)
-    {
-      return m_instance->getValueLabel(m_nodeID, index);
-    }
-
-  protected:
-    // also enable debugging in ozw
-    bool m_debugging;
-
-    // our target Device Node ID
-    uint32_t m_nodeID;
-
-    // a copy of the OZW singleton instance pointer.  This is used by
-    // drivers to access underlying OZW facilities.
-    OZW* m_instance;
-
-    // are we initialized?
-    bool m_initialized;
-
-  private:
-  };
-}
diff --git a/src/ozw/tzemt400.cxx b/src/ozw/tzemt400.cxx
deleted file mode 100644
index 200fd49..0000000
--- a/src/ozw/tzemt400.cxx
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <iostream>
-#include <stdexcept>
-
-#include "tzemt400.hpp"
-
-using namespace upm;
-using namespace std;
-
-// conversion from fahrenheit to celsius and back
-
-static float f2c(float f)
-{
-  return ((f - 32.0) / (9.0 / 5.0));
-}
-
-static float c2f(float c)
-{
-  return (c * (9.0 / 5.0) + 32.0);
-}
-
-TZEMT400::TZEMT400(int nodeID) :
-  ozwInterface(nodeID)
-{
-}
-
-TZEMT400::~TZEMT400()
-{
-}
-
-float TZEMT400::getTemperature(bool fahrenheit)
-{
-  float temp = m_instance->getValueAsFloat(m_nodeID, INDEX_Temperature);
-  uint8_t isFahrenheit = m_instance->getValueAsByte(m_nodeID, INDEX_FC_Units);
-
-  if (fahrenheit)
-    {
-      if (isFahrenheit)
-        return temp;
-      else
-        return c2f(temp);
-    }
-  else
-    {
-      if (isFahrenheit)
-        return f2c(temp);
-      else
-        return temp;
-    }
-}
-
-string TZEMT400::getMode()
-{
-  return m_instance->getValueAsString(m_nodeID, INDEX_Mode);
-}
-
-string TZEMT400::getOperatingState()
-{
-  return m_instance->getValueAsString(m_nodeID, INDEX_Operating_State);
-}
-
-float TZEMT400::getHeatingPointTemperature(bool fahrenheit)
-{
-  float temp = m_instance->getValueAsFloat(m_nodeID, INDEX_Heating_Point);
-  uint8_t isFahrenheit = m_instance->getValueAsByte(m_nodeID, INDEX_FC_Units);
-
-  if (fahrenheit)
-    {
-      if (isFahrenheit)
-        return temp;
-      else
-        return c2f(temp);
-    }
-  else
-    {
-      if (isFahrenheit)
-        return f2c(temp);
-      else
-        return temp;
-    }
-}
-
-float TZEMT400::getCoolingPointTemperature(bool fahrenheit)
-{
-  float temp = m_instance->getValueAsFloat(m_nodeID, INDEX_Cooling_Point);
-  uint8_t isFahrenheit = m_instance->getValueAsByte(m_nodeID, INDEX_FC_Units);
-
-  if (fahrenheit)
-    {
-      if (isFahrenheit)
-        return temp;
-      else
-        return c2f(temp);
-    }
-  else
-    {
-      if (isFahrenheit)
-        return f2c(temp);
-      else
-        return temp;
-    }
-}
-
-string TZEMT400::getFanMode()
-{
-  return m_instance->getValueAsString(m_nodeID, INDEX_Fan_Mode);
-}
-
-string TZEMT400::getFanState()
-{
-  return m_instance->getValueAsString(m_nodeID, INDEX_Fan_State);
-}
-
-void TZEMT400::update()
-{
-  m_instance->refreshValue(m_nodeID, INDEX_Temperature);
-  m_instance->refreshValue(m_nodeID, INDEX_Mode);
-  m_instance->refreshValue(m_nodeID, INDEX_Operating_State);
-  m_instance->refreshValue(m_nodeID, INDEX_Heating_Point);
-  m_instance->refreshValue(m_nodeID, INDEX_Cooling_Point);
-  m_instance->refreshValue(m_nodeID, INDEX_Fan_Mode);
-  m_instance->refreshValue(m_nodeID, INDEX_Fan_State);
-  m_instance->refreshValue(m_nodeID, INDEX_FC_Units);
-}
diff --git a/src/ozw/tzemt400.hpp b/src/ozw/tzemt400.hpp
deleted file mode 100644
index 8bba658..0000000
--- a/src/ozw/tzemt400.hpp
+++ /dev/null
@@ -1,159 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-
-#include "ozwinterface.hpp"
-
-namespace upm {
-
-  /**
-   * @library ozw
-   * @sensor tzemt400
-   * @comname Trane TZEMT400 Z-Wave Thermostat.
-   * @con uart
-   * @man trane
-   *
-   * @brief UPM API for Trane TZEMT400 Z-Wave Thermostat
-   *
-   * This module allows for monitoring certain elements of a Trane
-   * TZEMT400 Z-Wave Thermostat.  It was tested with a Trane
-   * TZEMT400BB32MAA variant.
-   *
-   * @snippet ozw-tzemt400.cxx Interesting
-   */
-
-  class TZEMT400 : public ozwInterface {
-  public:
-
-    /**
-     * These values correspond to the index values of the given node
-     *
-     */
-    typedef enum : int {
-      INDEX_Temperature                = 0,
-      INDEX_Mode                       = 1,
-      INDEX_Operating_State            = 2,
-      INDEX_Heating_Point              = 3,
-      INDEX_Cooling_Point              = 4,
-      INDEX_Fan_Mode                   = 5,
-      INDEX_Fan_State                  = 6,
-      INDEX_FC_Units                   = 14 // F or C units
-    } INDEX_VALUES_T;
-
-    /**
-     * TZEMT400 constructor
-     *
-     * @param nodeID The ZWave node number of the device we are
-     * interested in.  Use the ozwdump example to see what nodes you
-     * have available.
-     */
-    TZEMT400(int nodeID);
-
-    /**
-     * TZEMT400 Destructor
-     */
-    ~TZEMT400();
-
-    /**
-     * Return the current measured temperature in Celsius or
-     * Fahrenheit.
-     *
-     * @param fahrenheit true to return data in Fahrenheit, false for
-     * Celicus.  Celsius is the default.
-     * @return The temperature in degrees Celsius or Fahrenheit.
-     */
-    float getTemperature(bool fahrenheit=false);
-
-    /**
-     * Return a string representing the current Mode.  This is usually
-     * something like "Cool", "Heat", "Auto", etc.
-     *
-     * @return a string representing the current mode.
-     */
-    std::string getMode();
-
-    /**
-     * Return a string representing the current Operating State.  This
-     * is usually something like "Idle", or "Cooling".
-     *
-     * @return a string representing the current operating state.
-     */
-    std::string getOperatingState();
-
-    /**
-     * Return the current Heating Point temperature in Celsius or
-     * Fahrenheit.  This is the temperature at which the thermostat
-     * will want to engage Heat.
-     *
-     * @param fahrenheit true to return data in Fahrenheit, false for
-     * Celicus.  Celsius is the default.
-     * @return The Heating Point temperature in degrees Celsius or
-     * Fahrenheit.
-     */
-    float getHeatingPointTemperature(bool fahrenheit=false);
-
-    /**
-     * Return the current Cooling Point temperature in Celsius or
-     * Fahrenheit.  This is the temperature at which the thermostat
-     * will want to engage Cooling.
-     *
-     * @param fahrenheit true to return data in Fahrenheit, false for
-     * Celicus.  Celsius is the default.
-     * @return The Cooling Point temperature in degrees Celsius or
-     * Fahrenheit.
-     */
-    float getCoolingPointTemperature(bool fahrenheit=false);
-
-    /**
-     * Return a string representing the current Fan Mode.  This
-     * is usually something like "Auto Low".
-     *
-     * @return a string representing the Fan Mode.
-     */
-    std::string getFanMode();
-
-    /*
-     * Return a string representing the current Fan State.  This
-     * is usually something like "Idle".
-     *
-     * @return a string representing the Fan State.
-     */
-    std::string getFanState();
-
-    /**
-     * Query the device and update internal state.  Strictly speaking,
-     * this is not really neccessary -- a device may send this data on
-     * it's own at periodic intervals.  This method causes OZW to
-     * specifically query the device for it's current information.
-     * The device may take some time to respond.
-     */
-    void update();
-
-
-  protected:
-  private:
-  };
-}
diff --git a/src/ozw/zwNode.cxx b/src/ozw/zwNode.cxx
deleted file mode 100644
index 93102e1..0000000
--- a/src/ozw/zwNode.cxx
+++ /dev/null
@@ -1,197 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015-2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <stdint.h>
-#include <string>
-#include <cinttypes>
-
-#include "zwNode.hpp"
-
-#include "Node.h"
-
-using namespace upm;
-using namespace std;
-using namespace OpenZWave;
-
-zwNode::zwNode(uint32_t homeId, uint8_t nodeId)
-{
-  m_homeId = homeId;
-  m_nodeId = nodeId;
-
-  m_vindex = 0;
-  m_list.clear();
-  m_values.clear();
-  m_autoUpdate = false;
-}
-
-zwNode::~zwNode()
-{
-}
-
-uint8_t zwNode::nodeId()
-{
-  return m_nodeId;
-}
-
-uint32_t zwNode::homeId()
-{
-  return m_homeId;
-}
-
-void zwNode::addValueID(ValueID vid) 
-{
-  m_list.push_back(vid);
-
-  if (m_autoUpdate)
-    updateVIDMap();
-}
-
-void zwNode::removeValueID(ValueID vid) 
-{
-  m_list.remove(vid);
-
-  if (m_autoUpdate)
-    updateVIDMap();
-}
-
-void zwNode::updateVIDMap()
-{
-  m_values.clear();
-  m_vindex = 0;
-
-  m_list.sort();
-
-  for (auto it = m_list.cbegin(); it != m_list.cend(); ++it)
-    {
-      // We need to use insert since ValueID's default ctor is private
-      m_values.insert(std::pair<int, ValueID>(m_vindex++, *it));
-    }
-
-}
-
-bool zwNode::indexToValueID(int index, ValueID *vid)
-{
-  valueMap_t::iterator it;
-
-  it = m_values.find(index);
-
-  if (it == m_values.end())
-    {
-      // not found, return false
-      return false;
-    }
-  else
-    *vid = (*it).second;
-
-  return true;
-}
-
-void zwNode::dumpNode(bool all)
-{
-  for (auto it = m_values.cbegin();
-       it != m_values.cend(); ++it)
-    {
-      int vindex = it->first;
-      ValueID vid = it->second;
-      string label = Manager::Get()->GetValueLabel(vid);
-      string valueAsStr;
-      Manager::Get()->GetValueAsString(vid, &valueAsStr);
-      string valueUnits = Manager::Get()->GetValueUnits(vid);
-      ValueID::ValueType vType = vid.GetType();
-      string vTypeStr;
-      string perms;
-
-      if (Manager::Get()->IsValueWriteOnly(vid))
-        perms = "WO";
-      else if (Manager::Get()->IsValueReadOnly(vid))
-        perms = "RO";
-      else
-        perms = "RW";
-
-      switch (vType)
-        {
-        case ValueID::ValueType_Bool:
-          vTypeStr = "bool";
-          break;
-
-        case ValueID::ValueType_Byte:
-          vTypeStr = "byte";
-          break;
-
-        case ValueID::ValueType_Decimal:
-          vTypeStr = "float";
-          break;
-
-        case ValueID::ValueType_Int:
-          vTypeStr = "int32";
-          break;
-
-        case ValueID::ValueType_List:
-          vTypeStr = "list";
-          break;
-
-        case ValueID::ValueType_Schedule:
-          vTypeStr = "schedule";
-          break;
-
-        case ValueID::ValueType_Short:
-          vTypeStr = "int16";
-          break;
-
-        case ValueID::ValueType_String:
-          vTypeStr = "string";
-          break;
-
-        case ValueID::ValueType_Button:
-          vTypeStr = "button";
-          break;
-
-        case ValueID::ValueType_Raw:
-          vTypeStr = "raw";
-          break;
-
-        default:
-          vTypeStr = "undefined";
-          break;
-        }
-
-      // by default we only want user values, unless 'all' is true
-      if (all || (vid.GetGenre() == ValueID::ValueGenre_User))
-        {
-          fprintf(stderr, "\t Index: %d, Type: %s, Label: %s, Value: %s %s (%s)\n",
-                  vindex,
-                  vTypeStr.c_str(),
-                  label.c_str(),
-                  valueAsStr.c_str(),
-                  valueUnits.c_str(),
-                  perms.c_str());
-
-          fprintf(stderr, "\t\t VID: %016llx\n",
-                  vid.GetId());
-        }
-    }
-}
-
-
-
diff --git a/src/ozw/zwNode.hpp b/src/ozw/zwNode.hpp
deleted file mode 100644
index 1533b08..0000000
--- a/src/ozw/zwNode.hpp
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015-2016l Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <map>
-#include <list>
-
-#include "Manager.h"
-
-namespace upm {
-
-  /**
-   * @library ozw
-   *
-   * @brief Node management for ozw
-   *
-   * This class is used by ozw to manage valueids for a node (device).
-   * No user-serviceable parts inside.  It is not exposed to the end
-   * user.
-   */
-
-  class zwNode {
-  public:
-    // valueid map
-    typedef std::map<int, OpenZWave::ValueID> valueMap_t;
-    // valueid list, used for sorting
-    typedef std::list<OpenZWave::ValueID> valueList_t;
-
-    /**
-     * zwNode constructor.
-     *
-     * @param homeId the homeId os the network controller
-     * @param nodeId the node index
-     */
-    zwNode(uint32_t homeId, uint8_t nodeId);
-
-    ~zwNode();
-
-    /**
-     * get the nodeId
-     *
-     * @return The nodeId for this node
-     */
-    uint8_t nodeId();
-
-    /**
-     * get the homeId
-     *
-     * @return The homeId for this node
-     */
-    uint32_t homeId();
-
-    /**
-     * Add an OpenZWave ValueID and index to the value map,
-     * incrementing m_vindex.
-     *
-     * @param vid The OpenZWave ValueID
-     */
-    void addValueID(OpenZWave::ValueID vid);
-
-    /**
-     * Remove an OpenZWave ValueID from the value map.
-     *
-     * @param vid The OpenZWave ValueID
-     */
-    void removeValueID(OpenZWave::ValueID vid);
-
-    /**
-     * Lookup and return a ValueID corresponding to an index.
-     *
-     * @param index the index to look up
-     * @param vid The pointer to the returned ValueID, if it exists
-     * @return true if the index was found, false otherwise
-     */
-    bool indexToValueID(int index, OpenZWave::ValueID *vid);
-
-    /**
-     * Dump various information about the ValueIDs stored in this
-     * node.
-     *
-     * @param all true to dump all values, false to limit dumping only
-     * 'user' values.
-     */
-    void dumpNode(bool all=false);
-
-    /**
-     * Clear the VID map, sort the list containing registered VID's,
-     * and re-create the VID map.  The goal is to ensure that the Map
-     * is always sorted in acsending order by VID.
-     */
-    void updateVIDMap();
-
-    /**
-     * When enabled, updateVIDMap() will be called every time a new
-     * VID is inserted or removed.  This is disabled by default for
-     * performance reasons during init() time.  Once the driver is
-     * initialized, then this option is, by default  enabled so that
-     * the VID map is always kept in a sorted order.
-     *
-     * @param enable true to enable, false to disable.
-     */
-    void setAutoUpdate(bool enable)
-    {
-      m_autoUpdate = enable;
-    }
-
-  protected:
-
-  private:
-    bool m_autoUpdate;
-    uint32_t m_homeId;
-    uint8_t m_nodeId;
-
-    valueMap_t m_values;
-    valueList_t m_list;
-
-    // we increment this index for every ValueID we add into the map
-    unsigned int m_vindex;
-  };
-
-}
diff --git a/src/p9813/CMakeLists.txt b/src/p9813/CMakeLists.txt
deleted file mode 100644
index f8b69f3..0000000
--- a/src/p9813/CMakeLists.txt
+++ /dev/null
@@ -1,7 +0,0 @@
-upm_mixed_module_init (NAME p9813
-    DESCRIPTION "P9813 Chainable RGB LEDs"
-    C_HDR p9813.h
-    C_SRC p9813.c
-    CPP_HDR p9813.hpp
-    CPP_SRC p9813.cxx
-    REQUIRES mraa utilities-c)
diff --git a/src/p9813/p9813.c b/src/p9813/p9813.c
deleted file mode 100644
index 4e10982..0000000
--- a/src/p9813/p9813.c
+++ /dev/null
@@ -1,150 +0,0 @@
-/*
- * Author: Sergey Kiselev <sergey.kiselev@intel.com>
- * Copyright (c) 2017 Sergey Kiselev
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string.h>
-#include <assert.h>
-
-#include "p9813.h"
-#include "upm_utilities.h"
-
-p9813_context p9813_init(int ledcount, int clk, int data) {
-
-    p9813_context dev = (p9813_context)malloc(sizeof(struct _p9813_context));
-
-    if(!dev)
-        return NULL;
-
-    memset(dev, 0, sizeof(struct _p9813_context));
-    dev->leds = ledcount;
-
-    // Try to allocate and zero out buffer
-    if ((dev->buffer = (uint8_t*)malloc(dev->leds * 3))) {
-        memset(dev->buffer, 0x00, dev->leds * 3);
-    } else {
-        printf("%s: Failed to allocate LED buffer.\n", __FUNCTION__);
-        p9813_close(dev);
-        return NULL;
-    }
-
-    dev->clk = NULL;
-    dev->data = NULL;
-
-    if (!(dev->clk = mraa_gpio_init(clk))) {
-        printf("%s: mraa_gpio_init(clk) failed.\n", __FUNCTION__);
-        p9813_close(dev);
-        return NULL;
-    }
-    mraa_gpio_dir(dev->clk, MRAA_GPIO_OUT);
-
-    if (!(dev->data = mraa_gpio_init(data))) {
-        printf("%s: mraa_gpio_init(data) failed.\n", __FUNCTION__);
-        p9813_close(dev);
-        return NULL;
-    }
-
-    return dev;
-}
-
-void p9813_close(p9813_context dev) {
-    assert(dev != NULL);
-
-    if (dev->clk)
-        mraa_gpio_close(dev->clk);
-    if (dev->data)
-        mraa_gpio_close(dev->data);
-    if(dev->buffer)
-        free(dev->buffer);
-    free(dev);
-}
-
-upm_result_t p9813_set_led(p9813_context dev, uint16_t index, uint8_t r, uint8_t g, uint8_t b) {
-    return p9813_set_leds(dev, index, index, r, g, b);
-}
-
-upm_result_t p9813_set_leds(p9813_context dev, uint16_t s_index, uint16_t e_index, uint8_t r, uint8_t g, uint8_t b) {
-    assert(dev != NULL);
-    int i;
-
-    for (i = s_index; i <= e_index; i++) {
-        dev->buffer[i * 3] = r;
-        dev->buffer[i * 3 + 1] = g;
-        dev->buffer[i * 3 + 2] = b;
-    }
-    return UPM_SUCCESS;
-}
-
-upm_result_t p9813_send_byte(p9813_context dev, uint8_t data)
-{
-    for (uint16_t i = 0; i < 8; i++) {
-        // Write the data bit
-        mraa_gpio_write(dev->data, (data & 0x80) >> 7);
-        // Pulse the clock
-        mraa_gpio_write(dev->clk, 1);
-        upm_delay_us(20);
-        mraa_gpio_write(dev->clk, 0);
-        upm_delay_us(20);
-
-        // Shift to the next data bit
-        data <<= 1;
-    }
-
-    return UPM_SUCCESS;
-}
-
-
-upm_result_t p9813_refresh(p9813_context dev) {
-    uint16_t i;
-    uint8_t byte0, red, green, blue;
-
-    assert(dev != NULL);
-
-    // Begin data frame
-    p9813_send_byte(dev, 0x00);
-    p9813_send_byte(dev, 0x00);
-    p9813_send_byte(dev, 0x00);
-    p9813_send_byte(dev, 0x00);
-
-    for (i = 0; i <= dev->leds; i++) {
-        red = dev->buffer[i * 3];
-        green = dev->buffer[i * 3 + 1];
-        blue = dev->buffer[i * 3 + 2];
-        // The first byte is 11 followed by inverted bits 7 and 6 of blue, green, and red
-        byte0 = 0xFF;
-        byte0 ^= (blue >> 2) & 0x30; // XOR bits 4-5
-        byte0 ^= (green >> 4) & 0x0C; // XOR bits 2-3
-        byte0 ^= (red >> 6) & 0x03; // XOR bits 0-1
-        p9813_send_byte(dev, byte0);
-        p9813_send_byte(dev, blue);
-        p9813_send_byte(dev, green);
-        p9813_send_byte(dev, red);
-    }
-
-    // End data frame
-    p9813_send_byte(dev, 0x00);
-    p9813_send_byte(dev, 0x00);
-    p9813_send_byte(dev, 0x00);
-    p9813_send_byte(dev, 0x00);
-
-    return UPM_SUCCESS;
-}
diff --git a/src/p9813/p9813.cxx b/src/p9813/p9813.cxx
deleted file mode 100644
index 82b8c59..0000000
--- a/src/p9813/p9813.cxx
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
- * Author: Sergey Kiselev <sergey.kiselev@intel.com>
- * Copyright (c) 2017 Sergey Kiselev
- * Based on the apa102 driver writen by Yannick Adam <yannick.adam@gmail.com>
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <cstring>
-#include <iostream>
-#include <stdexcept>
-#include <stdlib.h>
-#include <unistd.h>
-
-#include "p9813.hpp"
-
-using namespace upm;
-
-P9813::P9813(uint16_t ledCount, uint16_t clkPin, uint16_t dataPin, bool batchMode)
-        : m_leds(ledCount), m_clkGpio(clkPin), m_dataGpio(dataPin), m_batchMode(batchMode)
-{
-    mraa::Result res = mraa::SUCCESS;
-
-    // Set GPIO pins to output direction
-    res = m_clkGpio.dir(mraa::DIR_OUT);
-    if (res != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": GPIO failed to set direction");
-    }
-    res = m_dataGpio.dir(mraa::DIR_OUT);
-    if (res != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": GPIO failed to set direction");
-    }
-}
-
-void
-P9813::setLed(uint16_t ledIdx, uint8_t r, uint8_t g, uint8_t b)
-{
-    setLeds(ledIdx, ledIdx, r, g, b);
-}
-
-void
-P9813::setAllLeds(uint8_t r, uint8_t g, uint8_t b)
-{
-    setLeds(0, m_leds.size() - 1, r, g, b);
-}
-
-void
-P9813::setLeds(uint16_t startIdx, uint16_t endIdx, uint8_t r, uint8_t g, uint8_t b)
-{
-    for (uint16_t i = startIdx; i <= endIdx; i++) {
-	m_leds[i].red = r;
-	m_leds[i].green = g;
-	m_leds[i].blue = b;
-    }
-
-    if (!m_batchMode) {
-        pushState();
-    }
-}
-
-void
-P9813::setLeds(uint16_t startIdx, uint16_t endIdx, std::vector<RgbColor> colors)
-{
-    for (uint16_t i = startIdx, j = 0; i <= endIdx; i++) {
-	m_leds[i].red = colors[j].red;
-	m_leds[i].green = colors[j].green;
-	m_leds[i].blue = colors[j].blue;
-    }
-
-    if (!m_batchMode) {
-        pushState();
-    }
-}
-
-void
-P9813::pushState(void)
-{
-    // Begin data frame
-    sendByte(0x00);
-    sendByte(0x00);
-    sendByte(0x00);
-    sendByte(0x00);
-
-    for (uint16_t i = 0; i < m_leds.size(); i++) {
-	uint8_t red = m_leds[i].red;
-        uint8_t green = m_leds[i].green;
-        uint8_t blue = m_leds[i].blue;
-        // The first byte is 11 followed by inverted bits 7 and 6 of blue, green, and red
-        uint8_t byte0 = 0xFF;
-        byte0 ^= (blue >> 2) & 0x30; // XOR bits 4-5
-        byte0 ^= (green >> 4) & 0x0C; // XOR bits 2-3
-        byte0 ^= (red >> 6) & 0x03; // XOR bits 0-1
-	sendByte(byte0);
-        sendByte(blue);
-        sendByte(green);
-        sendByte(red);
-    }
-
-    // End data frame
-    sendByte(0x00);
-    sendByte(0x00);
-    sendByte(0x00);
-    sendByte(0x00);
-}
-
-/*
- * **************
- *  private area
- * **************
-*/
-
-void
-P9813::sendByte(uint8_t data)
-{
-    for (uint16_t i = 0; i < 8; i++) {
-        // Write the data bit
-        m_dataGpio.write((data & 0x80) >> 7);
-	// Pulse the clock
-        m_clkGpio.write(1);
-        usleep(20);
-        m_clkGpio.write(0);
-        usleep(20);
-
-	// Shift to the next data bit
-        data <<= 1;
-    }
-}
diff --git a/src/p9813/p9813.h b/src/p9813/p9813.h
deleted file mode 100644
index c11f32c..0000000
--- a/src/p9813/p9813.h
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Author: Sergey Kiselev <sergey.kiselev@intel.com>
- * Copyright (c) 2017 Sergey Kiselev
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <stdint.h>
-#include "upm.h"
-#include "mraa/gpio.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @file p9813.h
- * @library p9813
- * @brief C API for controlling P9813/Chainable RGN LEDs
- *
- * @include p9813.c
- */
-
-/**
- * Device context
- */
-typedef struct _p9813_context {
-    // clock and data GPIO pins
-    mraa_gpio_context       clk, data;
-
-    uint8_t*    buffer;
-    int         leds;
-} *p9813_context;
-
-
-/**
- * Instantiates a new P9813 Chainable RGB LEDs
- *
- * @param ledcount  Number of LEDs in the chain
- * @param clk       Clock pin
- * @param data      Data pin
- * @return an initialized p9813 context on success, NULL on error.
- */
-p9813_context p9813_init(int ledcount, int clk, int data);
-
-/**
- * P9813 close function
- *
- * @param dev The p9813_context to close
- */
-void p9813_close(p9813_context dev);
-
-/**
- * Sets the color for one LED in the buffer
- *
- * @param dev           The p9813_context to use
- * @param index         Index of the LED (0 based)
- * @param r             Red component (0-255)
- * @param g             Green component (0-255)
- * @param b             Blue component (0-255)
- * @return upm_result_t UPM success/error code
- */
-upm_result_t p9813_set_led(p9813_context dev, uint16_t index, uint8_t r, uint8_t g, uint8_t b);
-
-/**
- * Sets the color for multiple LEDs in the buffer
- *
- * @param dev           The p9813_context to use
- * @param s_index       The start Index of the LED range (0 based)
- * @param e_index       The end Index of the LED range (0 based)
- * @param r             Red component (0-255)
- * @param g             Green component (0-255)
- * @param b             Blue component (0-255)
- * @return upm_result_t UPM success/error code
- */
-upm_result_t p9813_set_leds(p9813_context dev, uint16_t s_index, uint16_t e_index, uint8_t r, uint8_t g, uint8_t b);
-
-/**
- * Writes the buffer to the LED controllers thus updating the LEDs
- *
- * @param dev The p9813_context to use
- * @return upm_result_t UPM success/error code
- */
-upm_result_t p9813_refresh(p9813_context dev);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/p9813/p9813.hpp b/src/p9813/p9813.hpp
deleted file mode 100644
index 88f067d..0000000
--- a/src/p9813/p9813.hpp
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
- * Author: Sergey Kiselev <sergey.kiselev@intel.com>
- * Copyright (c) 2017 Sergey Kiselev
- * Based on the apa102 driver writen by Yannick Adam <yannick.adam@gmail.com>
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <mraa/gpio.hpp>
-#include <vector>
-
-namespace upm
-{
-/**
- * @brief P9813 Chainable RGB LEDs Driver
- * @defgroup p9813 libupm-p9813
- * @ingroup adafruit gpio led
- */
-
-typedef struct {
-    uint8_t red, green, blue;
-} RgbColor;
-
-/**
- * @library p9813
- * @sensor p9813
- * @comname Chainable RGB LED driver
- * @type led
- * @man adafruit
- * @con gpio
- * @web https://www.adafruit.com/product/2343
- *
- * @brief API for controlling P9813/Chainable RGB LEDs
- *
- * P9813 LED controller provides individually controllable LEDs through a two pin protocol
- * For each LED, an RGB (0-255) value can be set.
- *
- * @image html p9813.jpg
- * @snippet p9813.cxx Interesting
- */
-class P9813
-{
-  public:
-    /**
-     * Instantiates a new P9813 LED chain
-     *
-     * @param ledCount  Number of P9813 leds in the chain
-     * @param clkPin	Clock Pin
-     * @param dataPin   Data Pin
-     * @param batchMode (optional) Immediately write to the LED controllers (false, default) or wait for a pushState
-     * call (true)
-     */
-    P9813(uint16_t ledCount, uint16_t clkPin, uint16_t dataPin, bool batchMode = false);
-
-    /**
-     * P9813 destructor
-     */
-    virtual ~P9813() {};
-
-    /**
-     * Set the color for a single LED
-     *
-     * @param ledIdx        Index of the LED in the chain (0 based)
-     * @param r             Red component (0-255)
-     * @param g             Green component (0-255)
-     * @param b             Blue component (0-255)
-     */
-    void setLed(uint16_t ledIdx, uint8_t r, uint8_t g, uint8_t b);
-
-    /**
-     * Set the color for all LEDs
-     *
-     * @param r             Red component (0-255)
-     * @param g             Green component (0-255)
-     * @param b             Blue component (0-255)
-     */
-    void setAllLeds(uint8_t r, uint8_t g, uint8_t b);
-
-    /**
-     * Set the color for a range of LEDs
-     *
-     * @param startIdx      Start index of the range of LEDs in the chain (0 based)
-     * @param endIdx        End index of the range of LEDs in the chain (0 based)
-     * @param r             Red component (0-255)
-     * @param g             Green component (0-255)
-     * @param b             Blue component (0-255)
-     */
-    void
-    setLeds(uint16_t startIdx, uint16_t endIdx, uint8_t r, uint8_t g, uint8_t b);
-
-    /**
-     * (Advanced) Manually control the colors and brightness of a range of LEDS
-     * Best used to maximize performance
-     *
-     * @param startIdx      Start index of the range of LEDs to update (0 based)
-     * @param endIdx        End index of the range of LEDs to update (0 based)
-     * @param colors        Vector containing RgbColor structures for each LED
-     *                      No check done on the boundaries
-     */
-    void setLeds(uint16_t startIdx, uint16_t endIdx, std::vector<RgbColor> colors);
-
-    /**
-     * Outputs the current LED data to the LED controllers
-     * Note: Only required if batch mode is set to TRUE
-     *
-     */
-    void pushState();
-
-  private:
-    std::vector<RgbColor> m_leds;
-    mraa::Gpio m_clkGpio;
-    mraa::Gpio m_dataGpio;
-    bool m_batchMode;
-
-    void sendByte(uint8_t data);
-};
-}
diff --git a/src/p9813/p9813.i b/src/p9813/p9813.i
deleted file mode 100644
index 4584595..0000000
--- a/src/p9813/p9813.i
+++ /dev/null
@@ -1,14 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_p9813)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "p9813.hpp"
-%}
-%include "p9813.hpp"
-/* END Common SWIG syntax */
diff --git a/src/p9813/p9813.json b/src/p9813/p9813.json
deleted file mode 100644
index 42caa07..0000000
--- a/src/p9813/p9813.json
+++ /dev/null
@@ -1,58 +0,0 @@
-{
-    "Library": "p9813",
-    "Description": "Shiji Lighting P9813 Chainable RGB LEDs driver library",
-    "Sensor Class": {
-        "P9813": {
-            "Name": "API for controlling Shiji Lighting P9813/Chainable RGB LEDs",
-            "Description": "This is the UPM Module for the Shiji Lighting P9813/Chainable RGB LEDs. This LED controller provides individually controllable LEDs through a two pin protocol",
-            "Aliases": ["p9813", "APA102 5050 RGB LED w/ Integrated Driver Chip"],
-            "Categories": ["LED"],
-            "Connections": ["gpio"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["Adafruit", "Shiji Lighting"],
-            "Image": "p9813.jpg",
-            "Examples": {
-                "Java": ["P9813_Example.java"],
-                "Python": ["p9813.py"],
-                "Node.js": ["p9813.js"],
-                "C++": ["p9813.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 5.0,
-                    "max": 5.5
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "min" : 22.5,
-                    "max" : 26.5
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -40,
-                    "max": 70
-                },
-                "View Angle":{
-                    "unit": "Â°",
-                    "degrees": 160
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need pull up resistors", "Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need pull up resistors", "Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.adafruit.com/product/2343"],
-                "Datasheets": ["https://cdn-shop.adafruit.com/product-files/2343/APA102C.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/p9813/p9813_fti.c b/src/p9813/p9813_fti.c
deleted file mode 100644
index 2257fa3..0000000
--- a/src/p9813/p9813_fti.c
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Author: Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "p9813.h"
-#include "upm_fti.h"
-
-/**
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_p9813_name[] = "P9813";
-const char upm_p9813_description[] = "P9813/Chainable RGB LEDs";
-const upm_protocol_t upm_p9813_protocol[] = {UPM_GPIO};
-const upm_sensor_t upm_p9813_category[] = {};
-
-// forward declarations
-const void* upm_p9813_get_ft(upm_sensor_t sensor_type);
-void* upm_p9813_init_name();
-void upm_p9813_close(void *dev);
-
-static const upm_sensor_ft ft =
-{
-  .upm_sensor_init_name = &upm_p9813_init_name,
-  .upm_sensor_close = &upm_p9813_close,
-};
-
-const void* upm_p9813_get_ft(upm_sensor_t sensor_type)
-{
-  switch(sensor_type)
-    {
-    case UPM_SENSOR:
-      return &ft;
-    default:
-      return NULL;
-    }
-}
-
-void* upm_p9813_init_name()
-{
-  return NULL;
-}
-
-void upm_p9813_close(void *dev)
-{
-  p9813_close((p9813_context)dev);
-}
diff --git a/src/pca9685/CMakeLists.txt b/src/pca9685/CMakeLists.txt
deleted file mode 100644
index 71b509c..0000000
--- a/src/pca9685/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "pca9685")
-set (libdescription "I2C 16-channel 12-bit PWM LED Controller")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/pca9685/pca9685.cxx b/src/pca9685/pca9685.cxx
deleted file mode 100644
index 7974598..0000000
--- a/src/pca9685/pca9685.cxx
+++ /dev/null
@@ -1,302 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <math.h>
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "pca9685.hpp"
-
-using namespace upm;
-using namespace std;
-
-
-PCA9685::PCA9685(int bus, uint8_t address, bool raw)
-{
-  m_addr = address;
-
-  // setup our i2c link
-  if ( raw )
-    {
-      m_i2c = mraa_i2c_init_raw(bus);
-    }
-  else
-    {
-      m_i2c = mraa_i2c_init(bus);
-    }
-
-  if ( !m_i2c)
-    {
-      throw std::invalid_argument(std::string(__FUNCTION__) +
-                                  ": mraa_i2c_init() failed");
-      return;
-    }
-      
-  mraa_result_t rv;
-  
-  if ( (rv = mraa_i2c_address(m_i2c, m_addr)) != MRAA_SUCCESS)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": mraa_i2c_address() failed");
-      return;
-    }
-
-  // enable auto-increment mode by default
-  enableAutoIncrement(true);
-
-  // enable restart by default.
-  enableRestart(true);
-}
-
-PCA9685::~PCA9685()
-{
-  setModeSleep(true);
-  mraa_i2c_stop(m_i2c);
-}
-
-bool PCA9685::writeByte(uint8_t reg, uint8_t byte)
-{
-  mraa_result_t rv = mraa_i2c_write_byte_data(m_i2c, byte, reg);
-
-  if (rv != MRAA_SUCCESS)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": mraa_i2c_write_byte_data() failed");
-      return false;
-    }
-
-  return true;
-}
-
-bool PCA9685::writeWord(uint8_t reg, uint16_t word)
-{
-  mraa_result_t rv = mraa_i2c_write_word_data(m_i2c, word, reg);
-
-  if (rv != MRAA_SUCCESS)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": mraa_i2c_write_word_data() failed");
-      return false;
-    }
-
-  return true;
-}
-
-uint8_t PCA9685::readByte(uint8_t reg)
-{
-  int x = mraa_i2c_read_byte_data(m_i2c, reg);
-  if (x != -1) {
-    return (uint8_t) x;
-  }
-  return 0;
-}
-
-uint16_t PCA9685::readWord(uint8_t reg)
-{
-  int x = mraa_i2c_read_word_data(m_i2c, reg);
-  if (x != -1) {
-    return (uint16_t) x;
-  }
-  return 0;
-}
-
-bool PCA9685::setModeSleep(bool sleep)
-{
-  uint8_t mode1 = readByte(REG_MODE1);
-  uint8_t restartBit = mode1 & MODE1_RESTART;
-
-  if (sleep)
-    mode1 |= MODE1_SLEEP;
-  else
-    mode1 &= ~MODE1_SLEEP;
-
-  // if we are waking up, then preserve but don't write restart bit if set
-  if (!sleep && restartBit)
-    mode1 &= ~MODE1_RESTART;
-
-  writeByte(REG_MODE1, mode1);
-
-  // Need a delay of 500us after turning sleep mode off for the oscillator 
-  // to stabilize
-  if (!sleep)
-    usleep(500);
-
-  // now check to see if we want to (and can) restart when waking up
-  if (restartBit && m_restartEnabled && !sleep)
-    {
-      mode1 |= restartBit;
-      writeByte(REG_MODE1, mode1);
-    }
-
-  return true;
-}
-
-bool PCA9685::enableAutoIncrement(bool ai)
-{
-  uint8_t mode1 = readByte(REG_MODE1);
-
-  if (ai)
-    mode1 |= MODE1_AI;
-  else
-    mode1 &= ~MODE1_AI;
-
-  return writeByte(REG_MODE1, mode1);
-}
-
-bool PCA9685::ledFullOn(uint8_t led, bool val)
-{
-  if (led > 15 && (led != PCA9685_ALL_LED))
-    {
-      throw std::out_of_range(std::string(__FUNCTION__) +
-                              ": led value must be between 0-15 or " +
-                              "PCA9685_ALL_LED (255)");
-      return false;
-    }
-
-  // figure out the register offset (*_ON_H)
-  uint8_t regoff;
-
-  if (led == PCA9685_ALL_LED)
-    regoff = REG_ALL_LED_ON_H;
-  else
-    regoff = REG_LED0_ON_L + (led * 4) + 1;
-
-  uint8_t bits = readByte(regoff);
-
-  if (val)
-    bits |= 0x10;
-  else
-    bits &= ~0x10;
-
-  return writeByte(regoff, bits);
-}
-
-bool PCA9685::ledFullOff(uint8_t led, bool val)
-{
-  if (led > 15 && (led != PCA9685_ALL_LED))
-    {
-      throw std::out_of_range(std::string(__FUNCTION__) +
-                              ": led value must be between 0-15 or " +
-                              "PCA9685_ALL_LED (255)");
-      return false;
-    }
-
-  // figure out the register offset (*_OFF_H)
-  uint8_t regoff;
-
-  if (led == PCA9685_ALL_LED)
-    regoff = REG_ALL_LED_OFF_H;
-  else
-    regoff = REG_LED0_ON_L + (led * 4) + 3;
-
-  uint8_t bits = readByte(regoff);
-
-  if (val)
-    bits |= 0x10;
-  else
-    bits &= ~0x10;
-
-  return writeByte(regoff, bits);
-}
-
-bool PCA9685::ledOnTime(uint8_t led, uint16_t time)
-{
-  if (led > 15 && (led != PCA9685_ALL_LED))
-    {
-      throw std::out_of_range(std::string(__FUNCTION__) +
-                              ": led value must be between 0-15 or " +
-                              "PCA9685_ALL_LED (255)");
-      return false;
-    }
-
-  if (time > 4095)
-    {
-      throw std::out_of_range(std::string(__FUNCTION__) +
-                              ": time value must be between 0-4095");
-      return false;
-    }
-
-  // figure out the register offset (*_ON_L)
-  uint8_t regoff;
-
-  if (led == PCA9685_ALL_LED)
-    regoff = REG_ALL_LED_ON_L;
-  else
-    regoff = REG_LED0_ON_L + (led * 4);
-
-  // we need to preserve the full ON bit in *_ON_H
-  uint8_t onbit = (readByte(regoff + 1) & 0x10);
-
-  time = (time & 0x0fff) | (onbit << 8);
-
-  return writeWord(regoff, time);
-}
-
-bool PCA9685::ledOffTime(uint8_t led, uint16_t time)
-{
-  if (led > 15 && (led != PCA9685_ALL_LED))
-    {
-      throw std::out_of_range(std::string(__FUNCTION__) +
-                              ": led value must be between 0-15 or " +
-                              "PCA9685_ALL_LED (255)");
-      return false;
-    }
-
-  if (time > 4095)
-    {
-      throw std::out_of_range(std::string(__FUNCTION__) +
-                              ": time value must be between 0-4095");
-      return false;
-    }
-
-  // figure out the register offset (*_OFF_L)
-  uint8_t regoff;
-
-  if (led == PCA9685_ALL_LED)
-    regoff = REG_ALL_LED_OFF_L;
-  else
-    regoff = REG_LED0_ON_L + (led * 4) + 2;
-
-  // we need to preserve the full OFF bit in *_OFF_H
-  uint8_t offbit = (readByte(regoff + 1) & 0x10);
-
-  time = (time & 0x0fff) | (offbit << 8);
-
-  return writeWord(regoff, time);
-}
-
-bool PCA9685::setPrescale(uint8_t prescale)
-{
-  // This will be ignored if the device isn't in SLEEP mode
-  return writeByte(REG_PRESCALE, prescale);
-}
-
-bool PCA9685::setPrescaleFromHz(float hz, float oscFreq)
-{
-  float prescale = round( oscFreq / (4096.0 * hz) ) - 1;
-
-  return setPrescale(uint8_t(prescale));
-}
diff --git a/src/pca9685/pca9685.hpp b/src/pca9685/pca9685.hpp
deleted file mode 100644
index 4ad39e8..0000000
--- a/src/pca9685/pca9685.hpp
+++ /dev/null
@@ -1,320 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/i2c.h>
-#include <mraa/gpio.h>
-
-#define PCA9685_I2C_BUS 0
-#define PCA9685_DEFAULT_I2C_ADDR 0x60
-// internal oscillator frequency
-#define PCA9685_INTERNAL_OSC  25000000.0
-
-// This is a 'special' LED number, used to refer to the ALL_LED registers
-// that affect all LED outputs at once.
-#define PCA9685_ALL_LED 0xff
-
-namespace upm {
-  
-  /**
-   * @brief PCA9685 PWM Controller
-   * @defgroup pca9685 libupm-pca9685
-   * @ingroup adafruit i2c led motor
-   */
-  /**
-   * @library pca9685
-   * @sensor pca9685
-   * @comname I2C 16-channel 12-bit PWM LED Controller
-   * @type led motor
-   * @man adafruit
-   * @web http://www.adafruit.com/products/815
-   * @con i2c
-   *
-   * @brief API for the PCA9685 16-channel, 12-bit PWM LED Controller
-   *
-   * This controller is also used on the Adafruit* Motor Shield v2.3
-   * board to control up to 4 DC motors, 2 stepper motors, and 2 servo
-   * motors.
-   *
-   * This module was tested with the Adafruit Motor Shield v2.3
-   *
-   * @image html pca9685.jpg
-   * @snippet pca9685.cxx Interesting
-   */
-  class PCA9685 {
-  public:
-
-    /**
-     * PCA9685 registers
-     */
-    typedef enum { REG_MODE1       = 0x00,
-                   REG_MODE2       = 0x01,
-                   REG_I2C_SA1     = 0x02, // I2C subaddress 1
-                   REG_I2C_SA2     = 0x03,
-                   REG_I2C_SA3     = 0x04,
-                   REG_ALLCALL     = 0x05, // I2C all call address
-
-                   // LED output PWM control
-                   REG_LED0_ON_L   = 0x06, // LED0 ON low byte
-                   REG_LED0_ON_H   = 0x07, // LED0 ON high byte
-                   REG_LED0_OFF_L  = 0x08, // LED0 OFF low byte
-                   REG_LED0_OFF_H  = 0x09, // LED0 OFF high byte
-                   REG_LED1_ON_L   = 0x0a,
-                   REG_LED1_ON_H   = 0x0b,
-                   REG_LED1_OFF_L  = 0x0c,
-                   REG_LED1_OFF_H  = 0x0d,
-                   REG_LED2_ON_L   = 0x0e,
-                   REG_LED2_ON_H   = 0x0f,
-                   REG_LED2_OFF_L  = 0x10,
-                   REG_LED2_OFF_H  = 0x11,
-                   REG_LED3_ON_L   = 0x12,
-                   REG_LED3_ON_H   = 0x13,
-                   REG_LED3_OFF_L  = 0x14,
-                   REG_LED3_OFF_H  = 0x15,
-                   REG_LED4_ON_L   = 0x16,
-                   REG_LED4_ON_H   = 0x17,
-                   REG_LED4_OFF_L  = 0x18,
-                   REG_LED4_OFF_H  = 0x19,
-                   REG_LED5_ON_L   = 0x1a,
-                   REG_LED5_ON_H   = 0x1b,
-                   REG_LED5_OFF_L  = 0x1c,
-                   REG_LED5_OFF_H  = 0x1d,
-                   REG_LED6_ON_L   = 0x1e,
-                   REG_LED6_ON_H   = 0x1f,
-                   REG_LED6_OFF_L  = 0x20,
-                   REG_LED6_OFF_H  = 0x21,
-                   REG_LED7_ON_L   = 0x22,
-                   REG_LED7_ON_H   = 0x23,
-                   REG_LED7_OFF_L  = 0x24,
-                   REG_LED7_OFF_H  = 0x25,
-                   REG_LED8_ON_L   = 0x26,
-                   REG_LED8_ON_H   = 0x27,
-                   REG_LED8_OFF_L  = 0x28,
-                   REG_LED8_OFF_H  = 0x29,
-                   REG_LED9_ON_L   = 0x2a,
-                   REG_LED9_ON_H   = 0x2b,
-                   REG_LED9_OFF_L  = 0x2c,
-                   REG_LED9_OFF_H  = 0x2d,
-                   REG_LED10_ON_L  = 0x2e,
-                   REG_LED10_ON_H  = 0x2f,
-                   REG_LED10_OFF_L = 0x30,
-                   REG_LED10_OFF_H = 0x31,
-                   REG_LED11_ON_L  = 0x32,
-                   REG_LED11_ON_H  = 0x33,
-                   REG_LED11_OFF_L = 0x34,
-                   REG_LED11_OFF_H = 0x35,
-                   REG_LED12_ON_L  = 0x36,
-                   REG_LED12_ON_H  = 0x37,
-                   REG_LED12_OFF_L = 0x38,
-                   REG_LED12_OFF_H = 0x39,
-                   REG_LED13_ON_L  = 0x3a,
-                   REG_LED13_ON_H  = 0x3b,
-                   REG_LED13_OFF_L = 0x3c,
-                   REG_LED13_OFF_H = 0x3d,
-                   REG_LED14_ON_L  = 0x3e,
-                   REG_LED14_ON_H  = 0x3f,
-                   REG_LED14_OFF_L = 0x40,
-                   REG_LED14_OFF_H = 0x41,
-                   REG_LED15_ON_L  = 0x42,
-                   REG_LED15_ON_H  = 0x43,
-                   REG_LED15_OFF_L = 0x44,
-                   REG_LED15_OFF_H = 0x45,
-                   // 0x46-0xf9 reserved
-
-                   REG_ALL_LED_ON_L  = 0xfa, // write all LED ON L
-                   REG_ALL_LED_ON_H  = 0xfb, // write all LED ON H
-                   REG_ALL_LED_OFF_L = 0xfc, // write all LED OFF L
-                   REG_ALL_LED_OFF_H = 0xfd, // write all LED OFF H
-                   REG_PRESCALE      = 0xfe,
-                   REG_TESTMODE      = 0xff  // don't use
-    } PCA9685_REG_T;
-    
-    /**
-     * MODE1 bits
-     */
-    typedef enum { MODE1_ALL_CALL    = 0x01, // all call status
-                   MODE1_SUB3        = 0x02, // subcall 3 status
-                   MODE1_SUB2        = 0x04, // subcall 2 status
-                   MODE1_SUB1        = 0x08, // subcall 1 status
-                   MODE1_SLEEP       = 0x10, // sleep/normal mode
-                   MODE1_AI          = 0x20, // auto-increment enable
-                   MODE1_EXTCLK      = 0x40, // external clock enable
-                   MODE1_RESTART     = 0x80  // restart status
-    } PCA9685_MODE1_T;
-    
-    /**
-     * MODE2 bits
-     */
-    typedef enum { MODE2_OUTNE0      = 0x01, // output driver enable bit 0
-                   MODE2_OUTNE       = 0x02, // output driver enable bit 1
-                   MODE2_OUTDRV      = 0x04, // output open-drain/totem pole
-                   MODE2_OCH         = 0x08, // output change on STOP or ACK
-                   MODE2_INVRT       = 0x10, // output logic state invert
-                   MODE2_RESERVE0    = 0x20, // reserved
-                   MODE2_RESERVE1    = 0x40, // reserved
-                   MODE2_RESERVE2    = 0x80  // reserved
-    } PCA9685_MODE2_T;
-    
-    /**
-     * PCA9685 constructor
-     *
-     * @param bus I2C bus to use
-     * @param address Address for this device
-     */
-    PCA9685(int bus, uint8_t address = PCA9685_DEFAULT_I2C_ADDR, bool raw = false);
-
-    /**
-     * PCA9685 destructor
-     */
-    ~PCA9685();
-
-    /**
-     * Writes a byte value into a register
-     *
-     * @param reg Register location to write into
-     * @param byte Byte to write
-     * @return True if successful
-     */
-    bool writeByte(uint8_t reg, uint8_t byte);
-
-    /**
-     * Writes a word value into a register. Note: the device must have the
-     * auto-increment bit set in the MODE1 register to work.
-     *
-     * @param reg Register location to write into
-     * @param word Word to write
-     * @return True if successful
-     */
-    bool writeWord(uint8_t reg, uint16_t word);
-
-    /**
-     * Reads a byte value from a register
-     *
-     * @param reg Register location to read from
-     * @return Value in a specified register
-     */
-    uint8_t readByte(uint8_t reg);
-
-    /**
-     * Reads a word value from a register. Note: the device must have the
-     * auto-increment bit set in the MODE1 register to work.
-     *
-     * @param reg Register location to read from
-     * @return Value in a specified register
-     */
-    uint16_t readWord(uint8_t reg);
-
-    /**
-     * Puts the device in or out of the sleep mode. The device is always
-     * in the sleep mode upon power-up.
-     *
-     * @param sleep True to put the device in the sleep mode, false to put out  
-     * @return True if successful
-     */
-    bool setModeSleep(bool sleep);
-
-    /**
-     * Sets or clears the FULL ON bit for a given LED
-     *
-     * @param led LED number; valid values are 0-15, PCA9685_ALL_LED
-     * @param val True to set the bit, false to clear it
-     * @return True if successful
-     */
-    bool ledFullOn(uint8_t led, bool val);
-
-    /**
-     * Sets or clears the FULL OFF bit for a given LED. If the FULL ON
-     * bit is also set, FULL OFF has precedence.
-     *
-     * @param led LED number; valid values are 0-15, PCA9685_ALL_LED
-     * @param val True to set the bit, false to clear it
-     * @return True if successful
-     */
-    bool ledFullOff(uint8_t led, bool val);
-
-    /**
-     * Sets the 'LED on' time (0-4,095). See the PCA9685 datasheet for details. 
-     *
-     * @param led LED number; valid values are 0-15, PCA9685_ALL_LED
-     * @param time 12-bit value at which point the LED turns on
-     * @return True if successful
-     */
-    bool ledOnTime(uint8_t led, uint16_t time);
-
-    /**
-     * Sets the 'LED off' time (0-4,095). See the PCA9685 datasheet for details. 
-     *
-     * @param led LED number; valid values are 0-15, PCA9685_ALL_LED
-     * @param time 12-bit value at which point the LED turns off
-     * @return True if successful
-     */
-    bool ledOffTime(uint8_t led, uint16_t time);
-
-    /**
-     * Sets the prescale value. See the PCA9685 datasheet for
-     * details. The prescale can only be set when the device is in
-     * the sleep mode.
-     *
-     * @param prescale Prescale value
-     * @return True if successful
-     */
-    bool setPrescale(uint8_t prescale);
-
-    /**
-     * Sets the prescale value based on a desired frequency in Hz. The
-     * prescale can only be set when the device is in the sleep mode.
-     *
-     * @param hz Desired frequency in Hz
-     * @param oscFreq Oscillator frequency; default is 25 MHz 
-     * @return True if successful
-     */
-    bool setPrescaleFromHz(float hz, 
-                           float oscFreq=PCA9685_INTERNAL_OSC);
-
-    /**
-     * Enables or disables the restart capability of the controller
-     *
-     * @param enabled True to enable, false to disable
-     * It is enabled by default.
-     */
-    void enableRestart(bool enabled) { m_restartEnabled = enabled; };
-
-  private:
-    /**
-     * Enables the I2C register auto-increment. This needs to be enabled
-     * for write/readWord() to work. The constructor enables this by
-     * default.
-     *
-     * @param ai True to enable, false otherwise
-     */
-    bool enableAutoIncrement(bool ai);
-
-    bool m_restartEnabled;
-    mraa_i2c_context m_i2c;
-    uint8_t m_addr;
-  };
-}
-
-
diff --git a/src/pca9685/pca9685.i b/src/pca9685/pca9685.i
deleted file mode 100644
index ffe142e..0000000
--- a/src/pca9685/pca9685.i
+++ /dev/null
@@ -1,14 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_pca9685)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "pca9685.hpp"
-%}
-%include "pca9685.hpp"
-/* END Common SWIG syntax */
diff --git a/src/pca9685/pca9685.json b/src/pca9685/pca9685.json
deleted file mode 100644
index 12a4b76..0000000
--- a/src/pca9685/pca9685.json
+++ /dev/null
@@ -1,56 +0,0 @@
-{
-    "Library": "pca9685",
-    "Description": "NXP/Adafruit PCA9685 PWM Controller library",
-    "Sensor Class": {
-        "PCA9685": {
-            "Name": "API for the NXP/Adafruit PCA9685 16-channel, 12-bit PWM Controller",
-            "Description": "This is the UPM Module for the NXP/Adafruit PCA9685 16-channel, 12-bit PWM Controller. You want to make a cool robot, maybe a hexapod walker, or maybe just a piece of art with a lot of moving parts. Or maybe you want to drive a lot of LEDs with precise PWM output. Then you realize that your microcontroller has a limited number of PWM outputs! What now? You could give up OR you could just get this handy PWM and Servo driver breakout.",
-            "Aliases": ["PCA9685", "Adafruit 16-Channel 12-bit PWM/Servo Driver - I2C interface - PCA9685"],
-            "Categories": ["led", "motor"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping", "robotics"],
-            "Manufacturers": ["NXP Semiconductors", "Adafruit"],
-            "Image": "pca9685.jpg",
-            "Examples": {
-                "Node.js": ["pca9685.js"],
-                "C++": ["pca9685.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 2.3,
-                    "max": 5.5
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "min": 6,
-                    "max": 10
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "PWM Channels": {
-                    "unit": "Channels",
-                    "channels": 16
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need pull up resistors"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.adafruit.com/product/815", "https://learn.adafruit.com/16-channel-pwm-servo-driver/overview"],
-                "Datasheets": ["https://cdn-shop.adafruit.com/datasheets/PCA9685.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/pn532/CMakeLists.txt b/src/pn532/CMakeLists.txt
deleted file mode 100644
index cb37f28..0000000
--- a/src/pn532/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "pn532")
-set (libdescription "NFC/RFID Reader/Writer")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/pn532/license.txt b/src/pn532/license.txt
deleted file mode 100644
index f6a0f22..0000000
--- a/src/pn532/license.txt
+++ /dev/null
@@ -1,26 +0,0 @@
-Software License Agreement (BSD License)
-
-Copyright (c) 2012, Adafruit Industries
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in the
-documentation and/or other materials provided with the distribution.
-3. Neither the name of the copyright holders nor the
-names of its contributors may be used to endorse or promote products
-derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY
-EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/src/pn532/pn532.cxx b/src/pn532/pn532.cxx
deleted file mode 100644
index 92029a0..0000000
--- a/src/pn532/pn532.cxx
+++ /dev/null
@@ -1,1573 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * This code is heavily based on the Adafruit-PN532 library at
- * https://github.com/adafruit/Adafruit-PN532, which is licensed under
- * the BSD license. See upm/src/pn532/license.txt
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <math.h>
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "pn532.hpp"
-
-using namespace upm;
-using namespace std;
-
-
-#define PN532_PACKBUFFSIZ 64
-static uint8_t pn532_packetbuffer[PN532_PACKBUFFSIZ];
-
-static uint8_t pn532ack[] = {0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00};
-static uint32_t pn532_firmwarerev = 0x00320106;
-
-PN532::PN532(int irq, int reset, int bus, uint8_t address):
-  m_gpioIRQ(irq), m_gpioReset(reset), m_i2c(bus)
-{
-  m_addr = address;
-  m_uidLen = 0;
-  m_inListedTag = 0;
-  m_SAK = 0;
-  m_ATQA = 0;
-  m_isrInstalled = false;
-  m_irqRcvd = false;
-
-  memset(m_uid, 0, 7);
-  memset(m_key, 0, 6);
-
-  // turn off debugging by default
-  pn532Debug(false);
-  mifareDebug(false);
-
-  mraa::Result rv;
-  if ( (rv = m_i2c.address(m_addr)) != mraa::SUCCESS)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": I2c.address() failed");
-      return;
-    }
-
-  m_gpioIRQ.dir(mraa::DIR_IN);
-  m_gpioReset.dir(mraa::DIR_OUT);
-}
-
-PN532::~PN532()
-{
-  if (m_isrInstalled)
-    m_gpioIRQ.isrExit();
-}
-
-bool PN532::init()
-{
-  m_gpioReset.write(1);
-  m_gpioReset.write(0);
-  usleep(400000);
-
-  // install an interrupt handler
-  m_gpioIRQ.isr(mraa::EDGE_FALLING, dataReadyISR, this);
-  m_isrInstalled = true;
-
-  m_gpioReset.write(1);
-
-  return true;
-}
-
-/**************************************************************************/
-/*! 
-    @brief  Prints a hexadecimal value in plain characters
-
-    @param  data      Pointer to the byte data
-    @param  numBytes  Data length in bytes
-*/
-/**************************************************************************/
-static void PrintHex(const uint8_t * data, const uint32_t numBytes)
-{
-  uint32_t szPos;
-  for (szPos=0; szPos < numBytes; szPos++) 
-    {
-      fprintf(stderr, "0x%02x ", data[szPos] & 0xff);
-    }
-  fprintf(stderr, "\n");
-}
-
-/**************************************************************************/
-/*! 
-    @brief  Prints a hexadecimal value in plain characters, along with
-            the char equivalents in the following format
-
-            00 00 00 00 00 00  ......
-
-    @param  data      Pointer to the byte data
-    @param  numBytes  Data length in bytes
-*/
-/**************************************************************************/
-static void PrintHexChar(const uint8_t * data, const uint32_t numBytes)
-{
-  uint32_t szPos;
-  for (szPos=0; szPos < numBytes; szPos++) 
-    {
-      fprintf(stderr, "0x%02x ", data[szPos] & 0xff);
-    }
-  fprintf(stderr, "  ");
-  for (szPos=0; szPos < numBytes; szPos++) 
-    {
-      if (data[szPos] <= 0x1F)
-        fprintf(stderr, ".");
-      else
-        fprintf(stderr, "%c ", (char)data[szPos]);
-    }
-  fprintf(stderr, "\n");
-}
-
-
-/**************************************************************************/
-/*! 
-  @brief  Checks the firmware version of the PN5xx chip
-
-  @returns  The chip's firmware version and ID
-*/
-/**************************************************************************/
-uint32_t PN532::getFirmwareVersion()
-{
-  uint32_t response = 0;
-
-  pn532_packetbuffer[0] = CMD_GETFIRMWAREVERSION;
-  
-  if (! sendCommandCheckAck(pn532_packetbuffer, 1))
-    return 0;
-  
-  // read data packet
-  readData(pn532_packetbuffer, 12);
-  
-  int offset = 7;  // Skip the ready byte when using I2C
-
-  response <<= 8;
-  response |= pn532_packetbuffer[offset++];
-  response <<= 8;
-  response |= pn532_packetbuffer[offset++];
-  response <<= 8;
-  response |= pn532_packetbuffer[offset++];
-
-  if (response != pn532_firmwarerev)
-    fprintf(stderr, 
-            "Warning: firmware revision 0x%08x does not match expected rev 0x%08x\n",
-            response, pn532_firmwarerev);
-
-  return response;
-}
-
-
-/**************************************************************************/
-/*! 
-  @brief  Sends a command and waits a specified period for the ACK
-
-  @param  cmd       Pointer to the command buffer
-  @param  cmdlen    The size of the command in bytes 
-  @param  timeout   timeout before giving up
-    
-  @returns  1 if everything is OK, 0 if timeout occurred before an
-  ACK was received
-*/
-/**************************************************************************/
-// default timeout of one second
-bool PN532::sendCommandCheckAck(uint8_t *cmd, uint8_t cmdlen, 
-                                uint16_t timeout)
-{
-  // clear any outstanding irq's
-  isReady();
-  
-  // write the command
-  writeCommand(cmd, cmdlen);
-  
-  // Wait for chip to say its ready!
-  if (!waitForReady(timeout)) {
-    cerr << __FUNCTION__ << ": Not ready, timeout" << endl;
-    return false;
-  }
-
-  if (m_pn532Debug)
-    cerr << __FUNCTION__ << ": IRQ received" << endl;
-  
-  // read acknowledgement
-  if (!readAck()) {
-    if (m_pn532Debug)
-      cerr << __FUNCTION__ << ": No ACK frame received!" << endl;
-
-    return false;
-  }
-
-  return true; // ack'd command
-}
-
-/**************************************************************************/
-/*! 
-  @brief  Configures the SAM (Secure Access Module)
-*/
-/**************************************************************************/
-bool PN532::SAMConfig(void)
-{
-  pn532_packetbuffer[0] = CMD_SAMCONFIGURATION;
-  pn532_packetbuffer[1] = 0x01; // normal mode;
-  pn532_packetbuffer[2] = 0x14; // timeout 50ms * 20 = 1 second
-  pn532_packetbuffer[3] = 0x01; // use IRQ pin!
-  
-  if (! sendCommandCheckAck(pn532_packetbuffer, 4))
-    return false;
-
-  // read data packet
-  readData(pn532_packetbuffer, 8);
-  
-  int offset = 6;
-  return  (pn532_packetbuffer[offset] == 0x15);
-}
-
-/**************************************************************************/
-/*! 
-  Sets the MxRtyPassiveActivation byte of the RFConfiguration register
-    
-  @param  maxRetries    0xFF to wait forever, 0x00..0xFE to timeout
-  after mxRetries
-    
-  @returns 1 if everything executed properly, 0 for an error
-*/
-/**************************************************************************/
-bool PN532::setPassiveActivationRetries(uint8_t maxRetries)
-{
-  pn532_packetbuffer[0] = CMD_RFCONFIGURATION;
-  pn532_packetbuffer[1] = 5;    // Config item 5 (MaxRetries)
-  pn532_packetbuffer[2] = 0xFF; // MxRtyATR (default = 0xFF)
-  pn532_packetbuffer[3] = 0x01; // MxRtyPSL (default = 0x01)
-  pn532_packetbuffer[4] = maxRetries;
-
-  if (m_mifareDebug)
-    cerr << __FUNCTION__ << ": Setting MxRtyPassiveActivation to " 
-         << (int)maxRetries << endl;
-  
-  if (! sendCommandCheckAck(pn532_packetbuffer, 5))
-    return false;  // no ACK
-  
-  return true;
-}
-
-/***** ISO14443A Commands ******/
-
-/**************************************************************************/
-/*! 
-  Waits for an ISO14443A target to enter the field
-    
-  @param  cardBaudRate  Baud rate of the card
-  @param  uid           Pointer to the array that will be populated
-  with the card's UID (up to 7 bytes)
-  @param  uidLength     Pointer to the variable that will hold the
-  length of the card's UID.
-    
-  @returns 1 if everything executed properly, 0 for an error
-*/
-/**************************************************************************/
-bool PN532::readPassiveTargetID(BAUD_T cardbaudrate, uint8_t * uid, 
-                                uint8_t * uidLength, uint16_t timeout)
-{
-  pn532_packetbuffer[0] = CMD_INLISTPASSIVETARGET;
-  pn532_packetbuffer[1] = 1;  // max 1 cards at once (we can set this
-                              // to 2 later)
-  pn532_packetbuffer[2] = cardbaudrate;
-  
-  if (!sendCommandCheckAck(pn532_packetbuffer, 3, timeout))
-    {
-      if (m_pn532Debug)
-        cerr << __FUNCTION__ << ": No card(s) read" << endl;
-
-      return false;  // no cards read
-    }
-
-  // wait for a card to enter the field (only possible with I2C)
-  if (m_pn532Debug)
-    cerr << __FUNCTION__ << ": Waiting for IRQ (indicates card presence)" << endl;
-
-  if (!waitForReady(timeout)) {
-    if (m_pn532Debug)
-      cerr << __FUNCTION__ << ": IRQ Timeout" << endl;
-
-    return false;
-  }
-  
-  // read data packet
-  readData(pn532_packetbuffer, 20);
-
-  // check some basic stuff
-
-  /* ISO14443A card response should be in the following format:
-  
-     byte            Description
-     -------------   ------------------------------------------
-     b0..6           Frame header and preamble
-     b7              Tags Found
-     b8              Tag Number (only one used in this example)
-     b9..10          SENS_RES
-     b11             SEL_RES
-     b12             NFCID Length
-     b13..NFCIDLen   NFCID                                      */
-
-  // SENS_RES   SEL_RES     Manufacturer/Card Type    NFCID Len
-  // --------   -------     -----------------------   ---------
-  // 00 04      08          NXP Mifare Classic 1K     4 bytes   
-  // 00 02      18          NXP Mifare Classic 4K     4 bytes
-  
-  if (m_mifareDebug)
-    cerr << __FUNCTION__ << ": Found " <<  (int)pn532_packetbuffer[7] << " tags"
-         << endl;
-
-  // only one card can be handled currently
-  if (pn532_packetbuffer[7] != 1) 
-    return false;
-    
-  uint16_t sens_res = pn532_packetbuffer[9];
-  sens_res <<= 8;
-  sens_res |= pn532_packetbuffer[10];
-
-  // store these for later retrieval, they can be used to more accurately
-  // ID the type of card.
-
-  m_ATQA = sens_res;
-  m_SAK = pn532_packetbuffer[11]; // SEL_RES
-
-  if (m_mifareDebug)
-    {
-      fprintf(stderr, "ATQA: 0x%04x\n", m_ATQA); 
-      fprintf(stderr, "SAK: 0x%02x\n", m_SAK);
-    }
-
-  /* Card appears to be Mifare Classic */
-  // JET: How so?
-
-  *uidLength = pn532_packetbuffer[12];
-  if (m_mifareDebug)
-    fprintf(stderr, "UID: "); 
-
-  for (uint8_t i=0; i < pn532_packetbuffer[12]; i++) 
-    {
-      uid[i] = pn532_packetbuffer[13+i];
-      if (m_mifareDebug)
-        fprintf(stderr, "0x%02x ", uid[i]); 
-    }
-  if (m_mifareDebug)
-    fprintf(stderr, "\n");
-
-  return true;
-}
-
-/**************************************************************************/
-/*! 
-  @brief  Exchanges an APDU with the currently inlisted peer
-
-  @param  send            Pointer to data to send
-  @param  sendLength      Length of the data to send
-  @param  response        Pointer to response data
-  @param  responseLength  Pointer to the response data length
-*/
-/**************************************************************************/
-bool PN532::inDataExchange(uint8_t * send, uint8_t sendLength,
-                           uint8_t * response, uint8_t * responseLength)
-{
-  if (sendLength > PN532_PACKBUFFSIZ-2) {
-    if (m_pn532Debug)
-      cerr << __FUNCTION__ << ": APDU length too long for packet buffer"
-           << endl;
-
-    return false;
-  }
-  uint8_t i;
-  
-  pn532_packetbuffer[0] = CMD_INDATAEXCHANGE; // 0x40
-  pn532_packetbuffer[1] = m_inListedTag;
-  for (i=0; i<sendLength; ++i) {
-    pn532_packetbuffer[i+2] = send[i];
-  }
-  
-  if (!sendCommandCheckAck(pn532_packetbuffer,sendLength+2,1000)) {
-    if (m_pn532Debug)
-      cerr << __FUNCTION__ << ": Could not send ADPU" << endl;
-
-    return false;
-  }
-
-  if (!waitForReady(1000)) {
-    if (m_pn532Debug)
-      cerr << __FUNCTION__ << ": Response never received for ADPU..." << endl;
-
-    return false;
-  }
-
-  readData(pn532_packetbuffer, sizeof(pn532_packetbuffer));
-  
-  if (pn532_packetbuffer[0] == 0 && pn532_packetbuffer[1] == 0 &&
-      pn532_packetbuffer[2] == 0xff)
-    {
-      
-      uint8_t length = pn532_packetbuffer[3];
-      if (pn532_packetbuffer[4]!=(uint8_t)(~length+1))
-        {
-          if (m_pn532Debug)
-            fprintf(stderr, "Length check invalid: 0x%02x != 0x%02x\n", length,
-                    (~length)+1);
-
-          return false;
-        }
-      if (pn532_packetbuffer[5]==PN532_PN532TOHOST && 
-          pn532_packetbuffer[6]==RSP_INDATAEXCHANGE)
-        {
-          if ((pn532_packetbuffer[7] & 0x3f)!=0)
-            {
-              if (m_pn532Debug)
-                cerr << __FUNCTION__ << ": Status code indicates an error" 
-                     << endl;
-
-              return false;
-            }
-          
-          length -= 3;
-          
-          if (length > *responseLength) {
-            length = *responseLength; // silent truncation...
-          }
-          
-          for (i=0; i<length; ++i) {
-            response[i] = pn532_packetbuffer[8+i];
-          }
-          *responseLength = length;
-          
-          return true;
-        } 
-      else {
-        fprintf(stderr, "Don't know how to handle this command: 0x%02x\n",
-                pn532_packetbuffer[6]);
-        return false;
-      } 
-    } 
-  else {
-    cerr << __FUNCTION__ << ": Preamble missing" << endl;
-    return false;
-  }
-}
-
-/**************************************************************************/
-/*! 
-  @brief  'InLists' a passive target. PN532 acting as reader/initiator,
-  peer acting as card/responder.
-*/
-/**************************************************************************/
-bool PN532::inListPassiveTarget() 
-{
-  m_inListedTag = 0;
-
-  pn532_packetbuffer[0] = CMD_INLISTPASSIVETARGET;
-  pn532_packetbuffer[1] = 1;
-  pn532_packetbuffer[2] = 0;
-  
-  if (m_pn532Debug)
-    cerr << __FUNCTION__ << ": About to inList passive target" << endl;
-
-  if (!sendCommandCheckAck(pn532_packetbuffer,3,1000)) {
-    if (m_pn532Debug)
-      cerr << __FUNCTION__ << ": Could not send inlist message" << endl;
-
-    return false;
-  }
-
-  if (!waitForReady(30000)) {
-    return false;
-  }
-
-  readData(pn532_packetbuffer, sizeof(pn532_packetbuffer));
-  
-  if (pn532_packetbuffer[0] == 0 && pn532_packetbuffer[1] == 0 && 
-      pn532_packetbuffer[2] == 0xff) {
-
-    uint8_t length = pn532_packetbuffer[3];
-    if (pn532_packetbuffer[4]!=(uint8_t)(~length+1)) {
-      if (m_pn532Debug)
-        fprintf(stderr, "Length check invalid: 0x%02x != 0x%02x\n", length,
-                (~length)+1);
-
-      return false;
-    }
-    if (pn532_packetbuffer[5]==PN532_PN532TOHOST && 
-        pn532_packetbuffer[6]==RSP_INLISTPASSIVETARGET) {
-      if (pn532_packetbuffer[7] != 1) {
-        cerr << __FUNCTION__ << ": Unhandled number of tags inlisted: "
-             << (int)pn532_packetbuffer[7] << endl;
-        return false;
-      }
-      
-      m_inListedTag = pn532_packetbuffer[8];
-      if (m_pn532Debug)
-        cerr << __FUNCTION__ << ": Tag number: " << (int)m_inListedTag << endl;
-      
-      return true;
-    } else {
-      if (m_pn532Debug)
-        cerr << __FUNCTION__ << ": Unexpected response to inlist passive host"
-             << endl;
-
-      return false;
-    } 
-  } 
-  else {
-    if (m_pn532Debug)
-      cerr << __FUNCTION__ << ": Preamble missing" << endl;
-
-    return false;
-  }
-
-  return true;
-}
-
-
-/***** Mifare Classic Functions ******/
-/*  MIFARE CLASSIC DESCRIPTION
-    ==========================
-
-    Taken from: https://www.kismetwireless.net/code-old/svn/hardware/kisbee-02/firmware/drivers/rf/pn532/helpers/pn532_mifare_classic.c
-
-    MIFARE Classic cards come in 1K and 4K varieties.  While several
-    varieties of chips exist, the two main chipsets used are described
-    in the following publicly accessible documents:
-
-        MF1S503x Mifare Classic 1K data sheet:
-        http://www.nxp.com/documents/data_sheet/MF1S503x.pdf
-            
-        MF1S70yyX MIFARE Classic 4K data sheet:
-        http://www.nxp.com/documents/data_sheet/MF1S70YYX.pdf
-
-    Mifare Classic cards typically have a a 4-byte NUID, though you may
-    find cards with 7 byte IDs as well
-        
-    EEPROM MEMORY
-    =============
-    Mifare Classic cards have either 1K or 4K of EEPROM memory. Each
-    memory block can be configured with different access conditions,
-    with two seperate authentication keys present in each block.
-
-    The two main Mifare Classic card types are organised as follows:
-
-        1K Cards: 16 sectors of 4 blocks (0..15)
-        4K Cards: 32 sectors of 4 blocks (0..31) and
-                  8 sectors of 16 blocks (32..39)
-
-    4 block sectors
-    ===============
-    Sector  Block   Bytes                                                           Description
-    ------  -----   -----                                                           -----------
-                    0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15
-
-    1       3       [-------KEY A-------]   [Access Bits]   [-------KEY A-------]   Sector Trailer 1
-            2       [                            Data                           ]   Data
-            1       [                            Data                           ]   Data
-            0       [                            Data                           ]   Data
-
-    0       3       [-------KEY A-------]   [Access Bits]   [-------KEY A-------]   Sector Trailer 1
-            2       [                            Data                           ]   Data
-            1       [                            Data                           ]   Data
-            0       [                     Manufacturer Data                     ]   Manufacturer Block
-
-    Sector Trailer (Block 3)
-    ------------------------
-    The sector trailer block contains the two secret keys (Key A and Key B), as well
-    as the access conditions for the four blocks.  It has the following structure:
-
-        Sector Trailer Bytes
-        --------------------------------------------------------------
-        0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15
-        [       Key A       ]   [Access Bits]   [       Key B       ]
-
-    For more information in using Keys to access the clock contents, see
-    Accessing Data Blocks further below.
-
-    Data Blocks (Blocks 0..2)
-    -------------------------
-    Data blocks are 16 bytes wide and, depending on the permissions set in the
-    access bits, can be read from and written to. You are free to use the 16 data
-    bytes in any way you wish.  You can easily store text input, store four 32-bit
-    integer values, a 16 character uri, etc.
-
-    Data Blocks as "Value Blocks"
-    -----------------------------
-    An alternative to storing random data in the 16 byte-wide blocks is to
-    configure them as "Value Blocks".  Value blocks allow performing electronic
-    purse functions (valid commands are: read, write, increment, decrement,
-    restore, transfer).
-    
-    Each Value block contains a single signed 32-bit value, and this value is
-    stored 3 times for data integrity and security reasons.  It is stored twice
-    non-inverted, and once inverted.  The last 4 bytes are used for a 1-byte
-    address, which is stored 4 times (twice non-inverted, and twice inverted).
-    
-    Data blocks configured as "Value Blocks" have the following structure:
-
-        Value Block Bytes
-        --------------------------------------------------------------
-        0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15
-        [   Value   ]   [   ~Value  ]   [   Value   ]   [A  ~A  A   ~A]
-
-    Manufacturer Block (Sector 0, Block 0)
-    --------------------------------------
-    Sector 0 is special since it contains the Manufacturer Block. This block
-    contains the manufacturer data, and is read-only.  It should be avoided
-    unless you know what you are doing.
-
-    16 block sectors
-    ================
-    16 block sectors are identical to 4 block sectors, but with more data blocks.  The same
-    structure described in the 4 block sectors above applies.
-
-    Sector  Block   Bytes                                                           Description
-    ------  -----   -----                                                           ----------
-                    0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15
-
-    32      15      [-------KEY A-------]   [Access Bits]   [-------KEY B-------]   Sector Trailer 32
-            14      [                            Data                           ]   Data
-            13      [                            Data                           ]   Data
-            ...
-            2       [                            Data                           ]   Data
-            1       [                            Data                           ]   Data
-            0       [                            Data                           ]   Data
-
-    ACCESSING DATA BLOCKS
-    =====================
-
-    Before you can access the cards, you must following two steps:
-
-    1.) You must retrieve the 7 byte UID or the 4-byte NUID of the card.
-        This can be done using pn532_mifareclassic_WaitForPassiveTarget()
-        below, which will return the appropriate ID.
-
-    2.) You must authenticate the sector you wish to access according to the
-        access rules defined in the Sector Trailer block for that sector.
-        This can be done using pn532_mifareclassic_AuthenticateBlock(),
-        passing in the appropriate key value.
-          
-        Most new cards have a default Key A of 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF,
-        but some common values worth trying are:
-
-            0XFF 0XFF 0XFF 0XFF 0XFF 0XFF
-            0XD3 0XF7 0XD3 0XF7 0XD3 0XF7
-            0XA0 0XA1 0XA2 0XA3 0XA4 0XA5
-            0XB0 0XB1 0XB2 0XB3 0XB4 0XB5
-            0X4D 0X3A 0X99 0XC3 0X51 0XDD
-            0X1A 0X98 0X2C 0X7E 0X45 0X9A
-            0XAA 0XBB 0XCC 0XDD 0XEE 0XFF
-            0X00 0X00 0X00 0X00 0X00 0X00
-            0XAB 0XCD 0XEF 0X12 0X34 0X56
-
-    3.) Once authenication has succeeded, and depending on the sector
-        permissions, you can then read/write/increment/decrement the
-        contents of the specific block, using one of the helper functions
-        included in this module.
-
-*/
-/**************************************************************************/
-/*! 
-  Indicates whether the specified block number is the first block
-  in the sector (block 0 relative to the current sector)
-*/
-/**************************************************************************/
-bool PN532::mifareclassic_IsFirstBlock (uint32_t uiBlock)
-{
-  // Test if we are in the small or big sectors
-  if (uiBlock < 128)
-    return ((uiBlock) % 4 == 0);
-  else
-    return ((uiBlock) % 16 == 0);
-}
-
-/**************************************************************************/
-/*! 
-  Indicates whether the specified block number is the sector trailer
-*/
-/**************************************************************************/
-bool PN532::mifareclassic_IsTrailerBlock (uint32_t uiBlock)
-{
-  // Test if we are in the small or big sectors
-  if (uiBlock < 128)
-    return ((uiBlock + 1) % 4 == 0);
-  else
-    return ((uiBlock + 1) % 16 == 0);
-}
-
-/**************************************************************************/
-/*! 
-  Tries to authenticate a block of memory on a MIFARE card using the
-  INDATAEXCHANGE command.  See section 7.3.8 of the PN532 User Manual
-  for more information on sending MIFARE and other commands.
-
-  @param  uid           Pointer to a byte array containing the card UID
-  @param  uidLen        The length (in bytes) of the card's UID (Should
-  be 4 for MIFARE Classic)
-  @param  blockNumber   The block number to authenticate.  (0..63 for
-  1KB cards, and 0..255 for 4KB cards).
-  @param  keyNumber     Which key type to use during authentication
-  (0 = MIFARE_CMD_AUTH_A, 1 = MIFARE_CMD_AUTH_B)
-  @param  keyData       Pointer to a byte array containing the 6 byte
-  key value
-    
-  @returns 1 if everything executed properly, 0 for an error
-*/
-/**************************************************************************/
-bool PN532::mifareclassic_AuthenticateBlock (uint8_t * uid, uint8_t uidLen,
-                                             uint32_t blockNumber,
-                                             uint8_t keyNumber,
-                                             uint8_t * keyData)
-{
-  uint8_t i;
-  
-  // Hang on to the key and uid data
-  memcpy (m_key, keyData, 6);
-  memcpy (m_uid, uid, uidLen);
-  m_uidLen = uidLen;  
-  
-  if (m_mifareDebug)
-    {
-      fprintf(stderr, "Trying to authenticate card ");
-      PrintHex(m_uid, m_uidLen);
-      fprintf(stderr, "Using authentication KEY %c: ", 
-              keyNumber ? 'B' : 'A');
-      PrintHex(m_key, 6);
-    }
-  
-  // Prepare the authentication command //
-  pn532_packetbuffer[0] = CMD_INDATAEXCHANGE;   /* Data Exchange Header */
-  pn532_packetbuffer[1] = 1;                              /* Max card numbers */
-  pn532_packetbuffer[2] = (keyNumber) ? MIFARE_CMD_AUTH_B : MIFARE_CMD_AUTH_A;
-  pn532_packetbuffer[3] = blockNumber;                    /* Block
-                                                             Number
-                                                             (1K =
-                                                             0..63, 4K
-                                                             =
-                                                             0..255 */
-  memcpy (pn532_packetbuffer+4, m_key, 6);
-  for (i = 0; i < m_uidLen; i++)
-    {
-      pn532_packetbuffer[10+i] = m_uid[i];                /* 4 byte card ID */
-    }
-  
-  if (! sendCommandCheckAck(pn532_packetbuffer, 10+m_uidLen))
-    return false;
-  
-  if (!waitForReady(1000)) {
-    if (m_pn532Debug)
-      cerr << __FUNCTION__ << ": timeout waiting auth..." << endl;
-
-    return false;
-  }
-
-  // Read the response packet
-  readData(pn532_packetbuffer, 12);
-  
-  // check if the response is valid and we are authenticated???
-  // for an auth success it should be bytes 5-7: 0xD5 0x41 0x00
-  // Mifare auth error is technically byte 7: 0x14 but anything other
-  // and 0x00 is not good
-  if (pn532_packetbuffer[7] != 0x00)
-    {
-      if (m_pn532Debug)
-        {
-          fprintf(stderr, "Authentication failed: ");
-          PrintHexChar(pn532_packetbuffer, 12);
-        }
-
-      return false;
-    }
-  
-  return true;
-}
-
-/**************************************************************************/
-/*! 
-  Tries to read an entire 16-byte data block at the specified block
-  address.
-
-  @param  blockNumber   The block number to authenticate.  (0..63 for
-  1KB cards, and 0..255 for 4KB cards).
-  @param  data          Pointer to the byte array that will hold the
-  retrieved data (if any)
-    
-  @returns 1 if everything executed properly, 0 for an error
-*/
-/**************************************************************************/
-bool PN532::mifareclassic_ReadDataBlock (uint8_t blockNumber, uint8_t * data)
-{
-  if (m_mifareDebug)
-    cerr << __FUNCTION__ << ": Trying to read 16 bytes from block " 
-         << (int)blockNumber << endl;
-  
-  /* Prepare the command */
-  pn532_packetbuffer[0] = CMD_INDATAEXCHANGE;
-  pn532_packetbuffer[1] = 1;                      /* Card number */
-  pn532_packetbuffer[2] = MIFARE_CMD_READ;        /* Mifare Read
-                                                     command = 0x30 */
-  pn532_packetbuffer[3] = blockNumber;            /* Block Number
-                                                     (0..63 for 1K,
-                                                     0..255 for 4K) */
-  
-  /* Send the command */
-  if (! sendCommandCheckAck(pn532_packetbuffer, 4))
-    {
-      if (m_mifareDebug)
-        cerr << __FUNCTION__ << ": Failed to receive ACK for read command" 
-             << endl;
-
-      return false;
-    }
-  
-  /* Read the response packet */
-  readData(pn532_packetbuffer, 26);
-  
-  /* If byte 8 isn't 0x00 we probably have an error */
-  if (pn532_packetbuffer[7] != 0x00)
-    {
-      if (m_mifareDebug)
-        {
-          fprintf(stderr, "Unexpected response: ");
-          PrintHexChar(pn532_packetbuffer, 26);
-        }
-      return false;
-    }
-  
-  /* Copy the 16 data bytes to the output buffer        */
-  /* Block content starts at byte 9 of a valid response */
-  memcpy (data, pn532_packetbuffer+8, 16);
-  
-  /* Display data for debug if requested */
-  if (m_mifareDebug)
-    {
-      fprintf(stderr, "Block %d: ", blockNumber);
-      PrintHexChar(data, 16);
-    }
-  
-  return true;
-}
-
-/**************************************************************************/
-/*! 
-  Tries to write an entire 16-byte data block at the specified block
-  address.
-
-  @param  blockNumber   The block number to authenticate.  (0..63 for
-  1KB cards, and 0..255 for 4KB cards).
-  @param  data          The byte array that contains the data to write.
-    
-  @returns 1 if everything executed properly, 0 for an error
-*/
-/**************************************************************************/
-bool PN532::mifareclassic_WriteDataBlock (uint8_t blockNumber, uint8_t * data)
-{
-  if (m_mifareDebug)
-    fprintf(stderr, "Trying to write 16 bytes to block %d\n", blockNumber);
-  
-  /* Prepare the first command */
-  pn532_packetbuffer[0] = CMD_INDATAEXCHANGE;
-  pn532_packetbuffer[1] = 1;                      /* Card number */
-  pn532_packetbuffer[2] = MIFARE_CMD_WRITE;       /* Mifare Write
-                                                     command = 0xA0 */
-  pn532_packetbuffer[3] = blockNumber;            /* Block Number
-                                                     (0..63 for 1K,
-                                                     0..255 for 4K) */
-  memcpy (pn532_packetbuffer+4, data, 16);          /* Data Payload */
-  
-  /* Send the command */
-  if (! sendCommandCheckAck(pn532_packetbuffer, 20))
-    {
-      if (m_mifareDebug)
-        cerr << __FUNCTION__ << ": Failed to receive ACK for write command"
-             << endl;
-
-      return false;
-    }  
-  usleep(10000);
-  
-  /* Read the response packet */
-  readData(pn532_packetbuffer, 26);
-  
-  return true;
-}
-
-/**************************************************************************/
-/*! 
-  Formats a Mifare Classic card to store NDEF Records 
-    
-  @returns 1 if everything executed properly, 0 for an error
-*/
-/**************************************************************************/
-bool PN532::mifareclassic_FormatNDEF (void)
-{
-  uint8_t sectorbuffer1[16] = {0x14, 0x01, 0x03, 0xE1, 0x03, 0xE1, 0x03, 0xE1, 
-                               0x03, 0xE1, 0x03, 0xE1, 0x03, 0xE1, 0x03, 0xE1};
-  uint8_t sectorbuffer2[16] = {0x03, 0xE1, 0x03, 0xE1, 0x03, 0xE1, 0x03, 0xE1,
-                               0x03, 0xE1, 0x03, 0xE1, 0x03, 0xE1, 0x03, 0xE1};
-  uint8_t sectorbuffer3[16] = {0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0x78, 0x77,
-                               0x88, 0xC1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
-
-  // Note 0xA0 0xA1 0xA2 0xA3 0xA4 0xA5 must be used for key A
-  // for the MAD sector in NDEF records (sector 0)
-
-  // Write block 1 and 2 to the card
-  if (!(mifareclassic_WriteDataBlock (1, sectorbuffer1)))
-    return false;
-  if (!(mifareclassic_WriteDataBlock (2, sectorbuffer2)))
-    return false;
-  // Write key A and access rights card
-  if (!(mifareclassic_WriteDataBlock (3, sectorbuffer3)))
-    return false;
-
-  // Seems that everything was OK (?!)
-  return true;
-}
-
-/**************************************************************************/
-/*! 
-  Writes an NDEF URI Record to the specified sector (1..15)
-    
-  Note that this function assumes that the Mifare Classic card is
-  already formatted to work as an "NFC Forum Tag" and uses a MAD1
-  file system.  You can use the NXP TagWriter app on Android to
-  properly format cards for this.
-
-  @param  sectorNumber  The sector that the URI record should be written
-  to (can be 1..15 for a 1K card)
-  @param  uriIdentifier The uri identifier code (0 = none, 0x01 = 
-  "http://www.", etc.)
-  @param  url           The uri text to write (max 38 characters).
-    
-  @returns 1 if everything executed properly, 0 for an error
-*/
-/**************************************************************************/
-bool PN532::mifareclassic_WriteNDEFURI (uint8_t sectorNumber, 
-                                        NDEF_URI_T uriIdentifier,
-                                        const char * url)
-{
-  if (!url)
-    return false;
-
-  // Figure out how long the string is
-  uint8_t len = strlen(url);
-  
-  // Make sure we're within a 1K limit for the sector number
-  if ((sectorNumber < 1) || (sectorNumber > 15))
-    return false;
-  
-  // Make sure the URI payload is between 1 and 38 chars
-  if ((len < 1) || (len > 38))
-    return false;
-
-  // Note 0xD3 0xF7 0xD3 0xF7 0xD3 0xF7 must be used for key A
-  // in NDEF records
-    
-  // Setup the sector buffer (w/pre-formatted TLV wrapper and NDEF message)
-  uint8_t sectorbuffer1[16] = {0x00, 0x00, 0x03, static_cast<uint8_t>(len+5),
-                               0xD1, 0x01, static_cast<uint8_t>(len+1),
-                               0x55, static_cast<uint8_t>(uriIdentifier), 
-                               0x00, 0x00, 0x00, 0x00, 
-                               0x00, 0x00, 0x00};
-  uint8_t sectorbuffer2[16] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-                               0x00, 0x00};
-  uint8_t sectorbuffer3[16] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-                               0x00, 0x00};
-  uint8_t sectorbuffer4[16] = {0xD3, 0xF7, 0xD3, 0xF7, 0xD3, 0xF7, 0x7F, 
-                               0x07, 0x88, 0x40, 0xFF, 0xFF, 0xFF, 0xFF, 
-                               0xFF, 0xFF};
-  if (len <= 6)
-    {
-      // Unlikely we'll get a url this short, but why not ...
-      memcpy (sectorbuffer1+9, url, len);
-      sectorbuffer1[len+9] = 0xFE;
-    }
-  else if (len == 7)
-    {
-      // 0xFE needs to be wrapped around to next block
-      memcpy (sectorbuffer1+9, url, len);
-      sectorbuffer2[0] = 0xFE;
-    }
-  else if ((len > 7) && (len <= 22))
-    {
-      // Url fits in two blocks
-      memcpy (sectorbuffer1+9, url, 7);
-      memcpy (sectorbuffer2, url+7, len-7);
-      sectorbuffer2[len-7] = 0xFE;
-    }
-  else if (len == 23)
-    {
-      // 0xFE needs to be wrapped around to final block
-      memcpy (sectorbuffer1+9, url, 7);
-      memcpy (sectorbuffer2, url+7, len-7);
-      sectorbuffer3[0] = 0xFE;
-    }
-  else
-    {
-      // Url fits in three blocks
-      memcpy (sectorbuffer1+9, url, 7);
-      memcpy (sectorbuffer2, url+7, 16);
-      memcpy (sectorbuffer3, url+23, len-24);
-      sectorbuffer3[len-23] = 0xFE;
-    }
-  
-  // Now write all three blocks back to the card
-  if (!(mifareclassic_WriteDataBlock (sectorNumber*4, sectorbuffer1)))
-    return false;
-  if (!(mifareclassic_WriteDataBlock ((sectorNumber*4)+1, sectorbuffer2)))
-    return false;
-  if (!(mifareclassic_WriteDataBlock ((sectorNumber*4)+2, sectorbuffer3)))
-    return false;
-  if (!(mifareclassic_WriteDataBlock ((sectorNumber*4)+3, sectorbuffer4)))
-    return false;
-
-  // Seems that everything was OK (?!)
-  return true;
-}
-
-
-/***** NTAG2xx/ultralight Functions ******/
-
-// Ultralight tags are limited to 64 pages max, with ntag2XX tags can
-// have up to 231 pages.
-
-/*  MIFARE ULTRALIGHT DESCRIPTION
-    =============================
-
-    Taken from: https://www.kismetwireless.net/code-old/svn/hardware/kisbee-02/firmware/drivers/rf/pn532/helpers/pn532_mifare_ultralight.c
-
-    MIFARE Ultralight cards typically contain 512 bits (64 bytes) of
-    memory, including 4 bytes (32-bits) of OTP (One Time Programmable)
-    memory where the individual bits can be written but not erased.
-
-        MF0ICU1 Mifare Ultralight Functional Specification:
-        http://www.nxp.com/documents/data_sheet/MF0ICU1.pdf
-            
-
-    Mifare Ultralight cards have a 7-byte UID
-    
-    EEPROM MEMORY
-    =============
-    Mifare Ultralight cards have 512 bits (64 bytes) of EEPROM memory,
-    including 4 byte (32 bits) of OTP memory.  Unlike Mifare Classic cards,
-    there is no authentication on a per block level, although the blocks
-    can be set to "read-only" mode using Lock Bytes (described below).
-
-    EEPROM memory is organised into 16 pages of four bytes eachs, in
-    the following order
-
-    Page   Description
-    ----   ------------
-    0      Serial Number (4 bytes)
-    1      Serial Number (4 bytes)
-    2      Byte 0:    Serial Number
-           Byte 1:    Internal Memory
-           Byte 2..3: lock bytes
-    3      One-time programmable memory (4 bytes)
-    4..15  User memory (4 bytes)
-
-    Lock Bytes (Page 2)
-    -------------------
-    Bytes 2 and 3 of page 2 are referred to as "Lock Bytes".  Each
-    page from 0x03 and higher can individually locked by setting the
-    corresponding locking bit to "1" to prevent further write access,
-    effectively making the memory read only.
-
-    For information on the lock byte mechanism, refer to section 8.5.2 of
-    the datasheet (referenced above).
-
-    OTP Bytes (Page 3)
-    ------------------
-    Page 3 is the OTP memory, and by default all bits on this page are
-    set to 0.  These bits can be bitwise modified using the Mifare WRITE
-    command, and individual bits can be set to 1, but can not be changed
-    back to 0.
-
-    Data Pages (Pages 4..15)
-    ------------------------
-    Pages 4 to 15 are can be freely read from and written to, 
-    provided there is no conflict with the Lock Bytes described above.
-
-    After production, the bytes have the following default values:
-
-    Page    Byte Values
-    ----    ----------------------
-            0     1     2     3
-    4       0xFF  0xFF  0xFF  0xFF
-    5..15   0x00  0x00  0x00  0x00
-
-    ACCESSING DATA BLOCKS
-    =====================
-
-    Before you can access the cards, you must following two steps:
-
-    1.) 'Connect' to a Mifare Ultralight card and retrieve the 7 byte
-        UID of the card.
-
-    2.) Memory can be read and written directly once a passive mode
-        connection has been made.  No authentication is required for
-        Mifare Ultralight cards.
-
-*/
-
-
-/**************************************************************************/
-/*! 
-  Tries to read an entire 4-byte page at the specified address.
-
-  @param  page        The page number (0..63 in most cases)
-  @param  buffer      Pointer to the byte array that will hold the
-  retrieved data (if any)
-*/
-/**************************************************************************/
-bool PN532::ntag2xx_ReadPage (uint8_t page, uint8_t * buffer)
-{
-  // TAG Type       PAGES   USER START    USER STOP
-  // --------       -----   ----------    ---------
-  // NTAG 203       42      4             39
-  // NTAG 213       45      4             39
-  // NTAG 215       135     4             129
-  // NTAG 216       231     4             225
-  
-  if (page >= 231)
-    {
-      cerr << __FUNCTION__ << ": Page value out of range" << endl;
-      return false;
-    }
-
-  if (m_mifareDebug)
-    fprintf(stderr, "Reading page %d\n", page);
-
-  /* Prepare the command */
-  pn532_packetbuffer[0] = CMD_INDATAEXCHANGE;
-  pn532_packetbuffer[1] = 1;                   /* Card number */
-  pn532_packetbuffer[2] = MIFARE_CMD_READ;     /* Mifare Read command = 0x30 */
-  pn532_packetbuffer[3] = page;                /* Page Number (0..63
-                                                  in most cases) */
-
-  /* Send the command */
-  if (! sendCommandCheckAck(pn532_packetbuffer, 4))
-    {
-      if (m_mifareDebug)
-        cerr << __FUNCTION__ << ": Failed to receive ACK for write command"
-             << endl;
-
-      return false;
-    }
-  
-  /* Read the response packet */
-  readData(pn532_packetbuffer, 26);
-
-  if (m_mifareDebug)
-    {
-      fprintf(stderr, "Received: \n");
-      PrintHexChar(pn532_packetbuffer, 26);
-    }
-
-  /* If byte 8 isn't 0x00 we probably have an error */
-  if (pn532_packetbuffer[7] == 0x00)
-    {
-      /* Copy the 4 data bytes to the output buffer         */
-      /* Block content starts at byte 9 of a valid response */
-      /* Note that the command actually reads 16 byte or 4  */
-      /* pages at a time ... we simply discard the last 12  */
-      /* bytes                                              */
-      memcpy (buffer, pn532_packetbuffer+8, 4);
-    }
-  else
-    {
-      if (m_mifareDebug)
-        {
-          fprintf(stderr, "Unexpected response reading block: \n");
-          PrintHexChar(pn532_packetbuffer, 26);
-        }
-
-      return false;
-    }
-
-  /* Display data for debug if requested */
-  if (m_mifareDebug)
-    {
-      fprintf(stderr, "Page %d:\n", page);
-      PrintHexChar(buffer, 4);
-    }
-
-  // Return OK signal
-  return true;
-}
-
-/**************************************************************************/
-/*! 
-  Tries to write an entire 4-byte page at the specified block
-  address.
-
-  @param  page          The page number to write.  (0..63 for most cases)
-  @param  data          The byte array that contains the data to write.
-  Should be exactly 4 bytes long.
-    
-  @returns 1 if everything executed properly, 0 for an error
-*/
-/**************************************************************************/
-bool PN532::ntag2xx_WritePage (uint8_t page, uint8_t * data)
-{
-  // TAG Type       PAGES   USER START    USER STOP
-  // --------       -----   ----------    ---------
-  // NTAG 203       42      4             39
-  // NTAG 213       45      4             39
-  // NTAG 215       135     4             129
-  // NTAG 216       231     4             225
-
-  if ((page < 4) || (page > 225))
-    {
-      cerr << __FUNCTION__ << ": Page value out of range" << endl;
-      return false;
-    }
-
-  if (m_mifareDebug)
-    fprintf(stderr, "Trying to write 4 byte page %d\n", page);
-  
-  /* Prepare the first command */
-  pn532_packetbuffer[0] = CMD_INDATAEXCHANGE;
-  pn532_packetbuffer[1] = 1;    /* Card number */
-  pn532_packetbuffer[2] = MIFARE_ULTRALIGHT_CMD_WRITE; /* Mifare
-                                                          Ultralight
-                                                          Write
-                                                          command =
-                                                          0xA2 */
-  pn532_packetbuffer[3] = page; /* Page Number (0..63 for most cases) */
-  memcpy (pn532_packetbuffer+4, data, 4); /* Data Payload */
-
-  /* Send the command */
-  if (! sendCommandCheckAck(pn532_packetbuffer, 8))
-    {
-      if (m_mifareDebug)
-        cerr << __FUNCTION__ << ": Failed to receive ACK for write command"
-             << endl;
-
-      // Return Failed Signal
-      return false;
-    }  
-  usleep(10000);
-  
-  /* Read the response packet */
-  readData(pn532_packetbuffer, 26);
- 
-  // Return OK Signal
-  return true;
-}
-
-/**************************************************************************/
-/*! 
-  Writes an NDEF URI Record starting at the specified page (4..nn)
-    
-  Note that this function assumes that the NTAG2xx card is
-  already formatted to work as an "NFC Forum Tag".
-
-  @param  uriIdentifier The uri identifier code (0 = none, 0x01 = 
-  "http://www.", etc.)
-  @param  url           The uri text to write (null-terminated string).
-  @param  dataLen       The size of the data area for overflow checks.
-    
-  @returns 1 if everything executed properly, 0 for an error
-*/
-/**************************************************************************/
-bool PN532::ntag2xx_WriteNDEFURI (NDEF_URI_T uriIdentifier, char * url, 
-                                  uint8_t dataLen)
-{
-  uint8_t pageBuffer[4] = { 0, 0, 0, 0 };
-  
-  // Remove NDEF record overhead from the URI data (pageHeader below)
-  uint8_t wrapperSize = 12;
-  
-  // Figure out how long the string is
-  uint8_t len = strlen(url);
-  
-  // Make sure the URI payload will fit in dataLen (include 0xFE trailer)
-  if ((len < 1) || (len+1 > (dataLen-wrapperSize)))
-    return false;
-  
-  // Setup the record header
-  // See NFCForum-TS-Type-2-Tag_1.1.pdf for details
-  uint8_t pageHeader[12] =
-    {
-      /* NDEF Lock Control TLV (must be first and always present) */
-      0x01,         /* Tag Field (0x01 = Lock Control TLV) */
-      0x03,         /* Payload Length (always 3) */
-      0xA0,         /* The position inside the tag of the lock bytes
-                       (upper 4 = page address, lower 4 = byte
-                       offset) */
-      0x10,         /* Size in bits of the lock area */
-      0x44,         /* Size in bytes of a page and the number of bytes
-                       each lock bit can lock (4 bit + 4 bits) */
-      /* NDEF Message TLV - URI Record */
-      0x03,         /* Tag Field (0x03 = NDEF Message) */
-      static_cast<uint8_t>(len+5), /* Payload Length (not including 0xFE trailer) */
-      0xD1,         /* NDEF Record Header (TNF=0x1:Well known record +
-                       SR + ME + MB) */
-      0x01,         /* Type Length for the record type indicator */
-      static_cast<uint8_t>(len+1),        /* Payload len */
-      0x55,         /* Record Type Indicator (0x55 or 'U' = URI Record) */
-      static_cast<uint8_t>(uriIdentifier) /* URI Prefix (ex. 0x01 = "http://www.") */
-    };
-  
-  // Write 12 byte header (three pages of data starting at page 4)
-  memcpy (pageBuffer, pageHeader, 4);
-  if (!(ntag2xx_WritePage (4, pageBuffer)))
-    return false;
-  memcpy (pageBuffer, pageHeader+4, 4);
-  if (!(ntag2xx_WritePage (5, pageBuffer)))
-    return false;
-  memcpy (pageBuffer, pageHeader+8, 4);
-  if (!(ntag2xx_WritePage (6, pageBuffer)))
-    return false;
-  
-  // Write URI (starting at page 7)
-  uint8_t currentPage = 7;
-  char * urlcopy = url;
-  while (len)
-    {
-      if (len < 4)
-        {
-          memset(pageBuffer, 0, 4);
-          memcpy(pageBuffer, urlcopy, len);
-          pageBuffer[len] = 0xFE; // NDEF record footer
-          if (!(ntag2xx_WritePage (currentPage, pageBuffer)))
-            return false;
-          // DONE!
-          return true;
-        }
-      else if (len == 4)
-        {
-          memcpy(pageBuffer, urlcopy, len);
-          if (!(ntag2xx_WritePage (currentPage, pageBuffer)))
-            return false;
-          memset(pageBuffer, 0, 4);
-          pageBuffer[0] = 0xFE; // NDEF record footer
-          currentPage++;
-          if (!(ntag2xx_WritePage (currentPage, pageBuffer)))
-            return false;
-          // DONE!
-          return true;
-        }
-      else
-        {
-          // More than one page of data left
-          memcpy(pageBuffer, urlcopy, 4);
-          if (!(ntag2xx_WritePage (currentPage, pageBuffer)))
-            return false;
-          currentPage++;
-          urlcopy+=4;
-          len-=4;
-        }
-    }
-  
-  // Seems that everything was OK (?!)
-  return true;
-}
-
-
-/**************************************************************************/
-/*! 
-  @brief  Tries to read/verify the ACK packet
-*/
-/**************************************************************************/
-bool PN532::readAck()
-{
-  uint8_t ackbuff[6];
-  
-  readData(ackbuff, 6);
-
-  return (0 == memcmp((char *)ackbuff, (char *)pn532ack, 6));
-}
-
-
-/**************************************************************************/
-/*! 
-  @brief  Return true if the PN532 is ready with a response.
-*/
-/**************************************************************************/
-bool PN532::isReady()
-{
-  // ALWAYS clear the m_irqRcvd flag if set.
-  if (m_irqRcvd)
-    {
-      m_irqRcvd = false;
-      return true;
-    }
-
-  return false;
-}
-
-/**************************************************************************/
-/*! 
-  @brief  Waits until the PN532 is ready.
-
-  @param  timeout   Timeout before giving up
-*/
-/**************************************************************************/
-bool PN532::waitForReady(uint16_t timeout)
-{
-  uint16_t timer = 0;
-  while(!isReady())
-    {
-      if (timeout != 0)
-        {
-          timer += 10;
-          if (timer > timeout)
-            {
-              return false;
-            }
-        }
-      usleep(10000);
-    }
-  return true;
-}
-
-/**************************************************************************/
-/*! 
-  @brief  Reads n bytes of data from the PN532 via SPI or I2C.
-
-  @param  buff      Pointer to the buffer where data will be written
-  @param  n         Number of bytes to be read
-*/
-/**************************************************************************/
-void PN532::readData(uint8_t* buff, uint8_t n)
-{
-  uint8_t buf[n + 2];
-  int rv;
-
-  memset(buf, 0, n+2);
-  usleep(2000); 
-
-  rv = m_i2c.read(buf, n + 2);
-
-  if (m_pn532Debug)
-    {
-      cerr << __FUNCTION__ << ": read returned " << rv << "bytes" << endl;
-
-      fprintf(stderr, "(raw) buf (%d) = ", rv);
-      PrintHex(buf, rv);
-      fprintf(stderr, "\n");
-    }
-
-  for (int i=0; i<n; i++)
-    buff[i] = buf[i+1];
-  
-  if (m_pn532Debug)
-    {
-      fprintf(stderr, "(returned) buf (%d) = \n", n);
-      PrintHex(buff, n);
-      fprintf(stderr, "\n");
-    }
-}
-
-/**************************************************************************/
-/*! 
-  @brief  Writes a command to the PN532, automatically inserting the
-  preamble and required frame details (checksum, len, etc.)
-
-  @param  cmd       Pointer to the command buffer
-  @param  cmdlen    Command length in bytes 
-*/
-/**************************************************************************/
-void PN532::writeCommand(uint8_t* cmd, uint8_t cmdlen)
-{
-  // I2C command write.
-
-  cmdlen++;
-
-  usleep(2000);     // 2ms max in case board needs to wake up
-
-  // command + packet wrapper
-  uint8_t buf[cmdlen + 8];
-  memset(buf, 0, cmdlen + 8);
-  int offset = 0;
-
-  if (m_pn532Debug)
-    cerr << __FUNCTION__ << ": Sending: " << endl;
-
-  uint8_t checksum = PN532_PREAMBLE + PN532_PREAMBLE + PN532_STARTCODE2;
-  buf[offset++] = PN532_PREAMBLE;
-  buf[offset++] = PN532_PREAMBLE;
-  buf[offset++] = PN532_STARTCODE2;
-
-  buf[offset++] = cmdlen;
-  buf[offset++] = ~cmdlen + 1;
-   
-  buf[offset++] = PN532_HOSTTOPN532;
-  checksum += PN532_HOSTTOPN532;
-
-  for (uint8_t i=0; i<cmdlen - 1; i++) 
-    {
-      buf[offset++] = cmd[i];
-      checksum += cmd[i];
-    }
-  
-  buf[offset++] = ~checksum;
-  buf[offset] = PN532_POSTAMBLE;
-
-  if (m_i2c.write(buf, cmdlen + 8 - 1) != mraa::SUCCESS)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": mraa_i2c_write() failed");
-      return;
-    }
-
-  if (m_pn532Debug)
-    {
-      cerr << __FUNCTION__ << ": cmdlen + 8 = " << cmdlen + 8 
-           <<", offset = " << offset << endl;
-
-      PrintHex(buf, cmdlen + 8);
-    }
-} 
-
-void PN532::dataReadyISR(void *ctx)
-{
-  upm::PN532 *This = (upm::PN532 *)ctx;
-
-  // if debugging is enabled, indicate when an interrupt occurred, and
-  // a previously triggered interrupt was still set.
-  if (This->m_pn532Debug)
-    if (This->m_irqRcvd)
-      cerr << __FUNCTION__ << ": INFO: Unhandled IRQ detected." << endl;
-
-  This->m_irqRcvd = true;
-}
-
-PN532::TAG_TYPE_T PN532::tagType()
-{
-  // This is really just a guess, ATQA and SAK could in theory be used
-  // to refine the detection.
-
-  if (m_uidLen == 4)
-    return TAG_TYPE_MIFARE_CLASSIC;
-  else if (m_uidLen == 7)
-    return TAG_TYPE_NFC2;
-  else
-    return TAG_TYPE_UNKNOWN;
-}
diff --git a/src/pn532/pn532.hpp b/src/pn532/pn532.hpp
deleted file mode 100644
index 504dd1d..0000000
--- a/src/pn532/pn532.hpp
+++ /dev/null
@@ -1,505 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * This code is heavily based on the Adafruit-PN532 library at
- * https://github.com/adafruit/Adafruit-PN532, which is licensed under
- * the BSD license. See upm/src/pn532/license.txt
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-  
-
-#pragma once
-
-#include <string.h>
-#include <string>
-#include <mraa/common.hpp>
-#include <mraa/i2c.hpp>
-
-#include <mraa/gpio.hpp>
-
-#define PN532_I2C_BUS 0
-#define PN532_DEFAULT_I2C_ADDR (0x48 >> 1)
-
-#define PN532_PREAMBLE                      (0x00)
-#define PN532_STARTCODE1                    (0x00)
-#define PN532_STARTCODE2                    (0xFF)
-#define PN532_POSTAMBLE                     (0x00)
-
-#define PN532_HOSTTOPN532                   (0xD4)
-#define PN532_PN532TOHOST                   (0xD5)
-
-namespace upm {
-  
-  /**
-   * @brief PN532 NFC/RFID Reader/Writer
-   * @defgroup pn532 libupm-pn532
-   * @ingroup adafruit i2c rfid
-   */
-
-  /**
-   * @library pn532
-   * @sensor pn532
-   * @comname NFC/RFID Reader/Writer
-   * @type rfid
-   * @man adafruit
-   * @web http://www.adafruit.com/products/364
-   * @con i2c
-   *
-   * @brief API for the PN532 based NFC/RFID reader/writer
-   *
-   * @image html pn532.jpg
-   * Identify a card and print out basic info
-   * @snippet pn532.cxx Interesting
-   * Add a URI to an already NDEF formatted ultralight or NTAG2XX tag
-   * @snippet pn532-writeurl.cxx Interesting
-   */
-  class PN532 {
-  public:
-
-    /**
-     * PN532 commands
-     */
-    typedef enum {
-      CMD_DIAGNOSE              = 0x00,
-      CMD_GETFIRMWAREVERSION    = 0x02,
-      CMD_GETGENERALSTATUS      = 0x04,
-      CMD_READREGISTER          = 0x06,
-      CMD_WRITEREGISTER         = 0x08,
-      CMD_READGPIO              = 0x0C,
-      CMD_WRITEGPIO             = 0x0E,
-      CMD_SETSERIALBAUDRATE     = 0x10,
-      CMD_SETPARAMETERS         = 0x12,
-      CMD_SAMCONFIGURATION      = 0x14,
-      CMD_POWERDOWN             = 0x16,
-      CMD_RFCONFIGURATION       = 0x32,
-      CMD_RFREGULATIONTEST      = 0x58,
-      CMD_INJUMPFORDEP          = 0x56,
-      CMD_INJUMPFORPSL          = 0x46,
-      CMD_INLISTPASSIVETARGET   = 0x4A,
-      CMD_INATR                 = 0x50,
-      CMD_INPSL                 = 0x4E,
-      CMD_INDATAEXCHANGE        = 0x40,
-      CMD_INCOMMUNICATETHRU     = 0x42,
-      CMD_INDESELECT            = 0x44,
-      CMD_INRELEASE             = 0x52,
-      CMD_INSELECT              = 0x54,
-      CMD_INAUTOPOLL            = 0x60,
-      CMD_TGINITASTARGET        = 0x8C,
-      CMD_TGSETGENERALBYTES     = 0x92,
-      CMD_TGGETDATA             = 0x86,
-      CMD_TGSETDATA             = 0x8E,
-      CMD_TGSETMETADATA         = 0x94,
-      CMD_TGGETINITIATORCOMMAND = 0x88,
-      CMD_TGRESPONSETOINITIATOR = 0x90,
-      CMD_TGGETTARGETSTATUS     = 0x8A
-    } PN532_CMD_T;
-    
-    /**
-     * Response bytes
-     */
-    typedef enum {
-      RSP_INDATAEXCHANGE        = 0x41,
-      RSP_INLISTPASSIVETARGET   = 0x4B
-    } PN532_RSP_T;
-
-    /**
-     * MIFARE commands
-     */
-    typedef enum {
-      MIFARE_CMD_AUTH_A                   = 0x60,
-      MIFARE_CMD_AUTH_B                   = 0x61,
-      MIFARE_CMD_READ                     = 0x30,
-      MIFARE_CMD_WRITE                    = 0xA0,
-      MIFARE_CMD_TRANSFER                 = 0xB0,
-      MIFARE_CMD_DECREMENT                = 0xC0,
-      MIFARE_CMD_INCREMENT                = 0xC1,
-      MIFARE_CMD_STORE                    = 0xC2,
-      MIFARE_ULTRALIGHT_CMD_WRITE         = 0xA2
-    } MIFARE_CMD_T;
-
-    /**
-     * NDEF prefixes
-     */
-    typedef enum {
-      NDEF_URIPREFIX_NONE                 = 0x00,
-      NDEF_URIPREFIX_HTTP_WWWDOT          = 0x01,
-      NDEF_URIPREFIX_HTTPS_WWWDOT         = 0x02,
-      NDEF_URIPREFIX_HTTP                 = 0x03,
-      NDEF_URIPREFIX_HTTPS                = 0x04,
-      NDEF_URIPREFIX_TEL                  = 0x05,
-      NDEF_URIPREFIX_MAILTO               = 0x06,
-      NDEF_URIPREFIX_FTP_ANONAT           = 0x07,
-      NDEF_URIPREFIX_FTP_FTPDOT           = 0x08,
-      NDEF_URIPREFIX_FTPS                 = 0x09,
-      NDEF_URIPREFIX_SFTP                 = 0x0A,
-      NDEF_URIPREFIX_SMB                  = 0x0B,
-      NDEF_URIPREFIX_NFS                  = 0x0C,
-      NDEF_URIPREFIX_FTP                  = 0x0D,
-      NDEF_URIPREFIX_DAV                  = 0x0E,
-      NDEF_URIPREFIX_NEWS                 = 0x0F,
-      NDEF_URIPREFIX_TELNET               = 0x10,
-      NDEF_URIPREFIX_IMAP                 = 0x11,
-      NDEF_URIPREFIX_RTSP                 = 0x12,
-      NDEF_URIPREFIX_URN                  = 0x13,
-      NDEF_URIPREFIX_POP                  = 0x14,
-      NDEF_URIPREFIX_SIP                  = 0x15,
-      NDEF_URIPREFIX_SIPS                 = 0x16,
-      NDEF_URIPREFIX_TFTP                 = 0x17,
-      NDEF_URIPREFIX_BTSPP                = 0x18,
-      NDEF_URIPREFIX_BTL2CAP              = 0x19,
-      NDEF_URIPREFIX_BTGOEP               = 0x1A,
-      NDEF_URIPREFIX_TCPOBEX              = 0x1B,
-      NDEF_URIPREFIX_IRDAOBEX             = 0x1C,
-      NDEF_URIPREFIX_FILE                 = 0x1D,
-      NDEF_URIPREFIX_URN_EPC_ID           = 0x1E,
-      NDEF_URIPREFIX_URN_EPC_TAG          = 0x1F,
-      NDEF_URIPREFIX_URN_EPC_PAT          = 0x20,
-      NDEF_URIPREFIX_URN_EPC_RAW          = 0x21,
-      NDEF_URIPREFIX_URN_EPC              = 0x22,
-      NDEF_URIPREFIX_URN_NFC              = 0x23
-    } NDEF_URI_T;
-
-    /**
-     * Card baud rates
-     */
-    typedef enum {
-      BAUD_MIFARE_ISO14443A               = 0x00 // 106 Kbit/s
-    } BAUD_T;
-
-
-    /**
-     * Tag types
-     */
-    typedef enum {
-      TAG_TYPE_UNKNOWN                    = 0,
-      TAG_TYPE_MIFARE_CLASSIC             = 1,
-      TAG_TYPE_NFC2                       = 2 /* ultralight or NTAG2XX */
-    } TAG_TYPE_T;
-
-    /**
-     * pn532 constructor
-     *
-     * @param irq pin to use for IRQ
-     * @param reset reset pin
-     * @param bus i2c bus to use
-     * @param address the address for this device
-     */
-    PN532(int irq, int reset, int bus=PN532_I2C_BUS, 
-          uint8_t address=PN532_DEFAULT_I2C_ADDR);
-
-    /**
-     * PN532 Destructor
-     */
-    ~PN532();
-    
-    /**
-     * set up initial values and start operation
-     *
-     * @return true if successful
-     */
-    bool init();
-
-    /**
-     * Checks the firmware version of the PN5xx chip
-     * 
-     * @return the chip's firmware version and ID
-    */
-    uint32_t getFirmwareVersion();
-
-    /**
-     * sends a command and waits a specified period for the ACK
-     * 
-     * @param  cmd       Pointer to the command buffer
-     * @param  cmdlen    the size of the command in bytes 
-     * @param  timeout   timeout before giving up (in ms)
-     * 
-     * @return true if everything is OK, false if timeout occurred
-     * before an ACK was received
-     */
-    bool sendCommandCheckAck(uint8_t *cmd, uint8_t cmdlen, 
-                             uint16_t timeout=1000);
-
-    /**
-     * configures the SAM (Secure Access Module)
-     *
-     * @return true if successfully configured
-     */
-    bool SAMConfig(void);
-
-    /**
-     * sets the MxRtyPassiveActivation byte of the RFConfiguration
-     * register.  By default the pn532 will retry indefinitely.
-     * 
-     * @param  maxRetries 0xFF to wait forever, 0x00..0xFE to timeout
-     * after maxRetries.  0x00 means try once, with no retries on failure.
-     * 
-     * @return true if everything executed properly, false for an error
-     */
-    bool setPassiveActivationRetries(uint8_t maxRetries);
- 
-    /**
-     *  waits for an ISO14443A target to enter the field
-     *
-     * @param  cardbaudrate  baud rate of the card, one of the BAUD_T values
-     * @param  uid Pointer to the array that will be populated with the
-     * cards UID, up to 7 bytes
-     * @param  uidLength Pointer to the variable that will hold the
-     * length of the card's UID.
-     * @param timeout the number of milliseconds to wait
-     *     
-     * @return true if everything executed properly, false for an error
-     */
-    bool readPassiveTargetID(BAUD_T cardbaudrate, uint8_t * uid, 
-                             uint8_t * uidLength, uint16_t timeout);
-    
-    /**
-     * exchanges an APDU (Application Protocol Data Unit) with the
-     * currently inlisted peer
-     *
-     * @param  send            Pointer to data to send
-     * @param  sendLength      Length of the data to send
-     * @param  response        Pointer to response data
-     * @param  responseLength  Pointer to the response data length
-     *     
-     * @return true if everything executed properly, false for an error
-     */
-    bool inDataExchange(uint8_t * send, uint8_t sendLength,
-                        uint8_t * response, uint8_t * responseLength);
-
-    /**
-     * 'InLists' a passive target. PN532 acting as reader/initiator,
-     * peer acting as card/responder.
-     *     
-     * @return true if everything executed properly, false for an error
-     */
-    bool inListPassiveTarget();
-
-    /**
-     *  Indicates whether the specified block number is the first block
-     *  in the sector (block 0 relative to the current sector)
-     *     
-     * @return true if it's the first block, false otherwise
-     */
-    bool mifareclassic_IsFirstBlock (uint32_t uiBlock);
-
-    /**
-     * indicates whether the specified block number is the sector trailer
-     *     
-     * @return true if it's the trailer block, false otherwise
-     */
-    bool mifareclassic_IsTrailerBlock (uint32_t uiBlock);
-
-    /**
-     * tries to authenticate a block of memory on a MIFARE card using the
-     * INDATAEXCHANGE command.  See section 7.3.8 of the PN532 User Manual
-     * for more information on sending MIFARE and other commands.
-     *
-     * @param  uid           Pointer to a byte array containing the card UID
-     * @param  uidLen        The length (in bytes) of the card's UID (Should
-     * be 4 for MIFARE Classic)
-     * @param  blockNumber   The block number to authenticate.  (0..63 for
-     * 1KB cards, and 0..255 for 4KB cards).
-     * @param  keyNumber     Which key type to use during authentication
-     * (0 = MIFARE_CMD_AUTH_A, 1 = MIFARE_CMD_AUTH_B)
-     * @param  keyData       Pointer to a byte array containing the 6 byte
-     * key value
-     *   
-     * @return true if everything executed properly, false for an error
-     */
-    bool mifareclassic_AuthenticateBlock (uint8_t * uid, uint8_t uidLen,
-                                          uint32_t blockNumber,
-                                          uint8_t keyNumber,
-                                          uint8_t * keyData);
-
-    /**
-     *  tries to read an entire 16-byte data block at the specified block
-     *  address.
-     *
-     *  @param  blockNumber   The block number to read  (0..63 for
-     *  1KB cards, and 0..255 for 4KB cards).
-     *  @param  data          Pointer to the byte array that will hold the
-     *  retrieved data (if any)
-     *    
-     *  @return true if everything executed properly, false for an error
-     */
-    bool mifareclassic_ReadDataBlock (uint8_t blockNumber, uint8_t * data);
-
-    /**
-     *  tries to write an entire 16-byte data block at the specified block
-     *  address.
-     *
-     *  @param  blockNumber   The block number to write.  (0..63 for
-     *  1KB cards, and 0..255 for 4KB cards).
-     *  @param  data          The byte array that contains the data to write.
-     *    
-     *  @returns true if everything executed properly, false for an error
-     */
-    bool mifareclassic_WriteDataBlock (uint8_t blockNumber, uint8_t * data);
-
-    /**
-     *  formats a Mifare Classic card to store NDEF Records 
-     *    
-     *  @return true if everything executed properly, false for an error
-     */
-    bool mifareclassic_FormatNDEF (void);
-
-    /**
-     *  writes an NDEF URI Record to the specified sector (1..15)
-     *    
-     *  Note that this function assumes that the Mifare Classic card is
-     *  already formatted to work as an "NFC Forum Tag" and uses a MAD1
-     *  file system.  You can use the NXP TagWriter app on Android to
-     *  properly format cards for this.
-     *
-     * @param  sectorNumber  The sector that the URI record should be written
-     * to (can be 1..15 for a 1K card)
-     * @param  uriIdentifier The uri identifier code (one of the NDEF_URI_T 
-     * values
-     * @param  url the uri text to write (max 38 characters).
-     *    
-     * @return true if everything executed properly, false for an error
-     */
-    bool mifareclassic_WriteNDEFURI (uint8_t sectorNumber, 
-                                     NDEF_URI_T uriIdentifier,
-                                     const char * url);
-
-    /**
-     * read an entire 4-byte page at the specified address
-     *
-     * @param  page        The page number (0..63 in most cases)
-     * @param  buffer      Pointer to the byte array that will hold the
-     * retrieved data (if any)
-     *    
-     * @return true if everything executed properly, false for an error
-     */
-    bool ntag2xx_ReadPage (uint8_t page, uint8_t * buffer);
-
-    /**
-     *  write an entire 4-byte page at the specified block address
-     *
-     * @param  page          The page number to write.  (0..63 for most cases)
-     * @param  data          The byte array that contains the data to write.
-     * Should be exactly 4 bytes long.
-     *    
-     * @return true if everything executed properly, false for an error
-     */
-    bool ntag2xx_WritePage (uint8_t page, uint8_t * data);
-
-    /**
-     * writes an NDEF URI Record starting at the specified page (4..nn)
-     *      
-     * Note that this function assumes that the NTAG2xx card is
-     * already formatted to work as an "NFC Forum Tag".
-     *
-     * @param  uriIdentifier The uri identifier code (one of the NDEF_URI_T 
-     * values
-     * @param  url           The uri text to write (null-terminated string).
-     * @param  dataLen       The size of the data area for overflow checks.
-     *    
-     * @return true if everything executed properly, false for an error
-     */
-    bool ntag2xx_WriteNDEFURI (NDEF_URI_T uriIdentifier, char * url, 
-                               uint8_t dataLen);
-
-    /**
-     * return the ATQA (Answer to Request Acknowledge) value.  This
-     * value is only valid after a successful call to
-     * readPassiveTargetID()
-     * 
-     * @return ATQA value
-     */
-    uint16_t getATQA() { return m_ATQA; };
-
-    /**
-     * return the SAK (Select Acknowledge) value.  This
-     * value is only valid after a successful call to
-     * readPassiveTargetID()
-     * 
-     * @return SAK value
-     */
-    uint8_t getSAK() { return m_SAK; };
-
-    /**
-     * provide public access to the class's MRAA i2C context for
-     * direct user access
-     *
-     * @return a reference to the class i2c context
-     */
-    mraa::I2c& i2cContext() { return m_i2c; };
-
-    /**
-     * enable or disable debugging output for pn532 related operations
-     *
-     * @param enable true to enabloe debug output, false to disable
-     */
-    void pn532Debug(bool enable) { m_pn532Debug = enable; };
-
-    /**
-     * enable or disable debugging output for mifare related operations
-     *
-     * @param enable true to enabloe debug output, false to disable
-     */
-
-    void mifareDebug(bool enable) { m_mifareDebug = enable; };
-
-    /**
-     * try to determine the tag type
-     *
-     * @return one of the TAG_TYPE_T values
-     */
-    TAG_TYPE_T tagType();
-
-  protected:
-    mraa::Gpio m_gpioIRQ;
-    mraa::Gpio m_gpioReset;
-    mraa::I2c m_i2c;
-
-    bool readAck();
-    bool isReady();
-    bool waitForReady(uint16_t timeout);
-    void readData(uint8_t* buff, uint8_t n);
-    void writeCommand(uint8_t* cmd, uint8_t cmdlen);
-
-  private:
-    static void dataReadyISR(void *ctx);
-    bool m_isrInstalled;
-    volatile bool m_irqRcvd;
-
-    uint8_t m_addr;
-
-    uint8_t m_uid[7];       // ISO14443A uid
-    uint8_t m_uidLen;       // uid len
-    uint8_t m_key[6];       // Mifare Classic key
-    uint8_t m_inListedTag;  // Tg number of inlisted tag.
-
-    uint16_t m_ATQA;        // ATQA (Answer to Request Acknowledge - ISO14443)
-                            // for currently inlisted card
-    uint8_t m_SAK;          // SAK (Select Acknowledge) 
-                            // for currently inlisted card
-
-    // debugables
-    bool m_pn532Debug;
-    bool m_mifareDebug;
-  };
-}
-
-
diff --git a/src/pn532/pn532.i b/src/pn532/pn532.i
deleted file mode 100644
index 6456cd5..0000000
--- a/src/pn532/pn532.i
+++ /dev/null
@@ -1,32 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "arrays_java.i"
-%ignore i2cContext;
-%apply signed char[] {uint8_t *};
-%apply unsigned char *OUTPUT {uint8_t *uidLength};
-%apply unsigned char *INOUT {uint8_t *responseLength};
-
-JAVA_JNI_LOADLIBRARY(javaupm_pn532)
-#endif
-/* END Java syntax */
-
-/* BEGIN Javascript syntax  ------------------------------------------------- */
-#ifdef SWIGJAVASCRIPT
-%include "../carrays_uint8_t.i"
-#endif
-/* END Javascript syntax */
-
-/* BEGIN Python syntax  ----------------------------------------------------- */
-#ifdef SWIGPYTHON
-%include "../carrays_uint8_t.i"
-#endif
-/* END Python syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "pn532.hpp"
-%}
-%include "pn532.hpp"
-/* END Common SWIG syntax */
diff --git a/src/pn532/pn532.json b/src/pn532/pn532.json
deleted file mode 100644
index 24e52d4..0000000
--- a/src/pn532/pn532.json
+++ /dev/null
@@ -1,50 +0,0 @@
-{
-    "Library": "pn532",
-    "Description": "Adafruit PN532 NFC/RFID reader/writer Library",
-    "Sensor Class": {
-        "PN532": {
-            "Name": "API for the PN532 based Adafruit NFC/RFID reader/writer",
-            "Description": "This is the UPM Module for the PN532 based Adafruit NFC/RFID reader/writer. The PN532 is the most popular NFC chip, and is what is embedded in pretty much every phone or device that does NFC. It can pretty much do it all, such as read and write to tags and cards, communicate with phones (say for payment processing), and 'act' like a NFC tag. If you want to do any sort of embedded NFC work, this is the chip you'll want to use!",
-            "Aliases": ["pn532", "PN532 NFC/RFID controller breakout board - v1.6"],
-            "Categories": ["rfid"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["Philips", "Adafruit"],
-            "Image": "pn532.jpg",
-            "Examples": {
-                "Python": ["pn532-writeurl.py", "pn532.py"],
-                "Node.js": ["pn532-writeurl.js", "pn532.js"],
-                "C++": ["pn532-writeurl.cxx", "pn532.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 1.6,
-                    "max": 3.6
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "min" : 6,
-                    "max" : 140
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -30,
-                    "max": 85
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                },
-                "Intel Edison": {
-                },
-                "Arduino 101": {
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.adafruit.com/product/364"],
-                "Datasheets": ["https://cdn-shop.adafruit.com/datasheets/pn532ds.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/ppd42ns/CMakeLists.txt b/src/ppd42ns/CMakeLists.txt
deleted file mode 100644
index fdcbced..0000000
--- a/src/ppd42ns/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME ppd42ns
-    DESCRIPTION "Dust Sensor"
-    C_HDR ppd42ns.h ppd42ns_data.h
-    C_SRC ppd42ns.c
-    CPP_HDR ppd42ns.hpp
-    CPP_SRC ppd42ns.cxx
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
-target_link_libraries(${libnamec} m)
diff --git a/src/ppd42ns/ppd42ns.c b/src/ppd42ns/ppd42ns.c
deleted file mode 100644
index 360e3ff..0000000
--- a/src/ppd42ns/ppd42ns.c
+++ /dev/null
@@ -1,196 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Contributions: Rex Tsai <rex.cc.tsai@gmail.com>
- *                Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Rewritten Based on original C++ driver written by:
- * Author: Zion Orent <sorent@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <assert.h>
-#include <stddef.h>
-#include <stdio.h>
-
-#include <upm_math.h>
-#include <upm_utilities.h>
-
-#include "ppd42ns.h"
-
-// Returns the amount of time it takes a pin to go from HIGH to LOW or
-// from LOW to HIGH
-static uint32_t ppd42ns_pulse_in(const ppd42ns_context dev,
-                                 bool high_low_value);
-double pcs2ugm3 (double concentration_pcs);
-
-ppd42ns_context ppd42ns_init(int pin)
-{
-    ppd42ns_context dev =
-        (ppd42ns_context)malloc(sizeof(struct _ppd42ns_context));
-
-    if (!dev)
-        return NULL;
-
-    dev->gpio = NULL;
-
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        ppd42ns_close(dev);
-        return NULL;
-    }
-
-    // MRAA contexts...
-    if ( !(dev->gpio = mraa_gpio_init(pin)) )
-    {
-        printf("%s: mraa_gpio_init() failed\n",
-               __FUNCTION__);
-        ppd42ns_close(dev);
-        return NULL;
-    }
-
-    mraa_gpio_dir(dev->gpio, MRAA_GPIO_IN);
-
-    return dev;
-}
-
-void ppd42ns_close(ppd42ns_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->gpio)
-        mraa_gpio_close(dev->gpio);
-
-    free(dev);
-}
-
-ppd42ns_dust_data ppd42ns_get_data(const ppd42ns_context dev)
-{
-    assert(dev != NULL);
-
-    ppd42ns_dust_data data;
-
-    // in ms, 30 seconds
-    const unsigned int pulse_check_time = 30000;
-    // loop timer
-    upm_clock_t max_loop_time;
-
-    unsigned int low_pulse_occupancy = 0;
-
-    max_loop_time = upm_clock_init();
-
-    do {
-        low_pulse_occupancy += ppd42ns_pulse_in(dev, 0);
-    } while (upm_elapsed_ms(&max_loop_time) < pulse_check_time);
-
-    // Store dust data
-    // Integer percentage 0=>100
-    double ratio = (float)low_pulse_occupancy
-        / ((float)pulse_check_time * 10.0);
-
-     // using spec sheet curve
-    double concentration = (1.1 * pow(ratio,3)) - (3.8 * pow(ratio, 2))
-        + (520 * ratio) + 0.62;
-
-    data.lowPulseOccupancy = low_pulse_occupancy;
-    data.ratio = ratio;
-    data.concentration = concentration;
-    data.ugm3 = pcs2ugm3(data.concentration);
-    data.aqi = upm_ugm3_to_aqi(data.ugm3);
-
-    return data;
-}
-
-
-// Mimicking Arduino's pulseIn function
-// return how long it takes a pin to go from HIGH to LOW or LOW to HIGH
-static uint32_t ppd42ns_pulse_in(const ppd42ns_context dev,
-                                 bool high_low_value)
-{
-    assert(dev != NULL);
-
-    // we run for no more than 1 second at a time
-    upm_clock_t pulse_time;
-    uint32_t total_pulse_time = 0;
-
-    upm_clock_t max_time = upm_clock_init();
-    bool pin_level;
-    bool is_timing = false;
-
-    do {
-        pin_level = (bool)mraa_gpio_read(dev->gpio);
-
-        if (!is_timing && pin_level == high_low_value)
-        {
-            // level is desired level, but not currently timing
-            pulse_time = upm_clock_init();
-            is_timing = true;
-        }
-        else if (is_timing && pin_level != high_low_value)
-        {
-            // we started timing, but level changed
-            total_pulse_time += upm_elapsed_us(&pulse_time);
-            is_timing = false;
-        }
-        else
-        {
-            // not timing and/or level is not equal to desired level
-            // so we "wait".
-            upm_delay_us(10);
-        }
-    } while (upm_elapsed_ms(&max_time) < 1000); // 1 second
-
-    if (is_timing)
-    {
-        // if we were still timing when the loop expired, add the
-        // accumulated time.
-        total_pulse_time += upm_elapsed_us(&pulse_time);
-    }
-
-    return total_pulse_time;
-}
-
-// Assumes density, shape, and size of dust to estimate mass concentration from particle count.
-//
-// This method was described in a 2009 paper
-// Preliminary Screening System for Ambient Air Quality in Southeast Philadelphia by Uva, M., Falcone, R., McClellan, A., and Ostapowicz, E.
-// https://www.yumpu.com/en/document/view/31692906/preliminary-screening-system-for-ambient-air-quality-in-southeast-
-//
-// This method does not use the correction factors, based on the presence of humidity and rain in the paper.
-//
-// convert from particles/0.01 ft3 to ug/m3
-double pcs2ugm3 (double concentration_pcs)
-{
-    double pi = 3.14159;
-    // All particles are spherical, with a density of 1.65E12 ug/m3
-    double density = 1.65 * pow (10, 12);
-    // The radius of a particle in the PM2.5 channel is .44 um
-    double r25 = 0.44 * pow (10, -6);
-    double vol25 = (4/3) * pi * pow (r25, 3);
-    double mass25 = density * vol25; // ug
-    double K = 3531.5; // per m^3 
-
-    return concentration_pcs * K * mass25;
-}
diff --git a/src/ppd42ns/ppd42ns.cxx b/src/ppd42ns/ppd42ns.cxx
deleted file mode 100644
index 72e8371..0000000
--- a/src/ppd42ns/ppd42ns.cxx
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Author: Zion Orent <sorent@ics.com>
- *         Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014-2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "ppd42ns.hpp"
-
-using namespace upm;
-
-PPD42NS::PPD42NS(int pin) :
-    m_ppd42ns(ppd42ns_init(pin))
-{
-    if (!m_ppd42ns)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                    ": ppd42ns_init() failed");
-}
-
-PPD42NS::~PPD42NS()
-{
-    ppd42ns_close(m_ppd42ns);
-}
-
-ppd42ns_dust_data PPD42NS::getData()
-{
-    return ppd42ns_get_data(m_ppd42ns);
-}
-
diff --git a/src/ppd42ns/ppd42ns.h b/src/ppd42ns/ppd42ns.h
deleted file mode 100644
index 09bc597..0000000
--- a/src/ppd42ns/ppd42ns.h
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Based on original C++ driver written by:
- * Author: Zion Orent <sorent@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <upm.h>
-
-#include <mraa/gpio.h>
-#include "ppd42ns_data.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    /**
-     * @file ppd42ns.h
-     * @library ppd42ns
-     * @brief C API for the ppd42ns driver
-     *
-     * @include ppd42ns.c
-     */
-
-    /**
-     * Device context
-     */
-    typedef struct _ppd42ns_context {
-        mraa_gpio_context gpio;
-
-    } *ppd42ns_context;
-
-    /**
-     * PPD42NS initialization
-     *
-     * @param pin Digital pin to use
-     * @return ppd42ns device context
-     */
-    ppd42ns_context ppd42ns_init(int pin);
-
-    /**
-     * PPD42NS close
-     *
-     * @param dev Device context.
-     */
-    void ppd42ns_close(ppd42ns_context dev);
-
-    /**
-     * Prints dust concentration
-     *
-     * @param dev Device context.
-     * @return ppd42ns_dust_data Contains data from the dust sensor
-     */
-    ppd42ns_dust_data ppd42ns_get_data(const ppd42ns_context dev);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/ppd42ns/ppd42ns.hpp b/src/ppd42ns/ppd42ns.hpp
deleted file mode 100644
index aee1cbe..0000000
--- a/src/ppd42ns/ppd42ns.hpp
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Author: Zion Orent <sorent@ics.com>
- *         Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014-2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <ppd42ns.h>
-
-namespace upm {
-
-    /**
-     * @brief PPD42NS Dust Sensor
-     * @defgroup ppd42ns libupm-ppd42ns
-     * @ingroup seeed gpio other eak
-     */
-    /**
-     * @library ppd42ns
-     * @sensor ppd42ns
-     * @comname Dust Sensor
-     * @altname Grove Dust Sensor
-     * @type other
-     * @man seeed
-     * @web http://www.seeedstudio.com/wiki/Grove_-_Dust_Sensor
-     * @con gpio
-     * @kit eak
-     *
-     * @brief API for the PPD42NS Dust Sensor
-     *
-     * UPM module for the PPD42NS dust sensor
-     *
-     * @image html ppd42ns.jpg
-     * @snippet ppd42ns.cxx Interesting
-     */
-    class PPD42NS {
-    public:
-
-        /**
-         * PPD42NS constructor
-         *
-         * @param pin Digital pin to use
-         */
-        PPD42NS(int pin);
-
-        /**
-         * PPD42NS destructor
-         */
-        ~PPD42NS();
-
-        /**
-         * Prints dust concentration
-         *
-         * @return struct ppd42ns_dust_data Contains data from the dust sensor
-         */
-        ppd42ns_dust_data getData();
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        PPD42NS(const PPD42NS&) = delete;
-        PPD42NS &operator=(const PPD42NS&) = delete;
-
-        ppd42ns_context m_ppd42ns;
-    };
-}
-
-
diff --git a/src/ppd42ns/ppd42ns.i b/src/ppd42ns/ppd42ns.i
deleted file mode 100644
index 1f1cfd0..0000000
--- a/src/ppd42ns/ppd42ns.i
+++ /dev/null
@@ -1,15 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_ppd42ns)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "ppd42ns.hpp"
-%}
-%include "ppd42ns_data.h"
-%include "ppd42ns.hpp"
-/* END Common SWIG syntax */
diff --git a/src/ppd42ns/ppd42ns.json b/src/ppd42ns/ppd42ns.json
deleted file mode 100644
index 76b34fd..0000000
--- a/src/ppd42ns/ppd42ns.json
+++ /dev/null
@@ -1,70 +0,0 @@
-{
-    "Library": "ppd42ns",
-    "Description": "Seeed/Shinyei PPD42NS Dust Sensor library",
-    "Sensor Class": {
-        "PPD42NS": {
-            "Name": "API for the Seeed/Shinyei PPD42NS Dust Sensor",
-            "Description": "This is the UPM Module for the Seeed/Shinyei PPD42NS Dust Sensor. This Dust Sensor gives a good indication of the air quality in an environment by measuring the dust concentration. The Particulate Matter level (PM level) in the air is measured by counting the Low Pulse Occupancy time (LPO time) in given time unit. LPO time is proportional to PM concentration. This sensor can provide reliable data for air purifier systems; it is responsive to PM of diameter 1Î¼m.",
-            "Aliases": ["ppd42ns", "Grove - Dust Sensor"],
-            "Categories": ["other"],
-            "Connections": ["gpio"],
-            "Project Type": ["prototyping"],
-            "Manufacturers": ["Shinyei", "Seeed"],
-            "Kits": ["eak"],
-            "Image": "ppd42ns.jpg",
-            "Examples": {
-                "Java": ["PPD42NS_Example.java"],
-                "Python": ["ppd42ns.py"],
-                "Node.js": ["ppd42ns.js"],
-                "C++": ["ppd42ns.cxx"],
-                "C": ["ppd42ns.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 4.75,
-                    "max": 5.75
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "typ": 90
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": 0,
-                    "max": 45
-                },
-                "Effective Range":{
-                    "Pieces Per Liter": {
-                        "unit": "pcs/liter",
-                        "min": 0,
-                        "max": 28000
-                    },
-                    "Pieces Per 0.01 Cubic Foot": {
-                        "unit": "pcs/0.01cf",
-                        "min": 0,
-                        "max": 8000
-                    }
-                },
-                "Particle Diameter": {
-                    "unit": "um",
-                    "size": ">1"
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-Dust-Sensor-p-1050.html", "http://wiki.seeed.cc/Grove-Dust_Sensor/"],
-                "Datasheets": ["https://github.com/SeeedDocument/Grove_Dust_Sensor/raw/master/resource/Grove_-_Dust_sensor.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/ppd42ns/ppd42ns_data.h b/src/ppd42ns/ppd42ns_data.h
deleted file mode 100644
index fe9222d..0000000
--- a/src/ppd42ns/ppd42ns_data.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Contributions: Rex Tsai <rex.cc.tsai@gmail.com>
- *                Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Based on original C++ driver written by:
- * Author: Zion Orent <sorent@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    // This is a data struct used by the ppd42ns (dust sensor) driver.
-    typedef struct
-    {
-        unsigned int lowPulseOccupancy;
-        double ratio;
-        double concentration;
-        double ugm3;
-        int aqi;
-    } ppd42ns_dust_data;
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/pulsensor/CMakeLists.txt b/src/pulsensor/CMakeLists.txt
deleted file mode 100644
index ff7b977..0000000
--- a/src/pulsensor/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "pulsensor")
-set (libdescription "3-wire Pulse Sensor")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa ${CMAKE_THREAD_LIBS_INIT})
diff --git a/src/pulsensor/Callback.hpp b/src/pulsensor/Callback.hpp
deleted file mode 100644
index 6cf3480..0000000
--- a/src/pulsensor/Callback.hpp
+++ /dev/null
@@ -1,12 +0,0 @@
-#pragma once
-
-class Callback
-{
-  public:
-    virtual ~Callback()
-    {
-    }
-    virtual void run(clbk_data arg)
-    { /* empty, overloaded in Java*/
-    }
-};
diff --git a/src/pulsensor/pulsensor.cxx b/src/pulsensor/pulsensor.cxx
deleted file mode 100644
index 38f1376..0000000
--- a/src/pulsensor/pulsensor.cxx
+++ /dev/null
@@ -1,160 +0,0 @@
-/*
- * Author: Andrei Vasiliu <andrei.vasiliu@intel.com>
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string>
-#include <stdexcept>
-#include <unistd.h>
-#include <stdlib.h>
-
-#include "pulsensor.hpp"
-
-using namespace upm;
-
-Pulsensor::Pulsensor (Callback *obj_call) : pin_ctx(0)
-{
-    obj_callback = obj_call;
-
-    sample_counter = 0;
-    last_beat_time = 0;
-    threshold      = 512;
-    ibi            = 600;
-    trough         = 512;
-    peak           = 512;
-    is_pulse       = FALSE;
-    ret            = FALSE;
-    bpm            = 0;
-    qs             = FALSE;
-    apmlitude      = 100;
-}
-
-void Pulsensor::start_sampler ()
-{
-    int error;
-    ctx_counter++;
-    usleep (100000);
-    error = pthread_create (&(sample_thread), NULL, &Pulsensor::do_sample, this);
-    if (error != 0) {
-        printf ("ERROR : Cannot created sampler thread.\n");
-    }
-}
-
-void Pulsensor::stop_sampler () {
-    ctx_counter--;
-}
-
-void *Pulsensor::do_sample (void *arg) {
-    int data_from_sensor;
-    clbk_data callback_data;
-
-    Pulsensor *pulsensor = static_cast<Pulsensor *>(arg);
-
-    while (pulsensor->ctx_counter) {
-        data_from_sensor = pulsensor->pin_ctx.read ();
-        pulsensor->ret = FALSE;
-
-        pulsensor->sample_counter += 2;
-        int N = pulsensor->sample_counter - pulsensor->last_beat_time;
-
-        if (data_from_sensor < pulsensor->threshold &&
-            N > ( pulsensor->ibi / 5)* 3) {
-            if (data_from_sensor < pulsensor->trough) {
-                pulsensor->trough = data_from_sensor;
-            }
-        }
-
-        if (data_from_sensor > pulsensor->threshold &&
-            data_from_sensor > pulsensor->peak) {
-            pulsensor->peak = data_from_sensor;
-        }
-
-        if (N > 250) {
-            // printf ("(NO_GDB) DEBUG\n");
-            if ( (data_from_sensor > pulsensor->threshold) &&
-                    (pulsensor->is_pulse == FALSE) &&
-                    (N > (pulsensor->ibi / 5)* 3) ) {
-                pulsensor->is_pulse = callback_data.is_heart_beat = TRUE;
-
-                pulsensor->obj_callback->run(callback_data);
-
-                pulsensor->ibi = pulsensor->sample_counter - pulsensor->last_beat_time;
-                pulsensor->last_beat_time = pulsensor->sample_counter;
-
-                // second beat
-                if (pulsensor->second_beat) {
-                    pulsensor->second_beat = FALSE;
-                    for (int i = 0; i <= 9; i++) {
-                        pulsensor->ibi_rate[i] = pulsensor->ibi;
-                    }
-                }
-
-                // first beat
-                if (pulsensor->first_beat) {
-                    pulsensor->first_beat  = FALSE;
-                    pulsensor->second_beat = TRUE;
-                    pulsensor->ret = TRUE;
-                } else {
-                    uint32_t running_total = 0;
-                    for(int i = 0; i <= 8; i++){
-                        pulsensor->ibi_rate[i] = pulsensor->ibi_rate[i+1];
-                        running_total += pulsensor->ibi_rate[i];
-                    }
-
-                    pulsensor->ibi_rate[9] = pulsensor->ibi;
-                    running_total += pulsensor->ibi_rate[9];
-                    running_total /= 10;
-                    pulsensor->bpm = 60000 / running_total;
-                    pulsensor->qs = TRUE;
-                }
-            }
-        }
-
-        if (pulsensor->ret == FALSE) {
-            if (data_from_sensor < pulsensor->threshold &&
-                pulsensor->is_pulse == TRUE) {
-                pulsensor->is_pulse = callback_data.is_heart_beat = FALSE;
-
-                pulsensor->obj_callback->run(callback_data);
-
-                pulsensor->is_pulse   = FALSE;
-                pulsensor->apmlitude  = pulsensor->peak - pulsensor->trough;
-                pulsensor->threshold  = pulsensor->apmlitude / 2 + pulsensor->trough;
-                pulsensor->peak       = pulsensor->threshold;
-                pulsensor->trough     = pulsensor->threshold;
-            }
-
-            if (N > 2500) {
-                pulsensor->threshold      = 512;
-                pulsensor->peak           = 512;
-                pulsensor->trough         = 512;
-                pulsensor->last_beat_time = pulsensor->sample_counter;
-                pulsensor->first_beat     = TRUE;
-                pulsensor->second_beat    = FALSE;
-            }
-        }
-
-        usleep (2000);
-    }
-    return NULL;
-}
diff --git a/src/pulsensor/pulsensor.hpp b/src/pulsensor/pulsensor.hpp
deleted file mode 100644
index 2d8f77a..0000000
--- a/src/pulsensor/pulsensor.hpp
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Author: Andrei Vasiliu <andrei.vasiliu@intel.com>
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Credits to Adafruit.
- * Based on Adafruit BMP085 library.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <math.h>
-#include <mraa/pwm.hpp>
-#include <mraa/aio.hpp>
-#include <mraa/gpio.hpp>
-#include <pthread.h>
-
-#define HIGH               1
-#define LOW                0
-
-#define TRUE               HIGH
-#define FALSE              LOW
-
-/**
- * Callback data struct
- */
-struct clbk_data {
-    int is_heart_beat; /**< heartbeat check */
-};
-
-#include "Callback.hpp"
-
-namespace upm {
-/**
- * @brief Pulsensor Pulse Sensor
- * @defgroup pulsensor libupm-pulsensor
- * @ingroup seeed analog medical
- */
-/**
- * @library pulsensor
- * @sensor pulsensor
- * @comname 3-wire Pulse Sensor
- * @type medical
- * @man seeed
- * @web http://www.adafruit.com/products/1093
- * @con analog
- *
- * @brief C++ API for the 3-Wire Pulse Sensor
- *
- * This is a library for a 3-wire pulse sensor sold by several manufacturers.
- * Usually, you can identify the sensor based on the round breakout and the
- * distinctive heart symbol.
- *
- * @image html pulsensor.jpg
- * @snippet pulsensor.cxx Interesting
- */
-class Pulsensor {
-
-public:
-    Pulsensor(Callback *callback);
-
-    void start_sampler();
-    void stop_sampler();
-
-private:
-    static void      *do_sample(void *arg);
-    pthread_t        sample_thread; /**< Thread for the code sample */
-    uint32_t         sample_counter; /**< Counter for the code sample */
-    uint32_t         last_beat_time; /**< Last heartbeat time */
-    int              threshold; /**< Threshold */
-    int              ibi_rate[10]; /**< ibi rate */
-    int              ibi; /**< ibi */
-    int              trough; /**< Trough */
-    int              peak; /**< Peak */
-    int              bpm; /**< Bits per minute */
-    int              apmlitude; /**< Amplitude */
-    uint8_t          qs; /**< qs */
-    uint8_t          is_pulse; /**< Is pulse check */
-    uint8_t          first_beat; /**< First heartbeat */
-    uint8_t          second_beat; /**< Second heartbeat */
-    uint8_t          ret; /**< Return value */
-    mraa::Aio        pin_ctx; /**< The pin context */
-
-    Callback *obj_callback; /**< The callback object */
-    volatile uint16_t ctx_counter;
-};
-}
diff --git a/src/pulsensor/pulsensor.i b/src/pulsensor/pulsensor.i
deleted file mode 100644
index 091bae1..0000000
--- a/src/pulsensor/pulsensor.i
+++ /dev/null
@@ -1,27 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-#ifndef ANDROID
-%module(directors="1") javaupm_pulsensor
-%feature("director") Callback;
-SWIG_DIRECTOR_OWNED(Callback)
-#endif
-%include "arrays_java.i"
-
-%ignore sample_thread;
-%ignore pin_ctx;
-%ignore do_sample;
-%ignore callback;
-
-JAVA_JNI_LOADLIBRARY(javaupm_pulsensor)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "pulsensor.hpp"
-%}
-%include "pulsensor.hpp"
-%include "Callback.hpp"
-/* END Common SWIG syntax */
diff --git a/src/pulsensor/pulsensor.json b/src/pulsensor/pulsensor.json
deleted file mode 100644
index 6a418f6..0000000
--- a/src/pulsensor/pulsensor.json
+++ /dev/null
@@ -1,43 +0,0 @@
-{
-    "Library": "pulsensor",
-    "Description": "Pulse Sensor library",
-    "Sensor Class": {
-        "Pulsensor": {
-            "Name": "C++ API for the Adafruit 3-Wire Pulse Sensor",
-            "Description": "This is the UPM Module for the Adafruit 3-Wire Pulse Sensor. It can be used by students, artists, athletes, makers, and game & mobile developers who want to easily incorporate live heart-rate data into their projects.",
-            "Aliases": ["pulsensor", "Pulse Sensor Amped"],
-            "Categories": ["other"],
-            "Connections": ["analog"],
-            "Project Type": ["medical", "prototyping"],
-            "Manufacturers": ["Adafruit"],
-            "Image": "pulsensor.jpg",
-            "Examples": {
-                "Java": ["Pulsensor_Example.java"],
-                "C++": ["pulsensor.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3,
-                    "max": 5
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -40,
-                    "max": 85
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                },
-                "Intel Edison": {
-                },
-                "Arduino 101": {
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.adafruit.com/product/1093", "https://media.digikey.com/pdf/Data%20Sheets/Pulse%20PDFs/PulseSensorAmpedGettingStartedGuide.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/relay/CMakeLists.txt b/src/relay/CMakeLists.txt
deleted file mode 100644
index a63573f..0000000
--- a/src/relay/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-upm_mixed_module_init (NAME relay
-    DESCRIPTION "Relay"
-    C_HDR relay.h
-    C_SRC relay.c
-    CPP_HDR relay.hpp
-    CPP_SRC relay.cxx
-    FTI_SRC relay_fti.c
-    REQUIRES mraa)
diff --git a/src/relay/relay.c b/src/relay/relay.c
deleted file mode 100644
index a45f0fe..0000000
--- a/src/relay/relay.c
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Author: Sisinty Sasmita Patra <sisinty.s.patra@intel.com>
- *
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "relay.h"
-
-relay_context relay_init(int pin)
-{
-    relay_context dev = (relay_context)malloc(sizeof(struct _relay_context));
-
-    if (dev == NULL)
-        return NULL;
-
-    dev->gpio = mraa_gpio_init(pin);
-
-    if (dev->gpio == NULL)
-    {
-        free(dev);
-        return NULL;
-    }
-    return dev;
-}
-
-void relay_close(relay_context dev)
-{
-    mraa_gpio_close(dev->gpio);
-
-    free(dev);
-}
-
-upm_result_t relay_on(relay_context dev)
-{
-    mraa_gpio_write(dev->gpio, 1);
-    return UPM_SUCCESS;
-}
-
-upm_result_t relay_off(relay_context dev)
-{
-    mraa_gpio_write(dev->gpio, 0);
-    return UPM_SUCCESS;
-}
-
-bool relay_is_on(relay_context dev)
-{
-    int val;
-    val = mraa_gpio_read(dev->gpio);
-    if (val > 0)
-        return true;
-    else
-        return false;
-}
-
-bool relay_is_off(relay_context dev)
-{
-    int val;
-    val = mraa_gpio_read(dev->gpio);
-    if (!val)
-        return true;
-    else
-        return false;
-}
-
diff --git a/src/relay/relay.cxx b/src/relay/relay.cxx
deleted file mode 100644
index 2b6165b..0000000
--- a/src/relay/relay.cxx
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Authors: Brendan Le Foll <brendan.le.foll@intel.com>
- *          Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- *          Sarah Knepper <sarah.knepper@intel.com>
- * Copyright (c) 2014 - 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "relay.hpp"
-
-using namespace upm;
-
-Relay::Relay(unsigned int pin)
-{
-    if ( !(m_gpio = mraa_gpio_init(pin)) ) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_gpio_init() failed, invalid pin?");
-        return;
-    }
-    mraa_gpio_dir(m_gpio, MRAA_GPIO_OUT);
-}
-
-Relay::~Relay()
-{
-    mraa_gpio_close(m_gpio);
-}
-
-mraa_result_t Relay::on()
-{
-    return mraa_gpio_write(m_gpio, 1);
-}
-
-mraa_result_t Relay::off()
-{
-    return mraa_gpio_write(m_gpio, 0);
-}
-
-bool Relay::isOn()
-{
-    return mraa_gpio_read(m_gpio) == 1;
-}
-
-bool Relay::isOff()
-{
-    return mraa_gpio_read(m_gpio) == 0;
-}
diff --git a/src/relay/relay.h b/src/relay/relay.h
deleted file mode 100644
index 525ebeb..0000000
--- a/src/relay/relay.h
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * Author: Sisinty Sasmita Patra <sisinty.s.patra@intel.com>
- *
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef RELAY_H_
-#define RELAY_H_
-
-#pragma once
-#include <stdlib.h>
-#include <unistd.h>
-
-#include "upm.h"
-#include <mraa/gpio.h>
-
-/**
- * @file relay.h
- * @library relay
- * @brief C API for Relays
- *
- * @include relay.c
- */
-
-/**
- * device context
- */
-typedef struct _relay_context{
-    mraa_gpio_context gpio;
-} *relay_context;
-
-/**
- * relay init function
- *
- * @param pin Pin to use
- */
-relay_context relay_init(int pin);
-
-/**
- * relay destructor
- */
-void relay_close(relay_context dev);
-
-/**
- * Sets the relay switch to on (closed circuit). This allows current
- * to flow and lights up the indicator LED.
- *
- * @return result of the operation
- */
-upm_result_t relay_on(relay_context dev);
-
-/**
- * Sets the relay switch to off (open circuit). This stops current
- * from flowing and the indicator LED is not lit.
- *
- * @return result of the operation
- */
-upm_result_t relay_off(relay_context dev);
-
-/**
- * Checks whether the relay switch is closed.
- *
- * @return True if the switch is on (closed), false otherwise
- */
-bool relay_is_on(relay_context dev);
-
-/**
- * Checks whether the relay switch is open.
- *
- * @return True if the switch is off (open), false otherwise
- */
-bool relay_is_off(relay_context dev);
-
-#endif /* RELAY_H_ */
diff --git a/src/relay/relay.hpp b/src/relay/relay.hpp
deleted file mode 100644
index a42676c..0000000
--- a/src/relay/relay.hpp
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * Authors: Brendan Le Foll <brendan.le.foll@intel.com>
- *          Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- *          Sarah Knepper <sarah.knepper@intel.com>
- * Copyright (c) 2014 - 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <string>
-#include <mraa/gpio.hpp>
-
-namespace upm {
- /**
-  * @brief Relay Library
-  * @defgroup relaylib libupm-relay
-  * @ingroup seeed gpio relay gsk eak hak
-  */
-
- /**
-  * @library relaylib
-  * @sensor relay
-  * @comname Relay
-  * @altname Grove Relay
-  * @type relay
-  * @man seeed
-  * @con gpio
-  * @kit gsk eak hak
-  *
-  * @brief API for the Relay
-  *
-  * UPM module for the relay switch. The relay is a digital normally-open
-  * switch that uses low voltage or current to control a higher voltage and/or
-  * higher current.  When closed, the indicator LED (if present) lights up and
-  * current is allowed to flow.
-  *
-  * @image html relay.jpg
-  * @snippet relay.cxx Interesting
-  */
-
-  class Relay{
-    public:
-        /**
-         * relay constructor
-         *
-         * @param pin Pin to use
-         */
-        Relay(unsigned int pin);
-        /**
-         * relay destructor
-         */
-        ~Relay();
-        /**
-         * Sets the relay switch to on (closed). This allows current
-         * to flow and lights up the indicator LED.
-         *
-         * @return 0 if successful, non-zero otherwise
-         */
-        mraa_result_t on();
-        /**
-         * Sets the relay switch to off (open). This stops current
-         * from flowing and the indicator LED is not lit.
-         *
-         * @return 0 if successful, non-zero otherwise
-         */
-        mraa_result_t off();
-        /**
-         * Defines whether the relay switch is closed.
-         *
-         * @return True if the switch is on (closed), false otherwise
-         */
-        bool isOn();
-        /**
-         * Defines whether the relay switch is open.
-         *
-         * @return True if the switch is off (open), false otherwise
-         */
-        bool isOff();
-        std::string name(){ return "Relay Switch";}
-    private:
-        mraa_gpio_context m_gpio;
-  };
-}
diff --git a/src/relay/relay.json b/src/relay/relay.json
deleted file mode 100644
index 24d12f7..0000000
--- a/src/relay/relay.json
+++ /dev/null
@@ -1,68 +0,0 @@
-{
-    "Library": "relaylib",
-    "Description": "Grove Relay library",
-    "Sensor Class": {
-        "Relay": {
-            "Name": "API for the Grove Relay",
-            "Description": "This is the UPM Module for the Grove Relay. UPM module for the relay switch. The relay is a digital normally-open switch that uses low voltage or current to control a higher voltage and/or higher current.  When closed, the indicator LED (if present) lights up and current is allowed to flow.",
-            "Aliases": ["relay", "Grove - Relay"],
-            "Categories": ["relay"],
-            "Connections": ["gpio"],
-            "Project Type": ["prototyping", "industrial", "commercial"],
-            "Manufacturers": ["Seeed"],
-            "Kits": ["gsk", "eak", "hak"],
-            "Image": "relay.jpg",
-            "Examples": {
-                "Java": ["Relay_Example.java"],
-                "Python": ["relay.py"],
-                "Node.js": ["relay.js"],
-                "C++": ["relay.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.3,
-                    "max": 5.0
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "min" : 60,
-                    "max" : 100
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Relay Life": {
-                    "unit": "Cycles",
-                    "typ" : 100000
-                },
-                "Max AC Switching Voltage": {
-                    "unit": "V",
-                    "max": 250
-                },
-                "Max DC Switching Voltage": {
-                    "unit": "V",
-                    "max" : 30
-                },
-                "Max Switching Current": {
-                    "unit": "A",
-                    "max" : 5
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-Relay-p-769.html", "http://wiki.seeed.cc/Grove-Relay/"],
-                "Datasheets": ["https://raw.githubusercontent.com/SeeedDocument/Grove-Relay/master/res/Relay_Datasheet.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/relay/relay_fti.c b/src/relay/relay_fti.c
deleted file mode 100644
index 4723f2d..0000000
--- a/src/relay/relay_fti.c
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Author: Sisinty Sasmita Patra <sisinty.s.patra@intel.com>
- *
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "relay.h"
-#include "upm_fti.h"
-
-/** 
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_relay_name[] = "Grove Relay";
-const char upm_relay_description[] = "Grove relay Sensor";
-const upm_protocol_t upm_relay_protocol[] = {UPM_GPIO};
-const upm_sensor_t upm_relay_category[] = {UPM_SWITCH};
-
-// forward declarations
-const upm_sensor_descriptor_t upm_relay_get_descriptor();
-const void* upm_relay_get_ft(upm_sensor_t sensor_type);
-void* upm_relay_init_name();
-void upm_relay_close(void* dev);
-upm_result_t upm_relay_get_value(void* dev, bool* value, int num);
-
-const upm_sensor_descriptor_t upm_relay_get_descriptor() {
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_relay_name;
-    usd.description = upm_relay_description;
-    usd.protocol_size = 1;
-    usd.protocol = upm_relay_protocol;
-    usd.category_size = 1;
-    usd.category = upm_relay_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = &upm_relay_init_name,
-    .upm_sensor_close = &upm_relay_close,
-    .upm_sensor_get_descriptor = &upm_relay_get_descriptor
-};
-
-static const upm_switch_ft sft =
-{
-    .upm_switch_get_value = &upm_relay_get_value
-};
-
-const void* upm_relay_get_ft(upm_sensor_t sensor_type) {
-    if(sensor_type == UPM_SENSOR) {
-        return &ft;
-    }
-    if(sensor_type == UPM_SWITCH) {
-        return &sft;
-    }
-    return NULL;
-}
-
-void* upm_relay_init_name(){
-    return NULL;
-}
-
-void upm_relay_close(void* dev)
-{
-    relay_close((relay_context)dev);
-}
-
-upm_result_t upm_relay_get_value(void* dev, bool* value, int num)
-{
-    // num is unused
-
-    if (relay_is_on((relay_context)dev))
-        *value = true;
-    else
-        *value = false;
-
-    return UPM_SUCCESS;
-}
diff --git a/src/rf22/CMakeLists.txt b/src/rf22/CMakeLists.txt
deleted file mode 100644
index 445d795..0000000
--- a/src/rf22/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "rf22")
-set (libdescription "ISM Band Radio Transceiver")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/rf22/rf22.cxx b/src/rf22/rf22.cxx
deleted file mode 100644
index 82239e5..0000000
--- a/src/rf22/rf22.cxx
+++ /dev/null
@@ -1,756 +0,0 @@
-/*
- * Author: Kiveisha Yevgeniy
- * Copyright (c) 2015-2016 Intel Corporation
- *
- * Author: Mike McCauley
- * Copyright (c) 2011 Mike McCauley
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <cstring>
-#include <cmath>
-#include <sys/time.h>
-#include "rf22.hpp"
-
-using namespace upm;
-
-// These are indexed by the values of ModemConfigChoice
-// Canned modem configurations generated with 
-// http://www.hoperf.com/upload/rf/RF22B%2023B%2031B%2042B%2043B%20Register%20Settings_RevB1-v5.xls
-// Stored in flash (program) memory to save SRAM
-static const RF22::ModemConfig MODEM_CONFIG_TABLE[] =
-{
-    { 0x2b, 0x03, 0xf4, 0x20, 0x41, 0x89, 0x00, 0x36, 0x40, 0x0a, 0x1d, 0x80, 0x60, 0x10, 0x62, 0x2c, 0x00, 0x08 }, // Unmodulated carrier
-    { 0x2b, 0x03, 0xf4, 0x20, 0x41, 0x89, 0x00, 0x36, 0x40, 0x0a, 0x1d, 0x80, 0x60, 0x10, 0x62, 0x2c, 0x33, 0x08 }, // FSK, PN9 random modulation, 2, 5
-
-    // All the following enable FIFO with reg 71
-    //  1c,   1f,   20,   21,   22,   23,   24,   25,   2c,   2d,   2e,   58,   69,   6e,   6f,   70,   71,   72
-    // FSK, No Manchester, Max Rb err <1%, Xtal Tol 20ppm
-    { 0x2b, 0x03, 0xf4, 0x20, 0x41, 0x89, 0x00, 0x36, 0x40, 0x0a, 0x1d, 0x80, 0x60, 0x10, 0x62, 0x2c, 0x22, 0x08 }, // 2, 5
-    { 0x1b, 0x03, 0x41, 0x60, 0x27, 0x52, 0x00, 0x07, 0x40, 0x0a, 0x1e, 0x80, 0x60, 0x13, 0xa9, 0x2c, 0x22, 0x3a }, // 2.4, 36
-    { 0x1d, 0x03, 0xa1, 0x20, 0x4e, 0xa5, 0x00, 0x13, 0x40, 0x0a, 0x1e, 0x80, 0x60, 0x27, 0x52, 0x2c, 0x22, 0x48 }, // 4.8, 45
-    { 0x1e, 0x03, 0xd0, 0x00, 0x9d, 0x49, 0x00, 0x45, 0x40, 0x0a, 0x20, 0x80, 0x60, 0x4e, 0xa5, 0x2c, 0x22, 0x48 }, // 9.6, 45
-    { 0x2b, 0x03, 0x34, 0x02, 0x75, 0x25, 0x07, 0xff, 0x40, 0x0a, 0x1b, 0x80, 0x60, 0x9d, 0x49, 0x2c, 0x22, 0x0f }, // 19.2, 9.6
-    { 0x02, 0x03, 0x68, 0x01, 0x3a, 0x93, 0x04, 0xd5, 0x40, 0x0a, 0x1e, 0x80, 0x60, 0x09, 0xd5, 0x0c, 0x22, 0x1f }, // 38.4, 19.6
-    { 0x06, 0x03, 0x45, 0x01, 0xd7, 0xdc, 0x07, 0x6e, 0x40, 0x0a, 0x2d, 0x80, 0x60, 0x0e, 0xbf, 0x0c, 0x22, 0x2e }, // 57.6. 28.8
-    { 0x8a, 0x03, 0x60, 0x01, 0x55, 0x55, 0x02, 0xad, 0x40, 0x0a, 0x50, 0x80, 0x60, 0x20, 0x00, 0x0c, 0x22, 0xc8 }, // 125, 125
-
-    // GFSK, No Manchester, Max Rb err <1%, Xtal Tol 20ppm
-    // These differ from FSK only in register 71, for the modulation type
-    { 0x2b, 0x03, 0xf4, 0x20, 0x41, 0x89, 0x00, 0x36, 0x40, 0x0a, 0x1d, 0x80, 0x60, 0x10, 0x62, 0x2c, 0x23, 0x08 }, // 2, 5
-    { 0x1b, 0x03, 0x41, 0x60, 0x27, 0x52, 0x00, 0x07, 0x40, 0x0a, 0x1e, 0x80, 0x60, 0x13, 0xa9, 0x2c, 0x23, 0x3a }, // 2.4, 36
-    { 0x1d, 0x03, 0xa1, 0x20, 0x4e, 0xa5, 0x00, 0x13, 0x40, 0x0a, 0x1e, 0x80, 0x60, 0x27, 0x52, 0x2c, 0x23, 0x48 }, // 4.8, 45
-    { 0x1e, 0x03, 0xd0, 0x00, 0x9d, 0x49, 0x00, 0x45, 0x40, 0x0a, 0x20, 0x80, 0x60, 0x4e, 0xa5, 0x2c, 0x23, 0x48 }, // 9.6, 45
-    { 0x2b, 0x03, 0x34, 0x02, 0x75, 0x25, 0x07, 0xff, 0x40, 0x0a, 0x1b, 0x80, 0x60, 0x9d, 0x49, 0x2c, 0x23, 0x0f }, // 19.2, 9.6
-    { 0x02, 0x03, 0x68, 0x01, 0x3a, 0x93, 0x04, 0xd5, 0x40, 0x0a, 0x1e, 0x80, 0x60, 0x09, 0xd5, 0x0c, 0x23, 0x1f }, // 38.4, 19.6
-    { 0x06, 0x03, 0x45, 0x01, 0xd7, 0xdc, 0x07, 0x6e, 0x40, 0x0a, 0x2d, 0x80, 0x60, 0x0e, 0xbf, 0x0c, 0x23, 0x2e }, // 57.6. 28.8
-    { 0x8a, 0x03, 0x60, 0x01, 0x55, 0x55, 0x02, 0xad, 0x40, 0x0a, 0x50, 0x80, 0x60, 0x20, 0x00, 0x0c, 0x23, 0xc8 }, // 125, 125
-
-    // OOK, No Manchester, Max Rb err <1%, Xtal Tol 20ppm
-    { 0x51, 0x03, 0x68, 0x00, 0x3a, 0x93, 0x01, 0x3d, 0x2c, 0x11, 0x28, 0x80, 0x60, 0x09, 0xd5, 0x2c, 0x21, 0x08 }, // 1.2, 75
-    { 0xc8, 0x03, 0x39, 0x20, 0x68, 0xdc, 0x00, 0x6b, 0x2a, 0x08, 0x2a, 0x80, 0x60, 0x13, 0xa9, 0x2c, 0x21, 0x08 }, // 2.4, 335
-    { 0xc8, 0x03, 0x9c, 0x00, 0xd1, 0xb7, 0x00, 0xd4, 0x29, 0x04, 0x29, 0x80, 0x60, 0x27, 0x52, 0x2c, 0x21, 0x08 }, // 4.8, 335
-    { 0xb8, 0x03, 0x9c, 0x00, 0xd1, 0xb7, 0x00, 0xd4, 0x28, 0x82, 0x29, 0x80, 0x60, 0x4e, 0xa5, 0x2c, 0x21, 0x08 }, // 9.6, 335
-    { 0xa8, 0x03, 0x9c, 0x00, 0xd1, 0xb7, 0x00, 0xd4, 0x28, 0x41, 0x29, 0x80, 0x60, 0x9d, 0x49, 0x2c, 0x21, 0x08 }, // 19.2, 335
-    { 0x98, 0x03, 0x9c, 0x00, 0xd1, 0xb7, 0x00, 0xd4, 0x28, 0x20, 0x29, 0x80, 0x60, 0x09, 0xd5, 0x0c, 0x21, 0x08 }, // 38.4, 335
-    { 0x98, 0x03, 0x96, 0x00, 0xda, 0x74, 0x00, 0xdc, 0x28, 0x1f, 0x29, 0x80, 0x60, 0x0a, 0x3d, 0x0c, 0x21, 0x08 }, // 40, 335
-
-};
-
-RF22::RF22(int spiBus, int slaveSelectPin, int interruptPin)
-{
-    _idleMode = RF22_XTON; // Default idle state is READY mode
-    _mode = RF22_MODE_IDLE; // We start up in idle mode
-    _rxGood = 0;
-    _rxBad = 0;
-    _txGood = 0;
-    
-    //Initialize the SPI bus and pins, MRAA will log any failures here
-    // start the SPI library:
-    // Note the RF22 wants mode 0, MSB first and default to 1 Mbps
-    _spi = mraa_spi_init(spiBus);
-    mraa_spi_mode (_spi, MRAA_SPI_MODE0);
-    mraa_spi_lsbmode(_spi, 0);
-    mraa_spi_frequency(_spi, 1000000); // 1Mhz
-
-    _cs = mraa_gpio_init(slaveSelectPin);
-    mraa_gpio_dir(_cs, MRAA_GPIO_OUT);    
-    
-    _irq = mraa_gpio_init(interruptPin);
-    mraa_gpio_dir(_irq, MRAA_GPIO_IN);
-    mraa_gpio_isr(_irq, MRAA_GPIO_EDGE_FALLING, &isr, (void*)this);
-}
-
-RF22::~RF22()
-{
-    mraa_spi_stop(_spi);
-    mraa_gpio_close(_cs);
-    mraa_gpio_close(_irq);
-}
-
-uint8_t RF22::init()
-{
-    // Wait for RF22 POR (up to 16msec)
-    usleep (16);
-
-    // Initialise the slave select pin    
-    mraa_gpio_write(_cs, 0x1);
-
-    usleep (100);
-    
-    // Software reset the device
-    reset();
-
-    // Get the device type and check it
-    // This also tests whether we are really connected to a device
-    _deviceType = spiRead(RF22_REG_00_DEVICE_TYPE);
-    if (   _deviceType != RF22_DEVICE_TYPE_RX_TRX
-        && _deviceType != RF22_DEVICE_TYPE_TX)
-    return 0;
-
-    clearTxBuf();
-    clearRxBuf();
-  
-    // Most of these are the POR default
-    spiWrite(RF22_REG_7D_TX_FIFO_CONTROL2, RF22_TXFFAEM_THRESHOLD);
-    spiWrite(RF22_REG_7E_RX_FIFO_CONTROL,  RF22_RXFFAFULL_THRESHOLD);
-    spiWrite(RF22_REG_30_DATA_ACCESS_CONTROL, RF22_ENPACRX | RF22_ENPACTX | RF22_ENCRC | RF22_CRC_CRC_16_IBM);
-    // Configure the message headers
-    // Here we set up the standard packet format for use by the RF22 library
-    // 8 nibbles preamble
-    // 2 SYNC words 2d, d4
-    // Header length 4 (to, from, id, flags)
-    // 1 octet of data length (0 to 255)
-    // 0 to 255 octets data
-    // 2 CRC octets as CRC16(IBM), computed on the header, length and data
-    // On reception the to address is check for validity against RF22_REG_3F_CHECK_HEADER3
-    // or the broadcast address of 0xff
-    // If no changes are made after this, the transmitted
-    // to address will be 0xff, the from address will be 0xff
-    // and all such messages will be accepted. This permits the out-of the box
-    // RF22 config to act as an unaddresed, unreliable datagram service
-    spiWrite(RF22_REG_32_HEADER_CONTROL1, RF22_BCEN_HEADER3 | RF22_HDCH_HEADER3);
-    spiWrite(RF22_REG_33_HEADER_CONTROL2, RF22_HDLEN_4 | RF22_SYNCLEN_2);
-    setPreambleLength(8);
-    uint8_t syncwords[] = { 0x2d, 0xd4 };
-    setSyncWords(syncwords, sizeof(syncwords));
-    setPromiscuous(0); 
-    // Check the TO header against RF22_DEFAULT_NODE_ADDRESS
-    spiWrite(RF22_REG_3F_CHECK_HEADER3, RF22_DEFAULT_NODE_ADDRESS);
-    // Set the default transmit header values
-    setHeaderTo(RF22_DEFAULT_NODE_ADDRESS);
-    setHeaderFrom(RF22_DEFAULT_NODE_ADDRESS);
-    setHeaderId(0);
-    setHeaderFlags(0);
-
-    // Ensure the antenna can be switched automatically according to transmit and receive
-    // This assumes GPIO0(out) is connected to TX_ANT(in) to enable tx antenna during transmit
-    // This assumes GPIO1(out) is connected to RX_ANT(in) to enable rx antenna during receive
-    spiWrite (RF22_REG_0B_GPIO_CONFIGURATION0, 0x12) ; // TX state
-    spiWrite (RF22_REG_0C_GPIO_CONFIGURATION1, 0x15) ; // RX state
-
-    // Enable interrupts
-    spiWrite(RF22_REG_05_INTERRUPT_ENABLE1, RF22_ENTXFFAEM | RF22_ENRXFFAFULL | RF22_ENPKSENT | RF22_ENPKVALID | RF22_ENCRCERROR | RF22_ENFFERR);
-    spiWrite(RF22_REG_06_INTERRUPT_ENABLE2, RF22_ENPREAVAL);
-
-    // Set some defaults. An innocuous ISM frequency, and reasonable pull-in
-    setFrequency(434.0, 0.05);
-//    setFrequency(900.0);
-    // Some slow, reliable default speed and modulation
-    setModemConfig(FSK_Rb2_4Fd36);
-//    setModemConfig(FSK_Rb125Fd125);
-    // Minimum power
-    setTxPower(RF22_TXPOW_8DBM);
-//    setTxPower(RF22_TXPOW_17DBM);
-
-    return 1;
-}
-
-// C++ level interrupt handler for this instance
-void RF22::handleInterrupt()
-{
-    uint8_t _lastInterruptFlags[2] = {};
-    // Read the interrupt flags which clears the interrupt
-    spiBurstRead(RF22_REG_03_INTERRUPT_STATUS1, _lastInterruptFlags, 2);
-
-    if (_lastInterruptFlags[0] & RF22_IFFERROR)
-    { 
-        resetFifos(); // Clears the interrupt
-        if (_mode == RF22_MODE_TX)
-            restartTransmit();
-        else if (_mode == RF22_MODE_RX)
-            clearRxBuf();
-    }
-    // Caution, any delay here may cause a FF underflow or overflow
-    if (_lastInterruptFlags[0] & RF22_ITXFFAEM)
-    {
-        // See if more data has to be loaded into the Tx FIFO 
-        sendNextFragment();
-    }
-    if (_lastInterruptFlags[0] & RF22_IRXFFAFULL)
-    {
-        // Caution, any delay here may cause a FF overflow
-        // Read some data from the Rx FIFO
-        readNextFragment(); 
-    }
-    if (_lastInterruptFlags[0] & RF22_IEXT)
-    {
-        // This is not enabled by the base code, but users may want to enable it
-        handleExternalInterrupt();
-    }
-    if (_lastInterruptFlags[1] & RF22_IWUT)
-    {
-        // This is not enabled by the base code, but users may want to enable it
-        handleWakeupTimerInterrupt();
-    }
-    if (_lastInterruptFlags[0] & RF22_IPKSENT)
-    {
-        _txGood++; 
-        // Transmission does not automatically clear the tx buffer.
-        // Could retransmit if we wanted
-        // RF22 transitions automatically to Idle
-        _mode = RF22_MODE_IDLE;
-    }
-    if (_lastInterruptFlags[0] & RF22_IPKVALID)
-    {
-        uint8_t len = spiRead(RF22_REG_4B_RECEIVED_PACKET_LENGTH);
-
-        // May have already read one or more fragments
-        // Get any remaining unread octets, based on the expected length
-        // First make sure we dont overflow the buffer in the case of a stupid length
-        // or partial bad receives
-        if (   len >  RF22_MAX_MESSAGE_LEN
-            || len < _bufLen)
-        {
-            _rxBad++;
-            _mode = RF22_MODE_IDLE;
-            clearRxBuf();
-            return; // Hmmm receiver buffer overflow. 
-        }
-
-        spiBurstRead(RF22_REG_7F_FIFO_ACCESS, _buf + _bufLen, len - _bufLen);
-        _rxGood++;
-        _bufLen = len;
-        _mode = RF22_MODE_IDLE;
-        _rxBufValid = true;
-    }
-    if (_lastInterruptFlags[0] & RF22_ICRCERROR)
-    {
-        _rxBad++;
-        clearRxBuf();
-        resetRxFifo();
-        _mode = RF22_MODE_IDLE;
-        setModeRx(); // Keep trying
-    }
-    if (_lastInterruptFlags[1] & RF22_IPREAVAL)
-    {
-        _lastRssi = spiRead(RF22_REG_26_RSSI);
-        clearRxBuf();
-    }
-}
-
-void RF22::isr(void* args)
-{
-    RF22* This = (RF22*)(args);
-    This->handleInterrupt();
-}
-
-void RF22::reset()
-{
-    spiWrite(RF22_REG_07_OPERATING_MODE1, RF22_SWRES);
-    // Wait for it to settle
-    usleep(100); // SWReset time is nominally 100usec
-}
-
-uint8_t RF22::spiRead(uint8_t reg)
-{
-    uint8_t data = 0;
-    spiBurstRead (reg, &data, 1);
-    return data;
-}
-
-void RF22::spiWrite(uint8_t reg, uint8_t val)
-{
-    spiBurstWrite (reg, &val, 1);
-}
-
-void RF22::spiBurstRead(uint8_t reg, uint8_t* dest, uint8_t len)
-{
-    uint8_t *request = new uint8_t[len + 1]();
-    uint8_t *response = new uint8_t[len + 1]();
-
-    request[0] = reg & ~RF22_SPI_WRITE_MASK;
-    memcpy (&request[1], dest, len);
-
-    mraa_gpio_write(_cs, 0x1);
-    mraa_gpio_write(_cs, 0x0);
-    usleep(100);
-    mraa_spi_transfer_buf(_spi, request, response, len + 1);
-    usleep(100);
-    mraa_gpio_write(_cs, 0x1);
-
-    memcpy (dest, &response[1], len);
-
-    delete[] request;
-    delete[] response;
-}
-
-void RF22::spiBurstWrite(uint8_t reg, const uint8_t* src, uint8_t len)
-{
-    uint8_t *request = new uint8_t[len + 1]();
-    uint8_t *response = new uint8_t[len + 1]();
-
-    request[0] = reg | RF22_SPI_WRITE_MASK;
-    memcpy (&request[1], src, len);
-
-    mraa_gpio_write(_cs, 0x1);
-    mraa_gpio_write(_cs, 0x0);
-    usleep(100);
-    mraa_spi_transfer_buf(_spi, request, response, len + 1);
-    usleep(100);
-    mraa_gpio_write(_cs, 0x1);
-
-    delete[] request;
-    delete[] response;
-}
-
-uint8_t RF22::statusRead()
-{
-    return spiRead(RF22_REG_02_DEVICE_STATUS);
-}
-
-uint8_t RF22::adcRead(uint8_t adcsel,
-                      uint8_t adcref ,
-                      uint8_t adcgain, 
-                      uint8_t adcoffs)
-{
-    uint8_t configuration = adcsel | adcref | (adcgain & RF22_ADCGAIN);
-    spiWrite(RF22_REG_0F_ADC_CONFIGURATION, configuration | RF22_ADCSTART);
-    spiWrite(RF22_REG_10_ADC_SENSOR_AMP_OFFSET, adcoffs);
-
-    // Conversion time is nominally 305usec
-    // Wait for the DONE bit
-    while (!(spiRead(RF22_REG_0F_ADC_CONFIGURATION) & RF22_ADCDONE))
-    ;
-    // Return the value  
-    return spiRead(RF22_REG_11_ADC_VALUE);
-}
-
-uint8_t RF22::temperatureRead(uint8_t tsrange, uint8_t tvoffs)
-{
-    spiWrite(RF22_REG_12_TEMPERATURE_SENSOR_CALIBRATION, tsrange | RF22_ENTSOFFS);
-    spiWrite(RF22_REG_13_TEMPERATURE_VALUE_OFFSET, tvoffs);
-    return adcRead(RF22_ADCSEL_INTERNAL_TEMPERATURE_SENSOR | RF22_ADCREF_BANDGAP_VOLTAGE); 
-}
-
-uint16_t RF22::wutRead()
-{
-    uint8_t buf[2] = {};
-    spiBurstRead(RF22_REG_17_WAKEUP_TIMER_VALUE1, buf, 2);
-    return ((uint16_t)buf[0] << 8) | buf[1]; // Dont rely on byte order
-}
-
-// RFM-22 doc appears to be wrong: WUT for wtm = 10000, r, = 0, d = 0 is about 1 sec
-void RF22::setWutPeriod(uint16_t wtm, uint8_t wtr, uint8_t wtd)
-{
-    uint8_t period[3];
-
-    period[0] = ((wtr & 0xf) << 2) | (wtd & 0x3);
-    period[1] = wtm >> 8;
-    period[2] = wtm & 0xff;
-    spiBurstWrite(RF22_REG_14_WAKEUP_TIMER_PERIOD1, period, sizeof(period));
-}
-
-// Returns true if center + (fhch * fhs) is within limits
-// Caution, different versions of the RF22 support different max freq
-// so YMMV
-uint8_t RF22::setFrequency(float center, float afcPullInRange)
-{
-    uint8_t fbsel = RF22_SBSEL;
-    uint8_t afclimiter;
-    if (center < 240.0 || center > 960.0) // 930.0 for early silicon
-    return false;
-    if (center >= 480.0)
-    {
-        if (afcPullInRange < 0.0 || afcPullInRange > 0.318750)
-            return false;
-        center /= 2;
-        fbsel |= RF22_HBSEL;
-        afclimiter = afcPullInRange * 1000000.0 / 1250.0;
-    }
-    else
-    {
-        if (afcPullInRange < 0.0 || afcPullInRange > 0.159375)
-            return false;
-        afclimiter = afcPullInRange * 1000000.0 / 625.0;
-    }
-    center /= 10.0;
-    float integerPart = floor(center);
-    float fractionalPart = center - integerPart;
-
-    uint8_t fb = (uint8_t)integerPart - 24; // Range 0 to 23
-    fbsel |= fb;
-    uint16_t fc = fractionalPart * 64000;
-    spiWrite(RF22_REG_73_FREQUENCY_OFFSET1, 0);  // REVISIT
-    spiWrite(RF22_REG_74_FREQUENCY_OFFSET2, 0);
-    spiWrite(RF22_REG_75_FREQUENCY_BAND_SELECT, fbsel);
-    spiWrite(RF22_REG_76_NOMINAL_CARRIER_FREQUENCY1, fc >> 8);
-    spiWrite(RF22_REG_77_NOMINAL_CARRIER_FREQUENCY0, fc & 0xff);
-    spiWrite(RF22_REG_2A_AFC_LIMITER, afclimiter);
-    return !(statusRead() & RF22_FREQERR);
-}
-
-// Step size in 10kHz increments
-// Returns true if centre + (fhch * fhs) is within limits
-uint8_t RF22::setFHStepSize(uint8_t fhs)
-{
-    spiWrite(RF22_REG_7A_FREQUENCY_HOPPING_STEP_SIZE, fhs);
-    return !(statusRead() & RF22_FREQERR);
-}
-
-// Adds fhch * fhs to centre frequency
-// Returns true if centre + (fhch * fhs) is within limits
-uint8_t RF22::setFHChannel(uint8_t fhch)
-{
-    spiWrite(RF22_REG_79_FREQUENCY_HOPPING_CHANNEL_SELECT, fhch);
-    return !(statusRead() & RF22_FREQERR);
-}
-
-uint8_t RF22::rssiRead()
-{
-    return spiRead(RF22_REG_26_RSSI);
-}
-
-uint8_t RF22::ezmacStatusRead()
-{
-    return spiRead(RF22_REG_31_EZMAC_STATUS);
-}
-
-void RF22::setMode(uint8_t mode)
-{
-    spiWrite(RF22_REG_07_OPERATING_MODE1, mode);
-}
-
-void RF22::setModeIdle()
-{
-    if (_mode != RF22_MODE_IDLE)
-    {
-        setMode(_idleMode);
-        _mode = RF22_MODE_IDLE;
-    }
-}
-
-void RF22::setModeRx()
-{
-    if (_mode != RF22_MODE_RX)
-    {
-        setMode(_idleMode | RF22_RXON);
-        _mode = RF22_MODE_RX;
-    }
-}
-
-void RF22::setModeTx()
-{
-    if (_mode != RF22_MODE_TX)
-    {
-        setMode(_idleMode | RF22_TXON);
-        _mode = RF22_MODE_TX;
-        // Hmmm, if you dont clear the RX FIFO here, then it appears that going
-        // to transmit mode in the middle of a receive can corrupt the
-        // RX FIFO
-        resetRxFifo();
-        clearRxBuf();
-    }
-}
-
-uint8_t  RF22::mode()
-{
-    return _mode;
-}
-
-void RF22::setTxPower(uint8_t power)
-{
-    spiWrite(RF22_REG_6D_TX_POWER, power);
-}
-
-// Sets registers from a canned modem configuration structure
-void RF22::setModemRegisters(const ModemConfig* config)
-{
-    spiWrite(RF22_REG_1C_IF_FILTER_BANDWIDTH,                    config->reg_1c);
-    spiWrite(RF22_REG_1F_CLOCK_RECOVERY_GEARSHIFT_OVERRIDE,      config->reg_1f);
-    spiBurstWrite(RF22_REG_20_CLOCK_RECOVERY_OVERSAMPLING_RATE, &config->reg_20, 6);
-    spiBurstWrite(RF22_REG_2C_OOK_COUNTER_VALUE_1,              &config->reg_2c, 3);
-    spiWrite(RF22_REG_58_CHARGE_PUMP_CURRENT_TRIMMING,           config->reg_58);
-    spiWrite(RF22_REG_69_AGC_OVERRIDE1,                          config->reg_69);
-    spiBurstWrite(RF22_REG_6E_TX_DATA_RATE1,                    &config->reg_6e, 5);
-}
-
-// Set one of the canned FSK Modem configs
-// Returns true if its a valid choice
-uint8_t RF22::setModemConfig(ModemConfigChoice index)
-{
-    if (index > (sizeof(MODEM_CONFIG_TABLE) / sizeof(ModemConfig)))
-        return false;
-
-    RF22::ModemConfig cfg;
-    // memcpy_P(&cfg, &MODEM_CONFIG_TABLE[index], sizeof(RF22::ModemConfig)); // !!!!!!!!!!!!!!!!!!! MIGHT CAUSE ISSUES
-    memcpy(&cfg, &MODEM_CONFIG_TABLE[index], sizeof(RF22::ModemConfig));
-    setModemRegisters(&cfg);
-
-    return true;
-}
-
-// REVISIT: top bit is in Header Control 2 0x33
-void RF22::setPreambleLength(uint8_t nibbles)
-{
-    spiWrite(RF22_REG_34_PREAMBLE_LENGTH, nibbles);
-}
-
-// Caution doesnt set sync word len in Header Control 2 0x33
-void RF22::setSyncWords(const uint8_t* syncWords, uint8_t len)
-{
-    spiBurstWrite(RF22_REG_36_SYNC_WORD3, syncWords, len);
-}
-
-void RF22::clearRxBuf()
-{
-    _bufLen = 0;
-    _rxBufValid = false;
-}
-
-uint8_t RF22::available()
-{
-    if (!_rxBufValid)
-    setModeRx(); // Make sure we are receiving
-    return _rxBufValid;
-}
-
-// Blocks until a valid message is received
-void RF22::waitAvailable()
-{
-    while (!available())
-    ;
-}
-
-// Blocks until a valid message is received or timeout expires
-// Return true if there is a message available
-bool RF22::waitAvailableTimeout(unsigned long timeout)
-{
-    unsigned long endtime = getTimestamp() + timeout;
-    unsigned long currenttime = getTimestamp();
-    while (currenttime < endtime) {
-        currenttime = getTimestamp();
-        if (available()) {
-            return true;
-        }
-    }
-        
-    return false;
-}
-
-void RF22::waitPacketSent()
-{
-    while (_mode == RF22_MODE_TX)
-    ; // Wait for any previous transmit to finish
-}
-
-// Diagnostic help
-void RF22::printBuffer(const char* prompt, const uint8_t* buf, uint8_t len)
-{
-}
-
-uint8_t RF22::recv(uint8_t* buf, uint8_t* len)
-{
-    if (!available())
-        return false;
-
-    if (*len > _bufLen)
-        *len = _bufLen;
-    memcpy(buf, _buf, *len);
-    clearRxBuf();
-    return true;
-}
-
-void RF22::clearTxBuf()
-{
-    _bufLen = 0;
-    _txBufSentIndex = 0;
-}
-
-void RF22::startTransmit()
-{
-    sendNextFragment(); // Actually the first fragment
-    spiWrite(RF22_REG_3E_PACKET_LENGTH, _bufLen); // Total length that will be sent
-    setModeTx(); // Start the transmitter, turns off the receiver
-}
-
-// Restart the transmission of a packet that had a problem
-void RF22::restartTransmit()
-{
-    _mode = RF22_MODE_IDLE;
-    _txBufSentIndex = 0;
-    startTransmit();
-}
-
-uint8_t RF22::send(const uint8_t* data, uint8_t len)
-{
-    waitPacketSent();
-
-    if (!fillTxBuf(data, len))
-        return false;
-    startTransmit();
-
-    return true;
-}
-
-uint8_t RF22::fillTxBuf(const uint8_t* data, uint8_t len)
-{
-    clearTxBuf();
-    if (!len)
-    return false; 
-    return appendTxBuf(data, len);
-}
-
-uint8_t RF22::appendTxBuf(const uint8_t* data, uint8_t len)
-{
-    if (((uint16_t)_bufLen + len) > RF22_MAX_MESSAGE_LEN)
-    return false;
-
-    memcpy(_buf + _bufLen, data, len);
-    _bufLen += len;
-
-    return true;
-}
-
-// Assumption: there is currently <= RF22_TXFFAEM_THRESHOLD bytes in the Tx FIFO
-void RF22::sendNextFragment()
-{
-    if (_txBufSentIndex < _bufLen)
-    {
-    // Some left to send?
-    uint8_t len = _bufLen - _txBufSentIndex;
-    // But dont send too much
-    if (len > (RF22_FIFO_SIZE - RF22_TXFFAEM_THRESHOLD - 1))
-        len = (RF22_FIFO_SIZE - RF22_TXFFAEM_THRESHOLD - 1);
-    spiBurstWrite(RF22_REG_7F_FIFO_ACCESS, _buf + _txBufSentIndex, len);
-    _txBufSentIndex += len;
-    }
-}
-
-// Assumption: there are at least RF22_RXFFAFULL_THRESHOLD in the RX FIFO
-// That means it should only be called after a RXFFAFULL interrupt
-void RF22::readNextFragment()
-{
-    if (((uint16_t)_bufLen + RF22_RXFFAFULL_THRESHOLD) > RF22_MAX_MESSAGE_LEN)
-    return; // Hmmm receiver overflow. Should never occur
-
-    // Read the RF22_RXFFAFULL_THRESHOLD octets that should be there
-    spiBurstRead(RF22_REG_7F_FIFO_ACCESS, _buf + _bufLen, RF22_RXFFAFULL_THRESHOLD);
-    _bufLen += RF22_RXFFAFULL_THRESHOLD;
-}
-
-// Clear the FIFOs
-void RF22::resetFifos()
-{
-    spiWrite(RF22_REG_08_OPERATING_MODE2, RF22_FFCLRRX | RF22_FFCLRTX);
-    spiWrite(RF22_REG_08_OPERATING_MODE2, 0);
-}
-
-// Clear the Rx FIFO
-void RF22::resetRxFifo()
-{
-    spiWrite(RF22_REG_08_OPERATING_MODE2, RF22_FFCLRRX);
-    spiWrite(RF22_REG_08_OPERATING_MODE2, 0);
-}
-
-// CLear the TX FIFO
-void RF22::resetTxFifo()
-{
-    spiWrite(RF22_REG_08_OPERATING_MODE2, RF22_FFCLRTX);
-    spiWrite(RF22_REG_08_OPERATING_MODE2, 0);
-}
-
-// Default implmentation does nothing. Override if you wish
-void RF22::handleExternalInterrupt()
-{
-}
-
-// Default implmentation does nothing. Override if you wish
-void RF22::handleWakeupTimerInterrupt()
-{
-}
-
-void RF22::setHeaderTo(uint8_t to)
-{
-    spiWrite(RF22_REG_3A_TRANSMIT_HEADER3, to);
-}
-
-void RF22::setHeaderFrom(uint8_t from)
-{
-    spiWrite(RF22_REG_3B_TRANSMIT_HEADER2, from);
-}
-
-void RF22::setHeaderId(uint8_t id)
-{
-    spiWrite(RF22_REG_3C_TRANSMIT_HEADER1, id);
-}
-
-void RF22::setHeaderFlags(uint8_t flags)
-{
-    spiWrite(RF22_REG_3D_TRANSMIT_HEADER0, flags);
-}
-
-uint8_t RF22::headerTo()
-{
-    return spiRead(RF22_REG_47_RECEIVED_HEADER3);
-}
-
-uint8_t RF22::headerFrom()
-{
-    return spiRead(RF22_REG_48_RECEIVED_HEADER2);
-}
-
-uint8_t RF22::headerId()
-{
-    return spiRead(RF22_REG_49_RECEIVED_HEADER1);
-}
-
-uint8_t RF22::headerFlags()
-{
-    return spiRead(RF22_REG_4A_RECEIVED_HEADER0);
-}
-
-uint8_t RF22::lastRssi()
-{
-    return _lastRssi;
-}
-
-void RF22::setPromiscuous(uint8_t promiscuous)
-{
-    spiWrite(RF22_REG_43_HEADER_ENABLE3, promiscuous ? 0x00 : 0xff);
-}
-
-uint64_t 
-RF22::getTimestamp () {
-    struct timeval tv;
-    gettimeofday(&tv, NULL);
-    return (uint64_t)(1000000 * tv.tv_sec + tv.tv_usec);
-}
diff --git a/src/rf22/rf22.hpp b/src/rf22/rf22.hpp
deleted file mode 100644
index 2e7a0f9..0000000
--- a/src/rf22/rf22.hpp
+++ /dev/null
@@ -1,987 +0,0 @@
-/*
- * Author: Kiveisha Yevgeniy
- * Copyright (c) 2015-2016 Intel Corporation
- *
- * Author: Mike McCauley
- * Copyright (c) 2011 Mike McCauley
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <stdint.h>
-#include <mraa.h>
-
-// This is the bit in the SPI address that marks it as a write
-#define RF22_SPI_WRITE_MASK 0x80
-
-// This is the maximum message length that can be supported by this library. Limited by
-// the single message length octet in the header. 
-// Yes, 255 is correct even though the FIFO size in the RF22 is only
-// 64 octets. We use interrupts to refill the Tx FIFO during transmission and to empty the
-// Rx FIFO during reception
-// Can be pre-defined to a smaller size (to save SRAM) prior to including this header
-#ifndef RF22_MAX_MESSAGE_LEN
-//#define RF22_MAX_MESSAGE_LEN 255
-#define RF22_MAX_MESSAGE_LEN 64
-#endif
-
-// Max number of octets the RF22 Rx and Tx FIFOs can hold
-#define RF22_FIFO_SIZE 64
-
-// Keep track of the mode the RF22 is in
-#define RF22_MODE_IDLE         0
-#define RF22_MODE_RX           1
-#define RF22_MODE_TX           2
-
-// These values we set for FIFO thresholds are actually the same as the POR values
-#define RF22_TXFFAEM_THRESHOLD 4
-#define RF22_RXFFAFULL_THRESHOLD 55
-
-// This is the default node address,
-#define RF22_DEFAULT_NODE_ADDRESS 0
-
-// This address in the TO address signifies a broadcast
-#define RF22_BROADCAST_ADDRESS 0xff
-
-// Number of registers to be passed to setModemConfig()
-#define RF22_NUM_MODEM_CONFIG_REGS 18
-
-// Register names
-#define RF22_REG_00_DEVICE_TYPE                         0x00
-#define RF22_REG_01_VERSION_CODE                        0x01
-#define RF22_REG_02_DEVICE_STATUS                       0x02
-#define RF22_REG_03_INTERRUPT_STATUS1                   0x03
-#define RF22_REG_04_INTERRUPT_STATUS2                   0x04
-#define RF22_REG_05_INTERRUPT_ENABLE1                   0x05
-#define RF22_REG_06_INTERRUPT_ENABLE2                   0x06
-#define RF22_REG_07_OPERATING_MODE1                     0x07
-#define RF22_REG_08_OPERATING_MODE2                     0x08
-#define RF22_REG_09_OSCILLATOR_LOAD_CAPACITANCE         0x09
-#define RF22_REG_0A_UC_OUTPUT_CLOCK                     0x0a
-#define RF22_REG_0B_GPIO_CONFIGURATION0                 0x0b
-#define RF22_REG_0C_GPIO_CONFIGURATION1                 0x0c
-#define RF22_REG_0D_GPIO_CONFIGURATION2                 0x0d
-#define RF22_REG_0E_IO_PORT_CONFIGURATION               0x0e
-#define RF22_REG_0F_ADC_CONFIGURATION                   0x0f
-#define RF22_REG_10_ADC_SENSOR_AMP_OFFSET               0x10
-#define RF22_REG_11_ADC_VALUE                           0x11
-#define RF22_REG_12_TEMPERATURE_SENSOR_CALIBRATION      0x12
-#define RF22_REG_13_TEMPERATURE_VALUE_OFFSET            0x13
-#define RF22_REG_14_WAKEUP_TIMER_PERIOD1                0x14
-#define RF22_REG_15_WAKEUP_TIMER_PERIOD2                0x15
-#define RF22_REG_16_WAKEUP_TIMER_PERIOD3                0x16
-#define RF22_REG_17_WAKEUP_TIMER_VALUE1                 0x17
-#define RF22_REG_18_WAKEUP_TIMER_VALUE2                 0x18
-#define RF22_REG_19_LDC_MODE_DURATION                   0x19
-#define RF22_REG_1A_LOW_BATTERY_DETECTOR_THRESHOLD      0x1a
-#define RF22_REG_1B_BATTERY_VOLTAGE_LEVEL               0x1b
-#define RF22_REG_1C_IF_FILTER_BANDWIDTH                 0x1c
-#define RF22_REG_1D_AFC_LOOP_GEARSHIFT_OVERRIDE         0x1d
-#define RF22_REG_1E_AFC_TIMING_CONTROL                  0x1e
-#define RF22_REG_1F_CLOCK_RECOVERY_GEARSHIFT_OVERRIDE   0x1f
-#define RF22_REG_20_CLOCK_RECOVERY_OVERSAMPLING_RATE    0x20
-#define RF22_REG_21_CLOCK_RECOVERY_OFFSET2              0x21
-#define RF22_REG_22_CLOCK_RECOVERY_OFFSET1              0x22
-#define RF22_REG_23_CLOCK_RECOVERY_OFFSET0              0x23
-#define RF22_REG_24_CLOCK_RECOVERY_TIMING_LOOP_GAIN1    0x24
-#define RF22_REG_25_CLOCK_RECOVERY_TIMING_LOOP_GAIN0    0x25
-#define RF22_REG_26_RSSI                                0x26
-#define RF22_REG_27_RSSI_THRESHOLD                      0x27
-#define RF22_REG_28_ANTENNA_DIVERSITY1                  0x28
-#define RF22_REG_29_ANTENNA_DIVERSITY2                  0x29
-#define RF22_REG_2A_AFC_LIMITER                         0x2a
-#define RF22_REG_2B_AFC_CORRECTION_READ                 0x2b
-#define RF22_REG_2C_OOK_COUNTER_VALUE_1                 0x2c
-#define RF22_REG_2D_OOK_COUNTER_VALUE_2                 0x2d
-#define RF22_REG_2E_SLICER_PEAK_HOLD                    0x2e
-#define RF22_REG_30_DATA_ACCESS_CONTROL                 0x30
-#define RF22_REG_31_EZMAC_STATUS                        0x31
-#define RF22_REG_32_HEADER_CONTROL1                     0x32
-#define RF22_REG_33_HEADER_CONTROL2                     0x33
-#define RF22_REG_34_PREAMBLE_LENGTH                     0x34
-#define RF22_REG_35_PREAMBLE_DETECTION_CONTROL1         0x35
-#define RF22_REG_36_SYNC_WORD3                          0x36
-#define RF22_REG_37_SYNC_WORD2                          0x37
-#define RF22_REG_38_SYNC_WORD1                          0x38
-#define RF22_REG_39_SYNC_WORD0                          0x39
-#define RF22_REG_3A_TRANSMIT_HEADER3                    0x3a
-#define RF22_REG_3B_TRANSMIT_HEADER2                    0x3b
-#define RF22_REG_3C_TRANSMIT_HEADER1                    0x3c
-#define RF22_REG_3D_TRANSMIT_HEADER0                    0x3d
-#define RF22_REG_3E_PACKET_LENGTH                       0x3e
-#define RF22_REG_3F_CHECK_HEADER3                       0x3f
-#define RF22_REG_40_CHECK_HEADER2                       0x40
-#define RF22_REG_41_CHECK_HEADER1                       0x41
-#define RF22_REG_42_CHECK_HEADER0                       0x42
-#define RF22_REG_43_HEADER_ENABLE3                      0x43
-#define RF22_REG_44_HEADER_ENABLE2                      0x44
-#define RF22_REG_45_HEADER_ENABLE1                      0x45
-#define RF22_REG_46_HEADER_ENABLE0                      0x46
-#define RF22_REG_47_RECEIVED_HEADER3                    0x47
-#define RF22_REG_48_RECEIVED_HEADER2                    0x48
-#define RF22_REG_49_RECEIVED_HEADER1                    0x49
-#define RF22_REG_4A_RECEIVED_HEADER0                    0x4a
-#define RF22_REG_4B_RECEIVED_PACKET_LENGTH              0x4b
-#define RF22_REG_50_ANALOG_TEST_BUS_SELECT              0x50
-#define RF22_REG_51_DIGITAL_TEST_BUS_SELECT             0x51
-#define RF22_REG_52_TX_RAMP_CONTROL                     0x52
-#define RF22_REG_53_PLL_TUNE_TIME                       0x53
-#define RF22_REG_55_CALIBRATION_CONTROL                 0x55
-#define RF22_REG_56_MODEM_TEST                          0x56
-#define RF22_REG_57_CHARGE_PUMP_TEST                    0x57
-#define RF22_REG_58_CHARGE_PUMP_CURRENT_TRIMMING        0x58
-#define RF22_REG_59_DIVIDER_CURRENT_TRIMMING            0x59
-#define RF22_REG_5A_VCO_CURRENT_TRIMMING                0x5a
-#define RF22_REG_5B_VCO_CALIBRATION                     0x5b
-#define RF22_REG_5C_SYNTHESIZER_TEST                    0x5c
-#define RF22_REG_5D_BLOCK_ENABLE_OVERRIDE1              0x5d
-#define RF22_REG_5E_BLOCK_ENABLE_OVERRIDE2              0x5e
-#define RF22_REG_5F_BLOCK_ENABLE_OVERRIDE3              0x5f
-#define RF22_REG_60_CHANNEL_FILTER_COEFFICIENT_ADDRESS  0x60
-#define RF22_REG_61_CHANNEL_FILTER_COEFFICIENT_VALUE    0x61
-#define RF22_REG_62_CRYSTAL_OSCILLATOR_POR_CONTROL      0x62
-#define RF22_REG_63_RC_OSCILLATOR_COARSE_CALIBRATION    0x63
-#define RF22_REG_64_RC_OSCILLATOR_FINE_CALIBRATION      0x64
-#define RF22_REG_65_LDO_CONTROL_OVERRIDE                0x65
-#define RF22_REG_66_LDO_LEVEL_SETTINGS                  0x66
-#define RF22_REG_67_DELTA_SIGMA_ADC_TUNING1             0x67
-#define RF22_REG_68_DELTA_SIGMA_ADC_TUNING2             0x68
-#define RF22_REG_69_AGC_OVERRIDE1                       0x69
-#define RF22_REG_6A_AGC_OVERRIDE2                       0x6a
-#define RF22_REG_6B_GFSK_FIR_FILTER_COEFFICIENT_ADDRESS 0x6b
-#define RF22_REG_6C_GFSK_FIR_FILTER_COEFFICIENT_VALUE   0x6c
-#define RF22_REG_6D_TX_POWER                            0x6d
-#define RF22_REG_6E_TX_DATA_RATE1                       0x6e
-#define RF22_REG_6F_TX_DATA_RATE0                       0x6f
-#define RF22_REG_70_MODULATION_CONTROL1                 0x70
-#define RF22_REG_71_MODULATION_CONTROL2                 0x71
-#define RF22_REG_72_FREQUENCY_DEVIATION                 0x72
-#define RF22_REG_73_FREQUENCY_OFFSET1                   0x73
-#define RF22_REG_74_FREQUENCY_OFFSET2                   0x74
-#define RF22_REG_75_FREQUENCY_BAND_SELECT               0x75
-#define RF22_REG_76_NOMINAL_CARRIER_FREQUENCY1          0x76
-#define RF22_REG_77_NOMINAL_CARRIER_FREQUENCY0          0x77
-#define RF22_REG_79_FREQUENCY_HOPPING_CHANNEL_SELECT    0x79
-#define RF22_REG_7A_FREQUENCY_HOPPING_STEP_SIZE         0x7a
-#define RF22_REG_7C_TX_FIFO_CONTROL1                    0x7c
-#define RF22_REG_7D_TX_FIFO_CONTROL2                    0x7d
-#define RF22_REG_7E_RX_FIFO_CONTROL                     0x7e
-#define RF22_REG_7F_FIFO_ACCESS                         0x7f
-
-// These register masks etc are named wherever possible
-// corresponding to the bit and field names in the RF-22 Manual
-// RF22_REG_00_DEVICE_TYPE                      0x00
-#define RF22_DEVICE_TYPE_RX_TRX                 0x08
-#define RF22_DEVICE_TYPE_TX                     0x07
-
-// RF22_REG_02_DEVICE_STATUS                    0x02
-#define RF22_FFOVL                              0x80
-#define RF22_FFUNFL                             0x40
-#define RF22_RXFFEM                             0x20
-#define RF22_HEADERR                            0x10
-#define RF22_FREQERR                            0x08
-#define RF22_LOCKDET                            0x04
-#define RF22_CPS                                0x03
-#define RF22_CPS_IDLE                           0x00
-#define RF22_CPS_RX                             0x01
-#define RF22_CPS_TX                             0x10
-
-// RF22_REG_03_INTERRUPT_STATUS1                0x03
-#define RF22_IFFERROR                           0x80
-#define RF22_ITXFFAFULL                         0x40
-#define RF22_ITXFFAEM                           0x20
-#define RF22_IRXFFAFULL                         0x10
-#define RF22_IEXT                               0x08
-#define RF22_IPKSENT                            0x04
-#define RF22_IPKVALID                           0x02
-#define RF22_ICRCERROR                          0x01
-
-// RF22_REG_04_INTERRUPT_STATUS2                0x04
-#define RF22_ISWDET                             0x80
-#define RF22_IPREAVAL                           0x40
-#define RF22_IPREAINVAL                         0x20
-#define RF22_IRSSI                              0x10
-#define RF22_IWUT                               0x08
-#define RF22_ILBD                               0x04
-#define RF22_ICHIPRDY                           0x02
-#define RF22_IPOR                               0x01
-
-// RF22_REG_05_INTERRUPT_ENABLE1                0x05
-#define RF22_ENFFERR                            0x80
-#define RF22_ENTXFFAFULL                        0x40
-#define RF22_ENTXFFAEM                          0x20
-#define RF22_ENRXFFAFULL                        0x10
-#define RF22_ENEXT                              0x08
-#define RF22_ENPKSENT                           0x04
-#define RF22_ENPKVALID                          0x02
-#define RF22_ENCRCERROR                         0x01
-
-// RF22_REG_06_INTERRUPT_ENABLE2                0x06
-#define RF22_ENSWDET                            0x80
-#define RF22_ENPREAVAL                          0x40
-#define RF22_ENPREAINVAL                        0x20
-#define RF22_ENRSSI                             0x10
-#define RF22_ENWUT                              0x08
-#define RF22_ENLBDI                             0x04
-#define RF22_ENCHIPRDY                          0x02
-#define RF22_ENPOR                              0x01
-
-// RF22_REG_07_OPERATING_MODE                   0x07
-#define RF22_SWRES                              0x80
-#define RF22_ENLBD                              0x40
-#define RF22_ENWT                               0x20
-#define RF22_X32KSEL                            0x10
-#define RF22_TXON                               0x08
-#define RF22_RXON                               0x04
-#define RF22_PLLON                              0x02
-#define RF22_XTON                               0x01
-
-// RF22_REG_08_OPERATING_MODE2                  0x08
-#define RF22_ANTDIV                             0xc0
-#define RF22_RXMPK                              0x10
-#define RF22_AUTOTX                             0x08
-#define RF22_ENLDM                              0x04
-#define RF22_FFCLRRX                            0x02
-#define RF22_FFCLRTX                            0x01
-
-// RF22_REG_0F_ADC_CONFIGURATION                0x0f
-#define RF22_ADCSTART                           0x80
-#define RF22_ADCDONE                            0x80
-#define RF22_ADCSEL                             0x70
-#define RF22_ADCSEL_INTERNAL_TEMPERATURE_SENSOR 0x00
-#define RF22_ADCSEL_GPIO0_SINGLE_ENDED          0x10
-#define RF22_ADCSEL_GPIO1_SINGLE_ENDED          0x20
-#define RF22_ADCSEL_GPIO2_SINGLE_ENDED          0x30
-#define RF22_ADCSEL_GPIO0_GPIO1_DIFFERENTIAL    0x40
-#define RF22_ADCSEL_GPIO1_GPIO2_DIFFERENTIAL    0x50
-#define RF22_ADCSEL_GPIO0_GPIO2_DIFFERENTIAL    0x60
-#define RF22_ADCSEL_GND                         0x70
-#define RF22_ADCREF                             0x0c
-#define RF22_ADCREF_BANDGAP_VOLTAGE             0x00
-#define RF22_ADCREF_VDD_ON_3                    0x08
-#define RF22_ADCREF_VDD_ON_2                    0x0c
-#define RF22_ADCGAIN                            0x03
-
-// RF22_REG_10_ADC_SENSOR_AMP_OFFSET            0x10
-#define RF22_ADCOFFS                            0x0f
-
-// RF22_REG_12_TEMPERATURE_SENSOR_CALIBRATION   0x12
-#define RF22_TSRANGE                            0xc0
-#define RF22_TSRANGE_M64_64C                    0x00
-#define RF22_TSRANGE_M64_192C                   0x40
-#define RF22_TSRANGE_0_128C                     0x80
-#define RF22_TSRANGE_M40_216F                   0xc0
-#define RF22_ENTSOFFS                           0x20
-#define RF22_ENTSTRIM                           0x10
-#define RF22_TSTRIM                             0x0f
-
-// RF22_REG_14_WAKEUP_TIMER_PERIOD1             0x14
-#define RF22_WTR                                0x3c
-#define RF22_WTD                                0x03
-
-// RF22_REG_1D_AFC_LOOP_GEARSHIFT_OVERRIDE      0x1d
-#define RF22_AFBCD                              0x80
-#define RF22_ENAFC                              0x40
-#define RF22_AFCGEARH                           0x38
-#define RF22_AFCGEARL                           0x07
-
-// RF22_REG_1E_AFC_TIMING_CONTROL               0x1e
-#define RF22_SWAIT_TIMER                        0xc0
-#define RF22_SHWAIT                             0x38
-#define RF22_ANWAIT                             0x07
-
-// RF22_REG_30_DATA_ACCESS_CONTROL              0x30
-#define RF22_ENPACRX                            0x80
-#define RF22_MSBFRST                            0x00
-#define RF22_LSBFRST                            0x40
-#define RF22_CRCHDRS                            0x00
-#define RF22_CRCDONLY                           0x20
-#define RF22_ENPACTX                            0x08
-#define RF22_ENCRC                              0x04
-#define RF22_CRC                                0x03
-#define RF22_CRC_CCITT                          0x00
-#define RF22_CRC_CRC_16_IBM                     0x01
-#define RF22_CRC_IEC_16                         0x02
-#define RF22_CRC_BIACHEVA                       0x03
-
-// RF22_REG_32_HEADER_CONTROL1                  0x32
-#define RF22_BCEN                               0xf0
-#define RF22_BCEN_NONE                          0x00
-#define RF22_BCEN_HEADER0                       0x10
-#define RF22_BCEN_HEADER1                       0x20
-#define RF22_BCEN_HEADER2                       0x40
-#define RF22_BCEN_HEADER3                       0x80
-#define RF22_HDCH                               0x0f
-#define RF22_HDCH_NONE                          0x00
-#define RF22_HDCH_HEADER0                       0x01
-#define RF22_HDCH_HEADER1                       0x02
-#define RF22_HDCH_HEADER2                       0x04
-#define RF22_HDCH_HEADER3                       0x08
-
-// RF22_REG_33_HEADER_CONTROL2                  0x33
-#define RF22_HDLEN                              0x70
-#define RF22_HDLEN_0                            0x00
-#define RF22_HDLEN_1                            0x10
-#define RF22_HDLEN_2                            0x20
-#define RF22_HDLEN_3                            0x30
-#define RF22_HDLEN_4                            0x40
-#define RF22_VARPKLEN                           0x00
-#define RF22_FIXPKLEN                           0x08
-#define RF22_SYNCLEN                            0x06
-#define RF22_SYNCLEN_1                          0x00
-#define RF22_SYNCLEN_2                          0x02
-#define RF22_SYNCLEN_3                          0x04
-#define RF22_SYNCLEN_4                          0x06
-#define RF22_PREALEN8                           0x01
-
-// RF22_REG_6D_TX_POWER                         0x6d
-#define RF22_TXPOW                              0x07
-#define RF22_TXPOW_4X31                         0x08 // Not used in RFM22B
-#define RF22_TXPOW_1DBM                         0x00
-#define RF22_TXPOW_2DBM                         0x01
-#define RF22_TXPOW_5DBM                         0x02
-#define RF22_TXPOW_8DBM                         0x03
-#define RF22_TXPOW_11DBM                        0x04
-#define RF22_TXPOW_14DBM                        0x05
-#define RF22_TXPOW_17DBM                        0x06
-#define RF22_TXPOW_20DBM                        0x07
-// IN RFM23B
-#define RF22_TXPOW_LNA_SW                       0x08
-
-// RF22_REG_71_MODULATION_CONTROL2              0x71
-#define RF22_TRCLK                              0xc0
-#define RF22_TRCLK_NONE                         0x00
-#define RF22_TRCLK_GPIO                         0x40
-#define RF22_TRCLK_SDO                          0x80
-#define RF22_TRCLK_NIRQ                         0xc0
-#define RF22_DTMOD                              0x30
-#define RF22_DTMOD_DIRECT_GPIO                  0x00
-#define RF22_DTMOD_DIRECT_SDI                   0x10
-#define RF22_DTMOD_FIFO                         0x20
-#define RF22_DTMOD_PN9                          0x30
-#define RF22_ENINV                              0x08
-#define RF22_FD8                                0x04
-#define RF22_MODTYP                             0x30
-#define RF22_MODTYP_UNMODULATED                 0x00
-#define RF22_MODTYP_OOK                         0x01
-#define RF22_MODTYP_FSK                         0x02
-#define RF22_MODTYP_GFSK                        0x03
-
-// RF22_REG_75_FREQUENCY_BAND_SELECT            0x75
-#define RF22_SBSEL                              0x40
-#define RF22_HBSEL                              0x20
-#define RF22_FB                                 0x1f
-
-// Define this to include Serial printing in diagnostic routines
-#define RF22_HAVE_SERIAL
-
-namespace upm {
-
-/**
- * @brief RF22 Wireless Transceiver
- * @defgroup rf22 libupm-rf22
- * @ingroup sparkfun spi wifi
- */
-/**
- * @library rf22
- * @sensor rf22
- * @comname ISM Band Radio Transceiver
- * @altname RFM22B
- * @type wifi
- * @man sparkfun
- * @web https://www.sparkfun.com/products/12030
- * @con spi
- *
- * @brief API for the RF22 Transceiver Module
- *
- * This base class provides basic functions for sending and receiving unaddressable,
- * unreliable datagrams of arbitrary length to 255 octets per packet.
- *
- * Subclasses may use this class to implement reliable, addressed datagrams and streams, 
- * mesh routers, repeaters, translators etc.
- *
- * On transmission, the TO and FROM addresses default to 0x00, unless changed by a subclass. 
- * On reception the TO addressed is checked against the node address (defaults to 0x00) or the
- * broadcast address (which is 0xff). The ID and FLAGS are set to 0, and not checked by this class.
- * This permits use of the this base RF22 class as an unaddressable, unreliable datagram service.
- * Subclasses are expected to change this behavior to add node address, ids, retransmission etc.
- *
- * Naturally, for any 2 radios to communicate that must be configured to use the same frequency and 
- * modulation scheme.
- *
- * @image html rf22.jpg
- * <br><em>RF22 Sensor image provided by SparkFun* under
- * <a href=https://creativecommons.org/licenses/by/2.0/>
- * CC BY 2.0</a>.</em>
- *
- * @snippet rf22-server.cxx Interesting
- * @snippet rf22-client.cxx Interesting
- */
-class RF22
-{
-public:
-
-    /**
-     * @brief Defines register values for a set of modem configuration registers
-     *
-     * Defines register values for a set of modem configuration registers
-     * that can be passed to setModemConfig()
-     * if none of the choices in ModemConfigChoice suit your need
-     * setModemConfig() writes the register values to the appropriate RF22 registers
-     * to set the desired modulation type, data rate and deviation/bandwidth.
-     * Suitable values for these registers can be computed using the register calculator at
-     * http://www.hoperf.com/upload/rf/RF22B%2023B%2031B%2042B%2043B%20Register%20Settings_RevB1-v5.xls
-     */
-    typedef struct
-    {
-    uint8_t    reg_1c;   ///< Value for register RF22_REG_1C_IF_FILTER_BANDWIDTH
-    uint8_t    reg_1f;   ///< Value for register RF22_REG_1F_CLOCK_RECOVERY_GEARSHIFT_OVERRIDE
-    uint8_t    reg_20;   ///< Value for register RF22_REG_20_CLOCK_RECOVERY_OVERSAMPLING_RATE
-    uint8_t    reg_21;   ///< Value for register RF22_REG_21_CLOCK_RECOVERY_OFFSET2 
-    uint8_t    reg_22;   ///< Value for register RF22_REG_22_CLOCK_RECOVERY_OFFSET1 
-    uint8_t    reg_23;   ///< Value for register RF22_REG_23_CLOCK_RECOVERY_OFFSET0
-    uint8_t    reg_24;   ///< Value for register RF22_REG_24_CLOCK_RECOVERY_TIMING_LOOP_GAIN1
-    uint8_t    reg_25;   ///< Value for register RF22_REG_25_CLOCK_RECOVERY_TIMING_LOOP_GAIN0 
-    uint8_t    reg_2c;   ///< Value for register RF22_REG_2C_OOK_COUNTER_VALUE_1 
-    uint8_t    reg_2d;   ///< Value for register RF22_REG_2D_OOK_COUNTER_VALUE_2
-    uint8_t    reg_2e;   ///< Value for register RF22_REG_2E_SLICER_PEAK_HOLD 
-    uint8_t    reg_58;   ///< Value for register RF22_REG_58_CHARGE_PUMP_CURRENT_TRIMMING
-    uint8_t    reg_69;   ///< Value for register RF22_REG_69_AGC_OVERRIDE1 
-    uint8_t    reg_6e;   ///< Value for register RF22_REG_6E_TX_DATA_RATE1
-    uint8_t    reg_6f;   ///< Value for register RF22_REG_6F_TX_DATA_RATE0 
-    uint8_t    reg_70;   ///< Value for register RF22_REG_70_MODULATION_CONTROL1
-    uint8_t    reg_71;   ///< Value for register RF22_REG_71_MODULATION_CONTROL2
-    uint8_t    reg_72;   ///< Value for register RF22_REG_72_FREQUENCY_DEVIATION
-    } ModemConfig;
-
-    /**
-     * Choices for setModemConfig() for a selected subset of common modulation types,
-     * and data rates. If you need another configuration, use the register calculator.
-     * and call setModemRegisters() with your desired settings
-     * These are indexes into _modemConfig
-     */
-    typedef enum
-    {
-    UnmodulatedCarrier = 0, ///< Unmodulated carrier for testing
-    FSK_PN9_Rb2Fd5,      ///< FSK, No Manchester, Rb = 2kbs, Fd = 5kHz, PN9 random modulation for testing
-
-    FSK_Rb2Fd5,      ///< FSK, No Manchester, Rb = 2kbs,    Fd = 5kHz
-    FSK_Rb2_4Fd36,       ///< FSK, No Manchester, Rb = 2.4kbs,  Fd = 36kHz
-    FSK_Rb4_8Fd45,       ///< FSK, No Manchester, Rb = 4.8kbs,  Fd = 45kHz
-    FSK_Rb9_6Fd45,       ///< FSK, No Manchester, Rb = 9.6kbs,  Fd = 45kHz
-    FSK_Rb19_2Fd9_6,     ///< FSK, No Manchester, Rb = 19.2kbs, Fd = 9.6kHz
-    FSK_Rb38_4Fd19_6,    ///< FSK, No Manchester, Rb = 38.4kbs, Fd = 19.6kHz
-    FSK_Rb57_6Fd28_8,    ///< FSK, No Manchester, Rb = 57.6kbs, Fd = 28.8kHz
-    FSK_Rb125Fd125,      ///< FSK, No Manchester, Rb = 125kbs,  Fd = 125kHz
-
-    GFSK_Rb2Fd5,         ///< GFSK, No Manchester, Rb = 2kbs,    Fd = 5kHz
-    GFSK_Rb2_4Fd36,      ///< GFSK, No Manchester, Rb = 2.4kbs,  Fd = 36kHz
-    GFSK_Rb4_8Fd45,      ///< GFSK, No Manchester, Rb = 4.8kbs,  Fd = 45kHz
-    GFSK_Rb9_6Fd45,      ///< GFSK, No Manchester, Rb = 9.6kbs,  Fd = 45kHz
-    GFSK_Rb19_2Fd9_6,    ///< GFSK, No Manchester, Rb = 19.2kbs, Fd = 9.6kHz
-    GFSK_Rb38_4Fd19_6,   ///< GFSK, No Manchester, Rb = 38.4kbs, Fd = 19.6kHz
-    GFSK_Rb57_6Fd28_8,   ///< GFSK, No Manchester, Rb = 57.6kbs, Fd = 28.8kHz
-    GFSK_Rb125Fd125,     ///< GFSK, No Manchester, Rb = 125kbs,  Fd = 125kHz
-
-    OOK_Rb1_2Bw75,       ///< OOK, No Manchester, Rb = 1.2kbs,  Rx Bandwidth = 75kHz
-    OOK_Rb2_4Bw335,      ///< OOK, No Manchester, Rb = 2.4kbs,  Rx Bandwidth = 335kHz
-    OOK_Rb4_8Bw335,      ///< OOK, No Manchester, Rb = 4.8kbs,  Rx Bandwidth = 335kHz
-    OOK_Rb9_6Bw335,      ///< OOK, No Manchester, Rb = 9.6kbs,  Rx Bandwidth = 335kHz
-    OOK_Rb19_2Bw335,     ///< OOK, No Manchester, Rb = 19.2kbs, Rx Bandwidth = 335kHz
-    OOK_Rb38_4Bw335,     ///< OOK, No Manchester, Rb = 38.4kbs, Rx Bandwidth = 335kHz
-    OOK_Rb40Bw335        ///< OOK, No Manchester, Rb = 40kbs,   Rx Bandwidth = 335kHz
-    } ModemConfigChoice;
-
-    /**
-     * Constructor. You can have multiple instances, but each instance must have its own
-     * interrupt and slave select pin. After constructing, you must call init() to initialize the interface
-     * and the radio module
-     * @param[in] spiBus Pointer to the SPI interface object to use. Default 0 or the standard Arduino hardware
-     * SPI interface
-     * @param[in] slaveSelectPin the Arduino pin number of the output to use to select the RF22 before
-     * accessing it. Default is 10 or the normal SS pin for Arduino
-     * @param[in] interruptPin The interrupt pin number to use. Default is 2
-     */
-    RF22(int spiBus = 0, int slaveSelectPin = 10, int interruptPin = 2);
-
-    /**
-     * Destructor.
-     */
-     virtual ~RF22();
-
-    /**
-     * Initializes this instance and the radio module connected to it.
-     * The following steps are taken:
-     * - Software reset the RF22 module
-     * - Checks the connected RF22 module is either a RF22_DEVICE_TYPE_RX_TRX or a RF22_DEVICE_TYPE_TX
-     * - Configures the RF22 module
-     * - Sets the frequency to 434.0 MHz
-     * - Sets the modem data rate to FSK_Rb2_4Fd36
-     * @return  true if everything was successful
-     */
-    uint8_t        init();
-
-    /**
-     * Issues a software reset to the 
-     * RF22 module. Blocks for 1ms to ensure the reset is complete.
-     */
-    void           reset();
-
-    /**
-     * Reads a single register from the RF22
-     * @param[in] reg Register number, one of RF22_REG_*
-     * @return The value of the register
-     */
-    uint8_t        spiRead(uint8_t reg);
-
-    /**
-     * Writes a single byte to the RF22
-     * @param[in] reg Register number, one of RF22_REG_*
-     * @param[in] val The value to write
-     */
-    void           spiWrite(uint8_t reg, uint8_t val);
-
-    /**
-     * Reads a number of consecutive registers from the RF22 using burst read mode
-     * @param[in] reg Register number of the first register, one of RF22_REG_*
-     * @param[in] dest Array to write the register values to. Must be at least len bytes
-     * @param[in] len Number of bytes to read
-     */
-    void           spiBurstRead(uint8_t reg, uint8_t* dest, uint8_t len);
-
-    /**
-     * Write a number of consecutive registers using burst write mode
-     * @param[in] reg Register number of the first register, one of RF22_REG_*
-     * @param[in] src Array of new register values to write. Must be at least len bytes
-     * @param[in] len Number of bytes to write
-     */
-    void           spiBurstWrite(uint8_t reg, const uint8_t* src, uint8_t len);
-
-    /**
-     * Reads and returns the device status register RF22_REG_02_DEVICE_STATUS
-     * @return The value of the device status register
-     */
-    uint8_t        statusRead();
-
-    /**
-     * Reads a value from the on-chip analog-digital converter
-     * @param[in] adcsel Selects the ADC input to measure. One of RF22_ADCSEL_*. Defaults to the 
-     * internal temperature sensor
-     * @param[in] adcref Specifies the reference voltage to use. One of RF22_ADCREF_*. 
-     * Defaults to the internal bandgap voltage.
-     * @param[in] adcgain Amplifier gain selection. 
-     * @param[in] adcoffs Amplifier offset (0 to 15).
-     * @return The analog value. 0 to 255.
-     */
-    uint8_t        adcRead(uint8_t adcsel = RF22_ADCSEL_INTERNAL_TEMPERATURE_SENSOR,
-               uint8_t adcref = RF22_ADCREF_BANDGAP_VOLTAGE,
-               uint8_t adcgain = 0, 
-               uint8_t adcoffs = 0);
-
-    /**
-     * Reads the on-chip temperature sensor
-     * @param[in] tsrange Specifies the temperature range to use. One of RF22_TSRANGE_*
-     * @param[in] tvoffs Specifies the temperature value offset. This is actually signed value 
-     * added to the measured temperature value
-     * @return The measured temperature.
-     */
-    uint8_t        temperatureRead(uint8_t tsrange = RF22_TSRANGE_M64_64C, uint8_t tvoffs = 0);   
-
-    /**
-     * Reads the wakeup timer value in registers RF22_REG_17_WAKEUP_TIMER_VALUE1 
-     * and RF22_REG_18_WAKEUP_TIMER_VALUE2
-     * @return The wakeup timer value 
-     */
-    uint16_t       wutRead();
-
-    /**
-     * Sets the wakeup timer period registers RF22_REG_14_WAKEUP_TIMER_PERIOD1,
-     * RF22_REG_15_WAKEUP_TIMER_PERIOD2 and RF22_R<EG_16_WAKEUP_TIMER_PERIOD3
-     * @param[in] wtm Wakeup timer mantissa value
-     * @param[in] wtr Wakeup timer exponent R value
-     * @param[in] wtd Wakeup timer exponent D value
-     */
-    void           setWutPeriod(uint16_t wtm, uint8_t wtr = 0, uint8_t wtd = 0);
-
-    /**
-     * Sets the transmitter and receiver center frequency
-     * @param[in] center Frequency in MHz. 240.0 to 960.0. Caution, some versions of RF22 and derivatives 
-     * implemented more restricted frequency ranges.
-     * @param[in] afcPullInRange Sets the AF Pull In Range in MHz. Defaults to 0.05MHz (50kHz). Range is 0.0 to 0.159375
-     * for frequencies 240.0 to 480MHz, and 0.0 to 0.318750MHz for  frequencies 480.0 to 960MHz, 
-     * @return true if the selected frequency center + (fhch * fhs) is within range and the afcPullInRange is within range
-     */
-    uint8_t        setFrequency(float center, float afcPullInRange = 0.05);
-
-    /**
-     * Sets the frequency hopping step size.
-     * @param[in] fhs Frequency Hopping step size in 10kHz increments
-     * @return true if center + (fhch * fhs) is within limits
-     */
-    uint8_t        setFHStepSize(uint8_t fhs);
-
-    /**
-     * Sets the frequency hopping channel. Adds fhch * fhs to center frequency
-     * @param[in] fhch The channel number
-     * @return true if the selected frequency center + (fhch * fhs) is within range
-     */
-    uint8_t        setFHChannel(uint8_t fhch);
-
-    /**
-     * Reads and returns the current RSSI value from register RF22_REG_26_RSSI. If you want to find the RSSI
-     * of the last received message, use lastRssi() instead.
-     * @return The current RSSI value 
-     */
-    uint8_t        rssiRead();
-
-    /**
-     * Reads and returns the current EZMAC value from register RF22_REG_31_EZMAC_STATUS
-     * @return The current EZMAC value
-     */
-    uint8_t        ezmacStatusRead();
-
-    /**
-     * Sets the parameters for the RF22 Idle mode in register RF22_REG_07_OPERATING_MODE. 
-     * Idle mode is the mode the RF22 will be in when not transmitting or receiving. The default idle mode 
-     * is RF22_XTON i.e. READY mode. 
-     * @param[in] mode Mask of mode bits, using RF22_SWRES, RF22_ENLBD, RF22_ENWT, 
-     * RF22_X32KSEL, RF22_PLLON, RF22_XTON.
-     */
-    void           setMode(uint8_t mode);
-
-    /**
-     * If current mode is Rx or Tx changes it to Idle. If the transmitter or receiver is running, 
-     * disables them.
-     */
-    void           setModeIdle();
-
-    /**
-     * If current mode is Tx or Idle, changes it to Rx. 
-     * Starts the receiver in the RF22.
-     */
-    void           setModeRx();
-
-    /**
-     * If current mode is Rx or Idle, changes it to Rx. 
-     * Starts the transmitter in the RF22.
-     */
-    void           setModeTx();
-
-    /**
-     * Returns the operating mode of the library.
-     * @return the current mode, one of RF22_MODE_*
-     */
-    uint8_t        mode();
-
-    /**
-     * Sets the transmitter power output level in register RF22_REG_6D_TX_POWER.
-     * Be a good neighbor and set the lowest power level you need.
-     * After init(), the power will be set to RF22_TXPOW_8DBM.
-     * Caution: In some countries you may only select RF22_TXPOW_17DBM if you
-     * are also using frequency hopping.
-     * @param[in] power Transmitter power level, one of RF22_TXPOW_*
-     */
-    void           setTxPower(uint8_t power);
-
-    /**
-     * Sets all the registered required to configure the data modem in the RF22, including the data rate, 
-     * bandwidths etc. You can use this to configure the modem with custom configurations if none of the 
-     * canned configurations in ModemConfigChoice suit you.
-     * @param[in] config A ModemConfig structure containing values for the modem configuration registers.
-     */
-    void           setModemRegisters(const ModemConfig* config);
-
-    /**
-     * Select one of the predefined modem configurations. If you need a modem configuration not provided 
-     * here, use setModemRegisters() with your own ModemConfig.
-     * @param[in] index The configuration choice.
-     * @return true if index is a valid choice.
-     */
-    uint8_t        setModemConfig(ModemConfigChoice index);
-
-    /**
-     * Starts the receiver and checks whether a received message is available.
-     * This can be called multiple times in a timeout loop
-     * @return true if a complete, valid message has been received and is able to be retrieved by
-     * recv()
-     */
-    uint8_t        available();
-
-    /**
-     * Starts the receiver and blocks until a valid received 
-     * message is available.
-     */
-    void           waitAvailable();
-
-    /**
-     * Starts the receiver and blocks until a received message is available or a timeout
-     * @param[in] timeout Maximum time to wait in milliseconds.
-     * @return true if a message is available
-     */
-    bool           waitAvailableTimeout(unsigned long timeout);
-
-    /**
-     * Turns the receiver on if it not already on.
-     * If there is a valid message available, copy it to buf and return true
-     * else return false.
-     * If a message is copied, *len is set to the length (Caution, 0 length messages are permitted).
-     * You should be sure to call this function frequently enough to not miss any messages
-     * It is recommended that you call it in your main loop.
-     * @param[in] buf Location to copy the received message
-     * @param[in,out] len Pointer to available space in buf. Set to the actual number of octets copied.
-     * @return true if a valid message was copied to buf
-     */
-    uint8_t        recv(uint8_t* buf, uint8_t* len);
-
-    /**
-     * Waits until any previous transmit packet is finished being transmitted with waitPacketSent().
-     * Then loads a message into the transmitter and starts the transmitter. Note that a message length
-     * of 0 is NOT permitted. 
-     * @param[in] data Array of data to be sent
-     * @param[in] len Number of bytes of data to send (> 0)
-     * @return true if the message length was valid and it was correctly queued for transmit
-     */
-    uint8_t        send(const uint8_t* data, uint8_t len);
-
-    /**
-     * Blocks until the RF22 is not in mode RF22_MODE_TX (i.e. until the RF22 is not transmitting).
-     * This effectively waits until any previous transmit packet is finished being transmitted.
-     */
-    void           waitPacketSent();
-
-    /**
-     * Tells the receiver to accept messages with any TO address, not just messages
-     * addressed to this node or the broadcast address
-     * @param[in] promiscuous true if you wish to receive messages with any TO address
-     */
-    void           setPromiscuous(uint8_t promiscuous);
-
-    /**
-     * Returns the TO header of the last received message
-     * @return The TO header
-     */
-    uint8_t        headerTo();
-
-    /**
-     * Returns the FROM header of the last received message
-     * @return The FROM header
-     */
-    uint8_t        headerFrom();
-
-    /**
-     * Returns the ID header of the last received message
-     * @return The ID header
-     */
-    uint8_t        headerId();
-
-    /**
-     * Returns the FLAGS header of the last received message
-     * @return The FLAGS header
-     */
-    uint8_t        headerFlags();
-
-    /**
-     * Returns the RSSI (Receiver Signal Strength Indicator)
-     * of the last received message. This measurement is taken when 
-     * the preamble has been received. It is a (non-linear) measure of the received signal strength.
-     * @return The RSSI
-     */
-    uint8_t        lastRssi();
-
-    /**
-     * Prints a data buffer in HEX.
-     * For diagnostic use
-     * @param[in] prompt string to preface the print
-     * @param[in] buf Location of the buffer to print
-     * @param[in] len Length of the buffer in octets.
-     */
-    static void     printBuffer(const char* prompt, const uint8_t* buf, uint8_t len);
-
-    /**
-     * Sets the length of the preamble
-     * in 4-bit nibbles. 
-     * Caution: this should be set to the same 
-     * value on all nodes in your network. Default is 8.
-     * Sets the message preamble length in RF22_REG_34_PREAMBLE_LENGTH
-     * @param[in] nibbles Preamble length in nibbles of 4 bits each.  
-     */
-    void           setPreambleLength(uint8_t nibbles);
-
-    /**
-     * Sets the sync words for transmit and receive in registers RF22_REG_36_SYNC_WORD3 
-     * to RF22_REG_39_SYNC_WORD0
-     * Caution: this should be set to the same 
-     * value on all nodes in your network. Default is { 0x2d, 0xd4 }
-     * @param[in] syncWords Array of sync words
-     * @param[in] len Number of sync words to set
-     */
-    void           setSyncWords(const uint8_t* syncWords, uint8_t len);
-
-protected:
-    /**
-     * This is a low level function to handle the interrupts for one instance of RF22.
-     * Called automatically when interrupt pin goes low, should not need to be called by user.
-     */
-    void           handleInterrupt();
-
-    /**
-     * Clears the receiver buffer.
-     * Internal use only
-     */
-    void           clearRxBuf();
-
-    /**
-     * Clears the transmitter buffer
-     * Internal use only
-     */
-    void           clearTxBuf();
-
-    /**
-     * Fills the transmitter buffer with the data of a message to be sent
-     * @param[in] data Array of data bytes to be sent (1 to 255)
-     * @param[in] len Number of data bytes in data (> 0)
-     * @return true if the message length is valid
-     */
-    uint8_t         fillTxBuf(const uint8_t* data, uint8_t len);
-
-    /**
-     * Appends the transmitter buffer with the data of a message to be sent
-     * @param[in] data Array of data bytes to be sent (0 to 255)
-     * @param[in] len Number of data bytes in data
-     * @return false if the resulting message would exceed RF22_MAX_MESSAGE_LEN, else true
-     */
-    uint8_t         appendTxBuf(const uint8_t* data, uint8_t len);
-
-    /**
-     * Internal function to load the next fragment of 
-     * the current message into the transmitter FIFO
-     * Internal use only
-     */
-    void           sendNextFragment();
-
-    /**
-     * Function to copy the next fragment from 
-     * the receiver FIFO into the receiver buffer
-     */
-    void           readNextFragment();
-
-    /**
-     * Clears the RF22 Rx and Tx FIFOs
-     * Internal use only
-     */
-    void           resetFifos();
-
-    /**
-     * Clears the RF22 Rx FIFO
-     * Internal use only
-     */
-    void           resetRxFifo();
-
-    /**
-     * Clears the RF22 Tx FIFO
-     * Internal use only
-     */
-    void           resetTxFifo();
-
-    /**
-     * This function will be called by handleInterrupt() if an RF22 external interrupt occurs. 
-     * This can only happen if external interrupts are enabled in the RF22 
-     * (which they are not by default). 
-     * Subclasses may override this function to get control when  an RF22 external interrupt occurs. 
-     */
-    virtual void   handleExternalInterrupt();
-
-    /**
-     * This function will be called by handleInterrupt() if an RF22 wakeup timer interrupt occurs. 
-     * This can only happen if wakeup timer interrupts are enabled in the RF22 
-     * (which they are not by default). 
-     * Subclasses may override this function to get control when  an RF22 wakeup timer interrupt occurs. 
-     */
-    virtual void   handleWakeupTimerInterrupt();
-
-    /**
-     * Sets the TO header to be sent in all subsequent messages
-     * @param[in] to The new TO header value
-     */
-    void           setHeaderTo(uint8_t to);
-
-    /**
-     * Sets the FROM header to be sent in all subsequent messages
-     * @param[in] from The new FROM header value
-     */
-    void           setHeaderFrom(uint8_t from);
-
-    /**
-     * Sets the ID header to be sent in all subsequent messages
-     * @param[in] id The new ID header value
-     */
-    void           setHeaderId(uint8_t id);
-
-    /**
-     * Sets the FLAGS header to be sent in all subsequent messages
-     * @param[in] flags The new FLAGS header value
-     */
-    void           setHeaderFlags(uint8_t flags);
-
-    /**
-     * Start the transmission of the contents 
-     * of the Tx buffer
-     */
-    void           startTransmit();
-
-    /**
-     * ReStart the transmission of the contents 
-     * of the Tx buffer after a transmission failure
-     */
-    void           restartTransmit();
-    uint64_t       getTimestamp ();
-
-private:
-    /**
-     * Static interrupt handler wrapper
-     */
-    static void         isr(void* args);
-    
-    mraa_spi_context    _spi;
-    mraa_gpio_context   _cs;
-    mraa_gpio_context   _irq;
-
-    volatile uint8_t    _mode; // One of RF22_MODE_*
-
-    uint8_t             _idleMode;
-    uint8_t             _deviceType;
-
-    // These volatile members may get changed in the interrupt service routine
-    volatile uint8_t    _bufLen;
-    uint8_t             _buf[RF22_MAX_MESSAGE_LEN];
-
-    volatile uint8_t    _rxBufValid;
-    volatile uint8_t    _txBufSentIndex;
-  
-    volatile uint16_t   _rxBad;
-    volatile uint16_t   _rxGood;
-    volatile uint16_t   _txGood;
-
-    volatile uint8_t    _lastRssi;
-};
-
-}
diff --git a/src/rf22/rf22.i b/src/rf22/rf22.i
deleted file mode 100644
index f029c0a..0000000
--- a/src/rf22/rf22.i
+++ /dev/null
@@ -1,34 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-#ifndef ANDROID
-%module(directors="1") javaupm_rf22
-#endif
-
-%include "arrays_java.i"
-%apply uint8_t *INOUT { uint8_t* len };
-%apply signed char[] {uint8_t*};
-
-JAVA_JNI_LOADLIBRARY(javaupm_rf22)
-#endif
-/* END Java syntax */
-
-/* BEGIN Javascript syntax  ------------------------------------------------- */
-#ifdef SWIGJAVASCRIPT
-%include "../carrays_uint8_t.i"
-#endif
-/* END Javascript syntax */
-
-/* BEGIN Python syntax  ----------------------------------------------------- */
-#ifdef SWIGPYTHON
-%include "../carrays_uint8_t.i"
-#endif
-/* END Python syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "rf22.hpp"
-%}
-%include "rf22.hpp"
-/* END Common SWIG syntax */
diff --git a/src/rf22/rf22.json b/src/rf22/rf22.json
deleted file mode 100644
index 066a94c..0000000
--- a/src/rf22/rf22.json
+++ /dev/null
@@ -1,63 +0,0 @@
-{
-    "Library": "rf22",
-    "Description": "SparkFun/HopeRF RF22 Wireless Transceiver library",
-    "Sensor Class": {
-        "RF22": {
-            "Name": "API for the SparkFun/HopeRF RF22 Transceiver Module",
-            "Description": "This is the UPM Module for the SparkFun/HopeRF RF22 Transceiver Module. This base class provides basic functions for sending and receiving unaddressable, unreliable datagrams of arbitrary length to 255 octets per packet. Subclasses may use this class to implement reliable, addressed datagrams and streams,  mesh routers, repeaters, translators etc. On transmission, the TO and FROM addresses default to 0x00, unless changed by a subclass.  On reception the TO addressed is checked against the node address (defaults to 0x00) or the broadcast address (which is 0xff). The ID and FLAGS are set to 0, and not checked by this class. This permits use of the this base RF22 class as an unaddressable, unreliable datagram service. Subclasses are expected to change this behavior to add node address, ids, retransmission etc. Naturally, for any 2 radios to communicate that must be configured to use the same frequency and  modulation scheme.",
-            "Aliases": ["rf22", "RFM22B-S2 SMD Wireless Transceiver - 915MHz"],
-            "Categories": ["wifi"],
-            "Connections": ["spi"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["SparkFun", "HopeRF"],
-            "Image": "rf22.jpg",
-            "Examples": {
-                "C++": ["rf22-client.cxx", "rf22-server.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 1.8,
-                    "max": 3.6
-                },
-                "Supply Current": {
-                    "Standby Mode": {
-                        "unit": "nA",
-                        "min" : 450,
-                        "max" : 800
-                    },
-                    "Standard Usage" : {
-                        "unit": "mA",
-                        "min" : 8.5,
-                        "max" : 85
-                    }
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Data Rate": {
-                    "unit": "kbps",
-                    "min" : 0.123,
-                    "max" : 256
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need pull up resistors"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.sparkfun.com/products/12030"],
-                "Datasheets": ["https://www.sparkfun.com/datasheets/Wireless/General/RFM22B.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/rfr359f/CMakeLists.txt b/src/rfr359f/CMakeLists.txt
deleted file mode 100644
index bb7baba..0000000
--- a/src/rfr359f/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "rfr359f")
-set (libdescription "Infrared Distance Interrupter")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/rfr359f/rfr359f.cxx b/src/rfr359f/rfr359f.cxx
deleted file mode 100644
index e24ce73..0000000
--- a/src/rfr359f/rfr359f.cxx
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "rfr359f.hpp"
-
-using namespace upm;
-using namespace std;
-
-RFR359F::RFR359F(int pin)
-{
-  if ( !(m_gpio = mraa_gpio_init(pin)) )
-   {
-      throw std::invalid_argument(std::string(__FUNCTION__) +
-                                  ": mraa_gpio_init() failed, invalid pin?");
-      return;
-    }
-
-  mraa_gpio_dir(m_gpio, MRAA_GPIO_IN);
-}
-
-RFR359F::~RFR359F()
-{
-  mraa_gpio_close(m_gpio);
-}
-
-bool RFR359F::objectDetected()
-{
-  return (!mraa_gpio_read(m_gpio) ? true : false);
-}
diff --git a/src/rfr359f/rfr359f.hpp b/src/rfr359f/rfr359f.hpp
deleted file mode 100644
index 3e43966..0000000
--- a/src/rfr359f/rfr359f.hpp
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/gpio.h>
-
-namespace upm {
-
-  /**
-   * @brief RFR359 Distance Interrupter
-   * @defgroup rfr359f libupm-rfr359f
-   * @ingroup seeed gpio light robok tsk
-   */
-  /**
-   * @library rfr359f
-   * @sensor rfr359f
-   * @comname Infrared Distance Interrupter
-   * @altname Grove Distance Interrupter
-   * @type light
-   * @man seeed
-   * @web https://www.seeedstudio.com/Grove-IR-Distance-Interrupter-p-1278.html
-   * @con gpio
-   * @kit robok tsk
-   *
-   * @brief API for the RFR359F-based Grove Distance Interrupter. 
-   *
-   * UPM module for the Grove distance interrupter. The sensitivity
-   * can be adjusted with the potentiometer on the sensor module. It
-   * has a range of approximately 4 inches and a quick response time.
-   *
-   * @image html rfr359f.jpg
-   * @snippet rfr359f.cxx Interesting
-   */
-  class RFR359F {
-  public:
-    /**
-     * RFR359F constructor
-     *
-     * @param pin Digital pin to use
-     */
-    RFR359F(int pin);
-
-    /**
-     * RFR359F destructor
-     */
-    ~RFR359F();
-
-    /**
-     * Gets the status of the pin; true means an object has been detected
-     *
-     * @return True if the sensor has detected an object
-     */
-    bool objectDetected();
-
-  private:
-    mraa_gpio_context m_gpio;
-  };
-}
-
-
diff --git a/src/rfr359f/rfr359f.json b/src/rfr359f/rfr359f.json
deleted file mode 100644
index 746a857..0000000
--- a/src/rfr359f/rfr359f.json
+++ /dev/null
@@ -1,57 +0,0 @@
-{
-    "Library": "rfr359f",
-    "Description": "Seeed RFR359 Distance Interrupter library",
-    "Sensor Class": {
-        "RFR359F": {
-            "Name": "API for the RFR359F-based Grove Distance Interrupter",
-            "Description": "This is the UPM Module for the RFR359F-based Grove Distance Interrupter. The sensitivity can be adjusted with the potentiometer on the sensor module. It has a range of approximately 4 inches and a quick response time.",
-            "Aliases": ["rfr359f", "Grove - IR Distance Interrupter"],
-            "Categories": ["light"],
-            "Connections": ["gpio"],
-            "Project Type": ["prototyping", "industrial"],
-            "Manufacturers": ["Seeed"],
-            "Kits": ["robot", "tsk"],
-            "Image": "rfr359f.jpg",
-            "Examples": {
-                "Java": ["RFR359F_Example.java"],
-                "Python": ["rfr359f.py"],
-                "Node.js": ["rfr359f.js"],
-                "C++": ["rfr359f.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.3,
-                    "max": 5.0
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "min" : 1,
-                    "max" : 20
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Effective Distance": {
-                    "unit": "cm",
-                    "min" : 7.5,
-                    "max" : 40
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-IR-Distance-Interrupter-p-1278.html", "http://wiki.seeed.cc/Grove-IR_Distance_Interrupter_v1.2/"],
-                "Datasheets": ["https://raw.githubusercontent.com/SeeedDocument/Grove-IR_Distance_Interrupter_v1.2/master/res/Reflective_photosensor.pdf", "https://raw.githubusercontent.com/SeeedDocument/Grove-IR_Distance_Interrupter_v1.2/master/res/LM393.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/rgbringcoder/CMakeLists.txt b/src/rgbringcoder/CMakeLists.txt
deleted file mode 100644
index 75cdbce..0000000
--- a/src/rgbringcoder/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "rgbringcoder")
-set (libdescription "RGB RingCoder")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/rgbringcoder/rgbringcoder.cxx b/src/rgbringcoder/rgbringcoder.cxx
deleted file mode 100644
index f7565d1..0000000
--- a/src/rgbringcoder/rgbringcoder.cxx
+++ /dev/null
@@ -1,187 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-
-#include "rgbringcoder.hpp"
-
-using namespace std;
-using namespace upm;
-
-RGBRingCoder::RGBRingCoder(int en, int latch, int clear, int clk, int dat,
-                           int sw, int encA, int encB, int red,
-                           int green, int blue) :
-  m_gpioEn(en), m_gpioLatch(latch), m_gpioClear(clear), m_gpioClock(clk),
-  m_gpioData(dat), m_gpioSwitch(sw), m_gpioEncA(encA), m_gpioEncB(encB),
-  m_pwmRed(red), m_pwmGreen(green), m_pwmBlue(blue)
-{
-  m_counter = 0;
-
-  // enable, set LOW
-  m_gpioEn.dir(mraa::DIR_OUT);
-  m_gpioEn.write(0);
-
-  // latch
-  m_gpioLatch.dir(mraa::DIR_OUT);
-  m_gpioLatch.write(0);
-
-  // clear, HIGH
-  m_gpioClear.dir(mraa::DIR_OUT);
-  m_gpioLatch.write(1);
-
-  // clock
-  m_gpioClock.dir(mraa::DIR_OUT);
-  m_gpioClock.write(0);
-
-  // data
-  m_gpioData.dir(mraa::DIR_OUT);
-  m_gpioData.write(0);
-
-  // switch
-  m_gpioSwitch.dir(mraa::DIR_IN);
-  m_gpioSwitch.mode(mraa::MODE_HIZ);  // no pullup
-  m_gpioSwitch.write(0);
-
-  // ecoder A interrupt
-  m_gpioEncA.dir(mraa::DIR_IN);
-  m_gpioEncA.mode(mraa::MODE_PULLUP);
-  // EDGE_BOTH would be nice...
-  m_gpioEncA.isr(mraa::EDGE_RISING, &interruptHandler, this);
-
-  // ecoder B interrupt
-  m_gpioEncB.dir(mraa::DIR_IN);
-  m_gpioEncB.mode(mraa::MODE_PULLUP);
-  // EDGE_BOTH would be nice...
-  m_gpioEncB.isr(mraa::EDGE_RISING, &interruptHandler, this);
-
-  // RGB LED pwms, set to off
-
-  // Red led
-  m_pwmRed.period_ms(1);
-  m_pwmRed.write(0.99);
-  m_pwmRed.enable(true);
-
-  // Green led
-  m_pwmGreen.period_ms(1);
-  m_pwmGreen.write(0.99);
-  m_pwmGreen.enable(true);
-
-  // Blue led
-  m_pwmBlue.period_ms(1);
-  m_pwmBlue.write(0.99);
-  m_pwmBlue.enable(true);
-
-  // whew.
-}
-
-RGBRingCoder::~RGBRingCoder()
-{
-  m_gpioEncA.isrExit();
-  m_gpioEncB.isrExit();
-
-  // turn off the ring
-  setRingLEDS(0x0000);
-
-  // Turn of RGB LEDS
-  setRGBLED(0.99, 0.99, 0.99);
-  usleep(100000);
-
-  // turn off PWM's
-  m_pwmRed.enable(false);
-  m_pwmGreen.enable(false);
-  m_pwmBlue.enable(false);
-}
-
-void RGBRingCoder::interruptHandler(void *ctx)
-{
-   upm::RGBRingCoder *This = (upm::RGBRingCoder *)ctx;
-
-   // From the Sparkfun guys:
-
-   // enc_states[] is a fancy way to keep track of which direction
-   // the encoder is turning. 2-bits of oldEncoderState are paired
-   // with 2-bits of newEncoderState to create 16 possible values.
-   // Each of the 16 values will produce either a CW turn (1),
-   // CCW turn (-1) or no movement (0).
-
-   static int8_t enc_states[] = {0, -1, 1, 0, 1, 0, 0, -1,
-                                 -1, 0, 0, 1, 0, 1, -1, 0};
-   static uint8_t oldEncoderState = 0;
-   static uint8_t newEncoderState = 0;
-
-   // First, find the newEncoderState. This'll be a 2-bit value
-   // the msb is the state of the B pin. The lsb is the state
-   // of the A pin on the encoder.
-   newEncoderState = (This->m_gpioEncB.read()<<1) |
-     (This->m_gpioEncA.read());
-
-   // Now we pair oldEncoderState with new encoder state
-   // First we need to shift oldEncoder state left two bits.
-   // This'll put the last state in bits 2 and 3.
-
-   oldEncoderState <<= 2;
-
-   // Mask out everything in oldEncoderState except for the previous state
-   oldEncoderState &= 0x0c;
-
-   // Now add the newEncoderState. oldEncoderState will now be of
-   // the form: 0b0000(old B)(old A)(new B)(new A)
-   oldEncoderState |= newEncoderState;
-
-   // update our counter
-   This->m_counter += enc_states[oldEncoderState & 0x0f];
-}
-
-void RGBRingCoder::setRingLEDS(uint16_t bits)
-{
-  // First we need to set latch LOW
-  m_gpioLatch.write(0);
-
-  // Now shift out the bits, msb first
-  for (int i=0; i<16; i++)
-    {
-      m_gpioData.write( ((bits & 0x8000) ? 1 : 0) );
-
-      // pulse the clock pin
-      m_gpioClock.write(1);
-      m_gpioClock.write(0);
-
-      bits <<= 1;
-    }
-
-  // latch it
-  m_gpioLatch.write(1);
-}
-
-bool RGBRingCoder::getButtonState()
-{
-  return (m_gpioSwitch.read() ? true : false);
-}
-
-void RGBRingCoder::setRGBLED(float r, float g, float b)
-{
-  m_pwmRed.write(r);
-  m_pwmGreen.write(g);
-  m_pwmBlue.write(b);
-}
diff --git a/src/rgbringcoder/rgbringcoder.hpp b/src/rgbringcoder/rgbringcoder.hpp
deleted file mode 100644
index 3813fb7..0000000
--- a/src/rgbringcoder/rgbringcoder.hpp
+++ /dev/null
@@ -1,152 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <iostream>
-#include <string>
-#include <stdint.h>
-#include <unistd.h>
-
-#include <mraa/gpio.hpp>
-
-#include <mraa/pwm.hpp>
-
-
-namespace upm {
-  /**
-   * @brief SparkFun RGB RingCoder
-   * @defgroup rgbringcoder libupm-rgbringcoder
-   * @ingroup seeed gpio led
-   */
-
-  /**
-   * @library rgbringcoder
-   * @sensor rgbringcoder
-   * @comname RGB RingCoder
-   * @type led
-   * @web https://www.sparkfun.com/products/11040
-   * @man sparkfun
-   * @con pwm gpio
-   *
-   * @brief API for the SparkFun* RGB RingCoder
-   *
-   * RGB RingCoder is a breakout board, a circular LED containing
-   * 16 LEDs arranged in a ring, and a rotary encoder. The encoder
-   * contains an RGB LED as well as a push button function.
-   *
-   * The device requires 11 pins, 3 of which must be PWM-capable
-   * (for the RGB LEDs).
-   *
-   * @image html rgbringcoder.jpg
-   * @snippet rgbringcoder.cxx Interesting
-   */
-
-  class RGBRingCoder {
-  public:
-
-    /**
-     * RGBRingCoder constructor
-     *
-     * @param en Enables GPIO
-     * @param latch Latch GPIO
-     * @param clear Clears GPIO
-     * @param clk Clock GPIO
-     * @param dat Data out GPIO
-     * @param sw Push button switch GPIO
-     * @param encA Encoder A GPIO
-     * @param encB Encoder B GPIO
-     * @param red RGB red LED PWM
-     * @param green RGB green LED PWM
-     * @param blue RGB blue LED PWM
-     */
-    RGBRingCoder(int en, int latch, int clear, int clk, int dat, int sw,
-                 int encA, int encB, int red, int green, int blue);
-
-    /**
-     * RGBRingCoder destructor
-     */
-    ~RGBRingCoder();
-
-    /*
-     * Sets the state of the ring LEDs. This is a 16-bit value, where
-     * each bit corresponds to one of the ring LEDs. A 1 bit means
-     * that a specific LED is on, and a 0 bit means that a specific LED is
-     * off.
-     *
-     * @param bits Bits representing the state of each LED
-     */
-    void setRingLEDS(uint16_t bits);
-
-    /**
-     * Returns the state of the button
-     *
-     * @return True if the button is pressed, false otherwise
-     */
-    bool getButtonState();
-
-    /*
-     * Gets the current rotary encoder counter value
-     *
-     * @return Current counter value
-     */
-    int getEncoderPosition() { return m_counter; };
-
-    /**
-     * Sets the encoder counter to 0
-     */
-    void clearEncoderPosition() { m_counter = 0; };
-
-    /**
-     * Sets the intensity of the red, green, and blue LEDs. Values can
-     * be between 0.0 and 1.0. Lower is brighter, higher is dimmer.
-     *
-     * @param r Red value; valid values are 0.0-1.0
-     * @param g Green value; valid values are 0.0-1.0
-     * @param b Blue value; valid values are 0.0-1.0
-     */
-    void setRGBLED(float r, float g, float b);
-
-  private:
-
-    mraa::Gpio m_gpioEn;
-
-    mraa::Gpio m_gpioLatch;
-    mraa::Gpio m_gpioClear;
-    mraa::Gpio m_gpioClock;
-    mraa::Gpio m_gpioData;
-
-    mraa::Gpio m_gpioSwitch;
-
-    mraa::Gpio m_gpioEncA;
-    mraa::Gpio m_gpioEncB;
-
-    mraa::Pwm m_pwmRed;
-    mraa::Pwm m_pwmGreen;
-    mraa::Pwm m_pwmBlue;
-
-    static void interruptHandler(void *ctx);
-    volatile int m_counter;
-
-  };
-}
diff --git a/src/rgbringcoder/rgbringcoder.i b/src/rgbringcoder/rgbringcoder.i
deleted file mode 100644
index eccfd29..0000000
--- a/src/rgbringcoder/rgbringcoder.i
+++ /dev/null
@@ -1,14 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_rgbringcoder)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "rgbringcoder.hpp"
-%}
-%include "rgbringcoder.hpp"
-/* END Common SWIG syntax */
diff --git a/src/rgbringcoder/rgbringcoder.json b/src/rgbringcoder/rgbringcoder.json
deleted file mode 100644
index 9cda654..0000000
--- a/src/rgbringcoder/rgbringcoder.json
+++ /dev/null
@@ -1,48 +0,0 @@
-{
-    "Library": "rgbringcoder",
-    "Description": "SparkFun RGB RingCoder Library",
-    "Sensor Class": {
-        "RGBRingCoder": {
-            "Name": "API for the SparkFun RGB RingCoder",
-            "Description": "This is the UPM Module for the SparkFun RGB RingCode. RGB RingCoder is a breakout board, a circular LED containing 16 LEDs arranged in a ring, and a rotary encoder. The encoder contains an RGB LED as well as a push button function. NOTE: This SparkFun product is retired, and no longer for sale.",
-            "Aliases": ["rgbringcoder", "SparkFun LED RingCoder Breakout - RGB"],
-            "Categories": ["led"],
-            "Connections": ["pwm", "gpio"],
-            "Project Type": ["prototyping"],
-            "Manufacturers": ["SparkFun"],
-            "Image": "rgbringcoder.jpg",
-            "Examples": {
-                "Python": ["rgbringcoder.py"],
-                "Node.js": ["rgbringcoder.js"],
-                "C++": ["rgbringcoder.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.3,
-                    "max": 5.0
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -40,
-                    "max": 85
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need pull up resistors"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.sparkfun.com/products/retired/11040"],
-                "Datasheets": ["https://github.com/sparkfun/LED_RingCoder_Breakout"]
-            }
-        }
-    }
-}
diff --git a/src/rhusb/CMakeLists.txt b/src/rhusb/CMakeLists.txt
deleted file mode 100644
index 0aaa9f1..0000000
--- a/src/rhusb/CMakeLists.txt
+++ /dev/null
@@ -1,6 +0,0 @@
-set (libname "rhusb")
-set (libdescription "Omega RH-USB Temperature and Humidity Sensor")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
-
diff --git a/src/rhusb/rhusb.cxx b/src/rhusb/rhusb.cxx
deleted file mode 100644
index e6e5fa7..0000000
--- a/src/rhusb/rhusb.cxx
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <stdlib.h>
-#include <iostream>
-#include <stdexcept>
-#include <string>
-
-#include "rhusb.hpp"
-
-using namespace upm;
-using namespace std;
-
-static const int maxBuffer = 1024;
-// baud rate is always 9600
-static const int baudRate = 9600;
-
-// conversion from celsius to fahrenheit
-
-static float c2f(float c)
-{
-  return (c * (9.0 / 5.0) + 32.0);
-}
-
-RHUSB::RHUSB(std::string device) :
-  m_uart(device)
-{
-  m_uart.setBaudRate(baudRate);
-
-  m_temperature = 0.0;
-  m_humidity = 0.0;
-}
-
-RHUSB::~RHUSB()
-{
-}
-
-void RHUSB::update()
-{
-  char *endptr;
-  float value;
-
-  // first get the temp in C
-  string resp = sendCommand("C");
-
-  // convert
-  value = strtof(resp.c_str(), &endptr);
-
-  // check for conversion failure
-  if (value == 0.0 && resp.c_str() == endptr)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": strtof() temperature conversion failed");
-    }
-  m_temperature = value;
-
-  // now humidity
-  resp = sendCommand("H");
-
-  // convert
-  value = strtof(resp.c_str(), &endptr);
-
-  // check for conversion failure
-  if (value == 0.0 && resp.c_str() == endptr)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": strtof() humidity conversion failed");
-    }
-  m_humidity = value;
-}
-
-float RHUSB::getTemperature(bool fahrenheit)
-{
-  if (fahrenheit)
-    return c2f(m_temperature);
-  else
-    return m_temperature;
-}
-
-float RHUSB::getHumidity()
-{
-  return m_humidity;
-}
-
-bool RHUSB::dataAvailable(unsigned int millis)
-{
-  return m_uart.dataAvailable(millis);
-}
-
-string RHUSB::readStr(int len)
-{
-  return m_uart.readStr(len);
-}
-
-int RHUSB::writeStr(string data)
-{
-  m_uart.flush();
-  return m_uart.writeStr(data);
-}
-
-string RHUSB::sendCommand(string cmd)
-{
-  // make sure we got a command
-  if (cmd.empty())
-    {
-      throw std::invalid_argument(std::string(__FUNCTION__) +
-                                  ": cmd is empty!");
-    }
-
-  // Terminate the command with a carriage return
-  writeStr(cmd + "\r");
-
-  string resp;
-  // I see random timeouts with wait values below 250ms
-  while (dataAvailable(250) && (resp.size() < maxBuffer) )
-    {
-      resp += readStr(maxBuffer);
-    }
-
-  if (resp.empty())
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": " + cmd + " response timed out");
-    }
-
-  // check that the last character is the prompt
-  if (resp.at(resp.size() - 1) != '>')
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": " + cmd + " response corrupt");
-    }
-
-  // delete the last 3 characters, which should be '\r\n>'
-  resp.erase(resp.size() - 3, 3);
-
-  return resp;
-}
-
-string RHUSB::getFirmwareID()
-{
-  string resp = sendCommand("ENQ");
-
-  // For readability, replace the intermediate \r\n with a space if found.
-
-  size_t pos = resp.find("\r\n");
-
-  if (pos != string::npos)
-    resp.replace(pos, 2, " ");
-
-  return resp;
-}
diff --git a/src/rhusb/rhusb.hpp b/src/rhusb/rhusb.hpp
deleted file mode 100644
index ba3d08f..0000000
--- a/src/rhusb/rhusb.hpp
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/uart.hpp>
-
-namespace upm {
-
-  /**
-   * @brief Omega RH-USB Temperature and Humidity Sensor
-   * @defgroup rhusb libupm-rhusb
-   * @ingroup uart temp
-   */
-
-  /**
-   * @library rhusb
-   * @sensor rhusb
-   * @comname Omega RH-USB Temperature and Humidity Sensor
-   * @type temp
-   * @man omega
-   * @con uart
-   * @web http://www.omega.com/pptst/RH-USB.html
-   *
-   * @brief UPM API for the Omega RH-USB Temperature and Humidity Sensor
-   *
-   * This module implements support for the Omega RH-USB Temperature
-   * and Humidity Sensor Probe.  It connects via an integrated USB
-   * cable, and is accessed via a serial port.  It is suitable for
-   * wall or duct mounting.
-   *
-   * @snippet rhusb.cxx Interesting
-   */
-
-  class RHUSB {
-  public:
-    /**
-     * RHUSB constructor
-     *
-     * @param device Path to the serial device
-     */
-    RHUSB(std::string device);
-
-    /**
-     * RHUSB Destructor
-     */
-    ~RHUSB();
-
-    /**
-     * Read current values from the sensor and update internal stored
-     * values.  This method must be called prior to querying any
-     * values, such as temperature or humidity.
-     */
-    void update();
-
-    /**
-     * Get the current temperature.  update() must have been called
-     * prior to calling this method.
-     *
-     * @param fahrenheit true to return the temperature in degrees
-     * fahrenheit, false to return the temperature in degrees celsius.
-     * The default is false (degrees Celsius).
-     * @return The last temperature reading in Celsius or Fahrenheit
-     */
-    float getTemperature(bool fahrenheit=false);
-
-    /**
-     * Get the current relative humidity.  update() must have been called
-     * prior to calling this method.
-     *
-     * @return The last humidity reading
-     */
-    float getHumidity();
-
-    /**
-     * Get the firmware identification string.
-     *
-     * @return The firmware identification
-     */
-    std::string getFirmwareID();
-
-
-  protected:
-    // serial i/o support
-    bool dataAvailable(unsigned int millis);
-    int writeStr(std::string data);
-    std::string readStr(int len);
-    std::string sendCommand(std::string cmd);
-
-    mraa::Uart m_uart;
-
-  private:
-    // data
-    float m_temperature;
-    float m_humidity;
-  };
-}
diff --git a/src/rhusb/rhusb.i b/src/rhusb/rhusb.i
deleted file mode 100644
index f1e69d8..0000000
--- a/src/rhusb/rhusb.i
+++ /dev/null
@@ -1,16 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "arrays_java.i";
-%include "../java_buffer.i"
-JAVA_JNI_LOADLIBRARY(javaupm_rhusb)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "rhusb.hpp"
-%}
-%include "rhusb.hpp"
-/* END Common SWIG syntax */
diff --git a/src/rhusb/rhusb.json b/src/rhusb/rhusb.json
deleted file mode 100644
index 2bbbab2..0000000
--- a/src/rhusb/rhusb.json
+++ /dev/null
@@ -1,60 +0,0 @@
-{
-    "Library": "rhusb",
-    "Description": "Omega RH-USB Temperature and Humidity Sensor Library",
-    "Sensor Class": {
-        "RHUSB": {
-            "Name": "API for the Omega RH-USB Temperature and Humidity Sensor",
-            "Description": "This is the UPM Module for the Omega RH-USB Temperature and Humidity Sensor. It connects via an integrated USB cable, and is accessed via a serial port.  It is suitable for wall or duct mounting.",
-            "Aliases": ["rhusb", "Humidity & Temperature Sensor with USB Output"],
-            "Categories": ["humidity", "temperature"],
-            "Connections": ["uart"],
-            "Project Type": ["industrial", "commercial"],
-            "Manufacturers": ["Omega"],
-            "Examples": {
-                "Python": ["rhusb.py"],
-                "Node.js": ["rhusb.js"],
-                "C++": ["rhusb.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 5.0,
-                    "max": 5.0
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Temperature": {
-                    "Effective Range": {
-                        "unit": "Â°C",
-                        "min" : -17,
-                        "max" : 49
-                    },
-                    "Accuracy": {
-                        "unit": "Â°C",
-                        "min" : -1,
-                        "max" : 1
-                    }
-                },
-                "Relative Humidity": {
-                    "Effective Range": {
-                        "unit": "RH",
-                        "min" : "2%",
-                        "max" : "98%"
-                    },
-                    "Accuracy": {
-                        "unit": "RH",
-                        "min" : "-3%",
-                        "max" : "3%"
-                    }
-                }
-            },
-            "Urls": {
-                "Product Pages": ["http://www.omega.com/pptst/RH-USB.html"],
-                "Datasheets": ["http://www.omega.com/das/pdf/RH-USB.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/rn2903/CMakeLists.txt b/src/rn2903/CMakeLists.txt
deleted file mode 100644
index f5d84c6..0000000
--- a/src/rn2903/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-upm_mixed_module_init (NAME rn2903
-    DESCRIPTION "LoRaWAN transceiver"
-    C_HDR rn2903.h rn2903_defs.h
-    C_SRC rn2903.c
-    CPP_HDR rn2903.hpp
-    CPP_SRC rn2903.cxx
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/rn2903/rn2903.c b/src/rn2903/rn2903.c
deleted file mode 100644
index 20239ba..0000000
--- a/src/rn2903/rn2903.c
+++ /dev/null
@@ -1,1162 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string.h>
-#include <ctype.h>
-#include <assert.h>
-
-#include "rn2903.h"
-
-#include "upm_utilities.h"
-#include "upm_platform.h"
-
-// we use small buffers of this size to build certain compound
-// commands
-#define RN2903_CMD_BUFFER_32B       (32) // 32 bytes
-
-// maximum number of autobaud retries
-#define RN2903_AUTOBAUD_RETRIES     (10)
-
-// some useful macros to save on typing and text wrapping
-#undef _SHIFT
-#define _SHIFT(x) (_RN2903_##x##_SHIFT)
-
-#undef _MASK
-#define _MASK(x) (_RN2903_##x##_MASK)
-
-#undef _SHIFTMASK
-#define _SHIFTMASK(x) (_MASK(x) << _SHIFT(x))
-
-// disable printf to stdout if on Zephyr, and stdout isn't available.
-#if defined(UPM_PLATFORM_ZEPHYR) && !defined(CONFIG_STDOUT_CONSOLE)
-# define printf printk
-#endif
-
-
-static bool validate_hex_str(const char *hex)
-{
-    assert(hex != NULL);
-
-    int len = strlen(hex);
-    if ((len % 2) != 0)
-    {
-        printf("%s: strlen(hex) must be a multiple of 2\n",
-               __FUNCTION__);
-        return false;
-    }
-
-    for (int i=0; i<len; i++)
-    {
-        if ( !((hex[i] >= '0' && hex[i] <= '9') ||
-               (tolower(hex[i]) >= 'a' && tolower(hex[i]) <= 'f')) )
-        {
-            printf("%s: invalid hex character at position %d\n",
-                   __FUNCTION__, i);
-            return false;
-        }
-    }
-
-    return true;
-}
-
-static rn2903_context _rn2903_preinit()
-{
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        return NULL;
-    }
-
-    rn2903_context dev =
-        (rn2903_context)malloc(sizeof(struct _rn2903_context));
-
-    if (!dev)
-        return NULL;
-
-    // zero out context
-    memset((void *)dev, 0, sizeof(struct _rn2903_context));
-
-    // first response wait time
-    dev->cmd_resp_wait_ms = RN2903_DEFAULT_RESP_DELAY;
-    // optional second response wait time
-    dev->cmd_resp2_wait_ms = RN2903_DEFAULT_RESP2_DELAY;
-
-    // init stored baudrate to RN2903_DEFAULT_BAUDRATE
-    dev->baudrate = RN2903_DEFAULT_BAUDRATE;
-
-    // uncomment for "early" debugging
-    // dev->debug = true;
-
-    return dev;
-}
-
-static rn2903_context _rn2903_postinit(rn2903_context dev,
-                                       unsigned int baudrate)
-{
-    assert(dev != NULL);
-
-    if (rn2903_set_baudrate(dev, baudrate))
-    {
-        printf("%s: rn2903_set_baudrate() failed.\n", __FUNCTION__);
-        rn2903_close(dev);
-        return NULL;
-    }
-
-    if (rn2903_set_flow_control(dev, RN2903_FLOW_CONTROL_NONE))
-    {
-        printf("%s: rn2903_set_flow_control() failed.\n", __FUNCTION__);
-        rn2903_close(dev);
-        return NULL;
-    }
-
-    // turn off debugging
-    rn2903_set_debug(dev, false);
-
-    // reset the device
-    if (rn2903_reset(dev))
-    {
-        printf("%s: rn2903_reset() failed.\n", __FUNCTION__);
-        rn2903_close(dev);
-        return NULL;
-    }
-
-    // now get and store our hardware EUI
-    if (rn2903_command(dev, "sys get hweui"))
-    {
-        printf("%s: rn2903_command(sys get hweui) failed.\n", __FUNCTION__);
-        rn2903_close(dev);
-        return NULL;
-    }
-    memcpy(dev->hardware_eui, dev->resp_data, RN2903_MAX_HEX_EUI64);
-
-    return dev;
-}
-
-// uart init
-rn2903_context rn2903_init(unsigned int uart, unsigned int baudrate)
-{
-    rn2903_context dev;
-
-    if (!(dev = _rn2903_preinit()))
-        return NULL;
-
-    // initialize the MRAA context
-
-    // uart, default should be 8N1
-    if (!(dev->uart = mraa_uart_init(uart)))
-    {
-        printf("%s: mraa_uart_init() failed.\n", __FUNCTION__);
-        rn2903_close(dev);
-        return NULL;
-    }
-
-    return _rn2903_postinit(dev, baudrate);
-}
-
-// uart tty init
-rn2903_context rn2903_init_tty(const char *uart_tty, unsigned int baudrate)
-{
-    rn2903_context dev;
-
-    if (!(dev = _rn2903_preinit()))
-        return NULL;
-
-    // initialize the MRAA context
-
-    // uart, default should be 8N1
-    if (!(dev->uart = mraa_uart_init_raw(uart_tty)))
-    {
-        printf("%s: mraa_uart_init_raw() failed.\n", __FUNCTION__);
-        rn2903_close(dev);
-        return NULL;
-    }
-
-    return _rn2903_postinit(dev, baudrate);
-}
-
-void rn2903_close(rn2903_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->to_hex_buf)
-        free(dev->to_hex_buf);
-    if (dev->from_hex_buf)
-        free(dev->from_hex_buf);
-
-    if (dev->uart)
-        mraa_uart_stop(dev->uart);
-
-    free(dev);
-}
-
-int rn2903_read(const rn2903_context dev, char *buffer, size_t len)
-{
-    assert(dev != NULL);
-
-    // uart
-    return mraa_uart_read(dev->uart, buffer, len);
-}
-
-int rn2903_write(const rn2903_context dev, const char *buffer, size_t len)
-{
-    assert(dev != NULL);
-
-    int rv = mraa_uart_write(dev->uart, buffer, len);
-    mraa_uart_flush(dev->uart);
-
-    return rv;
-}
-
-bool rn2903_data_available(const rn2903_context dev, unsigned int millis)
-{
-    assert(dev != NULL);
-
-    if (mraa_uart_data_available(dev->uart, millis))
-        return true;
-    else
-        return false;
-}
-
-upm_result_t rn2903_set_baudrate(const rn2903_context dev,
-                                 unsigned int baudrate)
-{
-    assert(dev != NULL);
-
-    if (dev->debug)
-        printf("%s: Setting baudrate to %d\n", __FUNCTION__,
-               baudrate);
-
-    if (mraa_uart_set_baudrate(dev->uart, baudrate))
-    {
-        printf("%s: mraa_uart_set_baudrate() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    dev->baudrate = baudrate;
-
-    if (!rn2903_autobaud(dev, RN2903_AUTOBAUD_RETRIES))
-    {
-        printf("%s: rn2903_autobaud detection failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-void rn2903_set_debug(const rn2903_context dev, bool enable)
-{
-    assert(dev != NULL);
-
-    dev->debug = enable;
-}
-
-void rn2903_set_response_wait_time(const rn2903_context dev,
-                                   unsigned int wait_time)
-{
-    assert(dev != NULL);
-
-    dev->cmd_resp_wait_ms = wait_time;
-}
-
-void rn2903_set_response2_wait_time(const rn2903_context dev,
-                                    unsigned int wait_time)
-{
-    assert(dev != NULL);
-
-    dev->cmd_resp2_wait_ms = wait_time;
-}
-
-void rn2903_drain(const rn2903_context dev)
-{
-    assert(dev != NULL);
-
-    char resp[RN2903_MAX_BUFFER];
-    int rv;
-    while (rn2903_data_available(dev, 0))
-    {
-        rv = rn2903_read(dev, resp, RN2903_MAX_BUFFER);
-        if (rv < 0)
-        {
-            printf("%s: read failed\n", __FUNCTION__);
-            return;
-        }
-        // printf("%s: Tossed %d bytes\n", __FUNCTION__, rv);
-    }
-
-    return;
-}
-
-RN2903_RESPONSE_T rn2903_waitfor_response(const rn2903_context dev,
-                                          int wait_ms)
-{
-    assert(dev != NULL);
-
-    memset(dev->resp_data, 0, RN2903_MAX_BUFFER);
-    dev->resp_len = 0;
-
-    upm_clock_t clock = upm_clock_init();
-    uint32_t elapsed = 0;
-
-    do
-    {
-        if (rn2903_data_available(dev, 1))
-        {
-            int rv = rn2903_read(dev, &(dev->resp_data[dev->resp_len]), 1);
-
-            if (rv < 0)
-                return RN2903_RESPONSE_UPM_ERROR;
-
-            // discard CR's
-            if (dev->resp_data[dev->resp_len] == '\r')
-                continue;
-
-            // got a LF, we are done - discard and finish
-            if (dev->resp_data[dev->resp_len] == '\n')
-            {
-                dev->resp_data[dev->resp_len] = 0;
-                break;
-            }
-
-            // too much data?
-            if (dev->resp_len >= RN2903_MAX_BUFFER - 1)
-                break;
-
-            dev->resp_len++;
-        }
-    } while ( (int)(elapsed = upm_elapsed_ms(&clock)) < wait_ms);
-
-    if (dev->debug)
-        printf("\tRESP (%d): '%s'\n", (int)dev->resp_len,
-               (dev->resp_len) ? dev->resp_data : "");
-
-    // check for and return obvious errors
-    if ((int)elapsed >= wait_ms)
-        return RN2903_RESPONSE_TIMEOUT;
-    else if (rn2903_find(dev, RN2903_PHRASE_INV_PARAM))
-        return RN2903_RESPONSE_INVALID_PARAM;
-    else
-        return RN2903_RESPONSE_OK; // either data or "ok"
-}
-
-RN2903_RESPONSE_T rn2903_command(const rn2903_context dev, const char *cmd)
-{
-    assert(dev != NULL);
-    assert(cmd != NULL);
-
-    rn2903_drain(dev);
-
-    if (dev->debug)
-        printf("CMD: '%s'\n", cmd);
-
-    if (rn2903_write(dev, cmd, strlen(cmd)) < 0)
-    {
-        printf("%s: rn2903_write(cmd) failed\n", __FUNCTION__);
-        return RN2903_RESPONSE_UPM_ERROR;
-    }
-
-    // now write the termination string (CR/LF)
-    if (rn2903_write(dev, RN2903_PHRASE_TERM, RN2903_PHRASE_TERM_LEN) < 0)
-    {
-        printf("%s: rn2903_write(TERM) failed\n", __FUNCTION__);
-        return RN2903_RESPONSE_UPM_ERROR;
-    }
-
-    return rn2903_waitfor_response(dev, dev->cmd_resp_wait_ms);
-}
-
-RN2903_RESPONSE_T rn2903_command_with_arg(const rn2903_context dev,
-                                          const char *cmd, const char *arg)
-{
-    assert(dev != NULL);
-    assert(cmd != NULL);
-    assert(arg != NULL);
-
-    // cmd<space>arg<0-terminator>
-    int buflen = strlen(cmd) + 1 + strlen(arg) + 1;
-    char buf[buflen];
-    memset(buf, 0, buflen);
-
-    snprintf(buf, buflen, "%s %s", cmd, arg);
-
-    return rn2903_command(dev, buf);
-}
-
-const char *rn2903_get_response(const rn2903_context dev)
-{
-    assert(dev != NULL);
-
-    return dev->resp_data;
-}
-
-size_t rn2903_get_response_len(const rn2903_context dev)
-{
-    assert(dev != NULL);
-
-    return dev->resp_len;
-}
-
-const char *rn2903_to_hex(const rn2903_context dev, const char *src, int len)
-{
-    assert(dev != NULL);
-    assert(src != NULL);
-
-    static const char hdigits[16] = "0123456789ABCDEF";
-
-    // first free previous destination hex buffer if allocated
-    if (dev->to_hex_buf)
-    {
-        free(dev->to_hex_buf);
-        dev->to_hex_buf = NULL;
-    }
-
-    if (len == 0)
-        return NULL;
-
-    int dlen = (len * 2) + 1;
-
-    if (!(dev->to_hex_buf = malloc(dlen)))
-    {
-        printf("%s: malloc(%d) failed\n", __FUNCTION__, dlen);
-        return NULL;
-    }
-    memset(dev->to_hex_buf, 0, dlen);
-
-    char *dptr = dev->to_hex_buf;
-    char *sptr = (char *)src;
-    for (int i=0; i<len; i++)
-    {
-        *dptr++ = hdigits[(sptr[i] >> 4) & 0x0f];
-        *dptr++ = hdigits[(sptr[i] & 0x0f)];
-    }
-
-    // the memset() will have ensured the last byte is 0
-    return dev->to_hex_buf;
-}
-
-const char *rn2903_from_hex(const rn2903_context dev,
-                            const char *src)
-{
-    assert(dev != NULL);
-    assert(src != NULL);
-
-    // first free previous destination hex buffer if allocated
-    if (dev->from_hex_buf)
-    {
-        free(dev->from_hex_buf);
-        dev->from_hex_buf = NULL;
-    }
-
-    int len = strlen(src);
-    if (len == 0)
-        return NULL;
-
-    if (!validate_hex_str(src))
-        return NULL;
-
-    // add a byte for 0 termination, just in case we're decoding a
-    // string
-    int dlen = (len / 2) + 1;
-
-    if (!(dev->from_hex_buf = malloc(dlen)))
-    {
-        printf("%s: malloc(%d) failed\n", __FUNCTION__, dlen);
-        return NULL;
-    }
-    memset(dev->from_hex_buf, 0, dlen);
-
-    char *dptr = dev->from_hex_buf;
-    for (int i=0; i<(dlen - 1); i++)
-    {
-        char tbuf[3] = { src[i*2], src[(i*2)+1], 0 };
-        *dptr++ = (char)strtol(tbuf, NULL, 16);
-    }
-
-    return dev->from_hex_buf;
-}
-
-const char *rn2903_get_hardware_eui(const rn2903_context dev)
-{
-    assert(dev != NULL);
-
-    return dev->hardware_eui;
-}
-
-upm_result_t rn2903_update_mac_status(const rn2903_context dev)
-{
-    assert(dev != NULL);
-
-    if (rn2903_command(dev, "mac get status"))
-    {
-        printf("%s: rn2903_command(mac get status) failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // make sure we actually got a hex value of 4 bytes
-    if (!validate_hex_str(dev->resp_data) || dev->resp_len != 4)
-    {
-        printf("%s: invalid mac status.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // convert it
-    const char *statPtr = rn2903_from_hex(dev, dev->resp_data);
-    if (!statPtr)
-    {
-        printf("%s: from_hex conversion failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // now play pointer games.  We should have 2 bytes which we'll
-    // turn into a uint16_t (LE), which we will then stuff into our
-    // mac_status_word field in the context.
-    uint16_t status16 = (statPtr[0] << 8) | statPtr[1];
-
-    // store the mac_status_word, then decode the actual mac_status
-    // (state) enumeration
-
-    dev->mac_status_word = status16;
-    dev->mac_mac_status =
-        (RN2903_MAC_STATUS_T)((status16 & _SHIFTMASK(MAC_STATUS_MAC_STATUS))
-                              >> _SHIFT(MAC_STATUS_MAC_STATUS));
-
-    return UPM_SUCCESS;
-}
-
-uint16_t rn2903_get_mac_status_word(const rn2903_context dev)
-{
-    assert(dev != NULL);
-
-    return dev->mac_status_word;
-}
-
-RN2903_MAC_STATUS_T rn2903_get_mac_status(const rn2903_context dev)
-{
-    assert(dev != NULL);
-
-    return dev->mac_mac_status;
-}
-
-upm_result_t rn2903_reset(const rn2903_context dev)
-{
-    assert(dev != NULL);
-
-    rn2903_autobaud(dev, RN2903_AUTOBAUD_RETRIES);
-
-    if (rn2903_command(dev, "sys reset"))
-    {
-        // this command will reset the baudrate back to the default if
-        // we changed it previously.  We do not report an error here,
-        // if we are not using the default baudrate, since we've now
-        // switched to a different baudrate than we had, and cannot
-        // read the response anyway.
-        if (dev->baudrate == RN2903_DEFAULT_BAUDRATE)
-            return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // to be safe, always set the baudrate after a reset
-    if (rn2903_set_baudrate(dev, dev->baudrate))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    upm_delay_ms(100);
-
-    return UPM_SUCCESS;
-}
-
-RN2903_JOIN_STATUS_T rn2903_join(const rn2903_context dev,
-                                 RN2903_JOIN_TYPE_T type)
-{
-    assert(dev != NULL);
-
-    // first, do a couple of initial checks...
-
-    // get the mac status and ensure that 1) we are not already
-    // joined, 2) the mac status is idle, 3) we have not been
-    // silenced, and 4) MAC has not been paused.
-
-    if (rn2903_update_mac_status(dev))
-    {
-        printf("%s: rn2903_update_mac_status() failed\n", __FUNCTION__);
-        return RN2903_JOIN_STATUS_UPM_ERROR;
-    }
-
-    // if the radio is not idle, we aren't going anywhere
-    RN2903_MAC_STATUS_T mac_status = rn2903_get_mac_status(dev);
-    if (mac_status != RN2903_MAC_STAT_IDLE)
-        return RN2903_JOIN_STATUS_BUSY;
-
-    // now check the rest of the status bits...
-    uint16_t status = rn2903_get_mac_status_word(dev);
-    if (status & RN2903_MAC_STATUS_JOINED)
-        return RN2903_JOIN_STATUS_ALREADY_JOINED;
-    else if (status & RN2903_MAC_STATUS_SILENT)
-        return RN2903_JOIN_STATUS_SILENT;
-    else if (status & RN2903_MAC_STATUS_PAUSED)
-        return RN2903_JOIN_STATUS_MAC_PAUSED;
-
-    // so far, so good... now build the command
-
-    char cmd[RN2903_CMD_BUFFER_32B] = {};
-    snprintf(cmd, RN2903_CMD_BUFFER_32B, "mac join %s",
-             (type == RN2903_JOIN_TYPE_OTAA) ? "otaa" : "abp");
-
-    // run the command.  We will get two responses back - one
-    // immediately if there is an error or if the join operation was
-    // successfully submitted to the radio for transmission, and
-    // another indicating whether the join was granted, or failed.
-    // ABP joins will always succeed immediately.
-
-    RN2903_RESPONSE_T rv;
-    if ((rv = rn2903_command(dev, cmd)))
-    {
-        // a failure of some sort.  We've already screened for most of
-        // them, but there are a couple that we can't detect until we
-        // try (UPM).
-        printf("%s: join command failed (%d).\n", __FUNCTION__, rv);
-        return RN2903_JOIN_STATUS_UPM_ERROR;
-    }
-
-    // if we are here, then we either got an "ok" or another error we
-    // couldn't screen for.  Check for them.
-
-    if (rn2903_find(dev, "no_free_ch"))
-        return RN2903_JOIN_STATUS_NO_CHAN;
-    else if (rn2903_find(dev, "keys_not_init"))
-        return RN2903_JOIN_STATUS_BAD_KEYS;
-
-    // now we wait awhile for another response indicating whether the
-    // join request was accepted or not
-
-    if ((rv = rn2903_waitfor_response(dev, dev->cmd_resp2_wait_ms)))
-    {
-        printf("%s: join second response failed (%d).\n", __FUNCTION__, rv);
-        return RN2903_JOIN_STATUS_UPM_ERROR;
-    }
-
-    if (rn2903_find(dev, "denied"))
-        return RN2903_JOIN_STATUS_DENIED;
-    else if (rn2903_find(dev, "accepted"))
-        return RN2903_JOIN_STATUS_ACCEPTED;
-
-    // if it's anything else, we failed :(
-    printf("%s: unexpected response to join request.\n", __FUNCTION__);
-
-    return RN2903_JOIN_STATUS_UPM_ERROR;
-}
-
-upm_result_t rn2903_set_flow_control(const rn2903_context dev,
-                                     RN2903_FLOW_CONTROL_T fc)
-{
-    assert(dev != NULL);
-
-    mraa_result_t rv = MRAA_SUCCESS;
-
-    switch(fc)
-    {
-    case RN2903_FLOW_CONTROL_NONE:
-        rv = mraa_uart_set_flowcontrol(dev->uart, false, false);
-        break;
-
-    case RN2903_FLOW_CONTROL_HARD:
-        rv = mraa_uart_set_flowcontrol(dev->uart, false, true);
-        break;
-
-    default:
-        return UPM_ERROR_INVALID_PARAMETER;
-    }
-
-    if (rv == MRAA_SUCCESS)
-        return UPM_SUCCESS;
-    else
-        return UPM_ERROR_OPERATION_FAILED;
-}
-
-bool rn2903_find(const rn2903_context dev, const char *str)
-{
-    assert(dev != NULL);
-    assert(str != NULL);
-
-    return ((strstr(dev->resp_data, str) == dev->resp_data) ? true : false);
-}
-
-upm_result_t rn2903_set_device_eui(const rn2903_context dev,
-                                   const char *str)
-{
-    assert(dev != NULL);
-    assert(str != NULL);
-
-    // first verify that the string is a valid hex string of the right
-    // size (16 bytes for the 8 byte EUI)
-
-    if (!validate_hex_str(str) || strlen(str) != 16)
-    {
-        printf("%s: invalid 16 byte device EUI hex string.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    if (rn2903_command_with_arg(dev, "mac set deveui", str))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t rn2903_get_device_eui(const rn2903_context dev)
-{
-    assert(dev != NULL);
-
-    if (rn2903_command(dev, "mac get deveui"))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t rn2903_set_application_eui(const rn2903_context dev,
-                                        const char *str)
-{
-    assert(dev != NULL);
-    assert(str != NULL);
-
-    // first verify that the string is a valid hex string of the right
-    // size (16 bytes for the 8 byte EUI)
-
-    if (!validate_hex_str(str) || strlen(str) != 16)
-    {
-        printf("%s: invalid 16 byte application EUI hex string.\n",
-               __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    if (rn2903_command_with_arg(dev, "mac set appeui", str))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t rn2903_get_application_eui(const rn2903_context dev)
-{
-    assert(dev != NULL);
-
-    if (rn2903_command(dev, "mac get appeui"))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t rn2903_set_application_key(const rn2903_context dev,
-                                        const char *str)
-{
-    assert(dev != NULL);
-    assert(str != NULL);
-
-    // first verify that the string is a valid hex string of the right
-    // size (32 bytes for the 16 byte key)
-
-    if (!validate_hex_str(str) || strlen(str) != 32)
-    {
-        printf("%s: invalid 32 byte application key hex string.\n",
-               __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    if (rn2903_command_with_arg(dev, "mac set appkey", str))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t rn2903_get_application_key(const rn2903_context dev)
-{
-    assert(dev != NULL);
-
-    if (rn2903_command(dev, "mac get appkey"))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t rn2903_set_device_addr(const rn2903_context dev,
-                                    const char *str)
-{
-    assert(dev != NULL);
-    assert(str != NULL);
-
-    // first verify that the string is a valid hex string of the right
-    // size (8 bytes for the 4 byte key)
-
-    if (!validate_hex_str(str) || strlen(str) != 8)
-    {
-        printf("%s: invalid 8 byte device addr hex string.\n",
-               __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    if (rn2903_command_with_arg(dev, "mac set devaddr", str))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t rn2903_get_device_addr(const rn2903_context dev)
-{
-    assert(dev != NULL);
-
-    if (rn2903_command(dev, "mac get devaddr"))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t rn2903_set_network_session_key(const rn2903_context dev,
-                                            const char *str)
-{
-    assert(dev != NULL);
-    assert(str != NULL);
-
-    // first verify that the string is a valid hex string of the right
-    // size (32 bytes for the 16 byte key)
-
-    if (!validate_hex_str(str) || strlen(str) != 32)
-    {
-        printf("%s: invalid 32 byte network session key hex string.\n",
-               __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    if (rn2903_command_with_arg(dev, "mac set nwkskey", str))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t rn2903_set_application_session_key(const rn2903_context dev,
-                                                const char *str)
-{
-    assert(dev != NULL);
-    assert(str != NULL);
-
-    // first verify that the string is a valid hex string of the right
-    // size (32 bytes for the 16 byte key)
-
-    if (!validate_hex_str(str) || strlen(str) != 32)
-    {
-        printf("%s: invalid 32 byte application session key hex string.\n",
-               __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    if (rn2903_command_with_arg(dev, "mac set appskey", str))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t rn2903_mac_save(const rn2903_context dev)
-{
-    assert(dev != NULL);
-
-    if (rn2903_command(dev, "mac save"))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t rn2903_mac_pause(const rn2903_context dev)
-{
-    assert(dev != NULL);
-
-    if (rn2903_command(dev, "mac pause"))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t rn2903_mac_resume(const rn2903_context dev)
-{
-    assert(dev != NULL);
-
-    if (rn2903_command(dev, "mac resume"))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-RN2903_MAC_TX_STATUS_T rn2903_mac_tx(const rn2903_context dev,
-                                     RN2903_MAC_MSG_TYPE_T type,
-                                     int port, const char *payload)
-{
-    assert(dev != NULL);
-    assert(payload != NULL);
-
-    // check some things
-
-    // port can only be between 1 and 223
-    if (port < 1 || port > 223)
-    {
-        printf("%s: port must be between 1 and 223\n", __FUNCTION__);
-        return RN2903_MAC_TX_STATUS_UPM_ERROR;
-    }
-
-    // make sure payload is a valid hex string
-    if (!validate_hex_str(payload))
-    {
-        printf("%s: payload is not a valid hex string\n", __FUNCTION__);
-        return RN2903_MAC_TX_STATUS_UPM_ERROR;
-    }
-
-    // get the mac status and ensure that 1) we are joined to a
-    // LoRaWAN network, 2) the mac status is idle, 3) we have not been
-    // silenced, and 4) MAC has not been paused.
-
-    if (rn2903_update_mac_status(dev))
-    {
-        printf("%s: rn2903_update_mac_status() failed\n", __FUNCTION__);
-        return RN2903_MAC_TX_STATUS_UPM_ERROR;
-    }
-
-    // if the radio is not idle, we aren't going anywhere
-    RN2903_MAC_STATUS_T mac_status = rn2903_get_mac_status(dev);
-    if (mac_status != RN2903_MAC_STAT_IDLE)
-        return RN2903_MAC_TX_STATUS_BUSY;
-
-    // now check the rest of the status bits...
-    uint16_t status = rn2903_get_mac_status_word(dev);
-    if (!(status & RN2903_MAC_STATUS_JOINED))
-        return RN2903_MAC_TX_STATUS_NOT_JOINED;
-    else if (status & RN2903_MAC_STATUS_SILENT)
-        return RN2903_MAC_TX_STATUS_SILENT;
-    else if (status & RN2903_MAC_STATUS_PAUSED)
-        return RN2903_MAC_TX_STATUS_MAC_PAUSED;
-
-    // good so far, build and send the command.  Then we check for
-    // more things.
-
-    char cmd[RN2903_CMD_BUFFER_32B] = {};
-    snprintf(cmd, RN2903_CMD_BUFFER_32B, "mac tx %s %d",
-             (type == RN2903_MAC_MSG_TYPE_CONFIRMED) ? "cnf" : "uncnf",
-             port);
-
-    RN2903_RESPONSE_T rv;
-    if ((rv = rn2903_command_with_arg(dev, cmd, payload)))
-    {
-        printf("%s: mac tx command failed (%d).\n", __FUNCTION__, rv);
-        return RN2903_MAC_TX_STATUS_UPM_ERROR;
-    }
-
-    // now check for some other things we couldn't check before
-    if (rn2903_find(dev, "no_free_ch"))
-        return RN2903_MAC_TX_STATUS_NO_CHAN;
-    else if (rn2903_find(dev, "frame_counter_err_rejoin_needed"))
-        return RN2903_MAC_TX_STATUS_FC_NEED_REJOIN;
-    else if (rn2903_find(dev, "invalid_data_len"))
-        return RN2903_MAC_TX_STATUS_BAD_DATA_LEN;
-
-    // now we wait for transmission to complete, and a possible
-    // downlink packet.
-
-    if ((rv = rn2903_waitfor_response(dev, dev->cmd_resp2_wait_ms)))
-    {
-        printf("%s: mac tx second response failed (%d).\n", __FUNCTION__, rv);
-        return RN2903_MAC_TX_STATUS_UPM_ERROR;
-    }
-
-    if (rn2903_find(dev, "mac_tx_ok"))
-        return RN2903_MAC_TX_STATUS_TX_OK;
-    else if (rn2903_find(dev, "mac_err"))
-        return RN2903_MAC_TX_STATUS_MAC_ERR;
-    else if (rn2903_find(dev, "invalid_data_len"))
-        return RN2903_MAC_TX_STATUS_BAD_DATA_LEN;
-    else if (rn2903_find(dev, "mac_rx"))
-        return RN2903_MAC_TX_STATUS_RX_RECEIVED; // we got a downlink
-                                                 // packet in the
-                                                 // response buffer
-
-    // if it's anything else, we failed :(
-    printf("%s: unexpected response to mac tx command\n", __FUNCTION__);
-
-    return RN2903_MAC_TX_STATUS_UPM_ERROR;
-}
-
-RN2903_RESPONSE_T rn2903_radio_tx(const rn2903_context dev,
-                                  const char *payload)
-{
-    assert(dev != NULL);
-    assert(payload != NULL);
-
-    // check some things
-
-    // make sure payload is a valid hex string
-    if (!validate_hex_str(payload))
-    {
-        printf("%s: payload is not a valid hex string\n", __FUNCTION__);
-        return RN2903_RESPONSE_UPM_ERROR;
-    }
-
-    // get the mac status and ensure that we are paused
-    if (rn2903_update_mac_status(dev))
-    {
-        printf("%s: rn2903_update_mac_status() failed\n", __FUNCTION__);
-        return RN2903_RESPONSE_UPM_ERROR;
-    }
-
-    uint16_t status = rn2903_get_mac_status_word(dev);
-    if (!(status & RN2903_MAC_STATUS_PAUSED))
-    {
-        printf("%s: MAC must be paused first\n", __FUNCTION__);
-        return RN2903_RESPONSE_UPM_ERROR;
-    }
-
-    // good so far, build and send the command
-
-    RN2903_RESPONSE_T rv;
-    if ((rv = rn2903_command_with_arg(dev, "radio tx", payload)))
-    {
-        printf("%s: radio tx command failed (%d).\n", __FUNCTION__, rv);
-        return rv;
-    }
-
-    // we're done
-    return RN2903_RESPONSE_OK;
-}
-
-RN2903_RESPONSE_T rn2903_radio_rx(const rn2903_context dev,
-                                  int window_size)
-{
-    assert(dev != NULL);
-
-    // check some things
-
-    // get the mac status and ensure that we are paused
-    if (rn2903_update_mac_status(dev))
-    {
-        printf("%s: rn2903_update_mac_status() failed\n", __FUNCTION__);
-        return RN2903_RESPONSE_UPM_ERROR;
-    }
-
-    uint16_t status = rn2903_get_mac_status_word(dev);
-    if (!(status & RN2903_MAC_STATUS_PAUSED))
-    {
-        printf("%s: MAC must be paused first\n", __FUNCTION__);
-        return RN2903_RESPONSE_UPM_ERROR;
-    }
-
-    // good so far, build and send the command
-
-    char cmd[RN2903_CMD_BUFFER_32B] = {};
-    snprintf(cmd, RN2903_CMD_BUFFER_32B, "radio rx %d", window_size);
-
-    RN2903_RESPONSE_T rv;
-    if ((rv = rn2903_command(dev, cmd)))
-    {
-        printf("%s: radio tx command failed (%d).\n", __FUNCTION__, rv);
-        return rv;
-    }
-
-    // now, wait for and return the second response
-    return rn2903_waitfor_response(dev, dev->cmd_resp2_wait_ms);
-}
-
-upm_result_t rn2903_mac_set_battery(const rn2903_context dev, int level)
-{
-    assert(dev != NULL);
-
-    if (level < 0 || level > 255)
-    {
-        printf("%s: level must be between 0 and 255\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    char cmd[RN2903_CMD_BUFFER_32B] = {};
-    snprintf(cmd, RN2903_CMD_BUFFER_32B, "mac set bat %d", level);
-
-    RN2903_RESPONSE_T rv;
-    if ((rv = rn2903_command(dev, cmd)))
-    {
-        printf("%s: mac tx command failed (%d).\n", __FUNCTION__, rv);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-bool rn2903_autobaud(const rn2903_context dev, int retries)
-{
-    assert(dev != NULL);
-
-    do
-    {
-        // trigger rn2903 auto-baud detection
-
-        // send a break signal, then a 0x55, then try a command
-        mraa_result_t rv;
-        if ((rv = mraa_uart_sendbreak(dev->uart, 0)))
-        {
-            // we don't want to fail here if break not implemented or
-            // supported
-            if (rv != MRAA_ERROR_FEATURE_NOT_IMPLEMENTED &&
-                rv != MRAA_ERROR_FEATURE_NOT_SUPPORTED)
-            {
-
-                printf("%s: mraa_uart_sendbreak() failed.\n", __FUNCTION__);
-                return UPM_ERROR_OPERATION_FAILED;
-            }
-        }
-
-        upm_delay_ms(100);
-
-        // The magic autobaud detection character
-        char buf = 0x55;
-        rn2903_write(dev, &buf, 1);
-
-        upm_delay_ms(100);
-
-        // try a command to verify speed
-        if (!rn2903_command(dev, "sys get ver"))
-            break;
-
-        if (dev->debug)
-            printf("%s: RETRIES %d: FAIL!\n", __FUNCTION__, retries);
-    } while (retries-- > 0);
-
-    if (retries <= 0)
-        return false;
-
-    if (dev->debug)
-        printf("%s: RETRIES %d: success!\n", __FUNCTION__, retries);
-
-    return true;
-}
-
-const char *rn2903_get_radio_rx_payload(const rn2903_context dev)
-{
-    assert(dev != NULL);
-
-    // first make sure we have the right data in the response buffer.
-    // The response buffer should contain "radio_rx<sp><sp><hex_payload>"
-    // (note the two spaces between radio_rx and the payload.)
-    if (rn2903_find(dev, "radio_rx") || dev->resp_len > 10)
-        return &(dev->resp_data[10]);
-
-    return NULL;
-}
diff --git a/src/rn2903/rn2903.cxx b/src/rn2903/rn2903.cxx
deleted file mode 100644
index 83c5bdb..0000000
--- a/src/rn2903/rn2903.cxx
+++ /dev/null
@@ -1,334 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <stdexcept>
-#include <string.h>
-
-#include "rn2903.hpp"
-
-using namespace upm;
-using namespace std;
-
-RN2903::RN2903(unsigned int uart, unsigned int baudrate) :
-    m_rn2903(rn2903_init(uart, baudrate))
-{
-    if (!m_rn2903)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": rn2903_init() failed");
-}
-
-RN2903::RN2903(string uart_path, unsigned int baudrate) :
-    m_rn2903(rn2903_init_tty(uart_path.c_str(), baudrate))
-{
-    if (!m_rn2903)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": rn2903_init_tty() failed");
-}
-
-RN2903::~RN2903()
-{
-    rn2903_close(m_rn2903);
-}
-
-std::string RN2903::read(int size)
-{
-    char buffer[size];
-
-    int rv;
-
-    if ((rv = rn2903_read(m_rn2903, buffer, (size_t)size)) < 0)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": rn2903_read() failed");
-
-    return string(buffer, rv);
-}
-
-int RN2903::write(std::string buffer)
-{
-    int rv;
-
-    if ((rv = rn2903_write(m_rn2903, (char*)buffer.data(),
-                           buffer.size())) < 0)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": rn2903_write() failed");
-
-    return rv;
-}
-
-void RN2903::setResponseWaitTime(unsigned int wait_time)
-{
-    rn2903_set_response_wait_time(m_rn2903, wait_time);
-}
-
-void RN2903::setResponse2WaitTime(unsigned int wait_time)
-{
-    rn2903_set_response2_wait_time(m_rn2903, wait_time);
-}
-
-bool RN2903::dataAvailable(unsigned int millis)
-{
-    return rn2903_data_available(m_rn2903, millis);
-}
-
-void RN2903::drain()
-{
-    rn2903_drain(m_rn2903);
-    return;
-}
-
-RN2903_RESPONSE_T RN2903::command(const std::string cmd)
-{
-    return rn2903_command(m_rn2903, cmd.c_str());
-}
-
-RN2903_RESPONSE_T RN2903::commandWithArg(const std::string cmd,
-                                         const std::string arg)
-
-{
-    return rn2903_command_with_arg(m_rn2903, cmd.c_str(), arg.c_str());
-}
-
-RN2903_RESPONSE_T RN2903::waitForResponse(int wait_ms)
-{
-    return rn2903_waitfor_response(m_rn2903, wait_ms);
-}
-
-std::string RN2903::getResponse()
-{
-    return string(rn2903_get_response(m_rn2903),
-                  rn2903_get_response_len(m_rn2903));
-}
-
-int RN2903::getResponseLen()
-{
-    return rn2903_get_response_len(m_rn2903);
-}
-
-void RN2903::setDeviceEUI(const std::string str)
-{
-    if (rn2903_set_device_eui(m_rn2903, str.c_str()))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": rn2903_set_device_eui() failed");
-}
-
-void RN2903::getDeviceEUI()
-{
-    if (rn2903_get_device_eui(m_rn2903))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": rn2903_get_device_eui() failed");
-}
-
-void RN2903::setNetworkSessionKey(const std::string str)
-{
-    if (rn2903_set_network_session_key(m_rn2903, str.c_str()))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": rn2903_set_network_session_key() failed");
-}
-
-void RN2903::setApplicationSessionKey(const std::string str)
-{
-    if (rn2903_set_application_session_key(m_rn2903, str.c_str()))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": rn2903_set_application_session_key() failed");
-}
-
-void RN2903::setApplicationEUI(const std::string str)
-{
-    if (rn2903_set_application_eui(m_rn2903, str.c_str()))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": rn2903_set_application_eui() failed");
-}
-
-void RN2903::getApplicationEUI()
-{
-    if (rn2903_get_application_eui(m_rn2903))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": rn2903_get_application_eui() failed");
-}
-
-void RN2903::setApplicationKey(const std::string str)
-{
-    if (rn2903_set_application_key(m_rn2903, str.c_str()))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": rn2903_set_application_key() failed");
-}
-
-void RN2903::getApplicationKey()
-{
-    if (rn2903_get_application_key(m_rn2903))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": rn2903_get_application_key() failed");
-}
-
-void RN2903::setDeviceAddr(const std::string str)
-{
-    if (rn2903_set_device_addr(m_rn2903, str.c_str()))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": rn2903_set_device_addr() failed");
-}
-
-void RN2903::getDeviceAddr()
-{
-   if (rn2903_get_device_addr(m_rn2903))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": rn2903_get_device_addr() failed");
-}
-
-std::string RN2903::toHex(const std::string src)
-{
-    const char *buf = rn2903_to_hex(m_rn2903, src.c_str(), src.size());
-
-    if (!buf)
-        return string("");
-    else
-        return string(buf);
-}
-
-std::string RN2903::fromHex(const std::string src)
-{
-    const char *buf = rn2903_from_hex(m_rn2903, src.c_str());
-
-    if (!buf)
-        return string("");
-    else
-        return string(buf);
-}
-
-RN2903_JOIN_STATUS_T RN2903::join(RN2903_JOIN_TYPE_T type)
-{
-    return rn2903_join(m_rn2903, type);
-}
-
-RN2903_MAC_TX_STATUS_T RN2903::macTx(RN2903_MAC_MSG_TYPE_T type, int port,
-                                     std::string payload)
-{
-    return rn2903_mac_tx(m_rn2903, type, port, payload.c_str());
-}
-
-RN2903_RESPONSE_T RN2903::radioTx(const std::string payload)
-{
-    return rn2903_radio_tx(m_rn2903, payload.c_str());
-}
-
-RN2903_RESPONSE_T RN2903::radioRx(int window_size)
-{
-    return rn2903_radio_rx(m_rn2903, window_size);
-}
-
-std::string RN2903::getHardwareEUI()
-{
-    return string(rn2903_get_hardware_eui(m_rn2903));
-}
-
-void RN2903::updateMacStatus()
-{
-    if (rn2903_update_mac_status(m_rn2903))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": rn2903_update_mac_status() failed");
-}
-
-int RN2903::getMacStatusWord()
-{
-    return int(rn2903_get_mac_status_word(m_rn2903));
-}
-
-RN2903_MAC_STATUS_T RN2903::getMacStatus()
-{
-    return rn2903_get_mac_status(m_rn2903);
-}
-
-void RN2903::macSave()
-{
-    if (rn2903_mac_save(m_rn2903))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": rn2903_mac_save() failed");
-}
-
-void RN2903::macPause()
-{
-    if (rn2903_mac_pause(m_rn2903))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": rn2903_mac_pause() failed");
-}
-
-void RN2903::macResume()
-{
-    if (rn2903_mac_resume(m_rn2903))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": rn2903_mac_resume() failed");
-}
-
-void RN2903::reset()
-{
-    if (rn2903_reset(m_rn2903))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": rn2903_reset() failed");
-}
-
-void RN2903::macSetBattery(int level)
-{
-    if (rn2903_mac_set_battery(m_rn2903, level))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": rn2903_mac_set_battery() failed");
-}
-
-void RN2903::setDebug(bool enable)
-{
-    rn2903_set_debug(m_rn2903, enable);
-}
-
-void RN2903::setBaudrate(unsigned int baudrate)
-{
-    if (rn2903_set_baudrate(m_rn2903, baudrate))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": rn2903_set_baudrate() failed");
-}
-
-void RN2903::setFlowControl(RN2903_FLOW_CONTROL_T fc)
-{
-    if (rn2903_set_flow_control(m_rn2903, fc))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": rn2903_set_flow_control() failed");
-}
-
-bool RN2903::find(const std::string str)
-{
-    return rn2903_find(m_rn2903, str.c_str());
-}
-
-std::string RN2903::getRadioRxPayload()
-{
-    const char *payload = rn2903_get_radio_rx_payload(m_rn2903);
-
-    if (!payload)
-        return string("");
-    else
-        return string(payload);
-}
-
-bool RN2903::autobaud(int retries)
-{
-    return rn2903_autobaud(m_rn2903, retries);
-}
diff --git a/src/rn2903/rn2903.h b/src/rn2903/rn2903.h
deleted file mode 100644
index 5e57802..0000000
--- a/src/rn2903/rn2903.h
+++ /dev/null
@@ -1,718 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <stdint.h>
-#include <stdlib.h>
-#include <unistd.h>
-
-#include <upm.h>
-#include <mraa/uart.h>
-
-#include "rn2903_defs.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    /**
-     * @file rn2903.h
-     * @library rn2903
-     * @brief Generic API for the Microchip RN2903 LoRa Radio
-     *
-     */
-
-    /**
-     * Device context
-     */
-    typedef struct _rn2903_context {
-        mraa_uart_context        uart;
-        // store the baudrate
-        int                      baudrate;
-
-        // response data buffer, stripped of CR/LF
-        char                     resp_data[RN2903_MAX_BUFFER];
-        // length of response data
-        size_t                   resp_len;
-
-        // these are allocated buffers we use manage and reuse
-        // internally to store conversions from/to hex and back
-        char                     *to_hex_buf;
-        char                     *from_hex_buf;
-
-        // maximum time to wait for a response after a command is
-        // submitted
-        int                      cmd_resp_wait_ms;
-
-        // maximum time to wait for a second response after a command is
-        // submitted
-        int                      cmd_resp2_wait_ms;
-
-        // debugging output
-        bool                     debug;
-
-        // our hardware hex encoded EUI + terminating NULL
-        char                     hardware_eui[RN2903_MAX_HEX_EUI64 + 1];
-
-        // 16b mac status word
-        uint16_t                 mac_status_word;
-        // this is the mac_status bitfield of the mac status word
-        RN2903_MAC_STATUS_T      mac_mac_status;
-    } *rn2903_context;
-
-    /**
-     * RN2903 Initializer for UART operation using a UART index
-     *
-     * @param uart Specify which uart to use
-     * @param baudrate Specify the baudrate to use.  57600 is the
-     * default baudrate of this device.
-     * @return an initialized device context on success, NULL on error
-     */
-    rn2903_context rn2903_init(unsigned int uart, unsigned int baudrate);
-
-    /**
-     * RN2903 Initializer for UART operation using a filesystem tty
-     * path (eg. /dev/ttyUSB0)
-     *
-     * @param uart_tty character string representing a filesystem path to a
-     * serial tty device
-     * @param baudrate Specify the baudrate to use.  57600 is the
-     * default baudrate of this device.
-     * @return an initialized device context on success, NULL on error
-     */
-    rn2903_context rn2903_init_tty(const char *uart_tty, unsigned int baudrate);
-
-    /**
-     * RN2903 sensor close function
-     *
-     * @param dev Device context
-     */
-    void rn2903_close(rn2903_context dev);
-
-    /**
-     * Set the default time, in milliseconds, to wait for a response
-     * after sending a command.  All commands return at least one
-     * response immediately after issuing the command.  This delay
-     * sets the maximum amount of time to wait for it.
-     *
-     * @param dev Device context
-     * @param wait_ms The response delay to set, in milliseconds.
-     */
-    void rn2903_set_response_wait_time(const rn2903_context dev,
-                                       unsigned int wait_ms);
-
-    /**
-     * Set the default time, in milliseconds, to wait for the second
-     * response data to arrive.  Some commands will have a second
-     * response emitted after the first response.  This delay sets the
-     * maximum amount of time to wait for it.
-     *
-     * @param dev Device context
-     * @param wait_ms The response delay to set, in milliseconds.
-     */
-    void rn2903_set_response2_wait_time(const rn2903_context dev,
-                                        unsigned int wait_ms);
-
-    /**
-     * Determine whether there is data available to be read.  This
-     * function will wait up to "millis" milliseconds for data to
-     * become available.
-     *
-     * @param dev Device context
-     * @param millis The number of milliseconds to wait for data to
-     * become available
-     * @return true if data is available to be read, false otherwise
-     */
-    bool rn2903_data_available(const rn2903_context dev,
-                               unsigned int millis);
-
-    /**
-     * Read and throw away any data currently available to be read.
-     * This is useful to avoid reading data that might have been the
-     * result of a previous command interfering with data you
-     * currently want to read.
-     *
-     * @param dev Device context
-     */
-    void rn2903_drain(const rn2903_context dev);
-
-    /**
-     * Send a command, wait for a response using
-     * rn2903_waitfor_response(), and return the status.  The response
-     * itself will be stored internally, and can be retrieved using
-     * rm2903_get_response() and rn2903_get_response_len().  Every
-     * command will return at least one response, and this function
-     * will always wait for it and store it after sending the command.
-     *
-     * @param dev Device context
-     * @param cmd A character string containing the command to
-     * send
-     * @return One of the RN2903_RESPONSE_T values
-     */
-    RN2903_RESPONSE_T rn2903_command(const rn2903_context dev,
-                                     const char *cmd);
-
-    /**
-     * Build a command string with the supplied command and string
-     * argument.  Then call rn2903_command() with the result, and
-     * return the result.  This is just a convenience function.
-     *
-     * @param dev Device context
-     * @param cmd A character string containing the command to
-     * send
-     * @param arg A string argument for the command
-     * @return One of the RN2903_RESPONSE_T values
-     */
-    RN2903_RESPONSE_T rn2903_command_with_arg(const rn2903_context dev,
-                                              const char *cmd,
-                                              const char *arg);
-
-    /**
-     * Wait up to wait_ms milliseconds for a response.
-     *
-     * In the case of errors ("invalid_param" received, timeout
-     * occurred, or other UPM specific error), this will be indicated
-     * by the return value.
-     *
-     * Otherwise, an "ok" or other data value will not be considered
-     * an error and will return RN2903_RESPONSE_OK.  The response
-     * itself will be stored internally, and can be retrieved using
-     * rm2903_get_response() and rn2903_get_response_len().
-     *
-     * NOTE: the response buffer is overwritten whenever this function
-     * is called, so if there is data in there that you need to save,
-     * copy it somewhere else before calling any other functions in
-     * this driver to be safe.
-     *
-     * @param dev Device context
-     * @param wait_ms The maximum number of milliseconds to wait for a
-     * response.
-     * @return One of the RN2903_RESPONSE_T values
-     */
-    RN2903_RESPONSE_T rn2903_waitfor_response(const rn2903_context dev,
-                                              int wait_ms);
-
-    /**
-     * Return a pointer to a string containing the last response.  If
-     * you wish to save the response for later, you will need to copy
-     * it somewhere before calling rn2903_command(),
-     * rn2903_command_with_arg() or rn2903_waitfor_response(), as
-     * these functions will overwrite the internally stored response
-     * buffer each time they are called.
-     *
-     * @param dev Device context
-     * @return A const pointer to a string containing the last response.
-     */
-    const char *rn2903_get_response(const rn2903_context dev);
-
-    /**
-     * Return the length in bytes of the string containing the last
-     * response.  If you wish to save the response length for later,
-     * you will need to copy it somewhere before calling
-     * rn2903_command() or rn2903_waitfor_respnse(), as these
-     * functions will overwrite the internally stored response length
-     * each time they are called.
-     *
-     * @param dev Device context
-     * @return The length of the last response in bytes
-     */
-    size_t rn2903_get_response_len(const rn2903_context dev);
-
-    /**
-     * Set the MAC device EUI for LoRaWAN communications.  The device
-     * EUI must be a hex encoded string of 16 bytes.  This value must
-     * be set for LoRaWAN OTAA joining.
-     *
-     * @param dev Device context
-     * @param str The 16-byte hex encoded device EUI
-     * @return UPM result
-     */
-    upm_result_t rn2903_set_device_eui(const rn2903_context dev,
-                                       const char *str);
-
-    /**
-     * Retrieve the device EUI from the device.  If this function
-     * succeeds, you can then use rn2903_get_response() to get the
-     * value.
-     *
-     * @param dev Device context
-     * @return UPM result
-     */
-    upm_result_t rn2903_get_device_eui(const rn2903_context dev);
-
-    /**
-     * Set the MAC application EUI for LoRaWAN communications.  The
-     * application EUI must be a hex encoded string of 16 bytes.  This
-     * value must be set for LoRaWAN OTAA joining.
-     *
-     * @param dev Device context
-     * @param str The 16-byte hex encoded application EUI
-     * @return UPM result
-     */
-    upm_result_t rn2903_set_application_eui(const rn2903_context dev,
-                                            const char *str);
-
-    /**
-     * Retrieve the application EUI from the device.  If this function
-     * succeeds, you can then use rn2903_get_response() to get the
-     * value.
-     *
-     * @param dev Device context
-     * @return UPM result
-     */
-    upm_result_t rn2903_get_application_eui(const rn2903_context dev);
-
-    /**
-     * Set the MAC application key for LoRaWAN communications.  The
-     * application key must be a hex encoded string of 32 bytes.  This
-     * value must be set for LoRaWAN OTAA joining.
-     *
-     * @param dev Device context
-     * @param str The 32-byte hex encoded application key
-     * @return UPM result
-     */
-    upm_result_t rn2903_set_application_key(const rn2903_context dev,
-                                            const char *str);
-
-    /**
-     * Retrieve the application key from the device.  If this function
-     * succeeds, you can then use rn2903_get_response() to get the
-     * value.
-     *
-     * @param dev Device context
-     * @return UPM result
-     */
-    upm_result_t rn2903_get_application_key(const rn2903_context dev);
-
-    /**
-     * Set the MAC device address for LoRaWAN communications.  The
-     * device address must be a hex encoded string of 8 bytes.  This
-     * value must be set for LoRaWAN ABP joining.
-     *
-     * For OTAA joining, this value will be overwritten once the join
-     * has completed, and therefore must not be set if performing an
-     * OTAA join.
-     *
-     * @param dev Device context
-     * @param str The 8-byte hex encoded device address
-     * @return UPM result
-     */
-    upm_result_t rn2903_set_device_addr(const rn2903_context dev,
-                                        const char *str);
-
-    /**
-     * Retrieve the device address from the device.  If this function
-     * succeeds, you can then use rn2903_get_response() to get the
-     * value.
-     *
-     * @param dev Device context
-     * @return UPM result
-     */
-    upm_result_t rn2903_get_device_addr(const rn2903_context dev);
-
-    /**
-     * Set the MAC network session key for LoRaWAN communications.
-     * The network session key must be a hex encoded string of 32
-     * bytes.  This value must be set for LoRaWAN ABP joining.  It it
-     * not possible to retrieve this key.
-     *
-     * For OTAA joining, this value will be overwritten once the join
-     * has completed, and therefore must not be set if performing an
-     * OTAA join.
-     *
-     * @param dev Device context
-     * @param str The 32-byte hex encoded network session key
-     * @return UPM result
-     */
-    upm_result_t rn2903_set_network_session_key(const rn2903_context dev,
-                                                const char *str);
-
-    /**
-     * Set the MAC application session key for LoRaWAN communications.
-     * The application session key must be a hex encoded string of 32
-     * bytes.  This value must be set for LoRaWAN ABP joining.  It it
-     * not possible to retrieve this key.
-     *
-     * For OTAA joining, this value will be overwritten once the join
-     * has completed, and therefore must not be set if performing an
-     * OTAA join.
-     *
-     * @param dev Device context
-     * @param str The 32-byte hex encoded application session key
-     * @return UPM result
-     */
-    upm_result_t rn2903_set_application_session_key(const rn2903_context dev,
-                                                    const char *str);
-
-    /**
-     * Convert src into a hex byte string.  All non-command related
-     * data such as keys, and payload sent to the device must be hex
-     * encoded.  The buffers used for this conversion are managed
-     * internally, so do not call free() on the returned pointer.  If
-     * you need to keep a copy of the resulting hex string, copy it
-     * somewhere before calling this function again.
-     *
-     * @param dev Device context
-     * @param src A char pointer pointing to the byte array to encode
-     * @param len The length in bytes of the data to encode
-     * @return A const pointer to the resulting hex string, or NULL if
-     * there was an error.
-     */
-    const char *rn2903_to_hex(const rn2903_context dev,
-                              const char *src, int len);
-
-    /**
-     * Convert a hex byte string into an array of bytes.  The hex
-     * string must have a length (not including the 0 terminator) that
-     * is a multiple of two, and all characters in the string must be
-     * valid hex characters.  The buffers used for this conversion are
-     * managed internally, so do not call free() on the returned
-     * pointer.  If you need to keep a copy of the resulting data byte
-     * array, copy it somewhere before calling this function again.
-     * The length of the returned data will be the length of the hex
-     * source string divided by 2, with a 0 byte terminator at the end
-     * in case a text string is being decoded.
-     *
-     * @param dev Device context
-     * @return A const pointer to the resulting data string, or NULL if
-     * there was an error
-     */
-    const char *rn2903_from_hex(const rn2903_context dev,
-                                const char *src);
-
-    /**
-     * Join a LoRaWAN network.  There are two types of joins possible
-     * - Over The Air Activation (OTAA) and Activation by
-     * Personalization (ABP).  Each join method requires that certain
-     * items have been configured first.
-     *
-     * For OTAA activation, the Device Extended Unique Identifier
-     * (EUI), the Application EUI, and Application Key must be set.
-     *
-     * For ABP activation, The Device Address, Network Session Key,
-     * and the Application Session Key must be set.
-     *
-     * @param dev Device context
-     * @param type The LoRaWAN activation type, one of the
-     * RN2903_JOIN_TYPE_T values
-     * @return The status of the join, one of the RN2903_JOIN_STATUS_T
-     * values
-     */
-    RN2903_JOIN_STATUS_T rn2903_join(const rn2903_context dev,
-                                     RN2903_JOIN_TYPE_T type);
-
-    /**
-     * Transmit a packet in a LoRaWAN network.  You must
-     * already be joined to a LoRaWAN network for this command to
-     * succeed, and the MAC stack must be in the idle
-     * (RN2903_MAC_STAT_IDLE) state.
-     *
-     * The packet payload must be a valid 0-terminated hex encoded
-     * string.
-     *
-     * There is the possibility of receiving a downlink message after
-     * transmitting a packet.  If this occurs, this function will
-     * return RN2903_MAC_TX_STATUS_RX_RECEIVED, and the returned data
-     * will be stored in the response buffer.  NOTE: calling pretty
-     * much any function that issues commands to the device will
-     * overwrite the response buffer, so save a copy of it if you need
-     * it before calling other functions.
-     *
-     * @param dev Device context
-     * @param type The type of message to send - confirmed or
-     * unconfirmed.  One of the RN2903_MAC_MSG_TYPE_T values.
-     * @param port An integer in the range 1-223
-     * @param payload A 0-terminated, hex encoded string that makes up
-     * the payload of the message
-     * @return The status of the transmit request, one of the
-     * RN2903_MAC_TX_STATUS_T values
-     */
-    RN2903_MAC_TX_STATUS_T rn2903_mac_tx(const rn2903_context dev,
-                                         RN2903_MAC_MSG_TYPE_T type,
-                                         int port, const char *payload);
-
-    /**
-     * Transmit a packet.  This method uses the radio directly without
-     * the LoRaWAN stack running.  For this reason, you must call
-     * rn2903_mac_pause() before trying to transmit using this
-     * function.  You should also configure any parameters (frequency,
-     * etc), before calling this function.
-     *
-     * @param dev Device context
-     * @param payload A 0-terminated, hex encoded string that makes up
-     * the payload of the message
-     * @return The status of the transmit request, one of the
-     * RN2903_RESPONSE_T values
-     */
-    RN2903_RESPONSE_T rn2903_radio_tx(const rn2903_context dev,
-                                      const char *payload);
-
-    /**
-     * Receive a packet.  This method uses the radio directly without
-     * the LoRaWAN stack running.  For this reason, you must call
-     * rn2903_mac_pause() before trying to receive using this
-     * function.  You should also configure any parameters (frequency,
-     * etc) to match the transmitter before calling this function.
-     *
-     * @param dev Device context
-     * @param window_size An integer that represents the number of
-     * symbols to wait for (lora) or the maximum number of
-     * milliseconds to wait (fsk).  This parameter is passed to the "radio
-     * rx" command.  Passing 0 causes the radio to enter continuous
-     * receive mode which will return when either a packet is
-     * received, or the radio watchdog timer expires.  See the RN2903
-     * Command Reference for details.
-     * @return The status of the transmit request, one of the
-     * RN2903_RESPONSE_T values
-     */
-    RN2903_RESPONSE_T rn2903_radio_rx(const rn2903_context dev,
-                                      int window_size);
-
-    /**
-     * Return the Hardware Extended Unique Identifier.  The is a 16
-     * byte hex encoded string representing the 64b hardware EUI.
-     * This value cannot be changed, and is globally unique to each
-     * device.  It is obtained from the device at initialization time.
-     *
-     * @param dev Device context
-     * @return A const string pointer to the hex encoded Hardware EUI
-     */
-    const char *rn2903_get_hardware_eui(const rn2903_context dev);
-
-    /**
-     * Retrieve the device MAC status, decode it, and store it
-     * internally.  This function must be called prior to calling
-     * rn2903_get_mac_status_word() or rn2903_get_mac_status().
-     *
-     * @param dev Device context
-     * @return UPM result
-     */
-    upm_result_t rn2903_update_mac_status(const rn2903_context dev);
-
-    /**
-     * Retrieve the MAC status word. rn2903_update_mac_status() must
-     * have been called prior to calling this function.
-     *
-     * @param dev Device context
-     * @return The MAC status word.  This is a bitmask of
-     * RN2903_MAC_STATUS_BITS_T bits.
-     */
-    uint16_t rn2903_get_mac_status_word(const rn2903_context dev);
-
-    /**
-     * Retrieve the MAC status. rn2903_update_mac_status() must have
-     * been called prior to calling this function.  The MAC status is
-     * a bitfield embedded in the mac_status_word.  It provides
-     * information on the status of the internal MAC state machine.
-     *
-     * @param dev Device context
-     * @return The MAC status, one of the RN2903_MAC_STATUS_T values.
-     */
-    RN2903_MAC_STATUS_T rn2903_get_mac_status(const rn2903_context dev);
-
-    /**
-     * Save the configurable device values to EEPROM.  These values
-     * will be reloaded automatically on a reset or power up.
-     *
-     * The data that can be saved are: deveui, appeui, appkey, nwkskey
-     * (Network Session Key), appskey, devaddr, channels, upctr
-     * (Uplink Counter), dnctr (Downlink Counter), adr (automatic
-     * data-rate) state, and rx2 (the RX2 receive window parameters).
-     *
-     * @param dev Device context
-     * @return UPM result
-     */
-    upm_result_t rn2903_mac_save(const rn2903_context dev);
-
-    /**
-     * Pause the MAC LoRaWAN stack.  This device can operate in one of
-     * two modes.
-     *
-     * The most common mode is used to join and participate in a LoRaWAN
-     * network as a Class A End Device.  This is handled by the MAC
-     * LoRaWAN stack on the device dealing with the details of
-     * LoRaWAN participation automatically.
-     *
-     * The other mode disables MAC LoRaWAN stack functionality and
-     * allows you to issue commands directly to the radio to set
-     * frequencies, data rates, modulation and many other parameters.
-     *
-     * Calling this function disables the MAC LoRaWAN stack and allows
-     * you to issue radio commands that are otherwise handled
-     * automatically.
-     *
-     * When pausing, the maximum allowable pause time in milliseconds
-     * will be returned in the response buffer.  You can grab this
-     * value by calling rn2903_get_response() after this function
-     * completes successfully.
-     *
-     * When the MAC is idle (rn2903_get_mac_status()), you can pause
-     * indefinitely.
-     *
-     * @param dev Device context
-     * @return UPM result
-     */
-    upm_result_t rn2903_mac_pause(const rn2903_context dev);
-
-    /**
-     * Resume the MAC LoRaWAN stack.  Call this to resume MAC LoRaWAN
-     * operation after having called rn2903_mac_pause(), to resume
-     * participation in a LoRaWAN network.
-     *
-     * @param dev Device context
-     * @return UPM result
-     */
-    upm_result_t rn2903_mac_resume(const rn2903_context dev);
-
-    /**
-     * Reset the device.  Any configuration is lost, as well as
-     * the current join status.  This method also calls
-     * rn2903_set_baudrate() after the reset to re-establish
-     * communications with the device in the event you are not
-     * using the default baudrate (which the device will revert to
-     * after a reset).
-     *
-     * @param dev Device context
-     * @return UPM result
-     */
-    upm_result_t rn2903_reset(const rn2903_context dev);
-
-    /**
-     * LoRaWAN communications allows for the reporting of current
-     * battery charge remaining to the LoRaWAN gateway/network server.
-     * This function allows you to specify the value that should be
-     * reported.
-     *
-     * The valid values are from 0 to 255.
-     * 0 = using external power
-     * 1(low) to 254(high) = battery power
-     * 255 = unable to measure battery level
-     *
-     * @param dev Device context
-     * @param level The battery level value from 0-255
-     * @return UPM result
-     */
-    upm_result_t rn2903_mac_set_battery(const rn2903_context dev, int level);
-
-    /**
-     * Enable debugging.  If enabled, commands will be printed out
-     * before being sent to the device.  Any responses will be printed
-     * out after retrieval.  Other miscellaneous debug output will
-     * also be printed.
-     *
-     * @param dev Device context
-     * @param enable true to enable debugging, false otherwise
-     */
-    void rn2903_set_debug(const rn2903_context dev, bool enable);
-
-    /**
-     * Read character data from the device
-     *
-     * @param dev Device context
-     * @param buffer The character buffer to read data into
-     * @param len The maximum size of the buffer
-     * @return The number of bytes successfully read, or -1 on error
-     */
-    int rn2903_read(const rn2903_context dev, char *buffer, size_t len);
-
-    /**
-     * Write character data to the device
-     *
-     * @param dev Device context
-     * @param buffer The character buffer containing data to write
-     * @param len The number of bytes to write
-     * @return The number of bytes successfully written, or -1 on error
-     */
-    int rn2903_write(const rn2903_context dev, const char *buffer, size_t len);
-
-    /**
-     * Set the baudrate of the device.  Auto-bauding is currently only
-     * supported on Linux (due to the need to send a break signal) and
-     * only on a recent MRAA which supports it (> 1.6.1).  If on a
-     * non-linux OS, you should not try to change the baudrate to
-     * anything other than the default 57600 or you will lose control
-     * of the device.
-     *
-     * @param dev Device context
-     * @param baudrate The baud rate to set for the device
-     * @return UPM result
-     */
-    upm_result_t rn2903_set_baudrate(const rn2903_context dev,
-                                     unsigned int baudrate);
-
-    /**
-     * Set a flow control method for the UART.  By default, during
-     * initialization, flow control is disabled.  The device MAY
-     * support hardware flow control, but MRAA does not (at least for
-     * UART numbers), so we can't either.  We leave the option here
-     * though so that if you are using a TTY (as opposed to a UART
-     * instance) it might work if the device is also configured to use
-     * hardware flow control.
-     *
-     * @param dev Device context
-     * @param fc One of the RN2903_FLOW_CONTROL_T values
-     * @return the UPM result
-     */
-    upm_result_t rn2903_set_flow_control(const rn2903_context dev,
-                                         RN2903_FLOW_CONTROL_T fc);
-
-    /**
-     * This is a utility function that can be used to indicate if a
-     * given string is present at the beginning of the response
-     * buffer.  The search is case sensitive.
-     *
-     * @param dev Device context
-     * @param str The 0 teminated string to search for
-     * @return true if the string was found at the beginning of the
-     * response buffer, false otherwise
-     */
-    bool rn2903_find(const rn2903_context dev, const char *str);
-
-    /**
-     * This is a utility function that can be used to return a pointer
-     * to the location in the response buffer where the hex encoded
-     * payload starts for radio_rx messages received.
-     *
-     * @param dev Device context
-     * @return A pointer to the start of the hex payload in the
-     * response buffer, or NULL if the response buffer does not
-     * contain a radio_rx sentence.
-     */
-    const char *rn2903_get_radio_rx_payload(const rn2903_context dev);
-
-    /**
-     * This function attempts to sync the device to the current
-     * baudrate.  It tries retries times, to send an autobaud
-     * sequence to the device and run a test command.
-     *
-     * @param dev Device context
-     * @param retries The number of times to retry autobaud detection
-     * @return true if the test command succeeded, false otherwise
-     */
-    bool rn2903_autobaud(const rn2903_context dev, int retries);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/rn2903/rn2903.hpp b/src/rn2903/rn2903.hpp
deleted file mode 100644
index 7946669..0000000
--- a/src/rn2903/rn2903.hpp
+++ /dev/null
@@ -1,640 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <iostream>
-
-#include "rn2903.h"
-
-namespace upm {
-    /**
-     * @brief Microchip RN2903 LoRa Radio
-     * @defgroup rn2903 libupm-rn2903
-     * @ingroup uart wifi
-     */
-
-    /**
-     * @library rn2903
-     * @sensor rn2903
-     * @comname Microchip RN2903 LoRa radio
-     * @type wifi
-     * @con uart
-     *
-     * @brief API for the Microchip RN2903 LoRa radio
-     *
-     * The Microchip RN2903 Low-Power Long Range LoRa Technology
-     * Transceiver module provides an easy to use, low-power solution
-     * for long range wireless data transmission. The advanced command
-     * interface offers rapid time to market.
-     *
-     * The RN2903 module complies with the LoRaWAN Class A protocol
-     * specifications. It integrates RF, a baseband controller, and a
-     * command Application Programming Interface (API) processor,
-     * making it a complete long range solution.
-     *
-     * Most of the effort in this driver has been geared to supporting
-     * operation within a LoRaWAN network, however methods are
-     * provided to allow you to control the device directly so that
-     * you can implement whatever solution you require.
-     *
-     * @snippet rn2903.cxx Interesting
-     * @snippet rn2903-p2p-tx.cxx Interesting
-     * @snippet rn2903-p2p-rx.cxx Interesting
-     */
-
-    class RN2903 {
-    public:
-
-        /**
-         * RN2903 object constructor for a UART specified by MRAA number.
-         *
-         * @param uart Specify which uart to use.
-         * @param baudrate Specify the baudrate to use.  The default
-         * is 57600.
-         */
-        RN2903(unsigned int uart,
-               unsigned int baudrate=RN2903_DEFAULT_BAUDRATE);
-
-        /**
-         * RN2903 object constructor for a UART specified by PATH (ex:
-         * /dev/ttyUSB0)
-         *
-         * @param uart_path Specify path of UART device.
-         * @param baudrate Specify the baudrate to use.  The default
-         * is 57600.
-         */
-        RN2903(std::string uart_path,
-               unsigned int baudrate=RN2903_DEFAULT_BAUDRATE);
-
-        /**
-         * RN2903 object destructor
-         */
-        virtual ~RN2903();
-
-        /**
-         * Set the default time, in milliseconds, to wait for a response
-         * after sending a command.  All commands return at least one
-         * response immediately after issuing the command.  This delay
-         * sets the maximum amount of time to wait for it.
-         *
-         * @param wait_ms The response delay to set, in milliseconds.
-         * The default is 1 second (1000ms).
-         */
-        void setResponseWaitTime(
-            unsigned int wait_ms=RN2903_DEFAULT_RESP_DELAY);
-
-        /**
-         * Set the default time, in milliseconds, to wait for the second
-         * response data to arrive.  Some commands will have a second
-         * response emitted after the first response.  This delay sets the
-         * maximum amount of time to wait for it.
-         *
-         * @param wait_ms The response delay to set, in milliseconds.
-         * The default is 60 seconds (60000ms).
-         */
-        void setResponse2WaitTime(
-            unsigned int wait_ms=RN2903_DEFAULT_RESP2_DELAY);
-
-        /**
-         * Determine whether there is data available to be read.  This
-         * function will wait up to "millis" milliseconds for data to
-         * become available.
-         *
-         * @param millis The number of milliseconds to wait for data to
-         * become available.
-         * @return true if data is available to be read, false otherwise.
-         */
-        bool dataAvailable(unsigned int millis);
-
-        /**
-         * Read and throw away any data currently available to be
-         * read.  This is useful to avoid reading data that might have
-         * been the result of a previous command interfering with data
-         * you currently want to read.
-         */
-        void drain();
-
-        /**
-         * Send a command, wait for a response using
-         * waitForResponse(), and return the status.  The response
-         * itself will be stored internally, and can be retrieved
-         * using getResponse() and getResponseLen().  Every command
-         * will return at least one response, and this function will
-         * always wait for it and store it into the internal response
-         * buffer after sending the command.
-         *
-         * @param cmd A character string containing the command to
-         * send
-         * @return One of the RN2903_RESPONSE_T values
-         */
-        RN2903_RESPONSE_T command(const std::string cmd);
-
-        /**
-         * Build a command string with the supplied command and string
-         * argument.  Then call command() with the result, and
-         * return the result.  This is just a convenience function.
-         *
-         * @param cmd A character string containing the command to
-         * send
-         * @param arg A string argument for the command
-         * @return One of the RN2903_RESPONSE_T values
-         */
-        RN2903_RESPONSE_T commandWithArg(const std::string cmd,
-                                         const std::string arg);
-
-        /**
-         * Wait up to wait_ms milliseconds for a response.
-         *
-         * In the case of errors ("invalid_param" received, timeout
-         * occurred, or other UPM specific error), this will be indicated
-         * by the return value.
-         *
-         * Otherwise, an "ok" or other data value will not be considered
-         * an error and will return RN2903_RESPONSE_OK.  The response
-         * itself will be stored internally, and can be retrieved using
-         * getResponse() and getResponseLen().
-         *
-         * NOTE: the response buffer is overwritten whenever this function
-         * is called, so if there is data in there that you need to save,
-         * copy it somewhere else before calling any other methods in
-         * this driver to be safe.
-         *
-         * @param wait_ms The maximum number of milliseconds to wait for a
-         * response.
-         * @return One of the RN2903_RESPONSE_T values
-         */
-        RN2903_RESPONSE_T waitForResponse(int wait_ms);
-
-        /**
-         * Return a string containing a copy of the last response
-         * saved in the response buffer
-         *
-         * @return A string containing a copy of the response buffer
-         */
-        std::string getResponse();
-
-        /**
-         * Return the length in bytes of the string containing the
-         * last response.
-         *
-         * @return The length of the last response in bytes
-         */
-        int getResponseLen();
-
-        /**
-         * Set the MAC device EUI for LoRaWAN communications.  The device
-         * EUI must be a hex encoded string of 16 bytes.  This value must
-         * be set for LoRaWAN OTAA joining.
-         *
-         * @param str The 16-byte hex encoded device EUI
-         * @throws std::runtime_error if the EUI is invalid or the mac
-         * set command failed
-         */
-        void setDeviceEUI(const std::string str);
-
-        /**
-         * Retrieve the device EUI from the device.  If this function
-         * succeeds, you can then use getResponse() to get the value.
-         *
-         * @return UPM result
-         * @throws std::runtime_error if the mac get command failed
-         */
-        void getDeviceEUI();
-
-        /**
-         * Set the MAC device address for LoRaWAN communications.  The
-         * device address must be a hex encoded string of 8 bytes.  This
-         * value must be set for LoRaWAN ABP joining.
-         *
-         * For OTAA joining, this value will be overwritten once the join
-         * has completed, and therefore must not be set if performing an
-         * OTAA join.
-         *
-         * @param str The 8-byte hex encoded device address
-         * @throws std::runtime_error if the mac set command failed or
-         * the hex string is invalid
-         */
-        void setDeviceAddr(std::string str);
-
-        /**
-         * Retrieve the device address from the device.  If this
-         * function succeeds, you can then use getResponse() to get
-         * the value.
-         *
-         * @throws std::runtime_error if the mac get failed
-         */
-        void getDeviceAddr();
-
-        /**
-         * Set the MAC network session key for LoRaWAN communications.
-         * The network session key must be a hex encoded string of 32
-         * bytes.  This value must be set for LoRaWAN ABP joining.  It it
-         * not possible to retrieve this key.
-         *
-         * For OTAA joining, this value will be overwritten once the join
-         * has completed, and therefore must not be set if performing an
-         * OTAA join.
-         *
-         * @param str The 32-byte hex encoded network session key
-         * @throws std::runtime_error if the mac set command failed or
-         * the hex string is invalid
-         */
-        void setNetworkSessionKey(std::string str);
-
-        /**
-         * Set the MAC application session key for LoRaWAN communications.
-         * The application session key must be a hex encoded string of 32
-         * bytes.  This value must be set for LoRaWAN ABP joining.  It it
-         * not possible to retrieve this key.
-         *
-         * For OTAA joining, this value will be overwritten once the join
-         * has completed, and therefore must not be set if performing an
-         * OTAA join.
-         *
-         * @param str The 32-byte hex encoded application session key
-         * @throws std::runtime_error if the mac set command failed or
-         * the hex string is invalid
-         */
-        void setApplicationSessionKey(std::string str);
-
-        /**
-         * Set the MAC application EUI for LoRaWAN communications.  The
-         * application EUI must be a hex encoded string of 16 bytes.  This
-         * value must be set for LoRaWAN OTAA joining.
-         *
-         * @param str The 16-byte hex encoded application EUI
-         * @throws std::runtime_error if the EUI is invalid, or if the
-         * mac set command failed
-         */
-        void setApplicationEUI(const std::string str);
-
-        /**
-         * Retrieve the application EUI from the device.  If this
-         * function succeeds, you can then use getResponse() to get
-         * the value.
-         *
-         * @throws std::runtime_error if the mac get command failed
-         */
-        void getApplicationEUI();
-
-        /**
-         * Set the MAC application key for LoRaWAN communications.
-         * The application key must be a hex encoded string of 32
-         * bytes.  This value must be set for LoRaWAN OTAA joining.
-         *
-         * @param str The 32-byte hex encoded application key
-         * @throws std::runtime_error if the key is invalid, or if the
-         * mac set command failed
-         */
-        void setApplicationKey(const std::string str);
-
-        /**
-         * Retrieve the application key from the device.  If this function
-         * succeeds, you can then use rn2903_get_response() to get the
-         * value.
-         *
-         * @throws std::runtime_error if the mac get command failed
-         */
-        void getApplicationKey();
-
-        /**
-         * Convert src into a hex byte string.  All non-command
-         * related data such as keys, and payload sent to the device
-         * must be hex encoded.
-         *
-         * @param src A string to encode
-         * @return A string containing the hex encoded version of str.
-         * In the event of an error, the return string will be empty.
-         */
-        std::string toHex(const std::string src);
-
-        /**
-         * Decode a hex byte string into the original string.  The hex
-         * string must have a length that is a multiple of two, and
-         * all characters in the string must be valid hex characters.
-         *
-         * @return A string containing the decoded contents of the hex
-         * string passed, or an empty string if there was an error.
-         */
-        std::string fromHex(const std::string src);
-
-        /**
-         * Join a LoRaWAN network.  There are two types of joins
-         * possible - Over The Air Activation (OTAA) and Activation by
-         * Personalization (ABP).  Each join method requires that
-         * certain items have been configured first.
-         *
-         * For OTAA activation, the Device Extended Unique Identifier
-         * (EUI), the Application EUI, and Application Key must be
-         * set.
-         *
-         * For ABP activation, The Device Address, Network Session
-         * Key, and the Application Session Key must be set.
-         *
-         * @param type The LoRaWAN join activation type, one of the
-         * RN2903_JOIN_TYPE_T values
-         * @return The status of the join, one of the RN2903_JOIN_STATUS_T
-         * values
-         */
-        RN2903_JOIN_STATUS_T join(RN2903_JOIN_TYPE_T type);
-
-        /**
-         * Transmit a packet in a LoRaWAN network.  You must
-         * already be joined to a LoRaWAN network for this command to
-         * succeed, and the MAC stack must be in the idle
-         * (RN2903_MAC_STAT_IDLE) state.
-         *
-         * The packet payload must be a valid hex encoded string.
-         *
-         * There is the possibility of receiving a downlink message after
-         * transmitting a packet.  If this occurs, this function will
-         * return RN2903_MAC_TX_STATUS_RX_RECEIVED, and the returned data
-         * will be stored in the response buffer.
-         *
-         * @param type The type of message to send - confirmed or
-         * unconfirmed.  One of the RN2903_MAC_MSG_TYPE_T values.
-         * @param port An integer in the range 1-223
-         * @param payload A valid hex encoded string that makes up the
-         * payload of the message
-         * @return The status of the transmit request, one of the
-         * RN2903_MAC_TX_STATUS_T values
-         */
-        RN2903_MAC_TX_STATUS_T macTx(RN2903_MAC_MSG_TYPE_T type,
-                                     int port, std::string payload);
-
-        /**
-         * Transmit a packet.  This method uses the radio directly
-         * without the LoRaWAN stack running.  For this reason, you
-         * must call macPause() before trying to transmit using this
-         * function.  You should also configure any radio parameters
-         * (frequency, etc), before calling this function.
-         *
-         * @param payload A valid hex encoded string that makes up
-         * the payload of the message
-         * @return The status of the transmit request, one of the
-         * RN2903_RESPONSE_T values
-         */
-        RN2903_RESPONSE_T radioTx(const std::string payload);
-
-        /**
-         * Receive a packet.  This method uses the radio directly
-         * without the LoRaWAN stack running.  For this reason, you
-         * must call macPause() before trying to receive using this
-         * function.  You should also configure any parameters
-         * (frequency, etc) to match the transmitter before calling
-         * this function.
-         *
-         * @param window_size An integer that represents the number of
-         * symbols to wait for (lora) or the maximum number of
-         * milliseconds to wait (fsk).  This parameter is passed to
-         * the "radio rx" command.  Passing 0 causes the radio to
-         * enter continuous receive mode which will return when either
-         * a packet is received, or the radio watchdog timer expires.
-         * See the RN2903 Command Reference for details.
-         * @return The status of the transmit request, one of the
-         * RN2903_RESPONSE_T values
-         */
-        RN2903_RESPONSE_T radioRx(int window_size);
-
-        /**
-         * Return the Hardware Extended Unique Identifier (EUI).  The
-         * is a 16 byte hex encoded string representing the 64b
-         * hardware EUI.  This value cannot be changed, and is
-         * globally unique to each device.  It is obtained from the
-         * device at initialization time.
-         *
-         * @return A const string pointer to the hex encoded Hardware EUI
-         */
-        std::string getHardwareEUI();
-
-        /**
-         * Retrieve the device MAC status, decode it, and store it
-         * internally.  This function must be called prior to calling
-         * getMacStatusWord() or getMacStatus().
-         *
-         * @throws std::runtime_error if the mac get command failed
-         */
-        void updateMacStatus();
-
-        /**
-         * Retrieve the MAC status word. updateMacStatus() must have
-         * been called prior to calling this function.
-         *
-         * @return The MAC status word.  This is a bitmask of
-         * RN2903_MAC_STATUS_BITS_T bits.
-         */
-        int getMacStatusWord();
-
-        /**
-         * Retrieve the MAC status. updateMacStatus() must have been
-         * called prior to calling this function.  The MAC status is a
-         * bitfield embedded in the mac status word.  It provides
-         * information on the status of the internal MAC state
-         * machine.
-         *
-         * @return The MAC status, one of the RN2903_MAC_STATUS_T values.
-         */
-        RN2903_MAC_STATUS_T getMacStatus();
-
-        /**
-         * Save the configurable device values to EEPROM.  These
-         * values will be reloaded automatically on a reset or power
-         * up.
-         *
-         * The data that can be saved are: deveui, appeui, appkey,
-         * nwkskey (Network Session Key), appskey, devaddr, channels,
-         * upctr (Uplink Counter), dnctr (Downlink Counter), adr
-         * (automatic data-rate) state, and rx2 (the RX2 receive
-         * window parameters).
-         *
-         * @throws std::runtime_error if the mac save command failed
-         */
-        void macSave();
-
-        /**
-         * Pause the MAC LoRaWAN stack.  This device can operate in
-         * one of two modes.
-         *
-         * The most common mode is used to join and participate in a
-         * LoRaWAN network as a Class A End Device.  This is handled
-         * by the MAC LoRaWAN stack on the device dealing with the
-         * details of LoRaWAN participation automatically.
-         *
-         * The other mode disables MAC LoRaWAN stack functionality and
-         * allows you to issue commands directly to the radio to set
-         * frequencies, data rates, modulation and many other
-         * parameters.
-         *
-         * Calling this function disables the MAC LoRaWAN stack and
-         * allows you to issue radio commands that are otherwise
-         * handled automatically.
-         *
-         * When pausing, the maximum allowable pause time in
-         * milliseconds will be returned in the response buffer.  You
-         * can grab this value by calling getResponse() after this
-         * function completes successfully.
-         *
-         * When the MAC is idle (getMacStatus()), you can pause
-         * the stack indefinitely.
-         *
-         * @throws std::runtime_error if the mac pause command failed
-         */
-        void macPause();
-
-        /**
-         * Resume the MAC LoRaWAN stack.  Call this to resume MAC
-         * LoRaWAN operation after having called macPause(), to resume
-         * participation in a LoRaWAN network.
-         *
-         * @param dev Device context
-         * @return UPM result
-         * @throws std::runtime_error if the mac resume command failed
-         */
-        void macResume();
-
-        /**
-         * Reset the device.  Any configuration is lost, as well as
-         * the current join status.  This method also calls
-         * setBaudrate() after the reset to re-establish
-         * communications with the device in the event you are not
-         * using the default baudrate (which the device will revert to
-         * after a reset).
-         *
-         * @throws std::runtime_error if the mac reset, or
-         * setBaudrate() command fails
-         */
-        void reset();
-
-        /**
-         * LoRaWAN communications allows for the reporting of current
-         * battery charge remaining to the LoRaWAN gateway/network server.
-         * This function allows you to specify the value that should be
-         * reported.
-         *
-         * The valid values are from 0 to 255.
-         * 0 = using external power
-         * 1(low) to 254(high) = battery power
-         * 255 = unable to measure battery level
-         *
-         * @param level The battery level value from 0-255
-         * @throws std::runtime_error if the mac set bat command
-         * failed, or if the battery level is invalid
-         */
-        void macSetBattery(int level);
-
-        /**
-         * Enable debugging.  If enabled, commands will be printed out
-         * before being sent to the device.  Any responses will be printed
-         * out after retrieval.  Other miscellaneous debug output will
-         * also be printed.
-         *
-         * @param enable true to enable debugging, false otherwise
-         */
-        void setDebug(bool enable);
-
-        /**
-         * Set the baudrate of the device.  Auto-bauding is currently only
-         * supported on Linux (due to the need to send a break signal) and
-         * only on a recent MRAA which supports it (> 1.6.1).  If on a
-         * non-linux OS, you should not try to change the baudrate to
-         * anything other than the default 57600 or you will lose control
-         * of the device.
-         *
-         * @param baudrate The baud rate to set for the device
-         * @throws std::runtime_error if the autobaud test command failed
-         */
-        void setBaudrate(unsigned int baudrate);
-
-        /**
-         * Set a flow control method for the UART.  By default, during
-         * initialization, flow control is disabled.  The device MAY
-         * support hardware flow control, but MRAA does not (at least for
-         * UART numbers), so we can't either.  We leave the option here
-         * though so that if you are using a TTY (as opposed to a UART
-         * instance) it might work if the device is also configured to use
-         * hardware flow control.
-         *
-         * @param fc One of the RN2903_FLOW_CONTROL_T values
-         * @throws std::runtime_error on failure
-         */
-        void setFlowControl(RN2903_FLOW_CONTROL_T fc);
-
-        /**
-         * This is a utility function that can be used to indicate if a
-         * given string is present at the beginning of the response
-         * buffer.  The search is case sensitive.
-         *
-         * @param str The string to search for
-         * @return true if the string was found at the beginning of the
-         * response buffer, false otherwise
-         */
-        bool find(const std::string str);
-
-        /**
-         * This is a utility function that can be used to return the
-         * hex encoded payload string for radio_rx messages received.
-         *
-         * @return A string representing the hex encoded payload, or
-         * an empty string if there was an error
-         */
-        std::string getRadioRxPayload();
-
-        /**
-         * This function attempts to sync the device to the current
-         * baudrate.  It tries retries times, to send an autobaud
-         * sequence to the device and run a test command.
-         *
-         * @param retries The number of times to retry autobaud detection
-         * @return true if the test command succeeded, false otherwise
-         */
-        bool autobaud(int retries);
-
-
-    protected:
-        // rn2903 device context
-        rn2903_context m_rn2903;
-
-        /**
-         * Read character data from the device
-         *
-         * @param size The maximum number of characters to read
-         * @return string containing the data read
-         */
-        std::string read(int size);
-
-        /**
-         * Write character data to the device
-         *
-         * @param buffer The string containing the data to write
-         * @return The number of bytes written
-         */
-        int write(std::string buffer);
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        RN2903(const RN2903&) = delete;
-        RN2903 &operator=(const RN2903&) = delete;
-    };
-}
diff --git a/src/rn2903/rn2903.i b/src/rn2903/rn2903.i
deleted file mode 100644
index 1fbb0a0..0000000
--- a/src/rn2903/rn2903.i
+++ /dev/null
@@ -1,16 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_rn2903)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "rn2903_defs.h"
-#include "rn2903.hpp"
-%}
-%include "rn2903_defs.h"
-%include "rn2903.hpp"
-/* END Common SWIG syntax */
diff --git a/src/rn2903/rn2903.json b/src/rn2903/rn2903.json
deleted file mode 100644
index 3dcb3c2..0000000
--- a/src/rn2903/rn2903.json
+++ /dev/null
@@ -1,53 +0,0 @@
-{
-    "Library": "rn2903",
-    "Description": "Microchip RN2903 LoRa radio Library",
-    "Sensor Class": {
-        "RN2903": {
-            "Name": "API for the Microchip RN2903 LoRa radio",
-            "Description": "This is the UPM Module for the Microchip RN2903 LoRa radio. The RN2903 is a fully-certified 915 MHz module based on wireless LoRa technology.  The RN2903 utilizes a unique spread spectrum modulation within the Sub-GHz band to enable long range, low power, and high network capacity.",
-            "Aliases": ["rn2903"],
-            "Categories": ["wifi"],
-            "Connections": ["uart"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["Microchip"],
-            "Examples": {
-                "Java": ["RN2903_Example.java", "RN2903_P2P_RX_Example.java", "RN2903_P2P_TX_Example.java"],
-                "Python": ["rn2903-p2p-rx.py", "rn2903-p2p-tx.py", "rn2903.py"],
-                "Node.js": ["rn2903-p2p-rx.js", "rn2903-p2p-tx.js", "rn2903.js"],
-                "C++": ["rn2903-p2p-rx.cxx", "rn2903-p2p-tx.cxx", "rn2903.cxx"],
-                "C": ["rn2903-p2p-rx.c", "rn2903-p2p-tx.c", "rn2903.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 2.1,
-                    "max": 3.6
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "min" : 185,
-                    "max" : 200
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Frequency Band": {
-                    "unit": "MHz",
-                    "min": 902.000,
-                    "max": 928.000
-                },
-                "Effective Range": {
-                    "unit": "km",
-                    "min": 5,
-                    "max": 15
-                }
-            },
-            "Urls": {
-                "Product Pages": ["http://www.microchip.com/wwwproducts/en/RN2903"],
-                "Datasheets": ["http://ww1.microchip.com/downloads/en/DeviceDoc/50002390C.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/rn2903/rn2903_defs.h b/src/rn2903/rn2903_defs.h
deleted file mode 100644
index dfba304..0000000
--- a/src/rn2903/rn2903_defs.h
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-// maximum buffer size
-#define RN2903_MAX_BUFFER (512)
-
-// size of hex encoded 64b EUI (IPV6 Extended Unique Identifier)
-#define RN2903_MAX_HEX_EUI64  (16)
-
-// default baudrate
-#define RN2903_DEFAULT_BAUDRATE (57600)
-
-// response wait times in milliseconds
-#define RN2903_DEFAULT_RESP_DELAY   (1000)   // 1 second
-#define RN2903_DEFAULT_RESP2_DELAY  (60000)  // 60 seconds
-
-// This byte sequence must follow all commands.  All responses
-// will also be followed by these bytes (\r\n - CR LF).
-#define RN2903_PHRASE_TERM "\r\n"
-#define RN2903_PHRASE_TERM_LEN (2)
-
-// invalid parameter
-#define RN2903_PHRASE_INV_PARAM "invalid_param"
-// ok
-#define RN2903_PHRASE_OK "ok"
-
-    // RN2903_MAC_STATUS_BITS_T from "mac get status" cmd
-    typedef enum {
-        RN2903_MAC_STATUS_JOINED              = 0x0001,
-
-        RN2903_MAC_STATUS_MAC_STATUS0         = 0x0002,
-        RN2903_MAC_STATUS_MAC_STATUS1         = 0x0004,
-        RN2903_MAC_STATUS_MAC_STATUS2         = 0x0008,
-        _RN2903_MAC_STATUS_MAC_STATUS_MASK    = 7,
-        _RN2903_MAC_STATUS_MAC_STATUS_SHIFT   = 1,
-
-        RN2903_MAC_STATUS_AUTO_REPLY          = 0x0010,
-        RN2903_MAC_STATUS_ADR                 = 0x0020,
-        RN2903_MAC_STATUS_SILENT              = 0x0040,
-        RN2903_MAC_STATUS_PAUSED              = 0x0080,
-        RN2903_MAC_STATUS_RFU                 = 0x0100,
-        RN2903_MAC_STATUS_LINK_CHK            = 0x0200,
-
-        RN2903_MAC_STATUS_CHAN_UPD            = 0x0400,
-        RN2903_MAC_STATUS_OUT_PWR_UPD         = 0x0800,
-        RN2903_MAC_STATUS_NBREP_UPD           = 0x1000,
-        RN2903_MAC_STATUS_PRESCALER_UPD       = 0x2000,
-        RN2903_MAC_STATUS_SECOND_RX_UPD       = 0x4000,
-        RN2903_MAC_STATUS_TX_TIMING_UPD       = 0x8000,
-    } RN2903_MAC_STATUS_BITS_T;
-
-    // RN2903_MAC_STATUS_MAC_STATUS values
-    typedef enum {
-        RN2903_MAC_STAT_IDLE                  = 0,
-        RN2903_MAC_STAT_TX_IN_PROGESS         = 1,
-        RN2903_MAC_STAT_BEFORE_RX_WIN1        = 2,
-        RN2903_MAC_STAT_RX_WIN1_OPEN          = 3,
-        RN2903_MAC_STAT_BETWEEN_RX_WIN1_WIN2  = 4,
-        RN2903_MAC_STAT_RX_WIN2_OPEN          = 5,
-        RN2903_MAC_STAT_ACK_TIMEOUT           = 6,
-    } RN2903_MAC_STATUS_T;
-
-    // Join types
-    typedef enum {
-        RN2903_JOIN_TYPE_OTAA                 = 0, // over-the-air-activation
-        RN2903_JOIN_TYPE_ABP                  = 1, // activation-by
-                                                   // personalization
-    } RN2903_JOIN_TYPE_T;
-
-    // Join status
-    typedef enum {
-        RN2903_JOIN_STATUS_ACCEPTED           = 0,
-        RN2903_JOIN_STATUS_BAD_KEYS           = 1,
-        RN2903_JOIN_STATUS_NO_CHAN            = 2,
-        RN2903_JOIN_STATUS_SILENT             = 3,
-        RN2903_JOIN_STATUS_BUSY               = 4,
-        RN2903_JOIN_STATUS_MAC_PAUSED         = 5,
-        RN2903_JOIN_STATUS_DENIED             = 6,
-        RN2903_JOIN_STATUS_ALREADY_JOINED     = 7,
-        RN2903_JOIN_STATUS_UPM_ERROR          = 8,
-    } RN2903_JOIN_STATUS_T;
-
-    // possible flow control methods
-    typedef enum {
-        RN2903_FLOW_CONTROL_NONE              = 0,
-        RN2903_FLOW_CONTROL_HARD,          // hardware flow control
-    } RN2903_FLOW_CONTROL_T;
-
-    // MAC TX message types
-    typedef enum {
-        RN2903_MAC_MSG_TYPE_UNCONFIRMED       = 0,
-        RN2903_MAC_MSG_TYPE_CONFIRMED         = 1,
-    } RN2903_MAC_MSG_TYPE_T;
-
-    // MAC TX status
-    typedef enum {
-        RN2903_MAC_TX_STATUS_TX_OK            = 0, // tx was sent successfully
-        RN2903_MAC_TX_STATUS_NOT_JOINED       = 1,
-        RN2903_MAC_TX_STATUS_NO_CHAN          = 2,
-        RN2903_MAC_TX_STATUS_SILENT           = 3,
-        RN2903_MAC_TX_STATUS_FC_NEED_REJOIN   = 4, // frame counter overflow
-        RN2903_MAC_TX_STATUS_BUSY             = 5,
-        RN2903_MAC_TX_STATUS_MAC_PAUSED       = 6,
-        RN2903_MAC_TX_STATUS_BAD_DATA_LEN     = 7,
-        RN2903_MAC_TX_STATUS_RX_RECEIVED      = 8, // received a packet
-        RN2903_MAC_TX_STATUS_MAC_ERR          = 9, // error during tx
-        RN2903_MAC_TX_STATUS_UPM_ERROR        = 10, // error during tx
-    } RN2903_MAC_TX_STATUS_T;
-
-    // last command status
-    typedef enum {
-        RN2903_RESPONSE_OK                    = 0, // "ok", or data
-        RN2903_RESPONSE_INVALID_PARAM         = 1, // "invalid_param"
-        RN2903_RESPONSE_TIMEOUT               = 3,
-        RN2903_RESPONSE_UPM_ERROR             = 4,
-    } RN2903_RESPONSE_T;
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/rotary/CMakeLists.txt b/src/rotary/CMakeLists.txt
deleted file mode 100644
index 4c6289a..0000000
--- a/src/rotary/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-upm_mixed_module_init (NAME rotary
-    DESCRIPTION "Rotary Angle Sensor"
-    C_HDR rotary.h
-    C_SRC rotary.c
-    CPP_HDR rotary.hpp
-    CPP_SRC rotary.cxx
-    FTI_SRC rotary_fti.c
-    REQUIRES mraa)
diff --git a/src/rotary/rotary.c b/src/rotary/rotary.c
deleted file mode 100644
index 8e29302..0000000
--- a/src/rotary/rotary.c
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Author: Brendan Le Foll <brendan.le.foll@intel.com>
- * 	   Sisinty Sasmita Patra <sisinty.s.patra@intel.com>
- *
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-
-#include "rotary.h"
-
-rotary_context rotary_init(int pin, float aRef)
-{
-    rotary_context dev = (rotary_context)malloc(sizeof(struct _rotary_context));
-
-    if(dev == NULL) return NULL;
-
-    dev->aio = mraa_aio_init(pin);
-
-    if(dev->aio == NULL){
-        free(dev);
-        return NULL;
-    }
-
-    dev->m_aRef = aRef;
-
-    // get adc bit range
-    dev->m_aRes = (1 << mraa_aio_get_bit(dev->aio));
-
-    return dev;
-}
-
-void rotary_close(rotary_context dev)
-{
-    mraa_aio_close(dev->aio);
-    free(dev);
-}
-
-upm_result_t rotary_get_value_voltage (const rotary_context dev,
-                                       float* volts)
-{
-    float val = 0.0;
-    val = mraa_aio_read(dev->aio);
-    *volts = (dev->m_aRef / dev->m_aRes) * (float)val;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t rotary_get_value_angle (rotary_context dev, float* rotval)
-{
-    float val = 0.0;
-    val = mraa_aio_read(dev->aio);
-
-    // return degrees
-    *rotval = val * (float)ROTARY_MAX_ANGLE / dev->m_aRes;
-
-    return UPM_SUCCESS;
-}
diff --git a/src/rotary/rotary.cxx b/src/rotary/rotary.cxx
deleted file mode 100644
index 03fe814..0000000
--- a/src/rotary/rotary.cxx
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Authors: Brendan Le Foll <brendan.le.foll@intel.com>
- *          Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- *          Sarah Knepper <sarah.knepper@intel.com>
- * Copyright (c) 2014 - 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "rotary.hpp"
-#include "math.h"
-
-using namespace upm;
-
-Rotary::Rotary(unsigned int pin)
-{
-    if ( !(m_aio = mraa_aio_init(pin)) ) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_aio_init() failed, invalid pin?");
-        return;
-    }
-}
-
-Rotary::~Rotary()
-{
-    mraa_aio_close(m_aio);
-}
-
-float Rotary::abs_value()
-{
-    return (float) mraa_aio_read(m_aio);
-}
-
-float Rotary::abs_deg()
-{
-    return Rotary::abs_value() * (float) m_max_angle / 1023.0;
-}
-
-float Rotary::abs_rad()
-{
-    return Rotary::abs_deg() * M_PI / 180.0;
-}
-
-float Rotary::rel_value()
-{
-    return Rotary::abs_value() - 512.0;
-}
-
-float Rotary::rel_deg()
-{
-    return Rotary::rel_value() * (float) m_max_angle / 1023.0;
-}
-
-float Rotary::rel_rad()
-{
-    return Rotary::rel_deg() * M_PI / 180.0;
-}
diff --git a/src/rotary/rotary.h b/src/rotary/rotary.h
deleted file mode 100644
index 86e383c..0000000
--- a/src/rotary/rotary.h
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Author: Brendan Le Foll <brendan.le.foll@intel.com>
- * 	   Sisinty Sasmita Patra <sisinty.s.patra@intel.com>
- *
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef ROTARY_H_
-#define ROTARY_H_
-
-#include <unistd.h>
-
-#include "upm.h"
-#include <mraa/aio.h>
-
-/**
- * @file rotary.h
- * @library rotary
- * @brief C API for the Rotary Angle Sensor
- *
- * @include rotary.c
- */
-
-/**
- * driver context
- */
-typedef struct _rotary_context {
-    mraa_aio_context aio;
-    float m_aRef;
-    int16_t m_aRes;
-} *rotary_context;
-
-#define ROTARY_MAX_ANGLE 300
-
-/**
- * Rotary angle sensor initialization function
- *
- * @param pin analog pin to use
- * @param aRef reference voltage
- * @return sensor context
- */
-rotary_context rotary_init(int pin, float aRef);
-
-/**
- * Rotary destructor
- *
- * @param dev sensor context pointer
- */
-void rotary_close(rotary_context dev);
-
-/**
- * Gets the voltage value from the analog pin
- *
- * @param dev sensor context pointer
- * @param volts sensor voltage value
- * @return result of the operation
- */
-upm_result_t rotary_get_value_voltage(const rotary_context dev, float* volts);
-
-/**
- * Gets the position of the rotary angle sensor in degrees
- *
- * @param dev sensor context pointer
- * @param rotval sensor position in degrees
- * @return result of the operation
- */
-upm_result_t rotary_get_value_angle(rotary_context dev, float* rotval);
-
-#endif /* ROTARY_H_ */
diff --git a/src/rotary/rotary.hpp b/src/rotary/rotary.hpp
deleted file mode 100644
index 092eeb8..0000000
--- a/src/rotary/rotary.hpp
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Authors: Brendan Le Foll <brendan.le.foll@intel.com>
- *          Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- *          Sarah Knepper <sarah.knepper@intel.com>
- * Copyright (c) 2014 - 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <string>
-#include <mraa/aio.hpp>
-
-#include "rotary.hpp"
-
-namespace upm {
-
-/**
- * @brief Rotary Angle Sensor
- * @defgroup rotary libupm-rotary
- * @ingroup seeed analog ainput gsk
- */
-
-/**
- * @library rotary
- * @sensor rotary
- * @comname Rotary Angle Sensor
- * @altname Rotary Potentiometer, Grove Rotary Angle Sensor
- * @type ainput
- * @man seeed
- * @web http://wiki.seeed.cc/Grove-Rotary_Angle_Sensor/
- * @con analog
- * @kit gsk
- *
- * @brief API for the Rotary Angle Sensor (Knob)
- *
- * Basic UPM module for the rotary angle sensor (knob) on analog. Provides a
- * set of functions to read the absolute pin value, degrees or radians, and
- * another set to do the same relative to the center of the knob's range.
- *
- * @image html rotary.jpg
- * @snippet rotary.cxx Interesting
- */
-class Rotary{
-    public:
-        /**
-         * Rotary angle sensor constructor
-         *
-         * @param pin Number of the analog pin to use
-         */
-        Rotary(unsigned int pin);
-        /**
-         * Rotary destructor
-         */
-        ~Rotary();
-        /**
-         * Gets the absolute raw value from the AIO pin
-         *
-         * @return Unsigned value from the ADC
-         */
-        float abs_value();
-        /**
-         * Gets absolute raw degrees from the AIO pin
-         *
-         * @return Unsigned degrees from the ADC
-         */
-        float abs_deg();
-        /**
-         * Gets absolute raw radians from the AIO pin
-         *
-         * @return Unsigned radians from the ADC
-         */
-        float abs_rad();
-        /**
-         * Gets the relative value from the AIO pin
-         *
-         * @return Signed value from the ADC
-         */
-        float rel_value();
-        /**
-         * Gets relative degrees from the AIO pin
-         *
-         * @return Signed degrees from the ADC
-         */
-        float rel_deg();
-        /**
-         * Gets relative radians from the AIO pin
-         *
-         * @return Signed radians from the ADC
-         */
-        float rel_rad();
-        std::string name(){ return "Rotary Angle Sensor";}
-    private:
-        mraa_aio_context m_aio;
-        static const int m_max_angle = 300;
-};
-}
diff --git a/src/rotary/rotary.json b/src/rotary/rotary.json
deleted file mode 100644
index 9d20406..0000000
--- a/src/rotary/rotary.json
+++ /dev/null
@@ -1,52 +0,0 @@
-{
-    "Library": "rotary",
-    "Description": "Seeed Rotary Angle Sensor library",
-    "Sensor Class": {
-        "Rotary": {
-            "Name": "API for the Seeed Rotary Angle Sensor",
-            "Description": "This is the UPM Module for the Seeed Rotary Angle Sensor. Provides a set of functions to read the absolute pin value, degrees or radians, and another set to do the same relative to the center of the knob's range.",
-            "Aliases": ["rotary", "Grove - Rotary Angle Sensor"],
-            "Categories": ["ainput"],
-            "Connections": ["analog"],
-            "Project Type": ["prototyping"],
-            "Manufacturers": ["Seeed"],
-            "Kits": ["gsk"],
-            "Image": "rotary.jpg",
-            "Examples": {
-                "Java": ["Rotary_Example.java"],
-                "Python": ["rotary.py"],
-                "Node.js": ["rotary.js"],
-                "C++": ["rotary.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 4.75,
-                    "max": 5.25
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Rotary Angle": {
-                    "unit": "Â°",
-                    "min": 0,
-                    "max": 300
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-Rotary-Angle-Sensor-p-770.html"],
-                "Datasheets": ["http://wiki.seeed.cc/Grove-Rotary_Angle_Sensor/"]
-            }
-        }
-    }
-}
diff --git a/src/rotary/rotary_fti.c b/src/rotary/rotary_fti.c
deleted file mode 100644
index 2eedf72..0000000
--- a/src/rotary/rotary_fti.c
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- * Author: Brendan Le Foll <brendan.le.foll@intel.com>
- * 	   Sisinty Sasmita Patra <sisinty.s.patra@intel.com>
- *
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "rotary.h"
-#include "upm_fti.h"
-#include "upm_math.h"
-
-/** 
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_rotary_name[] = "Grove Rotary";
-const char upm_rotary_description[] = "Analog Grove Rotary Sensor";
-const upm_protocol_t upm_rotary_protocol[] = {UPM_ANALOG};
-const upm_sensor_t upm_rotary_category[] = {UPM_VOLTAGE, UPM_ANGLE};
-
-// forward declarations
-const upm_sensor_descriptor_t upm_rotary_get_descriptor();
-const void* upm_rotary_get_ft(upm_sensor_t sensor_type);
-void* upm_rotary_init_name();
-void upm_rotary_close(void* dev);
-upm_result_t upm_rotary_get_value_voltage (const void* dev, float* volts);
-upm_result_t upm_rotary_get_value_angle(void* dev, float* rotval,
-                                        upm_angle_u unit);
-
-const upm_sensor_descriptor_t upm_rotary_get_descriptor() {
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_rotary_name;
-    usd.description = upm_rotary_description;
-    usd.protocol_size = 1;
-    usd.protocol = upm_rotary_protocol;
-    usd.category_size = 1;
-    usd.category = upm_rotary_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = &upm_rotary_init_name,
-    .upm_sensor_close = &upm_rotary_close,
-    .upm_sensor_get_descriptor = &upm_rotary_get_descriptor
-};
-
-static const upm_voltage_ft vft =
-{
-    .upm_voltage_get_value = &upm_rotary_get_value_voltage
-};
-
-static const upm_angle_ft aft =
-{
-    .upm_angle_get_value = &upm_rotary_get_value_angle
-};
-
-const void* upm_rotary_get_ft(upm_sensor_t sensor_type) {
-    if(sensor_type == UPM_SENSOR) {
-        return &ft;
-    }
-    if(sensor_type == UPM_VOLTAGE) {
-        return &vft;
-    }
-    if(sensor_type == UPM_ANGLE) {
-        return &aft;
-    }
-    return NULL;
-}
-
-void* upm_rotary_init_name(){
-    return NULL;
-}
-
-void upm_rotary_close(void* dev)
-{
-    rotary_close((rotary_context)dev);
-}
-
-upm_result_t upm_rotary_get_value_voltage (const void* dev, float* volts)
-{
-    return rotary_get_value_voltage((rotary_context)dev, volts);
-}
-
-upm_result_t upm_rotary_get_value_angle (void* dev, float* rotval,
-                                         upm_angle_u unit)
-{
-    float degrees;
-
-    // returned in degrees
-    rotary_get_value_angle((rotary_context)dev, &degrees);
-
-    switch(unit)
-        {
-        case DEGREES:
-            *rotval = degrees;
-            return UPM_SUCCESS;
-
-        case RADIANS:
-            *rotval = degrees * M_PI / 180.0;
-
-            return UPM_SUCCESS;
-
-        default:
-            return UPM_ERROR_INVALID_PARAMETER;
-        }
-}
diff --git a/src/rotaryencoder/CMakeLists.txt b/src/rotaryencoder/CMakeLists.txt
deleted file mode 100644
index 473e5a9..0000000
--- a/src/rotaryencoder/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME rotaryencoder
-    DESCRIPTION "Rotary Encoder"
-    C_HDR rotaryencoder.h
-    C_SRC rotaryencoder.c
-    CPP_HDR rotaryencoder.hpp
-    CPP_SRC rotaryencoder.cxx
-    FTI_SRC rotaryencoder_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa)
diff --git a/src/rotaryencoder/rotaryencoder.c b/src/rotaryencoder/rotaryencoder.c
deleted file mode 100644
index 640080f..0000000
--- a/src/rotaryencoder/rotaryencoder.c
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <assert.h>
-#include "rotaryencoder.h"
-
-
-// our ISR
-static void rotaryencoder_isr(void *ctx)
-{
-    assert (ctx != NULL);
-
-    rotaryencoder_context dev = (rotaryencoder_context)ctx;
-
-    if (mraa_gpio_read(dev->gpioA))
-    {
-        if (mraa_gpio_read(dev->gpioB))
-            dev->position++;      // CW
-        else
-            dev->position--;      // CCW
-    }
-}
-
-rotaryencoder_context rotaryencoder_init(int pin_a, int pin_b)
-{
-    rotaryencoder_context dev =
-        (rotaryencoder_context)malloc(sizeof(struct _rotaryencoder_context));
-
-    if (!dev)
-        return NULL;
-
-    dev->gpioA = NULL;
-    dev->gpioB = NULL;
-
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        rotaryencoder_close(dev);
-        return NULL;
-    }
-
-    // MRAA contexts...
-    if ( !(dev->gpioA = mraa_gpio_init(pin_a)) )
-    {
-        printf("%s: mraa_gpio_init(pin_a) failed\n",
-               __FUNCTION__);
-        rotaryencoder_close(dev);
-        return NULL;
-    }
-
-    mraa_gpio_dir(dev->gpioA, MRAA_GPIO_IN);
-
-    if ( !(dev->gpioB = mraa_gpio_init(pin_b)) )
-    {
-        printf("%s: mraa_gpio_init(pin_b) failed\n",
-               __FUNCTION__);
-        rotaryencoder_close(dev);
-        return NULL;
-    }
-
-    mraa_gpio_dir(dev->gpioB, MRAA_GPIO_IN);
-
-    dev->position = 0;
-
-    // setup the ISR
-
-    // We would prefer to use MRAA_GPIO_EDGE_BOTH for better resolution,
-    // but that does not appear to be supported universally
-    if (mraa_gpio_isr(dev->gpioA, MRAA_GPIO_EDGE_RISING,
-                      &rotaryencoder_isr, dev))
-    {
-        printf("%s: mraa_gpio_isr() failed\n",
-               __FUNCTION__);
-        rotaryencoder_close(dev);
-        return NULL;
-    }
-
-    return dev;
-}
-
-void rotaryencoder_close(rotaryencoder_context dev)
-{
-    assert (dev != NULL);
-
-    if (dev->gpioA)
-    {
-        mraa_gpio_isr_exit(dev->gpioA);
-        mraa_gpio_close(dev->gpioA);
-    }
-
-    if (dev->gpioB)
-        mraa_gpio_close(dev->gpioB);
-
-    free(dev);
-}
-
-void rotaryencoder_set_position(const rotaryencoder_context dev, int count)
-{
-    assert (dev != NULL);
-
-    dev->position = count;
-}
-
-int rotaryencoder_get_position(const rotaryencoder_context dev)
-{
-    assert (dev != NULL);
-
-    return dev->position;
-}
diff --git a/src/rotaryencoder/rotaryencoder.cxx b/src/rotaryencoder/rotaryencoder.cxx
deleted file mode 100644
index 71370c7..0000000
--- a/src/rotaryencoder/rotaryencoder.cxx
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015-2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "rotaryencoder.hpp"
-
-using namespace upm;
-
-RotaryEncoder::RotaryEncoder(int pinA, int pinB) :
-    m_rotaryencoder(rotaryencoder_init(pinA, pinB))
-{
-    if (!m_rotaryencoder)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": rotaryencoder_init failed");
-}
-
-RotaryEncoder::~RotaryEncoder()
-{
-    rotaryencoder_close(m_rotaryencoder);
-}
-
-void RotaryEncoder::initPosition(int count)
-{
-    rotaryencoder_set_position(m_rotaryencoder, count);
-}
-
-int RotaryEncoder::position()
-{
-    return rotaryencoder_get_position(m_rotaryencoder);
-}
-
-
diff --git a/src/rotaryencoder/rotaryencoder.h b/src/rotaryencoder/rotaryencoder.h
deleted file mode 100644
index 02f514d..0000000
--- a/src/rotaryencoder/rotaryencoder.h
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <upm.h>
-
-#include <mraa/gpio.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    /**
-     * @file rotaryencoder.h
-     * @library rotaryencoder
-     * @brief C API for the rotaryencoder driver
-     *
-     * @include rotaryencoder.c
-     */
-
-    /**
-     * Device context
-     */
-    typedef struct _rotaryencoder_context {
-        mraa_gpio_context gpioA;
-        mraa_gpio_context gpioB;
-
-        volatile int position;
-    } *rotaryencoder_context;
-
-    /**
-     * RotaryEncoder initialization
-     *
-     * @param pinA Digital pin to use for signal A
-     * @param pinB Digital pin to use for signal B
-     */
-    rotaryencoder_context rotaryencoder_init(int pin_a, int pin_b);
-
-    /**
-     * RotaryEncoder close function
-     */
-    void rotaryencoder_close(rotaryencoder_context dev);
-
-    /**
-     * Resets the position to a given number.
-     *
-     * @param count Integer to initialize the position to
-     */
-    void rotaryencoder_set_position(const rotaryencoder_context dev,
-                                    int count);
-
-    /**
-     * Gets the position value.
-     *
-     */
-    int rotaryencoder_get_position(const rotaryencoder_context dev);
-
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/rotaryencoder/rotaryencoder.hpp b/src/rotaryencoder/rotaryencoder.hpp
deleted file mode 100644
index 9c715e4..0000000
--- a/src/rotaryencoder/rotaryencoder.hpp
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015-2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include "rotaryencoder.h"
-
-namespace upm {
-
-    /**
-     * @brief Rotary Encoder
-     * @defgroup rotaryencoder libupm-rotaryencoder
-     * @ingroup seeed gpio other hak
-     */
-
-    /**
-     * @library rotaryencoder
-     * @sensor rotaryencoder
-     * @comname Rotary Encoder
-     * @type other
-     * @man seeed
-     * @web http://www.seeedstudio.com/wiki/Grove_-_Encoder
-     * @con gpio
-     * @kit hak
-     *
-     * @brief API for the Grove Rotary Encoder
-     *
-     * UPM module for the Grove rotary encoder. This rotary encoder
-     * encodes a rotation signal into electronic pulses that can be used
-     * to measure rotation and direction. It is useful in cases where a
-     * rotary knob is required, but using a potentiometer is not
-     * desirable. A rotary encoder can turn a full 360 degrees
-     * without a stop and does not place a resistive load on the
-     * circuit, as is the case with a potentiometer.
-     *
-     * This module maintains a position that is incremented or
-     * decremented according to the rotation on the encoder.
-     *
-     * @image html rotaryencoder.jpg
-     * @snippet rotaryencoder.cxx Interesting
-     */
-
-    class RotaryEncoder {
-    public:
-        /**
-         * RotaryEncoder constructor
-         *
-         * @param pinA Digital pin to use for signal A
-         * @param pinB Digital pin to use for signal B
-         */
-        RotaryEncoder(int pinA, int pinB);
-        /**
-         * RotaryEncoder destructor
-         */
-        ~RotaryEncoder();
-
-        /**
-         * Resets the position to a given number; default is 0.
-         *
-         * @param count Integer to initialize the position to
-         */
-        void initPosition(int count=0);
-
-        /**
-         * Gets the position value
-         *
-         */
-        int position();
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        RotaryEncoder(const RotaryEncoder&) = delete;
-        RotaryEncoder &operator=(const RotaryEncoder&) = delete;
-
-        rotaryencoder_context m_rotaryencoder;
-    };
-}
-
-
diff --git a/src/rotaryencoder/rotaryencoder.i b/src/rotaryencoder/rotaryencoder.i
deleted file mode 100644
index 25bec23..0000000
--- a/src/rotaryencoder/rotaryencoder.i
+++ /dev/null
@@ -1,16 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%ignore signalAISR;
-
-JAVA_JNI_LOADLIBRARY(javaupm_rotaryencoder)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "rotaryencoder.hpp"
-%}
-%include "rotaryencoder.hpp"
-/* END Common SWIG syntax */
diff --git a/src/rotaryencoder/rotaryencoder.json b/src/rotaryencoder/rotaryencoder.json
deleted file mode 100644
index 0dc6ab0..0000000
--- a/src/rotaryencoder/rotaryencoder.json
+++ /dev/null
@@ -1,58 +0,0 @@
-{
-    "Library": "rotaryencoder",
-    "Description": "Grove Rotary Encoder library",
-    "Sensor Class": {
-        "RotaryEncoder": {
-            "Name": "API for the Grove Rotary Encoder",
-            "Description": "This is the UPM Module for the Grove Rotary Encoder. This rotary encoder encodes a rotation signal into electronic pulses that can be used to measure rotation and direction. It is useful in cases where a rotary knob is required, but using a potentiometer is not desirable. A rotary encoder can turn a full 360 degrees without a stop and does not place a resistive load on the circuit, as is the case with a potentiometer.",
-            "Aliases": ["rotaryencoder", "Rotary Encoder", "Grove - Encoder"],
-            "Categories": ["other"],
-            "Connections": ["gpio"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["Seeed"],
-            "Kits": ["hak"],
-            "Image": "rotaryencoder.jpg",
-            "Examples": {
-                "Java": ["RotaryEncoder_Example.java"],
-                "Python": ["rotaryencoder.py"],
-                "Node.js": ["rotaryencoder.js"],
-                "C++": ["rotaryencoder.cxx"],
-                "C": ["rotaryencoder.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 4.5,
-                    "max": 5.5
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "min": 10,
-                    "max": 30
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Rotary Angle": {
-                    "unit": "Â°",
-                    "min": 0,
-                    "max": 360
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-Encoder-p-1352.html"],
-                "Datasheets": ["http://wiki.seeed.cc/Grove-Encoder/"]
-            }
-        }
-    }
-}
diff --git a/src/rotaryencoder/rotaryencoder_fti.c b/src/rotaryencoder/rotaryencoder_fti.c
deleted file mode 100644
index 2f5e239..0000000
--- a/src/rotaryencoder/rotaryencoder_fti.c
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "rotaryencoder.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-
-#include "upm_fti.h"
-#include "fti/upm_sensor.h"
-
-/**
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_rotaryencoder_name[] = "ROTARYENCODER";
-const char upm_rotaryencoder_description[] = "Rotary Encoder";
-const upm_protocol_t upm_rotaryencoder_protocol[] = {UPM_GPIO, UPM_GPIO};
-const upm_sensor_t upm_rotaryencoder_category[] = {UPM_ROTARYENCODER};
-
-// forward declarations
-const upm_sensor_descriptor_t upm_rotaryencoder_get_descriptor();
-const void* upm_rotaryencoder_get_ft(upm_sensor_t sensor_type);
-void* upm_rotaryencoder_init_name();
-void upm_rotaryencoder_close(void* dev);
-upm_result_t upm_rotaryencoder_get_pos(const void* dev, int *pos);
-upm_result_t upm_rotaryencoder_set_pos(const void* dev, int pos);
-
-const upm_sensor_descriptor_t upm_rotaryencoder_get_descriptor()
-{
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_rotaryencoder_name;
-    usd.description = upm_rotaryencoder_description;
-    usd.protocol_size = 2;
-    usd.protocol = upm_rotaryencoder_protocol;
-    usd.category_size = 1;
-    usd.category = upm_rotaryencoder_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = upm_rotaryencoder_init_name,
-    .upm_sensor_close = upm_rotaryencoder_close,
-    .upm_sensor_get_descriptor = upm_rotaryencoder_get_descriptor
-};
-
-static const upm_rotaryencoder_ft rft =
-{
-    .upm_rotaryencoder_get_position = upm_rotaryencoder_get_pos,
-    .upm_rotaryencoder_set_position = upm_rotaryencoder_set_pos,
-};
-
-const void* upm_rotaryencoder_get_ft(upm_sensor_t sensor_type)
-{
-    if (sensor_type == UPM_SENSOR)
-        return &ft;
-
-    if (sensor_type == UPM_ROTARYENCODER)
-        return &rft;
-
-    return NULL;
-}
-
-void* upm_rotaryencoder_init_name()
-{
-    return NULL;
-}
-
-void upm_rotaryencoder_close(void* dev)
-{
-    rotaryencoder_close((rotaryencoder_context)dev);
-}
-
-upm_result_t upm_rotaryencoder_set_pos(const void *dev, int pos)
-{
-    rotaryencoder_set_position((rotaryencoder_context)dev, pos);
-    return UPM_SUCCESS;
-}
-
-upm_result_t upm_rotaryencoder_get_pos(const void *dev, int *pos)
-{
-    *pos = rotaryencoder_get_position((rotaryencoder_context)dev);
-    return UPM_SUCCESS;
-}
diff --git a/src/rpr220/CMakeLists.txt b/src/rpr220/CMakeLists.txt
deleted file mode 100644
index af12ab6..0000000
--- a/src/rpr220/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME rpr220
-    DESCRIPTION "Infrared (IR) Reflective Sensor"
-    C_HDR rpr220.h
-    C_SRC rpr220.c
-    CPP_HDR rpr220.hpp
-    CPP_SRC rpr220.cxx
-    FTI_SRC rpr220_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa)
diff --git a/src/rpr220/rpr220.c b/src/rpr220/rpr220.c
deleted file mode 100644
index 0e8981c..0000000
--- a/src/rpr220/rpr220.c
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <assert.h>
-
-#include "rpr220.h"
-
-rpr220_context rpr220_init(int pin)
-{
-    rpr220_context dev =
-        (rpr220_context)malloc(sizeof(struct _rpr220_context));
-
-    if (!dev)
-        return NULL;
-
-    dev->gpio = NULL;
-    dev->isrInstalled = false;
-
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        rpr220_close(dev);
-        return NULL;
-    }
-
-    // MRAA contexts...
-    if ( !(dev->gpio = mraa_gpio_init(pin)) )
-    {
-        printf("%s: mraa_gpio_init() failed\n",
-               __FUNCTION__);
-        rpr220_close(dev);
-        return NULL;
-    }
-
-    mraa_gpio_dir(dev->gpio, MRAA_GPIO_IN);
-
-    return dev;
-}
-
-void rpr220_close(rpr220_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->isrInstalled)
-        rpr220_uninstall_isr(dev);
-
-    if (dev->gpio)
-        mraa_gpio_close(dev->gpio);
-
-    free(dev);
-}
-
-bool rpr220_black_detected(const rpr220_context dev)
-{
-    assert(dev != NULL);
-
-    return (mraa_gpio_read(dev->gpio) ? true : false);
-}
-
-void rpr220_install_isr(const rpr220_context dev,
-                        void (*isr)(void *), void *arg)
-{
-    assert(dev != NULL);
-
-    if (dev->isrInstalled)
-        rpr220_uninstall_isr(dev);
-
-    // install our interrupt handler
-    if (mraa_gpio_isr(dev->gpio, MRAA_GPIO_EDGE_RISING, isr, arg))
-    {
-        printf("%s: mraa_gpio_isr() failed.\n", __FUNCTION__);
-        return;
-    }
-
-    dev->isrInstalled = true;
-}
-
-void rpr220_uninstall_isr(const rpr220_context dev)
-{
-    assert(dev != NULL);
-
-    mraa_gpio_isr_exit(dev->gpio);
-    dev->isrInstalled = false;
-}
diff --git a/src/rpr220/rpr220.cxx b/src/rpr220/rpr220.cxx
deleted file mode 100644
index a8b503f..0000000
--- a/src/rpr220/rpr220.cxx
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015-2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "rpr220.hpp"
-
-using namespace upm;
-using namespace std;
-
-RPR220::RPR220(int pin) :
-    m_rpr220(rpr220_init(pin))
-{
-    if (!m_rpr220)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": rpr220_init() failed");
-}
-
-RPR220::~RPR220()
-{
-    rpr220_close(m_rpr220);
-}
-
-bool RPR220::blackDetected()
-{
-    return rpr220_black_detected(m_rpr220);
-}
-
-
-
-void RPR220::installISR(void (*isr)(void *), void *arg)
-{
-    rpr220_install_isr(m_rpr220, isr, arg);
-}
-
-void RPR220::uninstallISR()
-{
-    rpr220_uninstall_isr(m_rpr220);
-}
diff --git a/src/rpr220/rpr220.h b/src/rpr220/rpr220.h
deleted file mode 100644
index 6b733b6..0000000
--- a/src/rpr220/rpr220.h
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <upm.h>
-
-#include <mraa/gpio.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    /**
-     * @file rpr220.h
-     * @library rpr220
-     * @brief C API for the rpr220 driver
-     *
-     * @include rpr220.c
-     */
-
-    /**
-     * Device context
-     */
-    typedef struct _rpr220_context {
-        mraa_gpio_context gpio;
-
-        bool isrInstalled;
-    } *rpr220_context;
-
-    /**
-     * RPR220 initialization.
-     *
-     * @param pin Digital pin to use.
-     * @return rpr220 device context
-     */
-    rpr220_context rpr220_init(int pin);
-
-    /**
-     * RPR220 destructor
-     *
-     * @param dev Device context.
-     */
-    void rpr220_close(rpr220_context dev);
-
-    /**
-     * Gets the status of the pin; true means black has been detected
-     *
-     * @param dev Device context.
-     * @return True if the sensor has detected black
-     */
-    bool rpr220_black_detected(const rpr220_context dev);
-
-    /**
-     * Installs an ISR to be called when
-     * black is detected
-     *
-     * @param dev Device context.
-     * @param isr Pointer to a function to be called on interrupt
-     * @param arg Pointer to an object to be supplied as an
-     * argument to the ISR.
-     */
-    void rpr220_install_isr(const rpr220_context dev,
-                            void (*isr)(void *), void *arg);
-
-    /**
-     * Uninstalls the previously installed ISR
-     *
-     * @param dev Device context.
-     */
-    void rpr220_uninstall_isr(const rpr220_context dev);
-
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/rpr220/rpr220.hpp b/src/rpr220/rpr220.hpp
deleted file mode 100644
index 95cf6db..0000000
--- a/src/rpr220/rpr220.hpp
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015-2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <rpr220.h>
-
-namespace upm {
-
-    /**
-     * @brief RPR220 IR Reflective Sensor
-     * @defgroup rpr220 libupm-rpr220
-     * @ingroup seeed gpio light tsk hak
-     */
-    /**
-     * @library rpr220
-     * @sensor rpr220
-     * @comname Infrared (IR) Reflective Sensor
-     * @altname Grove IR Reflective Sensor
-     * @type light
-     * @man seeed
-     * @web http://www.seeedstudio.com/wiki/Grove_-_Infrared_Reflective_Sensor
-     * @con gpio
-     * @kit tsk hak
-     *
-     * @brief API for the RPR220-based Grove IR Reflective Sensor
-     *
-     * UPM module for the Grove IR reflective sensor. The sensitivity
-     * can be adjusted with the potentiometer on the sensor module. It
-     * has a range of approximately 15 mm, and a quick response time.
-     *
-     * It detects high-contrast dark areas on a light background.
-     *
-     * This module allows the user to determine the current status
-     * (black detected or not). Additionally, if desired, an interrupt
-     * service routine (ISR) can be installed that is called when
-     * black is detected. Either method can be used, depending on your
-     * use case.
-     *
-     * @image html rpr220.jpg
-     * @snippet rpr220.cxx Interesting
-     * @snippet rpr220-intr.cxx Interesting
-     */
-    class RPR220 {
-    public:
-        /**
-         * RPR220 constructor
-         *
-         * @param pin Digital pin to use
-         */
-        RPR220(int pin);
-
-        /**
-         * RPR220 destructor
-         */
-        ~RPR220();
-
-        /**
-         * Gets the status of the pin; true means black has been detected
-         *
-         * @return True if the sensor has detected black
-         */
-        bool blackDetected();
-
-
-        /**
-         * Installs an ISR to be called when
-         * black is detected
-         *
-         * @param isr Pointer to a function to be called on interrupt
-         * @param arg Pointer to an object to be supplied as an
-         * argument to the ISR.
-         */
-        void installISR(void (*isr)(void *), void *arg);
-
-        /**
-         * Uninstalls the previously installed ISR
-         *
-         */
-        void uninstallISR();
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        RPR220(const RPR220&) = delete;
-        RPR220 &operator=(const RPR220&) = delete;
-
-        rpr220_context m_rpr220;
-
-    };
-}
diff --git a/src/rpr220/rpr220.i b/src/rpr220/rpr220.i
deleted file mode 100644
index 6924374..0000000
--- a/src/rpr220/rpr220.i
+++ /dev/null
@@ -1,15 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_ADD_INSTALLISR(upm::RPR220)
-JAVA_JNI_LOADLIBRARY(javaupm_rpr220)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "rpr220.hpp"
-%}
-%include "rpr220.hpp"
-/* END Common SWIG syntax */
diff --git a/src/rpr220/rpr220.json b/src/rpr220/rpr220.json
deleted file mode 100644
index e950643..0000000
--- a/src/rpr220/rpr220.json
+++ /dev/null
@@ -1,64 +0,0 @@
-{
-    "Library": "rpr220",
-    "Description": "ROHM Semiconductor RPR220 IR Reflective Sensor library",
-    "Sensor Class": {
-        "RPR220": {
-            "Name": "API for the ROHM Semiconductor RPR220-based Grove IR Reflective Sensor",
-            "Description": "This is the UPM Module for the ROHM Semiconductor RPR220-based Grove IR Reflective Sensor. The reflectivity of infrared light varies with the color and distance of the reflecting surface. According to this principle, Grove - Infrared Reflective Sensor utilizes a RPR220 reflective photosensor module to detect color and distance. When a light-colored object approaches,the signal intensity received by infrared reflective sensor increases and the indicator LED on board turns red. When a dark-colored object approaches, the intensity decreases and the LED turns off.",
-            "Aliases": ["rpr220", "Grove - Infrared Reflective Sensor"],
-            "Categories": ["light"],
-            "Connections": ["gpio"],
-            "Project Type": ["mprototyping", "commercial"],
-            "Manufacturers": ["ROHM Semiconductor", "Seeed"],
-            "Kits": ["tsk", "hak"],
-            "Image": "rpr220.jpg",
-            "Examples": {
-                "Java": ["RPR220_Example.java", "RPR220_intr_Example.java"],
-                "Python": ["rpr220.py"],
-                "Node.js": ["rpr220.js"],
-                "C++": ["rpr220-intr.cxx", "rpr220.cxx"],
-                "C": ["rpr220-intr.c", "rpr220.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.3,
-                    "max": 5.0
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "min" : 14.69,
-                    "max" : 15.35
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Effective Distance": {
-                    "unit": "mm",
-                    "min": 4,
-                    "max": 15
-                },
-                "Response Time": {
-                    "unit": "us",
-                    "typ": 10
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-Infrared-Reflective-Sensor-p-1230.html", "http://wiki.seeed.cc/Grove-Infrared_Reflective_Sensor/"],
-                "Datasheets": ["https://raw.githubusercontent.com/SeeedDocument/Grove-Infrared_Reflective_Sensor/master/res/RPR220_datasheet.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/rpr220/rpr220_fti.c b/src/rpr220/rpr220_fti.c
deleted file mode 100644
index 1a6cc31..0000000
--- a/src/rpr220/rpr220_fti.c
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "rpr220.h"
-#include <upm_fti.h>
-
-/**
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_rpr220_name[] = "RPR220";
-const char upm_rpr220_description[] = "IR Reflective Sensor";
-const upm_protocol_t upm_rpr220_protocol[] = {UPM_GPIO};
-const upm_sensor_t upm_rpr220_category[] = {UPM_BINARY};
-
-// forward declarations
-const void* upm_rpr220_get_ft(upm_sensor_t sensor_type);
-void* upm_rpr220_init_name();
-void upm_rpr220_close(void *dev);
-upm_result_t upm_rpr220_black_detected(void *dev, bool *value);
-
-const upm_sensor_descriptor_t upm_rpr220_get_descriptor()
-{
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_rpr220_name;
-    usd.description = upm_rpr220_description;
-    usd.protocol_size = 1;
-    usd.protocol = upm_rpr220_protocol;
-    usd.category_size = 1;
-    usd.category = upm_rpr220_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-  .upm_sensor_init_name = upm_rpr220_init_name,
-  .upm_sensor_close = upm_rpr220_close,
-};
-
-static const upm_binary_ft bft =
-{
-  .upm_binary_get_value = upm_rpr220_black_detected,
-};
-
-const void* upm_rpr220_get_ft(upm_sensor_t sensor_type)
-{
-  switch(sensor_type)
-    {
-    case UPM_SENSOR:
-      return &ft;
-    case UPM_BINARY:
-      return &bft;
-    default:
-      return NULL;
-    }
-}
-
-void *upm_rpr220_init_name()
-{
-  return NULL;
-}
-
-void upm_rpr220_close(void *dev)
-{
-  rpr220_close((rpr220_context)dev);
-}
-
-upm_result_t upm_rpr220_black_detected(void *dev, bool *value)
-{
-  *value = rpr220_black_detected((rpr220_context)dev);
-
-  return UPM_SUCCESS;
-}
diff --git a/src/rsc/CMakeLists.txt b/src/rsc/CMakeLists.txt
deleted file mode 100644
index d59a1da..0000000
--- a/src/rsc/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-upm_mixed_module_init (NAME rsc
-    DESCRIPTION "Honeywell RSC TruStability Pressure and Temperature Sensor"
-    C_HDR rsc.h rsc_regs.h
-    C_SRC rsc.c
-    CPP_HDR rsc.hpp
-    CPP_SRC rsc.cxx
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/rsc/rsc.c b/src/rsc/rsc.c
deleted file mode 100644
index cb7daa9..0000000
--- a/src/rsc/rsc.c
+++ /dev/null
@@ -1,534 +0,0 @@
-/*
- * Author: Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#include "rsc.h"
-#include "upm_utilities.h"
-
-upm_result_t rsc_eeprom_read(rsc_context dev, uint16_t address, uint8_t* buf, int len, uint8_t arglen);
-
-upm_result_t rsc_adc_write(rsc_context dev, uint8_t reg, uint8_t num_bytes, uint8_t* write_data);
-
-upm_result_t rsc_adc_read(rsc_context dev, READING_T type, uint8_t* data);
-
-upm_result_t rsc_add_dr_delay(rsc_context dev);
-
-void rsc_set_access_type(rsc_context dev, ACCESS_T type);
- 
-rsc_context rsc_init(int bus, int cs_ee_pin, int cs_adc_pin) {
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        return NULL;
-    }
-
-    rsc_context dev = (rsc_context) malloc(sizeof(struct _rsc_context));
-    if (!dev) {
-        return NULL;
-    }
-
-    dev->spi_bus_number = bus;
-
-    dev->spi = mraa_spi_init(dev->spi_bus_number);
-    if(dev->spi == NULL)
-        printf("RSC: SPI context not initialized\n");
-
-    // initializing the EEPROM chip select
-    dev->cs_ee = mraa_gpio_init(cs_ee_pin);
-    if(dev->cs_ee == NULL)
-        printf("RSC: EEPROM GPIO context not initialized\n");
-
-    if(mraa_gpio_dir(dev->cs_ee, MRAA_GPIO_OUT) != MRAA_SUCCESS)
-        printf("RSC: EEPROM GPIO direction could not be set\n");
-    mraa_gpio_write(dev->cs_ee, 1);
-
-    // initializing the ADC chip select
-    dev->cs_adc = mraa_gpio_init(cs_adc_pin);
-    if(dev->cs_adc == NULL)
-        printf("RSC: ADC GPIO context not initialized\n");
-
-    if(mraa_gpio_dir(dev->cs_adc, MRAA_GPIO_OUT) != MRAA_SUCCESS)
-        printf("RSC: ADC GPIO direction could not be set\n");
-    mraa_gpio_write(dev->cs_adc, 1);
-
-    // setting the frequency and spi mode
-    mraa_spi_frequency(dev->spi, 1250000);
-    //mraa_spi_mode(dev->spi, MRAA_SPI_MODE0);
-    //rsc_set_access_type(dev, EEPEROM);
-	
-    upm_delay_ms(100);
-
-    uint8_t sensor_name[RSC_SENSOR_NAME_LEN]={0};
-    rsc_get_sensor_name(dev, sensor_name);
-    //printf("sensor name: %s\n", sensor_name);
-
-    upm_delay_ms(10);
-    uint8_t serial_number[RSC_SENSOR_NUMBER_LEN]={0};
-    rsc_get_sensor_serial_number(dev, serial_number);
-    //printf("sensor serial number: %s\n", serial_number);
-
-    upm_delay_ms(10);
-    float range = rsc_get_pressure_range(dev);
-    dev->pressure_range = range;
-
-    upm_delay_ms(10);
-    float min_pressure = rsc_get_minimum_pressure(dev);
-    dev->min_pressure_val = min_pressure;
-
-    upm_delay_ms(10);
-    rsc_get_pressure_unit(dev);
-
-    upm_delay_ms(10);
-    rsc_get_pressure_type(dev);
-
-    uint8_t adc_init_values[4];
-    rsc_get_initial_adc_values(dev, adc_init_values);
-
-    rsc_retrieve_coefficients(dev);
-
-    //mraa_spi_frequency(dev->spi, 1250000);
-    //mraa_spi_mode(dev->spi, MRAA_SPI_MODE1);
-    //rsc_set_access_type(dev, ADC);
-    rsc_setup_adc(dev, adc_init_values);
-
-    rsc_set_data_rate(dev, N_DR_20_SPS);
-    rsc_set_mode(dev, NORMAL_MODE);
-
-    rsc_get_temperature(dev);
-    upm_delay_ms(50);
-
-    return dev;
-}
-
-upm_result_t rsc_close(rsc_context dev) {
-    free(dev);
-    return UPM_SUCCESS;
-}
-
-void rsc_set_access_type(rsc_context dev, ACCESS_T type) {
-    switch(type) {
-        case EEPROM:
-            mraa_spi_mode(dev->spi, MRAA_SPI_MODE0);
-        break;
-        case ADC:
-            mraa_spi_mode(dev->spi, MRAA_SPI_MODE1);
-        break;
-        default:
-            // default mode is EEPROM
-            mraa_spi_mode(dev->spi, MRAA_SPI_MODE0);
-    }
-}
-
-upm_result_t rsc_eeprom_read(rsc_context dev, uint16_t address, uint8_t* buf, int len, uint8_t arglen) {
-    uint8_t lbuf[len+arglen];
-    lbuf[0] = RSC_READ_EEPROM_INSTRUCTION;
-    lbuf[1] = address & 0xff;
-    lbuf[0] = ((address & RSC_EEPROM_ADDRESS_9TH_BIT_MASK) >> 5) | lbuf[0];
-
-    mraa_gpio_write(dev->cs_ee, 0);
-    if(mraa_spi_transfer_buf(dev->spi, lbuf, lbuf, len+arglen) != MRAA_SUCCESS) {
-        printf("RSC: ISsues in SPI transfer\n");
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    mraa_gpio_write(dev->cs_ee, 1);
-    int i=0;
-    for(i=arglen;i<len+arglen;i++)
-        buf[i-2] = lbuf[i];
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t rsc_get_sensor_name(rsc_context dev, uint8_t* sensor_name) {
-    rsc_set_access_type(dev, EEPROM);
-    if(rsc_eeprom_read(dev, RSC_CATALOG_LISTING_MSB, sensor_name, RSC_SENSOR_NAME_LEN, RSC_EEPROM_STANDARD_ARGUMENT_LENGTH) != UPM_SUCCESS) {
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    sensor_name[RSC_SENSOR_NAME_LEN-1]='\0'; 
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t rsc_get_sensor_serial_number(rsc_context dev, uint8_t* rsc_number) {
-    rsc_set_access_type(dev, EEPROM);
-    if(rsc_eeprom_read(dev, RSC_SERIAL_NO_YYYY_MSB, rsc_number, RSC_SENSOR_NUMBER_LEN, RSC_EEPROM_STANDARD_ARGUMENT_LENGTH) != UPM_SUCCESS) {
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    rsc_number[RSC_SENSOR_NUMBER_LEN-1]='\0';
-
-    return UPM_SUCCESS;
-}
-
-float rsc_get_pressure_range(rsc_context dev) {
-    uint32_t alt_range;
-    uint8_t buf[RSC_PRESSURE_RANGE_LEN]={0};
-
-    rsc_set_access_type(dev, EEPROM);
-
-    rsc_eeprom_read(dev, RSC_PRESSURE_RANGE_LSB, buf, RSC_PRESSURE_RANGE_LEN, RSC_EEPROM_STANDARD_ARGUMENT_LENGTH);
-
-    alt_range = (buf[0] | (buf[1]<<8) | (buf[2]<<16) | (buf[3]<<24));
-
-    return *(float*)&alt_range;
-}
-
-float rsc_get_minimum_pressure(rsc_context dev) {
-    uint32_t alt_range;
-    uint8_t buf[RSC_PRESSURE_MINIMUM_LEN]={0};
-
-    rsc_set_access_type(dev, EEPROM);
-
-    rsc_eeprom_read(dev, RSC_PRESSURE_MINIMUM_LSB, buf, RSC_PRESSURE_MINIMUM_LEN, RSC_EEPROM_STANDARD_ARGUMENT_LENGTH);
-
-    alt_range = (buf[0] | (buf[1]<<8) | (buf[2]<<16) | (buf[3]<<24));
-
-    return *(float*)&alt_range;
-}
-
-PRESSURE_U rsc_get_pressure_unit(rsc_context dev) {
-    uint8_t pressure_unit[RSC_PRESSURE_UNIT_LEN]={0};
-
-    rsc_set_access_type(dev, EEPROM);
-
-    rsc_eeprom_read(dev, RSC_PRESSURE_UNIT_MSB, pressure_unit, RSC_PRESSURE_UNIT_LEN, RSC_EEPROM_STANDARD_ARGUMENT_LENGTH);
-
-    pressure_unit[RSC_PRESSURE_UNIT_LEN-1]='\0';
-
-    if(pressure_unit[RSC_PRESSURE_UNIT_LEN-2] == 'O')
-        dev->unit = INH2O;
-    else if(pressure_unit[RSC_PRESSURE_UNIT_LEN-2] == 'a')
-        if(pressure_unit[RSC_PRESSURE_UNIT_LEN-4] == 'K')
-            dev->unit = KPASCAL;
-        else if (pressure_unit[RSC_PRESSURE_UNIT_LEN-4] == 'M')
-            dev->unit = MPASCAL;
-        else
-            dev->unit = PASCAL;
-    else if(pressure_unit[RSC_PRESSURE_UNIT_LEN-2] == 'r')
-        if(pressure_unit[RSC_PRESSURE_UNIT_LEN-5] == 'm')
-            dev->unit = mBAR;
-        else
-            dev->unit = BAR;
-    else if(pressure_unit[RSC_PRESSURE_UNIT_LEN-2] == 'i')
-        dev->unit = PSI;
-
-    return dev->unit;
-}
-
-PRESSURE_T rsc_get_pressure_type(rsc_context dev) {
-    uint8_t type;
-
-    rsc_set_access_type(dev, EEPROM);
-
-    rsc_eeprom_read(dev, RSC_PRESSURE_REFERENCE, &type, RSC_SENSOR_TYPE_LEN, RSC_EEPROM_STANDARD_ARGUMENT_LENGTH);
-
-    switch (type) {
-        case 'D':
-            dev->type = DIFFERENTIAL;
-        break;
-        case 'A':
-            dev->type = ABSOLUTE;
-        break;
-        case 'G':
-            dev->type = GAUGE;
-        break;
-        default:
-            dev->type = DIFFERENTIAL;
-    }
-
-    return dev->type;
-}
-
-upm_result_t rsc_get_initial_adc_values(rsc_context dev, uint8_t* adc_init_values) {
-    rsc_set_access_type(dev, EEPROM);
-
-    rsc_eeprom_read(dev, RSC_ADC_CONDIG_00, &adc_init_values[0], 1, RSC_EEPROM_STANDARD_ARGUMENT_LENGTH);
-    upm_delay_ms(2);
-    rsc_eeprom_read(dev, RSC_ADC_CONDIG_01, &adc_init_values[1], 1, RSC_EEPROM_STANDARD_ARGUMENT_LENGTH);
-    upm_delay_ms(2);
-    rsc_eeprom_read(dev, RSC_ADC_CONDIG_02, &adc_init_values[2], 1, RSC_EEPROM_STANDARD_ARGUMENT_LENGTH);
-    upm_delay_ms(2);
-    rsc_eeprom_read(dev, RSC_ADC_CONDIG_03, &adc_init_values[3], 1, RSC_EEPROM_STANDARD_ARGUMENT_LENGTH);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t rsc_retrieve_coefficients(rsc_context dev) {
-    int base_address = RSC_OFFSET_COEFFICIENT_0_LSB;
-    uint8_t l_coeffs[RSC_COEFF_ADDRESS_SPACE_SIZE]={0};
-    int i,j = 0;
-    uint32_t temp;
-
-    rsc_set_access_type(dev, EEPROM);
-
-    for (i=0; i<RSC_COEFF_T_ROW_NO; i++) {
-        // 80 is the number of bytes that separate the beginning
-        // of the address spaces of all the 3 coefficient groups
-        // refer the datasheet for more info
-        base_address = RSC_OFFSET_COEFFICIENT_0_LSB + i*80;
-        if(rsc_eeprom_read(dev, base_address, l_coeffs, (RSC_COEFF_ADDRESS_SPACE_SIZE), RSC_EEPROM_STANDARD_ARGUMENT_LENGTH) != UPM_SUCCESS) {
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-
-        // storing all the coefficients
-        for(j=0; j<RSC_COEFF_T_COL_NO; j++) {
-            temp = l_coeffs[j*4+0] | 
-                   (l_coeffs[j*4+1]<<8) |
-                   (l_coeffs[j*4+2]<<16) |
-                   (l_coeffs[j*4+3]<<24);
-            dev->coeff_matrix[i][j] = *(float*)&temp;
-        }
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t rsc_adc_write(rsc_context dev, uint8_t reg, uint8_t num_bytes, uint8_t* write_data) {
-    // The number of bytes to write has to be - 1,2,3,4
-    if(num_bytes <= 0 || num_bytes >4)
-        return UPM_ERROR_UNSPECIFIED;
-
-    // the ADC registers are 0,1,2,3
-    if(reg >3)
-        return UPM_ERROR_UNSPECIFIED;
-
-    uint8_t tx[num_bytes+1];
-    // The ADC REG Write command is as follows: 0100 RRNN
-    // R - Register Number (0,1,2,3) N - Number of Bytes (0,1,2,3) (0 means 1)
-    tx[0] = RSC_ADC_WREG|((reg<<2)&RSC_ADC_REG_MASK)|((num_bytes-1)&RSC_ADC_NUM_BYTES_MASK);
-    int cnt = 0;
-    for(cnt=0; cnt<num_bytes; cnt++)
-        tx[cnt+1] = write_data[cnt];
-
-    mraa_gpio_write(dev->cs_adc, 0);
-    if(mraa_spi_transfer_buf(dev->spi, tx, NULL, num_bytes+1) != MRAA_SUCCESS) {
-        printf("RSC: ISsues in SPI transfer\n");
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-    mraa_gpio_write(dev->cs_adc, 1);
-    return UPM_SUCCESS;
-}
-
-upm_result_t rsc_set_data_rate(rsc_context dev, RSC_DATA_RATE dr) {
-    dev->data_rate = dr;
-    switch (dr) {
-        case N_DR_20_SPS:
-        case N_DR_45_SPS:
-        case N_DR_90_SPS:
-        case N_DR_175_SPS:
-        case N_DR_330_SPS:
-        case N_DR_600_SPS:
-        case N_DR_1000_SPS:
-            rsc_set_mode(dev, NORMAL_MODE);
-        break;
-        case F_DR_40_SPS:
-        case F_DR_90_SPS:
-        case F_DR_180_SPS:
-        case F_DR_350_SPS:
-        case F_DR_660_SPS:
-        case F_DR_1200_SPS:
-        case F_DR_2000_SPS:
-            rsc_set_mode(dev, FAST_MODE);
-        break;
-        default:
-            rsc_set_mode(dev, NA_MODE);
-    }
-    return UPM_SUCCESS;
-}
-
-upm_result_t rsc_set_mode(rsc_context dev, RSC_MODE mode) {
-    RSC_MODE l_mode;
-
-    switch(mode) {
-        case NORMAL_MODE:
-            if(dev->data_rate < N_DR_20_SPS || dev->data_rate > N_DR_1000_SPS) {
-                printf("RSC: Normal mode not supported with the current selection of data rate\n");
-                printf("RSC: You will see erronous readings\n");
-                l_mode = NA_MODE;
-            } else
-                l_mode = NORMAL_MODE;
-        break;
-        case FAST_MODE:
-            if(dev->data_rate < F_DR_40_SPS || dev->data_rate > F_DR_2000_SPS) {
-                printf("RSC: Fast mode not supported with the current selection of data rate\n");
-                printf("RSC: You will see erronous readings\n");
-                l_mode = NA_MODE;
-            } else
-                l_mode = FAST_MODE;
-        break;
-        default:
-            l_mode = NA_MODE;
-    }
-    dev->mode = l_mode;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t rsc_adc_read(rsc_context dev, READING_T type, uint8_t* data) { 
-    uint8_t tx[2]={0};
-    tx[0] = RSC_ADC_WREG|((1<<2)&RSC_ADC_REG_MASK);
-
-    // Composing tx[1], which includes Mode, DataRate, Pressure/Temperature choice
-    tx[1] = (((dev->data_rate << RSC_DATA_RATE_SHIFT)&RSC_DATA_RATE_MASK) |
-            ((dev->mode << RSC_OPERATING_MODE_SHIFT)&RSC_OPERATING_MODE_MASK) |
-            (((type&0x01)<<1)|RSC_SET_BITS_MASK));
-
-    mraa_gpio_write(dev->cs_adc, 0);
-    if(mraa_spi_transfer_buf(dev->spi, tx, NULL, 2) != MRAA_SUCCESS) {
-        printf("RSC: ISsues in SPI transfer\n");
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-    mraa_gpio_write(dev->cs_adc, 1);
-
-    // delay would depend on data rate
-    rsc_add_dr_delay(dev);
-    uint8_t tx_1[4]={0x10, 0, 0, 0};
-    mraa_gpio_write(dev->cs_adc, 0);
-    if(mraa_spi_transfer_buf(dev->spi, tx_1, data, 4) != MRAA_SUCCESS) {
-        printf("RSC: ISsues in SPI transfer\n");
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-    mraa_gpio_write(dev->cs_adc, 1);
-
-    return UPM_SUCCESS;
-}
-
-float rsc_get_temperature(rsc_context dev) {
-    uint8_t sec_arr[4]={0};
-    float temp;
-
-    rsc_set_access_type(dev, ADC);
-
-    rsc_adc_read(dev, TEMPERATURE, sec_arr);
-    dev->t_raw = ((sec_arr[1]<<8) | sec_arr[2]) >> 2;
-    temp = dev->t_raw*0.03125;
-
-    return temp;
-}
-
-float rsc_get_pressure(rsc_context dev) {
-    uint8_t sec_arr[4]={0};
-
-    rsc_set_access_type(dev, ADC);
-
-    rsc_adc_read(dev, PRESSURE, sec_arr);
-
-    uint32_t p_raw = (sec_arr[1]<<16)|(sec_arr[2]<<8)|sec_arr[3];
-
-    uint32_t t_raw = dev->t_raw;
-    float x = (dev->coeff_matrix[0][3]*t_raw*t_raw*t_raw);
-    float y = (dev->coeff_matrix[0][2]*t_raw*t_raw);
-    float z = (dev->coeff_matrix[0][1]*t_raw);
-    float p_int1 = p_raw - (x + y + z + dev->coeff_matrix[0][0]);
-
-    x = (dev->coeff_matrix[1][3]*t_raw*t_raw*t_raw);
-    y = (dev->coeff_matrix[1][2]*t_raw*t_raw);
-    z = (dev->coeff_matrix[1][1]*t_raw);
-    float p_int2 = p_int1/(x + y + z + dev->coeff_matrix[1][0]);
-
-    x = (dev->coeff_matrix[2][3]*p_int2*p_int2*p_int2);
-    y = (dev->coeff_matrix[2][2]*p_int2*p_int2);
-    z = (dev->coeff_matrix[2][1]*p_int2);
-    float p_comp_fs = x + y + z + dev->coeff_matrix[2][0];
-
-    float p_comp = (p_comp_fs*dev->pressure_range) + dev->min_pressure_val;
-
-    return p_comp;
-}
-
-upm_result_t rsc_setup_adc(rsc_context dev, uint8_t* adc_init_values) {
-    uint8_t tx=RSC_ADC_RESET_COMMAND;
-
-    rsc_set_access_type(dev, ADC);
-
-    mraa_gpio_write(dev->cs_adc, 0);
-    if(mraa_spi_transfer_buf(dev->spi, &tx, NULL, 1) != MRAA_SUCCESS) {
-        printf("RSC: ISsues in SPI transfer\n");
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-    upm_delay_ms(5);
-
-    uint8_t arr[4] = {adc_init_values[0], adc_init_values[1], adc_init_values[2], adc_init_values[3]};
-    rsc_adc_write(dev, 0, 4, arr);
-
-    mraa_gpio_write(dev->cs_adc, 1);
-    upm_delay_ms(5);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t rsc_add_dr_delay(rsc_context dev) {
-    float delay = 0;
-    // calculating delay based on the Data Rate
-    switch(dev->data_rate){
-        case N_DR_20_SPS:
-            delay = MSEC_PER_SEC/20;
-        break;
-        case N_DR_45_SPS:
-            delay = MSEC_PER_SEC/45;
-        break;
-        case N_DR_90_SPS:
-            delay = MSEC_PER_SEC/90;
-        break;
-        case N_DR_175_SPS:
-            delay = MSEC_PER_SEC/175;
-        break;
-        case N_DR_330_SPS:
-            delay = MSEC_PER_SEC/330;
-        break;
-        case N_DR_600_SPS:
-            delay = MSEC_PER_SEC/600;
-        break;
-        case N_DR_1000_SPS:
-            delay = MSEC_PER_SEC/1000;
-        break;
-        case F_DR_40_SPS:
-            delay = MSEC_PER_SEC/40;
-        break;
-        case F_DR_90_SPS:
-            delay = MSEC_PER_SEC/90;
-        break;
-        case F_DR_180_SPS:
-            delay = MSEC_PER_SEC/180;
-        break;
-        case F_DR_350_SPS:
-            delay = MSEC_PER_SEC/350;
-        break;
-        case F_DR_660_SPS:
-            delay = MSEC_PER_SEC/660;
-        break;
-        case F_DR_1200_SPS:
-            delay = MSEC_PER_SEC/1200;
-        break;
-        case F_DR_2000_SPS:
-            delay = MSEC_PER_SEC/2000;
-        break;
-        default:
-            delay = 50;
-    }
-    upm_delay_ms((int)delay + 2);
-
-    return UPM_SUCCESS;
-}
diff --git a/src/rsc/rsc.cxx b/src/rsc/rsc.cxx
deleted file mode 100644
index 0628596..0000000
--- a/src/rsc/rsc.cxx
+++ /dev/null
@@ -1,182 +0,0 @@
-/*
- * Author: Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "rsc.hpp"
-
-using namespace upm;
-using namespace std;
-
-RSC::RSC(uint8_t bus, uint8_t cs_ee_pin, uint8_t cs_adc_pin) :
-    m_rsc(rsc_init(bus, cs_ee_pin, cs_adc_pin))
-{
-    if(!m_rsc)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                ": rsc_init failed");
-}
-
-RSC::~RSC()
-{
-    rsc_close(m_rsc);
-}
-
-string RSC::getSensorName()
-{
-    uint8_t sensorName[RSC_SENSOR_NAME_LEN]={0};
-    if(rsc_get_sensor_name(m_rsc, sensorName) != UPM_SUCCESS) {
-        throw std::runtime_error(std::string(__FUNCTION__) +
-            ": Unable to read the sensor name");
-    }
-    std::string str((const char*)sensorName);
-
-    return str;
-}
-
-string RSC::getSensorSerialNumber()
-{
-    uint8_t serialNumber[RSC_SENSOR_NUMBER_LEN]={0};
-    if(rsc_get_sensor_serial_number(m_rsc, serialNumber) != UPM_SUCCESS) {
-        throw std::runtime_error(std::string(__FUNCTION__) +
-            ": Unable to read the sensor serial number");
-    }
-    std::string str((const char*)serialNumber);
-
-    return str;
-}
-
-float RSC::getPressureRange()
-{
-    return rsc_get_pressure_range(m_rsc);
-}
-
-float RSC::getMinimumPressure()
-{
-    return rsc_get_minimum_pressure(m_rsc);
-}
-
-string RSC::getPressureUnit()
-{
-    string s_unit;
-    PRESSURE_U unit = rsc_get_pressure_unit(m_rsc);
-    switch(unit){
-        case PASCAL:
-            s_unit = "Pascal";
-        break;
-        case KPASCAL:
-            s_unit = "Kilo Pascal";
-        break;
-        case MPASCAL:
-            s_unit = "Mega Pascal";
-        break;
-        case PSI:
-            s_unit = "PSI";
-        break;
-        case INH2O:
-            s_unit = "inH2O";
-        break;
-        case BAR:
-            s_unit = "Bar";
-        break;
-        case mBAR:
-            s_unit = "milli Bar";
-        break;
-        default:
-            throw std::runtime_error(std::string(__FUNCTION__) +
-                ": Unable to read the pressure unit from sensor");
-    }
-
-    return s_unit;
-}
-
-string RSC::getPressureType()
-{
-    string s_type;
-    PRESSURE_T type = rsc_get_pressure_type(m_rsc);
-    switch(type){
-        case DIFFERENTIAL:
-            s_type = "Differential";
-        break;
-        case ABSOLUTE:
-            s_type = "Absolute";
-        break;
-        case GAUGE:
-            s_type = "Gauge";
-        break;
-        default:
-            throw std::runtime_error(std::string(__FUNCTION__) +
-                ": Unable to read the pressure type from sensor");
-    }
-
-    return s_type;
-}
-
-uint8_t *RSC::getInitialADCState()
-{
-    uint8_t initialState[4]={0,0,0,0};
-    rsc_get_initial_adc_values(m_rsc, initialState);
-    int cnt = 0;
-    for (cnt = 0; cnt<4; cnt++)
-        m_adc_coeff[cnt]=initialState[cnt];
-
-    return m_adc_coeff;
-}
-
-void RSC::updateCoefficients()
-{
-    if(rsc_retrieve_coefficients(m_rsc) != UPM_SUCCESS) {
-        throw std::runtime_error(std::string(__FUNCTION__) +
-            ": Unable to retrieve ADC Coefficients from the eeprom");
-    }
-}
-
-void RSC::setupADC(uint8_t* adc_init_values)
-{
-    if(rsc_setup_adc(m_rsc, adc_init_values) != UPM_SUCCESS) {
-        throw std::runtime_error(std::string(__FUNCTION__) +
-            ": Unable to setup the ADC");
-    }
-}
-
-float RSC::getTemperature()
-{
-    return rsc_get_temperature(m_rsc);
-}
-
-float RSC::getPressure()
-{
-    return rsc_get_pressure(m_rsc);
-}
-
-void RSC::setMode(RSC_MODE mode)
-{
-    rsc_set_mode(m_rsc, mode);
-}
-
-void RSC::setDataRate(RSC_DATA_RATE dr)
-{
-    rsc_set_data_rate(m_rsc, dr);
-}
diff --git a/src/rsc/rsc.h b/src/rsc/rsc.h
deleted file mode 100644
index 10b161c..0000000
--- a/src/rsc/rsc.h
+++ /dev/null
@@ -1,219 +0,0 @@
-/*
- * Author: Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <stdlib.h>
-#include <unistd.h>
-#include <stdio.h>
-#include <string.h>
-
-#include "upm.h"
-#include "mraa/spi.h"
-#include "mraa/gpio.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include "rsc_regs.h"
-/**
- * @file rsc.h
- * @library rsc
- * @brief C API for the rsc driver
- *
- * @include rsc.c
- */
-
-/**
- * Device context
- */
-typedef struct _rsc_context {
-    mraa_spi_context       spi;
-    mraa_gpio_context      cs_ee;
-    mraa_gpio_context      cs_adc;
-    int                    spi_bus_number;
-    float                  coeff_matrix[RSC_COEFF_T_ROW_NO][RSC_COEFF_T_COL_NO];
-    PRESSURE_U             unit;
-    PRESSURE_T             type;
-    float                  pressure_range;
-    float                  min_pressure_val;
-    RSC_DATA_RATE          data_rate;
-    RSC_MODE               mode;
-    uint16_t               t_raw;
-} *rsc_context;
-
-/**
- * RSC initialization.
- *
- * This device supports SPI. The sensor has two chip select
- * pins since there are two ways to access content on the
- * sensor - EEPROM/ADC. We will not be using the SPI CS here
- * because that would work for all SPI operations. Hence, you are
- * expected to initialize any 2 gpio pins for CS by providing the
- * pin numbers.
- *
- * @param bus SPI bus to use.
- * @param cs_ee_pin The CS pin for accessing the EEPROM
- * @param cs_adc_pin The CS pin for accessing the ADC
- * @return The device context, or NULL if an error occurred.
- */
-rsc_context rsc_init(int bus, int cs_ee_pin, int cs_adc_pin);
-
-/**
- * RSC Close function
- *
- * @param dev The device context
- */
-upm_result_t rsc_close(rsc_context dev);
-
-/**
- * This function fills up a character array provided to it with
- * the sensor name that it reads from the EEPROM.
- * NOTE: The length of the array will always have to be RSC_SENSOR_NAME_LEN
- *
- * @param dev The device context
- * @param sensor_name Pointer to a uint8_t array with length
- * RSC_SENSOR_NAME_LEN. This array will be filled up with the sensor name
- * read from the EEPROM.
- * @return UPM result.
- */
-upm_result_t rsc_get_sensor_name(rsc_context dev, uint8_t* sensor_name);
-
-/**
- * This function fills up a character array provided to it with
- * the sensor serial number that it reads from the EEPROM.
- * NOTE: The length of the array will always have to be RSC_SENSOR_NUMBER_LEN
- *
- * @param dev The device context
- * @param sensor_name Pointer to a uint8_t array with length
- * RSC_SENSOR_NUMBER_LEN. This array will be filled up with the serial number
- * @return UPM result.
- */
-upm_result_t rsc_get_sensor_serial_number(rsc_context dev, uint8_t* rsc_number);
-
-/**
- * This function reads the EEPROM to retrieve the pressure range for the
- * particular RSC device.
- *
- * @param dev The device context
- * @return Sensor pressure range in float
- */
-float rsc_get_pressure_range(rsc_context dev);
-
-/**
- * This function reads the EEPROM to retrieve the minimum pressure that
- * the sensor can read.
- *
- * @param dev The device context
- * @return Minimum pressure sensor can read in float
- */
-float rsc_get_minimum_pressure(rsc_context dev);
-
-/**
- * This function reads the EEPROM to retrieve the pressure units that
- * the pressure is read in
- *
- * @param dev The device context
- * @return enum PRESSURE_U
- */
-PRESSURE_U rsc_get_pressure_unit(rsc_context dev);
-
-/**
- * This function reads the EEPROM to retrieve the sensor pressure type
- *
- * @param dev The device context
- * @return enum PRESSURE_T
- */
-PRESSURE_T rsc_get_pressure_type(rsc_context dev);
-
-/**
- * This function reads the EEPROM to extract the values with which the
- * ADC has to be initialized.
- * NOTE: The length of the array will always be 4
- *
- * @param dev The device context
- * @param adc_init_values uint8_t pointer to an array containing the
- * initial values for the ADC
- * @return UPM result.
- */
-upm_result_t rsc_get_initial_adc_values(rsc_context dev, uint8_t* adc_init_values);
-
-/**
- * This function is used to retrieve the coefficients from the EEPROM.
- * Once retrieved, the function updates a 2 dimensional array in the
- * sensor context with the latest values. This function doesn't return
- * the coefficient values.
- *
- * @param dev The device context
- * @return UPM result.
- */
-upm_result_t rsc_retrieve_coefficients(rsc_context dev);
-
-/**
- * This function sets up the initial values in the ADC and also
- * sets is to a default data rate - normal with 20 samples per second
- *
- * @param dev The device context
- * @return UPM result.
- */
-upm_result_t rsc_setup_adc(rsc_context dev, uint8_t* adc_init_values);
-
-/**
- * Function to get the compensated temperature as read by the sensor.
- *
- * @param dev The device context
- * @return float temperature in degree Celsius
- */
-float rsc_get_temperature(rsc_context dev);
-
-/**
- * Function to get the compensated pressure as read by the sensor.
- *
- * @param dev The device context
- * @return float pressure (units inH2O)
- */
-float rsc_get_pressure(rsc_context dev);
-
-/**
- * Function to set the mode of the sensor.
- *
- * @param dev The device context
- * @param mode mode of the sensor
- * @return UPM result.
- */
-upm_result_t rsc_set_mode(rsc_context dev, RSC_MODE mode);
-
-/**
- * Function to set the data rate of the sensor.
- *
- * @param dev The device context
- * @param dr data rate of the sensor
- * @return UPM result.
- */
-upm_result_t rsc_set_data_rate(rsc_context dev, RSC_DATA_RATE dr);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/rsc/rsc.hpp b/src/rsc/rsc.hpp
deleted file mode 100644
index 7ba474d..0000000
--- a/src/rsc/rsc.hpp
+++ /dev/null
@@ -1,251 +0,0 @@
-/*
- * Author: Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include "rsc.h"
-#include <string>
-
-namespace upm {
-    /**
-     * @brief Honeywell RSC TruStability Pressure and Temperature Sensors
-     * @defgroup rsc libupm-rsc
-     * @ingroup honeywell spi pressure temp
-     */
-
-    /**
-     * @library rsc
-     * @sensor rsc
-     * @comname Honeywell RSC TruStability Pressure and Temperature Sensors
-     * @altname Honeywell RSC TruStability Boardmount Pressure Sensors
-     * @type pressure temp
-     * @man honeywell
-     * @con spi
-     * @web https://sensing.honeywell.com/honeywell-sensing-trustability-rsc-series-data-sheet-32321348-b-en.pdf
-     *
-     * @brief Description for the RSC TruStability line
-     *
-     * The RSC Series is a piezoresistive silicon pressure sensor
-     * offering a digital output for reading pressure over the specified
-     * full scale pressure span and temperature range. It is calibrated
-     * and temperature compensated for sensor offset, sensitivity,
-     * temperature effects, and non-linearity using a 24-bit analog-todigital
-     * converter with integrated EEPROM. Pressure data may
-     * be acquired at rates between 20 and 2000 samples per second
-     * over an SPI interface. It is intended for use with non-corrosive,
-     * non-ionic gases, such as air and other dry gases, designed and
-     * manufactured according to ISO 9001 standards, and is REACH
-     * and RoHS compliant.
-     *
-     * Most of the functionality available on this chip has been implemented.
-     * The driver calculates the compensated pressure and temperature values
-     * based on the information provided in the datasheet. The user must not mess
-     * around with the coefficient and adc init value readings from the EEPROM as
-     * these are used to calculate the compensated pressure and temperature values.
-     * 
-     * In order to get the sensor to work properly on an Edison, you would need to
-     * turn off the Edison SPI power management, this can be done with the command:
-     * echo on > /sys/devices/pci0000\:00/0000\:00\:07.1/power/control
-     *
-     * You might have to use external pull up resistors on all the lines.
-     * More info about this has been provided in the datasheet with a table and
-     * a diagram.
-     *
-     * @snippet rsc.cxx Interesting
-     */
-    class RSC {
-
-    public:
-        /**
-         * @brief Default constructor for rsc
-         *
-         * This device supports SPI. The sensor has two chip select
-         * pins since there are two ways to access content on the
-         * sensor - EEPROM/ADC. We will not be using the SPI CS here
-         * because that would work for all SPI operations. Hence, you are
-         * expected to initialize any 2 gpio pins for CS by providing the
-         * pin numbers.
-         *
-         * @param bus SPI bus to use.
-         * @param cs_ee_pin The CS pin for accessing the EEPROM
-         * @param cs_adc_pin The CS pin for accessing the ADC
-         */
-        RSC(uint8_t bus, uint8_t cs_ee_pin, uint8_t cs_adc_pin);
-
-        /**
-         * rsc destructor
-         */
-        ~RSC();
-
-        /**
-         * This function provides the sensor name as a string to
-         * the user.
-         * 
-         * @return std::string sensor name
-         */
-        std::string getSensorName();
-
-        /**
-         * This function provides the sensor serial number as a 
-         * string to the user.
-         * 
-         * @return std::string sensor serial number
-         */
-        std::string getSensorSerialNumber();
-
-        /**
-         * This function provides the pressure range which the 
-         * sensor can read out. This will vary for the different
-         * kinds of RSC sensors. This value is read from the EEPROM		 
-         * 
-         * @return float Total sensor pressure range
-         */
-        float getPressureRange();
-
-        /**
-         * This function provides the minimum pressure which the 
-         * sensor can read out. This will vary for the different
-         * kinds of RSC sensors. This value is read from the EEPROM		 
-         * 
-         * @return float Sensor minimum pressure
-         */
-        float getMinimumPressure();
-
-        /**
-         * This function gets the units that the particular RSC
-         * sensor being used reads out the pressure data in.
-         * Following are the possible units data can be read out
-         * in:
-         * 1. Pascal
-         * 2. Kilo Pascal
-         * 3. Mega Pascal
-         * 4. PSI
-         * 5. inH2O
-         * 6. Bar
-         * 7. milli Bar
-         *
-         * This info can be retrieved from the EEPROM
-         *
-         * @return std::string pressure units
-         */
-        std::string getPressureUnit();
-
-        /**
-         * Function returns the type of RSC pressure sensor being
-         * used. This info is available in the EEPROM.
-         * Types:
-         * 1. Differential
-         * 2. Absolute
-         * 3. Gauge
-         * 
-         * @return std::string sensor type
-         */
-        std::string getPressureType();
-
-        /**
-         * Function returns the initial state that the ADC
-         * registers need to be set to. This info is retrieved
-         * from the EEPROM.
-         * 
-         * @return std::string sensor type
-         */
-        uint8_t *getInitialADCState();
-
-        /**
-         * Function used to update the coefficients. This function
-         * doesn't return the coefficent values. Intstead, it updates
-         * the 2-D array with the coefficient values read from the
-         * EEPROM. This function is mostly for internal use only.
-         */
-        void updateCoefficients();
-
-        /**
-         * Function used to set up the ADC with the initial values
-         * of the ADC registers read from the EEPROM.
-         *
-         * @param adc_init_values pointer to uint8_t array containing
-         * the initial ADC values
-         */
-        void setupADC(uint8_t* adc_init_values);
-
-        /**
-         * Function to get the compensated temperature value.
-         *
-         * @return float compensated temperature value
-         */
-        float getTemperature();
-
-        /**
-         * Function to get the compensated pressure value
-         *
-         * @return float compensated pressure value
-         */
-        float getPressure();
-
-        /**
-         * Function to set the mode for the RSC sensor:
-         * There are 2 types of modes available:
-         *
-         * 1. Normal Mode - 256 KHz
-         * 2. Fast Mode - 512 KHz
-         *
-         * @return mode enum of type RSC_MODE
-         */
-        void setMode(RSC_MODE mode);
-
-        /**
-         * Function to set the data rate for the RSC sensor:
-         * Following are the different data rates available:
-         *
-         * In Normal Mode
-         * 1. 20 SPS
-         * 2. 45 SPS
-         * 3. 90 SPS
-         * 4. 175 SPS
-         * 5. 330 SPS
-         * 6. 600 SPS
-         * 7. 1000 SPS
-         *
-         * In Fast Mode
-         * 1. 40 SPS
-         * 2. 90 SPS
-         * 3. 180 SPS
-         * 4. 350 SPS
-         * 5. 660 SPS
-         * 6. 1200 SPS
-         * 7. 2000 SPS
-         *
-         * SPS - Samples per Second
-         *
-         * @return dr enum of type RSC_DATA_RATE
-         */
-        void setDataRate(RSC_DATA_RATE dr);
-
-    private:
-        rsc_context m_rsc;
-        RSC(const RSC& src) { /* do not create copied */}
-        RSC& operator=(const RSC&) {return *this;}
-        uint8_t m_adc_coeff[4];
-    };
-}
diff --git a/src/rsc/rsc.json b/src/rsc/rsc.json
deleted file mode 100644
index 8a375ef..0000000
--- a/src/rsc/rsc.json
+++ /dev/null
@@ -1,84 +0,0 @@
-{
-    "Library": "rsc",
-    "Description": "Honeywell TruStability Pressure and Temperature Sensor Library",
-    "Sensor Class":
-    {
-        "RSC":
-        {
-            "Name": "SPI based Board Mount Pressure and Temperature",
-            "Description": "The RSC Series is a piezoresistive silicon pressure sensor offering a digital output for reading pressure over the specified full scale pressure span and temperature range. It is calibrated and temperature compensated for sensor offset, sensitivity, temperature effects, and non-linearity using a 24-bit analog-todigital converter with integrated EEPROM. Pressure data may be acquired at rates between 20 and 2000 samples per second over an SPI interface. It is intended for use with non-corrosive, non-ionic gases, such as air and other dry gases, designed and and RoHS compliant. Most of the functionality available on this chip has been implemented. The driver calculates the compensated pressure and temperature values based on the information provided in the datasheet. The user must not mess around with the coefficient and adc init value readings from the EEPROM as these are used to calculate the compensated pressure and temperature values. In order to get the sensor to work properly on an Edison, you would need to turn off the Edison SPI power management, this can be done with the command: echo on > /sys/devices/pci0000\\:00/0000\\:00\\:07.1/power/control. You might have to use external pull up resistors on all the lines. More info about this has been provided in the datasheet with a table and a diagram.",
-            "Aliases": ["rsc"],
-            "Categories": ["pressure", "temperature"],
-            "Connections": ["gpio", "spi"],
-            "Project Type": ["medical", "industrial", "extended"],
-            "Manufacturers": ["Honeywell"],
-            "Kits": [],
-            "Examples":
-            {
-                "Python": ["rsc.py"],
-                "Node.js": ["rsc.js"],
-                "C++": ["rsc.cxx"],
-                "C": ["rsc.c"]
-            },
-            "Specifications":
-            {
-                "Vsupply": {"unit": "Vdc", "min" : 2.7, "high": 6.0},
-                "Supply Current(3.3 Vdc)" : {"unit": "mA", "standby" : 1.3, "active": 1.7},
-                "Supply Current(5.0 Vdc)": {"unit": "mA", "standby" : 2.1, "active": 2.6},
-                "Operating Temperature": {"unit": "Â°C", "min" : -40, "max": 85},
-                "Start up Time": {"unit": "ms", "time" : 0.3},
-                "Compensated Temperature Range (Medical)" : {"unit": "Â°C", "min" : 0, "max" : 50},
-                "Compensated Temperature Range (Industrial)" : {"unit": "Â°C", "min" : -20, "max" : 85},
-                "Compensated Temperature Range (Extended)" : {"unit": "Â°C", "min" : -40, "max" : 85},
-                "Data Rate" : {"unit" : "samples per second", "min" : 20, "max" : 2000},
-                "Pressure Range": {
-                    "Absolute" : [
-                        {"unit" : "bar", "min" : 0, "max" : 10},
-                        {"unit" : "kPa", "min" : 0, "max" : 600},
-                        {"unit" : "MPa", "min" : 0, "max" : 1},
-                        {"unit" : "psi", "min" : 0, "max" : 150}
-                    ],
-                    "Differential": [
-                        {"unit" : "mbar", "min" : 1.6, "max": 600},
-                        {"unit" : "bar", "min" : 1, "max": 10},
-                        {"unit" : "Pa", "min" : 160, "max": 600},
-                        {"unit" : "kPa", "min" : 1, "max": 600},
-                        {"unit" : "MPa", "max": 1},
-                        {"unit" : "inH2O", "min" : 0.5, "max": 30},
-                        {"unit" : "psi", "min" : 1, "max": 150}
-                    ],
-                    "Gage": [
-                        {"unit" : "mbar", "min" : 0, "max": 600},
-                        {"unit" : "bar", "min" : 0, "max": 10},
-                        {"unit" : "Pa", "min" : 0, "max": 600},
-                        {"unit" : "kPa", "min" : 0, "max": 600},
-                        {"unit" : "MPa", "min" : 0, "max": 1},
-                        {"unit" : "inH2O", "min" : 0, "max": 30},
-                        {"unit" : "psi", "min" : 0, "max": 150}
-                    ]
-                }
-            },
-            "// Platforms": {"comment": "Catch-all for listing platforms used to validate this sensor class.", "required": false},
-            "Platforms":
-            {
-                "Intel Joule Module":
-                {
-                    "Notes": ["Might Require pull-up resistors or use a shield instead"]
-                },
-                "Intel Edison":
-                {
-                    "Notes": ["Turn of SPI power management to use the sensor. Turn it off using the command : echo on > /sys/devices/pci0000\\:00/0000\\:00\\:07.1/power/control"]
-                },
-                "Arduino 101":
-                {
-                    "Notes": ["Might need pull up resistors or a shield"]
-                }
-            },
-            "Urls" :
-            {
-                "Product Pages": ["https://sensing.honeywell.com/sensors/amplified-board-mount-pressure-sensors/trustability-rsc-series"],
-                "Datasheets": ["https://sensing.honeywell.com/honeywell-sensing-trustability-rsc-series-data-sheet-32321348-b-en.pdf"]
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/rsc/rsc_regs.h b/src/rsc/rsc_regs.h
deleted file mode 100644
index d295fc6..0000000
--- a/src/rsc/rsc_regs.h
+++ /dev/null
@@ -1,249 +0,0 @@
-/*
- * Author: Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-/*
- * The following section lists the EEPROM Addresses
- */
-/*
- * RSC EEPROM Catalog listing
- * This part in the EEPROM stores the ascii representation of the sensor chip
- * number
- */
-#define RSC_CATALOG_LISTING_MSB                0
-#define RSC_CATALOG_LISTING_LSB                15
-
-/*
- * RSC EEPROM Serial Number addresses
- */
-#define RSC_SERIAL_NO_YYYY_MSB                 16
-#define RSC_SERIAL_NO_YYYY_LSB                 19
-#define RSC_SERIAL_NO_DDD_MSB                  20
-#define RSC_SERIAL_NO_DDD_LSB                  22
-#define RSC_SERIAL_NO_XXXX_MSB                 23
-#define RSC_SERIAL_NO_XXXX_LSB                 26
-
-/*
- * This area in the EEPROM contains the sensor's pressure range in float
- */
-#define RSC_PRESSURE_RANGE_LSB                 27
-#define RSC_PRESSURE_RANGE_MSB                 30
-
-/*
- * This part in the EEPROM contains the lower pressure limit readable
- * Value is stored float
- */
-#define RSC_PRESSURE_MINIMUM_LSB               31
-#define RSC_PRESSURE_MINIMUM_MSB               34
-
-/*
- * Unit of measurement of pressure for this particular sensor
- * Ex: Pascal, Bar, PSI, inH2O
- */
-#define RSC_PRESSURE_UNIT_MSB                  35
-#define RSC_PRESSURE_UNIT_LSB                  39
-
-/*
- * Ex: Differential, Gauge, absolute
- */
-#define RSC_PRESSURE_REFERENCE                 40
-
-/*
- * ADC Configuration math
- */
-#define RSC_ADC_CONDIG_00                      61
-#define RSC_ADC_CONDIG_01                      63
-#define RSC_ADC_CONDIG_02                      65
-#define RSC_ADC_CONDIG_03                      67
-
-/*
- * Offset Coefficient matrix
- */
-#define RSC_OFFSET_COEFFICIENT_0_LSB           130
-#define RSC_OFFSET_COEFFICIENT_0_MSB           133
-
-#define RSC_OFFSET_COEFFICIENT_1_LSB           134
-#define RSC_OFFSET_COEFFICIENT_1_MSB           137
-
-#define RSC_OFFSET_COEFFICIENT_2_LSB           138
-#define RSC_OFFSET_COEFFICIENT_2_MSB           141
-
-#define RSC_OFFSET_COEFFICIENT_3_LSB           142
-#define RSC_OFFSET_COEFFICIENT_3_MSB           145
-
-/*
- * Span Coefficient Matrix
- */
-#define RSC_SPAN_COEFFICIENT_0_LSB             210
-#define RSC_SPAN_COEFFICIENT_0_MSB             213
-
-#define RSC_SPAN_COEFFICIENT_1_LSB             214
-#define RSC_SPAN_COEFFICIENT_1_MSB             217
-
-#define RSC_SPAN_COEFFICIENT_2_LSB             218
-#define RSC_SPAN_COEFFICIENT_2_MSB             221
-
-#define RSC_SPAN_COEFFICIENT_3_LSB             222
-#define RSC_SPAN_COEFFICIENT_3_MSB             225
-
-/*
- * Shape Coefficient Matrix
- */
-#define RSC_SHAPE_COEFFICIENT_0_LSB            290
-#define RSC_SHAPE_COEFFICIENT_0_MSB            293
-
-#define RSC_SHAPE_COEFFICIENT_1_LSB            294
-#define RSC_SHAPE_COEFFICIENT_1_MSB            297
-
-#define RSC_SHAPE_COEFFICIENT_2_LSB            298
-#define RSC_SHAPE_COEFFICIENT_2_MSB            301
-
-#define RSC_SHAPE_COEFFICIENT_3_LSB            302
-#define RSC_SHAPE_COEFFICIENT_3_MSB            305
-
-/*
- * Checksum addresses
- */
-#define RSC_CHECKSUM_LSB                       450
-#define RSC_CHECKSUM_MSB                       451
-
-/*
- * The following section contains a list of variations useful for EEPROM
- * calculations and reads.
- */
-#define RSC_EEPROM_ADDRESS_SPACE_SIZE             512
-#define RSC_EEPROM_STANDARD_ARGUMENT_LENGTH       2
-#define RSC_READ_EEPROM_INSTRUCTION               0x03
-#define RSC_EEPROM_ADDRESS_LOWER_BYTE_MASK        0xff
-#define RSC_EEPROM_ADDRESS_9TH_BIT_MASK           0x100
-#define RSC_SENSOR_NAME_LEN                       16
-#define RSC_SENSOR_NUMBER_LEN                     12
-#define RSC_PRESSURE_RANGE_LEN                    4
-#define RSC_PRESSURE_MINIMUM_LEN                  4
-#define RSC_PRESSURE_UNIT_LEN                     6
-#define RSC_SENSOR_TYPE_LEN                       1
-// total types of coefficients
-#define RSC_COEFF_T_ROW_NO                        3
-// total no of coefficients in each type
-#define RSC_COEFF_T_COL_NO                        4
-// this can be calculated by using the LSB address of the 0th coefficient
-// and the MSB of the 3rd coefficient
-#define RSC_COEFF_ADDRESS_SPACE_SIZE              16
-
-/*
- * The following section lists ADC Commands/Registers
- */
-#define RSC_ADC_RESET_COMMAND                         0x06
-#define RSC_DATA_RATE_SHIFT                           5
-#define RSC_DATA_RATE_MASK                            0xe0
-#define RSC_ADC_REG_MASK                              0x0C
-#define RSC_ADC_NUM_BYTES_MASK                        0x03
-#define RSC_OPERATING_MODE_MASK                       0x18
-#define RSC_OPERATING_MODE_SHIFT                      3
-#define RSC_SET_BITS_MASK                             0x04
-#define RSC_ADC_WREG                                  0x40
-#define MSEC_PER_SEC                                  1000
-#define RSC_CREATE_WREG_COMMAND(x,y,z) (x|((y<<2)&RSC_ADC_REG_MASK)|(z&RSC_ADC_NUM_BYTES_MASK))
-
-/*
- * Read/Write Enum
- */
-typedef enum {
-    READ = 0,
-    WRITE } RSC_ADC_TX;
-
-/*
- * Enum for the datarates supported by the sensor
- * N/F - Normal/Fast - 256 KHz/512 KHz
- * DR - Data Rate
- * SPS - Samples per second
- */
-typedef enum {
-    N_DR_20_SPS = 0,
-    N_DR_45_SPS,
-    N_DR_90_SPS,
-    N_DR_175_SPS,
-    N_DR_330_SPS,
-    N_DR_600_SPS,
-    N_DR_1000_SPS,
-    N_DR_NA,
-    F_DR_40_SPS,
-    F_DR_90_SPS,
-    F_DR_180_SPS,
-    F_DR_350_SPS,
-    F_DR_660_SPS,
-    F_DR_1200_SPS,
-    F_DR_2000_SPS,
-    F_DR_NA } RSC_DATA_RATE;
-
-/*
- * Enum for modes supported by the RSC sensor
- */
-typedef enum {
-    NORMAL_MODE = 0,
-    NA_MODE,
-    FAST_MODE } RSC_MODE;
-
-/*
- * Enum for the different pressure units supported by the rsc class of sensors
- */
-typedef enum {
-    PASCAL = 0,
-    KPASCAL,
-    MPASCAL,
-    PSI,
-    INH2O,
-    BAR,
-    mBAR } PRESSURE_U;
-
-/*
- * Enum for types of pressure that the rsc sensor class can calculate
- */
-typedef enum {
-    DIFFERENTIAL = 0,
-    ABSOLUTE,
-    GAUGE } PRESSURE_T;
-
-/*
- * Enum for types of coefficients available from the rsc sensors
- */
-typedef enum {
-    OFFSET = 0,
-    SPAN,
-    SHAPE } COEFFICIENT_T;
-
-/*
- * Enum for pressure/temperature reading
- */
-typedef enum {
-    PRESSURE = 0,
-    TEMPERATURE } READING_T;
-
-/*
- * Enum to access EEPROM/ADC
- */
-typedef enum {
-    EEPROM = 0,
-    ADC } ACCESS_T;
diff --git a/src/scam/CMakeLists.txt b/src/scam/CMakeLists.txt
deleted file mode 100644
index 63a779a..0000000
--- a/src/scam/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-upm_mixed_module_init (NAME scam
-    DESCRIPTION "Serial Camera"
-    CPP_HDR scam.hpp
-    CPP_SRC scam.cxx
-    REQUIRES mraa)
diff --git a/src/scam/scam.cxx b/src/scam/scam.cxx
deleted file mode 100644
index e304c28..0000000
--- a/src/scam/scam.cxx
+++ /dev/null
@@ -1,490 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Thanks to Seeed Studio for a working arduino sketch
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-#include <errno.h>
-
-#include "scam.hpp"
-
-using namespace upm;
-using namespace std;
-
-static const int maxRetries = 100;
-
-SCAM::SCAM(int uart, uint8_t camAddr)
-{
-  m_ttyFd = -1;
-
-  // save our shifted camera address, we'll need it a lot
-  m_camAddr = (camAddr << 5);
-
-  m_picTotalLen = 0;
-
-  if ( !(m_uart = mraa_uart_init(uart)) )
-    {
-      throw std::invalid_argument(std::string(__FUNCTION__) +
-                                  ": mraa_uart_init() failed");
-      return;
-    }
-
-  // This requires a recent MRAA (1/2015)
-  const char *devPath = mraa_uart_get_dev_path(m_uart);
-
-  if (!devPath)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": mraa_uart_get_dev_path() failed");
-      return;
-    }
-
-  // now open the tty
-  if ( (m_ttyFd = open(devPath, O_RDWR)) == -1)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": open of " + 
-                               string(devPath) + " failed:" +
-                               string(strerror(errno)));
-      return;
-    }
-}
-
-SCAM::~SCAM()
-{
-  if (m_ttyFd != -1)
-    close(m_ttyFd);
-}
-
-bool SCAM::dataAvailable(unsigned int millis)
-{
-  if (m_ttyFd == -1)
-    return false;
-
-  struct timeval timeout;
-
-  if (millis == 0) 
-    {
-      // no waiting
-      timeout.tv_sec = 0;
-      timeout.tv_usec = 0;
-    }
-  else 
-    {
-      timeout.tv_sec = millis / 1000;
-      timeout.tv_usec = (millis % 1000) * 1000;
-    }
-
-  fd_set readfds;
-
-  FD_ZERO(&readfds);
-
-  FD_SET(m_ttyFd, &readfds);
-  
-  if (select(m_ttyFd + 1, &readfds, NULL, NULL, &timeout) > 0)
-    return true;                // data is ready
-  else
-    return false;
-}
-
-int SCAM::readData(uint8_t *buffer, int len)
-{
-  if (m_ttyFd == -1)
-    return(-1);
-
-  int rv = read(m_ttyFd, (char *)buffer, len);
-
-  if (rv < 0)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": read() failed: " +
-                               string(strerror(errno)));
-      return rv;
-    }
-
-  return rv;
-}
-
-int SCAM::writeData(uint8_t *buffer, int len)
-{
-  if (m_ttyFd == -1)
-    return(-1);
-
-  // first, flush any pending but unread input
-
-  tcflush(m_ttyFd, TCIFLUSH);
-
-  int rv = write(m_ttyFd, (char *)buffer, len);
-
-  if (rv < 0)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": write() failed: " +
-                               string(strerror(errno)));
-      return rv;
-    }
-
-  tcdrain(m_ttyFd);
-
-  return rv;
-}
-
-bool SCAM::setupTty(speed_t baud)
-{
-  if (m_ttyFd == -1)
-    return(false);
-  
-  struct termios termio;
-
-  // get current modes
-  tcgetattr(m_ttyFd, &termio);
-
-  // setup for a 'raw' mode.  81N, no echo or special character
-  // handling, such as flow control.
-  cfmakeraw(&termio);
-
-  // set our baud rates
-  cfsetispeed(&termio, baud);
-  cfsetospeed(&termio, baud);
-
-  // make it so
-  if (tcsetattr(m_ttyFd, TCSAFLUSH, &termio) < 0)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": tcsetattr() failed: " +
-                               string(strerror(errno)));
-      return false;
-    }
-
-  return true;
-}
-
-void SCAM::drainInput()
-{
-  uint8_t ch;
-
-  while (dataAvailable(0))
-    readData(&ch, 1);
-}
-
-bool SCAM::init()
-{
-  const unsigned int pktLen = 6;
-  uint8_t cmd[pktLen] = {0xaa, static_cast<uint8_t>(0x0d|m_camAddr), 0x00,
-                         0x00, 0x00, 0x00};
-  uint8_t resp[pktLen];
-  int retries = 0;
-
-  while (true)
-    {
-      if (retries++ > maxRetries)
-        {
-          throw std::runtime_error(std::string(__FUNCTION__) +
-                                   ": maximum retries exceeded");
-          return false;
-        }
-
-      writeData(cmd, pktLen);
-
-      if (!dataAvailable(500))
-        continue;
-
-      if (readData(resp, pktLen) != pktLen)
-        continue;
-
-      if (resp[0] == 0xaa 
-          && resp[1] == (0x0e | m_camAddr) 
-          && resp[2] == 0x0d 
-          && resp[4] == 0 
-          && resp[5] == 0)
-        {
-          if (readData(resp, pktLen) != pktLen)
-            continue;
-          else
-            {
-              if (resp[0] == 0xaa 
-                  && resp[1] == (0x0d | m_camAddr) 
-                  && resp[2] == 0 
-                  && resp[3] == 0 
-                  && resp[4] == 0 
-                  && resp[5] == 0) 
-                break;
-            }
-        }
-    }
-
-  cmd[1] = 0x0e | m_camAddr;
-  cmd[2] = 0x0d;
-  writeData(cmd, pktLen);
-
-  return true;
-}
-
-bool SCAM::preCapture(PIC_FORMATS_T fmt)
-{
-  const unsigned int pktLen = 6;
-  uint8_t cmd[pktLen] = { 0xaa, static_cast<uint8_t>(0x01 | m_camAddr), 0x00,
-                          0x07, 0x00, static_cast<uint8_t>(fmt) };
-  uint8_t resp[pktLen];
-  int retries = 0;
-
-  while (true)
-    {
-      if (retries++ > maxRetries)
-        {
-          throw std::runtime_error(std::string(__FUNCTION__) +
-                                   ": maximum retries exceeded");
-          return false;
-        }
-
-      drainInput();
-
-      writeData(cmd, pktLen);
-
-      if (!dataAvailable(100))
-        continue;
-
-      if (readData(resp, pktLen) != pktLen)
-        continue;
-
-      if (resp[0] == 0xaa 
-          && resp[1] == (0x0e | m_camAddr) 
-          && resp[2] == 0x01 
-          && resp[4] == 0 
-          && resp[5] == 0) break;
-    }
-
-  return true;
-}
-
-bool SCAM::doCapture()
-{
-  const unsigned int pktLen = 6;
-  uint8_t cmd[pktLen] = { 0xaa, static_cast<uint8_t>(0x06 | m_camAddr), 0x08,
-                          static_cast<uint8_t>(MAX_PKT_LEN & 0xff),
-                          static_cast<uint8_t>((MAX_PKT_LEN >> 8)) & 0xff, 0};
-  uint8_t resp[pktLen];
-  int retries = 0;
-  
-  m_picTotalLen = 0;
-
-  while (true)
-    {
-      if (retries++ > maxRetries)
-        {
-          throw std::runtime_error(std::string(__FUNCTION__) +
-                                   ": maximum retries exceeded");
-          return false;
-        }
-
-      drainInput();
-      writeData(cmd, pktLen);
-      usleep(100000);
-
-      if (!dataAvailable(100))
-        continue;
-
-      if (readData(resp, pktLen) != pktLen)
-        continue;
-
-      if (resp[0] == 0xaa 
-          && resp[1] == (0x0e | m_camAddr) 
-          && resp[2] == 0x06 
-          && resp[4] == 0 
-          && resp[5] == 0)
-        break;
-    }
-
-  cmd[1] = 0x05 | m_camAddr;
-  cmd[2] = 0;
-  cmd[3] = 0;
-  cmd[4] = 0;
-  cmd[5] = 0;
-
-  retries = 0;
-  while (true)
-    {
-      if (retries++ > maxRetries)
-        {
-          throw std::runtime_error(std::string(__FUNCTION__) +
-                                   ": maximum retries exceeded");
-          return false;
-        }
-
-      drainInput();
-      writeData(cmd, pktLen);
-      if (readData(resp, pktLen) != pktLen)
-        continue;
-
-      if (resp[0] == 0xaa 
-          && resp[1] == (0x0e | m_camAddr) 
-          && resp[2] == 0x05 
-          && resp[4] == 0 
-          && resp[5] == 0)
-        break;
-    }
-
-  cmd[1] = 0x04 | m_camAddr;
-  cmd[2] = 0x01;
-
-  retries = 0;
-  while (true)
-    {
-      if (retries++ > maxRetries)
-        {
-          throw std::runtime_error(std::string(__FUNCTION__) +
-                                   ": maximum retries exceeded");
-          return false;
-        }
-
-      drainInput();
-      writeData(cmd, 6);
-
-      if (readData(resp, pktLen) != pktLen)
-        continue;
-
-      if (resp[0] == 0xaa 
-          && resp[1] == (0x0e | m_camAddr) 
-          && resp[2] == 0x04 
-          && resp[4] == 0 
-          && resp[5] == 0)
-        {
-          if (!dataAvailable(1000))
-            continue;
-
-          if (readData(resp, pktLen) != pktLen)
-            continue;
-
-          if (resp[0] == 0xaa
-              && resp[1] == (0x0a | m_camAddr)
-              && resp[2] == 0x01)
-            {
-              m_picTotalLen = (resp[3]) | (resp[4] << 8) | (resp[5] << 16);
-              break;
-            }
-        }
-    }
-
-  return true;
-}
-
-bool SCAM::storeImage(const char *fname)
-{
-  if (!fname)
-    {
-      throw std::invalid_argument(std::string(__FUNCTION__) +
-                                  ": filename is NULL");
-      return false;
-    }
-
-  if (!m_picTotalLen)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                    ": Picture length is zero, you need to capture first.");
-
-      return false;
-    }
-
-  FILE *file = fopen(fname, "wb");
-
-  if (!file)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": fopen() failed: " +
-                               string(strerror(errno)));
-      return false;
-    }
-  
-  /// let the games begin...
-  const unsigned int pktLen = 6;
-  unsigned int pktCnt = (m_picTotalLen) / (MAX_PKT_LEN - 6);
-  if ((m_picTotalLen % (MAX_PKT_LEN-6)) != 0) 
-    pktCnt += 1;
-  
-  uint8_t cmd[pktLen] = { 0xaa, static_cast<uint8_t>(0x0e | m_camAddr), 0x00,
-                          0x00, 0x00, 0x00 };
-  uint8_t pkt[MAX_PKT_LEN];
-  int retries = 0;
-  
-  for (unsigned int i = 0; i < pktCnt; i++)
-    {
-      cmd[4] = i & 0xff;
-      cmd[5] = (i >> 8) & 0xff;
-      
-      retries = 0;
-
-    retry:
-
-      usleep(10000);
-
-      drainInput();
-      writeData(cmd, pktLen);
-
-      if (!dataAvailable(1000))
-        {
-          if (retries++ > maxRetries)
-            {
-              throw std::runtime_error(std::string(__FUNCTION__) +
-                                       ": timeout, maximum retries exceeded");
-              return false;
-            }
-          goto retry;
-        }
-
-      uint16_t cnt = readData(pkt, MAX_PKT_LEN);
-      
-      unsigned char sum = 0;
-      for (int y = 0; y < cnt - 2; y++)
-        {
-          sum += pkt[y];
-        }
-      if (sum != pkt[cnt-2])
-        {
-          if (retries++ <= maxRetries)
-            goto retry;
-          else
-            {
-              fclose(file);
-              throw std::runtime_error(std::string(__FUNCTION__) +
-                                       ": cksum error, maximum retries exceeded");
-              return false;
-            }
-        }
-
-      fwrite((const uint8_t *)&pkt[4], cnt - 6, 1, file);
-    }
-
-  cmd[4] = 0xf0;
-  cmd[5] = 0xf0;
-  writeData(cmd, pktLen);
-
-  fclose(file);
-
-  // reset the pic length to 0 for another run.
-  m_picTotalLen = 0;
-
-  return true;
-}
diff --git a/src/scam/scam.hpp b/src/scam/scam.hpp
deleted file mode 100644
index ea11f57..0000000
--- a/src/scam/scam.hpp
+++ /dev/null
@@ -1,195 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Thanks to Seeed Studio for a working arduino sketch
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <iostream>
-
-#include <stdint.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-#include <fcntl.h>
-#include <errno.h>
-#include <termios.h>
-#include <sys/time.h>
-#include <sys/select.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-
-#include <mraa/uart.h>
-
-#define SCAM_DEFAULT_UART 0
-
-#define SCAM_DEFAULT_CAMERA_ADDR 0
-
-namespace upm {
-    /**
-     * @brief Serial Camera Library
-     * @defgroup scam libupm-scam
-     * @ingroup seeed uart other
-     */
-
-    /**
-     * @library scam
-     * @sensor scam
-     * @comname Serial Camera
-     * @altname Grove Serial Camera
-     * @type other
-     * @man seeed
-     * @con uart
-     * @web http://www.seeedstudio.com/wiki/Grove_-_Serial_Camera_Kit
-     *
-     * @brief API for the Serial Camera
-     *
-     * The driver was tested with the Serial Camera. There is
-     * no protocol documentation currently available, so this module
-     * was developed based completely on the Seeed Studio* Arduino*
-     * sketch.
-     *
-     * It is connected via a UART at 115,200 baud.
-     *
-     * @image html scam.jpg
-     * @snippet scam.cxx Interesting
-     */
-
-  class SCAM {
-  public:
-
-    static const unsigned int MAX_PKT_LEN = 128;
-
-    typedef enum {
-      FORMAT_VGA                   = 7, // 640x480
-      FORMAT_CIF                   = 5, // 352*288
-      FORMAT_OCIF                  = 3  // ??? (maybe they meant QCIF?)
-    } PIC_FORMATS_T;
-
-    /**
-     *   Serial Camera constructor
-     *
-     * @param uart Default UART to use (0 or 1)
-     * @param camAddr 3-bit address identifier of the camera; default is 0
-     */
-    SCAM(int uart, uint8_t camAddr=SCAM_DEFAULT_CAMERA_ADDR);
-
-    /**
-     * SCAM destructor
-     */
-    ~SCAM();
-
-    /**
-     * Checks to see if there is data available for reading
-     *
-     * @param millis Number of milliseconds to wait; 0 means no waiting.
-     * @return True if there is data available for reading
-     */
-    bool dataAvailable(unsigned int millis);
-
-    /**
-     * Reads any available data into a user-supplied buffer. Note: the
-     * call blocks until data is available to be read. Use
-     * dataAvailable() to determine whether there is data available
-     * beforehand, to avoid blocking.
-     *
-     * @param buffer Buffer to hold the data read
-     * @param len Length of the buffer
-     * @return Number of bytes read
-     */
-    int readData(uint8_t *buffer, int len);
-
-    /**
-     * Writes the data in the buffer to the device
-     *
-     * @param buffer Buffer to hold the data read
-     * @param len Length of the buffer
-     * @return Number of bytes written
-     */
-    int writeData(uint8_t *buffer, int len);
-
-    /**
-     * Sets up proper tty I/O modes and the baud rate. For this device, the default
-     * baud rate is 9,600 (B9600).
-     *
-     * @param baud Desired baud rate
-     * @return True if successful
-     */
-    bool setupTty(speed_t baud=B115200);
-
-    /**
-     * Reads serial input and discards until no more characters are available
-     *
-     */
-    void drainInput();
-
-    /**
-     * Initializes the camera
-     *
-     */
-    bool init();
-
-    /**
-     * Tells the camera to prepare for a capture
-     *
-     * @param fmt One of the PIC_FORMATS_T values
-     */
-    bool preCapture(PIC_FORMATS_T fmt=FORMAT_VGA);
-
-    /**
-     * Starts the capture
-     *
-     * @return True if successful
-     */
-    bool doCapture();
-
-    /**
-     * Stores the captured image in a file
-     *
-     * @param fname Name of the file to write
-     * @return True if successful
-     */
-    bool storeImage(const char *fname);
-
-    /**
-     * Returns the picture length. Note: this is only valid after
-     * doCapture() has run successfully.
-     *
-     * @return Image length
-     */
-    int getImageSize() { return m_picTotalLen; };
-
-  protected:
-    int ttyFd() { return m_ttyFd; };
-
-  private:
-    mraa_uart_context m_uart;
-    int m_ttyFd;
-
-    uint8_t m_camAddr;
-    int m_picTotalLen;
-  };
-}
-
-
diff --git a/src/scam/scam.i b/src/scam/scam.i
deleted file mode 100644
index 4ea720a..0000000
--- a/src/scam/scam.i
+++ /dev/null
@@ -1,16 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "../java_buffer.i"
-
-JAVA_JNI_LOADLIBRARY(javaupm_scam)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "scam.hpp"
-%}
-%include "scam.hpp"
-/* END Common SWIG syntax */
diff --git a/src/scam/scam.json b/src/scam/scam.json
deleted file mode 100644
index 808dd5a..0000000
--- a/src/scam/scam.json
+++ /dev/null
@@ -1,53 +0,0 @@
-{
-    "Library": "scam",
-    "Description": "Seeed Serial Camera library",
-    "Sensor Class": {
-        "SCAM": {
-            "Name": "API for the Seeed Serial Camera",
-            "Description": "This is the UPM Module for the Seeed Serial Camera. There is no protocol documentation currently available, so this module was developed based completely on the Seeed Studio* Arduino* sketch.",
-            "Aliases": ["scam", "Grove - Serial Camera Kit"],
-            "Categories": ["other"],
-            "Connections": ["uard"],
-            "Project Type": ["prototyping"],
-            "Manufacturers": ["Seeed"],
-            "Image": "scam.jpg",
-            "Examples": {
-                "Java": ["SCAM_Example.java"],
-                "Python": ["scam.py"],
-                "Node.js": ["scam.js"],
-                "C++": ["scam.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "typ" : 5.0
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Resolution": {
-                    "unit": "pixels",
-                    "res": "160x120"
-                },
-                "UART Baud Rate": {
-                    "unit": "Baud",
-                    "min" : 9600,
-                    "max" : 115200
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["http://wiki.seeed.cc/Grove-Serial_Camera_Kit/"]
-            }
-        }
-    }
-}
diff --git a/src/sensortemplate/CMakeLists.txt b/src/sensortemplate/CMakeLists.txt
deleted file mode 100644
index b6f9754..0000000
--- a/src/sensortemplate/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-upm_mixed_module_init (NAME sensortemplate
-    DESCRIPTION "Short, Title-Case Description from the SensorTemplate Datasheet"
-    CPP_HDR sensortemplate.hpp
-    CPP_SRC sensortemplate.cxx
-    REQUIRES mraa)
diff --git a/src/sensortemplate/sensortemplate.cxx b/src/sensortemplate/sensortemplate.cxx
deleted file mode 100644
index fb3bda2..0000000
--- a/src/sensortemplate/sensortemplate.cxx
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * The MIT License (MIT)
- *
- * Author: Your Full Name <your@email.address>
- * Copyright (c) <year> <copyright holder>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-
-#include "sensortemplate.hpp"
-
-using namespace upm;
-
-SensorTemplate::SensorTemplate(int i2c_bus): _i2c(i2c_bus) {}
-
-std::string SensorTemplate::helloWorld() { return "Hello World";}
diff --git a/src/sensortemplate/sensortemplate.hpp b/src/sensortemplate/sensortemplate.hpp
deleted file mode 100644
index 2691064..0000000
--- a/src/sensortemplate/sensortemplate.hpp
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * The MIT License (MIT)
- *
- * Author: Your Full Name <your@email.address>
- * Copyright (c) <year> <copyright holder>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-
-#pragma once
-
-#include <string>
-
-#include "mraa/i2c.hpp"
-
-namespace upm
-{
-/**
- * @brief Library block provides a short library description
- * @defgroup sensortemplate libupm-sensortemplate
- * @ingroup <manufacturer: adafruit,aeon,amphenol,avago,bosch,catnip,comet,dfrobot,emax,epict,freescale,generic,honeywell,kionix,maxbotix,maxbotix,maxim,meas,mouser,numatolabs,omega,openelectrons,sainsmart,seeed,semtech,silabs,sparkfun,stmicro,ti,trane,veris> <connection: analog,gpio,i2c,pwm,spi,uart> <category: accelerometer,ainput,button,color,compass,digipot,display,electric,flexfor,gaseous,gps,led,light,liquid,medical,motor,other,pressure,relay,rfid,serial,servos,sound,temp,time,touch,video,wifi> (<kit>: eak,gsk,hak,robok,tsk)
- */
-
-/**
- * @library sensortemplate
- * @sensor Usually the chip number used by the sensor. When this is not
- *         available or relevant, use a unique descriptor that makes sense.
- *         Must match class name. *Mandatory*
- * @comname Short, Title-Case Description from Datasheet. *Manditory*
- * @altname Alternative names that your sensor driver might have. This may
- *          include manufacturer's name. *Optional*
- * @altid Alternative chip-ids that your sensor driver supports. *Optional*
- * @type One or more of: accelerometer,ainput,button,color,compass,digipot,
- *       display,electric,flexfor,gaseous,gps,led,light,liquid,medical,motor,other,pressure,relay,rfid,serial,servos,sound,temp,time,touch,video,wifi *Manditory*
- * @man One or more of: Sensor manufacturer. Can be 'generic'. *Mandatory*
- * @web Links to vendors or data-sheets. *Optional*
- * @con One or more of: analog,gpio,i2c,pwm,spi,uart *Manditory*
- * @kit One of: gsk, hak, eak, tsk, robok *Optional*
- *
- * @brief Short class/sensor description
- *
- * Then add a much more detailed description here.  Include items such as
- * board-specifics, testing, etc...
- *
- * @image html sensortemplate.png
- * @snippet sensortemplate.cxx Interesting
- */
-
-class SensorTemplate
-{
-    public:
-        /**
-         * @brief Default constructor for SensorTemplate
-         *
-         * This creates an instance of SensorTemplate given an I2C bus
-         * number.
-         *
-         * @param i2c_bus Target I2C bus
-         * @return sensor context pointer
-         * @throws std::runtime_error on failure to initialize I2C
-         */
-        SensorTemplate(int i2c_bus);
-
-        /**
-         * SensorTemplate destructor
-         */
-        virtual ~SensorTemplate() {};
-
-        /**
-         * @brief Hello world method
-         *
-         * Provides an example method which returns 'Hello world'
-         */
-        std::string helloWorld();
-    private:
-        /* Private I2c instance */
-        mraa::I2c _i2c;
-};
-}
diff --git a/src/sensortemplate/sensortemplate.i b/src/sensortemplate/sensortemplate.i
deleted file mode 100644
index ee75787..0000000
--- a/src/sensortemplate/sensortemplate.i
+++ /dev/null
@@ -1,29 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-/* Add the JAVA code to load the module */
-JAVA_JNI_LOADLIBRARY(javaupm_sensortemplate)
-#endif
-/* END Java syntax */
-
-/* BEGIN Javascript syntax  ------------------------------------------------- */
-#ifdef SWIGJAVASCRIPT
-#endif
-/* END Javascript syntax */
-
-/* BEGIN Python syntax  ----------------------------------------------------- */
-#ifdef SWIGPYTHON
-#endif
-/* END Python syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-/* SWIG preprocessor copies this directly to the output wrapper*/
-#include "sensortemplate.hpp"
-%}
-
-/* %include is a SWIG directive.  SWIG will wrap types exposed in this
- * header to the target language. */
-%include "sensortemplate.hpp"
-/* END Common SWIG syntax */
diff --git a/src/sensortemplate/sensortemplate.json b/src/sensortemplate/sensortemplate.json
deleted file mode 100644
index 6d3478c..0000000
--- a/src/sensortemplate/sensortemplate.json
+++ /dev/null
@@ -1,251 +0,0 @@
-{
-    "// Library": {
-        "comment": "Library name. Usually synonymous with the chip ID (e.g. fooinc0378). However, in the case where this library implements multiple sensor classes, choose a name which describes the full functionality (e.g. fooincled).",
-        "type": "string",
-        "required": true
-    },
-    "Library": "sensortemplate",
-    "// Description": {
-        "comment": "Library description. This library provides support for the fooincled family of sensors.",
-        "type": "string",
-        "required": true
-    },
-    "Description": "This is a sensor library template used for new sensors",
-    "// Sensor Class": {
-        "comment": "Sensor/actuator class object which corresponds to the sensor/actuator C++ class (case sensitive).",
-        "type": "object",
-        "required": true
-    },
-    "Sensor Class": {
-        "// SensorTemplate": {
-            "comment": "Template Item",
-            "type": "object",
-            "required": true
-        },
-        "SensorTemplate": {
-            "// Name": {
-                "comment": "Sensor display name as indicated by the datasheet or manufacturer",
-                "type": "string",
-                "required": true
-            },
-            "Name": "Template Sensor",
-            "// Description": {
-                "comment": "In-depth description of the C++ sensor/actuator class. Include any necessary information on what is required for this implementation to work.",
-                "type": "string",
-                "required": true
-            },
-            "Description": "This sensor template can be used to generate code stubs for new sensor library development",
-            "// Aliases": {
-                "comment": "Known vendor/manufacturer part numbers or names for the sensor/actuator/s supported by this class. Part numbers/IDs are preferred when available.",
-                "type": "array",
-                "required": false
-            },
-            "Aliases": [
-                "template"
-            ],
-            "// Categories": {
-                "comment": "One or more categories that his sensor class fits in.",
-                "type": "array",
-                "required": true
-            },
-            "Categories": [
-                "other"
-            ],
-            "// Connections": {
-                "comment": "One or more connection types for this sensor class.",
-                "type": "array",
-                "required": true
-            },
-            "Connections": [
-                "i2c"
-            ],
-            "// Project Type": {
-                "comment": "One or more application fields or project types sensor is suited for (e.g. prototyping, industrial)",
-                "type": "array",
-                "required": true
-            },
-            "Project Type": [
-                "prototyping"
-            ],
-            "// Manufacturers": {
-                "comment": "One or more manufacturers for the hardware supported by this class.",
-                "type": "array",
-                "required": true
-            },
-            "Manufacturers": [
-                "generic"
-            ],
-            "// Kits": {
-                "comment": "One or more retail kits that provide this sensor",
-                "type": "array",
-                "required": false
-            },
-            "Kits": [],
-            "// Image": {
-                "comment": "A single small (0-20k) html-viewable image file (located in docs/images). Please do not use existing, copyrighted images with your sensors.",
-                "type": "string",
-                "required": false
-            },
-            "Image": "sensortemplate.png",
-            "// Examples": {
-                "comment": "Functional examples showing the main use cases for this sensor class. At least one is required.",
-                "type": "object",
-                "required": true
-            },
-            "Examples": {
-                "// Java": {
-                    "comment": "One or more Java examples.",
-                    "type": "array",
-                    "required": false
-                },
-                "Java": [
-                    "SensorTemplate_Example_Example_Example.java"
-                ],
-                "// Python": {
-                    "comment": "One or more Python examples.",
-                    "type": "array",
-                    "required": false
-                },
-                "Python": [
-                    "sensortemplate.py"
-                ],
-                "// Node.js": {
-                    "comment": "One or more Node.js examples.",
-                    "type": "array",
-                    "required": false
-                },
-                "Node.js": [
-                    "sensortemplate.js"
-                ],
-                "// C++": {
-                    "comment": "One or more C++ examples.",
-                    "type": "array",
-                    "required": true
-                },
-                "C++": [
-                    "sensortemplate.cxx"
-                ],
-                "// C": {
-                    "comment": "One or more C examples.",
-                    "type": "array",
-                    "required": false
-                },
-                "C": null
-            },
-            "// Specifications": {
-                "comment": "Catch-all for HW specifications.",
-                "type": "object",
-                "required": false
-            },
-            "Specifications": {
-                "// Vdd": {
-                    "comment": "Example specification. Provides unit value and range.",
-                    "type": "object",
-                    "required": false
-                },
-                "Vdd": {
-                    "// unit": {
-                      "comment": "Example specification. Provides unit value and range.",
-                      "type": "string",
-                      "required": false
-                    },
-                    "unit": "v",
-                    "low": 1.7,
-                    "high": 3.6
-                },
-                "// Ioff": {
-                    "comment": "Example specification. Provides unit value and range.",
-                    "type": "object",
-                    "required": false
-                },
-                "Ioff": {
-                    "unit": "mA",
-                    "typical": 0
-                },
-                "// Iavg": {
-                    "comment": "Example specification. Provides unit value and range.",
-                    "type": "object",
-                    "required": false
-                },
-                "Iavg": {
-                    "unit": "mA",
-                    "low": 1,
-                    "high": 2
-                },
-                "// Measured Range": {
-                    "comment": "Example specification. Provides unit value and range.",
-                    "type": "object",
-                    "required": false
-                },
-                "Measured Range": {
-                    "unit": "raw",
-                    "low": 0,
-                    "high": 1023
-                },
-                "// Other Specs": {
-                    "comment": "Example specification. Provides unit value and range.",
-                    "type": "object",
-                    "required": false
-                },
-                "Other Specs": {}
-            },
-            "// Platforms": {
-                "comment": "Catch-all for listing platforms used to validate this sensor class.",
-                "type": "object",
-                "required": false
-            },
-            "Platforms": {
-                "// Intel Joule Module": {
-                    "comment": "Example platform.",
-                    "type": "object",
-                    "required": false
-                },
-                "Intel Joule Module": {
-                    "// Notes": {
-                        "comment": "JSON Object or Array which documents this platform.",
-                        "type": "array",
-                        "required": false
-                    },
-                    "Notes": [
-                        "Requires pull-up resistors with carrier board"
-                    ],
-                    "// Images": {
-                        "comment": "JSON Object or Array which documents this platform.",
-                        "type": "array",
-                        "required": false
-                    },
-                    "Images": [
-                        ""
-                    ]
-                }
-            },
-            "// Urls": {
-                "comment": "Collection of external URLs which provide additional documentation for this sensor class.",
-                "type": "object",
-                "required": true
-            },
-            "Urls": {
-                "// Product Pages": {
-                    "comment": "Provide at least one URL for a product web-site where users can get additional information on this sensor.",
-                    "type": "array",
-                    "required": true
-                },
-                "Product Pages": [
-                    "https://software.intel.com/en-us/iot/hardware/sensors/short-title-case-description-from-datasheet-manditory"
-                ],
-                "// Datasheets": {
-                    "comment": "Array of product datasheets",
-                    "type": "array",
-                    "required": false
-                },
-                "Datasheets": [],
-                "// Schematics": {
-                    "comment": "Array of product schematic pages.",
-                    "type": "array",
-                    "required": false
-                },
-                "Schematics": []
-            }
-        }
-    }
-}
diff --git a/src/servo/CMakeLists.txt b/src/servo/CMakeLists.txt
deleted file mode 100644
index 592c33d..0000000
--- a/src/servo/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME servo
-    DESCRIPTION "Servo Controller"
-    C_HDR es08a.h es9257.h
-    C_SRC es08a.c es9257.c
-    CPP_HDR servo.hpp es08a.hpp es9257.hpp
-    CPP_SRC servo.cxx es08a.cxx es9257.cxx
-    FTI_SRC es08a_fti.c es9257_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/servo/es08a.c b/src/servo/es08a.c
deleted file mode 100644
index 97b5725..0000000
--- a/src/servo/es08a.c
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#include "es08a.h"
-#include "upm_utilities.h"
-
-es08a_context es08a_init(int32_t pin, int32_t min_pulse_width,
-                         int32_t max_pulse_width) {
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        return NULL;
-    }
-
-    es08a_context dev = (es08a_context) malloc(sizeof(struct _es08a_context));
-
-    if(dev == NULL){
-        printf("Unable to assign memory to the Servo motor structure");
-        return NULL;
-    }
-
-    dev->servo_pin = pin;
-
-    // second is the min pulse width
-    dev->min_pulse_width = min_pulse_width;
-    // third is the max pulse width
-    dev->max_pulse_width = max_pulse_width;
-
-    dev->pwm = mraa_pwm_init(dev->servo_pin);
-    if(dev->pwm == NULL){
-        printf("Unable to initialize the PWM pin");
-    }
-
-    es08a_set_angle(dev, 0);
-    return dev;
-}
-
-void es08a_halt(es08a_context dev){
-    mraa_pwm_enable(dev->pwm, 0);
-    free(dev);
-}
-
-upm_result_t es08a_set_angle(es08a_context dev, int32_t angle){
-
-    if(ES08A_MAX_ANGLE < angle || angle < 0){
-        printf("The angle specified is either above the max angle or below 0");
-        return UPM_ERROR_UNSPECIFIED;
-    }
-    printf("setting angle to: %d\n", angle);
-
-    mraa_pwm_enable(dev->pwm, 1);
-    mraa_pwm_period_us(dev->pwm, ES08A_PERIOD);
-    int32_t val = 0;
-
-    es08a_calc_pulse_travelling(dev, &val, angle);
-    mraa_pwm_pulsewidth_us(dev->pwm, val);
-
-    upm_delay(1);
-    mraa_pwm_enable(dev->pwm, 0);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t es08a_calc_pulse_travelling(const es08a_context dev,
-                                         int32_t* ret_val, int32_t value){
-    if (value > (int)dev->max_pulse_width) {
-        return dev->max_pulse_width;
-    }
-
-    // if less than the boundaries
-    if (value  < 0) {
-        return dev->min_pulse_width;
-    }
-
-    *ret_val = (int) ((float)dev->min_pulse_width + ((float)value / ES08A_MAX_ANGLE) * ((float)dev->max_pulse_width - (float)dev->min_pulse_width));
-    return UPM_SUCCESS;
-}
-
-void es08a_set_min_pulse_width (es08a_context dev, int width){
-    dev->min_pulse_width = width;
-}
-
-void es08a_set_max_pulse_width (es08a_context dev, int width){
-    dev->max_pulse_width = width;
-}
-
-int es08a_get_min_pulse_width (es08a_context dev){
-    return dev->min_pulse_width;
-}
-
-int es08a_get_max_pulse_width (es08a_context dev){
-    return dev->max_pulse_width;
-}
diff --git a/src/servo/es08a.cxx b/src/servo/es08a.cxx
deleted file mode 100644
index eab14c9..0000000
--- a/src/servo/es08a.cxx
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <unistd.h>
-
-#include "es08a.hpp"
-
-using namespace upm;
-
-ES08A::ES08A (int pin) : Servo(pin) {
-    m_name          = "ES08A";
-    m_maxAngle      = 180.0;
-    m_minPulseWidth = 600;
-    m_maxPulseWidth = 2200;
-}
-
-ES08A::~ES08A() {
-
-}
diff --git a/src/servo/es08a.h b/src/servo/es08a.h
deleted file mode 100644
index 8ec709a..0000000
--- a/src/servo/es08a.h
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef ES08A_H_
-#define ES08A_H_
-
-#include <string.h>
-#include <stdlib.h>
-#include <unistd.h>
-
-#include "upm.h"
-#include "mraa/pwm.h"
-
-#define ES08A_MIN_PULSE_WIDTH             600
-#define ES08A_MAX_PULSE_WIDTH             2200
-#define ES08A_PERIOD                      20000
-#define ES08A_MAX_ANGLE                   180.0
-
-/**
- * @file es08a.h
- * @library servo
- * @brief C API for the ES08A Servo
- *
- * @include es08a.c
- */
-
-/**
- * device context
- */
-typedef struct _es08a_context {
-    mraa_pwm_context    pwm;
-    uint16_t            servo_pin;
-    uint32_t            max_pulse_width;
-    uint32_t            min_pulse_width;
-} *es08a_context;
-
-/**
- * Instantiates a the servo at the given pin
- *
- * @param pin Servo pin number
- * @param minPulseWidth Minimum pulse width, in microseconds
- * @param maxPulseWidth Maximum pulse width, in microseconds
- * @param waitAndDisablePwm If 1, PWM is enabled only during the
- * setAngle() execution for a period of 1 second, and then turned back
- * off. If 0, PWM remains on afterward.
- */
-
-
-es08a_context es08a_init(int32_t pin, int32_t min_pulse_width,
-                         int32_t max_pulse_width);
-
-/**
- * Halts PWM for this servo and allows it to move freely.
- */
-void es08a_halt(es08a_context dev);
-
-/**
- * Sets the angle of the servo engine.
- *
- * @param angle Number between 0 and 180
- * @return 0 if successful, non-zero otherwise
- */
-upm_result_t es08a_set_angle(es08a_context dev, int32_t angle);
-
-/*
- * Calculating relative pulse time to the value.
- * */
-upm_result_t es08a_calc_pulse_travelling(const es08a_context dev,
-                                         int32_t* ret_val,
-                                         int32_t value);
-
-/**
- * Sets the minimum pulse width
- *
- * @param width Minimum HIGH signal width
- */
-void es08a_set_min_pulse_width (es08a_context dev, int width);
-
-/**
- * Sets the maximum pulse width
- *
- * @param width Maximum HIGH signal width
- */
-void es08a_set_max_pulse_width (es08a_context dev, int width);
-
-/**
- * Returns the minimum pulse width
- *
- * @return Minimum pulse width
- */
-int es08a_get_min_pulse_width (es08a_context dev);
-
-/**
- * Returns the maximum pulse width
- *
- * @return Maximum pulse width
- */
-int es08a_get_max_pulse_width (es08a_context dev);
-
-#endif /* ES08A_H_ */
diff --git a/src/servo/es08a.hpp b/src/servo/es08a.hpp
deleted file mode 100644
index 856c820..0000000
--- a/src/servo/es08a.hpp
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include "servo.hpp"
-
-namespace upm {
-
-/**
- * @library servo
- * @sensor es08a
- * @comname High-sensitivity Mini Servo
- * @altname Grove Servo
- * @type servos
- * @man emax
- * @web https://www.seeedstudio.com/EMAX-9g-ES08A-High-Sensitive-Mini-Servo-p-760.html
- * @con pwm
- * @kit gsk
- *
- * @brief API for the ES08A Servo
- * 
- * This module defines the ES08A interface for ES08A servos.
- * Like other servos, the ES08A servo has a shaft that can be controlled
- * by setting the desired angle. There are also routines for setting
- * and getting the minimum and maximum pulse width as well as the
- * maximum period.
- *
- * @image html es08a.jpg
- * @snippet servo-es08a.cxx Interesting
- */
- class ES08A : public Servo {
-    public:
-        /**
-         * Instantiates an ES08A object
-         *
-         * @param pin Servo pin number
-         */
-        ES08A (int pin);
-
-        /**
-         * ES08A object destructor
-         */
-        ~ES08A ();
-};
-
-}
diff --git a/src/servo/es08a_fti.c b/src/servo/es08a_fti.c
deleted file mode 100644
index b635c11..0000000
--- a/src/servo/es08a_fti.c
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "es08a.h"
-
-#include "upm_fti.h"
-
-/** 
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_es08a_name[] = "ES08A";
-const char upm_es08a_description[] = "Grove Servo Motor";
-const upm_protocol_t upm_es08a_protocol[] = {UPM_PWM};
-const upm_sensor_t upm_es08a_category[] = {UPM_SERVO};
-
-// forward declarations
-const upm_sensor_descriptor_t upm_es08a_get_descriptor ();
-const void* upm_es08a_get_ft(upm_sensor_t sensor_type);
-void* upm_es08a_init_name();
-upm_result_t upm_es08a_set_angle(void* dev, int32_t angle);
-void upm_es08a_close(void* dev);
-
-const upm_sensor_descriptor_t upm_es08a_get_descriptor (){
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_es08a_name;
-    usd.description = upm_es08a_description;
-    usd.protocol_size = 1;
-    usd.protocol = upm_es08a_protocol;
-    usd.category_size = 1;
-    usd.category = upm_es08a_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = &upm_es08a_init_name,
-    .upm_sensor_close = &upm_es08a_close,
-    .upm_sensor_get_descriptor = &upm_es08a_get_descriptor
-};
-
-static const upm_servo_ft sft =
-{
-    .upm_servo_set_angle = &upm_es08a_set_angle
-};
-
-const void* upm_es08a_get_ft(upm_sensor_t sensor_type){
-    if(sensor_type == UPM_SERVO){
-        return &sft;
-    }
-    else if(sensor_type == UPM_SENSOR){
-        return &ft;
-    }
-    return NULL;
-}
-
-void* upm_es08a_init_name(){
-    return NULL;
-}
-
-void upm_es08a_close(void* dev){
-    es08a_halt((es08a_context)dev);
-}
-
-upm_result_t upm_es08a_set_angle(void* dev, int32_t angle){
-    return es08a_set_angle((es08a_context)dev, angle);
-}
\ No newline at end of file
diff --git a/src/servo/es9257.c b/src/servo/es9257.c
deleted file mode 100644
index c55cc44..0000000
--- a/src/servo/es9257.c
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#include "es9257.h"
-#include "upm_utilities.h"
-
-es9257_context es9257_init(int32_t pin, int32_t min_pulse_width,
-                         int32_t max_pulse_width) {
-
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        return NULL;
-    }
-
-    es9257_context dev = (es9257_context) malloc(sizeof(struct _es9257_context));
-
-    if(dev == NULL){
-        printf("Unable to assign memory to the Servo motor structure");
-        return NULL;
-    }
-
-    dev->servo_pin = pin;
-
-    // second is the min pulse width
-    dev->min_pulse_width = min_pulse_width;
-    // third is the max pulse width
-    dev->max_pulse_width = max_pulse_width;
-
-    dev->pwm = mraa_pwm_init(dev->servo_pin);
-    if(dev->pwm == NULL){
-        printf("Unable to initialize the PWM pin");
-    }
-
-    es9257_set_angle(dev, 0);
-    return dev;
-}
-
-void es9257_halt(es9257_context dev){
-    mraa_pwm_enable(dev->pwm, 0);
-    free(dev);
-}
-
-upm_result_t es9257_set_angle(es9257_context dev, int32_t angle){
-
-    if(ES9257_MAX_ANGLE < angle || angle < 0){
-        printf("The angle specified is either above the max angle or below 0");
-        return UPM_ERROR_UNSPECIFIED;
-    }
-    printf("setting angle to: %d\n", angle);
-
-    mraa_pwm_enable(dev->pwm, 1);
-    mraa_pwm_period_us(dev->pwm, ES9257_PERIOD);
-    int32_t val = 0;
-
-    es9257_calc_pulse_travelling(dev, &val, angle);
-    mraa_pwm_pulsewidth_us(dev->pwm, val);
-
-    upm_delay(1);
-    mraa_pwm_enable(dev->pwm, 0);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t es9257_calc_pulse_travelling(const es9257_context dev,
-                                         int32_t* ret_val, int32_t value){
-    if (value > (int)dev->max_pulse_width) {
-        return dev->max_pulse_width;
-    }
-
-    // if less than the boundaries
-    if (value  < 0) {
-        return dev->min_pulse_width;
-    }
-
-    *ret_val = (int) ((float)dev->min_pulse_width + ((float)value / ES9257_MAX_ANGLE) * ((float)dev->max_pulse_width - (float)dev->min_pulse_width));
-    return UPM_SUCCESS;
-}
-
-void es9257_set_min_pulse_width (es9257_context dev, int width){
-    dev->min_pulse_width = width;
-}
-
-void es9257_set_max_pulse_width (es9257_context dev, int width){
-    dev->max_pulse_width = width;
-}
-
-int es9257_get_min_pulse_width (es9257_context dev){
-    return dev->min_pulse_width;
-}
-
-int es9257_get_max_pulse_width (es9257_context dev){
-    return dev->max_pulse_width;
-}
diff --git a/src/servo/es9257.cxx b/src/servo/es9257.cxx
deleted file mode 100644
index 6f55d45..0000000
--- a/src/servo/es9257.cxx
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Author: Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <unistd.h>
-
-#include "es9257.hpp"
-
-using namespace upm;
-
-ES9257::ES9257 (int pin) : Servo(pin) {
-    m_name          = "ES9257";
-    m_maxAngle      = 180.0;
-    m_minPulseWidth = 475;
-    m_maxPulseWidth = 2100;
-}
-
-ES9257::~ES9257() {
-
-}
diff --git a/src/servo/es9257.h b/src/servo/es9257.h
deleted file mode 100644
index 4a1ec52..0000000
--- a/src/servo/es9257.h
+++ /dev/null
@@ -1,119 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef ES9257_H_
-#define ES9257_H_
-
-#include <string.h>
-#include <stdlib.h>
-#include <unistd.h>
-
-#include "upm.h"
-#include "mraa/pwm.h"
-
-#define ES9257_MIN_PULSE_WIDTH             475
-#define ES9257_MAX_PULSE_WIDTH             2100
-#define ES9257_PERIOD                      20000
-#define ES9257_MAX_ANGLE                   180.0
-
-/**
- * @file es9257.h
- * @library servo
- * @brief C API for the ES9257 Servo
- *
- * @include es9257.c
- */
-
-/*
- * device context
- */
-typedef struct _es9257_context {
-    mraa_pwm_context    pwm;
-    uint16_t            servo_pin;
-    uint32_t            max_pulse_width;
-    uint32_t            min_pulse_width;
-} *es9257_context;
-
-/**
- * Instantiates a the servo at the given pin
- *
- * @param pin Servo pin number
- * @param minPulseWidth Minimum pulse width, in microseconds
- * @param maxPulseWidth Maximum pulse width, in microseconds
- */
-
-
-es9257_context es9257_init(int32_t pin, int32_t min_pulse_width,
-                         int32_t max_pulse_width);
-
-/**
- * Halts PWM for this servo and allows it to move freely.
- */
-void es9257_halt(es9257_context dev);
-
-/**
- * Sets the angle of the servo engine.
- *
- * @param angle Number between 0 and 180
- * @return 0 if successful, non-zero otherwise
- */
-upm_result_t es9257_set_angle(es9257_context dev, int32_t angle);
-
-/*
- * Calculating relative pulse time to the value.
- * */
-upm_result_t es9257_calc_pulse_travelling(const es9257_context dev,
-                                         int32_t* ret_val,
-                                         int32_t value);
-
-/**
- * Sets the minimum pulse width
- *
- * @param width Minimum HIGH signal width
- */
-void es9257_set_min_pulse_width (es9257_context dev, int width);
-
-/**
- * Sets the maximum pulse width
- *
- * @param width Maximum HIGH signal width
- */
-void es9257_set_max_pulse_width (es9257_context dev, int width);
-
-/**
- * Returns the minimum pulse width
- *
- * @return Minimum pulse width
- */
-int es9257_get_min_pulse_width (es9257_context dev);
-
-/**
- * Returns the maximum pulse width
- *
- * @return Maximum pulse width
- */
-int es9257_get_max_pulse_width (es9257_context dev);
-
-#endif /* ES9257_H_ */
\ No newline at end of file
diff --git a/src/servo/es9257.hpp b/src/servo/es9257.hpp
deleted file mode 100644
index 793dde8..0000000
--- a/src/servo/es9257.hpp
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Author: Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include "servo.hpp"
-
-namespace upm {
-
-/**
- * @library servo
- * @sensor es9257
- * @comname Micro Digital 3D Tail Servo
- * @altname Grove Servo
- * @type servos
- * @man emax
- * @web https://www.seeedstudio.com/EMAX-ES9257-2.5kg%26amp%3B-.05-sec-Micro-Digital-3D-Tail-Servo-p-762.html
- * @con pwm
- * @kit gsk
- *
- * @brief API for the ES9257 Servo
- * 
- * This module defines the ES9257 interface for ES9257 servos.
- * The ES9257 servo is a fast, heavy duty servo that is popular for moving the
- * control surfaces on RC models.
- * 
- * @image html es9257.jpg
- */
- class ES9257 : public Servo {
-    public:
-        /**
-         * Instantiates an ES9257 object
-         *
-         * @param pin Servo pin number
-         */
-        ES9257 (int pin);
-
-        /**
-         * ES9257 object destructor
-         */
-        ~ES9257 ();
-};
-
-}
diff --git a/src/servo/es9257_fti.c b/src/servo/es9257_fti.c
deleted file mode 100644
index 2599987..0000000
--- a/src/servo/es9257_fti.c
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "es9257.h"
-
-#include "upm_fti.h"
-
-/** 
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_es9257_name[] = "ES9257";
-const char upm_es9257_description[] = "Grove Servo Motor";
-const upm_protocol_t upm_es9257_protocol[] = {UPM_PWM};
-const upm_sensor_t upm_es9257_category[] = {UPM_SERVO};
-
-// forward declarations
-const upm_sensor_descriptor_t upm_es9257_get_descriptor ();
-const void* upm_es9257_get_ft(upm_sensor_t sensor_type);
-void* upm_es9257_init_name();
-upm_result_t upm_es9257_set_angle(void* dev, int32_t angle);
-void upm_es9257_close(void* dev);
-
-const upm_sensor_descriptor_t upm_es9257_get_descriptor (){
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_es9257_name;
-    usd.description = upm_es9257_description;
-    usd.protocol_size = 1;
-    usd.protocol = upm_es9257_protocol;
-    usd.category_size = 1;
-    usd.category = upm_es9257_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = &upm_es9257_init_name,
-    .upm_sensor_close = &upm_es9257_close,
-    .upm_sensor_get_descriptor = &upm_es9257_get_descriptor
-};
-
-static const upm_servo_ft sft =
-{
-    .upm_servo_set_angle = &upm_es9257_set_angle
-};
-
-const void* upm_es9257_get_ft(upm_sensor_t sensor_type){
-    if(sensor_type == UPM_SERVO){
-        return &sft;
-    }
-    else if(sensor_type == UPM_SENSOR){
-        return &ft;
-    }
-    return NULL;
-}
-
-void* upm_es9257_init_name(){
-    return NULL;
-}
-
-void upm_es9257_close(void* dev){
-    es9257_halt((es9257_context)dev);
-}
-
-upm_result_t upm_es9257_set_angle(void* dev, int32_t angle){
-    return es9257_set_angle((es9257_context)dev, angle);
-}
\ No newline at end of file
diff --git a/src/servo/servo.cxx b/src/servo/servo.cxx
deleted file mode 100644
index 9ed031d..0000000
--- a/src/servo/servo.cxx
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <sstream>
-#include <string>
-#include <stdexcept>
-#include <unistd.h>
-#include <stdlib.h>
-#include <math.h>
-
-#include "servo.hpp"
-
-using namespace upm;
-
-Servo::Servo (int pin) {
-    init(pin, MIN_PULSE_WIDTH, MAX_PULSE_WIDTH, DEFAULT_WAIT_DISABLE_PWM);
-}
-
-Servo::Servo (int pin, int minPulseWidth, int maxPulseWidth) {
-    init(pin, minPulseWidth, maxPulseWidth, DEFAULT_WAIT_DISABLE_PWM);
-}
-
-Servo::Servo (int pin, int minPulseWidth, int maxPulseWidth, int waitAndDisablePwm) {
-    init(pin, minPulseWidth, maxPulseWidth, waitAndDisablePwm);
-}
-
-Servo::~Servo () {
-    haltPwm();
-    mraa_pwm_close (m_pwmServoContext);
-}
-
-/*
- * X = between (MIN_PULSE_WIDTH , MAX_PULSE_WIDTH)
- *
- * X usec
- * _______
- *        |_______________________________________
- *                      m_period usec
- *
- * */
-mraa_result_t Servo::setAngle (int angle) {
-    if (angle > m_maxAngle || angle < 0) {
-        // C++11 std::to_string() would be nice, but...
-        std::ostringstream str;
-        str << m_maxAngle;
-        throw std::out_of_range(std::string(__FUNCTION__) +
-                                ": angle must be between 0 and " +
-                                str.str());
-
-        return MRAA_ERROR_UNSPECIFIED;
-    }
-
-    mraa_pwm_enable (m_pwmServoContext, 1);
-    mraa_pwm_period_us (m_pwmServoContext, m_period);
-    mraa_pwm_pulsewidth_us (m_pwmServoContext, calcPulseTraveling(angle));
-
-    if (m_waitAndDisablePwm) {
-        sleep(1); // we must make sure that we don't turn off PWM before the servo is done moving.
-        haltPwm();
-    }
-
-    m_currAngle = angle;
-    return MRAA_SUCCESS;
-}
-
-mraa_result_t Servo::haltPwm () {
-    return mraa_pwm_enable (m_pwmServoContext, 0);
-}
-
-/*
- * Calculating relative pulse time to the value.
- * */
-int Servo::calcPulseTraveling (int value) {
-    // if bigger than the boundaries
-    if (value > m_maxAngle) {
-        return m_maxPulseWidth;
-    }
-
-    // if less than the boundaries
-    if (value  < 0) {
-        return m_minPulseWidth;
-    }
-
-    // the conversion
-    return (int) ((float)m_minPulseWidth + ((float)value / m_maxAngle) * ((float)m_maxPulseWidth - (float)m_minPulseWidth));
-}
-
-void
-Servo::setMinPulseWidth (int width) {
-    m_minPulseWidth = width;
-}
-
-void
-Servo::setMaxPulseWidth (int width) {
-    m_maxPulseWidth = width;
-}
-
-void
-Servo::setPeriod (int period) {
-    m_period = period;
-}
-
-int
-Servo::getMinPulseWidth () {
-    return m_minPulseWidth;
-}
-
-int
-Servo::getMaxPulseWidth () {
-    return m_maxPulseWidth;
-}
-
-int
-Servo::getPeriod () {
-    return m_period;
-}
-
-/**
- *  private mathod:  would like to use delegating constructors instead but that requires C++11
- */
-void
-Servo::init (int pin, int minPulseWidth, int maxPulseWidth, int waitAndDisablePwm) {
-    m_minPulseWidth   = minPulseWidth;
-    m_maxPulseWidth   = maxPulseWidth;
-    m_period          = PERIOD;
-
-    m_waitAndDisablePwm = waitAndDisablePwm;
-
-    m_maxAngle        = 180.0;
-    m_servoPin        = pin;
-    
-    if ( !(m_pwmServoContext = mraa_pwm_init (m_servoPin)) ) 
-      {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_pwm_init() failed, invalid pin?");
-        return;
-      }
-
-    m_currAngle = 180;
-
-    setAngle (0);
-}
diff --git a/src/servo/servo.hpp b/src/servo/servo.hpp
deleted file mode 100644
index 490789a..0000000
--- a/src/servo/servo.hpp
+++ /dev/null
@@ -1,168 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/pwm.h>
-
-namespace upm {
-
-#define MIN_PULSE_WIDTH             600
-#define MAX_PULSE_WIDTH             2500
-#define PERIOD                      20000
-
-#define HIGH                        1
-#define LOW                         0
-
-#define DEFAULT_WAIT_DISABLE_PWM    0
-
-/**
- * @brief Servo Library
- *
- * The base Servo class provides routines for setting the angle of the shaft
- * as well as setting and getting the minimum and maximum pulse width and 
- * the maximum period.
- *
- * @defgroup servo libupm-servo
- * @ingroup seeed emax pwm servos gsk
- */
-class Servo {
-    public:
-        /**
-         * Instantiates a Servo object
-         *
-         * @param pin Servo pin number
-         */
-        Servo (int pin);
-
-        /**
-         * Instantiates a Servo object
-         *
-         * @param pin Servo pin number
-         * @param minPulseWidth Minimum pulse width, in microseconds
-         * @param maxPulseWidth Maximum pulse width, in microseconds
-         */
-        Servo (int pin, int minPulseWidth, int maxPulseWidth);
-
-        /**
-         * Instantiates a Servo object
-         *
-         * @param pin Servo pin number
-         * @param minPulseWidth Minimum pulse width, in microseconds
-         * @param maxPulseWidth Maximum pulse width, in microseconds
-         * @param waitAndDisablePwm If 1, PWM is enabled only during the setAngle() execution
-         * for a period of 1 second, and then turned back off. If 0, PWM remains on afterward.
-         */
-        Servo (int pin, int minPulseWidth, int maxPulseWidth, int waitAndDisablePwm);
-
-        /**
-         * Servo object destructor
-         */
-        ~Servo();
-
-        /**
-         * Sets the angle of the servo engine.
-         *
-         * @param angle Number between 0 and 180
-         * @return 0 if successful, non-zero otherwise
-         */
-        mraa_result_t setAngle (int angle);
-
-        /**
-         * Halts PWM for this servo and allows it to move freely.
-         */
-        mraa_result_t haltPwm ();
-
-        /**
-         * Returns the name of the component
-         *
-         * @return Name of the component
-         */
-        std::string name()
-        {
-            return m_name;
-        }
-
-        /**
-         * Sets the minimum pulse width
-         *
-         * @param width Minimum HIGH signal width
-         */
-        void setMinPulseWidth (int width);
-
-        /**
-         * Sets the maximum pulse width
-         *
-         * @param width Maximum HIGH signal width
-         */
-        void setMaxPulseWidth (int width);
-
-        /**
-         * Sets the maximum period width
-         *
-         * @param period PWM period width
-         */
-        void setPeriod (int period);
-
-        /**
-         * Returns the minimum pulse width
-         *
-         * @return Minimum pulse width
-         */
-        int getMinPulseWidth ();
-
-        /**
-         * Returns the maximum pulse width
-         *
-         * @return Maximum pulse width
-         */
-        int getMaxPulseWidth ();
-
-        /**
-         * Returns the maximum PWM period width
-         *
-         * @return Maximum PWM period width
-         */
-        int getPeriod ();
-
-    protected:
-        int calcPulseTraveling (int value);
-
-        std::string         m_name;
-        int                 m_servoPin;
-        float               m_maxAngle;
-        mraa_pwm_context    m_pwmServoContext;
-        int                 m_currAngle;
-
-        int                 m_minPulseWidth;
-        int                 m_maxPulseWidth;
-        int                 m_period;
-
-        int                 m_waitAndDisablePwm;
-
-    private:
-        void init (int pin, int minPulseWidth, int maxPulseWidth, int waitAndDisablePwm);
-};
-
-}
diff --git a/src/servo/servo.i b/src/servo/servo.i
deleted file mode 100644
index b9ed635..0000000
--- a/src/servo/servo.i
+++ /dev/null
@@ -1,18 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_servo)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "es08a.hpp"
-#include "servo.hpp"
-#include "es9257.hpp"
-%}
-%include "servo.hpp"
-%include "es9257.hpp"
-%include "es08a.hpp"
-/* END Common SWIG syntax */
diff --git a/src/servo/servo.json b/src/servo/servo.json
deleted file mode 100644
index f2d8cfd..0000000
--- a/src/servo/servo.json
+++ /dev/null
@@ -1,137 +0,0 @@
-{
-    "Library": "servo",
-    "Description": "Servo Library",
-    "Sensor Class": {
-        "ES08A": {
-            "Name": "API for the EMAX/Seeed ES08A Servo",
-            "Description": "This is the UPM Module for the EMAX/Seeed ES08A Servo. Like other servos, the ES08A servo has a shaft that can be controlled by setting the desired angle. There are also routines for setting and getting the minimum and maximum pulse width as well as the maximum period.",
-            "Aliases": ["es08a", "EMAX 9g ES08A High Sensitive Mini Servo"],
-            "Categories": ["servos"],
-            "Connections": ["pwm"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["EMAX"],
-            "Kits": ["gsk"],
-            "Image": "es08a.jpg",
-            "Examples": {
-                "Java": ["ES08A_Example.java"],
-                "Python": ["es08a.py"],
-                "Node.js": ["es08a.js"],
-                "C++": ["servo-es08a.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 4.8,
-                    "max": 6.0
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Operating Speed": {
-                    "unit": "Sec/60Â°",
-                    "min" : 0.10,
-                    "max" : 0.12
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                },
-                "Intel Edison": {
-                },
-                "Arduino 101": {
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/EMAX-9g-ES08A-High-Sensitive-Mini-Servo-p-760.html", "https://www.emaxmodel.com/es08a-ii.html#product_tabs_description_tabbed"]
-            }
-        },
-        "ES9257": {
-            "Name": "API for the EMAX ES9257 Servo",
-            "Description": "This is the UPM Module for the EMAX ES9257 Servo. The ES9257 servo is a fast, heavy duty servo that is popular for moving the control surfaces on RC models.",
-            "Aliases": ["es9257", "EMAX ES9257 2.5kg& .05 sec Micro Digital 3D Tail Servo"],
-            "Categories": ["servos"],
-            "Connections": ["pwm"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["EMAX"],
-            "Kits": ["gsk"],
-            "Image": "es9257.jpg",
-            "Examples": {
-                "Python": ["es08a.py"],
-                "Node.js": ["es08a.js"],
-                "C++": ["servo-es08a.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "typ" : 4.8
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Operating Speed": {
-                    "unit": "Sec/60Â°",
-                    "typ" : 0.08
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                },
-                "Intel Edison": {
-                },
-                "Arduino 101": {
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/EMAX-ES9257-2.5kg%26amp%3B-.05-sec-Micro-Digital-3D-Tail-Servo-p-762.html"]
-            }
-        },
-        "servo": {
-            "Name": "Servo library",
-            "Description": "This is the UPM Module for the Servo library. The base Servo class provides routines for setting the angle of the shaft as well as setting and getting the minimum and maximum pulse width and  the maximum period.",
-            "Aliases": ["servo"],
-            "Categories": ["servos"],
-            "Connections": ["pwm"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["EMAX"],
-            "Image": "es08a.jpg",
-            "Examples": {
-                "Java": ["ES08A_Example.java"],
-                "Python": ["es08a.py", "es08a.py"],
-                "Node.js": ["es08a.js", "es08a.js"],
-                "C++": ["servo-es08a.cxx", "servo-es08a.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 4.8,
-                    "max": 6.0
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Operating Speed": {
-                    "unit": "Sec/60Â°",
-                    "min" : 0.08,
-                    "max" : 0.12
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                },
-                "Intel Edison": {
-                },
-                "Arduino 101": {
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/EMAX-ES9257-2.5kg%26amp%3B-.05-sec-Micro-Digital-3D-Tail-Servo-p-762.html", "https://www.seeedstudio.com/EMAX-9g-ES08A-High-Sensitive-Mini-Servo-p-760.html", "https://www.emaxmodel.com/es08a-ii.html#product_tabs_description_tabbed"]
-            }
-        }
-    }
-}
diff --git a/src/sht1x/CMakeLists.txt b/src/sht1x/CMakeLists.txt
deleted file mode 100644
index 5b41797..0000000
--- a/src/sht1x/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME sht1x
-    DESCRIPTION "Temperature and Humidity Sensor"
-    C_HDR sht1x.h sht1x_defs.h
-    C_SRC sht1x.c
-    CPP_HDR sht1x.hpp
-    CPP_SRC sht1x.cxx
-    FTI_SRC sht1x_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/sht1x/sht1x.c b/src/sht1x/sht1x.c
deleted file mode 100644
index 945e990..0000000
--- a/src/sht1x/sht1x.c
+++ /dev/null
@@ -1,394 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string.h>
-#include <assert.h>
-
-#include "upm_utilities.h"
-#include "sht1x.h"
-
-sht1x_context sht1x_init(unsigned int clk_pin, unsigned int data_pin)
-{
-  // make sure MRAA is initialized
-  int mraa_rv;
-  if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-  {
-      printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-      return NULL;
-  }
-
-  sht1x_context dev =
-    (sht1x_context)malloc(sizeof(struct _sht1x_context));
-
-  if (!dev)
-    return NULL;
-
-  // zero out context
-  memset((void *)dev, 0, sizeof(struct _sht1x_context));
-
-  dev->gpio_clk = NULL;
-  dev->gpio_data = NULL;
-
-  // initialize the MRAA contexts
-
-  // clock
-  if (!(dev->gpio_clk = mraa_gpio_init(clk_pin)))
-    {
-      printf("%s: mraa_gpio_init(clk) failed.\n", __FUNCTION__);
-      sht1x_close(dev);
-      return NULL;
-    }
-
-  mraa_gpio_dir(dev->gpio_clk, MRAA_GPIO_OUT);
-
-  // data
-  if (!(dev->gpio_data = mraa_gpio_init(data_pin)))
-    {
-      printf("%s: mraa_gpio_init(data) failed.\n", __FUNCTION__);
-      sht1x_close(dev);
-      return NULL;
-    }
-
-  mraa_gpio_dir(dev->gpio_data, MRAA_GPIO_OUT);
-  mraa_gpio_mode(dev->gpio_data, MRAA_GPIO_PULLUP);
-
-  // max init time
-  upm_delay_ms(15);
-
-  // now read the status register to see if we are highres (14b) or not
-  uint8_t status;
-  if (sht1x_read_status(dev, &status))
-    {
-      printf("%s: sht1x_read_status() failed.\n", __FUNCTION__);
-      sht1x_close(dev);
-      return NULL;
-    }
-
-  if (status & SHT1X_STATUS_RESOLUTION_LOW)
-    dev->hires = false;
-  else
-    dev->hires = true;
-
-  // setup our coefficients (see the datasheet).  We always assume 5v
-  // here.  We also only deal with Celcius.
-
-  // this will set coeff_d1
-  sht1x_set_volts(dev, SHT1X_VOLTS_5);
-
-  dev->coeff_c1 = -2.0468;
-  dev->coeff_t1 = 0.01;
-  if (dev->hires)
-    {
-      dev->coeff_d2 = 0.01;
-      dev->coeff_c2 = 0.0367;
-      dev->coeff_c3 = -1.5955e-6;
-      dev->coeff_t2 = 0.00008;
-    }
-  else
-    {
-      dev->coeff_d2 = 0.04;
-      dev->coeff_c2 = 0.5872;
-      dev->coeff_c3 = -4.0845e-4;
-      dev->coeff_t2 = 0.00128;
-    }
-
-  return dev;
-}
-
-void sht1x_close(sht1x_context dev)
-{
-  assert(dev != NULL);
-
-  if (dev->gpio_clk)
-    mraa_gpio_close(dev->gpio_clk);
-  if (dev->gpio_data)
-    mraa_gpio_close(dev->gpio_data);
-
-  free(dev);
-}
-
-upm_result_t sht1x_update(const sht1x_context dev)
-{
-  assert(dev != NULL);
-
-  // byte 3 is the checksum which we currently ignore
-  uint8_t byte1, byte2, byte3;
-
-  // first read the temperature
-  sht1x_send_command(dev, SHT1X_CMD_MEAS_TEMPERATURE);
-  if (sht1x_wait_for_response(dev))
-    {
-      printf("%s: wait_for_response(temp) failed.\n", __FUNCTION__);
-      return UPM_ERROR_OPERATION_FAILED;
-    }
-
-  sht1x_read_8bits(dev, &byte1);
-  sht1x_read_8bits(dev, &byte2);
-  sht1x_read_8bits(dev, &byte3);
-
-  int temp = (byte1 << 8) | byte2;
-
-  // compute temperature
-  dev->temperature = dev->coeff_d1 + dev->coeff_d2 * (float)temp;
-
-  // now get humidity
-  sht1x_send_command(dev, SHT1X_CMD_MEAS_HUMIDITY);
-  if (sht1x_wait_for_response(dev))
-    {
-      printf("%s: wait_for_response(hum) failed.\n", __FUNCTION__);
-      return UPM_ERROR_OPERATION_FAILED;
-    }
-
-  sht1x_read_8bits(dev, &byte1);
-  sht1x_read_8bits(dev, &byte2);
-  sht1x_read_8bits(dev, &byte3);
-
-  temp = (byte1 << 8) | byte2;
-
-  // first we compute a linear humidity reading, then apply temperature
-  // compensation
-  float linHumidity = dev->coeff_c1 + dev->coeff_c2 * (float)temp
-    + dev->coeff_c3 * (float)temp * (float)temp;
-
-  // convert to "true" RH (temperature compensated)
-  dev->humidity = (dev->temperature - 25.0) * (dev->coeff_t1 + dev->coeff_t2)
-    + linHumidity;
-
-  if (dev->humidity > 99.0)
-    dev->humidity = 100.0;
-
-  return UPM_SUCCESS;
-}
-
-void sht1x_start_xmit(const sht1x_context dev)
-{
-  mraa_gpio_dir(dev->gpio_data, MRAA_GPIO_OUT);
-
-  // start sequence
-  mraa_gpio_write(dev->gpio_data, 1);
-  mraa_gpio_write(dev->gpio_clk, 1);
-
-  mraa_gpio_write(dev->gpio_data, 0);
-  mraa_gpio_write(dev->gpio_clk, 0);
-
-  mraa_gpio_write(dev->gpio_clk, 1);
-  mraa_gpio_write(dev->gpio_data, 1);
-
-  mraa_gpio_write(dev->gpio_clk, 0);
-}
-
-upm_result_t sht1x_write_8bits(const sht1x_context dev, uint8_t byte)
-{
-  // send the byte
-  mraa_gpio_dir(dev->gpio_data, MRAA_GPIO_OUT);
-
-  int i;
-  for (i=0; i<8; i++)
-    {
-      if (byte & 0x80)
-        mraa_gpio_write(dev->gpio_data, 1);
-      else
-        mraa_gpio_write(dev->gpio_data, 0);
-
-      mraa_gpio_write(dev->gpio_clk, 1);
-      mraa_gpio_write(dev->gpio_clk, 0);
-
-      byte <<= 1;
-    }
-
-  // now wait for the ack response.  After the falling edge of the 8th
-  // clock (above), the data line should be pulled low.  Then, after
-  // the falling edge of the ninth clock pulse, the data line should
-  // go high.  We check the data line after the rising edge of the
-  // ninth clock to make sure it went low.
-  bool ackError = false;
-
-  mraa_gpio_dir(dev->gpio_data, MRAA_GPIO_IN);
-
-  // start 9th clock
-  mraa_gpio_write(dev->gpio_clk, 1);
-
-  // should be low.  If it's high, there is a problem.
-  if (mraa_gpio_read(dev->gpio_data))
-    ackError = true;
-
-  // finish 9th clock
-  mraa_gpio_write(dev->gpio_clk, 0);
-
-  if (ackError)
-    {
-      printf("%s: didn't receive proper ACK from SHT1X.\n", __FUNCTION__);
-      return UPM_ERROR_OPERATION_FAILED;
-    }
-
-  return UPM_SUCCESS;
-}
-
-upm_result_t sht1x_send_command(const sht1x_context dev, SHT1X_CMD_T cmd)
-{
-  assert(dev != NULL);
-
-  sht1x_start_xmit(dev);
-
-  // send the command
-  return sht1x_write_8bits(dev, (uint8_t)cmd);
-}
-
-upm_result_t sht1x_wait_for_response(const sht1x_context dev)
-{
-  assert(dev != NULL);
-
-  const int maxRetries = 500;
-  int r = 0;
-
-  mraa_gpio_dir(dev->gpio_data, MRAA_GPIO_IN);
-
-  // we wait for some time (about .5 seconds, more than enough time)
-  // for the data line to be pulled low.
-  while (r++ < maxRetries)
-    {
-      if (!mraa_gpio_read(dev->gpio_data))
-        break;
-
-      upm_delay_ms(1);
-    }
-
-  if (r >= maxRetries)
-    {
-      printf("%s: no response to measurement request.\n", __FUNCTION__);
-      return UPM_ERROR_OPERATION_FAILED;
-    }
-
-  //  printf("%s: retries: %d\n", __FUNCTION__, r);
-
-  return UPM_SUCCESS;
-}
-
-void sht1x_read_8bits(const sht1x_context dev, uint8_t *value)
-{
-  assert(dev != NULL);
-
-  // we need to read a byte, and acknowlege it
-
-  uint8_t byte = 0;
-
-  mraa_gpio_dir(dev->gpio_data, MRAA_GPIO_IN);
-
-  int i;
-
-  for (i=0; i<8; i++)
-    {
-      mraa_gpio_write(dev->gpio_clk, 1);
-
-      if (mraa_gpio_read(dev->gpio_data))
-        byte |= 1;
-
-      // don't shift on the last bit!
-      if (i != 7)
-        byte <<= 1;
-
-      mraa_gpio_write(dev->gpio_clk, 0);
-    }
-
-  *value = byte;
-
-  // send the ack
-
-  mraa_gpio_dir(dev->gpio_data, MRAA_GPIO_OUT);
-
-  // pull data line low
-  mraa_gpio_write(dev->gpio_data, 0);
-  // cycle the clock
-  mraa_gpio_write(dev->gpio_clk, 1);
-  mraa_gpio_write(dev->gpio_clk, 0);
-  // release data line
-  mraa_gpio_write(dev->gpio_data, 1);
-}
-
-float sht1x_get_temperature(const sht1x_context dev)
-{
-  assert(dev != NULL);
-
-  return dev->temperature;
-}
-
-float sht1x_get_humidity(const sht1x_context dev)
-{
-  assert(dev != NULL);
-
-  return dev->humidity;
-}
-
-void sht1x_reset(const sht1x_context dev)
-{
-  assert(dev != NULL);
-
-  sht1x_send_command(dev, SHT1X_CMD_SOFT_RESET);
-  upm_delay_ms(20);
-}
-
-upm_result_t sht1x_read_status(const sht1x_context dev, uint8_t *status)
-{
-  assert(dev != NULL);
-
-  upm_result_t rv;
-
-  if ((rv = sht1x_send_command(dev, SHT1X_CMD_READ_STATUS)))
-    {
-      printf("%s: send_command() failed.\n", __FUNCTION__);
-      return rv;
-    }
-
-  sht1x_read_8bits(dev, status);
-  return UPM_SUCCESS;
-}
-
-upm_result_t sht1x_write_status(const sht1x_context dev, uint8_t status)
-{
-  assert(dev != NULL);
-
-  upm_result_t rv;
-
-  if ((rv = sht1x_send_command(dev, SHT1X_CMD_WRITE_STATUS)))
-    {
-      printf("%s: send_command() failed.\n", __FUNCTION__);
-      return rv;
-    }
-
-  return sht1x_write_8bits(dev, status);
-}
-
-void sht1x_set_volts(const sht1x_context dev, SHT1X_VOLTS_T volts)
-{
-  assert(dev != NULL);
-
-  switch (volts)
-    {
-    case SHT1X_VOLTS_5:   dev->coeff_d1 = -40.1; break;
-    case SHT1X_VOLTS_4:   dev->coeff_d1 = -39.8; break;
-    case SHT1X_VOLTS_3_5: dev->coeff_d1 = -39.7; break;
-    case SHT1X_VOLTS_3:   dev->coeff_d1 = -39.6; break;
-    case SHT1X_VOLTS_2_5: dev->coeff_d1 = -39.4; break;
-    }
-}
diff --git a/src/sht1x/sht1x.cxx b/src/sht1x/sht1x.cxx
deleted file mode 100644
index 733e884..0000000
--- a/src/sht1x/sht1x.cxx
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <stdexcept>
-
-#include "sht1x.hpp"
-
-using namespace upm;
-using namespace std;
-
-SHT1X::SHT1X(unsigned int clk_pin, unsigned int data_pin) :
-  m_sht1x(sht1x_init(clk_pin, data_pin))
-{
-  if (!m_sht1x)
-    throw std::runtime_error(string(__FUNCTION__)
-                             + ": sht1x_init() failed");
-}
-
-SHT1X::~SHT1X()
-{
-  sht1x_close(m_sht1x);
-}
-
-void SHT1X::reset()
-{
-  sht1x_reset(m_sht1x);
-}
-
-void SHT1X::update()
-{
-  if (sht1x_update(m_sht1x))
-    throw std::runtime_error(string(__FUNCTION__)
-                             + ": sht1x_update() failed");
-}
-
-float SHT1X::getTemperature()
-{
-  return sht1x_get_temperature(m_sht1x);
-}
-
-float SHT1X::getHumidity()
-{
-  return sht1x_get_humidity(m_sht1x);
-}
-
-uint8_t SHT1X::readStatus()
-{
-  uint8_t status;
-
-  if (sht1x_read_status(m_sht1x, &status))
-    throw std::runtime_error(string(__FUNCTION__)
-                             + ": sht1x_read_status() failed");
-
-  return status;
-}
-
-upm_result_t SHT1X::writeStatus(uint8_t status)
-{
-  return sht1x_write_status(m_sht1x, status);
-}
-
-void SHT1X::setVolts(SHT1X_VOLTS_T volts)
-{
-  sht1x_set_volts(m_sht1x, volts);
-}
-
-upm_result_t SHT1X::sendCommand(SHT1X_CMD_T cmd)
-{
-  return sht1x_send_command(m_sht1x, cmd);
-}
-
-upm_result_t SHT1X::waitForResponse()
-{
-  return sht1x_wait_for_response(m_sht1x);
-}
-
-void SHT1X::startXmit()
-{
-  sht1x_start_xmit(m_sht1x);
-}
-
-uint8_t SHT1X::read8Bits()
-{
-  uint8_t value;
-
-  sht1x_read_8bits(m_sht1x, &value);
-
-  return value;
-}
-
-upm_result_t SHT1X::write8Bits(uint8_t byte)
-{
-  return sht1x_write_8bits(m_sht1x, byte);
-}
diff --git a/src/sht1x/sht1x.h b/src/sht1x/sht1x.h
deleted file mode 100644
index cce4c2f..0000000
--- a/src/sht1x/sht1x.h
+++ /dev/null
@@ -1,207 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <stdint.h>
-#include "upm.h"
-#include "mraa/gpio.h"
-
-#include "sht1x_defs.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-  /**
-   * @file sht1x.h
-   * @library sht1x
-   * @brief C API for SHT1X Temperature and Humidity Sensors
-   *
-   * @include sht1x.c
-   */
-
-  /**
-   * Device context
-   */
-  typedef struct _sht1x_context {
-    mraa_gpio_context        gpio_clk;
-    mraa_gpio_context        gpio_data;
-
-    // high res? (temp/hum 14/12b vs. 12/8b)
-    bool                     hires;
-
-    // our data
-    float                    temperature;
-    float                    humidity;
-
-    // temperature coeff (we only care about C)
-    float                    coeff_d1;
-    float                    coeff_d2;
-
-    // humidity coeff
-    float                    coeff_c1;
-    float                    coeff_c2;
-    float                    coeff_c3;
-
-    float                    coeff_t1;
-    float                    coeff_t2;
-  } *sht1x_context;
-
-  /**
-   * SHT1X Initializer
-   *
-   * @param clk_pin Specify the GPIO pin to use for the clock.
-   * @param data_pin Specify the GPIO pin to use for data.
-   * @return an initialized device context on success, NULL on error.
-   */
-  sht1x_context sht1x_init(unsigned int clk_pin, unsigned int data_pin);
-
-  /**
-   * SHT1X sensor close function
-   */
-  void sht1x_close(sht1x_context dev);
-
-  /**
-   * Perform a soft reset of the device.
-   *
-   * @param dev sensor context
-   * @return UPM result
-   */
-  void sht1x_reset(const sht1x_context dev);
-
-  /**
-   * Query the device and store the latest values.  You must call this
-   * function before querying the temperature or the humidity.
-   *
-   * @param dev sensor context
-   * @return UPM result
-   */
-  upm_result_t sht1x_update(const sht1x_context dev);
-
-  /**
-   * Query the temperature in degrees Celsius.  sht1x_update() must
-   * have been called prior to calling this function.
-   *
-   * @param dev sensor context
-   * @return The temperature in Celsius
-   */
-  float sht1x_get_temperature(const sht1x_context dev);
-
-  /**
-   * Query the relative humidity.  sht1x_update() must have been
-   * called prior to calling this function.
-   *
-   * @param dev sensor context
-   * @return The relative humidity.
-   */
-  float sht1x_get_humidity(const sht1x_context dev);
-
-  /**
-   * Read the status register.
-   *
-   * @param dev sensor context
-   * @param status The pointer to a uint8_t the status register will
-   * be stored in.
-   * @return UPM result
-   */
-  upm_result_t sht1x_read_status(const sht1x_context dev, uint8_t *status);
-
-  /**
-   * Write a value to the status register.
-   *
-   * @param dev sensor context
-   * @param status The uint8_t to write to the register.
-   * @return UPM result
-   */
-  upm_result_t sht1x_write_status(const sht1x_context dev, uint8_t status);
-
-  /**
-   * The Vdd voltage the sensor is being driven at can affect the
-   * temperature measurements.  This function allows you to specify a
-   * voltage as close as you are using to power the sensor, so that
-   * the appropriate compensation can be made.  By default, the
-   * coefficients are set for 5v operation.
-   *
-   * @param dev sensor context
-   * @param volts One of the SHT1X_VOLTS_T values.
-   */
-  void sht1x_set_volts(const sht1x_context dev, SHT1X_VOLTS_T volts);
-
-  /**
-   * Send a command to the device.  This is a low level command that
-   * should not be used directly unless you know exactly what you are
-   * doing.
-   *
-   * @param dev sensor context
-   * @param cmd One of the SHT1X_CMD_T values.
-   * @return UPM result
-   */
-  upm_result_t sht1x_send_command(const sht1x_context dev, SHT1X_CMD_T cmd);
-
-  /**
-   * Wait for the appropriate response when starting a temperature or
-   * humidity measurement.  This is a low level command that should
-   * not be used directly unless you know exactly what you are doing.
-   *
-   * @param dev sensor context
-   * @return UPM result
-   */
-  upm_result_t sht1x_wait_for_response(const sht1x_context dev);
-
-  /**
-   * Issue the start transmission sequence.  This is a low level
-   * command that should not be used directly unless you know exactly
-   * what you are doing.
-   *
-   * @param dev sensor context
-   * @return UPM result
-   */
-  void sht1x_start_xmit(const sht1x_context dev);
-
-  /**
-   * Read 8 bits (a byte) from the device.  This is a low level
-   * command that should not be used directly unless you know exactly
-   * what you are doing.
-   *
-   * @param dev sensor context
-   * @param value Pointer to a uint8_t that will hold the received byte.
-   * @return UPM result
-   */
-  void sht1x_read_8bits(const sht1x_context dev, uint8_t *value);
-
-  /**
-   * Write 8 bits (a byte) to the device.  This is a low level command
-   * that should not be used directly unless you know exactly what you
-   * are doing.
-   *
-   * @param dev sensor context
-   * @param value A uint8_t that will be sent to the device.
-   * @return UPM result
-   */
-  upm_result_t sht1x_write_8bits(const sht1x_context dev, uint8_t byte);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/sht1x/sht1x.hpp b/src/sht1x/sht1x.hpp
deleted file mode 100644
index 441febe..0000000
--- a/src/sht1x/sht1x.hpp
+++ /dev/null
@@ -1,187 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <iostream>
-
-#include <stdlib.h>
-#include <unistd.h>
-
-#include "sht1x.h"
-
-namespace upm {
-  /**
-   * @brief SHT1X Temperature and Humidity Sensors
-   * @defgroup sht1x libupm-sht1x
-   * @ingroup gpio temp
-   */
-
-  /**
-   * @library sht1x
-   * @sensor sht1x
-   * @comname Temperature and Humidity Sensor
-   * @type temp
-   * @man dfrobot
-   * @web https://www.dfrobot.com/wiki/index.php/SHT1x_Humidity_and_Temperature_Sensor_(SKU:_DFR0066)
-   * @con gpio
-   *
-   * @brief SHT1X Temperature and Humidity Sensor
-   *
-   * This driver was tested with a DFRobot SHT10 Temperature and
-   * Humidity sensor.  This driver should work on all SHT1X devices.
-   *
-   * It requires a 10K pull-up resistor connected to the data pin.
-   * The sensor can be run at differing voltages from 2.5v to 5v.
-   *
-   * @snippet sht1x.cxx Interesting
-   */
-
-  class SHT1X {
-  public:
-
-    /**
-     * SHT1X object constructor
-     *
-     * @param clk_pin Specify the GPIO pin to use for the clock.
-     * @param data_pin Specify the GPIO pin to use for data.
-     */
-    SHT1X(unsigned int clk_pin, unsigned int data_pin);
-
-    /**
-     * SHT1X object destructor
-     */
-    ~SHT1X();
-
-    /**
-     * Perform a soft reset of the device.
-     */
-    void reset();
-
-    /**
-     * Query the device and store the latest values.  You must call this
-     * function before querying the temperature or the humidity.
-     */
-    void update();
-
-    /**
-     * Query the temperature in degrees Celsius.  update() must have
-     * been called prior to calling this function.
-     *
-     * @return The temperature in Celsius
-     */
-    float getTemperature();
-
-    /**
-     * Query the relative humidity.  update() must have been called
-     * prior to calling this function.
-     *
-     * @return The relative humidity.
-     */
-    float getHumidity();
-
-    /**
-     * Read the status register.
-     *
-     * @return The contents of the status register.
-     */
-    uint8_t readStatus();
-
-    /**
-     * Write a value to the status register.
-     *
-     * @param status The uint8_t to write to the register.
-     * @return UPM result
-     */
-    upm_result_t writeStatus(uint8_t status);
-
-    /**
-     * The Vdd voltage the sensor is being driven at can affect the
-     * temperature measurements.  This function allows you to specify a
-     * voltage as close as you are using to power the sensor, so that
-     * the appropriate compensation can be made.  By default, the
-     * coefficients are set for 5v operation.
-     *
-     * @param volts One of the SHT1X_VOLTS_T values.
-     */
-    void setVolts(SHT1X_VOLTS_T volts);
-
-  protected:
-    // device context
-    sht1x_context m_sht1x;
-
-    /**
-     * Send a command to the device.  This is a low level command that
-     * should not be used directly unless you know exactly what you are
-     * doing.
-     *
-     * @param cmd One of the SHT1X_CMD_T values.
-     * @return UPM result
-     */
-    upm_result_t sendCommand(SHT1X_CMD_T cmd);
-
-    /**
-     * Wait for the appropriate response when starting a temperature or
-     * humidity measurement.  This is a low level command that should
-     * not be used directly unless you know exactly what you are doing.
-     *
-     * @return UPM result
-     */
-    upm_result_t waitForResponse();
-
-    /**
-     * Issue the start transmission sequence.  This is a low level
-     * command that should not be used directly unless you know exactly
-     * what you are doing.
-     *
-     * @return UPM result
-     */
-    void startXmit();
-
-    /**
-     * Read 8 bits (a byte) from the device.  This is a low level
-     * command that should not be used directly unless you know exactly
-     * what you are doing.
-     *
-     * @param value Pointer to a uint8_t that will hold the received byte.
-     * @return UPM result
-     */
-    uint8_t read8Bits();
-
-    /**
-     * Write 8 bits (a byte) to the device.  This is a low level command
-     * that should not be used directly unless you know exactly what you
-     * are doing.
-     *
-     * @param value A uint8_t that will be sent to the device.
-     * @return UPM result
-     */
-    upm_result_t write8Bits(uint8_t byte);
-
-  private:
-    /* Disable implicit copy and assignment operators */
-    SHT1X(const SHT1X&) = delete;
-    SHT1X &operator=(const SHT1X&) = delete;
-  };
-}
diff --git a/src/sht1x/sht1x.i b/src/sht1x/sht1x.i
deleted file mode 100644
index 3dee709..0000000
--- a/src/sht1x/sht1x.i
+++ /dev/null
@@ -1,16 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_sht1x)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "sht1x_defs.h"
-#include "sht1x.hpp"
-%}
-%include "sht1x_defs.h"
-%include "sht1x.hpp"
-/* END Common SWIG syntax */
diff --git a/src/sht1x/sht1x.json b/src/sht1x/sht1x.json
deleted file mode 100644
index 9d24f80..0000000
--- a/src/sht1x/sht1x.json
+++ /dev/null
@@ -1,81 +0,0 @@
-{
-    "Library": "sht1x",
-    "Description": "DFRobot SHT1X Temperature and Humidity Sensor Library",
-    "Sensor Class": {
-        "SHT1X": {
-            "Name": "API for the DFRobot SHT1X Temperature and Humidity Sensor",
-            "Description": "This is the UPM Module for the DFRobot SHT1X Temperature and Humidity Sensor. SHT1x is individually calibrated in a precision humidity chamber. The calibration coefficients are programmed into an OTP memory on the chip. These coefficients are used to internally calibrate the signals from the sensors. The 2-wire serial interface and internal voltage regulation allows for easy and fast system integration. The tiny size and low power consumption makes SHT1x the ultimate choice for even the most demanding applications.",
-            "Aliases": ["sht1x", "SHT1x Humidity and Temperature Sensor (SKU: DFR0066)"],
-            "Categories": ["temperature", "humidity"],
-            "Connections": ["gpio"],
-            "Project Type": ["prototyping", "industrial", "commercial"],
-            "Manufacturers": ["DFRobot", "Sensirion"],
-            "Examples": {
-                "Java": ["SHT1X_Example.java"],
-                "Python": ["sht1x.py"],
-                "Node.js": ["sht1x.js"],
-                "C++": ["sht1x.cxx"],
-                "C": ["sht1x.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 2.4,
-                    "max": 5.5
-                },
-                "Supply Current Digital": {
-                    "unit": "mA",
-                    "typ" : 0.9
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Humidity Sensor": {
-                    "Measurement Range": {
-                        "unit": "%RH",
-                        "min" : 0,
-                        "max" : 100
-                    },
-                    "Accuracy": {
-                        "unit": "%RH",
-                        "min" : -2,
-                        "max" : 2
-                    }
-                },
-                "Temperature Sensor": {
-                    "Measurement Range": {
-                        "unit": "Â°C",
-                        "min" : -40,
-                        "max" : 123.8
-                    },
-                    "Accuracy": {
-                        "unit": "Â°C",
-                        "min" : -0.3,
-                        "max" : 0.3
-                    }
-                },
-                "Response Time": {
-                    "unit": "second",
-                    "typ" : "< 4"
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need pull up resistors"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.dfrobot.com/wiki/index.php/SHT1x_Humidity_and_Temperature_Sensor_(SKU:_DFR0066)"],
-                "Datasheets": ["https://www.sparkfun.com/datasheets/Sensors/SHT1x_datasheet.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/sht1x/sht1x_defs.h b/src/sht1x/sht1x_defs.h
deleted file mode 100644
index f5a8e18..0000000
--- a/src/sht1x/sht1x_defs.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-  // SHT1X commands.  The first 3 msb's are the address, which are
-  // always 0.  The following 5 bits are the actual command.
-  typedef enum {
-    SHT1X_CMD_MEAS_TEMPERATURE            = 0x03,
-    SHT1X_CMD_MEAS_HUMIDITY               = 0x05,
-    SHT1X_CMD_WRITE_STATUS                = 0x06,
-    SHT1X_CMD_READ_STATUS                 = 0x07,
-    SHT1X_CMD_SOFT_RESET                  = 0x1e
-  } SHT1X_CMD_T;
-
-  // status register bits
-  typedef enum {
-    SHT1X_STATUS_RESOLUTION_LOW           = 0x01, // 0=12b RH/14b temp (dflt)
-    SHT1X_STATUS_NO_RELOAD_FROM_OTP       = 0x02,
-    SHT1X_STATUS_HEATER_EN                = 0x04,
-
-    // 0x08-0x20 reserved
-
-    SHT1X_STATUS_LOW_VOLT                 = 0x40 // low battery
-
-    // 0x80 reserved
-  } SHT1X_STATUS_BITS_T;
-
-  // The Vdd voltage can affect the temperature coefficients, so we
-  // provide a way to indicate the closest voltage and set up the
-  // compensation accordingly.
-  typedef enum {
-    SHT1X_VOLTS_5                         = 0, // 5 volts
-    SHT1X_VOLTS_4                         = 1,
-    SHT1X_VOLTS_3_5                       = 2, // 3.5v
-    SHT1X_VOLTS_3                         = 3,
-    SHT1X_VOLTS_2_5                       = 4
-  } SHT1X_VOLTS_T;
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/sht1x/sht1x_fti.c b/src/sht1x/sht1x_fti.c
deleted file mode 100644
index c60aba3..0000000
--- a/src/sht1x/sht1x_fti.c
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "sht1x.h"
-#include "upm_fti.h"
-
-/**
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_sht1x_name[] = "SHT1X";
-const char upm_sht1x_description[] = "SHT1X Temperature and Humidity Sensor";
-const upm_protocol_t upm_sht1x_protocol[] = {UPM_GPIO, UPM_GPIO};
-const upm_sensor_t upm_sht1x_category[] = {UPM_TEMPERATURE, UPM_HUMIDITY};
-
-// forward declarations
-const void* upm_sht1x_get_ft(upm_sensor_t sensor_type);
-void* upm_sht1x_init_name();
-void upm_sht1x_close(void *dev);
-upm_result_t upm_sht1x_get_humidity(void *dev, float *value);
-upm_result_t upm_sht1x_get_temperature(void *dev, float *value,
-                                       upm_temperature_u unit);
-
-static const upm_sensor_ft ft =
-{
-  .upm_sensor_init_name = upm_sht1x_init_name,
-  .upm_sensor_close = upm_sht1x_close,
-};
-
-static const upm_temperature_ft tft =
-{
-  .upm_temperature_get_value = upm_sht1x_get_temperature,
-};
-
-static const upm_humidity_ft hft =
-{
-  .upm_humidity_get_value = upm_sht1x_get_humidity,
-};
-
-const void* upm_sht1x_get_ft(upm_sensor_t sensor_type)
-{
-  switch(sensor_type)
-    {
-    case UPM_SENSOR:
-      return &ft;
-    case UPM_HUMIDITY:
-      return &hft;
-    case UPM_TEMPERATURE:
-      return &tft;
-    default:
-      return NULL;
-    }
-}
-
-void* upm_sht1x_init_name()
-{
-  return NULL;
-}
-
-void upm_sht1x_close(void *dev)
-{
-  sht1x_close((sht1x_context)dev);
-}
-
-upm_result_t upm_sht1x_get_humidity(void *dev, float *value)
-{
-  upm_result_t rv;
-
-  if ((rv = sht1x_update((sht1x_context)dev)))
-    return rv;
-
-  *value = sht1x_get_humidity((sht1x_context)dev);
-
-  return UPM_SUCCESS;
-}
-
-upm_result_t upm_sht1x_get_temperature(void *dev, float *value,
-                                       upm_temperature_u unit)
-{
-  upm_result_t rv;
-
-  if ((rv = sht1x_update((sht1x_context)dev)))
-    return rv;
-
-  // always in C
-  float temp = sht1x_get_temperature((sht1x_context)dev);
-
-  switch (unit)
-    {
-    case CELSIUS:
-      *value = temp;
-      return UPM_SUCCESS;
-
-    case KELVIN:
-      *value = temp + 273.15;
-      return UPM_SUCCESS;
-
-    case FAHRENHEIT:
-      *value = temp * (9.0/5.0) + 32.0;
-      return UPM_SUCCESS;
-    }
-
-  return UPM_SUCCESS;
-}
diff --git a/src/si1132/CMakeLists.txt b/src/si1132/CMakeLists.txt
deleted file mode 100644
index bada7ce..0000000
--- a/src/si1132/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "si1132")
-set (libdescription "UV and Ambient Light Sensor")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa interfaces)
diff --git a/src/si1132/si1132.cxx b/src/si1132/si1132.cxx
deleted file mode 100644
index 541d39d..0000000
--- a/src/si1132/si1132.cxx
+++ /dev/null
@@ -1,223 +0,0 @@
-/*
- * Author: Scott Ware <scott.r.ware@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <unistd.h>
-#include <stdlib.h>
-#include <math.h>
-#include <errno.h>
-
-#include "si1132.hpp"
-
-
-#define SI1132_ADDRESS                  0x60
-
-/* REGISTER ADDRESSES */
-#define SI1132_REG_PART_ID              0x00
-#define SI1132_REG_INT_CFG              0x03
-#define SI1132_REG_IRQ_ENABLE           0x04
-#define SI1132_REG_HW_KEY               0x07
-#define SI1132_REG_MEAS_RATE0           0x08
-#define SI1132_REG_MEAS_RATE1           0x09
-#define SI1132_REG_PARAM_WR             0x17
-#define SI1132_REG_COMMAND              0x18
-#define SI1132_REG_RESPONSE             0x20
-#define SI1132_REG_ALS_VIS_DATA0        0x22
-#define SI1132_REG_ALS_VIS_DATA1        0x23
-#define SI1132_REG_PARAM_RD             0x2E
-#define SI1132_REG_CHIP_STAT            0x30
-
-/* REGISTER VALUES */
-#define SI1132_PART_ID                  0x32
-#define SI1132_HW_KEY_INIT              0x17
-
- /* COMMAND VALUES */
-#define SI1132_COMMAND_RESET            0x01
-#define SI1132_COMMAND_ALS_FORCE        0x06
-#define SI1132_COMMAND_PARAM_QUERY      0x80
-#define SI1132_COMMAND_PARAM_SET        0xA0
-#define SI1132_COMMAND_ALS_AUTO         0x0E
-
-/* PARAMETER RAM ADDRESSES */
-#define SI1132_PARAM_CHLIST             0x01
-#define SI1132_PARAM_ALS_VIS_ADC_COUNT  0x10
-#define SI1132_PARAM_ALS_VIS_ADC_GAIN   0x11
-#define SI1132_PARAM_ALS_VIS_ADC_MISC   0x12
-
-/* PARAMETER RAM VALUES */
-#define SI1132_PARAM_CHLIST_ENALSVIS    0x10
-#define SI1132_PARAM_ALS_VIS_RANGE_STD  0x00
-#define SI1132_PARAM_ALS_VIS_RANGE_HI   0x20
-
-
-
-using namespace upm;
-
-SI1132::SI1132 (int bus) {
-    i2c = new mraa::I2c(bus);
-    i2c->address(SI1132_ADDRESS);
-
-    // Reset chip to defaults
-    status = reset();
-    if (status != mraa::SUCCESS)
-        UPM_THROW("config failure");
-}
-
-SI1132::~SI1132() {
-   delete i2c;
-}
-
-mraa::Result SI1132::reset() {
-    // Check version
-    uint8_t regValue = i2c->readReg(SI1132_REG_PART_ID);
-    if (regValue != SI1132_PART_ID)  {
-        fprintf(stderr, "SI1132: Read ID failed. Data = %02x\n", regValue);
-        status = mraa::ERROR_UNSPECIFIED;
-        return status;
-    }
-
-    // disable automatic updates
-    uint16_t rate = 0;
-    status = i2c->writeWordReg(SI1132_REG_MEAS_RATE0, rate);
-    if (status != mraa::SUCCESS)  {
-        fprintf(stderr, "SI1132_REG_MEAS_RATE0 failed\n");
-        return status;
-    }
-
-    // reset device
-    status = i2c->writeReg(SI1132_REG_COMMAND, SI1132_COMMAND_RESET);
-    if (status != mraa::SUCCESS) {
-        fprintf(stderr, "SI1132: Reset failed.\n");
-        status = mraa::ERROR_UNSPECIFIED;
-        return status;
-    }
-    sleepMs(30);
-
-    // start state machine
-    i2c->writeReg(SI1132_REG_HW_KEY, SI1132_HW_KEY_INIT);
-    regValue = i2c->readReg(SI1132_REG_HW_KEY);
-    if (regValue != SI1132_HW_KEY_INIT) {
-        fprintf(stderr, "Si1132: Did not start\n");
-        status = mraa::ERROR_UNSPECIFIED;
-        return status;
-    }
-
-    status = writeParam(SI1132_PARAM_CHLIST, SI1132_PARAM_CHLIST_ENALSVIS);
-
-    // set visible light range for indoor lighting
-    status = writeParam(SI1132_PARAM_ALS_VIS_ADC_MISC, SI1132_PARAM_ALS_VIS_RANGE_STD);
-
-    // set visible light gain to 8
-    status = writeParam(SI1132_PARAM_ALS_VIS_ADC_GAIN, 3);
-    status = writeParam(SI1132_PARAM_ALS_VIS_ADC_COUNT, 3 << 4);
-    return status;
-}
-
-
-uint16_t SI1132::getVisibleRaw() {
-    status = runCommand(SI1132_COMMAND_ALS_FORCE);
-    if (status != mraa::SUCCESS)
-       UPM_THROW("command failed");
-    return i2c->readWordReg(SI1132_REG_ALS_VIS_DATA0);
-}
-
-
-double SI1132::getVisibleLux() {
-    uint16_t rawValue = getVisibleRaw();
-    if (rawValue < 256)
-        rawValue = 0;
-    else
-        rawValue -= 256;
-    return static_cast<double>(rawValue);
-}
-
-
-mraa::Result SI1132::clearResponseRegister()
-{
-    uint8_t regValue = 0xFF;
-    status = i2c->writeReg(SI1132_REG_COMMAND, 0);
-    if (status != mraa::SUCCESS)
-        return status;
-    int bytesRead = i2c->readBytesReg(SI1132_REG_RESPONSE, &regValue, 1);
-    if (bytesRead == 1 && regValue == 0)
-       status = mraa::SUCCESS;
-    else
-        status = mraa::ERROR_UNSPECIFIED;
-    return status;
-}
-
-mraa::Result SI1132::runCommand(uint8_t command)
-{
-    uint8_t response = 0;
-    int sleepTimeMs = 5;
-    int timeoutMs = 50;
-    int waitTimeMs = 0;
-    status = clearResponseRegister();
-    if (status != mraa::SUCCESS)
-        return status;
-    status = i2c->writeReg(SI1132_REG_COMMAND, command);
-    if (status != mraa::SUCCESS)
-        return status;
-    while (response == 0 && waitTimeMs < timeoutMs) {
-        response = i2c->readReg(SI1132_REG_RESPONSE);
-        sleepMs(sleepTimeMs);
-        waitTimeMs += sleepTimeMs;
-    }
-    if (response == 0) {
-        status = mraa::ERROR_UNSPECIFIED;
-        fprintf(stderr, "Command %d failed\n", command);
-    }
-    return status;
-}
-
-mraa::Result SI1132::writeParam(uint8_t param, uint8_t value)
-{
-    status = i2c->writeReg(SI1132_REG_PARAM_WR, value);
-    if (status != mraa::SUCCESS)
-        return status;
-    return runCommand(SI1132_COMMAND_PARAM_SET | param);
-}
-
-mraa::Result SI1132::readParam(uint8_t param, uint8_t* value)
-{
-    status = runCommand(SI1132_COMMAND_PARAM_QUERY | param);
-    if (status != mraa::SUCCESS)
-        return status;
-    if (i2c->readBytesReg(SI1132_REG_PARAM_RD, value, 1) != 1)
-        status = mraa::ERROR_UNSPECIFIED;
-    return status;
-}
-
-
-void SI1132::sleepMs(int mseconds)
-{
-    struct timespec sleepTime;
-
-    sleepTime.tv_sec = mseconds / 1000; // Number of seconds
-    sleepTime.tv_nsec = ( mseconds % 1000 ) * 1000000; // Convert fractional seconds to nanoseconds
-
-    // Iterate nanosleep in a loop until the total sleep time is the original
-    // value of the seconds parameter
-    while ( ( nanosleep( &sleepTime, &sleepTime ) != 0 ) && ( errno == EINTR ) );
-}
diff --git a/src/si1132/si1132.hpp b/src/si1132/si1132.hpp
deleted file mode 100644
index 29524de..0000000
--- a/src/si1132/si1132.hpp
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Author: Henry Bruce <henry.bruce@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include "mraa/i2c.hpp"
-#include "interfaces/iLightSensor.hpp"
-
-
-namespace upm {
-
-/**
- * @brief SI1132 UV and Visible Light Sensor
- * @defgroup Si1132 libupm-Si1132
- * @ingroup silabs i2c light ilightsensor
- */
-
-/**
- * @library si1132
- * @sensor si1132
- * @comname UV and Ambient Light Sensor
- * @altname Si1132
- * @type light
- * @man silabs
- * @con i2c
- * @web http://www.silabs.com/products/sensors/infraredsensors/Pages/si1132.aspx
- * @web https://www.silabs.com/Support%20Documents/TechnicalDocs/Si1132.pdf
- *
- * @brief API for Si1132 UV and Visible Light Sensor
- *
- * The Silicon Labs
- * [Si1132](https://www.silabs.com/Support%20Documents/TechnicalDocs/Si1132.pdf)
- * is a low-power, ultraviolet (UV) index, and ambient light sensor with I2C
- * digital interface and programmable-event interrupt output.
- *
- * @snippet si1132.cxx Interesting
- */
-class SI1132 : public ILightSensor {
-    public:
-        /**
-         * Instanciates a Si1132 object
-         *
-         * @param bus number of used bus
-         */
-        SI1132 (int bus);
-
-        /**
-         * Si1132 object destructor, basicaly it close i2c connection.
-         */
-        ~SI1132 ();
-
-        /**
-         * Read the raw visible light value
-         */
-        uint16_t getVisibleRaw();
-
-        /**
-         * Read the lux value
-         */
-        double getVisibleLux();
-
-        virtual const char* getModuleName() { return "si1132"; }
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        SI1132(const SI1132&) = delete;
-        SI1132 &operator=(const SI1132&) = delete;
-
-        mraa::Result reset();
-        mraa::Result clearResponseRegister();
-        mraa::Result runCommand(uint8_t command);
-        mraa::Result readParam(uint8_t param, uint8_t* value);
-        mraa::Result writeParam(uint8_t param, uint8_t value);
-        void sleepMs(int mseconds);
-
-        mraa::I2c* i2c;
-        mraa::Result status;
-};
-
-}
diff --git a/src/si1132/si1132.i b/src/si1132/si1132.i
deleted file mode 100644
index 94f0d4b..0000000
--- a/src/si1132/si1132.i
+++ /dev/null
@@ -1,21 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-#ifndef ANDROID
-    %module(directors="1") javaupm_si1132
-#endif
-
-%typemap(javaimports) SWIGTYPE %{import upm_interfaces.*;%}
-%import "../interfaces/javaupm_iLightSensor.i"
-
-JAVA_JNI_LOADLIBRARY(javaupm_si1132)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "si1132.hpp"
-%}
-%include "si1132.hpp"
-/* END Common SWIG syntax */
diff --git a/src/si1132/si1132.json b/src/si1132/si1132.json
deleted file mode 100644
index 4d45478..0000000
--- a/src/si1132/si1132.json
+++ /dev/null
@@ -1,50 +0,0 @@
-{
-    "Library": "si1132",
-    "Description": "Silicon Labs Si1132 UV and visible light sensor library",
-    "Sensor Class": {
-        "SI1132": {
-            "Name": "API for the Silicon Labs Si1132 UV and Visible Light Sensor",
-            "Description": "This is the UPM Module for the Silicon Labs Si1132 UV and Visible Light Sensor. The Silicon Labs Si1132 is a low-power, ultraviolet (UV) index, and ambient light sensor with I2C digital interface and programmable-event interrupt output.",
-            "Aliases": ["si1132"],
-            "Categories": ["light"],
-            "Connections": ["i2c"],
-            "Project Type": ["industrial", "commercial"],
-            "Manufacturers": ["Silicon Labs"],
-            "Examples": {
-                "C++": ["si1132.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 1.71,
-                    "max": 3.6
-                },
-                "Supply Current": {
-                    "Standby Mode": {
-                        "unit": "uA",
-                        "min": "0.15",
-                        "max": "1.4"
-                    },
-                    "Actively Measuring": {
-                        "unit": "mA",
-                        "min": "4.3",
-                        "max": "5.5"
-                    }
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Measurement Time": {
-                    "unit": "us",
-                    "typ": 285
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.silabs.com/products/sensors/optical/si1132"],
-                "Datasheets": ["https://www.silabs.com/documents/public/data-sheets/Si1132.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/si114x/CMakeLists.txt b/src/si114x/CMakeLists.txt
deleted file mode 100644
index 8153cf8..0000000
--- a/src/si114x/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "si114x")
-set (libdescription "UV/IR/visible Light Sensor")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/si114x/si114x.cxx b/src/si114x/si114x.cxx
deleted file mode 100644
index 7d75445..0000000
--- a/src/si114x/si114x.cxx
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Thanks to Adafruit for some important clues
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <math.h>
-#include <iostream>
-#include <stdexcept>
-#include <string>
-
-#include "si114x.hpp"
-
-using namespace upm;
-using namespace std;
-
-
-SI114X::SI114X(int bus, uint8_t address)
-{
-  m_addr = address;
-  m_uvIndex = 0;
-
-  // setup our i2c link
-  if ( !(m_i2c = mraa_i2c_init(bus)) )
-    {
-      throw std::invalid_argument(std::string(__FUNCTION__) +
-                                  ": mraa_i2c_init() failed");
-      return;
-    }
-      
-  mraa_result_t rv;
-  
-  if ( (rv = mraa_i2c_address(m_i2c, m_addr)) != MRAA_SUCCESS)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": mraa_i2c_address() failed");
-      return;
-    }
-
-  // The data sheet recommends setting the UV calibration values to
-  // 0x7b, 0x6b, 0x01, and 0x00, however the adafruit code uses a
-  // different set of values, presumably calibrated to their specific
-  // implementation.  We will use those defaults here, as this was
-  // developed on an adafruit device.  
-
-  // Use setUVCalibration() to set a different set of values before
-  // calling init() if you need different values.
-
-  setUVCalibration(0x29, 0x89, 0x02, 0x00);
-}
-
-SI114X::~SI114X()
-{
-  mraa_i2c_stop(m_i2c);
-}
-
-bool SI114X::writeByte(uint8_t reg, uint8_t byte)
-{
-  mraa_result_t rv = mraa_i2c_write_byte_data(m_i2c, byte, reg);
-
-  if (rv != MRAA_SUCCESS)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": mraa_i2c_write_byte() failed");
-      return false;
-    }
-
-  return true;
-}
-
-uint8_t SI114X::readByte(uint8_t reg)
-{
-  int x = mraa_i2c_read_byte_data(m_i2c, reg);
-  if (x != -1) {
-    return (uint8_t) x;
-  }
-  return 0;
-}
-
-uint16_t SI114X::readWord(uint8_t reg)
-{
-  int x = mraa_i2c_read_word_data(m_i2c, reg);
-  if (x != -1) {
-    return (uint16_t) x;
-  }
-  return 0;
-}
-
-void SI114X::setUVCalibration(uint8_t uvcoeff0, uint8_t uvcoeff1, 
-                              uint8_t uvcoeff2, uint8_t uvcoeff3)
-{
-  m_uv_cal[0] = uvcoeff0;
-  m_uv_cal[1] = uvcoeff1;
-  m_uv_cal[2] = uvcoeff2;
-  m_uv_cal[3] = uvcoeff3; 
-};
-
-
-void SI114X::writeParam(SI114X_PARAM_T param, uint8_t value)
-{
-  // write a parameter to the RAM parameter area
-
-  // We write the value to the PARAM_WR register, then execute a
-  // PARAM_WRITE command
-
-  writeByte(REG_PARAM_WR, value);
-
-  // now write it to parameter memory
-  writeByte(REG_COMMAND, CMD_PARAM_SET | param);
-}
-
-uint8_t SI114X::readParam(SI114X_PARAM_T param)
-{
-  // get the parameter into register REG_PARAM_READ, then read and return it.
-
-  writeByte(REG_COMMAND, CMD_PARAM_QUERY | param);
-  return readByte(REG_PARAM_READ);
-}
-
-void SI114X::reset()
-{
-  // reset the device 
-
-  // zero out measuring rate
-  writeByte(REG_MEAS_RATE0, 0);
-  writeByte(REG_MEAS_RATE1, 0);
-
-  // disable IRQ MODES
-  // these are undocumented in the datasheet, but mentioned in Adafruit's code
-  writeByte(REG_IRQ_MODE1, 0);
-  writeByte(REG_IRQ_MODE2, 0);
-  
-  // turn off interrupts
-  writeByte(REG_INT_CFG, 0);
-  writeByte(REG_IRQ_STATUS, 0xff);
-
-  // send a reset
-  writeByte(REG_COMMAND, CMD_RESET);
-  usleep(100);
-
-  // set the hardware key
-  writeByte(REG_HW_KEY, SI114X_HW_KEY);
-  usleep(100);
-}
-
-void SI114X::initialize()
-{
-  // initialize the device
-
-  // first, reset it
-  reset();
-
-  // UV coefficients
-  writeByte(REG_UCOEF0, m_uv_cal[0]);
-  writeByte(REG_UCOEF1, m_uv_cal[1]);
-  writeByte(REG_UCOEF2, m_uv_cal[2]);
-  writeByte(REG_UCOEF3, m_uv_cal[3]);
-  
-  // enable UV sensor only for now
-  writeParam(PARAM_CHLIST, CHLIST_EN_UV);
-
-  // auto-measure speed - slowest - (rate * 31.25us)
-  writeByte(REG_MEAS_RATE0, 0xff); // 7.9ms
-
-  // set autorun
-  writeByte(REG_COMMAND, CMD_ALS_AUTO);
-}
-
-void SI114X::update()
-{
-  // for now, just update the UV Index member variable
-  uint16_t uvi = readWord(REG_AUX_UVINDEX0);
-
-  m_uvIndex = float(uvi) / 100.0;
-
-  // Add any further data gets() here
-
-  return;
-}
diff --git a/src/si114x/si114x.hpp b/src/si114x/si114x.hpp
deleted file mode 100644
index 146b098..0000000
--- a/src/si114x/si114x.hpp
+++ /dev/null
@@ -1,323 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Thanks to Adafruit for some important clues
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/i2c.h>
-#include <mraa/gpio.h>
-
-#define SI114X_I2C_BUS 0
-#define SI114X_DEFAULT_I2C_ADDR 0x60
-#define SI114X_HW_KEY 0x17
-
-
-namespace upm {
-  
-  /**
-   * @brief SI1145 UV Light Sensor
-   * @defgroup si114x libupm-si114x
-   * @ingroup adafruit i2c light
-   */
-
-  /**
-   * @library si114x
-   * @sensor si114x
-   * @comname UV/IR/visible Light Sensor
-   * @altname SI1146, SI1147
-   * @type light
-   * @man adafruit
-   * @web https://www.adafruit.com/products/1777
-   * @con i2c
-   *
-   * @brief API for the SI1145 UV Light Sensor
-   *
-   * This module was tested with the Adafruit* UV Light Sensor
-   *
-   * This device is capable of measuring IR and visible ambient
-   * light as well. It also supports the ability to use externally
-   * attached LEDs to perform proximity detection on 3 separate
-   * channels.
-   *
-   * Currently, this class only supports the retrieving of the
-   * calculated UV index measured by the device, but enough
-   * infrastructure is provided to make it easy to enhance this driver
-   * in the future to support additional capabilities, including
-   * interrupt support.
-   *
-   * @image html si114x.jpg
-   * @snippet si114x.cxx Interesting
-   */
-  class SI114X {
-  public:
-
-    /**
-     * SI114X registers
-     */
-    typedef enum { REG_PART_ID       = 0x00,
-                   REG_REV_ID        = 0x01,
-                   REG_SEQ_ID        = 0x02,
-                   REG_INT_CFG       = 0x03,
-                   REG_IRQ_ENABLE    = 0x04,
-
-                   // these two are not documented in the datasheet,
-                   // but are mentioned there, as well as in the
-                   // Adafruit example
-                   REG_IRQ_MODE1     = 0x05,
-                   REG_IRQ_MODE2     = 0x06,
-
-                   REG_HW_KEY        = 0x07,
-                   REG_MEAS_RATE0    = 0x08,
-                   REG_MEAS_RATE1    = 0x09,
-
-                   REG_PS_LED21      = 0x0f,
-                   REG_PS_LED3       = 0x10,
-
-                   REG_UCOEF0        = 0x13,
-                   REG_UCOEF1        = 0x14,
-                   REG_UCOEF2        = 0x15,
-                   REG_UCOEF3        = 0x16,
-                   REG_PARAM_WR      = 0x17,
-                   REG_COMMAND       = 0x18,
-
-                   REG_RESPONSE      = 0x20,
-                   REG_IRQ_STATUS    = 0x21,
-                   REG_ALS_VIS_DATA0 = 0x22,
-                   REG_ALS_VIS_DATA1 = 0x23,
-                   REG_ALS_IR_DATA0  = 0x24,
-                   REG_ALS_IR_DATA1  = 0x25,
-                   REG_PS1_DATA0     = 0x26,
-                   REG_PS1_DATA1     = 0x27,
-                   REG_PS2_DATA0     = 0x28,
-                   REG_PS2_DATA1     = 0x29,
-                   REG_PS3_DATA0     = 0x2a,
-                   REG_PS3_DATA1     = 0x2b,
-                   REG_AUX_UVINDEX0  = 0x2c,
-                   REG_AUX_UVINDEX1  = 0x2d,
-                   REG_PARAM_READ    = 0x2e,
-
-                   REG_CHIP_STAT     = 0x30,
-
-                   REG_ANA_IN_KEY0   = 0x3b,
-                   REG_ANA_IN_KEY1   = 0x3c,
-                   REG_ANA_IN_KEY2   = 0x3d,
-                   REG_ANA_IN_KEY3   = 0x3e
-    } SI114X_REG_T;
-    
-    /**
-     * Parameter memory (PARAM)
-     */
-    typedef enum { PARAM_I2C_ADDDR         = 0x00,
-                   PARAM_CHLIST            = 0x01,
-                   PARAM_PSLED12_SEL       = 0x02,
-                   PARAM_PSLED3_SEL        = 0x03,
-
-                   PARAM_PS_ENCODING       = 0x05,
-                   PARAM_ALS_ENCODING      = 0x06,
-                   PARAM_PS1_ADCMUX        = 0x07,
-                   PARAM_PS2_ADCMUX        = 0x08,
-                   PARAM_PS3_ADCMUX        = 0x09,
-                   PARAM_PS_ADC_COUNT      = 0x0a,
-                   PARAM_PS_ADC_GAIN       = 0x0b,
-                   PARAM_PS_ADC_MISC       = 0x0c,
-
-                   PARAM_ALS_IR_ADCMUX     = 0x0e,
-                   PARAM_AUX_ADCMUX        = 0x0f,
-                   PARAM_ALS_VIS_ADC_COUNT = 0x10,
-                   PARAM_ALS_VIS_ADC_GAIN  = 0x11,
-                   PARAM_ALS_VIS_ADC_MISC  = 0x12,
-
-                   PARAM_LED_REC           = 0x1c,
-                   PARAM_ALS_IR_ADC_COUNT  = 0x1d,
-                   PARAM_ALS_IR_ADX_GAIN   = 0x1e,
-                   PARAM_ALS_IR_ADC_MISC   = 0x1f
-    } SI114X_PARAM_T;
-    
-    /**
-     * Commands (written to the REG_COMMAND register)
-     */
-    typedef enum { CMD_NOOP          = 0x00, // clear RESPONSE reg
-                   CMD_RESET         = 0x01,
-                   CMD_BUSADDR       = 0x02,
-
-                   CMD_PS_FORCE      = 0x05,
-                   CMD_GET_CAL       = 0x12,
-                   CMD_ALS_FORCE     = 0x06,
-                   CMD_PSALS_FORCE   = 0x07,
-
-                   CMD_PS_PAUSE      = 0x09,
-                   CMD_ALS_PAUSE     = 0x0a,
-                   CMD_PSALS_PAUSE   = 0x0b,
-
-                   CMD_PS_AUTO       = 0x0d,
-                   CMD_ALS_AUTO      = 0x0e,
-                   CMD_PSALS_AUTO    = 0x0f,
-
-                   CMD_PARAM_QUERY   = 0x80, // OR'd with PARAM_T value
-                   CMD_PARAM_SET     = 0xa0  // OR'd with PARAM_T value
-    } SI114X_CMD_T;
-
-
-    /**
-     * Channel list enable bits
-     */
-    typedef enum { CHLIST_EN_PS1     = 0x01, // proximity sense 1-3
-                   CHLIST_EN_PS2     = 0x02,
-                   CHLIST_EN_PS3     = 0x04,
-
-                   CHLIST_EN_ALS_VIS = 0x10, // ambient light sense
-                   CHLIST_EN_ALS_IR  = 0x20,
-                   CHLIST_EN_AUX     = 0x40, // AUX sense
-                   CHLIST_EN_UV      = 0x80  // UV sense
-    } SI114X_CHLIST_BITS_T;
-
-    /**
-     * Error codes from the RESPONSE register
-     */
-    typedef enum { ERR_NONE          = 0x00, // no error if high nibble is 0
-                                             // lower nibble is a counter
-                   ERR_INVALID_SET   = 0x80, // invalid setting
-                   ERR_PS1_ADC_OVER  = 0x88, // overflows
-                   ERR_PS2_ADC_OVER  = 0x89,
-                   ERR_PS3_ADC_OVER  = 0x8a,
-                   ERR_ALS_VIS_ADC_OVER  = 0x8c,
-                   ERR_ALS_IR_ADC_OVER   = 0x8d,
-                   ERR_AUX_ADC_OVER  = 0x8e
-    } SI114X_ERR_T;
-    
-
-    /**
-     * Interrupt enable bits
-     */
-    typedef enum { IRQEN_ALS_IE      = 0x01,
-                   IRQEN_PS1_IE      = 0x04,
-                   IRQEN_PS2_IE      = 0x08,
-                   IRQEN_PS3_IE      = 0x10
-    } SI114X_IRQEN_BITS_T;
-
-    /**
-     * SI114X constructor
-     *
-     * @param bus I2C bus to use
-     * @param address Address for this device
-     */
-    SI114X(int bus, uint8_t address = SI114X_DEFAULT_I2C_ADDR);
-
-    /**
-     * SI114X destructor
-     */
-    ~SI114X();
-
-    /**
-     * Writes a byte value into a register
-     *
-     * @param reg Register location to write into
-     * @param byte Byte to write
-     * @return True if successful
-     */
-    bool writeByte(uint8_t reg, uint8_t byte);
-
-    /**
-     * Reads a byte value from a register
-     *
-     * @param reg Register location to read from
-     * @return Value in a specified register
-     */
-    uint8_t readByte(uint8_t reg);
-
-    /**
-     * Reads a word value from a register
-     *
-     * @param reg Register location to read from
-     * @return Value in a specified register
-     */
-    uint16_t readWord(uint8_t reg);
-
-    /**
-     * Disables interrupts and auto-measuring, issues a device reset,
-     * and then sets the hardware key.
-     */
-    void reset();
-
-    /**
-     * Sets UV calibration values. The constructor sets default
-     * values for you, so you only need this function if you need
-     * different values for your device and situation. If you set new
-     * values here, be sure to do so before calling initialize().
-     *
-     * @param uvcoeff0 Coefficient for REG_UCOEF0
-     * @param uvcoeff1 Coefficient for REG_UCOEF1
-     * @param uvcoeff2 Coefficient for REG_UCOEF2
-     * @param uvcoeff3 Coefficient for REG_UCOEF3
-     *
-     */
-    void setUVCalibration(uint8_t uvcoeff0, uint8_t uvcoeff1, uint8_t uvcoeff2,
-                          uint8_t uvcoeff3);
-
-    /**
-     * Writes a value to the parameter memory.
-     *
-     * @param param SI114X_PARAM_T register to write
-     * @param value Value to write
-     */
-    void writeParam(SI114X_PARAM_T param, uint8_t value);
-    
-    /**
-     * Reads a value from the parameter memory
-     *
-     * @param param SI114X_PARAM_T register to read
-     * @return Value
-     */
-    uint8_t readParam(SI114X_PARAM_T param);
-
-    /**
-     * Resets and initializes the device and starts auto-sampling
-     */
-    void initialize();
-
-    /**
-     * Updates stored values. You should call this before calling
-     * getUVIndex()
-     */
-    void update();
-
-    /**
-     * Reads the currently measured UV index value
-     *
-     * @return UV index value
-     */
-    float getUVIndex() { return m_uvIndex; };
-
-  private:
-    mraa_i2c_context m_i2c;
-    uint8_t m_addr;
-    // UV calibration values
-    uint8_t m_uv_cal[4];
-    // updated by update()
-    float m_uvIndex;
-  };
-}
-
-
diff --git a/src/si114x/si114x.i b/src/si114x/si114x.i
deleted file mode 100644
index b6015ef..0000000
--- a/src/si114x/si114x.i
+++ /dev/null
@@ -1,14 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_si114x)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "si114x.hpp"
-%}
-%include "si114x.hpp"
-/* END Common SWIG syntax */
diff --git a/src/si114x/si114x.json b/src/si114x/si114x.json
deleted file mode 100644
index 9ef4940..0000000
--- a/src/si114x/si114x.json
+++ /dev/null
@@ -1,69 +0,0 @@
-{
-    "Library": "si114x",
-    "Description": "Silicon Labs SI1145 UV Light Sensor library",
-    "Sensor Class": {
-        "SI114x": {
-            "Name": "API for the Silicon Labs SI1145 UV Light Sensor",
-            "Description": "This is the UPM Module for the Silicon Labs SI1145 UV Light Sensor. This device is capable of measuring IR and visible ambient light as well. It also supports the ability to use externally attached LEDs to perform proximity detection on 3 separate channels. Currently, this class only supports the retrieving of the calculated UV index measured by the device, but enough infrastructure is provided to make it easy to enhance this driver in the future to support additional capabilities, including interrupt support.",
-            "Aliases": ["si114x", "SI1145 Digital UV Index / IR / Visible Light Sensor"],
-            "Categories": ["light"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping", "industrial", "commercial"],
-            "Manufacturers": ["Adafruit", "Silicon Labs"],
-            "Image": "si114x.jpg",
-            "Examples": {
-                "Python": ["si114x.py"],
-                "Node.js": ["si114x.js"],
-                "C++": ["si114x.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.0,
-                    "max": 5.0
-                },
-                "Supply Current": {
-                    "Standby Mode": {
-                        "unit": "uA",
-                        "min": "0.15",
-                        "max": "1.4"
-                    },
-                    "Actively Measuring": {
-                        "unit": "mA",
-                        "min": "4.3",
-                        "max": "5.5"
-                    }
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Start-up Time": {
-                    "unit": "ms",
-                    "time": 25
-                },
-                "Measurement Time": {
-                    "unit": "us",
-                    "min" : 155,
-                    "max" : 660
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": []
-                },
-                "Intel Edison": {
-                    "Notes": []
-                },
-                "Arduino 101": {
-                    "Notes": []
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.adafruit.com/product/1777"],
-                "Datasheets": ["https://cdn-shop.adafruit.com/datasheets/Si1145-46-47.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/si7005/CMakeLists.txt b/src/si7005/CMakeLists.txt
deleted file mode 100644
index 770c6d4..0000000
--- a/src/si7005/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "si7005")
-set (libdescription "Digital I2C Humidity and Temperature Sensor")
-set (module_src ${libname}.cxx mraa-utils.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa interfaces)
diff --git a/src/si7005/mraa-utils.cxx b/src/si7005/mraa-utils.cxx
deleted file mode 100644
index 4d23510..0000000
--- a/src/si7005/mraa-utils.cxx
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Author: Henry Bruce <henry.bruce@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string>
-
-#include "mraa-utils.hpp"
-#include "mraa/gpio.hpp"
-
- #define UPM_THROW(msg) throw std::runtime_error(std::string(__FUNCTION__) + ": " + (msg))
-
-void MraaUtils::setGpio(int pin, int level)
-{
-/*
-   mraa_result_t status = MRAA_ERROR_NO_RESOURCES; 
-   mraa_gpio_context gpio = mraa_gpio_init(pin);
-   if (gpio != NULL) 
-   {
-      mraa_gpio_dir(gpio, MRAA_GPIO_OUT);
-      status = mraa_gpio_write(gpio, level);
-      mraa_gpio_close(gpio);
-   } 
-   return status;
-*/
-   mraa::Gpio gpio(pin);
-   gpio.dir(mraa::DIR_OUT);
-   if (gpio.write(level) != mraa::SUCCESS)
-      UPM_THROW("gpio write failed");
-}
-
-
-int MraaUtils::getGpio(int pin)
-{
-/*
-   mraa_result_t status = MRAA_ERROR_NO_RESOURCES; 
-   mraa_gpio_context gpio = mraa_gpio_init(pin);
-   if (gpio != NULL) 
-   {
-      status = mraa_gpio_dir(gpio, MRAA_GPIO_IN);
-      int value = mraa_gpio_read(gpio);
-      if (value != -1)
-         *level = value;
-      else
-         status = MRAA_ERROR_NO_RESOURCES; 
-      mraa_gpio_close(gpio);
-   }
-   return status;       
-*/
-   mraa::Gpio gpio(pin);
-   gpio.dir(mraa::DIR_IN);
-   return gpio.read();
-}
-
-
diff --git a/src/si7005/mraa-utils.hpp b/src/si7005/mraa-utils.hpp
deleted file mode 100644
index f9e6acc..0000000
--- a/src/si7005/mraa-utils.hpp
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Author: Henry Bruce <henry.bruce@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include "mraa/types.h"
-
-class __attribute__ ((visibility("hidden"))) MraaUtils
-{
-public:
-   static void setGpio(int pin, int level);
-   static int getGpio(int pin);
-};
-
-
-
diff --git a/src/si7005/si7005.cxx b/src/si7005/si7005.cxx
deleted file mode 100644
index 7f6765b..0000000
--- a/src/si7005/si7005.cxx
+++ /dev/null
@@ -1,201 +0,0 @@
-/*
- * Author: Scott Ware <scott.r.ware@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <unistd.h>
-#include <stdlib.h>
-#include <math.h>
-
-#include "mraa-utils.hpp"
-#include "si7005.hpp"
-
-/* REGISTER ADDRESSES */
-#define SI7005_REG_STATUS                  ( 0x00 )
-#define SI7005_REG_DATA_LENGTH             ( 2 )
-#define SI7005_REG_DATA_START              ( 0x01 )
-#define SI7005_REG_DATA_HIGH               ( 0 )
-#define SI7005_REG_DATA_LOW                ( 1 )
-#define SI7005_REG_CONFIG                  ( 0x03 )
-#define SI7005_REG_ID                      ( 0x11 )
-
-/* STATUS REGISTER */
-#define SI7005_STATUS_NOT_READY            ( 0x01 )
-
-/* CONFIG REGISTER */
-#define SI7005_CONFIG_START                ( 0x01 )
-#define SI7005_CONFIG_HEAT                 ( 0x02 )
-#define SI7005_CONFIG_HUMIDITY             ( 0x00 )
-#define SI7005_CONFIG_TEMPERATURE          ( 0x10 )
-#define SI7005_CONFIG_FAST                 ( 0x20 )
-#define SI7005_CONFIG_RESET                ( 0x00 )
-
-/* ID REGISTER */
-#define SI7005_ID                          ( 0x50 )
-
-/* COEFFICIENTS */
-#define SI7005_TEMPERATURE_OFFSET          ( 50 )
-#define SI7005_TEMPERATURE_SLOPE           ( 32 )
-#define SI7005_HUMIDITY_OFFSET             ( 24 )
-#define SI7005_HUMIDITY_SLOPE              ( 16 )
-#define A0                                 ( -4.7844 )
-#define A1                                 ( 0.4008 )
-#define A2                                 ( -0.00393 )
-#define Q0                                 ( 0.1973 )
-#define Q1                                 ( 0.00237 )
-
-/* MISCELLANEOUS */
-#define SI7005_WAKE_UP_TIME                ( 15000 )
-
-using namespace upm;
-
-SI7005::SI7005 (int bus, int pin) {
-
-    m_controlAddr = SI7005_ADDRESS;
-    m_bus = bus;
-    m_pin = pin;
-    last_temperature = 25.0;
-    config_reg = SI7005_CONFIG_RESET;
-
-    // Disable chip until we need to do something with it
-    MraaUtils::setGpio(m_pin, 1);
-    m_i2c = new mraa::I2c(m_bus);
-    status = m_i2c->address(m_controlAddr);
-    if (!isAvailable())
-        UPM_THROW("config failure");
-}
-
-SI7005::~SI7005() {
-    delete m_i2c;
-}
-
-uint16_t
-SI7005::getTemperatureRaw () {
-    return getMeasurement( SI7005_CONFIG_TEMPERATURE );
-}
-
-int
-SI7005::getTemperatureCelsius () {
-    uint16_t rawTemperature = getTemperatureRaw();
-    rawTemperature = ((rawTemperature >> 2) & 0xFFFF);
-    last_temperature = ((float)rawTemperature) / SI7005_TEMPERATURE_SLOPE - SI7005_TEMPERATURE_OFFSET;
-    return static_cast<int>(last_temperature + 0.5);
-}
-
-uint16_t
-SI7005::getHumidityRaw () {
-    return getMeasurement( SI7005_CONFIG_HUMIDITY );
-}
-
-int
-SI7005::getHumidityRelative () {
-    uint16_t rawHumidity = getHumidityRaw();
-    rawHumidity = ((rawHumidity >> 4) & 0xFFFF);
-    float linearHumidity = ((float)rawHumidity) / SI7005_HUMIDITY_SLOPE - SI7005_HUMIDITY_OFFSET;
-    linearHumidity -= A2 * linearHumidity * linearHumidity + A1 * linearHumidity + A0;
-    linearHumidity += ( last_temperature - 30 ) * ( Q1 * linearHumidity + Q0 );
-    return static_cast<int>(linearHumidity + 0.5);
-}
-
-
-uint16_t SI7005::getMeasurement(uint8_t configValue) {
-
-    uint16_t rawData;
-    uint8_t data[SI7005_REG_DATA_LENGTH];
-    uint8_t measurementStatus;
-
-    // Enable the sensor
-    MraaUtils::setGpio(m_pin, 0);
-
-    // Wait for sensor to wake up
-    usleep(SI7005_WAKE_UP_TIME);
-
-    // Setup config register
-    status = m_i2c->writeReg(SI7005_REG_CONFIG, SI7005_CONFIG_START | configValue | config_reg);
-
-    // FIXME: readReg() returns 0 on failure which is same as "reading ready" status
-    // FIXME: no timeout if device never gets to "reading ready" status
-    // Wait for the measurement to finish
-    measurementStatus = SI7005_STATUS_NOT_READY;
-    while ( measurementStatus == SI7005_STATUS_NOT_READY ) {
-        measurementStatus = m_i2c->readReg(SI7005_REG_STATUS);
-    }
-
-    // Read data registers
-    int length = m_i2c->readBytesReg(SI7005_REG_DATA_START, data, SI7005_REG_DATA_LENGTH);
-
-    // Disable the sensor
-    MraaUtils::setGpio(m_pin, 1);
-
-    // Check we got the data we need
-    if(length != SI7005_REG_DATA_LENGTH)
-        UPM_THROW("read error");
-
-    // Merge MSB and LSB
-    rawData  = ((uint16_t)( data[SI7005_REG_DATA_LOW] & 0xFFFF )) + ( (uint16_t)(( data[SI7005_REG_DATA_HIGH] & 0xFFFF ) << 8 ));
-
-    return rawData;
-}
-
-
-bool
-SI7005::isAvailable( )
-{
-    // Enable the sensor
-    MraaUtils::setGpio(m_pin, 0);
-
-    // Wait for sensor to wake up
-    usleep(SI7005_WAKE_UP_TIME);
-
-    // Read id register
-    uint8_t  deviceID = m_i2c->readReg(SI7005_REG_ID);
-
-    // Disable the sensor
-    MraaUtils::setGpio(m_pin, 1);
-
-    return (( deviceID & SI7005_ID) == SI7005_ID );
-}
-
-void
-SI7005::enableHeater( )
-{
-    config_reg |= SI7005_CONFIG_HEAT;
-}
-
-void
-SI7005::disableHeater( )
-{
-    config_reg ^= SI7005_CONFIG_HEAT;
-}
-
-void
-SI7005::enableFastConversionMode( )
-{
-    config_reg |= SI7005_CONFIG_FAST;
-}
-
-void
-SI7005::disableFastConversionMode( )
-{
-    config_reg ^= SI7005_CONFIG_FAST;
-}
diff --git a/src/si7005/si7005.hpp b/src/si7005/si7005.hpp
deleted file mode 100644
index a121f72..0000000
--- a/src/si7005/si7005.hpp
+++ /dev/null
@@ -1,143 +0,0 @@
-/*
- * Author: Scott Ware <scott.r.ware@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <mraa/i2c.hpp>
-
-#include "interfaces/iTemperatureSensor.hpp"
-#include "interfaces/iHumiditySensor.hpp"
-
-/* ADDRESS AND NOT_FOUND VALUE */
-#define SI7005_ADDRESS                     ( 0x40 )
-#define SI7005_NOT_FOUND                   ( 0x00 )
-
-namespace upm {
-
-/**
- * @brief SI7005 Digital Humidity and Temperature Sensor
- * @defgroup si7005 libupm-si7005
- * @ingroup i2c silabs temp itemperaturesensor
- */
-
-/**
- * @library si7005
- * @sensor si7005
- * @comname Digital I2C Humidity and Temperature Sensor
- * @altname Si7005
- * @type temp
- * @man silabs
- * @web http://www.silabs.com/products/sensors/humidity-sensors/Pages/Si7005.aspx
- * @con i2c
- * @if itemperaturesensor
- *
- * @brief C++ API for SI7005 sensor (Humidity And Temperature Sensor)
- *
- * The Silicon Labs Si7005
- * [SI7005](https://www.silabs.com/Support%20Documents/TechnicalDocs/Si7005.pdf)
- * is a digital relative humidity and temperature sensor.
- *
- * @snippet si7005.cxx Interesting
- */
-class SI7005 : public ITemperatureSensor, public IHumiditySensor {
-    public:
-        /**
-         * Instantiates a SI7005 object
-         *
-         * @param bus number of used bus
-         * @param pin gpio number for chip select pin
-         */
-        SI7005 (int bus, int pin);
-
-        /**
-         * SI7005 object destructor.
-         */
-        ~SI7005 ();
-
-        /**
-         * Get temperature measurement.
-         */
-        uint16_t getTemperatureRaw ();
-
-        /**
-         * Get temperature measurement.
-         */
-        int getTemperatureCelsius ();
-
-        /**
-         * Get relative humidity measurement.
-         */
-        uint16_t getHumidityRaw ();
-
-        /**
-         * Get relative humidity measurement.
-         */
-        int getHumidityRelative ();
-
-        /**
-         * Returns sensor module name
-         */
-        virtual const char* getModuleName() { return "si7005"; }
-
-        /**
-         * Detects the sensor to ensure it is connected as required.
-         */
-        bool isAvailable();
-
-        /**
-         * Enables the integrated heating element.
-         */
-        void enableHeater();
-
-        /**
-         * Disables the integrated heating element.
-         */
-        void disableHeater();
-
-        /**
-         * Enables fast conversion mode.
-         */
-        void enableFastConversionMode();
-
-        /**
-         * Enables fast conversion mode.
-         */
-        void disableFastConversionMode();
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        SI7005(const SI7005&) = delete;
-        SI7005 &operator=(const SI7005&) = delete;
-
-        int m_controlAddr;
-        int m_bus;
-        int m_pin;
-        mraa::I2c* m_i2c;
-        mraa::Result status;
-        uint8_t config_reg;
-        float last_temperature;
-
-        uint16_t getMeasurement(uint8_t configValue);
-};
-
-}
diff --git a/src/si7005/si7005.i b/src/si7005/si7005.i
deleted file mode 100644
index cf15e11..0000000
--- a/src/si7005/si7005.i
+++ /dev/null
@@ -1,21 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "arrays_java.i";
-%include "../java_buffer.i"
-%typemap(javaimports) SWIGTYPE %{import upm_interfaces.*;%}
-
-%import "../interfaces/javaupm_iTemperatureSensor.i"
-%import "../interfaces/javaupm_iHumiditySensor.i"
-
-JAVA_JNI_LOADLIBRARY(javaupm_si7005)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "si7005.hpp"
-%}
-%include "si7005.hpp"
-/* END Common SWIG syntax */
diff --git a/src/si7005/si7005.json b/src/si7005/si7005.json
deleted file mode 100644
index 2de97ba..0000000
--- a/src/si7005/si7005.json
+++ /dev/null
@@ -1,54 +0,0 @@
-{
-    "Library": "si7005",
-    "Description": "Silicon Labs SI7005 digital I2C humidity and temperature sensor library",
-    "Sensor Class": {
-        "SI7005": {
-            "Name": "API for the Silicon Labs SI7005 digital I2C humidity and temperature sensor",
-            "Description": "This is the UPM Module for the Silicon Labs SI7005 digital I2C humidity and temperature sensor. The Si7005 sensor integrates humidity and temperature sensor elements and offers an analog-to-digital converter and signal processing in a single monolithic CMOS sensor IC. Both the humidity and temperature sensors are factory-calibrated and the data is stored in on-chip non-volatile memory.",
-            "Aliases": ["si7005"],
-            "Categories": ["humidity", "temperature"],
-            "Connections": ["i2c"],
-            "Project Type": ["industrial", "commercial"],
-            "Manufacturers": ["Silicon Labs"],
-            "Examples": {
-                "C++": ["si7005.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 2.1,
-                    "max": 3.6
-                },
-                "Supply Current Digital": {
-                    "unit": "uA",
-                    "min" : 1,
-                    "max" : 565
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Conversion Time": {
-                    "unit": "ms",
-                    "min" : 18,
-                    "max" : 40
-                },
-                "Wake-up Time": {
-                    "unit": "ms",
-                    "min" : 10,
-                    "max" : 15
-                },
-                "Power-up Time": {
-                    "unit": "ms",
-                    "min" : 10,
-                    "max" : 15
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.silabs.com/products/sensors/humidity/si7005"],
-                "Datasheets": ["https://www.silabs.com/documents/public/data-sheets/Si7005.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/slide/CMakeLists.txt b/src/slide/CMakeLists.txt
deleted file mode 100644
index 1e814b9..0000000
--- a/src/slide/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-upm_mixed_module_init (NAME slide
-    DESCRIPTION "Slide Potentiometer"
-    C_HDR slide.h
-    C_SRC slide.c
-    CPP_HDR slide.hpp
-    CPP_SRC slide.cxx
-    FTI_SRC slide_fti.c
-    REQUIRES mraa)
diff --git a/src/slide/slide.c b/src/slide/slide.c
deleted file mode 100644
index 332acd5..0000000
--- a/src/slide/slide.c
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- * Author: Noel Eck <noel.eck@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string.h>
-#include <stdlib.h>
-
-#include "slide.h"
-
-slide_context slide_init(int16_t pin)
-{
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        return NULL;
-    }
-
-    slide_context dev = (slide_context) malloc(sizeof(struct _slide_context));
-
-    if (dev == NULL)
-      return NULL;
-
-    /* Init aio pin */
-    dev->aio = mraa_aio_init(pin);
-
-    if (dev->aio == NULL) {
-        free(dev);
-        return NULL;
-    }
-
-    /* Set the ADC ref, scale, and offset defaults */
-    dev->m_aRef = 5.0;
-    dev->m_scale = 1.0;
-    dev->m_offset = 0.0;
-
-    return dev;
-}
-
-void slide_close(slide_context dev)
-{
-    mraa_aio_close(dev->aio);
-    free(dev);
-}
-
-upm_result_t slide_set_aref(const slide_context dev, float aref)
-{
-    dev->m_aRef = aref;
-    return UPM_SUCCESS;
-}
-
-upm_result_t slide_set_scale(const slide_context dev, float scale)
-{
-    dev->m_scale = scale;
-    return UPM_SUCCESS;
-}
-
-upm_result_t slide_set_offset(const slide_context dev, float offset)
-{
-    dev->m_offset = offset;
-    return UPM_SUCCESS;
-}
-
-float slide_get_aref(const slide_context dev)
-{
-    return dev->m_aRef;
-}
-
-float slide_get_scale(const slide_context dev)
-{
-    return dev->m_scale;
-}
-
-float slide_get_offset(const slide_context dev)
-{
-    return dev->m_offset;
-}
-
-upm_result_t slide_get_normalized(const slide_context dev, float *value)
-{
-    *value = mraa_aio_read_float(dev->aio);
-    if (*value < 0)
-        return UPM_ERROR_OPERATION_FAILED;
-    return UPM_SUCCESS;
-}
-
-upm_result_t slide_get_raw_volts(const slide_context dev, float *value)
-{
-    *value = mraa_aio_read_float(dev->aio);
-    if (*value < 0)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    /* Scale by the ADC reference voltage */
-    *value *= dev->m_aRef;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t slide_get_volts(const slide_context dev, float *value)
-{
-    *value = mraa_aio_read_float(dev->aio);
-    if (*value < 0)
-        return UPM_ERROR_OPERATION_FAILED;
-
-     /* Apply raw scale */
-    *value *= dev->m_scale;
-
-     /* Scale to aRef */
-    *value *= dev->m_aRef;
-
-    /* Apply the offset in volts */
-    *value += dev->m_offset;
-
-    return UPM_SUCCESS;
-}
diff --git a/src/slide/slide.cxx b/src/slide/slide.cxx
deleted file mode 100644
index 4ca8d27..0000000
--- a/src/slide/slide.cxx
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Authors: Brendan Le Foll <brendan.le.foll@intel.com>
- *          Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- *          Sarah Knepper <sarah.knepper@intel.com>
- * Copyright (c) 2014 - 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "slide.hpp"
-#include "math.h"
-
-using namespace upm;
-
-Slide::Slide(unsigned int pin, float ref_voltage)
-{
-    if ( !(m_aio = mraa_aio_init(pin)) ) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_aio_init() failed, invalid pin?");
-        return;
-    }
-    m_ref_voltage = ref_voltage;
-}
-
-Slide::~Slide()
-{
-    mraa_aio_close(m_aio);
-}
-
-float Slide::raw_value()
-{
-    return (float) mraa_aio_read(m_aio);
-}
-
-float Slide::voltage_value()
-{
-    // conversion to Volts
-    float a = Slide::raw_value();
-    a = m_ref_voltage * a / 1023.0 ;
-    return a;
-}
-
-float Slide::ref_voltage()
-{
-    return m_ref_voltage;
-}
diff --git a/src/slide/slide.h b/src/slide/slide.h
deleted file mode 100644
index 63fb0fd..0000000
--- a/src/slide/slide.h
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
- * Author: Noel Eck <noel.eck@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include "upm.h"
-#include "mraa/aio.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @file slide.h
- * @library slide
- * @brief C API for the Slide Potentiometer
- *
- * @include slide.c
- */
-
-/**
- * driver context
- */
-typedef struct _slide_context {
-    /* mraa aio pin context */
-    mraa_aio_context aio;
-    /* Analog voltage reference */
-    float m_aRef;
-    /* Scale */
-    float m_scale;
-    /* Offset in sensor units */
-    float m_offset;
-} *slide_context;
-
-/**
- * Initialize analog sensor
- * @param pin Analog pin
- * @return sensor context
- */
-slide_context slide_init(int16_t pin);
-
-/**
- * Analog sensor destructor
- * @param sensor context pointer
- */
-void slide_close(slide_context dev);
-
-/**
- * Set ADC reference voltage
- * @param dev sensor context pointer
- * @param aref ADC reference voltage
- * @return Function result code
- */
-upm_result_t slide_set_aref(const slide_context dev, float aref);
-
-/**
- * Set sensor scale.  This scale is applied to the return value:
- *     counts = counts * scale
- * @param dev sensor context pointer
- * @param scale count scale value used
- * @return Function result code
- */
-upm_result_t slide_set_scale(const slide_context dev, float scale);
-
-/**
- * Set sensor offset.  This offset is applied to the return value:
- *     value = value + offset
- * @param dev sensor context pointer
- * @param offset count offset value used
- * @return Function result code
- */
-upm_result_t slide_set_offset(const slide_context dev, float offset);
-
-/**
- * Get sensor aref
- * @param dev sensor context pointer
- * @return Sensor ADC reference voltage
- */
-float slide_get_aref(const slide_context dev);
-
-/**
- * Get sensor scale
- * @param dev sensor context pointer
- * @return Sensor scale
- */
-float slide_get_scale(const slide_context dev);
-
-/**
- * Get sensor offset
- * @param dev sensor context pointer
- * @return Sensor offset
- */
-float slide_get_offset(const slide_context dev);
-
-/**
- * Read normalized value for sensor
- * @param dev sensor context pointer
- * @param *value Normalized value (0.0 -> 1.0)
- * @return Function result code
- */
-upm_result_t slide_get_normalized(const slide_context dev, float *value);
-
-/**
- * Read raw voltage from the sensor
- * @param dev sensor context pointer
- * @param *value Raw sensor voltage
- * @return Function result code
- */
-upm_result_t slide_get_raw_volts(const slide_context dev, float *value);
-
-/**
- * Read scaled/offset voltage from the sensor
- * @param dev sensor context pointer
- * @param *value Adjusted sensor voltage
- * @return Function result code
- */
-upm_result_t slide_get_volts(const slide_context dev, float *value);
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/slide/slide.hpp b/src/slide/slide.hpp
deleted file mode 100644
index 39ba6b6..0000000
--- a/src/slide/slide.hpp
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Authors: Brendan Le Foll <brendan.le.foll@intel.com>
- *          Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- *          Sarah Knepper <sarah.knepper@intel.com>
- * Copyright (c) 2014 - 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <string>
-#include <mraa/aio.hpp>
-
-namespace upm {
- /**
-  * @brief Slide Sensor Library
-  * @defgroup slide libupm-slide
-  * @ingroup seeed analog ainput
-  */
-
- /**
-  * @library slide
-  * @sensor slide
-  * @comname Slide Potentiometer
-  * @altname Grove Slide
-  * @type ainput
-  * @man seeed
-  * @web http://wiki.seeed.cc/Grove-Slide_Potentiometer/
-  * @con analog
-  *
-  * @brief API for the Slide Potentiometer
-  *
-  * Basic UPM module for the slide potentiometer on analog that
-  * returns either a raw value or a scaled voltage value.
-  *
-  * @image html slide.jpg
-  * @snippet slide.cxx Interesting
-  */
-class Slide {
-    public:
-        /**
-         * Analog slide potentiometer constructor
-         *
-         * @param pin Number of the analog pin to use
-         *
-         * @param ref_voltage Reference voltage the board is set to, as a floating-point value; default is 5.0V
-         */
-        Slide(unsigned int pin, float ref_voltage = 5.0);
-        /**
-         * Slide destructor
-         */
-        ~Slide();
-        /**
-         * Gets the raw value from the AIO pin
-         *
-         * @return Raw value from the ADC
-         */
-        float raw_value();
-        /**
-         * Gets the voltage value from the pin
-         *
-         * @return Voltage reading based on the reference voltage
-         */
-        float voltage_value();
-        /**
-         * Gets the board's reference voltage passed on object initialization
-         *
-         * @return Reference voltage the class was set for
-         */
-        float ref_voltage();
-
-        /* Gets the sensor name
-         *
-         * @return sensor name
-         */
-        std::string name() {return "Slide Potentiometer";}
-    private:
-        mraa_aio_context m_aio;
-        float m_ref_voltage;
-};
-}
diff --git a/src/slide/slide.json b/src/slide/slide.json
deleted file mode 100644
index f93deab..0000000
--- a/src/slide/slide.json
+++ /dev/null
@@ -1,63 +0,0 @@
-{
-    "Library": "slide",
-    "Description": "Seeed Slide Sensor library",
-    "Sensor Class": {
-        "Slide": {
-            "Name": "API for the Seeed Slide Potentiometer",
-            "Description": "This is the UPM Module for the Seeed Slide Potentiometer. Basic UPM module for the slide potentiometer on analog that returns either a raw value or a scaled voltage value.",
-            "Aliases": ["slide", "Grove - Slide Potentiometer"],
-            "Categories": ["ainput"],
-            "Connections": ["analog"],
-            "Project Type": ["prototyping", "robotics"],
-            "Manufacturers": ["Seeed"],
-            "Image": "slide.jpg",
-            "Examples": {
-                "Java" : ["Slide_Example.java"],
-                "Python": ["slide.py"],
-                "Node.js": ["slide.js"],
-                "C++": ["slide.cxx"],
-                "C": ["slide.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.3,
-                    "max": 30.0
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "max" : 30
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Operational Life": {
-                    "unit": "cycles",
-                    "typ" : ">15,000"
-                },
-                "Stroke Length": {
-                    "unit": "mm",
-                    "length": 30
-                },
-                "Total Resistance": {
-                    "unit": "Kohm",
-                    "resistance": 10
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-Slide-Potentiometer-p-1196.html", "http://wiki.seeed.cc/Grove-Slide_Potentiometer/"],
-                "Datasheets": ["https://raw.githubusercontent.com/SeeedDocument/Grove-Slide_Potentiometer/master/res/Sliding_potentiometer_datasheet.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/slide/slide_fti.c b/src/slide/slide_fti.c
deleted file mode 100644
index a8ef51d..0000000
--- a/src/slide/slide_fti.c
+++ /dev/null
@@ -1,119 +0,0 @@
-/*
- * Author: Noel Eck <noel.eck@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string.h>
-#include <stdlib.h>
-
-#include "slide.h"
-#include "upm_fti.h"
-#include "fti/upm_sensor.h"
-#include "fti/upm_raw.h"
-
-/** 
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_slide_name[] = "SLIDE";
-const char upm_slide_description[] = "Analog slide sensor";
-const upm_protocol_t upm_slide_protocol[] = {UPM_ANALOG};
-const upm_sensor_t upm_slide_category[] = {UPM_RAW};
-
-// forward declarations
-const void* upm_slide_get_ft(upm_sensor_t sensor_type);
-void* upm_slide_init_str(const char* protocol, const char* params);
-void upm_slide_close(void* dev);
-const upm_sensor_descriptor_t upm_slide_get_descriptor();
-upm_result_t upm_slide_set_offset(const void* dev, float offset);
-upm_result_t upm_slide_set_scale(const void* dev, float scale);
-upm_result_t upm_slide_get_value(const void* dev, float *value);
-
-/* This sensor implementes 2 function tables */
-/* 1. Generic base function table */
-static const upm_sensor_ft ft_gen =
-{
-    .upm_sensor_init_name = &upm_slide_init_str,
-    .upm_sensor_close = &upm_slide_close,
-    .upm_sensor_get_descriptor = &upm_slide_get_descriptor
-};
-
-/* 2. RAW function table */
-static const upm_raw_ft ft_raw =
-{
-    .upm_raw_set_offset = &upm_slide_set_offset,
-    .upm_raw_set_scale = &upm_slide_set_scale,
-    .upm_raw_get_value = &upm_slide_get_value
-};
-
-const void* upm_slide_get_ft(upm_sensor_t sensor_type)
-{
-    switch(sensor_type)
-    {
-        case UPM_SENSOR:
-            return &ft_gen;
-        case UPM_RAW:
-            return &ft_raw;
-        default:
-            return NULL;
-    }
-}
-
-void* upm_slide_init_str(const char* protocol, const char* params)
-{
-    fprintf(stderr, "String initialization - not implemented, using ain0: %s\n", __FILENAME__);
-    return slide_init(0);
-}
-
-void upm_slide_close(void* dev)
-{
-    slide_close((slide_context)dev);
-}
-
-const upm_sensor_descriptor_t upm_slide_get_descriptor()
-{
-    /* Fill in the descriptor */
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_slide_name;
-    usd.description = upm_slide_description;
-    usd.protocol_size = 1;
-    usd.protocol = upm_slide_protocol;
-    usd.category_size = 1;
-    usd.category = upm_slide_category;
-
-    return usd;
-}
-
-upm_result_t upm_slide_set_offset(const void* dev, float offset)
-{
-    return slide_set_offset((slide_context)dev, offset);
-}
-
-upm_result_t upm_slide_set_scale(const void* dev, float scale)
-{
-    return slide_set_scale((slide_context)dev, scale);
-}
-
-upm_result_t upm_slide_get_value(const void* dev, float *value)
-{
-    return slide_get_volts((slide_context)dev, value);
-}
diff --git a/src/sm130/CMakeLists.txt b/src/sm130/CMakeLists.txt
deleted file mode 100644
index c11b699..0000000
--- a/src/sm130/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "sm130")
-set (libdescription "RFID Reader")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/sm130/sm130.cxx b/src/sm130/sm130.cxx
deleted file mode 100644
index 34e9fa1..0000000
--- a/src/sm130/sm130.cxx
+++ /dev/null
@@ -1,878 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <stdexcept>
-
-#include "sm130.hpp"
-
-using namespace upm;
-using namespace std;
-
-// Uncomment the below to see packaet data sent and received from the SM130
-// #define SM130_DEBUG
-
-static const int defaultDelay = 1000; // ms for read
-
-static const int maxLen = 64; // max number of bytes to read
-
-SM130::SM130(int uart, int reset) :
-  m_uart(uart), m_gpioReset(reset)
-{
-  m_tagType = TAG_NONE;
-  m_uidLen = 0;
-  m_uid.clear();
-  clearError();
-  initClock();
-
-  m_gpioReset.dir(mraa::DIR_OUT);
-  m_gpioReset.write(0);
-}
-
-SM130::~SM130() 
-{
-}
-
-mraa::Result SM130::setBaudRate(int baud)
-{
-  m_baud = baud;
-  return m_uart.setBaudRate(baud);
-}
-
-string SM130::sendCommand(CMD_T cmd, string data)
-{
-  uint8_t cksum = 0;
-  string command;
-
-  // for uart, we need to add the sync bytes, 0xff, 0x00
-  command.push_back(0xff);
-  command.push_back(0x00);
-  
-  // compute the length - command + data
-  uint8_t len = 1; // command
-  if (!data.empty())
-    len += data.size();
-
-  command.push_back(len);
-
-  cksum += len;
-
-  // now the command
-  command.push_back(cmd);
-  cksum += cmd;
-
-  // now the data if any
-  if (!data.empty())
-    {
-      for (size_t i=0; i<data.size(); i++)
-        {
-          command.push_back(data[i]);
-          cksum += (uint8_t)data[i];
-        }
-    }
-
-  // now add the checksum
-  command.push_back(cksum);
-
-#ifdef SM130_DEBUG
-  cerr << "CMD: " << string2HexString(command) << endl;
-#endif // SM130_DEBUG
-
-  // send it
-  m_uart.writeStr(command);
-
-  // if the command is SET_BAUD, then switch to the new baudrate here
-  // before attempting to read the response (and hope it worked).
-  if (cmd == CMD_SET_BAUD)
-    {
-      usleep(100000); // 100ms
-      setBaudRate(m_baud);
-    }
-
-  // now wait for a response
-  if (!m_uart.dataAvailable(defaultDelay))
-    {
-      cerr << __FUNCTION__ << ": timeout waiting for response" << endl;
-      return "";
-    }
-
-  string resp = m_uart.readStr(maxLen);
-
-#ifdef SM130_DEBUG
-  cerr << "RSP: " << string2HexString(resp) << endl;
-#endif // SM130_DEBUG
-
-  if (!((uint8_t)resp[0] == 0xff && (uint8_t)resp[1] == 0x00))
-    {
-      cerr << __FUNCTION__ << ": invalid packet header" << endl;
-      return "";
-    }
-    
-  // check size - 2 header bytes + len + cksum.
-  if (resp.size() != static_cast<size_t>((uint8_t)resp[2] + 2 + 1 + 1))
-    {
-      cerr << __FUNCTION__ << ": invalid packet length, expected " 
-           << int((uint8_t)resp[2] + 2 + 1 + 1) 
-           << ", got " << resp.size() << endl;
-      return "";
-    }
-
-  // verify the cksum
-  cksum = 0;
-  for (size_t i=2; i<(resp.size() - 1); i++)
-    cksum += (uint8_t)resp[i];
-
-  if (cksum != (uint8_t)resp[resp.size() - 1])
-    {
-      cerr << __FUNCTION__ << ": invalid checksum, expected " 
-           << int(cksum) << ", got " << (uint8_t)resp[resp.size()-1] << endl;
-      return "";
-    }
-
-  // we could also verify that the command code returned was for the
-  // command submitted...
-
-  // now, remove the 2 header bytes and the checksum, leave the length
-  // and command.
-  resp.erase(resp.size() - 1, 1); // cksum
-  resp.erase(0, 2);               // header bytes
-
-  // return the rest
-  return resp;
-}
-
-string SM130::getFirmwareVersion()
-{
-  clearError();
-
-  string resp = sendCommand(CMD_VERSION, "");
-
-  if (resp.empty())
-    {
-      cerr << __FUNCTION__ << ": failed" << endl;
-      return "";
-    }
-
-  // delete the len and cmd, return the rest
-  resp.erase(0, 2);
-  return resp;
-}
-
-bool SM130::reset()
-{
-  clearError();
-
-  string resp = sendCommand(CMD_RESET, "");
-  if (resp.empty())
-    {
-      cerr << __FUNCTION__ << ": failed" << endl;
-      return false;
-    }
-
-  return true;
-}
-
-void SM130::hardwareReset()
-{
-  m_gpioReset.write(1);
-  usleep(100000);
-  m_gpioReset.write(0);
-}
-
-bool SM130::select()
-{
-  clearError();
-
-  m_tagType = TAG_NONE;
-  m_uidLen = 0;
-  m_uid.clear();
-
-  string resp = sendCommand(CMD_SELECT_TAG, "");
-
-  if (resp.empty())
-    {
-      cerr << __FUNCTION__ << ": failed" << endl;
-      return false;
-    }
-
-  if ((uint8_t)resp[0] == 2)
-    {
-      // then we got an error of some sort, store the error code, str
-      // and bail.
-      m_lastErrorCode = resp[2];
-      
-      switch (m_lastErrorCode) 
-        {
-        case 'N': m_lastErrorString = "No tag present";
-          break;
-        case 'U': m_lastErrorString = "Access failed, RF field is off";
-          break;
-        default: m_lastErrorString = "Unknown error code";
-          break;
-        }
-      return false;
-    }
-
-  // if we are here, then store the uid info and tag type.
-  m_tagType = (TAG_TYPE_T)resp[2];
-
-  if ((uint8_t)resp[0] == 6)
-    m_uidLen = 4;               // 4 byte uid
-  else
-    m_uidLen = 7;               // 7 byte
-
-  for (int i=0; i<m_uidLen; i++)
-    m_uid.push_back(resp[i+3]);
-
-  return true;
-}
-
-bool SM130::authenticate(uint8_t block, KEY_TYPES_T keyType, string key)
-{
-  clearError();
-
-  // A little sanity checking...
-  if (keyType == KEY_TYPE_A || keyType == KEY_TYPE_B)
-    {
-      if (key.empty())
-        throw std::invalid_argument(string(__FUNCTION__) +
-                                    ": You must specify a key for type A or B");
-      if (key.size() != 6)
-        throw std::invalid_argument(string(__FUNCTION__) +
-                                    ": Key size must be 6");
-
-      return false; // probably not reached :)
-    }
-  else
-    {
-      // make sure the key is empty for any other key type
-      key.clear();
-    }
-
-  string data;
-  data.push_back(block);
-  data.push_back(keyType);
-  data += key;
-
-  string resp = sendCommand(CMD_AUTHENTICATE, data);
-  
-  if (resp.empty())
-    {
-      cerr << __FUNCTION__ << ": failed" << endl;
-      return false;
-    }
-  
-  // response len is always 2, 'L' means auth was successful
-  if (resp[2] != 'L')
-    {
-      // then we got an error of some sort, store the error code, str
-      // and bail.
-      m_lastErrorCode = resp[2];
-      
-      switch (m_lastErrorCode) 
-        {
-        case 'N': m_lastErrorString = "No tag present, or login failed";
-          break;
-        case 'U': m_lastErrorString = "Login failed";
-          break;
-        case 'E': m_lastErrorString = "Invalid key format in EEPROM";
-          break;
-        default: m_lastErrorString = "Unknown error code";
-          break;
-        }
-      return false;
-    }
-
-  return true;
-}
-
-string SM130::readBlock16(uint8_t block)
-{
-  clearError();
-
-  string data;
-
-  data.push_back(block);
-
-  string resp = sendCommand(CMD_READ16, data);
-
-  if (resp.empty())
-    {
-      cerr << __FUNCTION__ << ": failed" << endl;
-      return "";
-    }
-
-  if ((uint8_t)resp[0] == 2)
-    {
-      // then we got an error of some sort, store the error code, str
-      // and bail.
-      m_lastErrorCode = resp[2];
-      
-      switch (m_lastErrorCode) 
-        {
-        case 'N': m_lastErrorString = "No tag present";
-          break;
-        case 'F': m_lastErrorString = "Read failed";
-          break;
-        default: m_lastErrorString = "Unknown error code";
-          break;
-        }
-
-      return "";
-    }
-
-  // trim off the len, cmd, and block # bytes and return the rest
-  resp.erase(0, 3);
-  return resp;
-}
-
-int32_t SM130::readValueBlock(uint8_t block)
-{
-  clearError();
-
-  string data;
-
-  data.push_back(block);
-
-  string resp = sendCommand(CMD_READ_VALUE, data);
-
-  if (resp.empty())
-    {
-      cerr << __FUNCTION__ << ": failed" << endl;
-      return 0;
-    }
-
-  if ((uint8_t)resp[0] == 2)
-    {
-      // then we got an error of some sort, store the error code, str
-      // and bail.
-      m_lastErrorCode = resp[2];
-      
-      switch (m_lastErrorCode) 
-        {
-        case 'N': m_lastErrorString = "No tag present";
-          break;
-        case 'F': m_lastErrorString = "Read failed";
-          break;
-        case 'I': m_lastErrorString = "Invalid Value Block";
-          break;
-        default: m_lastErrorString = "Unknown error code";
-          break;
-        }
-
-      return 0;
-    }
-
-  int32_t rv;
-  rv = ((uint8_t)resp[3] |
-        ((uint8_t)resp[4] << 8) |
-        ((uint8_t)resp[5] << 16) |
-        ((uint8_t)resp[6] << 24));
-
-  return rv;
-}
-
-bool SM130::writeBlock16(uint8_t block, string contents)
-{
-  clearError();
-
-  // A little sanity checking...
-  if (contents.size() != 16)
-    {
-      throw std::invalid_argument(string(__FUNCTION__) +
-                                  ": You must supply 16 bytes for block content");
-      
-      return false;
-    }
-
-  string data;
-  data.push_back(block);
-  data += contents;
-
-  string resp = sendCommand(CMD_WRITE16, data);
-  
-  if (resp.empty())
-    {
-      cerr << __FUNCTION__ << ": failed" << endl;
-      return false;
-    }
-  
-  if ((uint8_t)resp[0] == 2)
-    {
-      // then we got an error of some sort, store the error code, str
-      // and bail.
-      m_lastErrorCode = resp[2];
-      
-      switch (m_lastErrorCode) 
-        {
-        case 'F': m_lastErrorString = "Write failed";
-          break;
-        case 'N': m_lastErrorString = "No tag present";
-          break;
-        case 'U': m_lastErrorString = "Read after write failed";
-          break;
-        case 'X': m_lastErrorString = "Unable to read after write";
-          break;
-        default: m_lastErrorString = "Unknown error code";
-          break;
-        }
-      return false;
-    }
-
-  return true;
-}
-
-bool SM130::writeValueBlock(uint8_t block, int32_t value)
-{
-  clearError();
-  
-  string data;
-  data.push_back(block);
-  // put the value in, LSB first
-  data += (value & 0xff);
-  data += ((value >> 8) & 0xff);
-  data += ((value >> 16) & 0xff);
-  data += ((value >> 24) & 0xff);
-
-  string resp = sendCommand(CMD_WRITE_VALUE, data);
-  
-  if (resp.empty())
-    {
-      cerr << __FUNCTION__ << ": failed" << endl;
-      return false;
-    }
-  
-  if ((uint8_t)resp[0] == 2)
-    {
-      // then we got an error of some sort, store the error code, str
-      // and bail.
-      m_lastErrorCode = resp[2];
-      
-      switch (m_lastErrorCode) 
-        {
-        case 'F': m_lastErrorString = "Read failed during verification";
-          break;
-        case 'N': m_lastErrorString = "No tag present";
-          break;
-        case 'I': m_lastErrorString = "Invalid value block";
-          break;
-        default: m_lastErrorString = "Unknown error code";
-          break;
-        }
-      return false;
-    }
-
-  return true;
-}
-
-bool SM130::writeBlock4(uint8_t block, string contents)
-{
-  clearError();
-
-  // A little sanity checking...
-  if (contents.size() != 4)
-    {
-      throw std::invalid_argument(string(__FUNCTION__) +
-                                  ": You must supply 4 bytes for block content");
-      
-      return false;
-    }
-
-  string data;
-  data.push_back(block);
-  data += contents;
-
-  string resp = sendCommand(CMD_WRITE4, data);
-  
-  if (resp.empty())
-    {
-      cerr << __FUNCTION__ << ": failed" << endl;
-      return false;
-    }
-  
-  if ((uint8_t)resp[0] == 2)
-    {
-      // then we got an error of some sort, store the error code, str
-      // and bail.
-      m_lastErrorCode = resp[2];
-      
-      switch (m_lastErrorCode) 
-        {
-        case 'F': m_lastErrorString = "Write failed";
-          break;
-        case 'N': m_lastErrorString = "No tag present";
-          break;
-        case 'U': m_lastErrorString = "Read after write failed";
-          break;
-        case 'X': m_lastErrorString = "Unable to read after write";
-          break;
-        default: m_lastErrorString = "Unknown error code";
-          break;
-        }
-      return false;
-    }
-
-  return true;
-}
-
-bool SM130::writeKey(uint8_t eepromSector, KEY_TYPES_T keyType, string key)
-{
-  clearError();
-
-  // A little sanity checking...
-  eepromSector &= 0x0f; // Only 0x00-0x0f is valid
-
-  if (!(keyType == KEY_TYPE_A || keyType == KEY_TYPE_B))
-    {
-      throw std::invalid_argument(string(__FUNCTION__) +
-                                  ": Key type must be A or B");
-      
-      return false;
-    }
-
-  if (key.size() != 6)
-    {
-      throw std::invalid_argument(string(__FUNCTION__) +
-                                  ": Key must be 6 bytes");
-      
-      return false;
-    }
-
-  string data;
-  data.push_back(eepromSector);
-  data += keyType;
-  data += key;
-
-  string resp = sendCommand(CMD_WRITE_KEY, data);
-  
-  if (resp.empty())
-    {
-      cerr << __FUNCTION__ << ": failed" << endl;
-      return false;
-    }
-
-  // reponse len is always 2
-  if ((uint8_t)resp[2] != 'L')
-    {
-      // then we got an error of some sort, store the error code, str
-      // and bail.
-      m_lastErrorCode = resp[2];
-      
-      switch (m_lastErrorCode) 
-        {
-        case 'N': m_lastErrorString = "Write master key failed";
-          break;
-        default: m_lastErrorString = "Unknown error code";
-          break;
-        }
-      return false;
-    }
-
-  return true;
-}
-
-int32_t SM130::adjustValueBlock(uint8_t block, int32_t value, bool incr)
-{
-  clearError();
-  
-  string data;
-  data.push_back(block);
-  // put the value in, LSB first
-  data += (value & 0xff);
-  data += ((value >> 8) & 0xff);
-  data += ((value >> 16) & 0xff);
-  data += ((value >> 24) & 0xff);
-
-  string resp = sendCommand(((incr) ? CMD_INC_VALUE : CMD_DEC_VALUE), data);
-  
-  if (resp.empty())
-    {
-      cerr << __FUNCTION__ << ": failed" << endl;
-      return 0;
-    }
-  
-  if ((uint8_t)resp[0] == 2)
-    {
-      // then we got an error of some sort, store the error code, str
-      // and bail.
-      m_lastErrorCode = resp[2];
-      
-      switch (m_lastErrorCode) 
-        {
-        case 'F': m_lastErrorString = "Read failed during verification";
-          break;
-        case 'N': m_lastErrorString = "No tag present";
-          break;
-        case 'I': m_lastErrorString = "Invalid value block";
-          break;
-        default: m_lastErrorString = "Unknown error code";
-          break;
-        }
-      return 0;
-    }
-
-  // now unpack the new value, LSB first
-  int32_t rv;
-  rv = ((uint8_t)resp[3] |
-        ((uint8_t)resp[4] << 8) |
-        ((uint8_t)resp[5] << 16) |
-        ((uint8_t)resp[6] << 24));
-  
-  return rv;
-}
-
-bool SM130::setAntennaPower(bool on)
-{
-  clearError();
-  
-  string resp = sendCommand(CMD_ANTENNA_POWER, "");
-  
-  if (resp.empty())
-    {
-      cerr << __FUNCTION__ << ": failed" << endl;
-      return false;
-    }
-  
-  return true;
-}
-
-uint8_t SM130::readPorts()
-{
-  clearError();
-  
-  string resp = sendCommand(CMD_READ_PORT, "");
-  
-  if (resp.empty())
-    {
-      cerr << __FUNCTION__ << ": failed" << endl;
-      return 0;
-    }
-  
-  // only the first 2 bits are valid
-  return (resp[2] & 3);
-}
-
-bool SM130::writePorts(uint8_t val)
-{
-  clearError();
-  
-  // only the first 2 bits are valid
-  val &= 3;
-
-  string data;
-  data.push_back(val);
-
-  string resp = sendCommand(CMD_WRITE_PORT, data);
-  
-  if (resp.empty())
-    {
-      cerr << __FUNCTION__ << ": failed" << endl;
-      return false;
-    }
-  
-  return true;
-}
-
-bool SM130::haltTag()
-{
-  clearError();
-
-  string resp = sendCommand(CMD_HALT_TAG, "");
-  
-  if (resp.empty())
-    {
-      cerr << __FUNCTION__ << ": failed" << endl;
-      return false;
-    }
-
-  // reponse len is always 2
-  if ((uint8_t)resp[2] != 'L')
-    {
-      // then we got an error of some sort, store the error code, str
-      // and bail.
-      m_lastErrorCode = resp[2];
-      
-      switch (m_lastErrorCode) 
-        {
-        case 'U': m_lastErrorString = "Can not halt, RF field is off";
-          break;
-        default: m_lastErrorString = "Unknown error code";
-          break;
-        }
-      return false;
-    }
-
-  return true;
-}
-
-bool SM130::setSM130BaudRate(int baud)
-{
-  clearError();
-  
-  uint8_t newBaud;
-
-  switch (baud)
-    {
-    case 9600: newBaud = 0x00;
-      break;
-    case 19200: newBaud = 0x01;
-      break;
-    case 38400: newBaud = 0x02;
-      break;
-    case 57600: newBaud = 0x03;
-      break;
-    case 115200: newBaud = 0x04;
-      break;
-    default:
-      throw std::invalid_argument(string(__FUNCTION__) +
-                                  ": Invalid SM130 baud rate specified");
-    }
-
-  // WARNING: this is a dangerous command
-  int oldBaud = m_baud;
-  m_baud = baud;
-  
-  string data;
-  data.push_back(newBaud);
-
-  string resp = sendCommand(CMD_SET_BAUD, data);
-
-  if (resp.empty())
-    {
-      cerr << __FUNCTION__ << ": failed" << endl;
-      cerr << __FUNCTION__ << ": restoring old baud rate" << endl;
-
-      setBaudRate(oldBaud);
-      return false;
-    }
-
-  // otherwise assume success, possibly incorrectly
-  return true;
-}
-
-bool SM130::sleep()
-{
-  clearError();
-  
-  string resp = sendCommand(CMD_SLEEP, "");
-  
-  if (resp.empty())
-    {
-      cerr << __FUNCTION__ << ": failed" << endl;
-      return false;
-    }
-  
-  return true;
-}
-
-string SM130::string2HexString(string input)
-{
-  static const char* const lut = "0123456789abcdef";
-  size_t len = input.size();
-  
-  string output;
-  output.reserve(3 * len);
-  for (size_t i = 0; i < len; ++i)
-    {
-      const unsigned char c = input[i];
-      output.push_back(lut[c >> 4]);
-      output.push_back(lut[c & 15]);
-      output.push_back(' ');
-    }
-
-  return output;
-}
-
-void SM130::initClock()
-{
-  gettimeofday(&m_startTime, NULL);
-}
-
-uint32_t SM130::getMillis()
-{
-  struct timeval elapsed, now;
-  uint32_t elapse;
-
-  // get current time
-  gettimeofday(&now, NULL);
-
-  // compute the delta since m_startTime
-  if( (elapsed.tv_usec = now.tv_usec - m_startTime.tv_usec) < 0 ) 
-    {
-      elapsed.tv_usec += 1000000;
-      elapsed.tv_sec = now.tv_sec - m_startTime.tv_sec - 1;
-    } 
-  else 
-    {
-      elapsed.tv_sec = now.tv_sec - m_startTime.tv_sec;
-    }
-
-  elapse = (uint32_t)((elapsed.tv_sec * 1000) + (elapsed.tv_usec / 1000));
-
-  // never return 0
-  if (elapse == 0)
-    elapse = 1;
-
-  return elapse;
-}
-
-bool SM130::waitForTag(uint32_t timeout)
-{
-  initClock();
-
-  do 
-    {
-      if (select())
-        {
-          // success
-          return true;
-        }
-      else
-        {
-          // If there was an error, fail if it's anything other than a
-          // tag not present
-          if (getLastErrorCode() != 'N')
-            return false;
-
-          // otherwise, sleep for 100ms and try again
-          usleep(100000);
-        }
-    } while (getMillis() <= timeout);
-
-  return false;
-}
-
-string SM130::tag2String(TAG_TYPE_T tag)
-{
-  switch (tag)
-    {
-    case TAG_MIFARE_ULTRALIGHT: return "MiFare Ultralight";
-    case TAG_MIFARE_1K:         return "MiFare 1K";
-    case TAG_MIFARE_4K:         return "MiFare 4K";
-    case TAG_UNKNOWN:           return "Unknown Tag Type";
-    default:                    return "Invalid Tag Type";
-    }
-}
-
-
-
diff --git a/src/sm130/sm130.hpp b/src/sm130/sm130.hpp
deleted file mode 100644
index 6612718..0000000
--- a/src/sm130/sm130.hpp
+++ /dev/null
@@ -1,467 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <iostream>
-
-#include <stdlib.h>
-#include <stdint.h>
-#include <unistd.h>
-#include <string.h>
-#include <sys/time.h>
-#include <sys/select.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-
-#include <mraa/common.hpp>
-#include <mraa/uart.hpp>
-#include <mraa/gpio.hpp>
-
-#define SM130_DEFAULT_UART 0
-#define SM130_DEFAULT_RESET_PIN 13
-
-namespace upm {
-  
-  /**
-   * @brief SM130 RFID Reader Module
-   * @defgroup sm130 libupm-sm130
-   * @ingroup sparkfun uart gpio rfid
-   */
-
-  /**
-   * @library sm130
-   * @sensor sm130
-   * @comname RFID Reader
-   * @type rfid
-   * @man sparkfun
-   * @web https://www.sparkfun.com/products/10126
-   * @con uart gpio
-   *
-   * @brief API for the SM130 RFID Reader Module
-   * 
-   * This module defines the SM130 interface for the sm130 RFID library
-   *
-   * This module was developed using an SM130 and a Sparkfun RFID
-   * Evaluation shield using a UART for communications.  It should be
-   * fairly trivial to add support for I2C communication in the
-   * future, if you have the correct firmware on the SM130.
-   *
-   * @image html sm130.jpg
-   * <br><em>SM130 RFID Reader image provided by SparkFun* under
-   * <a href=https://creativecommons.org/licenses/by/2.0/>
-   * CC BY 2.0</a>.</em>
-   *
-   * @snippet sm130.cxx Interesting
-   */
-
-  class SM130 {
-    
-  public:
-
-    // Valid commands
-    typedef enum {
-      CMD_RESET                  = 0x80,
-      CMD_VERSION                = 0x81,
-      CMD_SEEK_TAG               = 0x82,
-      CMD_SELECT_TAG             = 0x83,
-      CMD_AUTHENTICATE           = 0x85,
-      CMD_READ16                 = 0x86,
-      CMD_READ_VALUE             = 0x87,
-      CMD_WRITE16                = 0x89,
-      CMD_WRITE_VALUE            = 0x8a,
-      CMD_WRITE4                 = 0x8b,
-      CMD_WRITE_KEY              = 0x8c,
-      CMD_INC_VALUE              = 0x8d,
-      CMD_DEC_VALUE              = 0x8e,
-      CMD_ANTENNA_POWER          = 0x90,
-      CMD_READ_PORT              = 0x91,
-      CMD_WRITE_PORT             = 0x92,
-      CMD_HALT_TAG               = 0x93,
-      CMD_SET_BAUD               = 0x94,
-      CMD_SLEEP                  = 0x96
-    } CMD_T;
-
-    // valid tag types.
-    typedef enum {
-      TAG_NONE                   = 0x00, // error/invalid
-
-      TAG_MIFARE_ULTRALIGHT      = 0x01,
-      TAG_MIFARE_1K              = 0x02,
-      TAG_MIFARE_4K              = 0x03,
-      TAG_UNKNOWN                = 0xff
-    } TAG_TYPE_T;    
-
-    // Valid authentication keys
-    typedef enum {
-      KEY_TYPE_EEPROM_A0         = 0x10,
-      KEY_TYPE_EEPROM_A1         = 0x11,
-      KEY_TYPE_EEPROM_A2         = 0x12,
-      KEY_TYPE_EEPROM_A3         = 0x13,
-      KEY_TYPE_EEPROM_A4         = 0x14,
-      KEY_TYPE_EEPROM_A5         = 0x15,
-      KEY_TYPE_EEPROM_A6         = 0x16,
-      KEY_TYPE_EEPROM_A7         = 0x17,
-      KEY_TYPE_EEPROM_A8         = 0x18,
-      KEY_TYPE_EEPROM_A9         = 0x19,
-      KEY_TYPE_EEPROM_A10        = 0x1a,
-      KEY_TYPE_EEPROM_A11        = 0x1b,
-      KEY_TYPE_EEPROM_A12        = 0x1c,
-      KEY_TYPE_EEPROM_A13        = 0x1d,
-      KEY_TYPE_EEPROM_A14        = 0x1e,
-      KEY_TYPE_EEPROM_A15        = 0x1f,
-
-      KEY_TYPE_EEPROM_B0         = 0x20,
-      KEY_TYPE_EEPROM_B1         = 0x21,
-      KEY_TYPE_EEPROM_B2         = 0x22,
-      KEY_TYPE_EEPROM_B3         = 0x23,
-      KEY_TYPE_EEPROM_B4         = 0x24,
-      KEY_TYPE_EEPROM_B5         = 0x25,
-      KEY_TYPE_EEPROM_B6         = 0x26,
-      KEY_TYPE_EEPROM_B7         = 0x27,
-      KEY_TYPE_EEPROM_B8         = 0x28,
-      KEY_TYPE_EEPROM_B9         = 0x29,
-      KEY_TYPE_EEPROM_B10        = 0x2a,
-      KEY_TYPE_EEPROM_B11        = 0x2b,
-      KEY_TYPE_EEPROM_B12        = 0x2c,
-      KEY_TYPE_EEPROM_B13        = 0x2d,
-      KEY_TYPE_EEPROM_B14        = 0x2e,
-      KEY_TYPE_EEPROM_B15        = 0x2f,
-
-      KEY_TYPE_A                 = 0xaa,
-      KEY_TYPE_B                 = 0xbb,
-
-      KEY_TYPE_A_AND_TRANSPORT_F = 0xff
-    } KEY_TYPES_T;
-
-    /**
-     * Instantiates an SM130 object
-     *
-     * @param uart The UART port.  Default is 0.
-     * @param reset The Reset pin.  Default is 13.
-     */
-    SM130 (int uart=SM130_DEFAULT_UART, int reset=SM130_DEFAULT_RESET_PIN);
-
-    /**
-     * SM130 object destructor
-     */
-    ~SM130 ();
-
-    /**
-     * Sets the baud rate for the device.  The default is 19200.
-     *
-     * @param baud Desired baud rate, default 19200
-     * @return mraa::Result value
-     */
-    mraa::Result setBaudRate(int baud=19200);
-
-    /**
-     * Gets the firmware version string.
-     *
-     * @return The firmware revision
-     */
-    std::string getFirmwareVersion();
-
-    /**
-     * Issues a reset command to the device.
-     *
-     * @return true if successful
-     */
-    bool reset();
-
-    /**
-     * Resets the device using the hardware RESET pin.  This is
-     * required if the device has been put to sleep using the sleep()
-     * method.
-     */
-    void hardwareReset();
-
-    /**
-     * Checks to see if a tag is in the RF field, and selects it if
-     * one is present.
-     *
-     * @return true if a tag was detected, false if no tag is present
-     * or an error was detected.
-     */
-    bool select();
-
-    /**
-     * Waits for a tag to enter the RF field for up to 'timeout'
-     * milliseconds. It will call select() every 100ms until 'timeout'
-     * has been exceeded.
-     *
-     * @param timeout The number of milliseconds to wait for a tag to appear
-     * @return true if a tag was detected, false if no tag was
-     * detected within the timeout value, or an error occurred
-     */
-    bool waitForTag(uint32_t timeout);
-
-    /**
-     * Set the authentication key for a block.  Depending on the
-     * permissions on the tag, the correct key must be authenticated
-     * for that block in order to perform read and write operations.
-     *
-     * @param block The block to authenticate for
-     * @param keyType one of the KEY_TYPE_T values
-     * @param key The 6 byte key to use for Type A and Type B keys
-     * @return true if authentication was successful, false otherwise
-     */
-    bool authenticate(uint8_t block, KEY_TYPES_T keyType, std::string key="");
-
-    /**
-     * Read a 16 byte block.  Depending on the tag, authentication of
-     * the block may be required for this method to succeed.
-     *
-     * @param block The block to read
-     * @return The 16 byte block if successful, an empty string otherwise
-     */
-    std::string readBlock16(uint8_t block);
-
-    /**
-     * Read a 4 byte value block.  Depending on the tag, authentication of
-     * the block may be required for this method to succeed.
-     *
-     * @param block The block to read
-     * @return The 4 byte signed integer value block if successful, 0 otherwise
-     */
-    int32_t readValueBlock(uint8_t block);
-
-    /**
-     * Write 16 bytes to a block.  Depending on the tag, authentication of
-     * the block may be required for this method to succeed.
-     *
-     * @param block The block to write
-     * @param contents A 16 byte string containing the data to write
-     * @return true if successful, false otherwise
-     */
-    bool writeBlock16(uint8_t block, std::string contents);
-
-    /**
-     * Write to a 4 byte value block.  Depending on the tag,
-     * authentication of the block may be required for this method to
-     * succeed.
-     *
-     * @param block The block to write
-     * @param value the signed 4 byte integer to write to the value block
-     * @return true if successful, false otherwise
-     */
-    bool writeValueBlock(uint8_t block, int32_t value);
-
-    /**
-     * Write 4 bytes to a block.  This is typically used for
-     * Ultralight tags. Depending on the tag, authentication of the
-     * block may be required for this method to succeed.
-     *
-     * @param block The block to write
-     * @param contents A 4 byte string containing the data to write
-     * @return true if successful, false otherwise
-     */
-    bool writeBlock4(uint8_t block, std::string contents);
-
-    /**
-     * Write a key into one of the 16 EEPROM key slots.  This can be a
-     * Type A or Type B key.  It is not possible to read these keys
-     * once written.  Once stored, the key can be used for
-     * authentication without having to send the key itself.  You can
-     * then use the appropriate KEY_TYPE_EEPROM_* keyTypes in a call
-     * to authenticate().
-     *
-     * @param eepromSector A number between 0 and 15, indicating the
-     * EEPROM sector you want to store the key in
-     * @param keyType Either KEY_TYPE_A or KEY_TYPE_B
-     * @param key The 6 byte key to store in the EEPROM
-     * @return true if successful, false otherwise
-     */
-    bool writeKey(uint8_t eepromSector, KEY_TYPES_T keyType, std::string key);
-
-    /**
-     * Increment or decrement a value block.
-     *
-     * @param block The block to adjust
-     * @param value The number to increment or decrement the value block by
-     * @param incr true to increment, false to decrement
-     * @return The contents of the value block after the operation has
-     * completed.
-     */
-    int32_t adjustValueBlock(uint8_t block, int32_t value, bool incr);
-
-    /**
-     * Turn the antenna power on or off.  The power is on by default
-     * after a reset.  If you turn off the antenna, and methods used
-     * for interacting with tags will fail until power is re-enabled.
-     *
-     * @param on true to enable antenna power, false to disable
-     * @return true if successful, false otherwise
-     */
-    bool setAntennaPower(bool on);
-
-    /**
-     * Read the status of the 2 onboard GPIO input pins.  Bit 0 is for
-     * input 0, bit 1 for input 1.  All other bits will be 0.
-     *
-     * @return bitmask of input port status values
-     */
-    uint8_t readPorts();
-
-    /**
-     * Set the output status of the 2 onboard gpio outputs.  Bit 0 is for
-     * output 0, bit 1 for output 1.  All other bits will be discarded.
-     *
-     * @param val bitmask of output status bits to write
-     * @return true if successful, false otherwise
-     */
-    bool writePorts(uint8_t val);
-
-    /**
-     * Halts a tag.  Once a tag is halted, it cannot be accessed until
-     * it is removed and reinserted into the RF field and selected.
-     *
-     * @return true if successful, false otherwise
-     */
-    bool haltTag();
-
-    /**
-     * Changes the baud rate of the SM130.  WARNING: This is a
-     * potentially dangerous command that could cause you to lose
-     * contact with the device.  Once the command is validated and
-     * issued, the host baudrate will be changed to match, and this
-     * method will wait for a response at the new baudrate for up to 1
-     * second. 
-     * 
-     * If this response does not arrive, the old baudrate will be
-     * restored, though there is no way to know whether the SM130
-     * actually succeessfully executed the baudrate change.
-     *
-     * Once the SM130 has changed it's baudrate, the new value will be
-     * stored in it's EEPROM, and any further access to the device
-     * will need to use the new baudrate.  This is true even after a
-     * power on reset.
-     *
-     * @param baud The new baud rate to set.  Valid values are 9600,
-     * 19200, 38400, 57600, and 115200.
-     * @return true if successful, false otherwise
-     */
-    bool setSM130BaudRate(int baud);
-
-    /**
-     * Put the SM130 to sleep.  Once the device has been put to sleep,
-     * the only way to wake it is via hardwareReset() or a power
-     * cycle.
-     *
-     * @return true if successful, false otherwise
-     */
-    bool sleep();
-
-    /**
-     * Get the last error that occurred.  After a successful
-     * operation, this will be 0. See the datasheet for the various
-     * errors that can occur in various circumstances.
-     *
-     * @return The last error code, or 0 if the last operation succeeded.
-     */
-    char getLastErrorCode() { return m_lastErrorCode; };
-
-    /**
-     * Get the text representation of the last error that occurred.
-     * The returned string is empty if the last operation completed
-     * successfully.
-     *
-     * @return The last error string if an error occurred, or an empty
-     * string if the last operation succeeded.
-     */
-    std::string getLastErrorString() { return m_lastErrorString; };
-
-    /**
-     * Get the UID length of the currently selected tag.
-     *
-     * @return The UID length of the currently selected tag, or 0 if
-     * no tag is currently selected.
-     */
-    int getUIDLen() { return m_uidLen; };
-
-    /**
-     * Get the UID of the currently selected tag.
-     *
-     * @return The UID of the currently selected tag, or an empty string if
-     * no tag is currently selected.
-     */
-    std::string getUID() { return m_uid; };
-
-    /**
-     * Get the tag type of the currently selected tag.
-     *
-     * @return The tag type of the currently selected tag, or TAG_NONE
-     * if no tag is currently selected.
-     */
-    TAG_TYPE_T getTagType() { return m_tagType; };
-
-    /**
-     * Convert the supplied tag type into a human readable string.
-     *
-     * @param tag One of the TAG_TYPE_T values
-     * @return A string representation of the supplied tag type
-     */
-    std::string tag2String(TAG_TYPE_T tag);
-
-    /**
-     * This is a convenience function that converts a supplied string
-     * into a space separated hex formatted string.  This can be
-     * useful for printing out binary data in a human readable format,
-     * like the UID.
-     *
-     * @param input The string to convert
-     * @return A string representation of the input in space separated
-     * hex values
-     */
-    std::string string2HexString(std::string input);
-
-  protected:
-    mraa::Uart m_uart;
-    mraa::Gpio m_gpioReset;
-
-    std::string sendCommand(CMD_T cmd, std::string data);
-    void initClock();
-    uint32_t getMillis();
-
-  private:
-    int m_uidLen;
-    std::string m_uid;
-
-    char m_lastErrorCode;
-    std::string m_lastErrorString;
-
-    TAG_TYPE_T m_tagType;
-
-    int m_baud;
-
-    struct timeval m_startTime;
-
-    void clearError()
-    { 
-      m_lastErrorCode = 0;
-      m_lastErrorString.clear();
-    }
-  };
-
-}
diff --git a/src/sm130/sm130.json b/src/sm130/sm130.json
deleted file mode 100644
index d98d046..0000000
--- a/src/sm130/sm130.json
+++ /dev/null
@@ -1,43 +0,0 @@
-{
-    "Library": "sm130",
-    "Description": "SonMicro SM130 RFID Reader Module library",
-    "Sensor Class": {
-        "SM130": {
-            "Name": "API for the SonMicro SM130 RFID Reader Module",
-            "Description": "This is the UPM Module for the SonMicro SM130 RFID Reader Module. This module defines the SM130 interface for the sm130 RFID library This module was developed using an SM130 and a Sparkfun RFID Evaluation shield using a UART for communications.  It should be fairly trivial to add support for I2C communication in the future, if you have the correct firmware on the SM130.",
-            "Aliases": ["sm130"],
-            "Categories": ["rfid"],
-            "Connections": ["uart", "gpio"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["SonMicro", "RFID Module - SM130 MIFARE (13.56 MHz)"],
-            "Image": "sm130.jpg",
-            "Examples": {
-                "Java": ["SM130_Example.java"],
-                "Python": ["sm130.py"],
-                "Node.js": ["sm130.js"],
-                "C++": ["sm130.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 4.85,
-                    "max": 5.5
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "min" : 0.030,
-                    "max" : 180
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -40,
-                    "max": 85
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.sparkfun.com/products/10126"],
-                "Datasheets": ["https://www.sparkfun.com/datasheets/Sensors/ID/SM130.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/smartdrive/CMakeLists.txt b/src/smartdrive/CMakeLists.txt
deleted file mode 100644
index ab4a8b8..0000000
--- a/src/smartdrive/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "smartdrive")
-set (libdescription "SmartDrive Advanced Motor Controller")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/smartdrive/smartdrive.cxx b/src/smartdrive/smartdrive.cxx
deleted file mode 100644
index 12e02b1..0000000
--- a/src/smartdrive/smartdrive.cxx
+++ /dev/null
@@ -1,430 +0,0 @@
-/*
- * The MIT License (MIT)
- *
- * Author: Oussema Harbi <oussema.elharbi@gmail.com>
- * Copyright (c) <2016> <Oussema Harbi>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <exception>
-#include <stdexcept>
-#include <unistd.h>
-#include <unistd.h>
-#include <stdlib.h>
-
-#include "smartdrive.hpp"
-
-
-using namespace upm;
-
-SmartDrive::SmartDrive(int i2c_bus, int address): m_smartdrive_control_address(address), m_i2c_smartdrive_control(i2c_bus)
-{
-    mraa::Result ret = m_i2c_smartdrive_control.address(m_smartdrive_control_address);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_address() failed");
-        return;
-    }
-}
-
-
-void
-SmartDrive::writeByte(uint8_t addr, uint8_t value) {
-    try {
-        m_i2c_smartdrive_control.writeReg(addr, value);
-    } catch (int e) {
-        std::cout << "Failed to write " << value << " to address " << addr << " --> " << e << std::endl;
-    }
-}
-
-uint8_t
-SmartDrive::readByte(uint8_t addr) {
-    try {
-        return m_i2c_smartdrive_control.readReg(addr);
-    } catch (int e) {
-        std::cout << "Failed to read byte at address " << addr << " --> " << e << std::endl;
-    }
-    return -1;
-}
-
-void
-SmartDrive::writeArray(uint8_t* array, uint8_t len) {
-    try {
-        m_i2c_smartdrive_control.write(array, len);
-    } catch (int e) {
-        std::cout << "Failed to write array values to address " << array[0] << " --> " << e << std::endl;
-    }
-}
-
-uint16_t
-SmartDrive::readInteger(uint8_t addr) {
-    try {
-        return m_i2c_smartdrive_control.readWordReg(addr);
-    } catch (int e) {
-        std::cout << "Failed to read value at address " << addr << " --> " << e << std::endl;
-    }
-    return -1;
-}
-
-uint32_t
-SmartDrive::readLongSigned(uint8_t addr) {
-    uint8_t bytes[4]={0};
-
-    try {
-        m_i2c_smartdrive_control.readBytesReg(addr, bytes, sizeof(bytes)/sizeof(uint8_t));
-        return (bytes[0]|(bytes[1]<<8)|(bytes[2]<<16)|(bytes[3]<<24));
-    } catch (int e) {
-        std::cout << "Failed to read integer value at address " << addr << " --> " << e << std::endl;
-    }
-    return -1;
-}
-
-void
-SmartDrive::command(uint8_t cmd) {
-    std::cout << "Running Command : " << cmd << std::endl;
-    writeByte(SmartDrive_COMMAND, cmd);
-}
-
-
-float
-SmartDrive::GetBattVoltage() {
-    uint8_t value = 0;
-    try {
-        value = readByte(SmartDrive_BATT_VOLTAGE);
-        return (value * SmartDrive_VOLTAGE_MULTIPLIER);
-    } catch (int e) {
-        std::cout << "Error: Could not read voltage -> " << e << std::endl;
-    }
-    return -1.0f;
-}
-
-
-uint32_t
-SmartDrive::ReadTachometerPosition(int motor_id) {
-    try {
-        if (motor_id == 1 )
-            return readLongSigned(SmartDrive_POSITION_M1);
-        else
-            return readLongSigned(SmartDrive_POSITION_M2);
-    } catch (int e) {
-        std::cout << "Error: Could not read encoders" << std::endl;
-    }
-    return -1;
-}
-
-
-void
-SmartDrive::Run_Unlimited(int motor_id, int direction, uint8_t speed) {
-        uint8_t ctrl = 0;
-        ctrl |= SmartDrive_CONTROL_SPEED;
-        ctrl |= SmartDrive_CONTROL_BRK;
-
-        std::cout << "Running with speed : " << (int) speed << std::endl;
-
-        if ( motor_id != SmartDrive_Motor_ID_BOTH )
-            ctrl |= SmartDrive_CONTROL_GO;
-        if ( direction != SmartDrive_Dir_Forward )
-            speed = speed * -1;
-        if ( motor_id != SmartDrive_Motor_ID_2) {
-            uint8_t array [5] = {SmartDrive_SPEED_M1, speed, 0, 0, ctrl};
-            writeArray(array, sizeof(array));
-        }
-        if ( motor_id != SmartDrive_Motor_ID_1) {
-            uint8_t array [5] = {SmartDrive_SPEED_M2, speed, 0, 0, ctrl};
-            writeArray(array, sizeof(array));
-        }
-        if ( motor_id == SmartDrive_Motor_ID_BOTH )
-            writeByte(SmartDrive_COMMAND, CMD_S);
-}
-
-
-void
-SmartDrive::StopMotor(int motor_id, int next_action ) {
-        if ( next_action !=SmartDrive_Action_Float )
-            writeByte(SmartDrive_COMMAND, CMD_A+motor_id-1);
-        else
-            writeByte(SmartDrive_COMMAND, CMD_a+motor_id-1);
-}
-
-void
-SmartDrive::Run_Seconds(int motor_id, int direction, uint8_t speed, uint8_t duration, bool wait_for_completion, int next_action ) {
-        uint8_t ctrl = 0;
-        ctrl |= SmartDrive_CONTROL_SPEED;
-        ctrl |= SmartDrive_CONTROL_TIME;
-
-        if ( next_action ==SmartDrive_Action_Brake )
-            ctrl |= SmartDrive_CONTROL_BRK;
-        if ( next_action ==SmartDrive_Action_BrakeHold ) {
-            ctrl |= SmartDrive_CONTROL_BRK;
-            ctrl |= SmartDrive_CONTROL_ON;
-        }
-        if ( motor_id != SmartDrive_Motor_ID_BOTH )
-            ctrl |= SmartDrive_CONTROL_GO;
-        if ( direction != SmartDrive_Dir_Forward )
-            speed = speed * -1;
-        if ( motor_id != SmartDrive_Motor_ID_2) {
-            uint8_t array[5] = {SmartDrive_SPEED_M1, speed, duration, 0, ctrl};
-            writeArray(array, sizeof(array));
-        }
-        if ( motor_id != SmartDrive_Motor_ID_1) {
-            uint8_t array[5] = {SmartDrive_SPEED_M2, speed, duration, 0, ctrl};
-            writeArray(array, sizeof(array));
-        }
-        if ( motor_id == SmartDrive_Motor_ID_BOTH )
-            writeByte(SmartDrive_COMMAND, CMD_S);
-        if ( wait_for_completion ) {
-            sleep(1); //this delay is required for the status byte to be available for reading.
-            WaitUntilTimeDone(motor_id);
-        }
-}
-
-
-void
-SmartDrive::WaitUntilTimeDone(int motor_id) {
-        while (IsTimeDone(motor_id) == false)
-            sleep(1);
-}
-
-
-bool
-SmartDrive::IsTimeDone(int motor_id) {
-        uint8_t result_1 = 0, result_2 = 0;
-        if ( motor_id != SmartDrive_Motor_ID_2 )
-            result_1 = readByte(SmartDrive_STATUS_M1);
-        if ( motor_id != SmartDrive_Motor_ID_1 )
-            result_2 = readByte(SmartDrive_STATUS_M2);
-        return (((result_1 & 0x40) == 0) && ((result_2 & 0x40) == 0) );  //look for time bits to be zero
-}
-
-
-void
-SmartDrive::Run_Degrees(int motor_id, int direction, uint8_t speed, uint32_t degrees, bool wait_for_completion, int next_action) {
-        uint8_t ctrl = 0;
-        ctrl |= SmartDrive_CONTROL_SPEED;
-        ctrl |= SmartDrive_CONTROL_TACHO;
-        ctrl |= SmartDrive_CONTROL_RELATIVE;
-
-        uint32_t d = degrees;
-        if ( direction != SmartDrive_Dir_Forward )
-            d = degrees * -1 ;
-
-        uint8_t t4 = (d/0x1000000);
-        uint8_t t3 = ((d%0x1000000)/0x10000);
-        uint8_t t2 = (((d%0x1000000)%0x10000)/0x100);
-        uint8_t t1 = (((d%0x1000000)%0x10000)%0x100);
-
-        if ( next_action ==SmartDrive_Action_Brake )
-            ctrl |= SmartDrive_CONTROL_BRK;
-        if ( next_action ==SmartDrive_Action_BrakeHold ) {
-            ctrl |= SmartDrive_CONTROL_BRK;
-            ctrl |= SmartDrive_CONTROL_ON;
-        }
-        if ( motor_id != SmartDrive_Motor_ID_BOTH )
-            ctrl |= SmartDrive_CONTROL_GO;
-        if ( motor_id != SmartDrive_Motor_ID_2) {
-            uint8_t array[9] = {SmartDrive_SETPT_M1, t1, t2, t3, t4, speed, 0, 0, ctrl};
-            writeArray(array, sizeof(array));
-        }
-        if ( motor_id != SmartDrive_Motor_ID_1){
-            uint8_t array[9] = {SmartDrive_SETPT_M2, t1, t2, t3, t4, speed, 0, 0, ctrl};
-            writeArray(array, sizeof(array));
-        }
-        if ( motor_id == SmartDrive_Motor_ID_BOTH )
-            writeByte(SmartDrive_COMMAND, CMD_S);
-        if ( wait_for_completion ) {
-            sleep(1);//this delay is required for the status byte to be available for reading.
-            WaitUntilTachoDone(motor_id);
-        }
-}
-
-
-void
-SmartDrive::Run_Rotations(int motor_id, int direction, uint8_t speed, uint32_t rotations, bool wait_for_completion, int next_action) {
-        uint8_t ctrl = 0;
-        ctrl |= SmartDrive_CONTROL_SPEED;
-        ctrl |= SmartDrive_CONTROL_TACHO;
-        ctrl |= SmartDrive_CONTROL_RELATIVE;
-
-        uint32_t d = rotations * 360;
-        if ( direction != SmartDrive_Dir_Forward )
-            d = (rotations * 360) * -1;
-
-        uint8_t t4 = (d/0x1000000);
-        uint8_t t3 = ((d%0x1000000)/0x10000);
-        uint8_t t2 = (((d%0x1000000)%0x10000)/0x100);
-        uint8_t t1 = (((d%0x1000000)%0x10000)%0x100);
-
-        if ( next_action ==SmartDrive_Action_Brake )
-            ctrl |= SmartDrive_CONTROL_BRK;
-        if ( next_action ==SmartDrive_Action_BrakeHold ) {
-            ctrl |= SmartDrive_CONTROL_BRK;
-            ctrl |= SmartDrive_CONTROL_ON;
-        }
-        if ( motor_id != SmartDrive_Motor_ID_BOTH )
-            ctrl |= SmartDrive_CONTROL_GO;
-        if ( motor_id != SmartDrive_Motor_ID_2) {
-            uint8_t array[9] = {SmartDrive_SETPT_M1, t1, t2, t3, t4, speed, 0, 0, ctrl};
-            writeArray(array, sizeof(array));
-        }
-        if ( motor_id != SmartDrive_Motor_ID_1) {
-            uint8_t array[9] = {SmartDrive_SETPT_M2, t1, t2, t3, t4, speed, 0, 0, ctrl};
-            writeArray(array, sizeof(array));
-        }
-        if ( motor_id == SmartDrive_Motor_ID_BOTH )
-            writeByte(SmartDrive_COMMAND, CMD_S);
-        if ( wait_for_completion) {
-            sleep(1); //this delay is required for the status byte to be available for reading.
-            WaitUntilTachoDone(motor_id);
-        }
-}
-
-
-void
-SmartDrive::Run_Tacho(int motor_id, uint8_t speed, uint32_t tacho_count, bool wait_for_completion, int next_action) {
-        uint8_t ctrl = 0;
-        ctrl |= SmartDrive_CONTROL_SPEED;
-        ctrl |= SmartDrive_CONTROL_TACHO;
-
-        uint32_t d = tacho_count;
-
-        uint8_t t4 = (d/0x1000000);
-        uint8_t t3 = ((d%0x1000000)/0x10000);
-        uint8_t t2 = (((d%0x1000000)%0x10000)/0x100);
-        uint8_t t1 = (((d%0x1000000)%0x10000)%0x100);
-
-        if ( next_action ==SmartDrive_Action_Brake )
-            ctrl |= SmartDrive_CONTROL_BRK;
-        if ( next_action ==SmartDrive_Action_BrakeHold ) {
-            ctrl |= SmartDrive_CONTROL_BRK;
-            ctrl |= SmartDrive_CONTROL_ON;
-        }
-        if ( motor_id != SmartDrive_Motor_ID_BOTH )
-            ctrl |= SmartDrive_CONTROL_GO;
-        if ( motor_id != SmartDrive_Motor_ID_2){
-            uint8_t array[9]= {SmartDrive_SETPT_M1, t1, t2, t3, t4, speed, 0, 0, ctrl};
-            writeArray(array, sizeof(array));
-        }
-        if ( motor_id != SmartDrive_Motor_ID_1){
-            uint8_t array[9]= {SmartDrive_SETPT_M2, t1, t2, t3, t4, speed, 0, 0, ctrl};
-            writeArray(array, sizeof(array));
-        }
-        if ( motor_id == SmartDrive_Motor_ID_BOTH )
-            writeByte(SmartDrive_COMMAND, CMD_S);
-        if ( wait_for_completion )
-            sleep(1); //this delay is required for the status byte to be available for reading.
-            WaitUntilTachoDone(motor_id);
-}
-
-
-void
-SmartDrive::WaitUntilTachoDone(int motor_id) {
-        while (IsTachoDone(motor_id) == false)
-            sleep(1);
-}
-
-
-bool
-SmartDrive::IsTachoDone(int motor_id) {
-        uint8_t result_1 = 0, result_2 = 0;
-
-        if ( motor_id != SmartDrive_Motor_ID_2 )
-            result_1 = readByte(SmartDrive_STATUS_M1);
-        if ( motor_id != SmartDrive_Motor_ID_1 )
-            result_2 = readByte(SmartDrive_STATUS_M2);
-        //look for both time bits to be zero
-        return (((result_1 & 0x08) == 0) && ((result_2 & 0x08) == 0) );
-}
-
-
-void
-SmartDrive::SetPerformanceParameters( uint16_t Kp_tacho, uint16_t Ki_tacho, uint16_t Kd_tacho, uint16_t Kp_speed, uint16_t Ki_speed, uint16_t Kd_speed, uint8_t passcount, uint8_t tolerance) {
-    uint8_t Kp_t1 = Kp_tacho%0x100;
-    uint8_t Kp_t2 = Kp_tacho/0x100;
-    uint8_t Ki_t1 = Ki_tacho%0x100;
-    uint8_t Ki_t2 = Ki_tacho/0x100;
-    uint8_t Kd_t1 = Kd_tacho%0x100;
-    uint8_t Kd_t2 = Kd_tacho/0x100;
-    uint8_t Kp_s1 = Kp_speed%0x100;
-    uint8_t Kp_s2 = Kp_speed/0x100;
-    uint8_t Ki_s1 = Ki_speed%0x100;
-    uint8_t Ki_s2 = Ki_speed/0x100;
-    uint8_t Kd_s1 = Kd_speed%0x100;
-    uint8_t Kd_s2 = Kd_speed/0x100;
-
-    uint8_t array[15] = {SmartDrive_P_Kp, Kp_t1 , Kp_t2 , Ki_t1, Ki_t2, Kd_t1, Kd_t2, Kp_s1, Kp_s2, Ki_s1, Ki_s2, Kd_s1, Kd_s2, passcount, tolerance};
-    writeArray(array, sizeof(array));
-}
-
-
-void
-SmartDrive::ReadPerformanceParameters() {
-   try {
-        std::cout << "Pkp: " << readInteger(SmartDrive_P_Kp) << std::endl;
-        std::cout << "Pki: " << readInteger(SmartDrive_P_Ki) << std::endl;
-        std::cout << "Pkd: " << readInteger(SmartDrive_P_Kd) << std::endl;
-        std::cout << "Skp: " << readInteger(SmartDrive_S_Kp) << std::endl;
-        std::cout << "Ski: " << readInteger(SmartDrive_S_Ki) << std::endl;
-        std::cout << "Skd: " << readInteger(SmartDrive_S_Kd) << std::endl;
-        std::cout << "Passcount: " << SmartDrive_PASSCOUNT << std::endl; //ToDo : Check if these should actually be Register Reads !!
-        std::cout << "Tolerance: " << SmartDrive_PASSTOLERANCE << std::endl;
-    } catch( int e) {
-        std::cout << "Error: Could not read PID values -> " << e << std::endl;
-    }
-}
-
-uint8_t
-SmartDrive::GetMotorStatus(int motor_id) {
-    uint8_t status=0;
-    if (motor_id == SmartDrive_Motor_ID_1)
-        status = readByte(SmartDrive_STATUS_M1);
-    if (motor_id == SmartDrive_Motor_ID_2)
-        status = readByte(SmartDrive_STATUS_M1);
-    if (motor_id == SmartDrive_Motor_ID_BOTH) {
-        std::cout << "Please specify which motor's status you want to fetch !" << std::endl;
-    }
-    return status;
-}
-
-void
-SmartDrive::PrintMotorStatus(int motor_id) {
-    if (motor_id != SmartDrive_Motor_ID_BOTH) {
-    uint8_t status = GetMotorStatus(motor_id);
-    uint8_t control_on = (status & SmartDrive_MOTOR_CONTROL_ON);
-    uint8_t is_ramping = (status & SmartDrive_MOTOR_IS_RAMPING);
-    uint8_t is_powered = (status & SmartDrive_MOTOR_IS_POWERED);
-    uint8_t pos_control_on = (status & SmartDrive_MOTOR_POS_CTRL_ON);
-    uint8_t in_brake_mode = (status & SmartDrive_MOTOR_IN_BRAKE_MODE);
-    uint8_t is_overloaded = (status & SmartDrive_MOTOR_OVERLOADED);
-    uint8_t in_time_mode = (status & SmartDrive_MOTOR_IN_TIME_MODE);
-    uint8_t is_stalled = (status & SmartDrive_MOTOR_IS_STALLED);
-
-    std::cout << "Motor " << motor_id+1 << " is programemd to move at " << ( (control_on == 0) ? "variable" : "fixed") << " speed" << std::endl;
-    std::cout << "Motor " << motor_id+1 << " is " << ((is_ramping == 0) ? "NOT" : "") << " ramping" << std::endl;
-    std::cout << "Motor " << motor_id+1 << " is " <<  ((is_powered == 0) ? "NOT" : "") << " powered" << std::endl;
-    std::cout << "Motor " << motor_id+1 << " is " <<  ((pos_control_on == 0) ? "moving towards desired encoder " : "holding it ") << "position" << std::endl;
-    std::cout << "Motor " << motor_id+1 << " is in " <<  ((in_brake_mode == 0) ? "brake" : "float") << " mode" << std::endl;
-    std::cout << "Motor " << motor_id+1 << " is " <<  ((is_overloaded == 0) ? "NOT" : "") << " overloaded" << std::endl;
-    std::cout << "Motor " << motor_id+1 << " is " <<  ((in_time_mode == 0) ? "NOT" : "") << " in time mode" << std::endl;
-    std::cout << "Motor " << motor_id+1 << " is " <<  ((is_stalled == 0) ? "NOT" : "") << " stalled" << std::endl;
-
-    } else {
-        std::cout << "Please specify which motor's status you want to fetch !" << std::endl;
-    }
-}
diff --git a/src/smartdrive/smartdrive.hpp b/src/smartdrive/smartdrive.hpp
deleted file mode 100644
index 5110855..0000000
--- a/src/smartdrive/smartdrive.hpp
+++ /dev/null
@@ -1,302 +0,0 @@
-/*
- * The MIT License (MIT)
- *
- * Author: Oussema Harbi <oussema.elharbi@gmail.com>
- * Copyright (c) <2016> <Oussema Harbi>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
- * the Software, and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
- * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <mraa/i2c.hpp>
-
-//We can use direct integer IDs,
-//or we can use the typedef here to help limit the error cases
-//and still support extension to support more Motors in the future
-//But when using typedef, we need to cast these when sending them in i2c bus
-#define    SmartDrive_Motor_ID_1     0x01
-#define    SmartDrive_Motor_ID_2     0x02
-#define    SmartDrive_Motor_ID_BOTH  0x03
-
-#define    SmartDrive_Dir_Reverse  0x00
-#define    SmartDrive_Dir_Forward  0x01
-
-#define    SmartDrive_Action_Float      0x00  //stop and let the motor coast.
-#define    SmartDrive_Action_Brake      0x01  //apply brakes, and resist change to tachometer
-#define    SmartDrive_Action_BrakeHold  0x02  //apply brakes, and restore externally forced change to tachometer
-
-//Next action (upon completion of current action)
-#define    SmartDrive_Completion_Wait_For   0x01
-#define    SmartDrive_Completion_Dont_Wait  0x00
-
-#define    SmartDrive_DefaultAddress      0x1b
-#define    SmartDrive_VOLTAGE_MULTIPLIER  212.7
-
-//Commonly used speed constants, these are just convenience constants
-//You can use any value between 0 and 100.
-#define    SmartDrive_Speed_Full    90
-#define    SmartDrive_Speed_Medium  60
-#define    SmartDrive_Speed_Slow    25
-
-//Different commands
-#define    SmartDrive_CONTROL_SPEED    0x01
-#define    SmartDrive_CONTROL_RAMP     0x02
-#define    SmartDrive_CONTROL_RELATIVE 0x04
-#define    SmartDrive_CONTROL_TACHO    0x08
-#define    SmartDrive_CONTROL_BRK      0x10
-#define    SmartDrive_CONTROL_ON       0x20
-#define    SmartDrive_CONTROL_TIME     0x40
-#define    SmartDrive_CONTROL_GO       0x80
-
-#define    SmartDrive_COMMAND          0x41
-#define    SmartDrive_SETPT_M1         0x42
-#define    SmartDrive_SPEED_M1         0x46
-#define    SmartDrive_TIME_M1          0x47
-#define    SmartDrive_CMD_B_M1         0x48
-#define    SmartDrive_CMD_A_M1         0x49
-
-#define    SmartDrive_SETPT_M2         0x4A
-#define    SmartDrive_SPEED_M2         0x4E
-#define    SmartDrive_TIME_M2          0x4F
-#define    SmartDrive_CMD_B_M2         0x50
-#define    SmartDrive_CMD_A_M2         0x51
-
-//Read registers.
-#define    SmartDrive_POSITION_M1      0x52
-#define    SmartDrive_POSITION_M2      0x56
-#define    SmartDrive_STATUS_M1        0x5A
-#define    SmartDrive_STATUS_M2        0x5B
-#define    SmartDrive_TASKS_M1         0x5C
-#define    SmartDrive_TASKS_M2         0x5D
-
-//PID control registers
-#define    SmartDrive_P_Kp             0x5E   //proportional gain-position
-#define    SmartDrive_P_Ki             0x60   //integral gain-position
-#define    SmartDrive_P_Kd             0x62   //derivative gain-position
-#define    SmartDrive_S_Kp             0x64   //proportional gain-speed
-#define    SmartDrive_S_Ki             0x66   //integral gain-speed
-#define    SmartDrive_S_Kd             0x68   //derivative gain-speed
-#define    SmartDrive_PASSCOUNT        0x6A
-#define    SmartDrive_PASSTOLERANCE    0x6B
-
-#define    SmartDrive_CHKSUM    0x6C
-
-//Power data registers
-#define    SmartDrive_BATT_VOLTAGE   0x6E
-#define    SmartDrive_RESETSTATUS    0x6F
-#define    SmartDrive_CURRENT_M1     0x70
-#define    SmartDrive_CURRENT_M2     0x72
-
-//Supported I2C commands
-#define  CMD_R  0x52
-#define  CMD_S  0x53
-#define  CMD_a  0x61
-#define  CMD_b  0x62
-#define  CMD_c  0x63
-#define  CMD_A  0x41
-#define  CMD_B  0x42
-#define  CMD_C  0x43
-
-//Motor Status Masks
-#define SmartDrive_MOTOR_CONTROL_ON        0x1
-#define SmartDrive_MOTOR_IS_RAMPING        0x2
-#define SmartDrive_MOTOR_IS_POWERED        0x4
-#define SmartDrive_MOTOR_POS_CTRL_ON       0x8
-#define SmartDrive_MOTOR_IN_BRAKE_MODE     0x10
-#define SmartDrive_MOTOR_OVERLOADED        0x20
-#define SmartDrive_MOTOR_IN_TIME_MODE      0x40
-#define SmartDrive_MOTOR_IS_STALLED        0x80
-
-namespace upm {
-
-/**
- * @brief SmartDrive Motor Controller
- * @defgroup smartdrive libupm-smartdrive
- * @ingroup i2c motor openelectrons
- */
-
-/**
- * @library smartdrive
- * @sensor smartdrive
- * @comname SmartDrive Advanced Motor Controller
- * @altname smartdrive
- * @type motor
- * @man openelectrons
- * @con i2c
- *
- * @brief API for the SmartDrive advanced motor controller from OpenElectronis
- *
- * SmartDrive is a multiplexer to control high current DC motors
- *
- * This module has been tested on the SmartDrive.
- *
- * @snippet smartdrive.cxx Interesting
- */
-//Class definition
-class SmartDrive {
-
-public:
-    /**
-     * Initialize the class with the i2c address of your SmartDrive
-     * @param i2c_bus I2C bus to use.
-     * @param address Address of your SmartDrive.
-     */
-    SmartDrive(int i2c_bus, int address = SmartDrive_DefaultAddress);
-
-    /**
-     * Writes a specified command on the command register of the SmartDrive
-     * @param cmd The command you wish the SmartDrive to execute.
-     */
-    void command(uint8_t cmd);
-
-    /**
-     * Reads the battery voltage. Multiplier constant not yet verified
-     */
-    float GetBattVoltage();
-
-    /**
-     * Reads the tacheometer position of the specified motor
-     * @param motor_id Number of the motor you wish to read.
-     */
-    uint32_t ReadTachometerPosition(int motor_id);
-
-    /**
-     * Turns the specified motor(s) forever
-     * @param motor_id Number of the motor(s) you wish to turn.
-     * @param direction The direction you wish to turn the motor(s).
-     * @param speed The speed at which you wish to turn the motor(s).
-     */
-    void Run_Unlimited(int motor_id, int direction, uint8_t speed);
-
-    /**
-     * Stops the specified motor(s)
-     * @param motor_id Number of the motor(s) you wish to turn.
-     * @param next_action How you wish to stop the motor(s).
-     */
-    void StopMotor(int motor_id, int next_action );
-
-    /**
-     * Turns the specified motor(s) for a given amount of seconds
-     * @param motor_id Number of the motor(s) you wish to turn.
-     * @param direction The direction you wish to turn the motor(s).
-     * @param speed The speed at which you wish to turn the motor(s).
-     * @param duration The time in seconds you wish to turn the motor(s).
-     * @param wait_for_completion Tells the program when to handle the next line of code.
-     * @param next_action How you wish to stop the motor(s).
-     */
-    void Run_Seconds(int motor_id, int direction, uint8_t speed, uint8_t duration, bool wait_for_completion, int next_action );
-
-    /**
-     * Waits until the specified time for the motor(s) to run is completed
-     * @param motor_id Number of the motor(s) to wait for.
-     */
-    void WaitUntilTimeDone(int motor_id);
-
-    /**
-     * Checks to ensure the specified time for the motor(s) to run is completed.
-     * @param motor_id Number of the motor(s) to check.
-     */
-    bool IsTimeDone(int motor_id);
-
-    /**
-     * Turns the specified motor(s) for given relative tacheometer count
-     * @param motor_id Number of the motor(s) you wish to turn.
-     * @param direction The direction you wish to turn the motor(s).
-     * @param speed The speed at which you wish to turn the motor(s).
-     * @param degrees The relative tacheometer count you wish to turn the motor(s).
-     * @param wait_for_completion Tells the program when to handle the next line of code.
-     * @param next_action How you wish to stop the motor(s).
-     */
-    void Run_Degrees(int motor_id, int direction, uint8_t speed, uint32_t degrees, bool wait_for_completion, int next_action);
-
-    /**
-     * Turns the specified motor(s) for given relative tacheometer count
-     * @param motor_id Number of the motor(s) you wish to turn.
-     * @param direction The direction you wish to turn the motor(s).
-     * @param speed The speed at which you wish to turn the motor(s).
-     * @param rotations The relative amount of rotations you wish to turn the motor(s).
-     * @param wait_for_completion Tells the program when to handle the next line of code.
-     * @param next_action How you wish to stop the motor(s).
-     */
-    void Run_Rotations(int motor_id, int direction, uint8_t speed, uint32_t rotations, bool wait_for_completion, int next_action);
-
-    /**
-     * Turns the specified motor(s) for given absolute tacheometer count
-     * @param motor_id Number of the motor(s) you wish to turn.
-     * @param speed The speed at which you wish to turn the motor(s).
-     * @param tacho_count The absolute tacheometer count you wish to turn the motor(s).
-     * @param wait_for_completion Tells the program when to handle the next line of code.
-     * @param next_action How you wish to stop the motor(s).
-     */
-    void Run_Tacho(int motor_id, uint8_t speed, uint32_t tacho_count, bool wait_for_completion, int next_action);
-
-    /**
-     * Waits until the specified tacheomter count for the motor(s) to run is reached.
-     * @param motor_id Number of the motor(s) to wait for.
-     */
-    void WaitUntilTachoDone(int motor_id);
-
-    /**
-     * Checks to ensure the specified tacheomter count for the motor(s) to run is reached.
-     * @param motor_id Number of the motor(s) to check.
-     */
-    bool IsTachoDone(int motor_id);
-
-    /**
-     * Writes user specified values to the PID control registers
-     * @param Kp_tacho Proportional-gain of the tacheometer position of the motor.
-     * @param Ki_tacho Integral-gain of the tacheometer position of the motor.
-     * @param Kd_tacho Derivative-gain of the tacheometer position of the motor.
-     * @param Kp_speed Proportional-gain of the speed of the motor.
-     * @param Ki_speed Integral-gain of the speed of the motor.
-     * @param Kd_speed Derivative-gain of the speed of the motor.
-     */
-    void SetPerformanceParameters( uint16_t Kp_tacho, uint16_t Ki_tacho, uint16_t Kd_tacho, uint16_t Kp_speed, uint16_t Ki_speed, uint16_t Kd_speed, uint8_t passcount, uint8_t tolerance);
-
-    /**
-     * Reads the values of the PID control registers
-     */
-    void ReadPerformanceParameters();
-
-    /**
-     * Read the status of a motor, and return it in a uint8_t
-     * param motor_id Number fo the motor to check
-     */
-    uint8_t GetMotorStatus(int motor_id);
-
-    /**
-     * Print the detailed status of the motor
-     * @param motor_id Number fo the motor to check
-     */
-    void PrintMotorStatus(int motor_id);
-
-private:
-    void writeByte(uint8_t addr, uint8_t value);
-    void writeArray(uint8_t* array, uint8_t len);
-    uint8_t readByte(uint8_t addr);
-    uint16_t readInteger(uint8_t addr);
-    uint32_t readLongSigned(uint8_t addr);
-
-private:
-    int m_smartdrive_control_address;
-    mraa::I2c m_i2c_smartdrive_control;
-
-};
-
-}
diff --git a/src/smartdrive/smartdrive.i b/src/smartdrive/smartdrive.i
deleted file mode 100644
index 45e76fa..0000000
--- a/src/smartdrive/smartdrive.i
+++ /dev/null
@@ -1,14 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_smartdrive)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "smartdrive.hpp"
-%}
-%include "smartdrive.hpp"
-/* END Common SWIG syntax */
diff --git a/src/smartdrive/smartdrive.json b/src/smartdrive/smartdrive.json
deleted file mode 100644
index c3bf703..0000000
--- a/src/smartdrive/smartdrive.json
+++ /dev/null
@@ -1,42 +0,0 @@
-{
-    "Library": "smartdrive",
-    "Description": "SmartDrive library",
-    "Sensor Class": {
-        "SmartDrive": {
-            "Name": "API for the SmartDrive advanced motor controller from OpenElectronics",
-            "Description": "This is the UPM Module for the OpenElectronics SmartDrive advanced motor controller. SmartDrive is a multiplexer to control high current DC motors This module has been tested on the SmartDrive.",
-            "Aliases": ["smartdrive", "SmartDrive High Current Motor Controller"],
-            "Categories": ["motor"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping", "robotics"],
-            "Manufacturers": ["OpenElectronics"],
-            "Examples": {
-                "C++": ["smartdrive.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 12,
-                    "max": 24
-                },
-                "Supply Current": {
-                    "unit": "A",
-                    "average": 10,
-                    "max": 30
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Controllable Motors": {
-                    "unit": "motors",
-                    "motors": 2
-                }
-            },
-            "Urls": {
-                "Product Pages": ["http://www.mindsensors.com/rpi/76-smartdrive-high-current-motor-controller"]
-            }
-        }
-    }
-}
diff --git a/src/speaker/CMakeLists.txt b/src/speaker/CMakeLists.txt
deleted file mode 100644
index 18a08f0..0000000
--- a/src/speaker/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME speaker
-    DESCRIPTION "Speaker"
-    C_HDR speaker.h
-    C_SRC speaker.c
-    CPP_HDR speaker.hpp
-    CPP_SRC speaker.cxx
-#    FTI_SRC speaker_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/speaker/speaker.c b/src/speaker/speaker.c
deleted file mode 100644
index 6e1dc03..0000000
--- a/src/speaker/speaker.c
+++ /dev/null
@@ -1,349 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Based on original C++ driver by:
- * Author: Zion Orent <sorent@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <assert.h>
-
-#include <upm_utilities.h>
-#include <upm_platform.h>
-
-#include "speaker.h"
-
-typedef struct
-{
-    int delayTimeLow;
-    int delayTimeLowSharp;
-    int delayTimeMed;
-    int delayTimeMedSharp;
-    int delayTimeHigh;
-    int delayTimeHighSharp;
-} noteData_t;
-
-// keep this synchronized with the switch statement in play_sound()
-static noteData_t note_list[7] = {       // index, note
-    { 1136, 1073, 568, 536, 284, 268 }, // 0, a
-    { 1012, 0, 506, 0, 253, 0 },        // 1, b
-    { 1911, 1804, 956, 902, 478, 451 }, // 2, c
-    { 1703, 1607, 851, 804, 426, 402 }, // 3, d
-    { 1517, 0, 758, 0, 379, 0 },        // 4, e
-    { 1432, 1351, 716, 676, 358, 338 }, // 5, f
-    { 1276, 1204, 638, 602, 319, 301 }  // 6, g
-};
-
-// forward decl
-static void speaker_sound(const speaker_context dev, int note_delay);
-
-static speaker_context _common_init()
-{
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        return NULL;
-    }
-
-    speaker_context dev =
-        (speaker_context)malloc(sizeof(struct _speaker_context));
-
-    if (!dev)
-        return NULL;
-
-    // zero out context
-    memset((void *)dev, 0, sizeof(struct _speaker_context));
-
-    return dev;
-}
-
-// initialization in GPIO mode
-speaker_context speaker_init(int pin)
-{
-    speaker_context dev = NULL;
-    if (!(dev = _common_init()))
-        return NULL;
-
-    dev->is_pwm = false;
-
-    if (!(dev->gpio = mraa_gpio_init(pin)))
-    {
-        printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
-        speaker_close(dev);
-        return NULL;
-    }
-
-    mraa_gpio_dir(dev->gpio, MRAA_GPIO_OUT);
-
-    return dev;
-}
-
-// initialization in PWM mode
-speaker_context speaker_init_pwm(int pin)
-{
-    speaker_context dev = NULL;
-    if (!(dev = _common_init()))
-        return NULL;
-
-    dev->is_pwm = true;
-
-    if (!(dev->pwm = mraa_pwm_init(pin)))
-    {
-        printf("%s: mraa_pwm_init() failed.\n", __FUNCTION__);
-        speaker_close(dev);
-        return NULL;
-    }
-
-    // set the default frequency to 1Khz
-    dev->default_freq = 1000;
-
-    return dev;
-}
-
-void speaker_close(speaker_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->gpio)
-        mraa_gpio_close(dev->gpio);
-
-    if (dev->pwm)
-    {
-        speaker_off(dev);
-        mraa_pwm_close(dev->pwm);
-    }
-
-    free(dev);
-}
-
-upm_result_t speaker_set_frequency(const speaker_context dev,
-                                   unsigned int freq)
-{
-    assert(dev != NULL);
-
-    if (!dev->is_pwm)
-        return UPM_ERROR_NO_RESOURCES;
-
-    if (freq < 50 || freq > 32000)
-    {
-        printf("%s: freq must be between 50 and 32000.\n", __FUNCTION__);
-
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    float period = 1.0 / (float)freq;
-
-    // printf("PERIOD: %f (freq %d)\n", period, freq);
-
-    if (period >= 0.001) // ms range
-    {
-        if (mraa_pwm_period(dev->pwm, period))
-        {
-            printf("%s: mraa_pwm_period() failed.\n", __FUNCTION__);
-
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-    }
-    else // us range.  With a max of 32KHz, no less than 3.125 us.
-    {
-        if (mraa_pwm_period_us(dev->pwm, (int)(period * 1000000)))
-        {
-            printf("%s: mraa_pwm_period_us() failed.\n", __FUNCTION__);
-
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-    }
-
-    // save it for later if needed
-    dev->default_freq = freq;
-
-    // A 10% duty cycle enables better results at high frequencies
-    mraa_pwm_write(dev->pwm, 0.1);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t speaker_emit(const speaker_context dev, unsigned int freq,
-                          unsigned int emit_ms)
-{
-    assert(dev != NULL);
-
-    if (!dev->is_pwm)
-        return UPM_ERROR_NO_RESOURCES;
-
-    if (speaker_set_frequency(dev, freq))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    upm_clock_t clock = upm_clock_init();
-
-    mraa_pwm_enable(dev->pwm, 1);
-    while (upm_elapsed_ms(&clock) < emit_ms)
-        ; // loop until finished
-
-    mraa_pwm_enable(dev->pwm, 0);
-
-    return UPM_SUCCESS;
-}
-
-void speaker_on(const speaker_context dev)
-{
-    assert(dev != NULL);
-
-    if (!dev->is_pwm)
-        return;
-
-    speaker_set_frequency(dev, dev->default_freq);
-
-    mraa_pwm_enable(dev->pwm, 1);
-}
-
-void speaker_off(const speaker_context dev)
-{
-    assert(dev != NULL);
-
-    if (!dev->is_pwm)
-        return;
-
-    mraa_pwm_enable(dev->pwm, 0);
-}
-
-void speaker_play_all(const speaker_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->is_pwm)
-        return;
-
-    speaker_play_sound(dev, 'c', false, "low");
-    upm_delay_us(200000);
-    speaker_play_sound(dev, 'd', false, "low");
-    upm_delay_us(200000);
-    speaker_play_sound(dev, 'e', false, "low");
-    upm_delay_us(200000);
-    speaker_play_sound(dev, 'f', false, "low");
-    upm_delay_us(200000);
-    speaker_play_sound(dev, 'g', false, "low");
-    upm_delay_us(500000);
-    speaker_play_sound(dev, 'a', false, "low");
-    upm_delay_us(500000);
-    speaker_play_sound(dev, 'b', false, "low");
-    upm_delay_us(500000);
-}
-
-void speaker_play_sound(const speaker_context dev, char letter, bool sharp,
-                        const char *vocal_weight)
-{
-    assert(dev != NULL);
-
-    if (dev->is_pwm)
-        return;
-
-    int index = 0;
-    switch (letter)
-    {
-    case 'a':
-        index = 0;
-        break;
-    case 'b':
-        index = 1;
-        break;
-    case 'c':
-        index = 2;
-        break;
-    case 'd':
-        index = 3;
-        break;
-    case 'e':
-        index = 4;
-        break;
-    case 'f':
-        index = 5;
-        break;
-    case 'g':
-        index = 6;
-        break;
-    default:
-        printf("%s: The note '%c' is invalid.\n", __FUNCTION__, letter);
-        return;
-    }
-
-    int delayTime = 0;
-    bool valid = true;
-    if (sharp)
-    {
-        if (strstr(vocal_weight, "low"))
-            delayTime = note_list[index].delayTimeLowSharp;
-        else if (strstr(vocal_weight, "med"))
-            delayTime = note_list[index].delayTimeMedSharp;
-        else if (strstr(vocal_weight, "high"))
-            delayTime = note_list[index].delayTimeHighSharp;
-        else
-            valid = false;
-    }
-    else
-    {
-        if (strstr(vocal_weight, "low"))
-            delayTime = note_list[index].delayTimeLow;
-        else if (strstr(vocal_weight, "med"))
-            delayTime = note_list[index].delayTimeMed;
-        else if (strstr(vocal_weight, "high"))
-            delayTime = note_list[index].delayTimeHigh;
-        else
-            valid = false;
-    }
-
-    if (!valid)
-        printf("%s: Correct voice weight values are low, med, or high.\n",
-               __FUNCTION__);
-
-    // If delayTime is zero, that means you tried to choose a sharp note
-    // for a note that has no sharp
-    if (sharp && !delayTime)
-    {
-        printf("%s: the key '%c' doesn't have a sharp note.\n",
-               __FUNCTION__, letter);
-        return;
-    }
-
-    speaker_sound(dev, delayTime);
-}
-
-static void speaker_sound(const speaker_context dev, int note_delay)
-{
-    assert(dev != NULL);
-
-    for (int i=0; i<100; i++)
-    {
-        mraa_gpio_write (dev->gpio, 1);
-        upm_delay_us(note_delay);
-        mraa_gpio_write (dev->gpio, 0);
-        upm_delay_us(note_delay);
-    }
-}
diff --git a/src/speaker/speaker.cxx b/src/speaker/speaker.cxx
deleted file mode 100644
index 276e0ec..0000000
--- a/src/speaker/speaker.cxx
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Based on original C++ driver by:
- * Author: Zion Orent <sorent@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "speaker.hpp"
-
-using namespace upm;
-
-Speaker::Speaker(int pin, bool usePWM) :
-    m_speaker(nullptr)
-{
-    if (usePWM)
-        m_speaker = speaker_init_pwm(pin);
-    else
-        m_speaker = speaker_init(pin);
-
-    if (!m_speaker)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": speaker_init()/speaker_init_pwm() failed.");
-}
-
-Speaker::~Speaker()
-{
-    speaker_close(m_speaker);
-}
-
-void Speaker::playAll()
-{
-    speaker_play_all(m_speaker);
-}
-
-void Speaker::playSound(char letter, bool sharp, std::string vocalWeight)
-{
-    speaker_play_sound(m_speaker, letter, sharp, vocalWeight.c_str());
-}
-
-void Speaker::emit(unsigned int freq, unsigned int emit_ms)
-{
-    if (speaker_emit(m_speaker, freq, emit_ms))
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": speaker_emit() failed.");
-}
-
-void Speaker::setFrequency(unsigned int freq)
-{
-    if (speaker_set_frequency(m_speaker, freq))
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": speaker_set_frequency() failed.");
-}
-
-void Speaker::on()
-{
-    speaker_on(m_speaker);
-}
-
-void Speaker::off()
-{
-    speaker_off(m_speaker);
-}
diff --git a/src/speaker/speaker.h b/src/speaker/speaker.h
deleted file mode 100644
index ebebb9b..0000000
--- a/src/speaker/speaker.h
+++ /dev/null
@@ -1,171 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Based on original C++ driver by:
- * Author: Zion Orent <sorent@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <unistd.h>
-#include <mraa/gpio.h>
-#include <mraa/pwm.h>
-
-#include <upm.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    /**
-     * @file speaker.h
-     * @library speaker
-     * @brief C API for the Speaker
-     *
-     * @include speaker.c
-     */
-
-    /**
-     * Device context
-     */
-    typedef struct _speaker_context {
-        // gpio version
-        mraa_gpio_context gpio;
-
-        // pwm version
-        mraa_pwm_context  pwm;
-
-        // are using the original GPIO mechanism or PWM?
-        bool is_pwm;
-        // default frequency, or last frequency specified
-        unsigned int default_freq;
-    } *speaker_context;
-
-    /**
-     * Speaker GPIO init.  In this mode, only the speaker_play_all()
-     * and speaker_play_sound() function will work.  The other
-     * functions only support PWM mode (see speaker_init_pwm()).
-     *
-     * @param pin Digital pin to use
-     * @return Device context
-     */
-    speaker_context speaker_init(int pin);
-
-    /**
-     * Speaker PWM init.  In this mode a PWM pin is used to emit tones
-     * (within the capabilities of your PWM hardware).
-     * speaker_play_all() and speaker_play_sound() will not operate in
-     * this mode.  The default frequency is set to 1KHz.
-     *
-     * @param pin Digital PWM capable pin to use
-     * @return Device context
-     */
-    speaker_context speaker_init_pwm(int pin);
-
-    /**
-     * Speaker close function
-     *
-     * @param dev Device context
-     */
-    void speaker_close(speaker_context dev);
-
-    /**
-     * Plays all alto notes (lowest notes).  This function only
-     * operates in GPIO mode.
-     *
-     * @param dev Device context
-     */
-    void speaker_play_all(const speaker_context dev);
-
-    /**
-     * Plays a sound and a note whether it's sharp or not.  This
-     * function only operates in GPIO mode.
-     *
-     * @param dev Device context
-     * @param letter Character name of the note
-     * ('a', 'b', 'c', 'd', 'e', 'f', or 'g')
-     * @param sharp If true, plays a sharp version of the note;
-     * otherwise, does not play the note
-     * @param vocalWeight String to determine whether to play a low ("low"),
-     * a medium ("med"), or a high ("high") note
-     */
-    void speaker_play_sound(const speaker_context dev, char letter, bool sharp,
-                            const char *vocal_weight);
-
-    /**
-     * Emit a specific frequency for a given period of time and
-     * return.  This function only operates when in PWM mode (ie: the
-     * speaker context was initialized with speaker_init_pwm()).  The
-     * frequency is limited to between 50-32000Hz.  In addition, the
-     * allowable frequencies may be restricted further by the
-     * capabilities of your PWM hardware.
-     *
-     * @param dev Device context
-     * @param freq The frequency to emit. Must be between 50 and 32000Hz
-     * inclusive.
-     * @param emit_ms The number of milliseconds to emit the frequency.
-     * @return UPM result
-     */
-    upm_result_t speaker_emit(const speaker_context dev, unsigned int freq,
-                              unsigned int emit_ms);
-
-    /**
-     * Set a default frequency to be used with speaker_on() and
-     * speaker_off().  This function only operates when in PWM mode
-     * (ie: the speaker context was initialized with
-     * speaker_init_pwm()).  The frequency is limited to between
-     * 50-32000Hz.  In addition, the allowable frequencies may be
-     * restricted further by the capabilities of your PWM hardware.
-     *
-     * @param dev Device context
-     * @param freq The frequency to emit. Must be between 50 and 32000Hz
-     * inclusive.
-     * @return UPM result
-     */
-    upm_result_t speaker_set_frequency(const speaker_context dev,
-                                       unsigned int freq);
-
-    /**
-     * Turn the speaker on, and emit the frequency last specified with
-     * speaker_set_frequency() or speaker_emit().  This function only
-     * operates when in PWM mode (ie: the speaker context was
-     * initialized with speaker_init_pwm()).
-     *
-     * @param dev Device context
-     */
-    void speaker_on(const speaker_context dev);
-
-    /**
-     * Turn the speaker off.  This function only operates when in PWM
-     * mode (ie: the speaker context was initialized with
-     * speaker_init_pwm()).
-     *
-     * @param dev Device context
-     */
-    void speaker_off(const speaker_context dev);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/speaker/speaker.hpp b/src/speaker/speaker.hpp
deleted file mode 100644
index 2a4afc1..0000000
--- a/src/speaker/speaker.hpp
+++ /dev/null
@@ -1,152 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Based on original C++ driver by:
- * Author: Zion Orent <sorent@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-
-#include "speaker.h"
-
-namespace upm {
-
-    /**
-     * @brief Speaker Library
-     * @defgroup speaker libupm-speaker
-     * @ingroup seeed gpio sound hak
-     */
-
-    /**
-     * @library speaker
-     * @sensor speaker libupm-speaker
-     * @comname Speaker
-     * @altname Grove Speaker
-     * @type sound
-     * @man seeed
-     * @con gpio
-     * @kit hak
-     *
-     * @brief API for the Speaker
-     *
-     * UPM module for the Speaker.
-     * This sensor can generate different tones and sounds depending on the
-     * frequency of the input signal.
-     *
-     * It can operate in one of two modes: GPIO (default) and PWM.
-     *
-     * Depending on which mode is selected, some methods may not be
-     * usable.  In GPIO mode, the playAll() and playSound() methods
-     * are supported.  In PWM mode, setFrequency(), emit(), on() and
-     * off() are supported.  Calling a method not appropriate for the
-     * mode will have no effect.
-     *
-     * @image html speaker.jpg
-     * @snippet speaker.cxx Interesting
-     * @snippet speaker-pwm.cxx Interesting
-     */
-    class Speaker {
-    public:
-        /**
-         * Speaker constructor
-         *
-         * @param pin Digital pin to use
-         * @param usePWM If true, PWM mode will be used, otherwise
-         * GPIO mode (default) is used.
-         */
-        Speaker(int pin, bool usePWM=false);
-
-        /**
-         * Speaker destructor
-         */
-
-        virtual ~Speaker();
-        /**
-         * Plays all alto notes (lowest notes)
-         *
-         */
-
-        void playAll();
-        /**
-         * Plays a sound and a note whether it's sharp or not
-         *
-         * @param letter Character name of the note
-         * ('a', 'b', 'c', 'd', 'e', 'f', or 'g')
-         * @param sharp If true, plays a sharp version of the note;
-         * otherwise, does not play the note
-         * @param vocalWeight String to determine whether to play a
-         * low ("low"), a medium ("med"), or a high ("high") note
-         */
-        void playSound(char letter, bool sharp, std::string vocalWeight);
-
-        /**
-         * Emit a specific frequency for a given period of time and
-         * return.  This function only operates when in PWM mode.  The
-         * frequency is limited to between 50-32000Hz.  In addition,
-         * the allowable frequencies may be restricted further by the
-         * capabilities of your PWM hardware.
-         *
-         * @param freq The frequency to emit. Must be between 50 and 32000Hz
-         * inclusive.
-         * @param emit_ms The number of milliseconds to emit the frequency.
-         */
-        void emit(unsigned int freq, unsigned int emit_ms);
-
-        /**
-         * Set a default frequency to be used with on() and off().
-         * This function only operates when in PWM mode.
-         * The frequency is limited to between 50-32000Hz.  In
-         * addition, the allowable frequencies may be restricted
-         * further by the capabilities of your PWM hardware.
-         *
-         * @param freq The frequency to emit. Must be between 50 and 32000Hz
-         * inclusive.
-         */
-        void setFrequency(unsigned int freq);
-
-        /**
-         * Turn the speaker on, and emit the frequency last specified
-         * with setFrequency() or emit().  This function only operates
-         * when in PWM mode.
-         *
-         */
-        void on();
-
-        /**
-         * Turn the speaker off.  This function only operates when in
-         * PWM mode.
-         *
-         */
-        void off();
-
-    protected:
-        speaker_context m_speaker;
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        Speaker(const Speaker&) = delete;
-        Speaker &operator=(const Speaker&) = delete;
-    };
-}
diff --git a/src/speaker/speaker.json b/src/speaker/speaker.json
deleted file mode 100644
index 914e706..0000000
--- a/src/speaker/speaker.json
+++ /dev/null
@@ -1,53 +0,0 @@
-{
-    "Library": "speaker",
-    "Description": "Seeed Speaker library",
-    "Sensor Class": {
-        "Speaker": {
-            "Name": "API for the Seeed Speaker",
-            "Description": "This is the UPM Module for the Seeed Speaker. This speaker can generate different tones and sounds depending on the frequency of the input signal. It can operate in one of two modes: GPIO (default) and PWM. Depending on which mode is selected, some methods may not be usable.  In GPIO mode, the playAll() and playSound() methods are supported.  In PWM mode, setFrequency(), emit(), on() and off() are supported.  Calling a method not appropriate for the mode will have no effect.",
-            "Aliases": ["speaker", "Grove - Speaker"],
-            "Categories": ["sound"],
-            "Connections": ["gpio", "PWM"],
-            "Project Type": ["prototyping"],
-            "Manufacturers": ["Seeed"],
-            "Kits": ["hak"],
-            "Image": "speaker.jpg",
-            "Examples": {
-                "Java": ["SpeakerPWM_Example.java", "Speaker_Example.java"],
-                "Python": ["speaker_pwm.py", "speaker.py"],
-                "Node.js": ["speaker_pwm.js", "speaker.js"],
-                "C++": ["speaker-pwm.cxx", "speaker.cxx"],
-                "C": ["speaker-pwm.c", "speaker.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 4.0,
-                    "max": 5.5
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "min" : 4,
-                    "max" : 8
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": 0,
-                    "max": 70
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-Speaker-p-1445.html", "http://wiki.seeed.cc/Grove-Speaker/"],
-                "Datasheets": ["https://raw.githubusercontent.com/SeeedDocument/Grove-Speaker/master/res/LM386_Low_Voltage_Audio_Power_Amplifier_Datasheet.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/ssd1351/CMakeLists.txt b/src/ssd1351/CMakeLists.txt
deleted file mode 100644
index 1be5468..0000000
--- a/src/ssd1351/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "ssd1351")
-set (libdescription "SPI-based OLED Display")
-set (module_src ssd1351_gfx.cxx ssd1351.cxx)
-set (module_hpp ssd1351_gfx.hpp ssd1351.hpp)
-upm_module_init(mraa)
diff --git a/src/ssd1351/license.txt b/src/ssd1351/license.txt
deleted file mode 100644
index 7492e93..0000000
--- a/src/ssd1351/license.txt
+++ /dev/null
@@ -1,24 +0,0 @@
-Software License Agreement (BSD License)
-
-Copyright (c) 2012 Adafruit Industries.  All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-- Redistributions of source code must retain the above copyright notice,
-  this list of conditions and the following disclaimer.
-- Redistributions in binary form must reproduce the above copyright notice,
-  this list of conditions and the following disclaimer in the documentation
-  and/or other materials provided with the distribution.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
diff --git a/src/ssd1351/ssd1351.cxx b/src/ssd1351/ssd1351.cxx
deleted file mode 100644
index a155605..0000000
--- a/src/ssd1351/ssd1351.cxx
+++ /dev/null
@@ -1,223 +0,0 @@
-/*
- * Author: Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Based on Adafruit SSD1351 library.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-#include <unistd.h>
-#include <stdlib.h>
-
-#include "ssd1351.hpp"
-
-using namespace upm;
-using namespace std;
-
-SSD1351::SSD1351 (int oc, int dc, int rst) :
-        GFX(SSD1351WIDTH, SSD1351HEIGHT),
-        m_spi(0), m_oc(oc), m_dc(dc), m_rst(rst) {
-
-    m_name = "SSD1351";
-    m_usemap = true;
-
-    // Setup SPI bus
-    m_spi.frequency(8 * 1000000);
-    m_spi.mode(mraa::SPI_MODE0);
-    m_spi.writeByte(0x00); // Need to bring clk high before init
-
-    // Init pins
-    if (m_oc.dir(mraa::DIR_OUT) != mraa::SUCCESS) {
-        throw std::runtime_error(string(__FUNCTION__) +
-                               ": Could not initialize CS pin");
-        return;
-    }
-    if (m_dc.dir(mraa::DIR_OUT) != mraa::SUCCESS) {
-        throw std::runtime_error(string(__FUNCTION__) +
-                               ": Could not initialize data/cmd pin");
-        return;
-    }
-    if (m_rst.dir(mraa::DIR_OUT) != mraa::SUCCESS) {
-        throw std::runtime_error(string(__FUNCTION__) +
-                               ": Could not initialize reset pin");
-        return;
-    }
-
-    // Toggle reset pin
-    ocLow();
-    m_rst.write(1);
-    usleep(500000);
-    m_rst.write(0);
-    usleep(500000);
-    m_rst.write(1);
-    usleep(500000);
-
-    // Configure and init display
-    writeCommand(SSD1351_CMD_COMMANDLOCK);
-    writeData(0x12);
-
-    writeCommand(SSD1351_CMD_COMMANDLOCK);
-    writeData(0xB1);
-
-    writeCommand(SSD1351_CMD_DISPLAYOFF);
-
-    writeCommand(SSD1351_CMD_CLOCKDIV);
-    writeCommand(0xF1);
-
-    writeCommand(SSD1351_CMD_MUXRATIO);
-    writeData(127);
-
-    writeCommand(SSD1351_CMD_SETREMAP);
-    writeData(0x74);
-
-    writeCommand(SSD1351_CMD_SETCOLUMN);
-    writeData(0x00);
-    writeData(0x7F);
-
-    writeCommand(SSD1351_CMD_SETROW);
-    writeData(0x00);
-    writeData(0x7F);
-
-    writeCommand(SSD1351_CMD_STARTLINE);
-    if (SSD1351HEIGHT == 96) {
-        writeData(96);
-    } else {
-        writeData(0);
-    }
-
-    writeCommand(SSD1351_CMD_DISPLAYOFFSET);
-    writeData(0x0);
-
-    writeCommand(SSD1351_CMD_SETGPIO);
-    writeData(0x00);
-
-    writeCommand(SSD1351_CMD_FUNCTIONSELECT);
-    writeData(0x01);
-
-    writeCommand(SSD1351_CMD_PRECHARGE);
-    writeCommand(0x32);
-
-    writeCommand(SSD1351_CMD_VCOMH);
-    writeCommand(0x05);
-
-    writeCommand(SSD1351_CMD_NORMALDISPLAY);
-
-    writeCommand(SSD1351_CMD_CONTRASTABC);
-    writeData(0xC8);
-    writeData(0x80);
-    writeData(0xC8);
-
-    writeCommand(SSD1351_CMD_CONTRASTMASTER);
-    writeData(0x0F);
-
-    writeCommand(SSD1351_CMD_SETVSL );
-    writeData(0xA0);
-    writeData(0xB5);
-    writeData(0x55);
-
-    writeCommand(SSD1351_CMD_PRECHARGE2);
-    writeData(0x01);
-
-    writeCommand(SSD1351_CMD_DISPLAYON);
-}
-
-SSD1351::~SSD1351() {
-}
-
-void
-SSD1351::writeCommand (uint8_t value) {
-    dcLow();
-    m_spi.writeByte(value);
-}
-
-void
-SSD1351::writeData (uint8_t value) {
-    dcHigh ();
-    m_spi.writeByte(value);
-}
-
-void
-SSD1351::drawPixel(int16_t x, int16_t y, uint16_t color) {
-      if ((x < 0) || (y < 0) || (x >= SSD1351WIDTH) || (y >= SSD1351HEIGHT))
-          return;
-
-      if(m_usemap) {
-          int index = (y * SSD1351WIDTH + x) * 2;
-          m_map[index] = color >> 8;
-          m_map[index + 1] = color;
-      } else {
-          writeCommand(SSD1351_CMD_SETCOLUMN);
-          writeData(x);
-          writeData(SSD1351WIDTH-1);
-
-          writeCommand(SSD1351_CMD_SETROW);
-          writeData(y);
-          writeData(SSD1351HEIGHT-1);
-
-          writeCommand(SSD1351_CMD_WRITERAM);
-          writeData(color >> 8);
-          writeData(color);
-      }
-}
-void
-SSD1351::refresh () {
-    writeCommand(SSD1351_CMD_WRITERAM);
-    int blockSize = SSD1351HEIGHT * SSD1351WIDTH * 2 / BLOCKS;
-    dcHigh();
-    for (int block = 0; block < BLOCKS; block++) {
-        m_spi.write(&m_map[block * blockSize], blockSize);
-    }
-}
-void
-SSD1351::ocLow() {
-    if (m_oc.write(LOW) != mraa::SUCCESS) {
-        throw std::runtime_error(string(__FUNCTION__) +
-                               ": Failed to write CS pin");
-    }
-}
-void
-SSD1351::ocHigh() {
-    if (m_oc.write(HIGH) != mraa::SUCCESS) {
-        throw std::runtime_error(string(__FUNCTION__) +
-                               ": Failed to write CS pin");
-    }
-}
-void
-SSD1351::dcLow() {
-    if (m_dc.write(LOW) != mraa::SUCCESS) {
-        throw std::runtime_error(string(__FUNCTION__) +
-                               ": Failed to write data/cmd pin");
-    }
-}
-void
-SSD1351::dcHigh() {
-    if (m_dc.write(HIGH) != mraa::SUCCESS) {
-        throw std::runtime_error(string(__FUNCTION__) +
-                               ": Failed to write data/cmd pin");
-    }
-}
-void
-upm::SSD1351::useMemoryMap(bool var) {
-    m_usemap = var;
-}
diff --git a/src/ssd1351/ssd1351.hpp b/src/ssd1351/ssd1351.hpp
deleted file mode 100644
index aca4ca4..0000000
--- a/src/ssd1351/ssd1351.hpp
+++ /dev/null
@@ -1,193 +0,0 @@
-/*
- * Author: Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Based on Adafruit SSD1351 library.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-
-#include <mraa/gpio.hpp>
-#include <mraa/spi.hpp>
-#include "ssd1351_gfx.hpp"
-
-// Display Size
-#define SSD1351WIDTH 128
-#define SSD1351HEIGHT 128  // Set this to 96 for 1.27"
-
-// SSD1351 Commands
-#define SSD1351_CMD_SETCOLUMN       0x15
-#define SSD1351_CMD_SETROW          0x75
-#define SSD1351_CMD_WRITERAM        0x5C
-#define SSD1351_CMD_READRAM         0x5D
-#define SSD1351_CMD_SETREMAP        0xA0
-#define SSD1351_CMD_STARTLINE       0xA1
-#define SSD1351_CMD_DISPLAYOFFSET   0xA2
-#define SSD1351_CMD_DISPLAYALLOFF   0xA4
-#define SSD1351_CMD_DISPLAYALLON    0xA5
-#define SSD1351_CMD_NORMALDISPLAY   0xA6
-#define SSD1351_CMD_INVERTDISPLAY   0xA7
-#define SSD1351_CMD_FUNCTIONSELECT  0xAB
-#define SSD1351_CMD_DISPLAYOFF      0xAE
-#define SSD1351_CMD_DISPLAYON       0xAF
-#define SSD1351_CMD_PRECHARGE       0xB1
-#define SSD1351_CMD_DISPLAYENHANCE  0xB2
-#define SSD1351_CMD_CLOCKDIV        0xB3
-#define SSD1351_CMD_SETVSL          0xB4
-#define SSD1351_CMD_SETGPIO         0xB5
-#define SSD1351_CMD_PRECHARGE2      0xB6
-#define SSD1351_CMD_SETGRAY         0xB8
-#define SSD1351_CMD_USELUT          0xB9
-#define SSD1351_CMD_PRECHARGELEVEL  0xBB
-#define SSD1351_CMD_VCOMH           0xBE
-#define SSD1351_CMD_CONTRASTABC     0xC1
-#define SSD1351_CMD_CONTRASTMASTER  0xC7
-#define SSD1351_CMD_MUXRATIO        0xCA
-#define SSD1351_CMD_COMMANDLOCK     0xFD
-#define SSD1351_CMD_HORIZSCROLL     0x96
-#define SSD1351_CMD_STOPSCROLL      0x9E
-#define SSD1351_CMD_STARTSCROLL     0x9F
-
-#define HIGH                1
-#define LOW                 0
-
-// Number of blocks for SPI transfer of buffer
-#define BLOCKS              8
-
-namespace upm {
-/**
- * @brief SSD1351 OLED Display Controller
- * @defgroup ssd1351 libupm-ssd1351
- * @ingroup adafruit spi display
- */
-/**
- * @library ssd1351
- * @sensor ssd1351
- * @comname SPI-based OLED Display
- * @type display
- * @man adafruit
- * @web http://www.adafruit.com/products/1431
- * @con spi
- *
- * @brief API for SSD1351 OLED displays
- *
- * This module defines the interface for the SSD1351 display library. It was
- * tested with the Adafruit 1.5" OLED Display, but should work with any SSD1351
- * display running in SPI mode.
- *
- * On the Intel Edison don't forget to disable SPI Power Management (PM) for
- * this driver to work, you can find more details on this topic here:
- * http://iotdk.intel.com/docs/master/mraa/edison.html
- *
- * @image html ssd1351.jpg
- * @snippet ssd1351.cxx Interesting
- */
-class SSD1351 : public GFX{
-    public:
-        /**
-         * Instantiates an SSD1351 object
-         *
-         * @param oc LCD chip select pin
-         * @param dc Data/command pin
-         * @param rst Reset pin
-         */
-        SSD1351 (int oc, int dc, int rst);
-
-        /**
-         * SSD1351 object destructor
-         */
-        ~SSD1351();
-
-        /**
-         * Returns the name of the component
-         */
-        std::string name()
-        {
-            return m_name;
-        }
-
-        /**
-         * Sends a command to an SPI bus
-         *
-         * @param value Command
-         */
-        void writeCommand (uint8_t value);
-
-        /**
-         * Sends data to an SPI bus
-         *
-         * @param value Data
-         */
-        void writeData (uint8_t value);
-        /**
-         * Sends a pixel color (RGB) to the display buffer or chip
-         *
-         * @param x Axis on the horizontal scale
-         * @param y Axis on the vertical scale
-         * @param color RGB (16-bit) color (R[0-4], G[5-10], B[11-15])
-         */
-        void drawPixel (int16_t x, int16_t y, uint16_t color);
-
-        /**
-         * Copies the buffer to the chip via the SPI bus
-         */
-        void refresh ();
-
-        /**
-         * Set OLED chip select LOW
-         */
-        void ocLow ();
-
-        /**
-         * Set OLED chip select HIGH
-         */
-        void ocHigh ();
-
-        /**
-         * Data select LOW
-         */
-        void dcLow ();
-
-        /**
-         * Data select HIGH
-         */
-        void dcHigh ();
-
-        /**
-         * Use memory mapped (buffered) writes to the display
-         *
-         * @param var true for yes (default), false for no
-         */
-        void useMemoryMap (bool var);
-    private:
-        mraa::Spi       m_spi;
-        uint8_t         m_map[SSD1351HEIGHT * SSD1351WIDTH * 2]; /**< Screen buffer */
-        bool            m_usemap;
-
-        mraa::Gpio      m_oc;
-        mraa::Gpio      m_dc;
-        mraa::Gpio      m_rst;
-
-        std::string     m_name;
-};
-}
diff --git a/src/ssd1351/ssd1351.i b/src/ssd1351/ssd1351.i
deleted file mode 100644
index 6c68582..0000000
--- a/src/ssd1351/ssd1351.i
+++ /dev/null
@@ -1,19 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%ignore font;
-%ignore m_map;
-
-JAVA_JNI_LOADLIBRARY(javaupm_ssd1351)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "ssd1351.hpp"
-#include "ssd1351_gfx.hpp"
-%}
-%include "ssd1351_gfx.hpp"
-%include "ssd1351.hpp"
-/* END Common SWIG syntax */
diff --git a/src/ssd1351/ssd1351.json b/src/ssd1351/ssd1351.json
deleted file mode 100644
index 6f26299..0000000
--- a/src/ssd1351/ssd1351.json
+++ /dev/null
@@ -1,49 +0,0 @@
-{
-    "Library": "ssd1351",
-    "Description": "Adafruit SSD1351 OLED library",
-    "Sensor Class": {
-        "SSD1351": {
-            "Name": "API for the Adafruit SSD1351 OLED displays",
-            "Description": "This is the UPM Module for the Adafruit SSD1351 OLED displays. It was tested with the Adafruit 1.5\" OLED Display, but should work with any SSD1351 display running in SPI mode. On the Intel Edison don't forget to disable SPI Power Management (PM) for this driver to work, you can find more details on this topic here: http://iotdk.intel.com/docs/master/mraa/edison.html",
-            "Aliases": ["ssd1351", "OLED Breakout Board - 16-bit Color 1.5\" w/microSD holder"],
-            "Categories": ["display"],
-            "Connections": ["spi"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["Adafruit", "Slomon Systech", "Univision"],
-            "Image": "ssd1351.jpg",
-            "Examples": {
-                "C++": ["ssd1351.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.3,
-                    "max": 5.0
-                },
-                "Supply Current": {
-                    "unit": "uA",
-                    "min" : 10,
-                    "max" : 1260
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Resolution": {
-                    "unit": "pixels",
-                    "height": 128,
-                    "width": 128
-                },
-                "Color Resolution": {
-                    "unit": "bits",
-                    "resolution": 14
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.adafruit.com/product/1431"],
-                "Datasheets": ["https://cdn-shop.adafruit.com/datasheets/SSD1351-Revision+1.3.pdf", "https://cdn-shop.adafruit.com/datasheets/UG-2828GDEDF11.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/ssd1351/ssd1351_gfx.cxx b/src/ssd1351/ssd1351_gfx.cxx
deleted file mode 100644
index 5cfebc3..0000000
--- a/src/ssd1351/ssd1351_gfx.cxx
+++ /dev/null
@@ -1,220 +0,0 @@
-/*
- * Authors: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- *          Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- *
- * Copyright (c) 2016 Intel Corporation.
- *
- * Based on GFX interface by Yevgeniy Kiveisha and Adafruit Industries.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <unistd.h>
-#include <stdlib.h>
-
-#include "ssd1351_gfx.hpp"
-
-using namespace upm;
-
-GFX::GFX (int width, int height) : m_width(width), m_height(height),
-        m_textSize(1), m_textColor(0xFFFF), m_textBGColor(0x0000),
-        m_cursorX(0), m_cursorY(0), m_font(font) {
-}
-
-GFX::~GFX () {
-}
-
-void
-GFX::fillScreen (uint16_t color) {
-    fillRect(0, 0, m_width, m_height, color);
-}
-
-void
-GFX::fillRect (int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color) {
-    for (int16_t i=x; i<x+w; i++) {
-        drawFastVLine(i, y, h, color);
-    }
-}
-
-void
-GFX::drawFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color) {
-    drawLine(x, y, x, y+h-1, color);
-}
-
-void
-GFX::drawLine (int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) {
-    int16_t steep = abs(y1 - y0) > abs(x1 - x0);
-
-    if (steep) {
-        swap(x0, y0);
-        swap(x1, y1);
-    }
-
-    if (x0 > x1) {
-        swap(x0, x1);
-        swap(y0, y1);
-    }
-
-    int16_t dx, dy;
-    dx = x1 - x0;
-    dy = abs (y1 - y0);
-
-    int16_t err = dx / 2;
-    int16_t ystep;
-
-    if (y0 < y1) {
-        ystep = 1;
-    } else {
-        ystep = -1;
-    }
-
-    for (; x0 <= x1; x0++) {
-        if (steep) {
-            drawPixel(y0, x0, color);
-        } else {
-            drawPixel(x0, y0, color);
-        }
-        err -= dy;
-        if (err < 0) {
-            y0 += ystep;
-            err += dx;
-        }
-    }
-}
-
-void
-GFX::drawTriangle(int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color) {
-    drawLine(x0, y0, x1, y1, color);
-    drawLine(x1, y1, x2, y2, color);
-    drawLine(x2, y2, x0, y0, color);
-}
-
-void
-GFX::drawCircle(int16_t x0, int16_t y0, int16_t r, uint16_t color) {
-    int16_t f = 1 - r;
-    int16_t ddF_x = 1;
-    int16_t ddF_y = -2 * r;
-    int16_t x = 0;
-    int16_t y = r;
-
-    drawPixel(x0  , y0+r, color);
-    drawPixel(x0  , y0-r, color);
-    drawPixel(x0+r, y0  , color);
-    drawPixel(x0-r, y0  , color);
-
-    while (x<y) {
-        if (f >= 0) {
-            y--;
-            ddF_y += 2;
-            f += ddF_y;
-        }
-        x++;
-
-        ddF_x += 2;
-        f += ddF_x;
-
-        drawPixel(x0 + x, y0 + y, color);
-        drawPixel(x0 - x, y0 + y, color);
-        drawPixel(x0 + x, y0 - y, color);
-        drawPixel(x0 - x, y0 - y, color);
-        drawPixel(x0 + y, y0 + x, color);
-        drawPixel(x0 - y, y0 + x, color);
-        drawPixel(x0 + y, y0 - x, color);
-        drawPixel(x0 - y, y0 - x, color);
-    }
-}
-
-void
-GFX::setCursor (int16_t x, int16_t y) {
-    m_cursorX = x;
-    m_cursorY = y;
-}
-
-void
-GFX::setTextColor (uint16_t textColor, uint16_t textBGColor) {
-    m_textColor   = textColor;
-    m_textBGColor = textBGColor;
-}
-
-void
-GFX::setTextSize (uint8_t size) {
-    m_textSize = (size > 0) ? size : 1;
-}
-
-void
-GFX::setTextWrap (uint8_t wrap) {
-    m_wrap = wrap;
-}
-
-void
-GFX::drawChar (int16_t x, int16_t y, uint8_t data, uint16_t color, uint16_t bg, uint8_t size) {
-    if( (x >= m_width)            || // Clip right
-        (y >= m_height)           || // Clip bottom
-        ((x + 6 * size - 1) < 0)  || // Clip left
-        ((y + 8 * size - 1) < 0))    // Clip top
-    return;
-
-    for (int8_t i=0; i<6; i++ ) {
-        uint8_t line;
-        if (i == 5) {
-            line = 0x0;
-        } else {
-            line = *(m_font+(data * 5)+i);
-            for (int8_t j = 0; j<8; j++) {
-                if (line & 0x1) {
-                    if (size == 1) // default size
-                        drawPixel (x+i, y+j, color);
-                    else {  // big size
-                        fillRect (x+(i*size), y+(j*size), size, size, color);
-                    }
-                } else if (bg != color) {
-                    if (size == 1) // default size
-                        drawPixel (x+i, y+j, bg);
-                    else {  // big size
-                        fillRect (x+i*size, y+j*size, size, size, bg);
-                    }
-                }
-                line >>= 1;
-            }
-        }
-    }
-}
-
-void
-GFX::print (std::string msg) {
-    int len = msg.length();
-
-    for (int idx = 0; idx < len; idx++) {
-        if (msg[idx] == '\n') {
-            m_cursorY += m_textSize * 8;
-            m_cursorX  = 0;
-        } else if (msg[idx] == '\r') {
-            // skip em
-        } else {
-            drawChar(m_cursorX, m_cursorY, msg[idx], m_textColor, m_textBGColor, m_textSize);
-            m_cursorX += m_textSize * 6;
-            if (m_wrap && ((m_cursorX + m_textSize * 6) >= m_width)) {
-                m_cursorY += m_textSize * 8;
-                m_cursorX = 0;
-            }
-        }
-    }
-}
diff --git a/src/ssd1351/ssd1351_gfx.hpp b/src/ssd1351/ssd1351_gfx.hpp
deleted file mode 100644
index 785ad0b..0000000
--- a/src/ssd1351/ssd1351_gfx.hpp
+++ /dev/null
@@ -1,455 +0,0 @@
-/*
- * Authors: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- *          Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- *
- * Copyright (c) 2016 Intel Corporation.
- *
- * Based on GFX interface by Yevgeniy Kiveisha and Adafruit Industries.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <stdio.h>
-#include <unistd.h>
-#include <stdint.h>
-
-#define swap(a, b) { int16_t t = a; a = b; b = t; }
-
-namespace upm {
-
-const unsigned char font[] = {
-    0x00, 0x00, 0x00, 0x00, 0x00,
-    0x3E, 0x5B, 0x4F, 0x5B, 0x3E,
-    0x3E, 0x6B, 0x4F, 0x6B, 0x3E,
-    0x1C, 0x3E, 0x7C, 0x3E, 0x1C,
-    0x18, 0x3C, 0x7E, 0x3C, 0x18,
-    0x1C, 0x57, 0x7D, 0x57, 0x1C,
-    0x1C, 0x5E, 0x7F, 0x5E, 0x1C,
-    0x00, 0x18, 0x3C, 0x18, 0x00,
-    0xFF, 0xE7, 0xC3, 0xE7, 0xFF,
-    0x00, 0x18, 0x24, 0x18, 0x00,
-    0xFF, 0xE7, 0xDB, 0xE7, 0xFF,
-    0x30, 0x48, 0x3A, 0x06, 0x0E,
-    0x26, 0x29, 0x79, 0x29, 0x26,
-    0x40, 0x7F, 0x05, 0x05, 0x07,
-    0x40, 0x7F, 0x05, 0x25, 0x3F,
-    0x5A, 0x3C, 0xE7, 0x3C, 0x5A,
-    0x7F, 0x3E, 0x1C, 0x1C, 0x08,
-    0x08, 0x1C, 0x1C, 0x3E, 0x7F,
-    0x14, 0x22, 0x7F, 0x22, 0x14,
-    0x5F, 0x5F, 0x00, 0x5F, 0x5F,
-    0x06, 0x09, 0x7F, 0x01, 0x7F,
-    0x00, 0x66, 0x89, 0x95, 0x6A,
-    0x60, 0x60, 0x60, 0x60, 0x60,
-    0x94, 0xA2, 0xFF, 0xA2, 0x94,
-    0x08, 0x04, 0x7E, 0x04, 0x08,
-    0x10, 0x20, 0x7E, 0x20, 0x10,
-    0x08, 0x08, 0x2A, 0x1C, 0x08,
-    0x08, 0x1C, 0x2A, 0x08, 0x08,
-    0x1E, 0x10, 0x10, 0x10, 0x10,
-    0x0C, 0x1E, 0x0C, 0x1E, 0x0C,
-    0x30, 0x38, 0x3E, 0x38, 0x30,
-    0x06, 0x0E, 0x3E, 0x0E, 0x06,
-    0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x5F, 0x00, 0x00,
-    0x00, 0x07, 0x00, 0x07, 0x00,
-    0x14, 0x7F, 0x14, 0x7F, 0x14,
-    0x24, 0x2A, 0x7F, 0x2A, 0x12,
-    0x23, 0x13, 0x08, 0x64, 0x62,
-    0x36, 0x49, 0x56, 0x20, 0x50,
-    0x00, 0x08, 0x07, 0x03, 0x00,
-    0x00, 0x1C, 0x22, 0x41, 0x00,
-    0x00, 0x41, 0x22, 0x1C, 0x00,
-    0x2A, 0x1C, 0x7F, 0x1C, 0x2A,
-    0x08, 0x08, 0x3E, 0x08, 0x08,
-    0x00, 0x80, 0x70, 0x30, 0x00,
-    0x08, 0x08, 0x08, 0x08, 0x08,
-    0x00, 0x00, 0x60, 0x60, 0x00,
-    0x20, 0x10, 0x08, 0x04, 0x02,
-    0x3E, 0x51, 0x49, 0x45, 0x3E,
-    0x00, 0x42, 0x7F, 0x40, 0x00,
-    0x72, 0x49, 0x49, 0x49, 0x46,
-    0x21, 0x41, 0x49, 0x4D, 0x33,
-    0x18, 0x14, 0x12, 0x7F, 0x10,
-    0x27, 0x45, 0x45, 0x45, 0x39,
-    0x3C, 0x4A, 0x49, 0x49, 0x31,
-    0x41, 0x21, 0x11, 0x09, 0x07,
-    0x36, 0x49, 0x49, 0x49, 0x36,
-    0x46, 0x49, 0x49, 0x29, 0x1E,
-    0x00, 0x00, 0x14, 0x00, 0x00,
-    0x00, 0x40, 0x34, 0x00, 0x00,
-    0x00, 0x08, 0x14, 0x22, 0x41,
-    0x14, 0x14, 0x14, 0x14, 0x14,
-    0x00, 0x41, 0x22, 0x14, 0x08,
-    0x02, 0x01, 0x59, 0x09, 0x06,
-    0x3E, 0x41, 0x5D, 0x59, 0x4E,
-    0x7C, 0x12, 0x11, 0x12, 0x7C,
-    0x7F, 0x49, 0x49, 0x49, 0x36,
-    0x3E, 0x41, 0x41, 0x41, 0x22,
-    0x7F, 0x41, 0x41, 0x41, 0x3E,
-    0x7F, 0x49, 0x49, 0x49, 0x41,
-    0x7F, 0x09, 0x09, 0x09, 0x01,
-    0x3E, 0x41, 0x41, 0x51, 0x73,
-    0x7F, 0x08, 0x08, 0x08, 0x7F,
-    0x00, 0x41, 0x7F, 0x41, 0x00,
-    0x20, 0x40, 0x41, 0x3F, 0x01,
-    0x7F, 0x08, 0x14, 0x22, 0x41,
-    0x7F, 0x40, 0x40, 0x40, 0x40,
-    0x7F, 0x02, 0x1C, 0x02, 0x7F,
-    0x7F, 0x04, 0x08, 0x10, 0x7F,
-    0x3E, 0x41, 0x41, 0x41, 0x3E,
-    0x7F, 0x09, 0x09, 0x09, 0x06,
-    0x3E, 0x41, 0x51, 0x21, 0x5E,
-    0x7F, 0x09, 0x19, 0x29, 0x46,
-    0x26, 0x49, 0x49, 0x49, 0x32,
-    0x03, 0x01, 0x7F, 0x01, 0x03,
-    0x3F, 0x40, 0x40, 0x40, 0x3F,
-    0x1F, 0x20, 0x40, 0x20, 0x1F,
-    0x3F, 0x40, 0x38, 0x40, 0x3F,
-    0x63, 0x14, 0x08, 0x14, 0x63,
-    0x03, 0x04, 0x78, 0x04, 0x03,
-    0x61, 0x59, 0x49, 0x4D, 0x43,
-    0x00, 0x7F, 0x41, 0x41, 0x41,
-    0x02, 0x04, 0x08, 0x10, 0x20,
-    0x00, 0x41, 0x41, 0x41, 0x7F,
-    0x04, 0x02, 0x01, 0x02, 0x04,
-    0x40, 0x40, 0x40, 0x40, 0x40,
-    0x00, 0x03, 0x07, 0x08, 0x00,
-    0x20, 0x54, 0x54, 0x78, 0x40,
-    0x7F, 0x28, 0x44, 0x44, 0x38,
-    0x38, 0x44, 0x44, 0x44, 0x28,
-    0x38, 0x44, 0x44, 0x28, 0x7F,
-    0x38, 0x54, 0x54, 0x54, 0x18,
-    0x00, 0x08, 0x7E, 0x09, 0x02,
-    0x18, 0xA4, 0xA4, 0x9C, 0x78,
-    0x7F, 0x08, 0x04, 0x04, 0x78,
-    0x00, 0x44, 0x7D, 0x40, 0x00,
-    0x20, 0x40, 0x40, 0x3D, 0x00,
-    0x7F, 0x10, 0x28, 0x44, 0x00,
-    0x00, 0x41, 0x7F, 0x40, 0x00,
-    0x7C, 0x04, 0x78, 0x04, 0x78,
-    0x7C, 0x08, 0x04, 0x04, 0x78,
-    0x38, 0x44, 0x44, 0x44, 0x38,
-    0xFC, 0x18, 0x24, 0x24, 0x18,
-    0x18, 0x24, 0x24, 0x18, 0xFC,
-    0x7C, 0x08, 0x04, 0x04, 0x08,
-    0x48, 0x54, 0x54, 0x54, 0x24,
-    0x04, 0x04, 0x3F, 0x44, 0x24,
-    0x3C, 0x40, 0x40, 0x20, 0x7C,
-    0x1C, 0x20, 0x40, 0x20, 0x1C,
-    0x3C, 0x40, 0x30, 0x40, 0x3C,
-    0x44, 0x28, 0x10, 0x28, 0x44,
-    0x4C, 0x90, 0x90, 0x90, 0x7C,
-    0x44, 0x64, 0x54, 0x4C, 0x44,
-    0x00, 0x08, 0x36, 0x41, 0x00,
-    0x00, 0x00, 0x77, 0x00, 0x00,
-    0x00, 0x41, 0x36, 0x08, 0x00,
-    0x02, 0x01, 0x02, 0x04, 0x02,
-    0x3C, 0x26, 0x23, 0x26, 0x3C,
-    0x1E, 0xA1, 0xA1, 0x61, 0x12,
-    0x3A, 0x40, 0x40, 0x20, 0x7A,
-    0x38, 0x54, 0x54, 0x55, 0x59,
-    0x21, 0x55, 0x55, 0x79, 0x41,
-    0x21, 0x54, 0x54, 0x78, 0x41,
-    0x21, 0x55, 0x54, 0x78, 0x40,
-    0x20, 0x54, 0x55, 0x79, 0x40,
-    0x0C, 0x1E, 0x52, 0x72, 0x12,
-    0x39, 0x55, 0x55, 0x55, 0x59,
-    0x39, 0x54, 0x54, 0x54, 0x59,
-    0x39, 0x55, 0x54, 0x54, 0x58,
-    0x00, 0x00, 0x45, 0x7C, 0x41,
-    0x00, 0x02, 0x45, 0x7D, 0x42,
-    0x00, 0x01, 0x45, 0x7C, 0x40,
-    0xF0, 0x29, 0x24, 0x29, 0xF0,
-    0xF0, 0x28, 0x25, 0x28, 0xF0,
-    0x7C, 0x54, 0x55, 0x45, 0x00,
-    0x20, 0x54, 0x54, 0x7C, 0x54,
-    0x7C, 0x0A, 0x09, 0x7F, 0x49,
-    0x32, 0x49, 0x49, 0x49, 0x32,
-    0x32, 0x48, 0x48, 0x48, 0x32,
-    0x32, 0x4A, 0x48, 0x48, 0x30,
-    0x3A, 0x41, 0x41, 0x21, 0x7A,
-    0x3A, 0x42, 0x40, 0x20, 0x78,
-    0x00, 0x9D, 0xA0, 0xA0, 0x7D,
-    0x39, 0x44, 0x44, 0x44, 0x39,
-    0x3D, 0x40, 0x40, 0x40, 0x3D,
-    0x3C, 0x24, 0xFF, 0x24, 0x24,
-    0x48, 0x7E, 0x49, 0x43, 0x66,
-    0x2B, 0x2F, 0xFC, 0x2F, 0x2B,
-    0xFF, 0x09, 0x29, 0xF6, 0x20,
-    0xC0, 0x88, 0x7E, 0x09, 0x03,
-    0x20, 0x54, 0x54, 0x79, 0x41,
-    0x00, 0x00, 0x44, 0x7D, 0x41,
-    0x30, 0x48, 0x48, 0x4A, 0x32,
-    0x38, 0x40, 0x40, 0x22, 0x7A,
-    0x00, 0x7A, 0x0A, 0x0A, 0x72,
-    0x7D, 0x0D, 0x19, 0x31, 0x7D,
-    0x26, 0x29, 0x29, 0x2F, 0x28,
-    0x26, 0x29, 0x29, 0x29, 0x26,
-    0x30, 0x48, 0x4D, 0x40, 0x20,
-    0x38, 0x08, 0x08, 0x08, 0x08,
-    0x08, 0x08, 0x08, 0x08, 0x38,
-    0x2F, 0x10, 0xC8, 0xAC, 0xBA,
-    0x2F, 0x10, 0x28, 0x34, 0xFA,
-    0x00, 0x00, 0x7B, 0x00, 0x00,
-    0x08, 0x14, 0x2A, 0x14, 0x22,
-    0x22, 0x14, 0x2A, 0x14, 0x08,
-    0xAA, 0x00, 0x55, 0x00, 0xAA,
-    0xAA, 0x55, 0xAA, 0x55, 0xAA,
-    0x00, 0x00, 0x00, 0xFF, 0x00,
-    0x10, 0x10, 0x10, 0xFF, 0x00,
-    0x14, 0x14, 0x14, 0xFF, 0x00,
-    0x10, 0x10, 0xFF, 0x00, 0xFF,
-    0x10, 0x10, 0xF0, 0x10, 0xF0,
-    0x14, 0x14, 0x14, 0xFC, 0x00,
-    0x14, 0x14, 0xF7, 0x00, 0xFF,
-    0x00, 0x00, 0xFF, 0x00, 0xFF,
-    0x14, 0x14, 0xF4, 0x04, 0xFC,
-    0x14, 0x14, 0x17, 0x10, 0x1F,
-    0x10, 0x10, 0x1F, 0x10, 0x1F,
-    0x14, 0x14, 0x14, 0x1F, 0x00,
-    0x10, 0x10, 0x10, 0xF0, 0x00,
-    0x00, 0x00, 0x00, 0x1F, 0x10,
-    0x10, 0x10, 0x10, 0x1F, 0x10,
-    0x10, 0x10, 0x10, 0xF0, 0x10,
-    0x00, 0x00, 0x00, 0xFF, 0x10,
-    0x10, 0x10, 0x10, 0x10, 0x10,
-    0x10, 0x10, 0x10, 0xFF, 0x10,
-    0x00, 0x00, 0x00, 0xFF, 0x14,
-    0x00, 0x00, 0xFF, 0x00, 0xFF,
-    0x00, 0x00, 0x1F, 0x10, 0x17,
-    0x00, 0x00, 0xFC, 0x04, 0xF4,
-    0x14, 0x14, 0x17, 0x10, 0x17,
-    0x14, 0x14, 0xF4, 0x04, 0xF4,
-    0x00, 0x00, 0xFF, 0x00, 0xF7,
-    0x14, 0x14, 0x14, 0x14, 0x14,
-    0x14, 0x14, 0xF7, 0x00, 0xF7,
-    0x14, 0x14, 0x14, 0x17, 0x14,
-    0x10, 0x10, 0x1F, 0x10, 0x1F,
-    0x14, 0x14, 0x14, 0xF4, 0x14,
-    0x10, 0x10, 0xF0, 0x10, 0xF0,
-    0x00, 0x00, 0x1F, 0x10, 0x1F,
-    0x00, 0x00, 0x00, 0x1F, 0x14,
-    0x00, 0x00, 0x00, 0xFC, 0x14,
-    0x00, 0x00, 0xF0, 0x10, 0xF0,
-    0x10, 0x10, 0xFF, 0x10, 0xFF,
-    0x14, 0x14, 0x14, 0xFF, 0x14,
-    0x10, 0x10, 0x10, 0x1F, 0x00,
-    0x00, 0x00, 0x00, 0xF0, 0x10,
-    0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-    0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
-    0xFF, 0xFF, 0xFF, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0xFF, 0xFF,
-    0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
-    0x38, 0x44, 0x44, 0x38, 0x44,
-    0x7C, 0x2A, 0x2A, 0x3E, 0x14,
-    0x7E, 0x02, 0x02, 0x06, 0x06,
-    0x02, 0x7E, 0x02, 0x7E, 0x02,
-    0x63, 0x55, 0x49, 0x41, 0x63,
-    0x38, 0x44, 0x44, 0x3C, 0x04,
-    0x40, 0x7E, 0x20, 0x1E, 0x20,
-    0x06, 0x02, 0x7E, 0x02, 0x02,
-    0x99, 0xA5, 0xE7, 0xA5, 0x99,
-    0x1C, 0x2A, 0x49, 0x2A, 0x1C,
-    0x4C, 0x72, 0x01, 0x72, 0x4C,
-    0x30, 0x4A, 0x4D, 0x4D, 0x30,
-    0x30, 0x48, 0x78, 0x48, 0x30,
-    0xBC, 0x62, 0x5A, 0x46, 0x3D,
-    0x3E, 0x49, 0x49, 0x49, 0x00,
-    0x7E, 0x01, 0x01, 0x01, 0x7E,
-    0x2A, 0x2A, 0x2A, 0x2A, 0x2A,
-    0x44, 0x44, 0x5F, 0x44, 0x44,
-    0x40, 0x51, 0x4A, 0x44, 0x40,
-    0x40, 0x44, 0x4A, 0x51, 0x40,
-    0x00, 0x00, 0xFF, 0x01, 0x03,
-    0xE0, 0x80, 0xFF, 0x00, 0x00,
-    0x08, 0x08, 0x6B, 0x6B, 0x08,
-    0x36, 0x12, 0x36, 0x24, 0x36,
-    0x06, 0x0F, 0x09, 0x0F, 0x06,
-    0x00, 0x00, 0x18, 0x18, 0x00,
-    0x00, 0x00, 0x10, 0x10, 0x00,
-    0x30, 0x40, 0xFF, 0x01, 0x01,
-    0x00, 0x1F, 0x01, 0x01, 0x1E,
-    0x00, 0x19, 0x1D, 0x17, 0x12,
-    0x00, 0x3C, 0x3C, 0x3C, 0x3C,
-    0x00, 0x00, 0x00, 0x00, 0x00
-};
-
-/**
- * @brief GFX helper class
- *
- * This file is used by the screen.
- */
-class GFX {
-    public:
-        /**
-         * Instantiates a GFX object
-         *
-         * @param width Screen width
-         * @param height Screen height
-         */
-        GFX (int width, int height);
-
-        /**
-         * GFX object destructor
-         */
-        virtual ~GFX ();
-
-        /**
-         * Sends a pixel color (RGB) to the chip. Must be implemented by the
-         * inherited class.
-         *
-         * @param x Axis on the horizontal scale
-         * @param y Axis on the vertical scale
-         * @param color RGB value
-         */
-        virtual void drawPixel (int16_t x, int16_t y, uint16_t color) = 0;
-
-        /**
-         * Copies the buffer to the chip via the SPI.
-         */
-        virtual void refresh () = 0;
-
-        /**
-         *
-         *
-         * @param x Axis on the horizontal scale
-         * @param y Axis on the vertical scale
-         * @param data Character to write
-         * @param color Character color
-         * @param bg Character background color
-         * @param size Size of the font
-         */
-        void drawChar (int16_t x, int16_t y, uint8_t data, uint16_t color, uint16_t bg, uint8_t size);
-
-        /**
-         * Prints a message on the screen
-         *
-         * @param msg Message to print
-         */
-        void print (std::string msg);
-
-        /**
-         * Fills the screen with a selected color
-         *
-         * @param color Selected color
-         */
-        void fillScreen (uint16_t color);
-
-        /**
-         * Fills a rectangle with a selected color
-         *
-         * @param x Axis on the horizontal scale (top-left corner)
-         * @param y Axis on the vertical scale (top-left corner)
-         * @param w Distanse from x
-         * @param h Distanse from y
-         * @param color Selected color
-         */
-        void fillRect (int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color);
-
-        /**
-         * Draws a line on the vertical scale
-         *
-         * @param x Axis on the horizontal scale
-         * @param y Axis on the vertical scale
-         * @param h Distanse from y
-         * @param color Selected color
-         */
-        void drawFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color);
-
-        /**
-         * Draws a line from coordinate C0 to coordinate C1
-         *
-         * @param x0 First coordinate
-         * @param y0 First coordinate
-         * @param x1 Second coordinate
-         * @param y1 Second coordinate
-         * @param color selected color
-         */
-        void drawLine (int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color);
-
-        /**
-         * Draws a triangle
-         *
-         * @param x0 First coordinate
-         * @param y0 First coordinate
-         * @param x1 Second coordinate
-         * @param y1 Second coordinate
-         * @param x2 Third coordinate
-         * @param y2 Third coordinate
-         * @param color Selected color
-         */
-        void drawTriangle (int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color);
-
-        /**
-         * Draws a circle
-         *
-         * @param x Center of the circle on the horizontal scale
-         * @param y Center of the circle on the vertical scale
-         * @param r Radius of the circle
-         * @param color Color of the circle
-         */
-        void drawCircle (int16_t x, int16_t y, int16_t r, uint16_t color);
-
-        /**
-         * Sets the cursor for a text message
-         *
-         * @param x Axis on the horizontal scale
-         * @param y Axis on the vertical scale
-         */
-        void setCursor (int16_t x, int16_t y);
-
-        /**
-         * Sets a text color for a message
-         *
-         * @param textColor Font color
-         * @param textBGColor Background color
-         */
-        void setTextColor (uint16_t textColor, uint16_t textBGColor);
-
-        /**
-         * Sets the size of the font
-         *
-         * @param size Font size
-         */
-        void setTextSize (uint8_t size);
-
-        /**
-         * Wraps a printed message
-         *
-         * @param wrap True (0x1) or false (0x0)
-         */
-        void setTextWrap (uint8_t wrap);
-
-    protected:
-        int m_width; /**< Screen width */
-        int m_height; /**< Screen height */
-        int m_textSize; /**< Printed text size */
-        int m_textColor; /**< Printed text color */
-        int m_textBGColor; /**< Printed text background color */
-        int m_cursorX; /**< Cursor X coordinate */
-        int m_cursorY; /**< Cursor Y coordinate */
-        int m_wrap; /**< Wrapper flag (true or false) */
-
-        const unsigned char * m_font;
-    };
-}
diff --git a/src/st7735/CMakeLists.txt b/src/st7735/CMakeLists.txt
deleted file mode 100644
index f88eea5..0000000
--- a/src/st7735/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "st7735")
-set (libdescription "SPI-based 262K Color Single-Chip TFT-LCD")
-set (module_src st7735_gfx.cxx st7735.cxx)
-set (module_hpp st7735_gfx.hpp st7735.hpp)
-upm_module_init(mraa)
diff --git a/src/st7735/license.txt b/src/st7735/license.txt
deleted file mode 100644
index 7492e93..0000000
--- a/src/st7735/license.txt
+++ /dev/null
@@ -1,24 +0,0 @@
-Software License Agreement (BSD License)
-
-Copyright (c) 2012 Adafruit Industries.  All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-- Redistributions of source code must retain the above copyright notice,
-  this list of conditions and the following disclaimer.
-- Redistributions in binary form must reproduce the above copyright notice,
-  this list of conditions and the following disclaimer in the documentation
-  and/or other materials provided with the distribution.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
diff --git a/src/st7735/st7735.cxx b/src/st7735/st7735.cxx
deleted file mode 100644
index 480103d..0000000
--- a/src/st7735/st7735.cxx
+++ /dev/null
@@ -1,270 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-#include <unistd.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-
-#include "st7735.hpp"
-
-using namespace upm;
-
-ST7735::ST7735 (int csLCD, int cSD, int rs, int rst)
-    : GFX (160, 128, m_map, font), m_spi(0), m_csLCDPinCtx(csLCD), m_cSDPinCtx(cSD),
-      m_rSTPinCtx(rst), m_rSPinCtx(rs) {
-
-      initModule ();
-    configModule ();
-}
-
-void
-ST7735::initModule () {
-    mraa::Result error = mraa::SUCCESS;
-
-    m_height = 160;
-    m_width  = 128;
-
-    m_spi.frequency(15 * 1000000);
-
-    error = m_csLCDPinCtx.dir(mraa::DIR_OUT);
-    if (error != mraa::SUCCESS) {
-        mraa::printError (error);
-    }
-
-    error = m_cSDPinCtx.dir(mraa::DIR_OUT);
-    if (error != mraa::SUCCESS) {
-        mraa::printError (error);
-    }
-
-    error = m_rSTPinCtx.dir(mraa::DIR_OUT);
-    if (error != mraa::SUCCESS) {
-        mraa::printError (error);
-    }
-
-    error = m_rSPinCtx.dir(mraa::DIR_OUT);
-    if (error != mraa::SUCCESS) {
-        mraa::printError (error);
-    }
-
-    error = m_spi.frequency(15 * 1000000);
-    if (error != mraa::SUCCESS) {
-        mraa::printError (error);
-    }
-
-    lcdCSOn ();
-}
-
-void
-ST7735::write (uint8_t value) {
-    rsLOW ();
-    m_spi.writeByte(value);
-}
-
-void
-ST7735::data (uint8_t value) {
-    rsHIGH ();
-    m_spi.writeByte(value);
-}
-
-void
-ST7735::executeCMDList(const uint8_t *addr) {
-    uint8_t  numCommands, numArgs;
-    uint16_t ms;
-
-    numCommands = *(addr++);           // Number of commands to follow
-    while(numCommands--) {             // For each command...
-        write (*(addr++));             // Read, issue command
-        numArgs  = *(addr++);          // Number of args to follow
-        ms       = numArgs & DELAY;    // If hibit set, delay follows args
-        numArgs &= ~DELAY;             // Mask out delay bit
-        while(numArgs--) {             // For each argument...
-            data (*(addr++));          // Read, issue argument
-        }
-
-        if(ms) {
-            ms = *(addr++);            // Read post-command delay time (ms)
-            if (ms == 255) {
-                ms = 500;              // If 255, delay for 500 ms
-            }
-            usleep (ms * 1000);
-        }
-    }
-}
-
-void
-ST7735::setAddrWindow(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
-    uint8_t colstart, rowstart;
-    colstart  = rowstart = 0;
-
-    write (ST7735_CASET);                       // Column addr set
-
-    rsHIGH ();
-    m_spiBuffer[0] = 0x00;
-    m_spiBuffer[1] = x0 + colstart;             // XSTART
-    m_spiBuffer[2] = 0x00;
-    m_spiBuffer[3] = x1 + colstart;             // XEND
-    free(m_spi.write(m_spiBuffer, 4));
-
-    write (ST7735_RASET);                       // Row addr set
-
-    rsHIGH ();
-    m_spiBuffer[0] = 0x00;
-    m_spiBuffer[1] = y0 + rowstart;             // YSTART
-    m_spiBuffer[2] = 0x00;
-    m_spiBuffer[3] = y1 + rowstart;             // YEND
-    free(m_spi.write(m_spiBuffer, 4));
-
-    write (ST7735_RAMWR);                       // write to RAM
-}
-
-void
-ST7735::drawPixel(int16_t x, int16_t y, uint16_t color) {
-    if (mraa::SUCCESS != setPixel (x, y, color)) {
-        return;
-    }
-
-    refresh ();
-}
-
-void
-ST7735::refresh () {
-    rsHIGH ();
-
-    int fragmentSize = m_height * m_width * 2 / 20;
-    for (int fragment = 0; fragment < 20; fragment++) {
-        free(m_spi.write(&m_map[fragment * fragmentSize], fragmentSize));
-    }
-}
-
-void
-ST7735::configModule() {
-    rsHIGH ();
-    lcdCSOff ();
-    lcdCSOn ();
-
-    m_rSTPinCtx.write(HIGH);
-    usleep (500000);
-    m_rSTPinCtx.write(LOW);
-    usleep (500000);
-    m_rSTPinCtx.write(HIGH);
-    usleep (500000);
-
-    executeCMDList (Rcmd1);
-    executeCMDList (Rcmd2red);
-    executeCMDList (Rcmd3);
-
-    write (ST7735_MADCTL);
-    data (0xC0);
-
-    setAddrWindow (0, 0, m_width - 1, m_height - 1);
-
-    fillScreen (ST7735_BLACK);
-    refresh ();
-}
-
-mraa::Result
-ST7735::lcdCSOn () {
-    mraa::Result error = mraa::SUCCESS;
-
-    error = m_csLCDPinCtx.write(LOW);
-    if (error != mraa::SUCCESS) {
-        mraa::printError (error);
-    }
-
-    error = m_cSDPinCtx.write(HIGH);
-    if (error != mraa::SUCCESS) {
-        mraa::printError (error);
-    }
-
-    return error;
-}
-
-mraa::Result
-ST7735::lcdCSOff () {
-    mraa::Result error = mraa::SUCCESS;
-
-    error = m_csLCDPinCtx.write(HIGH);
-    if (error != mraa::SUCCESS) {
-        mraa::printError (error);
-    }
-
-    return error;
-}
-
-mraa::Result
-ST7735::sdCSOn () {
-    mraa::Result error = mraa::SUCCESS;
-
-    error = m_cSDPinCtx.write(LOW);
-    if (error != mraa::SUCCESS) {
-        mraa::printError (error);
-    }
-
-    error = m_csLCDPinCtx.write(HIGH);
-    if (error != mraa::SUCCESS) {
-        mraa::printError (error);
-    }
-
-    return error;
-}
-
-mraa::Result
-ST7735::sdCSOff () {
-    mraa::Result error = mraa::SUCCESS;
-
-    error = m_cSDPinCtx.write(HIGH);
-    if (error != mraa::SUCCESS) {
-        mraa::printError (error);
-    }
-
-    return error;
-}
-
-mraa::Result
-ST7735::rsHIGH () {
-    mraa::Result error = mraa::SUCCESS;
-
-    error = m_rSPinCtx.write(HIGH);
-    if (error != mraa::SUCCESS) {
-        mraa::printError (error);
-    }
-
-    return error;
-}
-
-mraa::Result
-ST7735::rsLOW () {
-    mraa::Result error = mraa::SUCCESS;
-
-    error = m_rSPinCtx.write(LOW);
-    if (error != mraa::SUCCESS) {
-        mraa::printError (error);
-    }
-
-    return error;
-}
diff --git a/src/st7735/st7735.hpp b/src/st7735/st7735.hpp
deleted file mode 100644
index aca459f..0000000
--- a/src/st7735/st7735.hpp
+++ /dev/null
@@ -1,639 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Credits to Adafruit.
- * Based on Adafruit ST7735 library, see original license in license.txt file.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/aio.hpp>
-#include <mraa/common.hpp>
-
-#include <mraa/gpio.hpp>
-
-#include <mraa/spi.hpp>
-#include "st7735_gfx.hpp"
-
-#define INITR_GREENTAB      0x0
-#define INITR_REDTAB        0x1
-#define INITR_BLACKTAB      0x2
-
-#define ST7735_TFTWIDTH     128
-#define ST7735_TFTHEIGHT    160
-
-#define ST7735_NOP          0x00
-#define ST7735_SWRESET      0x01
-#define ST7735_RDDID        0x04
-#define ST7735_RDDST        0x09
-
-#define ST7735_SLPIN        0x10
-#define ST7735_SLPOUT       0x11
-#define ST7735_PTLON        0x12
-#define ST7735_NORON        0x13
-
-#define ST7735_INVOFF       0x20
-#define ST7735_INVON        0x21
-#define ST7735_DISPOFF      0x28
-#define ST7735_DISPON       0x29
-#define ST7735_CASET        0x2A
-#define ST7735_RASET        0x2B
-#define ST7735_RAMWR        0x2C
-#define ST7735_RAMRD        0x2E
-
-#define ST7735_PTLAR        0x30
-#define ST7735_COLMOD       0x3A
-#define ST7735_MADCTL       0x36
-
-#define ST7735_FRMCTR1      0xB1
-#define ST7735_FRMCTR2      0xB2
-#define ST7735_FRMCTR3      0xB3
-#define ST7735_INVCTR       0xB4
-#define ST7735_DISSET5      0xB6
-
-#define ST7735_PWCTR1       0xC0
-#define ST7735_PWCTR2       0xC1
-#define ST7735_PWCTR3       0xC2
-#define ST7735_PWCTR4       0xC3
-#define ST7735_PWCTR5       0xC4
-#define ST7735_VMCTR1       0xC5
-
-#define ST7735_RDID1        0xDA
-#define ST7735_RDID2        0xDB
-#define ST7735_RDID3        0xDC
-#define ST7735_RDID4        0xDD
-
-#define ST7735_PWCTR6       0xFC
-
-#define ST7735_GMCTRP1      0xE0
-#define ST7735_GMCTRN1      0xE1
-
-// Color definitions
-#define ST7735_BLACK        0x0000
-#define ST7735_BLUE         0x001F
-#define ST7735_RED          0xF800
-#define ST7735_GREEN        0x07E0
-#define ST7735_CYAN         0x07FF
-#define ST7735_MAGENTA      0xF81F
-#define ST7735_YELLOW       0xFFE0
-#define ST7735_WHITE        0xFFFF
-
-#define HIGH                1
-#define LOW                 0
-
-#define DELAY               0x80
-
-namespace upm {
-
-static const uint8_t Bcmd[] = {
-    // Initialization commands for 7735B screens
-      18,                     // 18 commands in list:
-    ST7735_SWRESET,   DELAY,  //  1: Software reset, no args, w/delay
-      50,                     //     50 ms delay
-    ST7735_SLPOUT ,   DELAY,  //  2: Out of sleep mode, no args, w/delay
-      255,                    //     255 = 500 ms delay
-    ST7735_COLMOD , 1+DELAY,  //  3: Set color mode, 1 arg + delay:
-      0x05,                   //     16-bit color
-      10,                     //     10 ms delay
-    ST7735_FRMCTR1, 3+DELAY,  //  4: Frame rate control, 3 args + delay:
-      0x00,                   //     fastest refresh
-      0x06,                   //     6 lines front porch
-      0x03,                   //     3 lines back porch
-      10,                     //     10 ms delay
-    ST7735_MADCTL , 1      ,  //  5: Memory access ctrl (directions), 1 arg:
-      0x08,                   //     Row addr/col addr, bottom to top refresh
-    ST7735_DISSET5, 2      ,  //  6: Display settings #5, 2 args, no delay:
-      0x15,                   //     1 clk cycle nonoverlap, 2 cycle gate
-                              //     rise, 3 cycle osc equalize
-      0x02,                   //     Fix on VTL
-    ST7735_INVCTR , 1      ,  //  7: Display inversion control, 1 arg:
-      0x0,                    //     Line inversion
-    ST7735_PWCTR1 , 2+DELAY,  //  8: Power control, 2 args + delay:
-      0x02,                   //     GVDD = 4.7V
-      0x70,                   //     1.0uA
-      10,                     //     10 ms delay
-    ST7735_PWCTR2 , 1      ,  //  9: Power control, 1 arg, no delay:
-      0x05,                   //     VGH = 14.7V, VGL = -7.35V
-    ST7735_PWCTR3 , 2      ,  // 10: Power control, 2 args, no delay:
-      0x01,                   //     Opamp current small
-      0x02,                   //     Boost frequency
-    ST7735_VMCTR1 , 2+DELAY,  // 11: Power control, 2 args + delay:
-      0x3C,                   //     VCOMH = 4V
-      0x38,                   //     VCOML = -1.1V
-      10,                     //     10 ms delay
-    ST7735_PWCTR6 , 2      ,  // 12: Power control, 2 args, no delay:
-      0x11, 0x15,
-    ST7735_GMCTRP1,16      ,  // 13: Magical unicorn dust, 16 args, no delay:
-      0x09, 0x16, 0x09, 0x20, //     (seriously though, not sure what
-      0x21, 0x1B, 0x13, 0x19, //      these config values represent)
-      0x17, 0x15, 0x1E, 0x2B,
-      0x04, 0x05, 0x02, 0x0E,
-    ST7735_GMCTRN1,16+DELAY,  // 14: Sparkles and rainbows, 16 args + delay:
-      0x0B, 0x14, 0x08, 0x1E, //     (ditto)
-      0x22, 0x1D, 0x18, 0x1E,
-      0x1B, 0x1A, 0x24, 0x2B,
-      0x06, 0x06, 0x02, 0x0F,
-      10,                     //     10 ms delay
-    ST7735_CASET  , 4      ,  // 15: Column addr set, 4 args, no delay:
-      0x00, 0x02,             //     XSTART = 2
-      0x00, 0x81,             //     XEND = 129
-    ST7735_RASET  , 4      ,  // 16: Row addr set, 4 args, no delay:
-      0x00, 0x02,             //     XSTART = 1
-      0x00, 0x81,             //     XEND = 160
-    ST7735_NORON  ,   DELAY,  // 17: Normal display on, no args, w/delay
-      10,                     //     10 ms delay
-    ST7735_DISPON ,   DELAY,  // 18: Main screen turn on, no args, w/delay
-      255 },                  //     255 = 500 ms delay
-
-  Rcmd1[] = {                 // Init for 7735R, part 1 (red or green tab)
-      15,                     // 15 commands in list:
-    ST7735_SWRESET,   DELAY,  //  1: Software reset, 0 args, w/delay
-      150,                    //     150 ms delay
-    ST7735_SLPOUT ,   DELAY,  //  2: Out of sleep mode, 0 args, w/delay
-      255,                    //     500 ms delay
-    ST7735_FRMCTR1, 3      ,  //  3: Frame rate ctrl - normal mode, 3 args:
-      0x01, 0x2C, 0x2D,       //     Rate = fosc/(1x2+40) * (LINE+2C+2D)
-    ST7735_FRMCTR2, 3      ,  //  4: Frame rate control - idle mode, 3 args:
-      0x01, 0x2C, 0x2D,       //     Rate = fosc/(1x2+40) * (LINE+2C+2D)
-    ST7735_FRMCTR3, 6      ,  //  5: Frame rate ctrl - partial mode, 6 args:
-      0x01, 0x2C, 0x2D,       //     Dot inversion mode
-      0x01, 0x2C, 0x2D,       //     Line inversion mode
-    ST7735_INVCTR , 1      ,  //  6: Display inversion ctrl, 1 arg, no delay:
-      0x07,                   //     No inversion
-    ST7735_PWCTR1 , 3      ,  //  7: Power control, 3 args, no delay:
-      0xA2,
-      0x02,                   //     -4.6V
-      0x84,                   //     AUTO mode
-    ST7735_PWCTR2 , 1      ,  //  8: Power control, 1 arg, no delay:
-      0xC5,                   //     VGH25 = 2.4C VGSEL = -10 VGH = 3 * AVDD
-    ST7735_PWCTR3 , 2      ,  //  9: Power control, 2 args, no delay:
-      0x0A,                   //     Opamp current small
-      0x00,                   //     Boost frequency
-    ST7735_PWCTR4 , 2      ,  // 10: Power control, 2 args, no delay:
-      0x8A,                   //     BCLK/2, Opamp current small & Medium low
-      0x2A,
-    ST7735_PWCTR5 , 2      ,  // 11: Power control, 2 args, no delay:
-      0x8A, 0xEE,
-    ST7735_VMCTR1 , 1      ,  // 12: Power control, 1 arg, no delay:
-      0x0E,
-    ST7735_INVOFF , 0      ,  // 13: Don't invert display, no args, no delay
-    ST7735_MADCTL , 1      ,  // 14: Memory access control (directions), 1 arg:
-      0xC8,                   //     row addr/col addr, bottom to top refresh
-    ST7735_COLMOD , 1      ,  // 15: set color mode, 1 arg, no delay:
-      0x05 },                 //     16-bit color
-
-  Rcmd2green[] = {            // Init for 7735R, part 2 (green tab only)
-      2,                      //  2 commands in list:
-    ST7735_CASET  , 4      ,  //  1: Column addr set, 4 args, no delay:
-      0x00, 0x02,             //     XSTART = 0
-      0x00, 0x7F+0x02,        //     XEND = 127
-    ST7735_RASET  , 4      ,  //  2: Row addr set, 4 args, no delay:
-      0x00, 0x01,             //     XSTART = 0
-      0x00, 0x9F+0x01 },      //     XEND = 159
-  Rcmd2red[] = {              // Init for 7735R, part 2 (red tab only)
-      2,                      //  2 commands in list:
-    ST7735_CASET  , 4      ,  //  1: Column addr set, 4 args, no delay:
-      0x00, 0x00,             //     XSTART = 0
-      0x00, 0x7F,             //     XEND = 127
-    ST7735_RASET  , 4      ,  //  2: Row addr set, 4 args, no delay:
-      0x00, 0x00,             //     XSTART = 0
-      0x00, 0x9F },           //     XEND = 159
-
-  Rcmd3[] = {                 // Init for 7735R, part 3 (red or green tab)
-      4,                      //  4 commands in list:
-    ST7735_GMCTRP1, 16      , //  1: Magical unicorn dust, 16 args, no delay:
-      0x02, 0x1c, 0x07, 0x12,
-      0x37, 0x32, 0x29, 0x2d,
-      0x29, 0x25, 0x2B, 0x39,
-      0x00, 0x01, 0x03, 0x10,
-    ST7735_GMCTRN1, 16      , //  2: Sparkles and rainbows, 16 args, no delay:
-      0x03, 0x1d, 0x07, 0x06,
-      0x2E, 0x2C, 0x29, 0x2D,
-      0x2E, 0x2E, 0x37, 0x3F,
-      0x00, 0x00, 0x02, 0x10,
-    ST7735_NORON  ,    DELAY, //  3: Normal display on, no args, w/delay
-      10,                     //     10 ms delay
-    ST7735_DISPON ,    DELAY, //  4: Main screen turn on, no args w/delay
-      100 };                  //     100 ms delay
-
-#define swap(a, b) { int16_t t = a; a = b; b = t; }
-
-const unsigned char font[] = {
-    0x00, 0x00, 0x00, 0x00, 0x00,
-    0x3E, 0x5B, 0x4F, 0x5B, 0x3E,
-    0x3E, 0x6B, 0x4F, 0x6B, 0x3E,
-    0x1C, 0x3E, 0x7C, 0x3E, 0x1C,
-    0x18, 0x3C, 0x7E, 0x3C, 0x18,
-    0x1C, 0x57, 0x7D, 0x57, 0x1C,
-    0x1C, 0x5E, 0x7F, 0x5E, 0x1C,
-    0x00, 0x18, 0x3C, 0x18, 0x00,
-    0xFF, 0xE7, 0xC3, 0xE7, 0xFF,
-    0x00, 0x18, 0x24, 0x18, 0x00,
-    0xFF, 0xE7, 0xDB, 0xE7, 0xFF,
-    0x30, 0x48, 0x3A, 0x06, 0x0E,
-    0x26, 0x29, 0x79, 0x29, 0x26,
-    0x40, 0x7F, 0x05, 0x05, 0x07,
-    0x40, 0x7F, 0x05, 0x25, 0x3F,
-    0x5A, 0x3C, 0xE7, 0x3C, 0x5A,
-    0x7F, 0x3E, 0x1C, 0x1C, 0x08,
-    0x08, 0x1C, 0x1C, 0x3E, 0x7F,
-    0x14, 0x22, 0x7F, 0x22, 0x14,
-    0x5F, 0x5F, 0x00, 0x5F, 0x5F,
-    0x06, 0x09, 0x7F, 0x01, 0x7F,
-    0x00, 0x66, 0x89, 0x95, 0x6A,
-    0x60, 0x60, 0x60, 0x60, 0x60,
-    0x94, 0xA2, 0xFF, 0xA2, 0x94,
-    0x08, 0x04, 0x7E, 0x04, 0x08,
-    0x10, 0x20, 0x7E, 0x20, 0x10,
-    0x08, 0x08, 0x2A, 0x1C, 0x08,
-    0x08, 0x1C, 0x2A, 0x08, 0x08,
-    0x1E, 0x10, 0x10, 0x10, 0x10,
-    0x0C, 0x1E, 0x0C, 0x1E, 0x0C,
-    0x30, 0x38, 0x3E, 0x38, 0x30,
-    0x06, 0x0E, 0x3E, 0x0E, 0x06,
-    0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0x5F, 0x00, 0x00,
-    0x00, 0x07, 0x00, 0x07, 0x00,
-    0x14, 0x7F, 0x14, 0x7F, 0x14,
-    0x24, 0x2A, 0x7F, 0x2A, 0x12,
-    0x23, 0x13, 0x08, 0x64, 0x62,
-    0x36, 0x49, 0x56, 0x20, 0x50,
-    0x00, 0x08, 0x07, 0x03, 0x00,
-    0x00, 0x1C, 0x22, 0x41, 0x00,
-    0x00, 0x41, 0x22, 0x1C, 0x00,
-    0x2A, 0x1C, 0x7F, 0x1C, 0x2A,
-    0x08, 0x08, 0x3E, 0x08, 0x08,
-    0x00, 0x80, 0x70, 0x30, 0x00,
-    0x08, 0x08, 0x08, 0x08, 0x08,
-    0x00, 0x00, 0x60, 0x60, 0x00,
-    0x20, 0x10, 0x08, 0x04, 0x02,
-    0x3E, 0x51, 0x49, 0x45, 0x3E,
-    0x00, 0x42, 0x7F, 0x40, 0x00,
-    0x72, 0x49, 0x49, 0x49, 0x46,
-    0x21, 0x41, 0x49, 0x4D, 0x33,
-    0x18, 0x14, 0x12, 0x7F, 0x10,
-    0x27, 0x45, 0x45, 0x45, 0x39,
-    0x3C, 0x4A, 0x49, 0x49, 0x31,
-    0x41, 0x21, 0x11, 0x09, 0x07,
-    0x36, 0x49, 0x49, 0x49, 0x36,
-    0x46, 0x49, 0x49, 0x29, 0x1E,
-    0x00, 0x00, 0x14, 0x00, 0x00,
-    0x00, 0x40, 0x34, 0x00, 0x00,
-    0x00, 0x08, 0x14, 0x22, 0x41,
-    0x14, 0x14, 0x14, 0x14, 0x14,
-    0x00, 0x41, 0x22, 0x14, 0x08,
-    0x02, 0x01, 0x59, 0x09, 0x06,
-    0x3E, 0x41, 0x5D, 0x59, 0x4E,
-    0x7C, 0x12, 0x11, 0x12, 0x7C,
-    0x7F, 0x49, 0x49, 0x49, 0x36,
-    0x3E, 0x41, 0x41, 0x41, 0x22,
-    0x7F, 0x41, 0x41, 0x41, 0x3E,
-    0x7F, 0x49, 0x49, 0x49, 0x41,
-    0x7F, 0x09, 0x09, 0x09, 0x01,
-    0x3E, 0x41, 0x41, 0x51, 0x73,
-    0x7F, 0x08, 0x08, 0x08, 0x7F,
-    0x00, 0x41, 0x7F, 0x41, 0x00,
-    0x20, 0x40, 0x41, 0x3F, 0x01,
-    0x7F, 0x08, 0x14, 0x22, 0x41,
-    0x7F, 0x40, 0x40, 0x40, 0x40,
-    0x7F, 0x02, 0x1C, 0x02, 0x7F,
-    0x7F, 0x04, 0x08, 0x10, 0x7F,
-    0x3E, 0x41, 0x41, 0x41, 0x3E,
-    0x7F, 0x09, 0x09, 0x09, 0x06,
-    0x3E, 0x41, 0x51, 0x21, 0x5E,
-    0x7F, 0x09, 0x19, 0x29, 0x46,
-    0x26, 0x49, 0x49, 0x49, 0x32,
-    0x03, 0x01, 0x7F, 0x01, 0x03,
-    0x3F, 0x40, 0x40, 0x40, 0x3F,
-    0x1F, 0x20, 0x40, 0x20, 0x1F,
-    0x3F, 0x40, 0x38, 0x40, 0x3F,
-    0x63, 0x14, 0x08, 0x14, 0x63,
-    0x03, 0x04, 0x78, 0x04, 0x03,
-    0x61, 0x59, 0x49, 0x4D, 0x43,
-    0x00, 0x7F, 0x41, 0x41, 0x41,
-    0x02, 0x04, 0x08, 0x10, 0x20,
-    0x00, 0x41, 0x41, 0x41, 0x7F,
-    0x04, 0x02, 0x01, 0x02, 0x04,
-    0x40, 0x40, 0x40, 0x40, 0x40,
-    0x00, 0x03, 0x07, 0x08, 0x00,
-    0x20, 0x54, 0x54, 0x78, 0x40,
-    0x7F, 0x28, 0x44, 0x44, 0x38,
-    0x38, 0x44, 0x44, 0x44, 0x28,
-    0x38, 0x44, 0x44, 0x28, 0x7F,
-    0x38, 0x54, 0x54, 0x54, 0x18,
-    0x00, 0x08, 0x7E, 0x09, 0x02,
-    0x18, 0xA4, 0xA4, 0x9C, 0x78,
-    0x7F, 0x08, 0x04, 0x04, 0x78,
-    0x00, 0x44, 0x7D, 0x40, 0x00,
-    0x20, 0x40, 0x40, 0x3D, 0x00,
-    0x7F, 0x10, 0x28, 0x44, 0x00,
-    0x00, 0x41, 0x7F, 0x40, 0x00,
-    0x7C, 0x04, 0x78, 0x04, 0x78,
-    0x7C, 0x08, 0x04, 0x04, 0x78,
-    0x38, 0x44, 0x44, 0x44, 0x38,
-    0xFC, 0x18, 0x24, 0x24, 0x18,
-    0x18, 0x24, 0x24, 0x18, 0xFC,
-    0x7C, 0x08, 0x04, 0x04, 0x08,
-    0x48, 0x54, 0x54, 0x54, 0x24,
-    0x04, 0x04, 0x3F, 0x44, 0x24,
-    0x3C, 0x40, 0x40, 0x20, 0x7C,
-    0x1C, 0x20, 0x40, 0x20, 0x1C,
-    0x3C, 0x40, 0x30, 0x40, 0x3C,
-    0x44, 0x28, 0x10, 0x28, 0x44,
-    0x4C, 0x90, 0x90, 0x90, 0x7C,
-    0x44, 0x64, 0x54, 0x4C, 0x44,
-    0x00, 0x08, 0x36, 0x41, 0x00,
-    0x00, 0x00, 0x77, 0x00, 0x00,
-    0x00, 0x41, 0x36, 0x08, 0x00,
-    0x02, 0x01, 0x02, 0x04, 0x02,
-    0x3C, 0x26, 0x23, 0x26, 0x3C,
-    0x1E, 0xA1, 0xA1, 0x61, 0x12,
-    0x3A, 0x40, 0x40, 0x20, 0x7A,
-    0x38, 0x54, 0x54, 0x55, 0x59,
-    0x21, 0x55, 0x55, 0x79, 0x41,
-    0x21, 0x54, 0x54, 0x78, 0x41,
-    0x21, 0x55, 0x54, 0x78, 0x40,
-    0x20, 0x54, 0x55, 0x79, 0x40,
-    0x0C, 0x1E, 0x52, 0x72, 0x12,
-    0x39, 0x55, 0x55, 0x55, 0x59,
-    0x39, 0x54, 0x54, 0x54, 0x59,
-    0x39, 0x55, 0x54, 0x54, 0x58,
-    0x00, 0x00, 0x45, 0x7C, 0x41,
-    0x00, 0x02, 0x45, 0x7D, 0x42,
-    0x00, 0x01, 0x45, 0x7C, 0x40,
-    0xF0, 0x29, 0x24, 0x29, 0xF0,
-    0xF0, 0x28, 0x25, 0x28, 0xF0,
-    0x7C, 0x54, 0x55, 0x45, 0x00,
-    0x20, 0x54, 0x54, 0x7C, 0x54,
-    0x7C, 0x0A, 0x09, 0x7F, 0x49,
-    0x32, 0x49, 0x49, 0x49, 0x32,
-    0x32, 0x48, 0x48, 0x48, 0x32,
-    0x32, 0x4A, 0x48, 0x48, 0x30,
-    0x3A, 0x41, 0x41, 0x21, 0x7A,
-    0x3A, 0x42, 0x40, 0x20, 0x78,
-    0x00, 0x9D, 0xA0, 0xA0, 0x7D,
-    0x39, 0x44, 0x44, 0x44, 0x39,
-    0x3D, 0x40, 0x40, 0x40, 0x3D,
-    0x3C, 0x24, 0xFF, 0x24, 0x24,
-    0x48, 0x7E, 0x49, 0x43, 0x66,
-    0x2B, 0x2F, 0xFC, 0x2F, 0x2B,
-    0xFF, 0x09, 0x29, 0xF6, 0x20,
-    0xC0, 0x88, 0x7E, 0x09, 0x03,
-    0x20, 0x54, 0x54, 0x79, 0x41,
-    0x00, 0x00, 0x44, 0x7D, 0x41,
-    0x30, 0x48, 0x48, 0x4A, 0x32,
-    0x38, 0x40, 0x40, 0x22, 0x7A,
-    0x00, 0x7A, 0x0A, 0x0A, 0x72,
-    0x7D, 0x0D, 0x19, 0x31, 0x7D,
-    0x26, 0x29, 0x29, 0x2F, 0x28,
-    0x26, 0x29, 0x29, 0x29, 0x26,
-    0x30, 0x48, 0x4D, 0x40, 0x20,
-    0x38, 0x08, 0x08, 0x08, 0x08,
-    0x08, 0x08, 0x08, 0x08, 0x38,
-    0x2F, 0x10, 0xC8, 0xAC, 0xBA,
-    0x2F, 0x10, 0x28, 0x34, 0xFA,
-    0x00, 0x00, 0x7B, 0x00, 0x00,
-    0x08, 0x14, 0x2A, 0x14, 0x22,
-    0x22, 0x14, 0x2A, 0x14, 0x08,
-    0xAA, 0x00, 0x55, 0x00, 0xAA,
-    0xAA, 0x55, 0xAA, 0x55, 0xAA,
-    0x00, 0x00, 0x00, 0xFF, 0x00,
-    0x10, 0x10, 0x10, 0xFF, 0x00,
-    0x14, 0x14, 0x14, 0xFF, 0x00,
-    0x10, 0x10, 0xFF, 0x00, 0xFF,
-    0x10, 0x10, 0xF0, 0x10, 0xF0,
-    0x14, 0x14, 0x14, 0xFC, 0x00,
-    0x14, 0x14, 0xF7, 0x00, 0xFF,
-    0x00, 0x00, 0xFF, 0x00, 0xFF,
-    0x14, 0x14, 0xF4, 0x04, 0xFC,
-    0x14, 0x14, 0x17, 0x10, 0x1F,
-    0x10, 0x10, 0x1F, 0x10, 0x1F,
-    0x14, 0x14, 0x14, 0x1F, 0x00,
-    0x10, 0x10, 0x10, 0xF0, 0x00,
-    0x00, 0x00, 0x00, 0x1F, 0x10,
-    0x10, 0x10, 0x10, 0x1F, 0x10,
-    0x10, 0x10, 0x10, 0xF0, 0x10,
-    0x00, 0x00, 0x00, 0xFF, 0x10,
-    0x10, 0x10, 0x10, 0x10, 0x10,
-    0x10, 0x10, 0x10, 0xFF, 0x10,
-    0x00, 0x00, 0x00, 0xFF, 0x14,
-    0x00, 0x00, 0xFF, 0x00, 0xFF,
-    0x00, 0x00, 0x1F, 0x10, 0x17,
-    0x00, 0x00, 0xFC, 0x04, 0xF4,
-    0x14, 0x14, 0x17, 0x10, 0x17,
-    0x14, 0x14, 0xF4, 0x04, 0xF4,
-    0x00, 0x00, 0xFF, 0x00, 0xF7,
-    0x14, 0x14, 0x14, 0x14, 0x14,
-    0x14, 0x14, 0xF7, 0x00, 0xF7,
-    0x14, 0x14, 0x14, 0x17, 0x14,
-    0x10, 0x10, 0x1F, 0x10, 0x1F,
-    0x14, 0x14, 0x14, 0xF4, 0x14,
-    0x10, 0x10, 0xF0, 0x10, 0xF0,
-    0x00, 0x00, 0x1F, 0x10, 0x1F,
-    0x00, 0x00, 0x00, 0x1F, 0x14,
-    0x00, 0x00, 0x00, 0xFC, 0x14,
-    0x00, 0x00, 0xF0, 0x10, 0xF0,
-    0x10, 0x10, 0xFF, 0x10, 0xFF,
-    0x14, 0x14, 0x14, 0xFF, 0x14,
-    0x10, 0x10, 0x10, 0x1F, 0x00,
-    0x00, 0x00, 0x00, 0xF0, 0x10,
-    0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-    0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
-    0xFF, 0xFF, 0xFF, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0xFF, 0xFF,
-    0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
-    0x38, 0x44, 0x44, 0x38, 0x44,
-    0x7C, 0x2A, 0x2A, 0x3E, 0x14,
-    0x7E, 0x02, 0x02, 0x06, 0x06,
-    0x02, 0x7E, 0x02, 0x7E, 0x02,
-    0x63, 0x55, 0x49, 0x41, 0x63,
-    0x38, 0x44, 0x44, 0x3C, 0x04,
-    0x40, 0x7E, 0x20, 0x1E, 0x20,
-    0x06, 0x02, 0x7E, 0x02, 0x02,
-    0x99, 0xA5, 0xE7, 0xA5, 0x99,
-    0x1C, 0x2A, 0x49, 0x2A, 0x1C,
-    0x4C, 0x72, 0x01, 0x72, 0x4C,
-    0x30, 0x4A, 0x4D, 0x4D, 0x30,
-    0x30, 0x48, 0x78, 0x48, 0x30,
-    0xBC, 0x62, 0x5A, 0x46, 0x3D,
-    0x3E, 0x49, 0x49, 0x49, 0x00,
-    0x7E, 0x01, 0x01, 0x01, 0x7E,
-    0x2A, 0x2A, 0x2A, 0x2A, 0x2A,
-    0x44, 0x44, 0x5F, 0x44, 0x44,
-    0x40, 0x51, 0x4A, 0x44, 0x40,
-    0x40, 0x44, 0x4A, 0x51, 0x40,
-    0x00, 0x00, 0xFF, 0x01, 0x03,
-    0xE0, 0x80, 0xFF, 0x00, 0x00,
-    0x08, 0x08, 0x6B, 0x6B, 0x08,
-    0x36, 0x12, 0x36, 0x24, 0x36,
-    0x06, 0x0F, 0x09, 0x0F, 0x06,
-    0x00, 0x00, 0x18, 0x18, 0x00,
-    0x00, 0x00, 0x10, 0x10, 0x00,
-    0x30, 0x40, 0xFF, 0x01, 0x01,
-    0x00, 0x1F, 0x01, 0x01, 0x1E,
-    0x00, 0x19, 0x1D, 0x17, 0x12,
-    0x00, 0x3C, 0x3C, 0x3C, 0x3C,
-    0x00, 0x00, 0x00, 0x00, 0x00
-};
-
-/**
- * @brief ST7735 LCD Display Controller
- * @defgroup st7735 libupm-st7735
- * @ingroup adafruit spi display
- */
-/**
- * @library st7735
- * @sensor st7735
- * @comname SPI-based 262K Color Single-Chip TFT-LCD
- * @type display
- * @man adafruit
- * @web http://www.adafruit.com/product/358
- * @con spi
- *
- * @brief API for the ST7735 LCD
- *
- * This module defines the interface for the ST7735 display library
- *
- * @image html st7735.jpg
- * @snippet st7735.cxx Interesting
- */
-class ST7735 : public GFX {
-    public:
-        /**
-         * Instantiates an ST7735 object
-         *
-         * @param csLCD LCD chip select pin
-         * @param cSD SD card chip select pin
-         * @param rs Data/command pin
-         * @param rst Reset pin
-         */
-        ST7735 (int csLCD, int cSD, int rs, int rst);
-
-        /**
-         * Returns the name of the component
-         */
-        std::string name()
-        {
-            return m_name;
-        }
-
-        /**
-         * Initializes the module GPIOs
-         */
-        void initModule ();
-
-        /**
-         * Configures the chip via the SPI
-         */
-        void configModule ();
-
-        /**
-         * Sends a command to an SPI bus (rs must be LOW)
-         *
-         * @param value Command number
-         */
-        void write (uint8_t value);
-
-        /**
-         * Sends data to an SPI bus (rs must be HIGH)
-         *
-         * @param value Command number
-         */
-        void data (uint8_t value);
-
-        /**
-         * Executes a set of commands and data
-         *
-         * @param addr Pointer to the start of the commands/data section
-         */
-        void executeCMDList (const uint8_t *addr);
-
-        /**
-         * Sets the window size inside the screen where pixels data
-         * is written.
-         *
-         * @param x0 First coordinate
-         * @param y0 First coordinate
-         * @param x1 Second coordinate
-         * @param y1 Second coordinate
-         */
-        void setAddrWindow (uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1);
-
-        /**
-         * Sends a pixel color (RGB) to the chip.
-         *
-         * @param x Axis on the horizontal scale
-         * @param y Axis on the vertical scale
-         * @param color RGB (16-bit) color (R[0-4], G[5-10], B[11-15])
-         */
-        void drawPixel (int16_t x, int16_t y, uint16_t color);
-
-        /**
-         * Copies the buffer to the chip via the SPI.
-         */
-        void refresh ();
-
-        /**
-         * LCD chip select is LOW
-         */
-        mraa::Result lcdCSOn ();
-
-        /**
-         * LCD chip select is HIGH
-         */
-        mraa::Result lcdCSOff ();
-
-        /**
-         * CD card chip select is LOW
-         */
-        mraa::Result sdCSOn ();
-
-        /**
-         * CD card select is HIGH
-         */
-        mraa::Result sdCSOff ();
-
-        /**
-         * Data select is HIGH
-         */
-        mraa::Result rsHIGH ();
-
-        /**
-         * Data select is LOW
-         */
-        mraa::Result rsLOW ();
-
-        uint8_t m_map[160 * 128 * 2]; /**< Screens buffer */
-    private:
-        uint8_t        m_spiBuffer[32];
-
-        mraa::Spi      m_spi;
-        mraa::Gpio     m_csLCDPinCtx;
-        mraa::Gpio     m_cSDPinCtx;
-        mraa::Gpio     m_rSTPinCtx;
-        mraa::Gpio     m_rSPinCtx;
-
-        std::string    m_name;
-};
-
-}
diff --git a/src/st7735/st7735.i b/src/st7735/st7735.i
deleted file mode 100644
index 5be51e5..0000000
--- a/src/st7735/st7735.i
+++ /dev/null
@@ -1,59 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "arrays_java.i"
-%ignore m_map;
-%ignore Bcmd;
-%ignore font;
-%ignore Rcmd1;
-%ignore Rcmd2green;
-%ignore Rcmd2red;
-%ignore Rcmd3;
-
-/*
-%typemap(jni) unsigned char[] "jbyteArray";
-%typemap(jtype) unsigned char[] "byte[]";
-%typemap(jstype) unsigned char[] "byte[]";
-
-%typemap(out) unsigned char[] {
-    $result = SWIG_JavaArrayOutSchar(jenv, reinterpret_cast<signed char*>($1), sizeof($1));
-}
-%typemap(freearg) unsigned char* {
-    JCALL3(ReleaseByteArrayElements, jenv, $input, reinterpret_cast<jbyte*>($1), 0);
-}
-*/
-%typemap(jni) unsigned char* "jbyteArray";
-%typemap(jtype) unsigned char* "byte[]";
-%typemap(jstype) unsigned char* "byte[]";
-
-%typemap(javain) unsigned char* "$javainput"
-
-%typemap(in) unsigned char* {
-    $1 = (unsigned char *)JCALL2(GetByteArrayElements, jenv, $input, NULL);
-}
-
-JAVA_JNI_LOADLIBRARY(javaupm_st7735)
-#endif
-/* END Java syntax */
-
-/* BEGIN Javascript syntax  ------------------------------------------------- */
-#ifdef SWIGJAVASCRIPT
-%include "../carrays_uint8_t.i"
-#endif
-/* END Javascript syntax */
-
-/* BEGIN Python syntax  ----------------------------------------------------- */
-#ifdef SWIGPYTHON
-%include "../carrays_uint8_t.i"
-#endif
-/* END Python syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "st7735_gfx.hpp"
-#include "st7735.hpp"
-%}
-%include "st7735_gfx.hpp"
-%include "st7735.hpp"
-/* END Common SWIG syntax */
diff --git a/src/st7735/st7735.json b/src/st7735/st7735.json
deleted file mode 100644
index a0be541..0000000
--- a/src/st7735/st7735.json
+++ /dev/null
@@ -1,51 +0,0 @@
-{
-    "Library": "st7735",
-    "Description": "Adafruit ST7735 LCD library",
-    "Sensor Class": {
-        "ST7735": {
-            "Name": "API for the Adafruit ST7735 LCD",
-            "Description": "This is the UPM Module for the Adafruit ST7735 LCD. This lovely little display breakout is the best way to add a small, colorful and bright display to any project. Since the display uses 4-wire SPI to communicate and has its own pixel-addressable frame buffer, it can be used with every kind of microcontroller. Even a very small one with low memory and few pins available!",
-            "Aliases": ["st7735", "1.8\" Color TFT LCD display with MicroSD Card Breakout - ST7735R"],
-            "Categories": ["display"],
-            "Connections": ["spi"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["Adafruit", "Truly Semiconductors", "Sitronix"],
-            "Image": "st7735.jpg",
-            "Examples": {
-                "Java": ["ST7735_Example.java"],
-                "Node.js": ["st7735.js"],
-                "C++": ["st7735.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.3,
-                    "max": 5.0
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "min": 1.0,
-                    "max": 50.0
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Resolution": {
-                    "unit": "pixels",
-                    "height": 128,
-                    "width" : 160
-                },
-                "Color Resolution": {
-                    "unit": "bits",
-                    "resolution": 18
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.adafruit.com/product/358"],
-                "Datasheets": ["https://cdn-shop.adafruit.com/datasheets/JD-T1800.pdf", "https://cdn-shop.adafruit.com/datasheets/ST7735R_V0.2.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/st7735/st7735_gfx.cxx b/src/st7735/st7735_gfx.cxx
deleted file mode 100644
index 29064fd..0000000
--- a/src/st7735/st7735_gfx.cxx
+++ /dev/null
@@ -1,233 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Based on GFX interface by Adafruit Industries.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <unistd.h>
-#include <stdlib.h>
-
-#include "st7735_gfx.hpp"
-
-using namespace upm;
-
-GFX::GFX (int width, int height, uint8_t * screenBuffer, const unsigned char * font) : WIDTH(width), HEIGHT(height) {
-    m_height = height;
-    m_width  = width;
-    m_font   = font;
-    m_map    = screenBuffer;
-}
-
-GFX::~GFX () {
-}
-
-mraa::Result
-GFX::setPixel (int x, int y, uint16_t color) {
-    if((x < 0) ||(x >= m_width) || (y < 0) || (y >= m_height)) {
-        return mraa::ERROR_UNSPECIFIED;
-    }
-
-    int index = ((y * m_width) + x) * sizeof(uint16_t);
-    m_map[index] = (uint8_t) (color >> 8);
-    m_map[++index] = (uint8_t)(color);
-
-    return mraa::SUCCESS;
-}
-
-void
-GFX::fillScreen (uint16_t color) {
-    fillRect(0, 0, m_width, m_height, color);
-}
-
-void
-GFX::fillRect (int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color) {
-    for (int16_t i=x; i<x+w; i++) {
-        drawFastVLine(i, y, h, color);
-    }
-}
-
-void
-GFX::drawFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color) {
-    drawLine(x, y, x, y+h-1, color);
-}
-
-void
-GFX::drawLine (int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color) {
-    int16_t steep = abs(y1 - y0) > abs(x1 - x0);
-
-    if (steep) {
-        swap(x0, y0);
-        swap(x1, y1);
-    }
-
-    if (x0 > x1) {
-        swap(x0, x1);
-        swap(y0, y1);
-    }
-
-    int16_t dx, dy;
-    dx = x1 - x0;
-    dy = abs (y1 - y0);
-
-    int16_t err = dx / 2;
-    int16_t ystep;
-
-    if (y0 < y1) {
-        ystep = 1;
-    } else {
-        ystep = -1;
-    }
-
-    for (; x0 <= x1; x0++) {
-        if (steep) {
-            setPixel(y0, x0, color);
-        } else {
-            setPixel(x0, y0, color);
-        }
-        err -= dy;
-        if (err < 0) {
-            y0 += ystep;
-            err += dx;
-        }
-    }
-}
-
-void
-GFX::drawTriangle(int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color) {
-    drawLine(x0, y0, x1, y1, color);
-    drawLine(x1, y1, x2, y2, color);
-    drawLine(x2, y2, x0, y0, color);
-}
-
-void
-GFX::drawCircle(int16_t x0, int16_t y0, int16_t r, uint16_t color) {
-    int16_t f = 1 - r;
-    int16_t ddF_x = 1;
-    int16_t ddF_y = -2 * r;
-    int16_t x = 0;
-    int16_t y = r;
-
-    setPixel(x0  , y0+r, color);
-    setPixel(x0  , y0-r, color);
-    setPixel(x0+r, y0  , color);
-    setPixel(x0-r, y0  , color);
-
-    while (x<y) {
-        if (f >= 0) {
-            y--;
-            ddF_y += 2;
-            f += ddF_y;
-        }
-        x++;
-
-        ddF_x += 2;
-        f += ddF_x;
-
-        setPixel(x0 + x, y0 + y, color);
-        setPixel(x0 - x, y0 + y, color);
-        setPixel(x0 + x, y0 - y, color);
-        setPixel(x0 - x, y0 - y, color);
-        setPixel(x0 + y, y0 + x, color);
-        setPixel(x0 - y, y0 + x, color);
-        setPixel(x0 + y, y0 - x, color);
-        setPixel(x0 - y, y0 - x, color);
-    }
-}
-
-void
-GFX::setCursor (int16_t x, int16_t y) {
-    m_cursorX = x;
-    m_cursorY = y;
-}
-
-void
-GFX::setTextColor (uint16_t textColor, uint16_t textBGColor) {
-    m_textColor   = textColor;
-    m_textBGColor = textBGColor;
-}
-
-void
-GFX::setTextSize (uint8_t size) {
-    m_textSize = (size > 0) ? size : 1;
-}
-
-void
-GFX::setTextWrap (uint8_t wrap) {
-    m_wrap = wrap;
-}
-
-void
-GFX::drawChar (int16_t x, int16_t y, uint8_t data, uint16_t color, uint16_t bg, uint8_t size) {
-    if( (x >= m_width)            || // Clip right
-        (y >= m_height)           || // Clip bottom
-        ((x + 6 * size - 1) < 0)  || // Clip left
-        ((y + 8 * size - 1) < 0))    // Clip top
-    return;
-
-    for (int8_t i=0; i<6; i++ ) {
-        uint8_t line;
-        if (i == 5) {
-            line = 0x0;
-        } else {
-            line = *(m_font+(data * 5)+i);
-            for (int8_t j = 0; j<8; j++) {
-                if (line & 0x1) {
-                    if (size == 1) // default size
-                        setPixel (x+i, y+j, color);
-                    else {  // big size
-                        fillRect (x+(i*size), y+(j*size), size, size, color);
-                    }
-                } else if (bg != color) {
-                    if (size == 1) // default size
-                        setPixel (x+i, y+j, bg);
-                    else {  // big size
-                        fillRect (x+i*size, y+j*size, size, size, bg);
-                    }
-                }
-                line >>= 1;
-            }
-        }
-    }
-}
-
-void
-GFX::print (std::string msg) {
-    int len = msg.length();
-
-    for (int idx = 0; idx < len; idx++) {
-        if (msg[idx] == '\n') {
-            m_cursorY += m_textSize * 8;
-            m_cursorX  = 0;
-        } else if (msg[idx] == '\r') {
-            // skip em
-        } else {
-            drawChar(m_cursorX, m_cursorY, msg[idx], m_textColor, m_textBGColor, m_textSize);
-            m_cursorX += m_textSize * 6;
-            if (m_wrap && (m_textColor > (m_width - m_textSize * 6))) {
-                m_cursorY += m_textSize * 8;
-                m_cursorX = 0;
-            }
-        }
-    }
-}
diff --git a/src/st7735/st7735_gfx.hpp b/src/st7735/st7735_gfx.hpp
deleted file mode 100644
index a084178..0000000
--- a/src/st7735/st7735_gfx.hpp
+++ /dev/null
@@ -1,221 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Based on GFX interface by Adafruit Industries.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <stdio.h>
-#include <unistd.h>
-#include <stdint.h>
-
-#include <mraa.hpp>
-
-#define swap(a, b) { int16_t t = a; a = b; b = t; }
-
-namespace upm {
-
-/**
- * @brief GFX helper class
- *
- * This file is used by the screen.
- */
-class GFX {
-    public:
-        /**
-         * Instantiates a GFX object
-         *
-         * @param width Screen width
-         * @param height Screen height
-         * @param screenBuffer Pointer to the screen buffer
-         * @param font Pointer to the font map
-         */
-        GFX (int width, int height, uint8_t * screenBuffer, const unsigned char * font);
-
-        /**
-         * GFX object destructor
-         */
-        virtual ~GFX ();
-
-        /**
-         * Sets the window address
-         *
-         * @param x0 First coordinate
-         * @param y0 First coordinate
-         * @param x1 Second coordinate
-         * @param y1 Second coordinate
-         */
-        virtual void setAddrWindow (uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) = 0;
-
-        /**
-         * Sends a pixel color (RGB) to the chip. Must be implemented by the
-         * inherited class.
-         *
-         * @param x Axis on the horizontal scale
-         * @param y Axis on the vertical scale
-         * @param color RGB value
-         */
-        virtual void drawPixel (int16_t x, int16_t y, uint16_t color) = 0;
-
-        /**
-         * Copies the buffer to the chip via the SPI.
-         */
-        virtual void refresh () = 0;
-
-        /**
-         *
-         *
-         * @param x Axis on the horizontal scale
-         * @param y Axis on the vertical scale
-         * @param data Character to write
-         * @param color Character color
-         * @param bg Character background color
-         * @param size Size of the font
-         */
-        void drawChar (int16_t x, int16_t y, uint8_t data, uint16_t color, uint16_t bg, uint8_t size);
-
-        /**
-         * Prints a message on the screen
-         *
-         * @param msg Message to print
-         */
-        void print (std::string msg);
-
-        /**
-         * Prints a message on the screen
-         *
-         * @param x Axis on the horizontal scale
-         * @param y Axis on the vertical scale
-         * @param color Pixel color
-         */
-        mraa::Result setPixel (int x, int y, uint16_t color);
-
-        /**
-         * Fills the screen with a selected color
-         *
-         * @param color Selected color
-         */
-        void fillScreen (uint16_t color);
-
-        /**
-         * Fills a rectangle with a selected color
-         *
-         * @param x Axis on the horizontal scale (top-left corner)
-         * @param y Axis on the vertical scale (top-left corner)
-         * @param w Distanse from x
-         * @param h Distanse from y
-         * @param color Selected color
-         */
-        void fillRect (int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color);
-
-        /**
-         * Draws a line on the vertical scale
-         *
-         * @param x Axis on the horizontal scale
-         * @param y Axis on the vertical scale
-         * @param h Distanse from y
-         * @param color Selected color
-         */
-        void drawFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color);
-
-        /**
-         * Draws a line from coordinate C0 to coordinate C1
-         *
-         * @param x0 First coordinate
-         * @param y0 First coordinate
-         * @param x1 Second coordinate
-         * @param y1 Second coordinate
-         * @param color selected color
-         */
-        void drawLine (int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color);
-
-        /**
-         * Draws a triangle
-         *
-         * @param x0 First coordinate
-         * @param y0 First coordinate
-         * @param x1 Second coordinate
-         * @param y1 Second coordinate
-         * @param x2 Third coordinate
-         * @param y2 Third coordinate
-         * @param color Selected color
-         */
-        void drawTriangle (int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color);
-
-        /**
-         * Draws a circle
-         *
-         * @param x Center of the circle on the horizontal scale
-         * @param y Center of the circle on the vertical scale
-         * @param r Radius of the circle
-         * @param color Color of the circle
-         */
-        void drawCircle (int16_t x, int16_t y, int16_t r, uint16_t color);
-
-        /**
-         * Sets the cursor for a text message
-         *
-         * @param x Axis on the horizontal scale
-         * @param y Axis on the vertical scale
-         */
-        void setCursor (int16_t x, int16_t y);
-
-        /**
-         * Sets a text color for a message
-         *
-         * @param textColor Font color
-         * @param textBGColor Background color
-         */
-        void setTextColor (uint16_t textColor, uint16_t textBGColor);
-
-        /**
-         * Sets the size of the font
-         *
-         * @param size Font size
-         */
-        void setTextSize (uint8_t size);
-
-        /**
-         * Wraps a printed message
-         *
-         * @param wrap True (0x1) or false (0x0)
-         */
-        void setTextWrap (uint8_t wrap);
-
-        int m_height; /**< Screen height */
-        int m_width; /**< Screen width */
-        int m_textSize; /**< Printed text size */
-        int m_textColor; /**< Printed text color */
-        int m_textBGColor; /**< Printed text background color */
-        int m_cursorX; /**< Cursor X coordinate */
-        int m_cursorY; /**< Cursor Y coordinate */
-        int m_wrap; /**< Wrapper flag (true or false) */
-
-        uint8_t * m_map; /**< Screens buffer */
-
-    protected:
-        const int16_t   WIDTH, HEIGHT;
-        const unsigned char * m_font;
-    };
-}
diff --git a/src/stepmotor/CMakeLists.txt b/src/stepmotor/CMakeLists.txt
deleted file mode 100644
index 997217f..0000000
--- a/src/stepmotor/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-# Currently no librt in android
-if (NOT ANDROID)
-    set (libname "stepmotor")
-    set (libdescription "Stepper Motor")
-    set (module_src ${libname}.cxx)
-    set (module_hpp ${libname}.hpp)
-    upm_module_init(mraa)
-    target_link_libraries(${libname} rt)
-endif (NOT ANDROID)
diff --git a/src/stepmotor/stepmotor.cxx b/src/stepmotor/stepmotor.cxx
deleted file mode 100644
index 16900ef..0000000
--- a/src/stepmotor/stepmotor.cxx
+++ /dev/null
@@ -1,182 +0,0 @@
-/*
- * Authors: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- *          Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-#include <stdlib.h>
-#include <time.h>
-#include "stepmotor.hpp"
-
-using namespace upm;
-using namespace std;
-
-StepMotor::StepMotor (int dirPin, int stePin, int steps, int enPin)
-                    : m_dirPinCtx(dirPin),
-                      m_stePinCtx(stePin),
-                      m_enPinCtx(0),
-                      m_steps(steps) {
-    m_name = "StepMotor";
-    setSpeed(60);
-    setPosition(0);
-
-    if (m_dirPinCtx.dir(mraa::DIR_OUT) != mraa::SUCCESS) {
-        throw std::runtime_error(string(__FUNCTION__) +
-                               ": Could not initialize dirPin as output");
-        return;
-    }
-    m_dirPinCtx.write(0);
-
-    if (m_stePinCtx.dir(mraa::DIR_OUT) != mraa::SUCCESS) {
-        throw std::runtime_error(string(__FUNCTION__) +
-                               ": Could not initialize stePin as output");
-        return;
-    }
-    m_stePinCtx.write(0);
-
-    if (enPin >= 0) {
-        m_enPinCtx = new mraa::Gpio(enPin);
-        if(m_enPinCtx->dir(mraa::DIR_OUT) != mraa::SUCCESS) {
-            throw std::runtime_error(string(__FUNCTION__) +
-                               ": Could not initialize enPin as output");
-            return;
-        }
-        enable(true);
-    }
-}
-
-StepMotor::~StepMotor () {
-    if (m_enPinCtx)
-        delete m_enPinCtx;
-}
-
-void
-StepMotor::enable (bool flag) {
-    if (m_enPinCtx) {
-        m_enPinCtx->write(flag);
-    } else {
-        throw std::runtime_error(string(__FUNCTION__) +
-                                ": Enable pin not defined");
-    }
-}
-
-void
-StepMotor::setSpeed (int speed) {
-    if (speed > 0) {
-        m_delay = 60000000 / (speed * m_steps);
-    } else {
-        throw std::invalid_argument(string(__FUNCTION__) +
-                                    ": Parameter must be greater than 0");
-    }
-}
-
-mraa::Result
-StepMotor::step (int ticks) {
-    if (ticks < 0) {
-        return stepBackward(abs(ticks));
-    } else {
-        return stepForward(ticks);
-    }
-}
-
-mraa::Result
-StepMotor::stepForward (int ticks) {
-    dirForward();
-    for (int i = 0; i < ticks; i++) {
-        move();
-        m_position++;
-        delayus(m_delay - MINPULSE_US - OVERHEAD_US);
-    }
-    return mraa::SUCCESS;
-}
-
-mraa::Result
-StepMotor::stepBackward (int ticks) {
-    dirBackward();
-    for (int i = 0; i < ticks; i++) {
-        move();
-        m_position--;
-        delayus(m_delay - MINPULSE_US - OVERHEAD_US);
-    }
-    return mraa::SUCCESS;
-}
-
-void
-StepMotor::setPosition (int pos) {
-    m_position = pos;
-}
-
-int
-StepMotor::getPosition () {
-    return m_position;
-}
-
-int
-StepMotor::getStep () {
-    return m_position < 0 ? m_steps + m_position % m_steps :
-                            m_position % m_steps;
-}
-
-void
-StepMotor::move () {
-    m_stePinCtx.write(1);
-    delayus(MINPULSE_US);
-    m_stePinCtx.write(0);
-}
-
-mraa::Result
-StepMotor::dirForward () {
-    mraa::Result error = m_dirPinCtx.write(HIGH);
-    if (error != mraa::SUCCESS) {
-        throw std::runtime_error(string(__FUNCTION__) +
-                                       ": Could not write to dirPin");
-    }
-    return error;
-}
-
-mraa::Result
-StepMotor::dirBackward () {
-    mraa::Result error = m_dirPinCtx.write(LOW);
-    if (error != mraa::SUCCESS) {
-        throw std::runtime_error(string(__FUNCTION__) +
-                                       ": Could not write to dirPin");
-    }
-    return error;
-}
-
-void upm::StepMotor::delayus (int us) {
-    int diff = 0;
-    struct timespec gettime_now;
-
-    clock_gettime(CLOCK_REALTIME, &gettime_now);
-    int start = gettime_now.tv_nsec;
-    while (diff < us * 1000)
-    {
-        clock_gettime(CLOCK_REALTIME, &gettime_now);
-        diff = gettime_now.tv_nsec - start;
-        if (diff < 0)
-            diff += 1000000000;
-    }
-}
diff --git a/src/stepmotor/stepmotor.hpp b/src/stepmotor/stepmotor.hpp
deleted file mode 100644
index 861f249..0000000
--- a/src/stepmotor/stepmotor.hpp
+++ /dev/null
@@ -1,176 +0,0 @@
-/*
- * Authors: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- *          Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Credits to Adafruit.
- * Based on Adafruit BMP085 library.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/pwm.hpp>
-#include <mraa/common.hpp>
-#include <mraa/gpio.hpp>
-
-#define OVERHEAD_US     6
-#define MINPULSE_US     5
-
-#define HIGH            1
-#define LOW             0
-
-namespace upm {
-/**
- * @brief Stepper Motor Library
- * @defgroup stepmotor libupm-stepmotor
- * @ingroup sparkfun generic gpio motor
- */
-/**
- * @library stepmotor
- * @sensor stepmotor
- * @comname Stepper Motor
- * @altname EasyDriver Stepper Motor Driver
- * @type motor
- * @man sparkfun generic
- * @web http://www.schmalzhaus.com/EasyDriver/index.html
- * @con gpio
- *
- * @brief API for the Stepper Motor
- *
- * This module defines the Stepper Motor interface. It is compatible with
- * stepper motor drivers that use 2 pins to control the motor, like an Easy
- * Driver from Brian Schmalz or the STR driver series from Applied Motion. It
- * can also control an enable pin if one is available and connected.
- *
- * The implementation is synchronous and thus blocking while the stepper motor
- * is in motion. However it is possible to send the commands via threading and
- * the performance of the library will be very good given a low CPU load. On a
- * busy system though you will notice some jitter especially at higher speeds.
- * It is possible to reduce this effect to some extent by using smoothing
- * and/or microstepping on stepper drivers that support such features.
- *
- * @image html stepmotor.jpg
- * <br><em>EasyDriver Sensor image provided by SparkFun* under
- * <a href=https://creativecommons.org/licenses/by/2.0/>
- * CC BY 2.0</a>.</em>
- *
- * @snippet stepmotor.cxx Interesting
- */
-class StepMotor {
-    public:
-        /**
-         * Instantiates a StepMotor object.
-         *
-         * @param dirPin Direction GPIO pin
-         * @param stePin Stepper pulse GPIO pin
-         * @param steps Number of steps per revolution (Default 200)
-         * @param enPin Enable pin if connected (Optional)
-         */
-        StepMotor (int dirPin, int stePin, int steps = 200, int enPin = -1);
-
-        /**
-         * StepMotor object destructor.
-         */
-         ~StepMotor ();
-
-        /**
-         * Can be used to enable/disable the stepper driver if an enable pin is
-         * available and connected. Check your data sheet as some drivers might
-         * have the enable logic inverted.
-         *
-         * @param flag true to enable or false to disable
-         */
-        void enable (bool flag);
-
-        /**
-         * Sets the rotation speed in rpm. Default 60 rpm.
-         *
-         * @param speed Rotation speed in rpm
-         */
-        void setSpeed (int speed);
-
-        /**
-         * Rotates the motor by the specified number of steps. Positive values
-         * rotate clockwise and negative values rotate counter-clockwise.
-         *
-         * @param ticks Number of steps the motor moves
-         */
-        mraa::Result step (int ticks);
-
-        /**
-         * Rotates the motor forward (clockwise).
-         *
-         * @param ticks Number of steps the motor moves
-         */
-        mraa::Result stepForward (int ticks);
-
-        /**
-         * Rotates the motor backward (counter-clockwise).
-         *
-         * @param ticks Number of steps the motor moves
-         */
-        mraa::Result stepBackward (int ticks);
-
-        /**
-         * Sets the current position. Useful if the motor is not at 0 when the
-         * driver is initialized.
-         *
-         * @param pos Current position
-         */
-        void setPosition (int pos);
-
-        /**
-         * Gets the current position. This is cumulative and the result of all
-         * the step commands sent to the motor.
-         *
-         * @return Stepper's position.
-         */
-        int getPosition ();
-
-        /**
-         * Gets the current step. This is relative to one revolution.
-         *
-         * @return Current step, ranges from 0 to number of steps per revolution.
-         */
-        int getStep ();
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        StepMotor(const StepMotor&) = delete;
-        StepMotor &operator=(const StepMotor&) = delete;
-
-        std::string         m_name;
-
-        mraa::Gpio          m_dirPinCtx;
-        mraa::Gpio          m_stePinCtx;
-        mraa::Gpio          *m_enPinCtx;
-
-        int                 m_delay;
-        int                 m_steps;
-        int                 m_position;
-
-        mraa::Result dirForward ();
-        mraa::Result dirBackward ();
-        void move ();
-        void delayus (int us);
-    };
-}
diff --git a/src/stepmotor/stepmotor.i b/src/stepmotor/stepmotor.i
deleted file mode 100644
index 16bacc4..0000000
--- a/src/stepmotor/stepmotor.i
+++ /dev/null
@@ -1,14 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_stepmotor)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "stepmotor.hpp"
-%}
-%include "stepmotor.hpp"
-/* END Common SWIG syntax */
diff --git a/src/stepmotor/stepmotor.json b/src/stepmotor/stepmotor.json
deleted file mode 100644
index 07a7022..0000000
--- a/src/stepmotor/stepmotor.json
+++ /dev/null
@@ -1,48 +0,0 @@
-{
-    "Library": "stepmotor",
-    "Description": "Stepper Motor library",
-    "Sensor Class": {
-        "StepMotor": {
-            "Name": "API for the Stepper Motor",
-            "Description": "This is the UPM Module for the API for the Stepper Motor. This module defines the Stepper Motor interface. It is compatible with stepper motor drivers that use 2 pins to control the motor, like an Easy Driver from Brian Schmalz or the STR driver series from Applied Motion. It can also control an enable pin if one is available and connected. The implementation is synchronous and thus blocking while the stepper motor is in motion. However it is possible to send the commands via threading and the performance of the library will be very good given a low CPU load. On a busy system though you will notice some jitter especially at higher speeds. It is possible to reduce this effect to some extent by using smoothing and/or microstepping on stepper drivers that support such features.",
-            "Aliases": ["stepmotor", "EasyDriver - Stepper Motor Driver"],
-            "Categories": ["motor"],
-            "Connections": ["gpio"],
-            "Project Type": ["prototyping", "robotics", "commercial"],
-            "Manufacturers": ["Allegro", "SparkFun", "generic"],
-            "Image": "stepmotor.jpg",
-            "Examples": {
-                "Java": ["StepMotor_Example.java"],
-                "Python": ["stepmotor.py"],
-                "Node.js": ["stepmotor.js"],
-                "C++": ["stepmotor.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.3,
-                    "max": 7.0
-                },
-                "Motor Driver Voltage":{
-                    "unit": "V",
-                    "min" : 6,
-                    "max" : 30
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "min": 150,
-                    "max": 700
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -20,
-                    "max": 85
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.sparkfun.com/products/12779"],
-                "Datasheets": ["https://cdn.sparkfun.com/datasheets/Robotics/A3967-Datasheet.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/sx1276/CMakeLists.txt b/src/sx1276/CMakeLists.txt
deleted file mode 100644
index 01b9930..0000000
--- a/src/sx1276/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "sx1276")
-set (libdescription "SZ1276 LoRa/FSK/OOK Radio")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa ${CMAKE_THREAD_LIBS_INIT})
diff --git a/src/sx1276/LICENSE.txt b/src/sx1276/LICENSE.txt
deleted file mode 100644
index 3078581..0000000
--- a/src/sx1276/LICENSE.txt
+++ /dev/null
@@ -1,25 +0,0 @@
---- Revised BSD License ---
-Copyright (c) 2013, SEMTECH S.A.
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-	* Redistributions of source code must retain the above copyright
-	  notice, this list of conditions and the following disclaimer.
-	* Redistributions in binary form must reproduce the above copyright
-	  notice, this list of conditions and the following disclaimer in the
-	  documentation and/or other materials provided with the distribution.
-	* Neither the name of the Semtech corporation nor the
-	  names of its contributors may be used to endorse or promote products
-	  derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL SEMTECH S.A. BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
\ No newline at end of file
diff --git a/src/sx1276/sx1276.cxx b/src/sx1276/sx1276.cxx
deleted file mode 100644
index e5ad738..0000000
--- a/src/sx1276/sx1276.cxx
+++ /dev/null
@@ -1,2160 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <iostream>
-#include <stdexcept>
-#include <sstream>
-#include <string>
-#include <string.h>
-
-#include "sx1276.hpp"
-
-using namespace upm;
-using namespace std;
-
-//
-// FSK bandwidth to register definition structs
-//
-typedef struct
-{
-  uint32_t bandwidth;
-  uint8_t  RegValue;
-} FskBandwidth_t;
-
-static const FskBandwidth_t FskBandwidths[] =
-{       
-  { 2600  , 0x17 },   
-  { 3100  , 0x0F },
-  { 3900  , 0x07 },
-  { 5200  , 0x16 },
-  { 6300  , 0x0E },
-  { 7800  , 0x06 },
-  { 10400 , 0x15 },
-  { 12500 , 0x0D },
-  { 15600 , 0x05 },
-  { 20800 , 0x14 },
-  { 25000 , 0x0C },
-  { 31300 , 0x04 },
-  { 41700 , 0x13 },
-  { 50000 , 0x0B },
-  { 62500 , 0x03 },
-  { 83333 , 0x12 },
-  { 100000, 0x0A },
-  { 125000, 0x02 },
-  { 166700, 0x11 },
-  { 200000, 0x09 },
-  { 250000, 0x01 },
-  { 300000, 0x00 }, // Invalid Badwidth
-};
-
-
-SX1276::SX1276(uint8_t chipRev, int bus, int cs, int resetPin, int dio0, 
-               int dio1, int dio2, int dio3, int dio4, int dio5) :
-  m_spi(bus), m_gpioCS(cs), m_gpioReset(resetPin), m_gpioDIO0(dio0),
-  m_gpioDIO1(dio1), m_gpioDIO2(dio2), m_gpioDIO3(dio3), m_gpioDIO4(dio4),
-  m_gpioDIO5(dio5)
-{
-  m_spi.mode(mraa::SPI_MODE0);
-  m_spi.frequency(10000000); // 10Mhz, if supported
-
-  m_gpioCS.dir(mraa::DIR_OUT);
-  csOff();
-
-  m_gpioReset.dir(mraa::DIR_IN);
-
-  // 10ms for POR
-  usleep(10000);
-
-  // setup the interrupt handlers.  All 6 of them.
-  m_gpioDIO0.dir(mraa::DIR_IN);
-  if (m_gpioDIO0.isr(mraa::EDGE_RISING, onDio0Irq, this))
-    throw std::runtime_error(string(__FUNCTION__) +
-                             ": Gpio.isr(dio0) failed");
-
-  m_gpioDIO1.dir(mraa::DIR_IN);
-  if (m_gpioDIO1.isr(mraa::EDGE_RISING, onDio1Irq, this))
-    throw std::runtime_error(string(__FUNCTION__) +
-                             ": Gpio.isr(dio1) failed");
-
-  m_gpioDIO2.dir(mraa::DIR_IN);
-  if (m_gpioDIO2.isr(mraa::EDGE_RISING, onDio2Irq, this))
-    throw std::runtime_error(string(__FUNCTION__) +
-                             ": Gpio.isr(dio2) failed");
-
-  m_gpioDIO3.dir(mraa::DIR_IN);
-  if (m_gpioDIO3.isr(mraa::EDGE_RISING, onDio3Irq, this))
-    throw std::runtime_error(string(__FUNCTION__) +
-                             ": Gpio.isr(dio3) failed");
-
-  m_gpioDIO4.dir(mraa::DIR_IN);
-  if (m_gpioDIO4.isr(mraa::EDGE_RISING, onDio4Irq, this))
-    throw std::runtime_error(string(__FUNCTION__) +
-                             ": Gpio.isr(dio4) failed");
-
-  // this one isn't as vital, so no need to fail if this one can't be
-  // setup.
-  m_gpioDIO5.dir(mraa::DIR_IN);
-  if (m_gpioDIO5.isr(mraa::EDGE_RISING, onDio5Irq, this))
-    cerr << __FUNCTION__ << ": Gpio.isr(dio5) failed" << endl;
-
-  initClock();
-  m_radioEvent = REVENT_DONE;
-  m_settings.state = STATE_IDLE;
-  memset(m_rxBuffer, 0, FIFO_SIZE);
-  m_rxSNR = 0;
-  m_rxRSSI = 0;
-
-  // check the chip revision (to make sure we can read the regs properly)
-  uint8_t cRev = getChipVersion();
-  if (cRev != chipRev)
-    {
-      std::ostringstream str;
-      std::ostringstream str2;
-
-      str << hex << (int)cRev << dec;
-      str2 << hex << (int)chipRev << dec;
-      throw std::runtime_error(string(__FUNCTION__) +
-                               ": Incorrect Chip Revision. Expected 0x" +
-                               str2.str() + ", got 0x" + str.str());
-    }
-
-  pthread_mutexattr_t mutexAttrib;
-  pthread_mutexattr_init(&mutexAttrib);
-  //  pthread_mutexattr_settype(&mutexAttrib, PTHREAD_MUTEX_RECURSIVE);
-  
-  if (pthread_mutex_init(&m_intrLock, &mutexAttrib))
-    {
-      pthread_mutexattr_destroy(&mutexAttrib);
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": pthread_mutex_init(intrLock) failed");
-    }
-
-  pthread_mutexattr_destroy(&mutexAttrib);
-
-  init();
-}
-
-SX1276::~SX1276()
-{
-  pthread_mutex_destroy(&m_intrLock);
-}
-
-uint8_t SX1276::readReg(uint8_t reg)
-{
-  uint8_t pkt[2] = {static_cast<uint8_t>(reg & 0x7f), 0};
-
-  csOn();
-  if (m_spi.transfer(pkt, pkt, 2))
-   {
-      csOff();
-      throw std::runtime_error(string(__FUNCTION__) +
-                               ": Spi.transfer() failed");
-      return 0;
-    }
-  csOff();
-
-  return pkt[1];
-}
-
-bool SX1276::writeReg(uint8_t reg, uint8_t val)
-{
-  uint8_t pkt[2] = {static_cast<uint8_t>(reg | m_writeMode), val};
-
-  csOn();
-  if (m_spi.transfer(pkt, NULL, 2))
-    {
-      csOff();
-      throw std::runtime_error(string(__FUNCTION__) +
-                               ": Spi.transfer() failed");
-      return false;
-    }
-  csOff();
-
-  return true;
-}
-
-void SX1276::readFifo(uint8_t *buffer, int len)
-{
-  // can't read more than 256 bytes
-  if (len > FIFO_SIZE)
-    {
-      throw std::length_error(string(__FUNCTION__) +
-                              ": cannot read more than 256 bytes from FIFO");
-      return;
-    }
-
-  uint8_t pkt = 0;
-
-  csOn();
-  if (m_spi.transfer(&pkt, NULL, 1))
-    {
-      csOff();
-      throw std::runtime_error(string(__FUNCTION__) +
-                               ": Spi.transfer(0) failed");
-      return;
-    }
-
-  if (m_spi.transfer(NULL, buffer, len))
-    {
-      csOff();
-      throw std::runtime_error(string(__FUNCTION__) +
-                               ": Spi.transfer(buf) failed");
-      return;
-    }
-  csOff();
-}
-
-void SX1276::writeFifo(uint8_t *buffer, int len)
-{
-  // can't write more than 256 bytes
-  if (len > FIFO_SIZE)
-    {
-      throw std::length_error(string(__FUNCTION__) +
-                              ": cannot write more than 256 bytes to FIFO");
-      return;
-    }
-
-  uint8_t pkt = (0 | m_writeMode);
-
-  csOn();
-  if (m_spi.transfer(&pkt, NULL, 1))
-    {
-      csOff();
-      throw std::runtime_error(string(__FUNCTION__) +
-                               ": Spi.transfer(0) failed");
-      return;
-    }
-
-  if (m_spi.transfer(buffer, NULL, len))
-    {
-      csOff();
-      throw std::runtime_error(string(__FUNCTION__) +
-                               ": Spi.transfer(buf) failed");
-      return;
-    }
-  csOff();
-}
-
-
-uint8_t SX1276::getChipVersion()
-{
-  return readReg(COM_RegVersion);
-}
-
-
-void SX1276::reset()
-{
-  m_gpioReset.dir(mraa::DIR_OUT);
-  usleep(1000); // 1ms
-  m_gpioReset.dir(mraa::DIR_IN);
-  usleep(10000); // 10ms
-}
-
-
-void SX1276::init()
-{
-  typedef struct
-  {
-    RADIO_MODEM_T  Modem;
-    uint8_t        Addr;
-    uint8_t        Value;
-  } radioRegisters_t;
-  
-  // some initial setup
-  static const radioRegisters_t radioRegsInit[] = {
-    { MODEM_FSK , COM_RegLna             , 0x23 },
-    { MODEM_FSK , FSK_RegRxConfig        , 0x1E },
-    { MODEM_FSK , FSK_RegRssiConfg       , 0xD2 },
-    { MODEM_FSK , FSK_RegPreambleDetect  , 0xAA },
-    { MODEM_FSK , FSK_RegOsc             , 0x07 },
-    { MODEM_FSK , FSK_RegSyncConfig      , 0x12 },
-    { MODEM_FSK , FSK_RegSyncValue1      , 0xC1 },
-    { MODEM_FSK , FSK_RegSyncValue2      , 0x94 },
-    { MODEM_FSK , FSK_RegSyncValue3      , 0xC1 },
-    { MODEM_FSK , FSK_RegPacketConfig1   , 0xD8 },
-    { MODEM_FSK , FSK_RegFifoThresh      , 0x8F },
-    { MODEM_FSK , FSK_RegImageCal        , 0x02 },
-    { MODEM_FSK , COM_RegDioMapping1     , 0x00 },
-    { MODEM_FSK , COM_RegDioMapping2     , 0x30 },
-    { MODEM_LORA, LOR_RegMaxPayloadLength, 0x40 }
-  };
-
-  reset();
-
-  rxChainCalibration();
-
-  setOpMode(MODE_Sleep);
-
-  for (size_t i = 0; i < sizeof(radioRegsInit) / sizeof(radioRegisters_t); i++ )
-    {
-      setModem(radioRegsInit[i].Modem);
-      writeReg(radioRegsInit[i].Addr, radioRegsInit[i].Value);
-    }
-  
-  setModem(MODEM_FSK);
-  m_settings.state = STATE_IDLE;
-}
-
-void SX1276::rxChainCalibration()
-{
-  uint8_t regPaConfigInitVal;
-  uint32_t initialFreq;
-  uint8_t reg;
-
-  // this function should only be called in init() (after reset()), as
-  // the device is configured for FSK mode, LF at that time.
-  
-  // Save context
-  regPaConfigInitVal = readReg(COM_RegPaConfig);
-  initialFreq = (uint32_t) ( ((double)
-                               (((uint32_t)readReg(COM_RegFrfMsb) << 16) |
-                                 ((uint32_t)readReg(COM_RegFrfMid) << 8) |
-                                 ((uint32_t)readReg(COM_RegFrfLsb)) ) )
-    * FXOSC_STEP);
-  
-  // Cut the PA just in case, RFO output, power = -1 dBm
-  writeReg(COM_RegPaConfig, 0x00);
-  
-  // Launch Rx chain calibration for LF band
-  reg = readReg(FSK_RegImageCal);
-  writeReg(FSK_RegImageCal, reg | IMAGECAL_ImageCalStart); 
-
-  // spin until complete
-  while (readReg(FSK_RegImageCal) & IMAGECAL_ImageCalRunning)
-    usleep(1);
-
-  //  cerr << __FUNCTION__ << ": Imagecal LF complete" << endl;
-  
-  // Set a Frequency in HF band
-  setChannel(868000000);
-  
-  // Launch Rx chain calibration for HF band 
-  reg = readReg(FSK_RegImageCal);
-  writeReg(FSK_RegImageCal, reg | IMAGECAL_ImageCalStart); 
-
-  // spin until complete
-  while (readReg(FSK_RegImageCal) & IMAGECAL_ImageCalRunning)
-    usleep(1);
-  
-  //  cerr << __FUNCTION__ << ": Imagecal HF complete" << endl;
-  
-  // Restore context
-  writeReg(COM_RegPaConfig, regPaConfigInitVal);
-  setChannel(initialFreq);
-}
-
-void SX1276::setChannel(uint32_t freq)
-{
-  m_settings.channel = freq;
-
-  freq = ( uint32_t )( ( double )freq / FXOSC_STEP );
-
-  writeReg(COM_RegFrfMsb, ( uint8_t )( ( freq >> 16 ) & 0xff ) );
-  writeReg(COM_RegFrfMid, ( uint8_t )( ( freq >> 8 ) & 0xff ) );
-  writeReg(COM_RegFrfLsb, ( uint8_t )( freq & 0xff ) );
-}
-
-void SX1276::setOpMode(MODE_T opMode)
-{
-  static uint8_t opModePrev = MODE_Standby;
-  
-  if(opMode != opModePrev)
-    {
-      opModePrev = opMode;
-
-      uint8_t reg = readReg(COM_RegOpMode) & 
-        ~(_OPMODE_Mode_MASK << _OPMODE_Mode_SHIFT);
-      
-      writeReg(COM_RegOpMode, (reg | (opMode << _OPMODE_Mode_SHIFT)) );
-    }
-}
-
-void SX1276::setModem(RADIO_MODEM_T modem)
-{
-  if (m_settings.modem == modem )
-    {
-      return;
-    }
-  
-  m_settings.modem = modem;
-
-  uint8_t reg = 0;
-
-  switch (m_settings.modem)
-    {
-    default:
-    case MODEM_FSK:
-      setOpMode(MODE_Sleep);
-
-      // turn off lora
-      reg = (readReg(COM_RegOpMode) & ~OPMODE_LongRangeMode);
-      writeReg(COM_RegOpMode, reg);
-      
-      writeReg(COM_RegDioMapping1, 0x00);
-      writeReg(COM_RegDioMapping2, 0x30); // DIO5=ModeReady
-
-      break;
-
-    case MODEM_LORA:
-      setOpMode(MODE_Sleep);
-      // turn lora on
-      reg = (readReg(COM_RegOpMode) | OPMODE_LongRangeMode);
-      writeReg(COM_RegOpMode, reg);
-      
-      writeReg(COM_RegDioMapping1, 0x00);
-      writeReg(COM_RegDioMapping2, 0x00);
-
-      break;
-    }
-}
-
-bool SX1276::isChannelFree(RADIO_MODEM_T modem, uint32_t freq, 
-                           int16_t rssiThresh)
-{
-  int16_t rssi = 0;
-  
-  setModem(modem);
-  
-  setChannel(freq);
-  
-  setOpMode(MODE_FSK_RxMode);
-  
-  usleep(1000);
-  
-  rssi = getRSSI(modem);
-  
-  setSleep();
-  
-  if (rssi > rssiThresh)
-    {
-      return false;
-    }
-
-  return true;
-}
-
-int16_t SX1276::getRSSI(RADIO_MODEM_T modem)
-{
-  int16_t rssi = 0;
-  
-  switch (modem)
-    {
-    case MODEM_FSK:
-      // devide by 2
-      rssi = -(readReg(FSK_RegRssiValue) >> 1);
-
-      break;
-
-    case MODEM_LORA:
-      {
-        uint8_t reg = readReg(LOR_RegRssiValue);
-        if (m_settings.channel > RF_MID_BAND_THRESH )
-          {
-            rssi = LOR_RSSI_OFFSET_HF + reg;
-          }
-        else
-          {
-            rssi = LOR_RSSI_OFFSET_LF + reg;
-          }
-      }
-      break;
-
-    default:
-      rssi = -1;
-
-      break;
-    }
-
-  return rssi;
-}
-
-void SX1276::setSleep()
-{
-  setOpMode(MODE_Sleep);
-  m_settings.state = STATE_IDLE;
-}
-
-void SX1276::setStandby()
-{
-  setOpMode(MODE_Standby);
-  m_settings.state = STATE_IDLE;
-}
-
-uint8_t SX1276::lookupFSKBandWidth(uint32_t bw)
-{
-  // This function looks up values in the fsk_bw_lookup_table and
-  // returns the approprite register value to use for either the
-  // FSK_RxBw or the FSK_RegAfcBw registers
-
-  // See Table 40 in the datasheet
-
-  for (size_t i=0; i<(sizeof(FskBandwidths)/sizeof(FskBandwidth_t)) - 1; i++)
-    {
-      if ( (bw >= FskBandwidths[i].bandwidth) && 
-           (bw < FskBandwidths[i + 1].bandwidth) )
-        {
-          return FskBandwidths[i].RegValue;
-        }
-    }
-  
-  // shouldn't happen, but the universe is vast and indifferent...
-  throw std::range_error(std::string(__FUNCTION__) +
-                         ": Unable to find bandwidth in lookup table. "
-                         "Bandwidth must be between 2600 and 250000 for FSK");
-
-  return 0;
-}
-
-SX1276::RADIO_EVENT_T SX1276::sendStr(string buffer, int timeout)
-{
-  if (buffer.size() > (FIFO_SIZE - 1))
-    throw std::range_error(string(__FUNCTION__) +
-                           ": buffer size must be less than 256");
-
-  // for LORA/FSK modem, there seems to be a 64 byte requirement,
-  // (LOR_RegRxNbBytes on the receiver) never seems to be anything
-  // other than 64. Same seems to go for the FSK modem.  So, if the
-  // packet is less than 64, pad it out to 64 bytes.  This requires
-  // investigation.
-  while (buffer.size() < 64)
-    buffer.push_back(0);
-
-  return send((uint8_t *)buffer.c_str(), buffer.size(), timeout);
-}
-
-SX1276::RADIO_EVENT_T SX1276::send(uint8_t *buffer, uint8_t size, 
-                                   int txTimeout)
-{
-  switch (m_settings.modem)
-    {
-    case MODEM_FSK:
-      {
-        m_settings.fskPacketHandler.NbBytes = 0;
-        m_settings.fskPacketHandler.Size = size;
-
-        if (m_settings.fskSettings.FixLen == false)
-          {
-            writeFifo((uint8_t *)&size, 1);
-          }
-        else
-          {
-            writeReg(FSK_RegPayloadLength, size );
-          }
-
-        if ( (size > 0) && (size <= 64) )
-          {
-            m_settings.fskPacketHandler.ChunkSize = size;
-          }
-        else
-          {
-            m_settings.fskPacketHandler.ChunkSize = 32;
-          }
-
-        // Write payload buffer
-        writeFifo(buffer, m_settings.fskPacketHandler.ChunkSize);
-        m_settings.fskPacketHandler.NbBytes += 
-          m_settings.fskPacketHandler.ChunkSize;
-      }
-
-      break;
-
-    case MODEM_LORA:
-      {
-        if (m_settings.loraSettings.IqInverted == true)
-          {
-            uint8_t reg = readReg(LOR_RegInvertIQ);
-
-            reg &= ~(INVERTIQ_InvertIQTxOff | INVERTIQ_InvertIQRx);
-            writeReg(LOR_RegInvertIQ, reg);
-
-            // warning, hardcoded undocumented magic number into
-            // undocumented register
-            writeReg(LOR_RegInvertIQ2, 0x19);
-          }
-        else
-          {
-            uint8_t reg = readReg(LOR_RegInvertIQ);
-            reg &= ~(INVERTIQ_InvertIQTxOff | INVERTIQ_InvertIQRx);
-            reg |= INVERTIQ_InvertIQTxOff; // 'active' off.
-            writeReg(LOR_RegInvertIQ, reg);
-
-            // warning, hardcoded undocumented magic number into
-            // undocumented register
-            writeReg(LOR_RegInvertIQ2, 0x1d);
-          }
-
-        m_settings.loraPacketHandler.Size = size;
-        //        cerr << "PAYLOAD SIZE " << (int)size << endl;
-
-        // Initializes the payload size
-        writeReg(LOR_RegPayloadLength, size);
-
-        // Full buffer used for Tx
-        writeReg(LOR_RegFifoTxBaseAddr, 0);
-        writeReg(LOR_RegFifoAddrPtr, 0 );
-
-        // FIFO operations can not take place in Sleep mode
-        if ((readReg(COM_RegOpMode) & _OPMODE_Mode_MASK) == MODE_Sleep)
-          {
-            setStandby();
-            usleep(1000); // 1ms
-          }
-
-        // Write payload buffer
-        writeFifo(buffer, size);
-      }
-
-      break;
-    }
-
-  return setTx(txTimeout);
-}
-
-
-void SX1276::setRxConfig(RADIO_MODEM_T modem, uint32_t bandwidth,
-                         uint32_t datarate, uint8_t coderate,
-                         uint32_t bandwidthAfc, uint16_t preambleLen,
-                         uint16_t symbTimeout, bool fixLen,
-                         uint8_t payloadLen,
-                         bool crcOn, bool freqHopOn, uint8_t hopPeriod,
-                         bool iqInverted, bool rxContinuous)
-{
-  setModem( modem );
-  
-  uint8_t reg;
-  
-  switch (modem)
-    {
-    case MODEM_FSK:
-      {
-        m_settings.fskSettings.Bandwidth = bandwidth;
-        m_settings.fskSettings.Datarate = datarate;
-        m_settings.fskSettings.BandwidthAfc = bandwidthAfc;
-        m_settings.fskSettings.FixLen = fixLen;
-        m_settings.fskSettings.PayloadLen = payloadLen;
-        m_settings.fskSettings.CrcOn = crcOn;
-        m_settings.fskSettings.IqInverted = iqInverted;
-        m_settings.fskSettings.RxContinuous = rxContinuous;
-        m_settings.fskSettings.PreambleLen = preambleLen;
-            
-        datarate = (uint16_t)(FXOSC_FREQ / (double)datarate);
-        writeReg(FSK_RegBitrateMsb, (uint8_t)(datarate >> 8));
-        writeReg(FSK_RegBitrateLsb, (uint8_t)(datarate & 0xff));
-        
-        writeReg(FSK_RegRxBw, lookupFSKBandWidth(bandwidth));
-        writeReg(FSK_RegAfcBw, lookupFSKBandWidth(bandwidthAfc));
-        
-        writeReg(FSK_RegPreambleMsb, 
-                 (uint8_t)((preambleLen >> 8) & 0xff));
-        writeReg(FSK_RegPreambleLsb, (uint8_t)(preambleLen & 0xff));
-            
-        if (fixLen)
-          {
-            writeReg(FSK_RegPayloadLength, payloadLen);
-          }
-            
-        reg = readReg(FSK_RegPacketConfig1);
-        reg &= ~(PACKETCONFIG1_CrcOn | PACKETCONFIG1_PacketFormat);
-
-        if (!fixLen)
-          reg |= PACKETCONFIG1_PacketFormat; // variable len
-        
-        if (crcOn)
-          reg |= PACKETCONFIG1_CrcOn;
-
-        writeReg(FSK_RegPacketConfig1, reg);
-      }
-
-      break;
-
-    case MODEM_LORA:
-      {
-        // convert the supplied (legal) LORA bandwidths into something
-        // the chip can handle.
-        switch (bandwidth) 
-          {
-          case 125000:
-            bandwidth = BW_125;
-            break;
-            
-          case 250000:
-            bandwidth = BW_250;
-            break;
-            
-          case 500000:
-            bandwidth = BW_500;
-            break;
-            
-          default:
-            throw std::runtime_error(std::string(__FUNCTION__) +
-                                     ": LORA bandwidth must be 125000, 250000, "
-                                     "or 500000");
-          }
-
-        m_settings.loraSettings.Bandwidth = bandwidth;
-        m_settings.loraSettings.Datarate = datarate;
-        m_settings.loraSettings.Coderate = coderate;
-        m_settings.loraSettings.FixLen = fixLen;
-        m_settings.loraSettings.PayloadLen = payloadLen;
-        m_settings.loraSettings.CrcOn = crcOn;
-        m_settings.loraSettings.FreqHopOn = freqHopOn;
-        m_settings.loraSettings.HopPeriod = hopPeriod;
-        m_settings.loraSettings.IqInverted = iqInverted;
-        m_settings.loraSettings.RxContinuous = rxContinuous;
-
-        // datarate is really LORA SPREADING_FACTOR_*
-        if (datarate > 12)
-          {
-            datarate = 12;
-          }
-        else if (datarate < 6)
-          {
-            datarate = 6;
-          }
-        
-        if ( ((bandwidth == BW_125) && ((datarate == 11) || 
-                                        (datarate == 12))) ||
-             ((bandwidth == BW_250) && (datarate == 12)) )
-          {
-            m_settings.loraSettings.LowDatarateOptimize = true;
-          }
-        else
-          {
-            m_settings.loraSettings.LowDatarateOptimize = false;
-          }
-
-        reg = readReg(LOR_RegModemConfig1);
-        reg &= ~((_MODEMCONFIG1_CodingRate_MASK << 
-                  _MODEMCONFIG1_CodingRate_SHIFT) |
-                 (_MODEMCONFIG1_Bw_MASK << _MODEMCONFIG1_Bw_SHIFT) |
-                 MODEMCONFIG1_ImplicitHeaderModeOn);
-
-        if (fixLen)
-          reg |= MODEMCONFIG1_ImplicitHeaderModeOn;
-
-        reg |= ((bandwidth & _MODEMCONFIG1_Bw_MASK) << _MODEMCONFIG1_Bw_SHIFT);
-        reg |= ((coderate & _MODEMCONFIG1_CodingRate_MASK) << 
-                _MODEMCONFIG1_CodingRate_SHIFT);
-
-        writeReg(LOR_RegModemConfig1, reg);
-
-        reg = readReg(LOR_RegModemConfig2);
-        reg &= ~((_MODEMCONFIG2_SpreadingFactor_MASK << 
-                  _MODEMCONFIG2_SpreadingFactor_SHIFT) |
-                 MODEMCONFIG2_RxPayloadCrcOn |
-                 (_MODEMCONFIG2_SymbTimeoutMsb_MASK <<
-                  _MODEMCONFIG2_SymbTimeoutMsb_SHIFT));
-
-        if (crcOn)
-          reg |= MODEMCONFIG2_RxPayloadCrcOn;
-
-        reg |= ((datarate & _MODEMCONFIG2_SpreadingFactor_MASK) << 
-                _MODEMCONFIG2_SpreadingFactor_SHIFT);
-
-        // mask symbTimeOut (MSB) for safety
-        reg |= ( ((symbTimeout >> 8) & _MODEMCONFIG2_SymbTimeoutMsb_MASK) << 
-                 _MODEMCONFIG2_SymbTimeoutMsb_SHIFT);
-        writeReg(LOR_RegModemConfig2, reg);
-
-        reg = readReg(LOR_RegModemConfig3);
-        
-        reg &= ~MODEMCONFIG3_LowDataRateOptimize;
-
-        if (m_settings.loraSettings.LowDatarateOptimize)
-          reg |= MODEMCONFIG3_LowDataRateOptimize;
-
-        writeReg(LOR_RegModemConfig3, reg);
-
-        writeReg(LOR_RegSymbTimeoutLsb, (uint8_t)(symbTimeout & 0xff));
-
-            
-        writeReg(LOR_RegPreambleMsb, (uint8_t)((preambleLen >> 8) & 0xff));
-        writeReg(LOR_RegPreambleLsb, (uint8_t)(preambleLen & 0xff));
-
-        if (fixLen == 1)
-          writeReg(LOR_RegPayloadLength, payloadLen);
-
-        // The datasheet says this is only valid in FSK mode, but
-        // Semtech code indicates it is only available in LORA
-        // mode... So which is it?
-        
-        // Lets assume for now that the code is correct, as there
-        // is a HopPeriod register for LoRa, and no such registers
-        // exist for FSK.
-        if (m_settings.loraSettings.FreqHopOn)
-          {
-            reg = readReg(LOR_RegPllHop);
-            reg &= ~PLLHOP_FastHopOn;
-            reg |= PLLHOP_FastHopOn;
-            writeReg(LOR_RegPllHop, reg);
-
-            writeReg(LOR_RegHopPeriod, m_settings.loraSettings.HopPeriod);
-          }
-        else
-          {
-            reg = readReg(LOR_RegPllHop);
-            reg &= ~PLLHOP_FastHopOn;
-            writeReg(LOR_RegPllHop, reg);
-          }
-
-        // errata checks - writing magic numbers into undocumented,
-        // reserved registers :) The Semtech code was broken in this
-        // logic.
-        if ( (bandwidth == BW_500) && 
-             (m_settings.channel > RF_MID_BAND_THRESH) )
-          {
-            // ERRATA 2.1 - Sensitivity Optimization with a 500 kHz
-            // Bandwidth (HF)
-            writeReg(LOR_Reserved36, 0x02);
-            writeReg(LOR_Reserved3a, 0x64);
-          }
-        else if (bandwidth == BW_500 && 
-                 (m_settings.channel >= 410000000))
-          {
-            // ERRATA 2.1 - Sensitivity Optimization with a 500 kHz
-            // Bandwidth (LF above 410Mhz)
-            writeReg(LOR_Reserved36, 0x02);
-            writeReg(LOR_Reserved3a, 0x7f);
-          }
-        else
-          {
-            // ERRATA 2.1 - Sensitivity Optimization with a 500 kHz
-            // Bandwidth (everything else)
-            writeReg(LOR_Reserved36, 0x03);
-          }
-                 
-        // datarate is really LORA spreading factor
-        if (datarate == 6)
-          {
-            // datarate == SPREADINGFACTOR_64
-            reg = readReg(LOR_RegDetectOptimize);
-            reg &= ~(_DETECTOPTIMIZE_DetectionOptimize_MASK << 
-                     _DETECTOPTIMIZE_DetectionOptimize_SHIFT);
-
-            reg |= (DETECTIONOPTIMIZE_SF6 << 
-                    _DETECTOPTIMIZE_DetectionOptimize_SHIFT);
-
-            writeReg(LOR_RegDetectOptimize, reg);
-
-            // see page 27 in the datasheet
-            writeReg(LOR_RegDetectionThreshold, LOR_DetectionThreshold_SF6);
-          }
-        else
-          {
-            reg = readReg(LOR_RegDetectOptimize);
-            reg &= ~(_DETECTOPTIMIZE_DetectionOptimize_MASK << 
-                     _DETECTOPTIMIZE_DetectionOptimize_SHIFT);
-
-            reg |= (DETECTIONOPTIMIZE_SF7_SF12 << 
-                    _DETECTOPTIMIZE_DetectionOptimize_SHIFT);
-
-            writeReg(LOR_RegDetectOptimize, reg);
-
-            // see page 27 in the datasheet
-            writeReg(LOR_RegDetectionThreshold, 
-                     LOR_DetectionThreshold_SF7_SF12);
-          }
-      }
-      break;
-    }
-}
-
-void SX1276::setTxConfig(RADIO_MODEM_T modem, int8_t power, 
-                         uint32_t fdev, 
-                         uint32_t bandwidth, uint32_t datarate,
-                         uint8_t coderate, uint16_t preambleLen,
-                         bool fixLen, bool crcOn, bool freqHopOn, 
-                         uint8_t hopPeriod, bool iqInverted)
-{
-  uint8_t paConfig = 0;
-  uint8_t paDac = 0;
-  
-  setModem(modem);
-    
-  paConfig = readReg(COM_RegPaConfig);
-  paDac = readReg(COM_RegPaDac);
-
-  uint8_t paSelect = 0x00; // default, +14dBm
-  if (m_settings.channel < RF_MID_BAND_THRESH)
-    paSelect = PACONFIG_PaSelect; // PA_BOOST, +20dBm
-  
-  paConfig &= ~PACONFIG_PaSelect;
-  paConfig |= paSelect;
-  paConfig &= ~(_PACONFIG_MaxPower_MASK << _PACONFIG_MaxPower_SHIFT);
-  paConfig |= (7 << _PACONFIG_MaxPower_SHIFT); // PACONFIG_MaxPower = 7
-
-  if ((paConfig & PACONFIG_PaSelect))
-    {
-      if (power > 17)
-        {
-          paDac &= ~(_PADAC_PaDac_MASK << _PADAC_PaDac_SHIFT);
-          paDac |= (PADAC_BOOST << _PADAC_PaDac_SHIFT);
-        }
-      else
-        {
-          paDac &= ~(_PADAC_PaDac_MASK << _PADAC_PaDac_SHIFT);
-          paDac |= (PADAC_DEFAULT << _PADAC_PaDac_SHIFT);
-        }
-
-      if ((paDac & PADAC_BOOST) == PADAC_BOOST)
-        {
-          if (power < 5)
-            {
-              power = 5;
-            }
-          if (power > 20)
-            {
-              power = 20;
-            }
-          paConfig = ~(_PACONFIG_OutputPower_MASK & _PACONFIG_OutputPower_SHIFT);
-          paConfig |= ( ((uint8_t)(power - 5) & 
-                         _PACONFIG_OutputPower_MASK) << 
-                        _PACONFIG_OutputPower_SHIFT );
-        }
-      else
-        {
-          if (power < 2)
-            {
-              power = 2;
-            }
-          if (power > 17)
-            {
-              power = 17;
-            }
-          
-          paConfig = ~(_PACONFIG_OutputPower_MASK & _PACONFIG_OutputPower_SHIFT);
-          paConfig |= ( ((uint8_t)(power - 2) & 
-                         _PACONFIG_OutputPower_MASK) << 
-                        _PACONFIG_OutputPower_SHIFT );
-        }
-    }
-  else
-    {
-      if (power < -1)
-        {
-          power = -1;
-        }
-      if (power > 14)
-        {
-          power = 14;
-        }
-
-      paConfig = ~(_PACONFIG_OutputPower_MASK & _PACONFIG_OutputPower_SHIFT);
-      paConfig |= ( ((uint8_t)(power + 1) & 
-                    _PACONFIG_OutputPower_MASK) << 
-                    _PACONFIG_OutputPower_SHIFT );
-    }
-  writeReg(COM_RegPaConfig, paConfig);
-  writeReg(COM_RegPaDac, paDac);
-
-  uint8_t reg;
-
-  switch (modem)
-    {
-    case MODEM_FSK:
-      {
-        m_settings.fskSettings.Power = power;
-        m_settings.fskSettings.Fdev = fdev;
-        m_settings.fskSettings.Bandwidth = bandwidth;
-        m_settings.fskSettings.Datarate = datarate;
-        m_settings.fskSettings.PreambleLen = preambleLen;
-        m_settings.fskSettings.FixLen = fixLen;
-        m_settings.fskSettings.CrcOn = crcOn;
-        m_settings.fskSettings.IqInverted = iqInverted;
-            
-        fdev = (uint16_t)((double)fdev / FXOSC_STEP);
-        writeReg(FSK_RegFdevMsb, (uint8_t)(fdev >> 8));
-        writeReg(FSK_RegFdevLsb, (uint8_t)(fdev & 0xFF));
-
-        datarate = (uint16_t)(FXOSC_FREQ / (double)datarate);
-        writeReg(FSK_RegBitrateMsb, (uint8_t)(datarate >> 8));
-        writeReg(FSK_RegBitrateLsb, (uint8_t)(datarate & 0xff));
-        
-        writeReg(FSK_RegPreambleMsb, (uint8_t)(preambleLen >> 8));
-        writeReg(FSK_RegPreambleLsb, (uint8_t)(preambleLen & 0xff));
-        
-        reg = readReg(FSK_RegPacketConfig1);
-        reg &= ~(PACKETCONFIG1_CrcOn | PACKETCONFIG1_PacketFormat);
-
-        if (!fixLen)
-          reg |= PACKETCONFIG1_PacketFormat; // variable len
-
-        if (crcOn)
-          reg |= PACKETCONFIG1_CrcOn;
-
-        writeReg(FSK_RegPacketConfig1, reg);
-      }
-      break;
-      
-    case MODEM_LORA:
-      {
-        m_settings.loraSettings.Power = power;
-
-        // we convert bandwidth into appropriate BW_* constants for LORA
-        switch (bandwidth) {
-        case 125000:
-          bandwidth = BW_125;
-          break;
-
-        case 250000:
-          bandwidth = BW_250;
-          break;
-
-        case 500000:
-          bandwidth = BW_500;
-          break;
-
-        default:
-          throw std::runtime_error(std::string(__FUNCTION__) +
-                                   ": LORA bandwidth must be 125000, 250000, "
-                                   "or 500000");
-        }
-
-
-        m_settings.loraSettings.Bandwidth = bandwidth;
-        m_settings.loraSettings.Datarate = datarate;
-        m_settings.loraSettings.Coderate = coderate;
-        m_settings.loraSettings.PreambleLen = preambleLen;
-        m_settings.loraSettings.FixLen = fixLen;
-        m_settings.loraSettings.FreqHopOn = freqHopOn;
-        m_settings.loraSettings.HopPeriod = hopPeriod;
-        m_settings.loraSettings.CrcOn = crcOn;
-        m_settings.loraSettings.IqInverted = iqInverted;
-        
-        // datarate is really SPREADINGFACTOR_* for LoRa
-        if (datarate > 12)
-          {
-            datarate = 12;
-          }
-        else if (datarate < 6)
-          {
-            datarate = 6;
-          }
-        
-        if ( ((bandwidth == BW_125) && ((datarate == 11) || 
-                                        (datarate == 12))) ||
-             ((bandwidth == BW_250) && (datarate == 12)) )
-          {
-            m_settings.loraSettings.LowDatarateOptimize = true;
-          }
-        else
-          {
-            m_settings.loraSettings.LowDatarateOptimize = false;
-          }
-        
-
-        // datasheet says this is only valid in FSK mode, but Semtech
-        // code indicates it is only available in LORA mode... So
-        // which is it?
-        
-        // Lets assume for now that the code is correct, as there
-        // is a HopPeriod register for LoRa, and no such registers
-        // exist for FSK.
-        if (m_settings.loraSettings.FreqHopOn == true)
-          {
-            reg = readReg(LOR_RegPllHop);
-            reg &= ~PLLHOP_FastHopOn;
-            reg |= PLLHOP_FastHopOn;
-            writeReg(LOR_RegPllHop, reg);
-
-            writeReg(LOR_RegHopPeriod, m_settings.loraSettings.HopPeriod);
-          }
-        else
-          {
-            reg = readReg(LOR_RegPllHop);
-            reg &= ~PLLHOP_FastHopOn;
-            writeReg(LOR_RegPllHop, reg);
-          }
-        
-        reg = readReg(LOR_RegModemConfig1);
-        reg &= ~((_MODEMCONFIG1_CodingRate_MASK << 
-                  _MODEMCONFIG1_CodingRate_SHIFT) |
-                 (_MODEMCONFIG1_Bw_MASK << _MODEMCONFIG1_Bw_SHIFT) |
-                 MODEMCONFIG1_ImplicitHeaderModeOn);
-
-        if (fixLen)
-          reg |= MODEMCONFIG1_ImplicitHeaderModeOn;
-
-        reg |= ((bandwidth & _MODEMCONFIG1_Bw_MASK) << _MODEMCONFIG1_Bw_SHIFT);
-        reg |= ((coderate & _MODEMCONFIG1_CodingRate_MASK) << 
-                _MODEMCONFIG1_CodingRate_SHIFT);
-
-        writeReg(LOR_RegModemConfig1, reg);
-
-        reg = readReg(LOR_RegModemConfig2);
-        reg &= ~((_MODEMCONFIG2_SpreadingFactor_MASK << 
-                  _MODEMCONFIG2_SpreadingFactor_SHIFT) |
-                 MODEMCONFIG2_RxPayloadCrcOn);
-
-        if (crcOn)
-          reg |= MODEMCONFIG2_RxPayloadCrcOn;
-
-        reg |= ((datarate & _MODEMCONFIG2_SpreadingFactor_MASK) << 
-                _MODEMCONFIG2_SpreadingFactor_SHIFT);
-        writeReg(LOR_RegModemConfig2, reg);
-
-        reg = readReg(LOR_RegModemConfig3);
-        
-        reg &= ~MODEMCONFIG3_LowDataRateOptimize;
-
-        if (m_settings.loraSettings.LowDatarateOptimize)
-          reg |= MODEMCONFIG3_LowDataRateOptimize;
-
-        writeReg(LOR_RegModemConfig3, reg);
-
-        writeReg(LOR_RegPreambleMsb, (uint8_t)((preambleLen >> 8) & 0xff));
-        writeReg(LOR_RegPreambleLsb, (uint8_t)(preambleLen & 0xff));
-        
-        // datarate is SPREADINGFACTOR_*
-        if (datarate == 6)
-          {
-            reg = readReg(LOR_RegDetectOptimize);
-            reg &= ~(_DETECTOPTIMIZE_DetectionOptimize_MASK << 
-                     _DETECTOPTIMIZE_DetectionOptimize_SHIFT);
-
-            reg |= (DETECTIONOPTIMIZE_SF6 << 
-                    _DETECTOPTIMIZE_DetectionOptimize_SHIFT);
-
-            writeReg(LOR_RegDetectOptimize, reg);
-
-            // see page 27 in the datasheet
-            writeReg(LOR_RegDetectionThreshold, LOR_DetectionThreshold_SF6);
-
-          }
-        else
-          {
-            reg = readReg(LOR_RegDetectOptimize);
-            reg &= ~(_DETECTOPTIMIZE_DetectionOptimize_MASK << 
-                     _DETECTOPTIMIZE_DetectionOptimize_SHIFT);
-
-            reg |= (DETECTIONOPTIMIZE_SF7_SF12 << 
-                    _DETECTOPTIMIZE_DetectionOptimize_SHIFT);
-
-            writeReg(LOR_RegDetectOptimize, reg);
-
-            // see page 27 in the datasheet
-            writeReg(LOR_RegDetectionThreshold, 
-                     LOR_DetectionThreshold_SF7_SF12);
-          }
-      }
-
-      break;
-    }
-}
-
-SX1276::RADIO_EVENT_T SX1276::setTx(int timeout)
-{
-  uint8_t reg = 0;
-
-  switch (m_settings.modem)
-    {
-    case MODEM_FSK:
-      {
-        // DIO0=PacketSent
-        // DIO1=FifoLevel
-        // DIO2=FifoFull
-        // DIO3=FifoEmpty
-        // DIO4=LowBat
-        // DIO5=ModeReady
-
-        reg = readReg(COM_RegDioMapping1);
-        reg &= ~( (DOIMAPPING1_Dio0Mapping_MASK << 
-                   DOIMAPPING1_Dio0Mapping_SHIFT) |
-                  (DOIMAPPING1_Dio2Mapping_MASK << 
-                   DOIMAPPING1_Dio2Mapping_SHIFT) );
-
-        writeReg(COM_RegDioMapping1, reg);
-
-
-        reg = readReg(COM_RegDioMapping2);
-        reg &= ~( (DOIMAPPING2_Dio4Mapping_MASK << 
-                   DOIMAPPING2_Dio4Mapping_SHIFT) |
-                  (DOIMAPPING2_Dio5Mapping_MASK << 
-                   DOIMAPPING2_Dio5Mapping_SHIFT) );
-
-        writeReg(COM_RegDioMapping2, reg);
-
-        m_settings.fskPacketHandler.FifoThresh = 
-          (readReg(FSK_RegFifoThresh) & 
-           (_FIFOTHRESH_FifoThreshold_MASK << _FIFOTHRESH_FifoThreshold_SHIFT));
-      }
-
-      break;
-
-    case MODEM_LORA:
-      {
-        if (m_settings.loraSettings.FreqHopOn == true )
-          {
-            // mask out all except TxDone and FhssChangeChannel
-            writeReg(LOR_RegIrqFlagsMask, 
-                     LOR_IRQFLAG_RxTimeout |
-                     LOR_IRQFLAG_RxDone |
-                     LOR_IRQFLAG_PayloadCrcError |
-                     LOR_IRQFLAG_ValidHeader |
-                     // LOR_IRQFLAG_TxDone |
-                     LOR_IRQFLAG_CadDone |
-                     // LOR_IRQFLAG_FhssChangeChannel |
-                     LOR_IRQFLAG_CadDetected);
-            
-            // DIO0=TxDone, DIO2=FhssChangeChannel
-            reg = readReg(COM_RegDioMapping1);
-            reg &= ~( (DOIMAPPING1_Dio0Mapping_MASK << 
-                       DOIMAPPING1_Dio0Mapping_SHIFT) |
-                      (DOIMAPPING1_Dio2Mapping_MASK << 
-                       DOIMAPPING1_Dio2Mapping_SHIFT) );
-            reg |= ( (DIOMAPPING_01 << DOIMAPPING1_Dio0Mapping_SHIFT) |
-                     (DIOMAPPING_00 << DOIMAPPING1_Dio2Mapping_SHIFT) );
-            writeReg(COM_RegDioMapping1, reg);
-          }
-        else
-          {
-            // mask out all except TxDone
-            writeReg(LOR_RegIrqFlagsMask, 
-                     LOR_IRQFLAG_RxTimeout |
-                     LOR_IRQFLAG_RxDone |
-                     LOR_IRQFLAG_PayloadCrcError |
-                     LOR_IRQFLAG_ValidHeader |
-                     // LOR_IRQFLAG_TxDone |
-                     LOR_IRQFLAG_CadDone |
-                     LOR_IRQFLAG_FhssChangeChannel |
-                     LOR_IRQFLAG_CadDetected);
-
-            // DIO0=TxDone
-            reg = readReg(COM_RegDioMapping1);
-            reg &= ~( (DOIMAPPING1_Dio0Mapping_MASK << 
-                       DOIMAPPING1_Dio0Mapping_SHIFT) );
-            reg |= (DIOMAPPING_01 << DOIMAPPING1_Dio0Mapping_SHIFT);
-            writeReg(COM_RegDioMapping1, reg);
-          }
-      }
-      break;
-    }
-
-  m_settings.state = STATE_TX_RUNNING;
-  m_radioEvent = REVENT_EXEC;
-
-  setOpMode(MODE_TxMode);
-
-  initClock();
-  while ((getMillis() < static_cast<uint32_t>(timeout)) && m_radioEvent == REVENT_EXEC)
-    usleep(100);
-
-  if (m_radioEvent == REVENT_EXEC)
-    {
-      // timeout
-      m_radioEvent = REVENT_TIMEOUT;
-    }
-
-  return m_radioEvent;
-}
-
-SX1276::RADIO_EVENT_T SX1276::setRx(uint32_t timeout)
-{
-  bool rxContinuous = false;
-  uint8_t reg = 0;
-
-  switch (m_settings.modem)
-    {
-    case MODEM_FSK:
-      {
-        rxContinuous = m_settings.fskSettings.RxContinuous;
-            
-        // DIO0=PayloadReady
-        // DIO1=FifoLevel
-        // DIO2=SyncAddr
-        // DIO3=FifoEmpty
-        // DIO4=Preamble
-        // DIO5=ModeReady
-        reg = readReg(COM_RegDioMapping1);
-        reg &= ~( (DOIMAPPING1_Dio0Mapping_MASK << 
-                   DOIMAPPING1_Dio0Mapping_SHIFT) |
-                  (DOIMAPPING1_Dio2Mapping_MASK << 
-                   DOIMAPPING1_Dio2Mapping_SHIFT) );
-        reg |= ( (DIOMAPPING_00 << DOIMAPPING1_Dio0Mapping_SHIFT) |
-                 (DIOMAPPING_11 << DOIMAPPING1_Dio2Mapping_SHIFT) );
-        writeReg(COM_RegDioMapping1, reg);
-
-            
-        reg = readReg(COM_RegDioMapping2);
-        reg &= ~( (DOIMAPPING2_Dio4Mapping_MASK << 
-                   DOIMAPPING2_Dio4Mapping_SHIFT) |
-                  (DOIMAPPING2_Dio5Mapping_MASK << 
-                   DOIMAPPING2_Dio5Mapping_SHIFT) );
-        reg |= (DIOMAPPING_11 << DOIMAPPING2_Dio4Mapping_SHIFT) |
-          DOIMAPPING2_MapPreambleDetect;
-
-        writeReg(COM_RegDioMapping2, reg);
-
-        m_settings.fskPacketHandler.FifoThresh = 
-          (readReg(FSK_RegFifoThresh) & _FIFOTHRESH_FifoThreshold_MASK);
-            
-        m_settings.fskPacketHandler.PreambleDetected = false;
-        m_settings.fskPacketHandler.SyncWordDetected = false;
-        m_settings.fskPacketHandler.NbBytes = 0;
-        m_settings.fskPacketHandler.Size = 0;
-      }
-
-      break;
-
-    case MODEM_LORA:
-      {
-        // The datasheet does not mention anything other than an
-        // InvertIQ bit (0x40) in RegInvertIQ register (0x33).  Here,
-        // we seem to have two bits in RegInvertIQ (existing one for
-        // RX), and a 'new' one for TXOff (0x01).  In addition,
-        // INVERTIQ2 (0x3b) does not exist in the datasheet, it is
-        // marked as reserved. We will assume that the datasheet is
-        // out of date.
-
-        if (m_settings.loraSettings.IqInverted == true)
-          {
-            reg = readReg(LOR_RegInvertIQ);
-            reg &= ~(INVERTIQ_InvertIQTxOff | INVERTIQ_InvertIQRx);
-            reg |= INVERTIQ_InvertIQRx;
-            writeReg(LOR_RegInvertIQ, reg);
-
-            // warning, hardcoded undocumented magic number into
-            // undocumented register
-            writeReg(LOR_RegInvertIQ2, 0x19);
-          }
-        else
-          {
-            reg = readReg(LOR_RegInvertIQ);
-            reg &= ~(INVERTIQ_InvertIQTxOff | INVERTIQ_InvertIQRx);
-            reg |= INVERTIQ_InvertIQTxOff; // 'active' off.
-            writeReg(LOR_RegInvertIQ, reg);
-
-            // warning, hardcoded undocumented magic number into
-            // undocumented register
-            writeReg(LOR_RegInvertIQ2, 0x1d);
-          }         
-
-        // ERRATA 2.3 - Receiver Spurious Reception of a LoRa Signal
-        if (m_settings.loraSettings.Bandwidth < 9)
-          {
-            reg = readReg(LOR_RegDetectOptimize);
-            reg &= 0x7f; // clear undocumented bit 7
-            writeReg(LOR_RegDetectOptimize, reg);
-
-            // warning, writing magic numbers into undocumented
-            // registers
-            switch (m_settings.loraSettings.Bandwidth)
-              {
-              case 0: // 7.8 kHz
-                writeReg(LOR_Reserved2f, 0x48);
-                setChannel(m_settings.channel + 7.81e3);
-                break;
-              case 1: // 10.4 kHz
-                writeReg(LOR_Reserved2f, 0x44);
-                setChannel(m_settings.channel + 10.42e3);
-                break;
-              case 2: // 15.6 kHz
-                writeReg(LOR_Reserved2f, 0x44);
-                setChannel(m_settings.channel + 15.62e3);
-                break;
-              case 3: // 20.8 kHz
-                writeReg(LOR_Reserved2f, 0x44);
-                setChannel(m_settings.channel + 20.83e3);
-                break;
-              case 4: // 31.2 kHz
-                writeReg(LOR_Reserved2f, 0x44);
-                setChannel(m_settings.channel + 31.25e3);
-                break;
-              case 5: // 41.4 kHz
-                writeReg(LOR_Reserved2f, 0x44);
-                setChannel(m_settings.channel + 41.67e3);
-                break;
-              case 6: // 62.5 kHz
-                writeReg(LOR_Reserved2f, 0x40);
-                break;
-              case 7: // 125 kHz
-                writeReg(LOR_Reserved2f, 0x40);
-                break;
-              case 8: // 250 kHz
-                writeReg(LOR_Reserved2f, 0x40);
-                break;
-              }
-          }
-        else
-          {
-            reg = readReg(LOR_RegDetectOptimize);
-            reg |= 0x80; // set undocumented bit 7
-            writeReg(LOR_RegDetectOptimize, reg);
-          }
-
-        rxContinuous = m_settings.loraSettings.RxContinuous;
-            
-        if (m_settings.loraSettings.FreqHopOn == true)
-          {
-            // mask out all except RxDone, RxTimeout, PayloadCrCError,
-            // and FhssChangeChannel
-            writeReg(LOR_RegIrqFlagsMask, 
-                     // LOR_IRQFLAG_RxTimeout |
-                     // LOR_IRQFLAG_RxDone |
-                     // LOR_IRQFLAG_PayloadCrcError |
-                     LOR_IRQFLAG_ValidHeader |
-                     LOR_IRQFLAG_TxDone |
-                     LOR_IRQFLAG_CadDone |
-                     // LOR_IRQFLAG_FhssChangeChannel |
-                     LOR_IRQFLAG_CadDetected);
-
-            // DIO0=RxDone, DIO2=FhssChangeChannel
-            reg = readReg(COM_RegDioMapping1);
-            reg &= ~( (DOIMAPPING1_Dio0Mapping_MASK << 
-                       DOIMAPPING1_Dio0Mapping_SHIFT) |
-                      (DOIMAPPING1_Dio2Mapping_MASK << 
-                       DOIMAPPING1_Dio2Mapping_SHIFT) );
-            reg |= ( (DIOMAPPING_00 << DOIMAPPING1_Dio0Mapping_SHIFT) |
-                     (DIOMAPPING_00 << DOIMAPPING1_Dio2Mapping_SHIFT) );
-            writeReg(COM_RegDioMapping1, reg);
-          }
-        else
-          {
-            // mask out all except RxDone, RxTimeout, and PayloadCrCError
-            writeReg(LOR_RegIrqFlagsMask, 
-                     // LOR_IRQFLAG_RxTimeout |
-                     // LOR_IRQFLAG_RxDone |
-                     // LOR_IRQFLAG_PayloadCrcError |
-                     LOR_IRQFLAG_ValidHeader |
-                     LOR_IRQFLAG_TxDone |
-                     LOR_IRQFLAG_CadDone |
-                     LOR_IRQFLAG_FhssChangeChannel |
-                     LOR_IRQFLAG_CadDetected);
-
-            // DIO0=RxDone
-            reg = readReg(COM_RegDioMapping1);
-            reg &= ~(DOIMAPPING1_Dio0Mapping_MASK << 
-                     DOIMAPPING1_Dio0Mapping_SHIFT);
-            reg |= (DIOMAPPING_00 << DOIMAPPING1_Dio0Mapping_SHIFT);
-            writeReg(COM_RegDioMapping1, reg);
-          }
-
-        writeReg(LOR_RegFifoRxBaseAddr, 0);
-        writeReg(LOR_RegFifoAddrPtr, 0);
-      }
-
-      break;
-
-    }
-
-  memset(m_rxBuffer, 0, FIFO_SIZE);
-
-  m_settings.state = STATE_RX_RUNNING;
-  m_radioEvent = REVENT_EXEC;
-
-  if (m_settings.modem == MODEM_FSK)
-    {
-      setOpMode(MODE_FSK_RxMode);
-        
-      if (rxContinuous == false)
-        {
-          // timer..?
-#if 0
-          TimerSetValue( &RxTimeoutSyncWord, ( 8.0 * ( m_settings.fsk.PreambleLen +
-                                                       ( ( SX1276Read( REG_SYNCCONFIG ) &
-                                                           ~RF_SYNCCONFIG_SYNCSIZE_MASK ) +
-                                                         1.0 ) + 10.0 ) /
-                                               ( double )m_settings.fsk.Datarate ) * 1e6 );
-          TimerStart( &RxTimeoutSyncWord );
-#endif
-        }
-    }
-  else
-    {
-      // LoRa
-
-      if (rxContinuous == true)
-        {
-          setOpMode(MODE_LOR_RxContinuous);
-        }
-      else
-        {
-          setOpMode(MODE_LOR_RxSingle);
-        }
-    }
-
-  initClock();
-  while ((getMillis() < timeout) && m_radioEvent == REVENT_EXEC)
-    usleep(100);
-
-  if (m_radioEvent == REVENT_EXEC)
-    {
-      // timeout
-      m_radioEvent = REVENT_TIMEOUT;
-    }
-
-  return m_radioEvent;
-}
-
-
-void SX1276::startCAD()
-{
-  switch (m_settings.modem)
-    {
-    case MODEM_LORA:
-      {
-        // mask out all except CadDone and CadDetected
-        writeReg(LOR_RegIrqFlagsMask, 
-                 LOR_IRQFLAG_RxTimeout |
-                 LOR_IRQFLAG_RxDone |
-                 LOR_IRQFLAG_PayloadCrcError |
-                 LOR_IRQFLAG_ValidHeader |
-                 LOR_IRQFLAG_TxDone |
-                 // LOR_IRQFLAG_CadDone |
-                 LOR_IRQFLAG_FhssChangeChannel //|
-                 // LOR_IRQFLAG_CadDetected
-                 );
-
-        // DIO3=CADDone
-
-        uint8_t reg;
-        reg = readReg(COM_RegDioMapping1);
-        reg &= ~(DOIMAPPING1_Dio3Mapping_MASK << 
-                 DOIMAPPING1_Dio3Mapping_SHIFT);
-        reg |= (DIOMAPPING_00 << DOIMAPPING1_Dio3Mapping_SHIFT);
-        writeReg(COM_RegDioMapping1, reg);
-        
-        m_settings.state = STATE_CAD;
-        setOpMode(MODE_LOR_CAD);
-      }
-
-      break;
-
-    case MODEM_FSK:
-    default:
-      break;
-    }
-}
-
-void SX1276::setMaxPayloadLength(RADIO_MODEM_T modem, uint8_t max)
-{
-  setModem(modem);
-  
-  switch (modem)
-    {
-    case MODEM_FSK:
-      if (m_settings.fskSettings.FixLen == false)
-        {
-          writeReg(FSK_RegPayloadLength, max);
-        }
-
-      break;
-
-    case MODEM_LORA:
-      writeReg(LOR_RegMaxPayloadLength, max);
-
-      break;
-    }
-}
-
-
-void SX1276::onDio0Irq(void *ctx)
-{
-  upm::SX1276 *This = (upm::SX1276 *)ctx;
-
-  This->lockIntrs();
-
-  volatile uint8_t irqFlags = 0;
-
-  //  cerr << __FUNCTION__ << ": Enter" << endl;
-
-  switch (This->m_settings.state)
-    {
-    case STATE_RX_RUNNING:
-
-      // RxDone interrupt
-      switch (This->m_settings.modem)
-        {
-        case MODEM_FSK:
-
-          if (This->m_settings.fskSettings.CrcOn == true )
-            {
-              irqFlags = This->readReg(FSK_RegIrqFlags2);
-
-              if (!(irqFlags & IRQFLAGS2_CrcOk))
-                {
-                  // Clear Irqs
-                  This->writeReg(FSK_RegIrqFlags1,
-                                 IRQFLAGS1_Rssi | 
-                                 IRQFLAGS1_PreambleDetect |
-                                 IRQFLAGS1_SyncAddressMatch);
-                  This->writeReg(FSK_RegIrqFlags2, IRQFLAGS2_FifoOverrun);
-
-                  if (This->m_settings.fskSettings.RxContinuous == false )
-                    {
-                      This->m_settings.state = STATE_IDLE;
-                    }
-                  else
-                    {
-                      // Continuous mode restart Rx chain
-                      This->writeReg(FSK_RegRxConfig,
-                                     This->readReg(FSK_RegRxConfig) | 
-                                     RXCONFIG_RestartRxWithoutPllLock);
-                    }
-
-                  // RxError radio event
-                  //                  cerr << __FUNCTION__ << ": RxError crc/sync timeout" << endl;
-                  This->m_radioEvent = REVENT_ERROR;
-
-                  This->m_settings.fskPacketHandler.PreambleDetected = false;
-                  This->m_settings.fskPacketHandler.SyncWordDetected = false;
-                  This->m_settings.fskPacketHandler.NbBytes = 0;
-                  This->m_settings.fskPacketHandler.Size = 0;
-                  break;
-                }
-            }
-
-          // Read received packet size
-          if ( (This->m_settings.fskPacketHandler.Size == 0) && 
-               (This->m_settings.fskPacketHandler.NbBytes == 0) )
-            {
-              if (This->m_settings.fskSettings.FixLen == false )
-                {
-                  This->readFifo((uint8_t*)&(This->m_settings.fskPacketHandler.Size),
-                                 1);
-                }
-              else
-                {
-                  This->m_settings.fskPacketHandler.Size = 
-                    This->readReg(FSK_RegPayloadLength);
-                }
-
-              This->readFifo(This->m_rxBuffer + 
-                             This->m_settings.fskPacketHandler.NbBytes, 
-                             This->m_settings.fskPacketHandler.Size - 
-                             This->m_settings.fskPacketHandler.NbBytes);
-
-              This->m_settings.fskPacketHandler.NbBytes += 
-                (This->m_settings.fskPacketHandler.Size - 
-                 This->m_settings.fskPacketHandler.NbBytes);
-            }
-          else
-            {
-              This->readFifo(This->m_rxBuffer + 
-                             This->m_settings.fskPacketHandler.NbBytes, 
-                             (This->m_settings.fskPacketHandler.Size - 
-                              This->m_settings.fskPacketHandler.NbBytes));
-
-              This->m_settings.fskPacketHandler.NbBytes += 
-                (This->m_settings.fskPacketHandler.Size - 
-                 This->m_settings.fskPacketHandler.NbBytes);
-            }
-
-          if (This->m_settings.fskSettings.RxContinuous == false)
-            {
-              This->m_settings.state = STATE_IDLE;
-            }
-          else
-            {
-              // Continuous mode restart Rx chain
-              This->writeReg(FSK_RegRxConfig,
-                             This->readReg(FSK_RegRxConfig) | 
-                             RXCONFIG_RestartRxWithoutPllLock);
-            }
-
-          // RxDone radio event
-          This->m_rxRSSI = This->m_settings.fskPacketHandler.RssiValue;
-          This->m_rxLen = This->m_settings.fskPacketHandler.Size;
-          This->m_radioEvent = REVENT_DONE;
-          // cerr << __FUNCTION__ << ": FSK RxDone" << endl;
-          // fprintf(stderr, "### %s: RX(%d): %s\n", 
-          //         __FUNCTION__, 
-          //         This->m_settings.fskPacketHandler.Size,
-          //         This->m_rxBuffer);
-
-          This->m_settings.fskPacketHandler.PreambleDetected = false;
-          This->m_settings.fskPacketHandler.SyncWordDetected = false;
-          This->m_settings.fskPacketHandler.NbBytes = 0;
-          This->m_settings.fskPacketHandler.Size = 0;
-
-          break;
-
-        case MODEM_LORA:
-          {
-            int8_t snr = 0;
-
-            // Clear Irq
-            This->writeReg(LOR_RegIrqFlags, LOR_IRQFLAG_RxDone);
-
-            irqFlags = This->readReg(LOR_RegIrqFlags);
-
-            // cerr << "LORA PayloadCRC on = " 
-            //      <<  hex << (int)This->readReg(LOR_RegHopChannel) << dec << endl;
-            if (irqFlags & LOR_IRQFLAG_PayloadCrcError)
-              {
-                // Clear Irq
-                This->writeReg(LOR_RegIrqFlags, LOR_IRQFLAG_PayloadCrcError);
-                if (This->m_settings.loraSettings.RxContinuous == false)
-                  {
-                    This->m_settings.state = STATE_IDLE;
-                  }
-                // RxError radio event
-                // cerr << __FUNCTION__ << ": RxError (payload crc error)" << endl;
-                This->m_radioEvent = REVENT_ERROR;
-
-                break;
-              }
-
-            This->m_settings.loraPacketHandler.SnrValue = 
-              This->readReg(LOR_RegPktSnrValue);
-
-            if (This->m_settings.loraPacketHandler.SnrValue & 0x80)
-              {
-                // The SNR sign bit is 1
-                // Invert and divide by 4
-                snr = ( (~(This->m_settings.loraPacketHandler.SnrValue) + 1 ) & 
-                        0xff) >> 2;
-                snr = -snr;
-              }
-            else
-              {
-                // Divide by 4
-                snr = (This->m_settings.loraPacketHandler.SnrValue & 0xff) >> 2;
-              }
-
-            int16_t rssi = This->readReg(LOR_RegPktRssiValue);
-
-            if (snr < 0)
-              {
-                if (This->m_settings.channel > RF_MID_BAND_THRESH)
-                  {
-                    This->m_settings.loraPacketHandler.RssiValue =
-                      LOR_RSSI_OFFSET_HF + rssi + ( rssi >> 4 ) + snr;
-                  }
-                else
-                  {
-                    This->m_settings.loraPacketHandler.RssiValue =
-                      LOR_RSSI_OFFSET_LF + rssi + ( rssi >> 4 ) + snr;
-                  }
-              }
-            else
-              {
-                if (This->m_settings.channel > RF_MID_BAND_THRESH)
-                  {
-                    This->m_settings.loraPacketHandler.RssiValue =
-                      LOR_RSSI_OFFSET_HF + rssi + (rssi >> 4);
-                  }
-                else
-                  {
-                    This->m_settings.loraPacketHandler.RssiValue =
-                      LOR_RSSI_OFFSET_LF + rssi + (rssi >> 4);
-                  }
-              }
-
-            This->m_settings.loraPacketHandler.Size = 
-              This->readReg(LOR_RegRxNbBytes);
-
-            // cerr << "LORA HANDLER SIZE = " 
-            //      <<  (int)This->m_settings.loraPacketHandler.Size << endl;
-
-            // cerr << "LORA MAXPAYLOAD = " 
-            //      <<  (int)This->readReg(LOR_RegMaxPayloadLength) << endl;
-
-            This->readFifo(This->m_rxBuffer, 
-                           This->m_settings.loraPacketHandler.Size);
-
-            if (This->m_settings.loraSettings.RxContinuous == false)
-              {
-                This->m_settings.state = STATE_IDLE;
-              }
-
-            // RxDone radio event
-            
-            // The returned size (from LOR_RegRxNbBytes) is always 64
-            // bytes regardless of the packet size I sent.  Something
-            // is wrong here.
-            //            cerr << __FUNCTION__ << ": RxDone (LORA)" << endl;
-            This->m_rxRSSI = (int)rssi;
-            This->m_rxSNR = (int)snr;
-            This->m_rxLen = This->m_settings.loraPacketHandler.Size;
-            This->m_radioEvent = REVENT_DONE;
-            // if (This->m_settings.state == STATE_RX_RUNNING)
-            //   fprintf(stderr, "### %s: snr = %d rssi = %d RX(%d): %s\n", 
-            //           __FUNCTION__, 
-            //           (int)snr, (int)rssi,
-            //           This->m_settings.loraPacketHandler.Size,
-            //           This->m_rxBuffer);
-            // else
-            //   fprintf(stderr, "### %s: snr = %d rssi = %d RX: INV BUFFER (crc)\n", __FUNCTION__, 
-            //         (int)snr, (int)rssi);
-
-          }
-
-          break;
-
-        default:
-          break;
-
-        }
-
-      break;
-
-    case STATE_TX_RUNNING:
-
-      // TxDone interrupt
-      switch (This->m_settings.modem)
-        {
-        case MODEM_LORA:
-          // Clear Irq
-          This->writeReg(LOR_RegIrqFlags, LOR_IRQFLAG_TxDone);
-          // fprintf(stderr, "%s: LORA IrqFlags = %02x\n", __FUNCTION__,
-          //         This->readReg(LOR_RegIrqFlags));
-          // Intentional fall through
-   
-        case MODEM_FSK:
-        default:
-          This->m_settings.state = STATE_IDLE;
-
-          // TxDone radio event
-          This->m_radioEvent = REVENT_DONE;
-          //          cerr << __FUNCTION__ << ": TxDone" << endl;
-
-          break;
-        }
-      break;
-
-    default:
-      break;
-    }
-
-  This->unlockIntrs();
-}
-
-
-void SX1276::onDio1Irq(void *ctx)
-{
-  upm::SX1276 *This = (upm::SX1276 *)ctx;
-
-  This->lockIntrs();
-  //  cerr << __FUNCTION__ << ": Enter" << endl;
-
-  switch (This->m_settings.state)
-    {                
-    case STATE_RX_RUNNING:
-
-      switch (This->m_settings.modem)
-        {
-        case MODEM_FSK:
-          // FifoLevel interrupt
-          // Read received packet size
-          if ( (This->m_settings.fskPacketHandler.Size == 0 ) && 
-               (This->m_settings.fskPacketHandler.NbBytes == 0) )
-            {
-              if (This->m_settings.fskSettings.FixLen == false)
-                {
-                  This->readFifo((uint8_t*)&(This->m_settings.fskPacketHandler.Size),
-                                 1);
-                }
-              else
-                {
-                  This->m_settings.fskPacketHandler.Size = 
-                    This->readReg(FSK_RegPayloadLength);
-                }
-            }
-          
-          if ( (This->m_settings.fskPacketHandler.Size - 
-                This->m_settings.fskPacketHandler.NbBytes) > 
-               This->m_settings.fskPacketHandler.FifoThresh)
-            {
-              This->readFifo((This->m_rxBuffer + 
-                              This->m_settings.fskPacketHandler.NbBytes), 
-                             This->m_settings.fskPacketHandler.FifoThresh);
-              This->m_settings.fskPacketHandler.NbBytes += 
-                This->m_settings.fskPacketHandler.FifoThresh;
-            }
-          else
-            {
-              This->readFifo((This->m_rxBuffer +
-                              This->m_settings.fskPacketHandler.NbBytes),
-                             This->m_settings.fskPacketHandler.Size - 
-                             This->m_settings.fskPacketHandler.NbBytes);
-              This->m_settings.fskPacketHandler.NbBytes += 
-                (This->m_settings.fskPacketHandler.Size - 
-                 This->m_settings.fskPacketHandler.NbBytes);
-            }
-
-          break;
-
-        case MODEM_LORA:
-          // Sync time out
-          This->m_settings.state = STATE_IDLE;
-          // RxError (LORA timeout) radio events
-          //          cerr << __FUNCTION__ << ": RxTimeout (LORA)" << endl;
-          This->m_radioEvent = REVENT_TIMEOUT;
-
-          break;
-
-        default:
-          break;
-        }
-
-      break;
-
-    case STATE_TX_RUNNING:
-
-      switch (This->m_settings.modem )
-        {
-        case MODEM_FSK:
-          // FifoLevel interrupt
-          if ( (This->m_settings.fskPacketHandler.Size - 
-                This->m_settings.fskPacketHandler.NbBytes) > 
-               This->m_settings.fskPacketHandler.ChunkSize)
-            {
-              This->writeFifo((This->m_rxBuffer + 
-                               This->m_settings.fskPacketHandler.NbBytes), 
-                              This->m_settings.fskPacketHandler.ChunkSize);
-              This->m_settings.fskPacketHandler.NbBytes += 
-                This->m_settings.fskPacketHandler.ChunkSize;
-            }
-          else 
-            {
-              // Write the last chunk of data
-              This->writeFifo((This->m_rxBuffer +
-                               This->m_settings.fskPacketHandler.NbBytes),
-                              This->m_settings.fskPacketHandler.Size - 
-                              This->m_settings.fskPacketHandler.NbBytes);
-              This->m_settings.fskPacketHandler.NbBytes += 
-                (This->m_settings.fskPacketHandler.Size - 
-                 This->m_settings.fskPacketHandler.NbBytes);
-            }
-          break;
-
-        case MODEM_LORA:
-          break;
-
-        default:
-          break;
-        }
-      break;      
-
-    default:
-      break;
-    }
-
-  This->unlockIntrs();
-}
-
-void SX1276::onDio2Irq(void *ctx)
-{
-  upm::SX1276 *This = (upm::SX1276 *)ctx;
-
-  This->lockIntrs();
-  //  cerr << __FUNCTION__ << ": Enter" << endl;
-
-  switch (This->m_settings.state)
-    {
-    case STATE_RX_RUNNING:
-
-      switch (This->m_settings.modem)
-        {
-        case MODEM_FSK:
-          if ( (This->m_settings.fskPacketHandler.PreambleDetected == true ) && 
-              (This->m_settings.fskPacketHandler.SyncWordDetected == false) )
-            {
-              This->m_settings.fskPacketHandler.SyncWordDetected = true;
-
-              This->m_settings.fskPacketHandler.RssiValue = 
-                -(This->readReg(FSK_RegRssiValue) >> 1 );
-
-              This->m_settings.fskPacketHandler.AfcValue = 
-                (int32_t)(double)( ((uint16_t)This->readReg(FSK_RegAfcMsb) << 8 ) |
-                                   (uint16_t)This->readReg(FSK_RegAfcLsb) ) *
-                FXOSC_STEP;
-              This->m_settings.fskPacketHandler.RxGain = 
-                (This->readReg(COM_RegLna) >> 5) & 0x07;
-            }
-
-          break;
-
-        case MODEM_LORA:
-          if (This->m_settings.loraSettings.FreqHopOn == true)
-            {
-              // Clear Irq
-              This->writeReg(LOR_RegIrqFlags, LOR_IRQFLAG_FhssChangeChannel);
-
-              // Fhss radio event (unsupported currently)
-              // FhssChangeChannel( (readReg( LOR_RegHopChannel) & 
-              // ~_HOPCHANNEL_FhssPresentChannel_MASK) );
-              //cerr << __FUNCTION__ << ": Fhss Change Channel (LORA, RX running)" << endl;
-            }
-          break;
-
-        default:
-          break;
-        }
-      break;
-
-    case STATE_TX_RUNNING:
-      switch (This->m_settings.modem)
-        {
-        case MODEM_FSK:
-          break;
-        case MODEM_LORA:
-          if (This->m_settings.loraSettings.FreqHopOn == true)
-            {
-              // Clear Irq
-              This->writeReg(LOR_RegIrqFlags, LOR_IRQFLAG_FhssChangeChannel);
-                    
-              // Fhss radio event (unsupported currently)
-              // FhssChangeChannel( (readReg( LOR_RegHopChannel) & 
-              // ~_HOPCHANNEL_FhssPresentChannel_MASK) );
-              //cerr << __FUNCTION__ << ": Fhss Change Channel (LORA, TX running)" << endl;
-            }
-          break;
-
-        default:
-          break;
-        }
-      break;      
-
-    default:
-      break;
-    }
-
-  This->unlockIntrs();
-}
-
-void SX1276::onDio3Irq(void *ctx)
-{
-  upm::SX1276 *This = (upm::SX1276 *)ctx;
-
-  This->lockIntrs();
-  //  cerr << __FUNCTION__ << ": Enter" << endl;
-  switch (This->m_settings.modem)
-    {
-    case MODEM_FSK:
-      break;
-
-    case MODEM_LORA:
-      if (This->readReg(LOR_RegIrqFlags) & LOR_IRQFLAG_CadDetected)
-        {
-          // Clear Irq
-          This->writeReg(LOR_RegIrqFlags, 
-                         (LOR_IRQFLAG_CadDetected | LOR_IRQFLAG_CadDone));
-
-          // CADDetected radio event (true)
-          // cerr << __FUNCTION__ << ": CadDetected (LORA)" << endl;
-
-        }
-      else
-        {
-          // Clear Irq
-          This->writeReg(LOR_RegIrqFlags, LOR_IRQFLAG_CadDone);
-          // CADDetected radio event (false)
-          //cerr << __FUNCTION__ << ": CadDone (LORA)" << endl;
-        }
-
-      break;
-
-    default:
-      break;
-    }
-
-  This->unlockIntrs();
-}
-
-void SX1276::onDio4Irq(void *ctx)
-{
-  upm::SX1276 *This = (upm::SX1276 *)ctx;
-
-  This->lockIntrs();
-  //  cerr << __FUNCTION__ << ": Enter" << endl;
-  switch (This->m_settings.modem)
-    {
-    case MODEM_FSK:
-      {
-        if (This->m_settings.fskPacketHandler.PreambleDetected == false)
-          {
-            This->m_settings.fskPacketHandler.PreambleDetected = true;
-          }
-      }
-
-      break;
-
-    case MODEM_LORA:
-      break;
-
-    default:
-      break;
-    }
-
-  This->unlockIntrs();
-}
-
-void SX1276::onDio5Irq(void *ctx)
-{
-  upm::SX1276 *This = (upm::SX1276 *)ctx;
-
-  This->lockIntrs();
-  //  cerr << __FUNCTION__ << ": Enter" << endl;
-  switch (This->m_settings.modem)
-    {
-    case MODEM_FSK:
-      break;
-    case MODEM_LORA:
-      //      fprintf(stderr, "%s: LORA IrqFlags = %02x\n", __FUNCTION__,
-      //              This->readReg(LOR_RegIrqFlags));
-      break;
-    default:
-      break;
-    }
-
-  This->unlockIntrs();
-}
-
-void SX1276::initClock()
-{
-  gettimeofday(&m_startTime, NULL);
-}
-
-uint32_t SX1276::getMillis()
-{
-  struct timeval elapsed, now;
-  uint32_t elapse;
-
-  // get current time
-  gettimeofday(&now, NULL);
-
-  // compute the delta since m_startTime
-  if( (elapsed.tv_usec = now.tv_usec - m_startTime.tv_usec) < 0 ) 
-    {
-      elapsed.tv_usec += 1000000;
-      elapsed.tv_sec = now.tv_sec - m_startTime.tv_sec - 1;
-    } 
-  else 
-    {
-      elapsed.tv_sec = now.tv_sec - m_startTime.tv_sec;
-    }
-
-  elapse = (uint32_t)((elapsed.tv_sec * 1000) + (elapsed.tv_usec / 1000));
-
-  // never return 0
-  if (elapse == 0)
-    elapse = 1;
-
-  return elapse;
-}
-
-
diff --git a/src/sx1276/sx1276.hpp b/src/sx1276/sx1276.hpp
deleted file mode 100644
index 6379ab9..0000000
--- a/src/sx1276/sx1276.hpp
+++ /dev/null
@@ -1,2036 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Thanks to Semtech for their example code at:
- * https://github.com/Lora-net/LoRaMac-node
- * released under a modified BSD license, for many clues as to how to
- * initialize and operate this radio properly.
- * See src/sx1276/LICENSE.txt
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <string>
-
-#include <sys/time.h>
-#include <sys/select.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <pthread.h>
-
-#include <mraa/common.hpp>
-#include <mraa/spi.hpp>
-#include <mraa/gpio.hpp>
-
-// Our crystal oscillator frequency (32Mhz)
-#define FXOSC_FREQ 32000000.0
-
-// Our freq stepping resolution (in Hz) if FXOSC_FREQ is 32Mhz
-// (FXOSC_FREQ / 2^19) =
-#define FXOSC_STEP 61.03515625
-
-namespace upm {
-  
-  /**
-   * @brief Semtech SX1276 LoRa/FSK Modem
-   * @defgroup sx1276 libupm-sx1276
-   * @ingroup spi gpio wifi
-   */
-
-  /**
-   * @library sx1276
-   * @sensor sx1276
-   * @comname SX1276 LoRa/FSK Modem
-   * @altname SX1277 SX1278 SX1279
-   * @type wifi
-   * @man semtech
-   * @con spi gpio
-   * @web http://www.digikey.com/product-search/en?vendor=0&keywords=SX1276MB1LAS
-   *
-   * @brief API for the SX1276 LoRa/FSK modem
-   *
-   * The SX1276 is a FSK/OOK/LoRa modem capable of both Low Frequency
-   * and High Frequency communication.
-   *
-   * It requires a 3.3v power supply, do not use 5v.
-   *
-   * Frequency Hopping Spread Spectrum (FHSS) is not currently supported.
-   *
-   * While not all of the functionality of this device is supported
-   * initially, methods and register definitions are provided that
-   * should allow an end user to implement whatever features are
-   * required.
-   *
-   * FSK send/receive example
-   * @snippet sx1276-fsk.cxx Interesting
-   * LORA send/receive example
-   * @snippet sx1276-lora.cxx Interesting
-   */
-
-  class SX1276 {
-  public:
-
-    // The default chip revision
-    static const uint8_t chipRevision = 0x12;
-
-
-    // total FIFO size
-    static const int FIFO_SIZE = 256;
-
-    // differentiator between high and low bands
-    static const int RF_MID_BAND_THRESH = 525000000;
-
-    // LoRa RSSI offsets depending on LF or HF bands
-    static const int LOR_RSSI_OFFSET_HF = -157;
-    static const int LOR_RSSI_OFFSET_LF = -164;
-
-    /**
-     * What modem we are configured for
-     */
-    typedef enum {
-      MODEM_LORA                         = 0,
-      MODEM_FSK
-    } RADIO_MODEM_T;
-
-    /**
-     * Events that can occurr during a TX or RX operation.
-     *
-     * When sending or receiving a packet (calling setTx()/send() or
-     * setRx()), the state will be initialized to ESTATE_EXEC to
-     * indicate the operation is in progress.  Once an event has
-     * occurred, this state will be updated accordingly.
-     *
-     * For receiving, if RX_DONE is set, then it is safe to retrieve
-     * the rx buffer (via getRxBuffer()/getRxBufferStr()) as well as
-     * query the RSSI and SNR.  On RX_ERROR, these values will be the
-     * same as they were last set during the last RX_DONE event.
-     */
-    typedef enum {
-      REVENT_DONE                       = 0, // operation completed successfully
-      REVENT_EXEC,                           // runninsg something
-      REVENT_ERROR,                          // failed, crc error, sync timeout
-      REVENT_TIMEOUT                         // timed out
-    } RADIO_EVENT_T;
-
-    /**
-     * SX1276 registers
-     *
-     * NOTE: reserved registers must not be written into or read from.
-     * Reserved bitfields must always be 0.  
-     *
-     * This device has a set of "common" registers, as well as
-     * registers that represent different things depending on whether
-     * the device in in LoRa mode or FSK/OOK mode.  So here, we will
-     * prefix the register names with COM (common), LOR (LoRa mode),
-     * and FSK (FSK/OOK mode) accordingly.
-     */
-    typedef enum {
-      COM_RegFifo                      = 0x00, // FIFO r/w access
-      COM_RegOpMode                    = 0x01, // LoRa/FSK
-
-      FSK_RegBitrateMsb                = 0x02,
-      LOR_Reserved02                   = 0x02, // reserved
-
-      FSK_RegBitrateLsb                = 0x03,
-      LOR_Reserved03                   = 0x03, // reserved
-
-      FSK_RegFdevMsb                   = 0x04, // freq deviation
-      LOR_Reserved04                   = 0x04, // reserved
-
-      FSK_RegFdevLsb                   = 0x05,
-      LOR_Reserved05                   = 0x05, // reserved
-      
-      COM_RegFrfMsb                    = 0x06, // carrier freq
-      COM_RegFrfMid                    = 0x07,
-      COM_RegFrfLsb                    = 0x08,
-      COM_RegPaConfig                  = 0x09,
-      COM_RegPaRamp                    = 0x0a,
-
-      COM_RegOcp                       = 0x0b, // overcurrent protection
-      COM_RegLna                       = 0x0c,
-
-      FSK_RegRxConfig                  = 0x0d,
-      LOR_RegFifoAddrPtr               = 0x0d,
-
-      FSK_RegRssiConfg                 = 0x0e,
-      LOR_RegFifoTxBaseAddr            = 0x0e,
-
-      FSK_RegRssiCollision             = 0x0f,
-      LOR_RegFifoRxBaseAddr            = 0x0f,
-
-      FSK_RegRssiThresh                = 0x10,
-      LOR_RegFifoRxCurrentAddr         = 0x10,
-
-      FSK_RegRssiValue                 = 0x11,
-      LOR_RegIrqFlagsMask              = 0x11,
-
-      FSK_RegRxBw                      = 0x12,
-      LOR_RegIrqFlags                  = 0x12,
-
-      FSK_RegAfcBw                     = 0x13, // automatic freq cntrl
-      LOR_RegRxNbBytes                 = 0x13, // received pkt len
-
-      FSK_RegOokPeak                   = 0x14,
-      LOR_RegRxHeaderCntValueMsb       = 0x14,
-
-      FSK_RegOokFix                    = 0x15,
-      LOR_RegRxHeaderCntValueLsb       = 0x15,
-
-      FSK_RegOokAvg                    = 0x16,
-      LOR_RegRxPacketCntValueMsb       = 0x16,
-
-      FSK_Reserved17                   = 0x17, // reserved
-      LOR_RegRxPacketCntValueLsb       = 0x17,
-
-      FSK_Reserved18                   = 0x18, // reserved
-      LOR_RegModemStat                 = 0x18,
-
-      FSK_Reserved19                   = 0x19, // reserved
-      LOR_RegPktSnrValue               = 0x19,
-
-      FSK_RegAfcFei                    = 0x1a,
-      LOR_RegPktRssiValue              = 0x1a,
-
-      FSK_RegAfcMsb                    = 0x1b,
-      LOR_RegRssiValue                 = 0x1b,
-
-      FSK_RegAfcLsb                    = 0x1c,
-      LOR_RegHopChannel                = 0x1c, // fhss starting channel
-
-      FSK_RegFeiMsb                    = 0x1d,
-      LOR_RegModemConfig1              = 0x1d,
-
-      FSK_RegFeiLsb                    = 0x1e,
-      LOR_RegModemConfig2              = 0x1e,
-
-      FSK_RegPreambleDetect            = 0x1f,
-      LOR_RegSymbTimeoutLsb            = 0x1f,
-
-      FSK_RegRxTimeout1                = 0x20,
-      LOR_RegPreambleMsb               = 0x20,
-
-      FSK_RegRxTimeout2                = 0x21,
-      LOR_RegPreambleLsb               = 0x21,
-
-      FSK_RegRxTimeout3                = 0x22,
-      LOR_RegPayloadLength             = 0x22,
-
-      FSK_RegRxDelay                   = 0x23,
-      LOR_RegMaxPayloadLength          = 0x23,
-
-      FSK_RegOsc                       = 0x24,
-      LOR_RegHopPeriod                 = 0x24,
-
-      FSK_RegPreambleMsb               = 0x25,
-      LOR_RegFifoRxByteAddr            = 0x25,
-
-      FSK_RegPreambleLsb               = 0x26,
-      LOR_RegModemConfig3              = 0x26,
-
-      FSK_RegSyncConfig                = 0x27,
-      LOR_Reserved27                   = 0x27, // reserved
-
-      FSK_RegSyncValue1                = 0x28,
-      LOR_RegFeiMsb                    = 0x28,
-      
-      FSK_RegSyncValue2                = 0x29,
-      LOR_RegFeiMid                    = 0x29,
-
-      FSK_RegSyncValue3                = 0x2a,
-      LOR_RegFeiLsb                    = 0x2a,
-
-      FSK_RegSyncValue4                = 0x2b,
-      LOR_Reserved2b                   = 0x2b, // reserved
-
-      FSK_RegSyncValue5                = 0x2c,
-      LOR_RegRssiWideband              = 0x2c,
-
-      FSK_RegSyncValue6                = 0x2d,
-      LOR_Reserved2d                   = 0x2d, // reserved
-      
-      FSK_RegSyncValue7                = 0x2e,
-      LOR_Reserved2e                   = 0x2e, // reserved
-      
-      FSK_RegSyncValue8                = 0x2f,
-      LOR_Reserved2f                   = 0x2f, // reserved
-
-      FSK_RegPacketConfig1             = 0x30,
-      LOR_Reserved30                   = 0x30, // reserved
-
-      FSK_RegPacketConfig2             = 0x31,
-      LOR_RegDetectOptimize            = 0x31,
-
-      FSK_RegPayloadLength             = 0x32,
-      LOR_Reserved32                   = 0x32, // reserved
-
-      FSK_RegNodeAddr                  = 0x33,
-      LOR_RegInvertIQ                  = 0x33,
-
-      FSK_RegBroadcastAddr             = 0x34,
-      LOR_Reserved34                   = 0x34, // reserved
-      
-      FSK_RegFifoThresh                = 0x35,
-      LOR_Reserved35                   = 0x35, // reserved
-      
-      FSK_RegSeqConfig1                = 0x36,
-      LOR_Reserved36                   = 0x36, // reserved
-
-      FSK_RegSeqConfig2                = 0x37,
-      LOR_RegDetectionThreshold        = 0x37,
-
-      FSK_RegTimerResol                = 0x38,
-      LOR_Reserved38                   = 0x38, // reserved
-
-      FSK_RegTimer1Coeff               = 0x39,
-      LOR_RegSyncWord                  = 0x39,
-
-      FSK_RegTimer2Coeff               = 0x3a,
-      LOR_Reserved3a                   = 0x3a, // reserved
-
-      FSK_RegImageCal                  = 0x3b,
-      LOR_Reserved3b                   = 0x3b, // reserved (in datasheet)?
-      LOR_RegInvertIQ2                 = 0x3b, // does not exist in datasheet
-                                               // but used in Semtech code.
-                                               // UNDOCUMENTED
-
-      FSK_RegTemp                      = 0x3c,
-      LOR_Reserved3c                   = 0x3c, // reserved
-
-      FSK_RegLowBat                    = 0x3d,
-      LOR_Reserved3d                   = 0x3d, // reserved
-
-      FSK_RegIrqFlags1                 = 0x3e,
-      LOR_Reserved3e                   = 0x3e, // reserved
-
-      FSK_RegIrqFlags2                 = 0x3f,
-      LOR_Reserved3f                   = 0x3f, // reserved
-
-      COM_RegDioMapping1               = 0x40, // DIO0-DIO3
-      COM_RegDioMapping2               = 0x41, // DIO4-DIO5, clk out freq
-
-      COM_RegVersion                   = 0x42, // Semtech ID (silicon revision)
-
-      // 0x43 reserved
-
-      // The data sheet says this is FSK only, but the semtech code
-      // implies this is only valid for LoRa.  So for now, assume the
-      // datasheet is wrong.
-      //
-      // FSK_RegPllHop                    = 0x44, 
-      // LOR_Reserved44                   = 0x44, // reserved 
-
-      FSK_Reserved44                   = 0x44,
-      LOR_RegPllHop                    = 0x44,
-
-      // 0x45-0x4a reserved
-
-      COM_RegTcxo                      = 0x4b,
-
-      // 0x4c reserved
-
-      COM_RegPaDac                     = 0x4d,
-
-      // 0x4e-0x5a reserved
-
-      COM_RegFormerTemp                = 0x5b,
-
-      // 0x5c reserved
-
-      FSK_RegBitRateFrac               = 0x5d,
-      LOR_Reserved5d                   = 0x5d, // reserved
-
-      // 0x5e-0x60 reserved
-
-      COM_RegAgcRef                    = 0x61,
-      COM_RegAgcThresh1                = 0x62,
-      COM_RegAgcThresh2                = 0x63,
-      COM_RegAgcThresh3                = 0x64,
-
-      // 0x65-0x6f reserved
-
-      COM_RegPll                       = 0x70
-
-      // 0x71-0xff reserved
-    } SX1276_REGS_T;
-
-    /**
-     * OpMode register (differing bitfields depending on mode)
-     */
-    typedef enum {
-      OPMODE_Mode0                     = 0x01, // operating modes (sleep, etc)
-      OPMODE_Mode1                     = 0x02,
-      OPMODE_Mode2                     = 0x04,
-      _OPMODE_Mode_MASK                = 7,
-      _OPMODE_Mode_SHIFT               = 0,
-
-      OPMODE_LowFrequencyModeOn        = 0x08,
-
-      // 0x10 reserved
-
-      OPMODE_FSK_ModulationType0       = 0x20,
-      OPMODE_FSK_ModulationType1       = 0x40,
-      _OPMODE_FSK_ModulationType_MASK  = 3,
-      _OPMODE_FSK_ModulationType_SHIFT = 5,
-
-      OPMODE_LOR_Reserved0x20          = 0x20,
-
-      OPMODE_LOR_AccessSharedReg       = 0x40, // tmp sw to FSK regs
-
-      OPMODE_LongRangeMode             = 0x80 // LoRa mode enable(1), else FSK
-    } OPMODE_BITS_T;
-
-
-    /**
-     * Mode values
-     */
-    typedef enum {
-      MODE_Sleep                        = 0,
-      MODE_Standby                      = 1,
-      MODE_FSTX                         = 2, // freq synth
-      MODE_TxMode                       = 3,
-      MODE_FSRX                         = 4, // freq synth
-
-      MODE_FSK_RxMode                   = 5,
-      MODE_LOR_RxContinuous             = 5, // continuous rx mode
-
-      MODE_FSK_Reserved6                = 6,
-      MODE_LOR_RxSingle                 = 6, // single packet rx mode
-
-      MODE_FSK_Reserved7                = 7,
-      MODE_LOR_CAD                      = 7 // channel activity detection
-    } MODE_T;
-
-    /**
-     * FSK_ModulationType values
-     */
-    typedef enum {
-      MODULATION_FSK                    = 0, // freq shift keying
-      MODULATION_OOK                    = 1, // on/off keying
-      // 2-3 reserved
-    } FSK_MODULATION_TYPE_T;
-
-    /**
-     * RegPaConfig register
-     */
-    typedef enum {
-      PACONFIG_OutputPower0              = 0x01,
-      PACONFIG_OutputPower1              = 0x02,
-      PACONFIG_OutputPower2              = 0x04,
-      PACONFIG_OutputPower3              = 0x08,
-      _PACONFIG_OutputPower_MASK         = 15,
-      _PACONFIG_OutputPower_SHIFT        = 0,
-
-      PACONFIG_MaxPower0                 = 0x10,
-      PACONFIG_MaxPower1                 = 0x20,
-      PACONFIG_MaxPower2                 = 0x40,
-      _PACONFIG_MaxPower_MASK            = 7,
-      _PACONFIG_MaxPower_SHIFT           = 4,
-
-      PACONFIG_PaSelect                  = 0x80 // PA output pin,
-                                                //  0 = 14dBm, 1 = 20dBm
-    } PACONFIG_BITS_T;
-
-    /**
-     * RegPaRamp register
-     */
-    typedef enum {
-      PARAMP_PaRamp0                     = 0x01, // rise/fall of ramp up/down
-      PARAMP_PaRamp1                     = 0x02,
-      PARAMP_PaRamp2                     = 0x04,
-      PARAMP_PaRamp3                     = 0x08,
-      _PARAMP_PaRamp_MASK                = 15,
-      _PARAMP_PaRamp_SHIFT               = 0,
-
-      // 0x10 reserved
-
-      // LORA 0x20-0x40 reserved
-
-      PARAMP_FSK_ModulationShaping0      = 0x20,
-      PARAMP_FSK_ModulationShaping1      = 0x40,
-      _PARAMP_FSK_ModulationShaping_MASK = 3,
-      _PARAMP_FSK_ModulationShaping_SHIFT = 5
-
-      // 0x80 reserved
-    } PARAMP_BITS_T;
-
-    /**
-     * PARAMP_PaRamp values
-     */
-    typedef enum {
-      PARAMP_3_4MS                       = 0, // 3.4ms
-      PARAMP_2MS                         = 1,
-      PARAMP_1MS                         = 2,
-      PARAMP_500US                       = 3, // 500us
-      PARAMP_250US                       = 4,
-      PARAMP_125US                       = 5,
-      PARAMP_100US                       = 6,
-      PARAMP_62US                        = 7,
-      PARAMP_50US                        = 8,
-      PARAMP_40US                        = 9,
-      PARAMP_31US                        = 10,
-      PARAMP_25US                        = 11,
-      PARAMP_20US                        = 12,
-      PARAMP_15US                        = 13,
-      PARAMP_12US                        = 14,
-      PARAMP_10US                        = 15
-    } PARAMP_T;
-
-    /**
-     * PARAMP_ModulationShaping values.  Note, these mean different
-     * things depending on whether you are using FSK or OOK.  Hence
-     * the FSK/OOK dups.  We will also name these as 'MODSHAPING_', rather
-     * than the lengthy 'MODULATIONSHAPING... '
-     */
-    typedef enum {
-      MODSHAPING_NOSHAPING              = 0,
-
-      // FSK
-      MODSHAPING_FSK_GaussianFilterBT1  = 1, // BT = 1.0
-      MODSHAPING_FSK_GaussianFilterBT05 = 2, // BT = 0.5
-      MODSHAPING_FSK_GaussianFilterBT03 = 3, // BT = 0.3
-
-      // OOK
-      MODSHAPING_OOK_FCutoffBitRate     = 1, // Fcutoff = BitRate
-      MODSHAPING_OOK_FCutoffBitRate2    = 2  // Fcutoff = 2*BitRate
-
-      // for OOK, 3 is reserved
-    } MODSHAPING_T;
-
-    /**
-     * RegOcp register (see datasheet for OcpTrim values)
-     */
-    typedef enum {
-      OCP_OcpTrim0                      = 0x01,
-      OCP_OcpTrim1                      = 0x02,
-      OCP_OcpTrim2                      = 0x04,
-      OCP_OcpTrim3                      = 0x08,
-      _OCP_OcpTrim_MASK                 = 15,
-      _OCP_OcpTrim_SHIFT                = 0,
-
-      OCP_OcpOn                         = 0x10
-
-      // 0x20-0x80 reserved
-    } OCP_BITS_T;
-
-    /**
-     * Lna register
-     */
-    typedef enum {
-      LNA_LnaBoostHf0                    = 0x01,
-      LNA_LnaBoostHf1                    = 0x02,
-      _LNA_LnaBoostHf_MASK               = 3,
-      _LNA_LnaBoostHf_SHIFT              = 0,
-
-      // 0x04 reserved
-
-      LNA_LnaBoostLf0                    = 0x08,
-      LNA_LnaBoostLf1                    = 0x10,
-      _LNA_LnaBoostLf_MASK               = 3,
-      _LNA_LnaBoostLf_SHIFT              = 3,
-
-      LNA_LnaGain0                       = 0x20,
-      LNA_LnaGain1                       = 0x40,
-      LNA_LnaGain2                       = 0x80,
-      _LNA_LnaGain_MASK                  = 7,
-      _LNA_LnaGain_SHIFT                 = 5
-    } LNA_BITS_T;
-
-    /**
-     * LnaBoostHf values
-     */
-    typedef enum {
-      LNABOOSTHF_Default                = 0,
-      // 1-2 reserved
-      LNABOOSTHF_BoostOn                = 3, // 150% LNA current
-    } LNABOOSTHF_T;
-
-    /**
-     * LnaBoostLf values
-     */
-    typedef enum {
-      LNABOOSTLF_Default                = 0
-      // 1-3 reserved
-    } LNABOOSTLF_T;
-
-    /**
-     * LnaGain values
-     */
-    typedef enum {
-      // 0 reserved
-      LNAGAIN_G1                        = 1, // max gain
-      LNAGAIN_G2                        = 2,
-      LNAGAIN_G3                        = 3,
-      LNAGAIN_G4                        = 4,
-      LNAGAIN_G5                        = 5,
-      LNAGAIN_G6                        = 6  // minimum gain
-      // 7 reserved
-    } LNAGAIN_T;
-
-    /**
-     * FSK_RxConfig register.  See Table 24 in the data sheet for
-     * the meanings of the RxTrigger values.
-     */
-    typedef enum {
-      RXCONFIG_RxTrigger0               = 0x01,
-      RXCONFIG_RxTrigger1               = 0x02,
-      RXCONFIG_RxTrigger2               = 0x04,
-      _RXCONFIG_RxTrigger_MASK          = 7,
-      _RXCONFIG_RxTrigger_SHIFT         = 0,
-
-      RXCONFIG_AgcAutoOn                = 0x08,
-      RXCONFIG_AfcAutoOn                = 0x10,
-      RXCONFIG_RestartRxWithPllLock     = 0x20,
-      RXCONFIG_RestartRxWithoutPllLock  = 0x40,
-      RXCONFIG_RestartRxOnCollision     = 0x80
-    } RXCONFIG_BITS_T;
-
-    /**
-     * FSK_RssiConfig register
-     */
-    typedef enum {
-      RSSICONFIG_RssiSmoothing0         = 0x01, // RSSI sampling/averaging
-      RSSICONFIG_RssiSmoothing1         = 0x02,
-      RSSICONFIG_RssiSmoothing2         = 0x04,
-      _RSSICONFIG_RssiSmoothing_MASK    = 7,
-      _RSSICONFIG_RssiSmoothing_SHIFT   = 0,
-
-      RSSICONFIG_RssiOffset0            = 0x08, // 2's complement offset
-      RSSICONFIG_RssiOffset1            = 0x10,
-      RSSICONFIG_RssiOffset2            = 0x20,
-      RSSICONFIG_RssiOffset3            = 0x40,
-      RSSICONFIG_RssiOffset4            = 0x80,
-      _RSSICONFIG_RssiOffset_MASK       = 31,
-      _RSSICONFIG_RssiOffset_SHIFT      = 3
-    } RSSICONFIG_BITS_T;
-
-    /**
-     * RssiSmoothing values
-     */
-    typedef enum {
-      RSSISMOOTHING_2                   = 0, // 2 samples used
-      RSSISMOOTHING_4                   = 1,
-      RSSISMOOTHING_8                   = 2,
-      RSSISMOOTHING_16                  = 3,
-      RSSISMOOTHING_32                  = 4,
-      RSSISMOOTHING_64                  = 5,
-      RSSISMOOTHING_128                 = 6,
-      RSSISMOOTHING_256                 = 7
-    } RSSISMOOTHING_T;
-
-    /**
-     * LOR_RegIrqFlagsMask and LOR_RegIrqFlags registers
-     */
-    typedef enum {
-      LOR_IRQFLAG_CadDetected            = 0x01,
-      LOR_IRQFLAG_FhssChangeChannel      = 0x02,
-      LOR_IRQFLAG_CadDone                = 0x04,
-      LOR_IRQFLAG_TxDone                 = 0x08,
-
-      LOR_IRQFLAG_ValidHeader            = 0x10,
-      LOR_IRQFLAG_PayloadCrcError        = 0x20,
-      LOR_IRQFLAG_RxDone                 = 0x40,
-      LOR_IRQFLAG_RxTimeout              = 0x80
-    } LOR_IRQFLAG_BITS_T;
-    
-    /**
-     * FSK_RxBw register and FSK_RegAfcBw registers
-     */
-    typedef enum {
-      RXBW_RxBwExp0                      = 0x01,
-      RXBW_RxBwExp1                      = 0x02,
-      RXBW_RxBwExp2                      = 0x04,
-      _RXBW_RxBwExp_MASK                 = 7,
-      _RXBW_RxBwExp_SHIFT                = 0,
-
-      RXBW_RxBwMant0                     = 0x08,
-      RXBW_RxBwMant1                     = 0x10,
-      _RXBW_RxBwMant_MASK                = 3,
-      _RXBW_RxBwMant_SHIFT               = 3,
-      // 0x20-0x80 reserved
-    } RXBW_BITS_T;
-
-    /**
-     * RXBW_RxBwMant values
-     */
-    typedef enum {
-      RXBWMANT_0                         = 0,
-      RXBWMANT_1                         = 1,
-      RXBWMANT_2                         = 2
-      // 3 reserved
-    } RXBWMANT_T;
-
-    /**
-     * RXBW_RxBwExp values
-     */
-    typedef enum {
-      RXBWEXP_1                          = 1,
-      RXBWEXP_2                          = 2,
-      RXBWEXP_3                          = 3,
-      RXBWEXP_4                          = 4,
-      RXBWEXP_5                          = 5,
-      RXBWEXP_6                          = 6,
-      RXBWEXP_7                          = 7
-      // other values reserved
-    } RXBWEXP_T;
-
-    /**
-     * FSK_OokPeak register
-     */
-    typedef enum {
-      OOKPEAK_OokPeakThreshStep0         = 0x01,
-      OOKPEAK_OokPeakThreshStep1         = 0x02,
-      OOKPEAK_OokPeakThreshStep2         = 0x04,
-      _OOKPEAK_OokPeakThreshStep_MASK    = 7,
-      _OOKPEAK_OokPeakThreshStep_SHIFT   = 0,
-
-      OOKPEAK_OokThreshType0             = 0x08,
-      OOKPEAK_OokThreshType1             = 0x10,
-      _OOKPEAK_OokThreshType_MASK        = 3,
-      _OOKPEAK_OokThreshType_SHIFT       = 3,
-
-      OOKPEAK_BitSyncOn                  = 0x20,
-
-      // 0x40-0x80 reserved
-    } OOKPEAK_BITS_T;
-
-    /**
-     * OokPeakThreshStep values
-     */
-    typedef enum {
-      OOKPEAKTHRESHSTEP_05dB             = 0, // dec of RSSI threshold 0.5dB
-      OOKPEAKTHRESHSTEP_1dB              = 1, // 1 dB
-      OOKPEAKTHRESHSTEP_15dB             = 2, // 1.5 dB
-      OOKPEAKTHRESHSTEP_2dB              = 3, // 2 dB
-      OOKPEAKTHRESHSTEP_3dB              = 4,
-      OOKPEAKTHRESHSTEP_4dB              = 5,
-      OOKPEAKTHRESHSTEP_5dB              = 6,
-      OOKPEAKTHRESHSTEP_6dB              = 7
-    } OOKPEAKTHRESHSTEP_T;
-
-    /**
-     * OokPeakThreshType values
-     */
-    typedef enum {
-      OOKTHRESHTYPE_FIXED                = 0,
-      OOKTHRESHTYPE_PEAK                 = 1,
-      OOKTHRESHTYPE_AVERAGE              = 2
-      // 3 reserved
-    } OOKTHRESHTYPE_T;
-
-    /**
-     * FSK_OokAvg register
-     */
-    typedef enum {
-      OOKAVG_OokAvgThreshFilt0           = 0x01,
-      OOKAVG_OokAvgThreshFilt1           = 0x02,
-      _OOKAVG_OokAvgThreshFilt_MASK      = 3,
-      _OOKAVG_OokAvgThreshFilt_SHIFT     = 0,
-    
-      OOKAVG_OokAvgOffset0               = 0x04,
-      OOKAVG_OokAvgOffset1               = 0x08,
-      _OOKAVG_OokAvgOffset_MASK          = 3,
-      _OOKAVG_OokAvgOffset_SHIFT         = 2,
-
-      // 0x10 reserved
-
-      OOKAVG_OokPeakThreshDec0           = 0x20,
-      OOKAVG_OokPeakThreshDec1           = 0x40,
-      OOKAVG_OokPeakThreshDec2           = 0x80,
-      _OOKAVG_OokPeakThreshDec_MASK      = 7,
-      _OOKAVG_OokPeakThreshDec_SHIFT     = 5
-    } OOKAVG_BITS_T;
-
-    /**
-     * OokAvgThreshFilt values
-     */
-    typedef enum {
-      OOKAVGTHRESHFILT_32                = 0, // filter coedd in avg mode
-      OOKAVGTHRESHFILT_8                 = 1,
-      OOKAVGTHRESHFILT_4                 = 2,
-      OOKAVGTHRESHFILT_2                 = 3
-    } OOKAVGTHRESHFILT_T;
-
-    /**
-     * OokAvgOffset values
-     */
-    typedef enum {
-      OOKAVGOFFSET_0                     = 0, // 0.0dB
-      OOKAVGOFFSET_2                     = 1,
-      OOKAVGOFFSET_4                     = 2,
-      OOKAVGOFFSET_6                     = 3
-    } OOKAVGOFFSET_T;
-
-    /**
-     * OokPeakThreshDec values
-     */
-    typedef enum {
-      OOKPEAKTHRESHDEC_1_1               = 0, // once per chip
-      OOKPEAKTHRESHDEC_1_2               = 1, // once every 2 chips...
-      OOKPEAKTHRESHDEC_1_4               = 2,
-      OOKPEAKTHRESHDEC_1_8               = 3,
-      OOKPEAKTHRESHDEC_2_1               = 4, // twice per chip
-      OOKPEAKTHRESHDEC_4_1               = 5, // 4 times every chip...
-      OOKPEAKTHRESHDEC_8_1               = 6,
-      OOKPEAKTHRESHDEC_16_1              = 7
-    } OOKPEAKTHRESHDEC_T;
-
-    /**
-     * LOR_ModemStat register
-     */
-    typedef enum {
-      MODEMSTAT_SignalDetected           = 0x01,
-      MODEMSTAT_SignalSynchronized       = 0x02,
-      MODEMSTAT_RxOngoing                = 0x04,
-      MODEMSTAT_HeaderInfoValid          = 0x08,
-      MODEMSTAT_ModemClear               = 0x10,
-      
-      MODEMSTAT_RxCodingRate0            = 0x20,
-      MODEMSTAT_RxCodingRate1            = 0x40,
-      MODEMSTAT_RxCodingRate2            = 0x80,
-      _MODEMSTAT_RxCodingRate_MASK       = 7,
-      _MODEMSTAT_RxCodingRate_SHIFT      = 5
-    } MODEMSTAT_BITS_T;
-
-    /**
-     * FSK_RegAfcFei register
-     */
-    typedef enum {
-      AFCFEI_AfcAutoClearOn              = 0x01,
-      AFCFEI_AfcClear                    = 0x02,
-
-      // 0x04-0x08 reserved
-
-      AFCFEI_AgcStart                    = 0x10
-
-      // 0x20-0x80 reserved
-    } AFCFEI_BITS_T;
-
-    /**
-     * LOR_HopChannel register
-     */
-    typedef enum {
-      HOPCHANNEL_FhssPresentChannel0     = 0x01, // current freq hopping channel
-      HOPCHANNEL_FhssPresentChannel1     = 0x02,
-      HOPCHANNEL_FhssPresentChannel2     = 0x04,
-      HOPCHANNEL_FhssPresentChannel3     = 0x08,
-      HOPCHANNEL_FhssPresentChannel4     = 0x10,
-      HOPCHANNEL_FhssPresentChannel5     = 0x20,
-      _HOPCHANNEL_FhssPresentChannel_MASK = 63,
-      _HOPCHANNEL_FhssPresentChannel_SHIFT = 0,
-
-      HOPCHANNEL_CrcOnPayload            = 0x40,
-      HOPCHANNEL_PllTimeout              = 0x80
-    } HOPCHANNEL_BITS_T;
-
-    /**
-     * LOR_ModemConfig1 register
-     */
-    typedef enum {
-      MODEMCONFIG1_ImplicitHeaderModeOn  = 0x01,
-
-      MODEMCONFIG1_CodingRate0           = 0x02,
-      MODEMCONFIG1_CodingRate1           = 0x04,
-      MODEMCONFIG1_CodingRate2           = 0x08,
-      _MODEMCONFIG1_CodingRate_MASK      = 7,
-      _MODEMCONFIG1_CodingRate_SHIFT     = 0,
-
-      MODEMCONFIG1_Bw0                   = 0x10,
-      MODEMCONFIG1_Bw1                   = 0x20,
-      MODEMCONFIG1_Bw2                   = 0x40,
-      MODEMCONFIG1_Bw3                   = 0x80,
-      _MODEMCONFIG1_Bw_MASK              = 15,
-      _MODEMCONFIG1_Bw_SHIFT             = 4
-    } MODEMCONFIG1_BITS_T;
-
-    /**
-     * CodingRate values
-     */
-    typedef enum {
-      CODINGRATE_4_5                     = 1, // Error coding rate 4/5
-      CODINGRATE_4_6                     = 2,
-      CODINGRATE_4_7                     = 3,
-      CODINGRATE_4_8                     = 4
-    } CODINGRATE_T;
-
-    /**
-     * Bw values
-     */
-    typedef enum {
-      BW_7_8                             = 0, // 7.8Khz
-      BW_10_4                            = 1,
-      BW_15_6                            = 2,
-      BW_20_8                            = 3,
-      BW_31_25                           = 4,
-      BW_41_7                            = 5,
-      BW_62_5                            = 6,
-      BW_125                             = 7,
-      BW_250                             = 8,
-      BW_500                             = 9
-
-      // BW250 and BW500 not supported in lower band (169Mhz)
-    } BW_T;
-
-    /**
-     * LOR_ModemConfig2 register
-     */
-    typedef enum {
-      MODEMCONFIG2_SymbTimeoutMsb0       = 0x01,
-      MODEMCONFIG2_SymbTimeoutMsb1       = 0x02,
-      _MODEMCONFIG2_SymbTimeoutMsb_MASK  = 3,
-      _MODEMCONFIG2_SymbTimeoutMsb_SHIFT = 0,
-
-      MODEMCONFIG2_RxPayloadCrcOn        = 0x04,
-
-      MODEMCONFIG2_TxContinuousMode      = 0x08,
-
-      MODEMCONFIG2_SpreadingFactor0      = 0x10,
-      MODEMCONFIG2_SpreadingFactor1      = 0x20,
-      MODEMCONFIG2_SpreadingFactor2      = 0x40,
-      MODEMCONFIG2_SpreadingFactor3      = 0x80,
-      _MODEMCONFIG2_SpreadingFactor_MASK = 15,
-      _MODEMCONFIG2_SpreadingFactor_SHIFT = 4,
-    } MODEMCONFIG2_BITS_T;
-
-    /**
-     * SpreadingFactor values (expressed as a base-2 logarithm)
-     */
-    typedef enum {
-      SPREADINGFACTOR_64                 = 6, // 64 chips/symbol
-      SPREADINGFACTOR_128                = 7,
-      SPREADINGFACTOR_256                = 8,
-      SPREADINGFACTOR_512                = 9,
-      SPREADINGFACTOR_1024               = 10,
-      SPREADINGFACTOR_2048               = 11,
-      SPREADINGFACTOR_4096               = 12
-
-      // other values reserved
-    } SPREADINGFACTOR_T;
-
-    /**
-     * FSK_PreableDetect register
-     */
-    typedef enum {
-      PREABLEDETECT_PreambleDetectorTol0 = 0x01,
-      PREABLEDETECT_PreambleDetectorTol1 = 0x02,
-      PREABLEDETECT_PreambleDetectorTol2 = 0x04,
-      PREABLEDETECT_PreambleDetectorTol3 = 0x08,
-      PREABLEDETECT_PreambleDetectorTol4 = 0x10,
-      _PREABLEDETECT_PreambleDetectorTol4_MASK = 31,
-      _PREABLEDETECT_PreambleDetectorTol4_SHIFT = 0,
-
-      PREABLEDETECT_PreambleDetectorSize0 = 0x20,
-      PREABLEDETECT_PreambleDetectorSize1 = 0x40,
-      _PREABLEDETECT_PreambleDetectorSize_MASK = 3,
-      _PREABLEDETECT_PreambleDetectorSize_SHIFT = 5,
-
-      PREABLEDETECT_PreambleDetectorOn   = 0x80
-    } PREAMBLEDETECT_BITS_T;
-
-    /**
-     * PreambleDetectorSize values
-     */
-    typedef enum {
-      PREAMBLEDETECTORSIZE_1             = 0, // 1 byte
-      PREAMBLEDETECTORSIZE_2             = 1,
-      PREAMBLEDETECTORSIZE_3             = 2
-
-      // other values reserved
-    } PREAMBLEDETECTORSIZE_T;
-
-    /**
-     * FSK_Osc register
-     */
-    typedef enum {
-      OSC_ClkOut0                        = 0x01, // clk output freq
-      OSC_ClkOut1                        = 0x02,
-      OSC_ClkOut2                        = 0x04,
-      _OSC_ClkOut_MASK                   = 7,
-      _OSC_ClkOut_SHIFT                  = 0,
-
-      OSC_RcCalStart                     = 0x08
-
-      // other bits reserved
-    } OSC_BITS_T;
-
-    /**
-     * ClkOut values
-     */
-    typedef enum {
-      CLKOUT_1                           = 0, // FXOSC
-      CLKOUT_2                           = 1, // FXOSC / 2 ...
-      CLKOUT_4                           = 2,
-      CLKOUT_8                           = 3,
-      CLKOUT_16                          = 4,
-      CLKOUT_32                          = 5,
-      CLKOUT_RC                          = 6, // RC, (automatically enabled)
-      CLKOUT_OFF                         = 7  // clkout off
-    } CLKOUT_T;
-
-    /**
-     * LOR_ModemConfig3 register
-     */
-    typedef enum {
-      // 0x01-0x02 reserved
-
-      MODEMCONFIG3_AgcAutoOn             = 0x04,
-      MODEMCONFIG3_LowDataRateOptimize   = 0x08  // req. for SF11 and SF12 and
-                                                 // BW125
-
-      // 0x10-0x80 reserved
-    } MODEMCONFIG3_BITS_T;
-
-    /**
-     * FSK_SyncConfig register
-     */
-    typedef enum {
-      SYNCCONFIG_SyncSize0               = 0x01,
-      SYNCCONFIG_SyncSize1               = 0x02,
-      SYNCCONFIG_SyncSize2               = 0x04,
-      _SYNCCONFIG_SyncSize_MASK          = 7,
-      _SYNCCONFIG_SyncSize_SHIFT         = 0,
-
-      // 0x08 reserved
-
-      SYNCCONFIG_SyncOn                  = 0x10,
-      SYNCCONFIG_PreamblePolarity        = 0x20,
-
-      SYNCCONFIG_AutoRestartMode0        = 0x40,
-      SYNCCONFIG_AutoRestartMode1        = 0x80,
-      _SYNCCONFIG_AutoRestartMode_MASK   = 3,
-      _SYNCCONFIG_AutoRestartMode_SHIFT  = 6,
-    } SYNCCONFIG_BITS_T;
-
-    /**
-     * AutoRestartMode values
-     */
-    typedef enum {
-      AUTORESTARTMODE_OFF                = 0,
-      AUTORESTARTMODE_ON_NOPLL           = 1, // don't wait for PLL resync
-      AUTORESTARTMODE_ON_PLL             = 2  // wait for PLL resync
-      // other values reserved
-    } AUTORESTARTMODE_T;
-
-    /**
-     * LOR_FeiMsb register (4 bit MSB of Fei value)
-     */
-    typedef enum {
-      FEIMSB_FreqError0                  = 0x01,
-      FEIMSB_FreqError1                  = 0x02,
-      FEIMSB_FreqError2                  = 0x04,
-      FEIMSB_FreqError3                  = 0x08,
-      _FEIMSB_FreqError_MASK             = 15,
-      _FEIMSB_FreqError_SHIFT            = 0
-
-      // 0x10-0x80 reserved
-    } FEIMSB_BITS_T;
-
-    /**
-     * FSK_PacketConfig1 register
-     */
-    typedef enum {
-      PACKETCONFIG1_CrcWhiteningType     = 0x01,
-
-      PACKETCONFIG1_AddressFiltering0    = 0x02,
-      PACKETCONFIG1_AddressFiltering1    = 0x04,
-      _PACKETCONFIG1_AddressFiltering_MASK = 3,
-      _PACKETCONFIG1_AddressFiltering_SHIFT = 1,
-
-      PACKETCONFIG1_CrcAutoClearOff      = 0x08,
-      PACKETCONFIG1_CrcOn                = 0x10,
-
-      PACKETCONFIG1_DcFree0              = 0x20,
-      PACKETCONFIG1_DcFree1              = 0x40,
-      _PACKETCONFIG1_DcFree_MASK         = 3,
-      _PACKETCONFIG1_DcFree_SHIFT        = 5,
-
-      PACKETCONFIG1_PacketFormat         = 0x80 // fixed(0) or variable(1)
-    } PACKETCONFIG1_BITS_T;
-
-    /**
-     * AddressFiltering values
-     */
-    typedef enum {
-      ADDRESSFILTERING_NONE              = 0,
-      ADDRESSFILTERING_NODE              = 1, // must match node addr
-      ADDRESSFILTERING_NODE_BROADCAST    = 2, // match node or broadcast
-    } ADDRESSFILTERING_T;
-
-    /**
-     * DcFree values (DC-free encoding/decoding schemes)
-     */
-    typedef enum {
-      DCFREE_NONE                        = 0,
-      DCFREE_MANCHESTER                  = 1,
-      DCFREE_WHITENING                   = 2
-      // other values reserved
-    } DCFREE_T;
-
-    /**
-     * FSK_PacketConfig2 register
-     */
-    typedef enum {
-      PACKETCONFIG2_PayloadLengthMsb0    = 0x01,
-      PACKETCONFIG2_PayloadLengthMsb1    = 0x02,
-      PACKETCONFIG2_PayloadLengthMsb2    = 0x04,
-      _PACKETCONFIG2_PayloadLengthMsb_MASK = 7,
-      _PACKETCONFIG2_PayloadLengthMsb_SHIFT = 0,
-
-      PACKETCONFIG2_BeaconOn             = 0x08,
- 
-      // 0x10 reserved (linked to io-homecontrol compat mode (?))
-
-      PACKETCONFIG2_IoHomeOn             = 0x20,
-      PACKETCONFIG2_DataMode             = 0x40, // continuous(0), packet(1)
-
-      // 0x80 reserved
-    } PACKETCONFIG2_BITS_T;
-
-    /**
-     * LOR_DetectOptimize register
-     */
-    typedef enum {
-      DETECTOPTIMIZE_DetectionOptimize0  = 0x01,
-      DETECTOPTIMIZE_DetectionOptimize1  = 0x02,
-      DETECTOPTIMIZE_DetectionOptimize2  = 0x04,
-      _DETECTOPTIMIZE_DetectionOptimize_MASK = 7,
-      _DETECTOPTIMIZE_DetectionOptimize_SHIFT = 0
-
-      // 0x08-0x80 reserved
-    } DETECTOPTIMIZE_BITS_T;
-
-    /**
-     * DetectionOptimize values
-     */
-    typedef enum {
-      DETECTIONOPTIMIZE_SF7_SF12         = 3,
-      DETECTIONOPTIMIZE_SF6              = 5
-
-      // other values reserved
-    } DETECTIONOPTIMIZE_T;
-
-    /**
-     * LOR_InvertIQ register
-     */
-    typedef enum {
-      INVERTIQ_InvertIQTxOff             = 0x01, // invert LoRa I & Q signals
-                                                // UNDOCUMENTED
-
-      // 0x01-0x20 reserved
-
-      INVERTIQ_InvertIQRx                = 0x40 // invert LoRa I & Q signals
-
-      // 0x80 reserved
-    } INVERTIQ_BITS_T;
-
-    /**
-     * FSK_FifoThresh register
-     */
-    typedef enum {
-      FIFOTHRESH_FifoThreshold0          = 0x01,
-      FIFOTHRESH_FifoThreshold1          = 0x02,
-      FIFOTHRESH_FifoThreshold2          = 0x04,
-      FIFOTHRESH_FifoThreshold3          = 0x08,
-      FIFOTHRESH_FifoThreshold4          = 0x10,
-      FIFOTHRESH_FifoThreshold5          = 0x20,
-      _FIFOTHRESH_FifoThreshold_MASK     = 63,
-      _FIFOTHRESH_FifoThreshold_SHIFT    = 0,
-
-      // 0x40 reserved
-
-      FIFOTHRESH_TxStartCondition        = 0x80
-    } FIFOTHRESH_BITS_T;
-
-    /**
-     * FSK_SeqConfig1 register
-     */
-    typedef enum {
-      SEQCONFIG1_FromTransit             = 0x01,
-      SEQCONFIG1_FromIdle                = 0x02,
-      SEQCONFIG1_LowPowerSelection       = 0x04,
-
-      SEQCONFIG1_FromStart0              = 0x08,
-      SEQCONFIG1_FromStart1              = 0x10,
-      _SEQCONFIG1_FromStart_MASK         = 3,
-      _SEQCONFIG1_FromStart_SHIFT        = 3,
-
-      SEQCONFIG1_IdleMode                = 0x20,
-      SEQCONFIG1_SequencerStop           = 0x40,
-      SEQCONFIG1_SequencerStart          = 0x80
-    } SEQCONFIG1_BITS_T;
-
-    /**
-     * FromStart values
-     */
-    typedef enum {
-      FROMSTART_ToLowPowerSelection        = 0,
-      FROMSTART_ToReceiveState             = 1,
-      FROMSTART_ToTransmitState            = 2,
-      FROMSTART_ToTransmitStateOnFifoLevel = 3
-    } FROMSTART_T;
-
-    /**
-     * FSK_SeqConfig2 register
-     */
-    typedef enum {
-      SEQCONFIG2_FromPacketReceived0       = 0x01,
-      SEQCONFIG2_FromPacketReceived1       = 0x02,
-      SEQCONFIG2_FromPacketReceived2       = 0x04,
-      _SEQCONFIG2_FromPacketReceived_MASK  = 7,
-      _SEQCONFIG2_FromPacketReceived_SHIFT = 0,
-
-      SEQCONFIG2_FromRxTimeout0            = 0x08,
-      SEQCONFIG2_FromRxTimeout1            = 0x10,
-      _SEQCONFIG2_FromRxTimeout_MASK       = 3,
-      _SEQCONFIG2_FromRxTimeout_SHIFT      = 3,
-      
-      SEQCONFIG2_FromReceive0              = 0x20,
-      SEQCONFIG2_FromReceive1              = 0x40,
-      SEQCONFIG2_FromReceive2              = 0x80,
-      _SEQCONFIG2_FromReceive_MASK         = 3,
-      _SEQCONFIG2_FromReceive_SHIFT        = 5
-    } SEQCONFIG2_BITS_T;
-      
-    /**
-     * FromPacketReceived values
-     */
-    typedef enum {
-      FROMPACKETRECEIVED_ToSequencerOff    = 0,
-      FROMPACKETRECEIVED_ToTransmitStateOnFifoEmpty = 1,
-      FROMPACKETRECEIVED_ToLowPowerSelection = 2,
-      FROMPACKETRECEIVED_ToReceiveViaFS    = 3, // if freq was changed
-      FROMPACKETRECEIVED_ToReceive         = 4  // if freq was not changed
-
-      // other values reserved
-    } FROMPACKETRECEIVED_T;
-
-    /**
-     * FromRxTimeout values
-     */
-    typedef enum {
-      FROMRXTIMEOUT_ToReceiveViaReceiveStart = 0,
-      FROMRXTIMEOUT_ToTransmitState      = 1,
-      FROMRXTIMEOUT_ToLowPowerSelection  = 2,
-      FROMRXTIMEOUT_ToSequencerOffState  = 3
-    } FROMRXTIMEOUT_T;
-
-    /**
-     * FromReceive values
-     */
-    typedef enum {
-      FROMRECEIVE_ToPcketReceived        = 1,
-      FROMRECEIVE_ToLowPowerSelection    = 2,
-      FROMRECEIVE_ToPacketReceived       = 3,
-      FROMRECEIVE_ToSequencerOffOnRSSI   = 4, // RSSI interrupt
-      FROMRECEIVE_ToSequencerOffOnSync   = 5, // SyncAddr interrupt
-      FROMRECEIVE_ToSequencerOffOnPreambleDetect = 6, // PreambleDetect intr
-      // other values reserved
-    } FROMRECEIVE_T;
-
-    /**
-     * FSK_TimerResol register
-     */
-    typedef enum {
-      TIMERRESOL_Timer2Resolution0       = 0x01,
-      TIMERRESOL_Timer2Resolution1       = 0x02,
-      _TIMERRESOL_Timer2Resolution_MASK  = 3,
-      _TIMERRESOL_Timer2Resolution_SHIFT = 0,
-
-      TIMERRESOL_Timer1Resolution0       = 0x04,
-      TIMERRESOL_Timer1Resolution1       = 0x08,
-      _TIMERRESOL_Timer1Resolution_MASK  = 3,
-      _TIMERRESOL_Timer1Resolution_SHIFT = 2
-
-      // 0x10-0x80 reserved
-    } TIMERRESOL_BITS_T;
-
-    /**
-     * Timer1/Timer2Resolution values
-     */
-    typedef enum {
-      TIMERRESOLUTION_DISABLED           = 0,
-      TIMERRESOLUTION_64us               = 1, // 64us
-      TIMERRESOLUTION_4_1ms              = 2, // 4.1ms
-      TIMERRESOLUTION_262ms              = 3  // 262ms
-    } TIMERRESOLUTION_T;
-
-    /**
-     * FSK_ImageCal register
-     */
-    typedef enum {
-      IMAGECAL_TempMonitorOff            = 0x01,
-
-      IMAGECAL_TempThreshold0            = 0x02,
-      IMAGECAL_TempThreshold1            = 0x04,
-      _IMAGECAL_TempThreshold_MASK       = 3,
-      _IMAGECAL_TempThreshold_SHIFT      = 1,
-
-      IMAGECAL_TenpChange                = 0x08,
-
-      // 0x10 reserved
-
-      IMAGECAL_ImageCalRunning           = 0x20,
-      IMAGECAL_ImageCalStart             = 0x40,
-      IMAGECAL_AutoImageCalOn            = 0x80
-    } IMAGECAL_BITS_T;
-
-    /**
-     * TempThreshold values
-     */
-    typedef enum {
-      TEMPTHRESHOLD_5C                   = 0, // temp change to trigger new I/Q
-      TEMPTHRESHOLD_10C                  = 1, //  calibration
-      TEMPTHRESHOLD_15C                  = 2,
-      TEMPTHRESHOLD_20C                  = 3
-    } TEMPTHRESHOLD_T;
-
-    /**
-     * FSK_LowBat register
-     */
-    typedef enum {
-      LOWBAT_LowBatTrim0                 = 0x01,
-      LOWBAT_LowBatTrim1                 = 0x02,
-      LOWBAT_LowBatTrim2                 = 0x04,
-      _LOWBAT_LowBatTrim_MASK            = 7,
-      _LOWBAT_LowBatTrim_SHIFT           = 0,
-
-      LOWBAT_LowBatOn                    = 0x08
-
-      // 0x10-0z80 reserved
-    } LOWBAT_BITS_T;
-
-    /**
-     * LowBatTrim values
-     */
-    typedef enum {
-      LOWBATTRIM_1_695                   = 0, // 1.695v
-      LOWBATTRIM_1_764                   = 1,
-      LOWBATTRIM_1_835                   = 2,
-      LOWBATTRIM_1_905                   = 3,
-      LOWBATTRIM_1_976                   = 4,
-      LOWBATTRIM_2_045                   = 5,
-      LOWBATTRIM_2_116                   = 6,
-      LOWBATTRIM_2_185                   = 7
-    } LOWBATTRIM_T;
-
-    /**
-     * FSK_IrqFlags1 register
-     */
-    typedef enum {
-      IRQFLAGS1_SyncAddressMatch         = 0x01,
-      IRQFLAGS1_PreambleDetect           = 0x02,
-      IRQFLAGS1_Timeout                  = 0x04,
-      IRQFLAGS1_Rssi                     = 0x08,
-      IRQFLAGS1_PllLock                  = 0x10,
-      IRQFLAGS1_TxReady                  = 0x20,
-      IRQFLAGS1_RxReady                  = 0x40,
-      IRQFLAGS1_ModeReady                = 0x80
-    } IRQFLAGS1_BITS_T;
-
-    /**
-     * FSK_IrqFlags2 register
-     */
-    typedef enum {
-      IRQFLAGS2_LowBat                   = 0x01,
-      IRQFLAGS2_CrcOk                    = 0x02,
-      IRQFLAGS2_PayloadReady             = 0x04,
-      IRQFLAGS2_PacketSent               = 0x08,
-      IRQFLAGS2_FifoOverrun              = 0x10,
-      IRQFLAGS2_FifoLevel                = 0x20,
-      IRQFLAGS2_FifoEmpty                = 0x40,
-      IRQFLAGS2_FifoFull                 = 0x80
-    } IRQFLAGS2_BITS_T;
-
-    /**
-     * COM_DioMapping1 register. See Tables 18, 29, and 30 in the
-     * datasheet for the different mappings depending on mode.
-     */
-    typedef enum {
-      DOIMAPPING1_Dio3Mapping0           = 0x01,
-      DOIMAPPING1_Dio3Mapping1           = 0x02,
-      DOIMAPPING1_Dio3Mapping_MASK       = 3,
-      DOIMAPPING1_Dio3Mapping_SHIFT      = 0,
-
-      DOIMAPPING1_Dio2Mapping0           = 0x04,
-      DOIMAPPING1_Dio2Mapping1           = 0x08,
-      DOIMAPPING1_Dio2Mapping_MASK       = 3,
-      DOIMAPPING1_Dio2Mapping_SHIFT      = 2,
-
-      DOIMAPPING1_Dio1Mapping0           = 0x10,
-      DOIMAPPING1_Dio1Mapping1           = 0x20,
-      DOIMAPPING1_Dio1Mapping_MASK       = 3,
-      DOIMAPPING1_Dio1Mapping_SHIFT      = 4,
-
-      DOIMAPPING1_Dio0Mapping0           = 0x40,
-      DOIMAPPING1_Dio0Mapping1           = 0x80,
-      DOIMAPPING1_Dio0Mapping_MASK       = 3,
-      DOIMAPPING1_Dio0Mapping_SHIFT      = 6,
-    } DIOMAPPING1_BITS_T;
-
-
-    /**
-     * COM_DioMapping2 register. See Tables 18, 29, and 30 in the
-     * datasheet for the different mappings depending on mode.
-     */
-    typedef enum {
-      DOIMAPPING2_MapPreambleDetect      = 0x01, // rssi intr(0), preambledet(1)
-
-      // 0x02-0x08 reserved
-
-      DOIMAPPING2_Dio5Mapping0           = 0x10,
-      DOIMAPPING2_Dio5Mapping1           = 0x20,
-      DOIMAPPING2_Dio5Mapping_MASK       = 3,
-      DOIMAPPING2_Dio5Mapping_SHIFT      = 4,
-
-      DOIMAPPING2_Dio4Mapping0           = 0x40,
-      DOIMAPPING2_Dio4Mapping1           = 0x80,
-      DOIMAPPING2_Dio4Mapping_MASK       = 3,
-      DOIMAPPING2_Dio4Mapping_SHIFT      = 6,
-    } DIOMAPPING2_BITS_T;
-
-    /**
-     * DioXMapping values
-     *
-     * These differ depending on LoRa, FSK packet, and FSK continous
-     * modes.  See Tables 29, 30 (FSK), and 18 (LoRa) in the datasheet
-     * for details.
-     */
-    typedef enum {
-      DIOMAPPING_00                      = 0, 
-      DIOMAPPING_01                      = 1,
-      DIOMAPPING_10                      = 2,
-      DIOMAPPING_11                      = 3
-    } DIOMAPPING_T;
-
-
-    /**
-     * LOR_PllHop (or FSK_PllHop depending on who you believe) register
-     */
-    typedef enum {
-      // 0x01-0x40 reserved
-
-      PLLHOP_FastHopOn                   = 0x80
-    } PLLHOP_BITS_T;
-
-    /**
-     * COM_Tcxo register
-     */
-    typedef enum {
-      // 0x01-0x08 reserved
-
-      TCXO_TcxoOn                        = 0x10
-
-      // 0x20-0x80 reserved
-    } TCXO_BITS_T;
-
-    /**
-     * COM_PaDac register
-     */
-    typedef enum {
-      PADAC_PaDac0                       = 0x01,
-      PADAC_PaDac1                       = 0x02,
-      PADAC_PaDac2                       = 0x04,
-      _PADAC_PaDac_MASK                  = 7,
-      _PADAC_PaDac_SHIFT                 = 0
-
-      // 0x08-0x80 reserved
-    } PADAC_BITS_T;
-
-    /**
-     * PaDac values
-     */
-    typedef enum {
-      PADAC_DEFAULT                      = 4, 
-      PADAC_BOOST                        = 7 // +20dBm on PA_BOOST when
-                                            // OuputPower = 1111
-      // other values reserved
-    } PADAC_T;
-
-    /**
-     * FSK_BitRateFrac register
-     */
-    typedef enum {
-      BITRATEFRAC_BitRateFrac0           = 0x01,
-      BITRATEFRAC_BitRateFrac1           = 0x02,
-      BITRATEFRAC_BitRateFrac2           = 0x04,
-      BITRATEFRAC_BitRateFrac3           = 0x08,
-      _BITRATEFRAC_BitRateFrac_MASK      = 15,
-      _BITRATEFRAC_BitRateFrac_SHIFT     = 0
-
-      // 0x10-0x80 reserved
-    } BITRATEFRAC_BITS_T;
-
-    /**
-     * COM_AgcRef register
-     *
-     * These registers have 2 sets of values depending on whether
-     * LowFrequencyModeOn is set or unset.
-     */
-    typedef enum {
-      AGCREF_AgcReferenceLevel0          = 0x01,
-      AGCREF_AgcReferenceLevel1          = 0x02,
-      AGCREF_AgcReferenceLevel2          = 0x04,
-      AGCREF_AgcReferenceLevel3          = 0x08,
-      AGCREF_AgcReferenceLevel4          = 0x10,
-      AGCREF_AgcReferenceLevel5          = 0x20,
-      _AGCREF_AgcReferenceLevel_MASK     = 63,
-      _AGCREF_AgcReferenceLevel_SHIFT    = 0
-
-      // 0x40-0x80 reserved
-    } ACFREF_BITS_T;
-
-    /**
-     * COM_AgcThresh1 register
-     *
-     * These registers have 2 sets of values depending on whether
-     * LowFrequencyModeOn is set or unset.
-     */
-    typedef enum {
-      AGCTHRESH1_AcgStep10               = 0x01,
-      AGCTHRESH1_AcgStep11               = 0x02,
-      AGCTHRESH1_AcgStep12               = 0x04,
-      AGCTHRESH1_AcgStep13               = 0x08,
-      _AGCTHRESH1_AcgStep1_MASK          = 15,
-      _AGCTHRESH1_AcgStep1_SHIFT         = 0,
-
-      // 0x10-0x80 reserved
-    } ACGTHRESH1_BITS_T;
-
-    /**
-     * COM_AgcThresh2 register
-     *
-     * These registers have 2 sets of values depending on whether
-     * LowFrequencyModeOn is set or unset.
-     */
-    typedef enum {
-      AGCTHRESH2_AcgStep30               = 0x01,
-      AGCTHRESH2_AcgStep31               = 0x02,
-      AGCTHRESH2_AcgStep32               = 0x04,
-      AGCTHRESH2_AcgStep33               = 0x08,
-      _AGCTHRESH2_AcgStep3_MASK          = 15,
-      _AGCTHRESH2_AcgStep3_SHIFT         = 0,
-
-      AGCTHRESH2_AcgStep20               = 0x10,
-      AGCTHRESH2_AcgStep21               = 0x20,
-      AGCTHRESH2_AcgStep22               = 0x40,
-      AGCTHRESH2_AcgStep23               = 0x80,
-      _AGCTHRESH2_AcgStep2_MASK          = 15,
-      _AGCTHRESH2_AcgStep2_SHIFT         = 4
-    } ACGTHRESH2_BITS_T;
-
-    /**
-     * LOR_RegDetectionThreshold values
-     */
-    typedef enum {
-      LOR_DetectionThreshold_SF7_SF12    = 0x0a,
-      LOR_DetectionThreshold_SF6         = 0x0c
-    } LOR_DETECTIONTHRESHOLD_T;
-
-    /**
-     * COM_AgcThresh3 register
-     *
-     * These registers have 2 sets of values depending on whether
-     * LowFrequencyModeOn is set or unset.
-     */
-    typedef enum {
-      AGCTHRESH3_AcgStep50               = 0x01,
-      AGCTHRESH3_AcgStep51               = 0x02,
-      AGCTHRESH3_AcgStep52               = 0x04,
-      AGCTHRESH3_AcgStep53               = 0x08,
-      _AGCTHRESH3_AcgStep5_MASK          = 15,
-      _AGCTHRESH3_AcgStep5_SHIFT         = 0,
-
-      AGCTHRESH3_AcgStep40               = 0x10,
-      AGCTHRESH3_AcgStep41               = 0x20,
-      AGCTHRESH3_AcgStep42               = 0x40,
-      AGCTHRESH3_AcgStep43               = 0x80,
-      _AGCTHRESH3_AcgStep4_MASK          = 15,
-      _AGCTHRESH3_AcgStep4_SHIFT         = 4
-    } ACGTHRESH3_BITS_T;
-
-
-    /**
-     * SX1276 constructor
-     *
-     * Since this is a shield, you will not have much choice as to
-     * what pins are used.
-     *
-     * @param chipRev chip revision, default is 0x12
-     * @param bus spi bus to use
-     * @param cs GPIO pin to use as SPI Chip Select
-     * @param resetPin GPIO pin to use as reset (A0=GPIO14)
-     * @param dio0 GPIO pin to use as reset DIO0 intr
-     * @param dio1 GPIO pin to use as reset DIO1 intr
-     * @param dio2 GPIO pin to use as reset DIO2 intr
-     * @param dio3 GPIO pin to use as reset DIO3 intr
-     * @param dio4 GPIO pin to use as reset DIO4 intr
-     * @param dio5 GPIO pin to use as reset DIO5 intr
-     */
-    SX1276(uint8_t chipRev=chipRevision, int bus=1, int cs=10, int resetPin=14,
-           int dio0=2, int dio1=3, int dio2=4, int dio3=5, int dio4=17, 
-           int dio5=9);
-
-    /**
-     * SX1276 Destructor
-     */
-    ~SX1276();
-
-    /**
-     * read a register
-     *
-     * @param reg the register to read
-     * @return the value of the register
-     */
-    uint8_t readReg(uint8_t reg);
-
-    /**
-     * write to a register
-     *
-     * @param reg the register to write to
-     * @param val the value to write
-     * @return true if successful, false otherwise
-     */
-    bool writeReg(uint8_t reg, uint8_t val);
-
-    /**
-     * return the chip revision
-     *
-     * @return the chip revision (usually 0x12)
-     */
-    uint8_t getChipVersion();
-
-    /**
-     * reset the modem
-     */
-    void reset();
-
-    /**
-     * read the FIFO into a buffer
-     *
-     * @param buffer The buffer to read data into
-     * @param len The length of the buffer
-     */
-    void readFifo(uint8_t *buffer, int len);
-
-    /**
-     * write a buffer into the FIFO
-     *
-     * @param buffer The buffer containing the data to write
-     * @param len The length of the buffer
-     */
-    void writeFifo(uint8_t *buffer, int len);
-
-    /**
-     * Set the frequency to transmit and receive on
-     *
-     * @param freq The frequency to set
-     */
-    void setChannel(uint32_t freq);
-
-    /**
-     * Set the operating mode
-     *
-     * @param opMode One of the MODE_T values
-     */
-    void setOpMode(MODE_T opMode);
-
-    /**
-     * Set the modem to access.  This can be either the LORA or
-     * KSK/OOK modem.
-     *
-     * @param modem One of the MODEM_T values
-     */
-    void setModem(RADIO_MODEM_T modem);
-
-    /**
-     * Place the SX1276 into sleep mode
-     */
-    void setSleep();
-
-    /**
-     * Place the SX1276 into standby mode
-     */
-    void setStandby();
-
-    /**
-     * Return the current Received Signal Strength Indicator for the
-     * given modem
-     *
-     * @param modem One of the MODEM_T values
-     */
-    int16_t getRSSI(RADIO_MODEM_T modem);
-
-    /**
-     * Check to see if a given channel is free by comparing the RSSI
-     * to the supplied threshold.
-     *
-     * @param modem One of the MODEM_T values
-     * @param freq The channel to check
-     * @param rssiThresh The RSSI threshold, over which the channel
-     * os considerd in use.
-     */
-    bool isChannelFree(RADIO_MODEM_T modem, uint32_t freq, int16_t rssiThresh);
-
-    /**
-     * Send the supplied string.  This writes the string into the FIFO
-     * and places the modem in transmit mode (via setTx()).  This is a
-     * wrapper around send().
-     *
-     * @param buffer The buffer to send
-     * @param timeout The timeout in milliseconds
-     * @return one of the RADIO_EVENT_T values
-     */
-    RADIO_EVENT_T sendStr(std::string buffer, int timeout);
-
-    /**
-     * Send the supplied buffer.  The writes the buffer into the FIFO
-     * and places the modem in transmit mode (via setTx()).
-     *
-     * @param buffer The buffer to send
-     * @param size The size of the buffer
-     * @param timeout The timeout in milliseconds
-     * @return one of the RADIO_EVENT_T values
-     */
-    RADIO_EVENT_T send(uint8_t *buffer, uint8_t size, int timeout);
-
-    /**
-     * Set the receive configuration for a modem.  It is important
-     * that both the receive and transmit configurations match in order
-     * for communication to work between two radios.
-     *
-     * @param modem One of the MODEM_T values
-
-     * @param bandwidth The bandwidth to use.  Valid values are
-     *                          FSK : >= 2600 and <= 250000 Hz
-     *                          LoRa: [125 kHz, 250 kHz, 500 kHz] 
-     * @param datarate Sets the Datarate
-     *                          FSK : 600..300000 bits/s
-     *                          LoRa: [6: 64, 7: 128, 8: 256, 9: 512,
-     *                                10: 1024, 11: 2048, 12: 4096  chips]
-     * @param coderate Sets the coding rate (LoRa only)
-     *                          FSK : N/A ( set to 0 )
-     *                          LoRa: [1: 4/5, 2: 4/6, 3: 4/7, 4: 4/8] 
-     * @param bandwidthAfc Sets the AFC Bandwidth (FSK only) 
-     *                          FSK : >= 2600 and <= 250000 Hz
-     *                          LoRa: N/A ( set to 0 ) 
-     * @param preambleLen Sets the Preamble length
-     *                          FSK : Number of bytes 
-     *                          LoRa: Length in symbols (the hardware adds 
-     *                                4 more symbols)
-     * @param symbTimeout Sets the RxSingle timeout value (LoRa only) 
-     *                          FSK : N/A ( set to 0 ) 
-     *                          LoRa: timeout in symbols
-     * @param fixLen Fixed length packets [false: variable, true: fixed]
-     * @param payloadLen Sets payload length when fixed length is used
-     * @param crcOn Enables/Disables the CRC [false: OFF, true: ON]
-     * @param freqHopOn Enables disables the intra-packet frequency hopping
-     *                          FSK : N/A ( set to 0 )
-     *                          LoRa: [false: OFF, true: ON]
-     * @param hopPeriod Number of symbols bewteen each hop
-     *                          FSK : N/A ( set to 0 )
-     *                          LoRa: Number of symbols
-     * @param  iqInverted Inverts IQ signals (LoRa only)
-     *                          FSK : N/A ( set to 0 )
-     *                          LoRa: [false: not inverted, true: inverted]
-     * @param  rxContinuous Sets the reception in continuous mode
-     *                          [false: single mode, true: continuous mode]
-     */
-    void setRxConfig(RADIO_MODEM_T modem, uint32_t bandwidth,
-                     uint32_t datarate, uint8_t coderate,
-                     uint32_t bandwidthAfc, uint16_t preambleLen,
-                     uint16_t symbTimeout, bool fixLen,
-                     uint8_t payloadLen,
-                     bool crcOn, bool freqHopOn, uint8_t hopPeriod,
-                     bool iqInverted, bool rxContinuous);
-
-    /**
-     * Set the transmit configuration for a modem.  It is important
-     * that both the receive and transmit configurations match in order
-     * for communication to work between two radios.
-     *
-     * @param modem One of the MODEM_T values
-     * @param power Sets the output power [dBm]
-     * @param fdev Sets the frequency deviation (FSK only)
-     *                          FSK : [Hz]
-     *                          LoRa: 0
-     * @param bandwidth Sets the bandwidth (LoRa only)
-     *                          FSK : 0
-     *                          LoRa: [125 kHz, 250 kHz,
-     *                                 or 500 kHz] 
-     * @param datarate Sets the Datarate
-     *                          FSK : 600..300000 bits/s
-     *                          LoRa: [6: 64, 7: 128, 8: 256, 9: 512,
-     *                                10: 1024, 11: 2048, 12: 4096  chips]
-     * @param coderate Sets the coding rate (LoRa only)
-     *                          FSK : N/A ( set to 0 )
-     *                          LoRa: [1: 4/5, 2: 4/6, 3: 4/7, 4: 4/8] 
-     * @param preambleLen Sets the preamble length
-     *                          FSK : Number of bytes 
-     *                          LoRa: Length in symbols (the hardware adds 
-     *                                4 more symbols)
-     * @param fixLen Fixed length packets [false: variable, true: fixed]
-     * @param crcOn Enables disables the CRC [false: OFF, true: ON]
-     * @param freqHopOn Enables disables the intra-packet frequency hopping
-     *                          FSK : N/A ( set to 0 )
-     *                          LoRa: [false: OFF, true: ON]
-     * @param hopPeriod Number of symbols bewteen each hop
-     *                          FSK : N/A ( set to 0 )
-     *                          LoRa: Number of symbols
-     * @param iqInverted Inverts IQ signals (LoRa only)
-     *                          FSK : N/A ( set to 0 )
-     *                          LoRa: [false: not inverted, true: inverted]
-     */
-    void setTxConfig(RADIO_MODEM_T modem, int8_t power, uint32_t fdev, 
-                     uint32_t bandwidth, uint32_t datarate,
-                     uint8_t coderate, uint16_t preambleLen,
-                     bool fixLen, bool crcOn, bool freqHopOn, 
-                     uint8_t hopPeriod, bool iqInverted);
-
-    /**
-     * Start a receive operation.  The method will return when
-     * completed, either successfully, or in error (crc, or other
-     * issue).  If completed successfully, the returned buffer can be
-     * read via getRxBuffer() or getRxBufferStr().  In addition,
-     * values for RSSI and SNR (Lora only) can be retrieved.
-     *
-     * @param timeout The timeout in milliseconds
-     * @return one of the RADIO_EVENT_T values
-     */
-    RADIO_EVENT_T setRx(uint32_t timeout);
-
-    /**
-     * Upon a successful receive, this method can be used to retrieve
-     * the received packet.
-     *
-     * @return The received buffer in a std::string
-     */
-    std::string getRxBufferStr()
-    {
-      std::string rBuffer((char *)m_rxBuffer, getRxLen());
-      return rBuffer;
-    };
-
-    /**
-     * Upon a successful receive, this method can be used to retrieve
-     * the received packet.
-     *
-     * @return a pointer to the received buffer.  You can use
-     * getRxLen() to determine the number of valid bytes present.
-     */
-    uint8_t *getRxBuffer()
-    {
-      return (uint8_t*)m_rxBuffer;
-    };
-
-    /**
-     * Upon a successful receive, this method can be used to retrieve
-     * the received packet's Received Signal Strength Indicator (RSSI)
-     * value.
-     *
-     * @return RSSI value
-     */
-    int getRxRSSI()
-    {
-      return m_rxRSSI;
-    };
-
-    /**
-     * Upon a successful receive, this method can be used to retrieve
-     * the received packet's Signal to Noise (SNR) value.
-     *
-     * @return SNR value
-     */
-    int getRxSNR()
-    {
-      return m_rxSNR;
-    };
-
-    /**
-     * Upon a successful receive, this method can be used to retrieve
-     * the number of bytes received.
-     *
-     * @return the number of bytes received
-     */
-    int getRxLen()
-    {
-      return m_rxLen;
-    };
-
-
-  protected:
-    // I/O
-    mraa::Spi m_spi;
-    mraa::Gpio m_gpioCS;
-    mraa::Gpio m_gpioReset;
-
-    mraa::Gpio m_gpioDIO0;
-    mraa::Gpio m_gpioDIO1;
-    mraa::Gpio m_gpioDIO2;
-    mraa::Gpio m_gpioDIO3;
-    mraa::Gpio m_gpioDIO4;
-    mraa::Gpio m_gpioDIO5;
-
-    // calibration called during init()
-    void rxChainCalibration();
-
-    // interrupt handlers
-    static void onDio0Irq(void *ctx);
-    static void onDio1Irq(void *ctx);
-    static void onDio2Irq(void *ctx);
-    static void onDio3Irq(void *ctx);
-    static void onDio4Irq(void *ctx);
-    static void onDio5Irq(void *ctx);
-
-    /**
-     * What internal state are we in
-     */
-    typedef enum {
-      STATE_IDLE                         = 0,
-      STATE_RX_RUNNING,
-      STATE_TX_RUNNING,
-      STATE_CAD
-    } RADIO_STATES_T;
-
-    // needs to be OR'd onto registers for SPI write
-    static const uint8_t m_writeMode = 0x80;
-
-    // initialize the chip
-    void init();
-
-    // Start a transmit event (you should use send() or sendStr()
-    // rather than call this function directly.
-    RADIO_EVENT_T setTx(int timeout);
-
-    void startCAD(); // non-functional/non-tested
-
-    // not really used, maybe it should be
-    void setMaxPayloadLength(RADIO_MODEM_T modem, uint8_t max);
-
-    // Chip Select control (active LOW)
-    void csOn() 
-    {
-      m_gpioCS.write(0);
-    };
-
-    void csOff() 
-    {
-      m_gpioCS.write(1);
-    };
-
-  private:
-    // Thse structs will generate SWIG warnings, as we do not expose
-    // this data, they can be ignored.
-
-    // stored settings for the FSK modem
-    typedef struct
-    {
-      int8_t   Power;
-      uint32_t Fdev;
-      uint32_t Bandwidth;
-      uint32_t BandwidthAfc;
-      uint32_t Datarate;
-      uint16_t PreambleLen;
-      bool     FixLen;
-      uint8_t  PayloadLen;
-      bool     CrcOn;
-      bool     IqInverted;
-      bool     RxContinuous;
-    } radioFskSettings_t;
-
-    // stored settings for the LoRa modem
-    typedef struct
-    {
-      int8_t   Power;
-      uint32_t Bandwidth;
-      uint32_t Datarate;
-      bool     LowDatarateOptimize;
-      uint8_t  Coderate;
-      uint16_t PreambleLen;
-      bool     FixLen;
-      uint8_t  PayloadLen;
-      bool     CrcOn;
-      bool     FreqHopOn;
-      uint8_t  HopPeriod;
-      bool     IqInverted;
-      bool     RxContinuous;
-    } radioLoRaSettings_t;
-
-    // FSK packet handler state
-    typedef struct
-    {
-      uint8_t  PreambleDetected;
-      uint8_t  SyncWordDetected;
-      int8_t   RssiValue;
-      int32_t  AfcValue;
-      uint8_t  RxGain;
-      uint16_t Size;
-      uint16_t NbBytes;
-      uint8_t  FifoThresh;
-      uint8_t  ChunkSize;
-    } radioFskPacketHandler_t;
-
-    // LoRa packet handler state
-    typedef struct
-    {
-      int8_t SnrValue;
-      int16_t RssiValue;
-      uint8_t Size;
-    } radioLoRaPacketHandler_t;
-
-    // our radio settings
-    struct {
-      RADIO_MODEM_T  modem;
-      volatile RADIO_STATES_T state;
-      uint32_t       channel;
-
-      radioFskSettings_t      fskSettings;
-      volatile radioFskPacketHandler_t fskPacketHandler;
-
-      radioLoRaSettings_t      loraSettings;
-      volatile radioLoRaPacketHandler_t loraPacketHandler;
-    } m_settings;
-
-    uint8_t lookupFSKBandWidth(uint32_t bw);
-
-    // received data (on successful completion)
-    volatile int m_rxRSSI;
-    volatile int m_rxSNR;
-    volatile int m_rxLen;
-    uint8_t m_rxBuffer[FIFO_SIZE];
-
-    // for coordinating interrupt access
-    pthread_mutex_t m_intrLock;
-
-    void lockIntrs() { pthread_mutex_lock(&m_intrLock); };
-    void unlockIntrs() { pthread_mutex_unlock(&m_intrLock); };
-
-    // current radio event status
-    volatile RADIO_EVENT_T m_radioEvent;
-
-    // timer support
-    struct timeval m_startTime;
-    void initClock();
-    uint32_t getMillis();
-  };
-}
-
-
diff --git a/src/sx1276/sx1276.i b/src/sx1276/sx1276.i
deleted file mode 100644
index 062c729..0000000
--- a/src/sx1276/sx1276.i
+++ /dev/null
@@ -1,22 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "arrays_java.i";
-%include "../java_buffer.i"
-
-%ignore getRxBuffer();
-%ignore send(uint8_t *buffer, uint8_t size, int txTimeout);
-
-JAVA_JNI_LOADLIBRARY(javaupm_sx1276)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%pointer_functions(float, floatp);
-
-%{
-#include "sx1276.hpp"
-%}
-%include "sx1276.hpp"
-/* END Common SWIG syntax */
diff --git a/src/sx1276/sx1276.json b/src/sx1276/sx1276.json
deleted file mode 100644
index 398751b..0000000
--- a/src/sx1276/sx1276.json
+++ /dev/null
@@ -1,68 +0,0 @@
-{
-    "Library": "sx1276",
-    "Description": "Semtech SX1276 LoRa/FSK Modem Library",
-    "Sensor Class":
-    {
-        "SX1276":
-        {
-            "Name": "Semtech SX1276 LoRa/FSK Module",
-            "Description": "The SX1276 is a FSK/OOK/LoRa modem capable of both Low Frequency and High Frequency communication. It requires a 3.3v power supply, do not use 5v. Frequency Hopping Spread Spectrum (FHSS) is not currently supported.",
-            "Aliases": ["sx1276"],
-            "Categories": ["radio"],
-            "Connections": ["gpio", "spi"],
-            "Project Type": ["industrial"],
-            "Manufacturers": ["semtech"],
-            "Examples":
-            {
-                "Python": ["sx1276-fsk.py", "sx1276-lora.py"],
-                "Node.js": ["sx1276-fsk.js", "sx1276-lora.js"],
-                "C++": ["sx1276-fsk.cxx", "sx1276-lora.cxx"]
-            },
-            "Specifications":
-            {
-                "VDDmr": {"unit": "V", "min" : -0.5, "max": 3.9},
-                "VDDop": {"unit": "V", "min" : 1.8, "max": 3.7},
-                "Tmr" : {"unit": "°C", "min" : -55, "max": 115},
-                "Top" : {"unit": "°C", "min" : -40, "max": 85},
-                "IDDsl": {"unit": "uA", "typ" : 0, "max": 1},
-                "IDDidle": {"unit": "uA", "typ" : 1.5},
-                "IDDst": {"unit": "mA", "typ" : 1.6, "max": 1.8},
-                "IDDfs": {"unit": "mA", "typ" : 5.8},
-                "IDDr": [
-                    {"Conditions" : "LnaBoost Off, band 1", "unit": "mA", "typ" : 10.8},
-                    {"Conditions" : "LnaBoost On, band 1", "unit": "mA", "typ" : 11.5},
-                    {"Conditions" : "bands 2 & 3", "unit": "mA", "typ" : 12.0}
-                ],
-                "IDDt" : [
-                    {"Conditions" : "RFOP +20 dBm on PA_BOOST", "unit": "mA", "typ" : 120},
-                    {"Conditions" : "RFOP +17 dBm on PA_BOOST", "unit": "mA", "typ" : 87},
-                    {"Conditions" : "RFOP +13 dBm on RFO_LH/RH pin", "unit": "mA", "typ" : 29},
-                    {"Conditions" : "RFOP +7 dBm on RFO_LH/RH pin", "unit": "mA", "typ" : 20}
-                ],
-                "LoRaWAN Band" : "US915",
-                "Range" : "Claimed > 10km",
-                "Packet Size" : {"unit" : "bytes", "max" : 256}
-            },
-            "Platforms":
-            {
-                "Intel Edison":
-                {
-                    "Notes": ["Power using 3.3 V"]
-                },
-                "Arduino 101":
-                {
-                    "Notes": ["Power using 3.3 V"]
-                },
-                "Intel C1000":
-                {
-                    "Notes": ["Power using 3.3 V"]
-                }
-            },
-            "Urls" :
-            {
-                "Product Pages": ["http://www.semtech.com/wireless-rf/rf-transceivers/sx1276/"],
-                "Datasheets": ["http://www.semtech.com/images/datasheet/sx1276.pdf"]
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/sx6119/CMakeLists.txt b/src/sx6119/CMakeLists.txt
deleted file mode 100644
index d08b7ed..0000000
--- a/src/sx6119/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "sx6119")
-set (libdescription "FM Receiver")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/sx6119/sx6119.cxx b/src/sx6119/sx6119.cxx
deleted file mode 100644
index 5de0911..0000000
--- a/src/sx6119/sx6119.cxx
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "sx6119.hpp"
-
-using namespace upm;
-using namespace std;
-
-SX6119::SX6119(int powerPin, int seekPin)
-{
-  if ( !(m_gpioPower = mraa_gpio_init(powerPin)) )
-    {
-      throw std::invalid_argument(std::string(__FUNCTION__) +
-                                  ": mraa_gpio_init(power) failed, invalid pin?");
-      return;
-    }
-
-  mraa_gpio_dir(m_gpioPower, MRAA_GPIO_OUT);
-  mraa_gpio_write(m_gpioPower, 1);
-
-  if ( !(m_gpioSeek = mraa_gpio_init(seekPin)) )
-    {
-      throw std::invalid_argument(std::string(__FUNCTION__) +
-                                  ": mraa_gpio_init(seek) failed, invalid pin?");
-      return;
-    }
-
-  mraa_gpio_dir(m_gpioSeek, MRAA_GPIO_OUT);
-  mraa_gpio_write(m_gpioSeek, 1);
-}
-
-SX6119::~SX6119()
-{
-  mraa_gpio_close(m_gpioPower);
-  mraa_gpio_close(m_gpioSeek);
-}
-
-void SX6119::togglePower()
-{
-  // this is just a toggle -- we set LOW for one second and power will
-  // be turned on or off depending on the previous condition.
-  mraa_gpio_write(m_gpioPower, 0);
-  sleep(1);
-  mraa_gpio_write(m_gpioPower, 1);
-}
-
-void SX6119::seek()
-{
-  // this is just a trigger -- we set LOW for 500ms to seek to the
-  // next available station, wrapping around when we reach the end.
-  mraa_gpio_write(m_gpioSeek, 0);
-  usleep(500000);
-  mraa_gpio_write(m_gpioSeek, 1);
-}
diff --git a/src/sx6119/sx6119.hpp b/src/sx6119/sx6119.hpp
deleted file mode 100644
index 087ad86..0000000
--- a/src/sx6119/sx6119.hpp
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <iostream>
-
-#include <mraa/gpio.h>
-
-namespace upm {
-    /**
-     * @brief SX6119-based FM Receiver
-     * @defgroup sx6119 libupm-sx6119
-     * @ingroup seeed gpio sound
-     */
-
-    /**
-     * @sensor sx6119
-     * @library sx6119
-     * @comname FM Receiver
-     * @altname SX6119 FM Receiver
-     * @type sound
-     * @man seeed
-     * @web http://wiki.seeed.cc/Grove-FM_Receiver/
-     * @con gpio
-     *
-     * @brief API support for the SX6119-based Grove FM Receiver
-     *
-     * This class implements support for the SX6119 FM Receiver. There are
-     * two digital pins: one that toggles power on/off, and the other that
-     * does a seek to the next station.
-     *
-     * @image html sx6119.jpg
-     * @snippet sx6119.cxx Interesting
-     */
-  class SX6119 {
-  public:
-
-    /**
-     * SX6119 constructor
-     *
-     * @param powerPin Pin to use for recording
-     * @param seekPin Pin to use for seeking to the next station
-     */
-    SX6119(int powerPin, int seekPin);
-
-    /**
-     * SX6119 destructor
-     */
-    ~SX6119();
-
-    /**
-     * Toggles the device power on or off
-     *
-     */
-    void togglePower();
-
-    /**
-     * Seeks to the next station
-     *
-     */
-    void seek();
-
-  private:
-    mraa_gpio_context m_gpioPower;
-    mraa_gpio_context m_gpioSeek;
-  };
-}
-
-
diff --git a/src/sx6119/sx6119.json b/src/sx6119/sx6119.json
deleted file mode 100644
index 5912dc5..0000000
--- a/src/sx6119/sx6119.json
+++ /dev/null
@@ -1,55 +0,0 @@
-{
-    "Library": "sx6119",
-    "Description": "Seeed SX6119-based FM Receiver library",
-    "Sensor Class": {
-        "SX6119": {
-            "Name": "API support for the Seeed SX6119-based Grove FM Receiver",
-            "Description": "This is the UPM Module for the Seeed SX6119-based Grove FM Receiver. There are two digital pins: one that toggles power on/off, and the other that does a seek to the next station.",
-            "Aliases": ["sx6119", "Grove - FM Receiver"],
-            "Categories": ["sound"],
-            "Connections": ["gpio"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["Seeed"],
-            "Image": "sx6119.jpg",
-            "Examples": {
-                "Python": ["sx6119.py"],
-                "Node.js": ["sx6119.js"],
-                "C++": ["sx6119.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 2,
-                    "max": 3.6
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "min" : 0.005,
-                    "max" : 17
-                },
-                "Operating Temperature": {
-                    "unit": "Â°C",
-                    "min": -20,
-                    "max": 85
-                },
-                "Start-up Time": {
-                    "unit": "ms",
-                    "min" : 30,
-                    "max" : 150
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-FM-Receiver-p-1841.html", "http://wiki.seeed.cc/Grove-FM_Receiver/"],
-                "Datasheets": ["https://raw.githubusercontent.com/SeeedDocument/Grove-FM_Receiver/master/res/SX6119_%E6%94%B6%E9%9F%B3IC_datasheet.pdf"]
-            }
-        }
-    }
-}
-- 
2.7.4

