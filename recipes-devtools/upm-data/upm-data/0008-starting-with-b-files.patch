From fa19f430956393883f916818d5f879502273ec9f Mon Sep 17 00:00:00 2001
From: Ganesh K <ganesh.k@phytec.in>
Date: Mon, 24 Jun 2019 18:07:23 +0530
Subject: [PATCH 8/8] starting with b files

---
 src/bacnetmstp/CMakeLists.txt    |    11 -
 src/bacnetmstp/bacnetmstp.cxx    |   939 --
 src/bacnetmstp/bacnetmstp.hpp    |   754 --
 src/bacnetmstp/bacnetmstp.i      |    16 -
 src/bacnetmstp/bacnetutil.cxx    |   927 --
 src/bacnetmstp/bacnetutil.hpp    |   559 -
 src/bacnetmstp/device-client.c   |  1028 --
 src/bacnetmstp/device.h          |   466 -
 src/bacnetmstp/timer.h           |    65 -
 src/bh1749/CMakeLists.txt        |     8 -
 src/bh1749/bh1749.c              |   702 --
 src/bh1749/bh1749.cxx            |   304 -
 src/bh1749/bh1749.h              |   429 -
 src/bh1749/bh1749.hpp            |   345 -
 src/bh1749/bh1749.i              |    18 -
 src/bh1749/bh1749.json           |    49 -
 src/bh1749/bh1749_registers.h    |   160 -
 src/bh1750/CMakeLists.txt        |     9 -
 src/bh1750/bh1750.c              |   307 -
 src/bh1750/bh1750.cxx            |    99 -
 src/bh1750/bh1750.h              |   145 -
 src/bh1750/bh1750.hpp            |   135 -
 src/bh1750/bh1750.i              |    16 -
 src/bh1750/bh1750.json           |    50 -
 src/bh1750/bh1750_defs.h         |    71 -
 src/bh1750/bh1750_fti.c          |   112 -
 src/bh1792/CMakeLists.txt        |     8 -
 src/bh1792/bh1792.c              |   889 --
 src/bh1792/bh1792.cxx            |   305 -
 src/bh1792/bh1792.h              |   411 -
 src/bh1792/bh1792.hpp            |   324 -
 src/bh1792/bh1792.i              |    28 -
 src/bh1792/bh1792.json           |    62 -
 src/bh1792/bh1792glc_registers.h |   129 -
 src/biss0001/CMakeLists.txt      |     9 -
 src/biss0001/biss0001.c          |    77 -
 src/biss0001/biss0001.cxx        |    50 -
 src/biss0001/biss0001.h          |    76 -
 src/biss0001/biss0001.hpp        |    99 -
 src/biss0001/biss0001.json       |    73 -
 src/biss0001/biss0001_fti.c      |    82 -
 src/bma220/CMakeLists.txt        |     5 -
 src/bma220/bma220.cxx            |   518 -
 src/bma220/bma220.hpp            |   824 --
 src/bma220/bma220.i              |    54 -
 src/bma220/bma220.json           |    59 -
 src/bma250e/CMakeLists.txt       |     9 -
 src/bma250e/bma250e.c            |   967 --
 src/bma250e/bma250e.cxx          |   350 -
 src/bma250e/bma250e.h            |   635 --
 src/bma250e/bma250e.hpp          |   582 --
 src/bma250e/bma250e.i            |    56 -
 src/bma250e/bma250e.json         |    74 -
 src/bma250e/bma250e_defs.h       |   935 --
 src/bma250e/bma250e_fti.c        |   113 -
 src/bmg160/CMakeLists.txt        |     9 -
 src/bmg160/bmg160.c              |   777 --
 src/bmg160/bmg160.cxx            |   294 -
 src/bmg160/bmg160.h              |   519 -
 src/bmg160/bmg160.hpp            |   480 -
 src/bmg160/bmg160.i              |    56 -
 src/bmg160/bmg160.json           |    61 -
 src/bmg160/bmg160_defs.h         |   793 --
 src/bmg160/bmg160_fti.c          |   106 -
 src/bmi160/CMakeLists.txt        |     9 -
 src/bmi160/bmi160.c              |   588 --
 src/bmi160/bmi160.cxx            |   144 -
 src/bmi160/bmi160.h              |   234 -
 src/bmi160/bmi160.hpp            |   249 -
 src/bmi160/bmi160.i              |    48 -
 src/bmi160/bmi160.json           |    66 -
 src/bmi160/bmi160_defs.h         |    51 -
 src/bmi160/bosch_bmi160.c        | 20468 -------------------------------------
 src/bmi160/bosch_bmi160.h        | 12048 ----------------------
 src/bmi160/license.txt           |    55 -
 src/bmm150/CMakeLists.txt        |     9 -
 src/bmm150/bmm150.c              |   803 --
 src/bmm150/bmm150.cxx            |   201 -
 src/bmm150/bmm150.h              |   374 -
 src/bmm150/bmm150.hpp            |   345 -
 src/bmm150/bmm150.i              |    57 -
 src/bmm150/bmm150.json           |    46 -
 src/bmm150/bmm150_defs.h         |   272 -
 src/bmm150/bmm150_fti.c          |   106 -
 src/bmm150/license.txt           |    56 -
 src/bmpx8x/CMakeLists.txt        |    10 -
 src/bmpx8x/bmpx8x.c              |   360 -
 src/bmpx8x/bmpx8x.cxx            |   120 -
 src/bmpx8x/bmpx8x.h              |   230 -
 src/bmpx8x/bmpx8x.hpp            |   249 -
 src/bmpx8x/bmpx8x.i              |    28 -
 src/bmpx8x/bmpx8x.json           |    49 -
 src/bmpx8x/bmpx8x_defs.h         |   110 -
 src/bmpx8x/bmpx8x_fti.c          |   137 -
 src/bmx055/CMakeLists.txt        |     5 -
 src/bmx055/bmc150.cxx            |   116 -
 src/bmx055/bmc150.hpp            |   200 -
 src/bmx055/bmi055.cxx            |   118 -
 src/bmx055/bmi055.hpp            |   198 -
 src/bmx055/bmx055.cxx            |   168 -
 src/bmx055/bmx055.hpp            |   254 -
 src/bmx055/bmx055.i              |    65 -
 src/bmx055/bmx055.json           |    49 -
 src/bno055/CMakeLists.txt        |     8 -
 src/bno055/bno055.c              |  1057 --
 src/bno055/bno055.cxx            |   453 -
 src/bno055/bno055.h              |   717 --
 src/bno055/bno055.hpp            |   704 --
 src/bno055/bno055.i              |    53 -
 src/bno055/bno055.json           |    48 -
 src/bno055/bno055_regs.h         |   825 --
 src/button/CMakeLists.txt        |     7 -
 src/button/button.c              |    84 -
 src/button/button.cxx            |    76 -
 src/button/button.h              |    97 -
 src/button/button.hpp            |   103 -
 src/button/button.i              |    18 -
 src/button/button.json           |    32 -
 src/buzzer/CMakeLists.txt        |     9 -
 src/buzzer/buzzer.c              |   141 -
 src/buzzer/buzzer.cxx            |    75 -
 src/buzzer/buzzer.h              |   115 -
 src/buzzer/buzzer.hpp            |   127 -
 src/buzzer/buzzer.i              |    15 -
 src/buzzer/buzzer.json           |    40 -
 src/buzzer/buzzer_tones.h        |    37 -
 126 files changed, 62158 deletions(-)
 delete mode 100644 src/bacnetmstp/CMakeLists.txt
 delete mode 100644 src/bacnetmstp/bacnetmstp.cxx
 delete mode 100644 src/bacnetmstp/bacnetmstp.hpp
 delete mode 100644 src/bacnetmstp/bacnetmstp.i
 delete mode 100644 src/bacnetmstp/bacnetutil.cxx
 delete mode 100644 src/bacnetmstp/bacnetutil.hpp
 delete mode 100644 src/bacnetmstp/device-client.c
 delete mode 100644 src/bacnetmstp/device.h
 delete mode 100644 src/bacnetmstp/timer.h
 delete mode 100755 src/bh1749/CMakeLists.txt
 delete mode 100755 src/bh1749/bh1749.c
 delete mode 100755 src/bh1749/bh1749.cxx
 delete mode 100755 src/bh1749/bh1749.h
 delete mode 100755 src/bh1749/bh1749.hpp
 delete mode 100755 src/bh1749/bh1749.i
 delete mode 100755 src/bh1749/bh1749.json
 delete mode 100755 src/bh1749/bh1749_registers.h
 delete mode 100644 src/bh1750/CMakeLists.txt
 delete mode 100644 src/bh1750/bh1750.c
 delete mode 100644 src/bh1750/bh1750.cxx
 delete mode 100644 src/bh1750/bh1750.h
 delete mode 100644 src/bh1750/bh1750.hpp
 delete mode 100644 src/bh1750/bh1750.i
 delete mode 100644 src/bh1750/bh1750.json
 delete mode 100644 src/bh1750/bh1750_defs.h
 delete mode 100644 src/bh1750/bh1750_fti.c
 delete mode 100755 src/bh1792/CMakeLists.txt
 delete mode 100755 src/bh1792/bh1792.c
 delete mode 100755 src/bh1792/bh1792.cxx
 delete mode 100755 src/bh1792/bh1792.h
 delete mode 100755 src/bh1792/bh1792.hpp
 delete mode 100755 src/bh1792/bh1792.i
 delete mode 100755 src/bh1792/bh1792.json
 delete mode 100755 src/bh1792/bh1792glc_registers.h
 delete mode 100644 src/biss0001/CMakeLists.txt
 delete mode 100644 src/biss0001/biss0001.c
 delete mode 100644 src/biss0001/biss0001.cxx
 delete mode 100644 src/biss0001/biss0001.h
 delete mode 100644 src/biss0001/biss0001.hpp
 delete mode 100644 src/biss0001/biss0001.json
 delete mode 100644 src/biss0001/biss0001_fti.c
 delete mode 100644 src/bma220/CMakeLists.txt
 delete mode 100644 src/bma220/bma220.cxx
 delete mode 100644 src/bma220/bma220.hpp
 delete mode 100644 src/bma220/bma220.i
 delete mode 100644 src/bma220/bma220.json
 delete mode 100644 src/bma250e/CMakeLists.txt
 delete mode 100644 src/bma250e/bma250e.c
 delete mode 100644 src/bma250e/bma250e.cxx
 delete mode 100644 src/bma250e/bma250e.h
 delete mode 100644 src/bma250e/bma250e.hpp
 delete mode 100644 src/bma250e/bma250e.i
 delete mode 100644 src/bma250e/bma250e.json
 delete mode 100644 src/bma250e/bma250e_defs.h
 delete mode 100644 src/bma250e/bma250e_fti.c
 delete mode 100644 src/bmg160/CMakeLists.txt
 delete mode 100644 src/bmg160/bmg160.c
 delete mode 100644 src/bmg160/bmg160.cxx
 delete mode 100644 src/bmg160/bmg160.h
 delete mode 100644 src/bmg160/bmg160.hpp
 delete mode 100644 src/bmg160/bmg160.i
 delete mode 100644 src/bmg160/bmg160.json
 delete mode 100644 src/bmg160/bmg160_defs.h
 delete mode 100644 src/bmg160/bmg160_fti.c
 delete mode 100644 src/bmi160/CMakeLists.txt
 delete mode 100644 src/bmi160/bmi160.c
 delete mode 100644 src/bmi160/bmi160.cxx
 delete mode 100644 src/bmi160/bmi160.h
 delete mode 100644 src/bmi160/bmi160.hpp
 delete mode 100644 src/bmi160/bmi160.i
 delete mode 100644 src/bmi160/bmi160.json
 delete mode 100644 src/bmi160/bmi160_defs.h
 delete mode 100644 src/bmi160/bosch_bmi160.c
 delete mode 100644 src/bmi160/bosch_bmi160.h
 delete mode 100644 src/bmi160/license.txt
 delete mode 100644 src/bmm150/CMakeLists.txt
 delete mode 100644 src/bmm150/bmm150.c
 delete mode 100644 src/bmm150/bmm150.cxx
 delete mode 100644 src/bmm150/bmm150.h
 delete mode 100644 src/bmm150/bmm150.hpp
 delete mode 100644 src/bmm150/bmm150.i
 delete mode 100644 src/bmm150/bmm150.json
 delete mode 100644 src/bmm150/bmm150_defs.h
 delete mode 100644 src/bmm150/bmm150_fti.c
 delete mode 100644 src/bmm150/license.txt
 delete mode 100644 src/bmpx8x/CMakeLists.txt
 delete mode 100644 src/bmpx8x/bmpx8x.c
 delete mode 100644 src/bmpx8x/bmpx8x.cxx
 delete mode 100644 src/bmpx8x/bmpx8x.h
 delete mode 100644 src/bmpx8x/bmpx8x.hpp
 delete mode 100644 src/bmpx8x/bmpx8x.i
 delete mode 100644 src/bmpx8x/bmpx8x.json
 delete mode 100644 src/bmpx8x/bmpx8x_defs.h
 delete mode 100644 src/bmpx8x/bmpx8x_fti.c
 delete mode 100644 src/bmx055/CMakeLists.txt
 delete mode 100644 src/bmx055/bmc150.cxx
 delete mode 100644 src/bmx055/bmc150.hpp
 delete mode 100644 src/bmx055/bmi055.cxx
 delete mode 100644 src/bmx055/bmi055.hpp
 delete mode 100644 src/bmx055/bmx055.cxx
 delete mode 100644 src/bmx055/bmx055.hpp
 delete mode 100644 src/bmx055/bmx055.i
 delete mode 100644 src/bmx055/bmx055.json
 delete mode 100644 src/bno055/CMakeLists.txt
 delete mode 100644 src/bno055/bno055.c
 delete mode 100644 src/bno055/bno055.cxx
 delete mode 100644 src/bno055/bno055.h
 delete mode 100644 src/bno055/bno055.hpp
 delete mode 100644 src/bno055/bno055.i
 delete mode 100644 src/bno055/bno055.json
 delete mode 100644 src/bno055/bno055_regs.h
 delete mode 100644 src/button/CMakeLists.txt
 delete mode 100644 src/button/button.c
 delete mode 100644 src/button/button.cxx
 delete mode 100644 src/button/button.h
 delete mode 100644 src/button/button.hpp
 delete mode 100644 src/button/button.i
 delete mode 100644 src/button/button.json
 delete mode 100644 src/buzzer/CMakeLists.txt
 delete mode 100644 src/buzzer/buzzer.c
 delete mode 100644 src/buzzer/buzzer.cxx
 delete mode 100644 src/buzzer/buzzer.h
 delete mode 100644 src/buzzer/buzzer.hpp
 delete mode 100644 src/buzzer/buzzer.i
 delete mode 100644 src/buzzer/buzzer.json
 delete mode 100644 src/buzzer/buzzer_tones.h

diff --git a/src/bacnetmstp/CMakeLists.txt b/src/bacnetmstp/CMakeLists.txt
deleted file mode 100644
index 5e27df0..0000000
--- a/src/bacnetmstp/CMakeLists.txt
+++ /dev/null
@@ -1,11 +0,0 @@
-if (BACNET_FOUND)
-  set (libname "bacnetmstp")
-  set (libdescription "Driver Module for BACnet MS/TP Devices")
-  set (module_src ${libname}.cxx device-client.c bacnetutil.cxx)
-  set (module_hpp ${libname}.hpp bacnetutil.hpp device.h)
-
-  set (reqlibname "libbacnet")
-  upm_module_init(${BACNET_LIBRARIES} ${CMAKE_THREAD_LIBS_INIT})
-  # Add the bacnet include dirs to this target
-  target_include_directories(${libname} PUBLIC ${BACNET_INCLUDE_DIRS})
-endif ()
diff --git a/src/bacnetmstp/bacnetmstp.cxx b/src/bacnetmstp/bacnetmstp.cxx
deleted file mode 100644
index 7807c17..0000000
--- a/src/bacnetmstp/bacnetmstp.cxx
+++ /dev/null
@@ -1,939 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <iostream>
-#include <stdexcept>
-#include <string>
-#include <sstream>
-#include <syslog.h>
-
-#include "bacnetmstp.hpp"
-#include "handlers.h"
-#include "client.h"
-#include "txbuf.h"
-#include "mstpdef.h"
-
-using namespace upm;
-using namespace std;
-
-// our singleton instance
-BACNETMSTP* BACNETMSTP::m_instance = 0;
-
-BACNETMSTP::BACNETMSTP()
-{
-  // set defaults here
-  m_maxInfoFrames = DEFAULT_MAX_INFO_FRAMES;
-  m_maxMaster = DEFAULT_MAX_MASTER;
-  m_baudRate = 38400;
-  m_macAddr = DEFAULT_MAX_MASTER;
-
-  m_initialized = false;
-
-  // 60 sec, for MS/TP
-  m_adpuTimeoutMS = 60000;
-
-  m_deviceInstanceID = BACNET_MAX_INSTANCE;
-
-  memset(m_rxBuffer, 0, MAX_MPDU);
-
-  m_returnedValue.clear();
-  m_targetAddress = {0};
-  m_invokeID = 0;
-  m_errorDetected = false;
-
-  setDebug(false);
-}
-
-BACNETMSTP::~BACNETMSTP()
-{
-  if (m_initialized)
-    datalink_cleanup();
-}
-
-void BACNETMSTP::setDebug(bool enable)
-{
-  m_debugging = enable;
-}
-
-void BACNETMSTP::clearErrors()
-{
-  m_errorType = BACERR_TYPE_NONE;
-
-  // empty out all of our error/reject/abort info
-  m_rejectReason = REJECT_REASON_OTHER;
-  m_rejectString.clear();
-
-  m_abortReason = ABORT_REASON_OTHER;
-  m_abortString.clear();
-
-  m_errorClass = ERROR_CLASS_DEVICE;
-  m_errorCode = ERROR_CODE_OTHER;
-  m_errorString.clear();
-
-  m_upmErrorString.clear();
-}
-
-void BACNETMSTP::handlerError(BACNET_ADDRESS* src,
-                              uint8_t invoke_id,
-                              BACNET_ERROR_CLASS error_class,
-                              BACNET_ERROR_CODE error_code)
-{
-  if (instance()->m_debugging)
-    cerr << __FUNCTION__ << ": entered" << endl;
-
-  if (address_match(&(instance()->m_targetAddress), src) &&
-      (invoke_id == instance()->m_invokeID))
-    {
-      instance()->m_errorType = BACERR_TYPE_ERROR;
-      instance()->m_errorClass = error_class;
-      instance()->m_errorCode = error_code;
-      instance()->m_errorString =
-        bactext_error_class_name((int)error_class)
-        + string(": ") + bactext_error_code_name((int)error_code);
-
-      instance()->m_errorDetected = true;
-  }
-}
-
-void BACNETMSTP::handlerAbort(BACNET_ADDRESS* src,
-                              uint8_t invoke_id,
-                              uint8_t abort_reason,
-                              bool server)
-{
-  (void)server; // not used
-
-  if (instance()->m_debugging)
-    cerr << __FUNCTION__ << ": entered" << endl;
-
-  if (address_match(&(instance()->m_targetAddress), src) &&
-      (invoke_id == instance()->m_invokeID))
-    {
-      instance()->m_errorType = BACERR_TYPE_ABORT;
-      instance()->m_abortReason = abort_reason;
-      instance()->m_abortString =
-        bactext_abort_reason_name((int)abort_reason);
-
-      instance()->m_errorDetected = true;
-    }
-}
-
-void BACNETMSTP::handlerReject(BACNET_ADDRESS* src,
-                               uint8_t invoke_id,
-                               uint8_t reject_reason)
-{
-  if (instance()->m_debugging)
-    cerr << __FUNCTION__ << ": entered" << endl;
-
-  if (address_match(&(instance()->m_targetAddress), src) &&
-      (invoke_id == instance()->m_invokeID))
-    {
-      instance()->m_errorType = BACERR_TYPE_REJECT;
-      instance()->m_rejectReason = reject_reason;
-      instance()->m_rejectString =
-        bactext_reject_reason_name((int)reject_reason);
-
-      instance()->m_errorDetected = true;
-    }
-}
-
-void BACNETMSTP::handlerReadPropertyAck(uint8_t* service_request,
-                                        uint16_t service_len,
-                                        BACNET_ADDRESS* src,
-                                        BACNET_CONFIRMED_SERVICE_ACK_DATA* service_data)
-{
-  int len = 0;
-  BACNET_READ_PROPERTY_DATA data;
-
-  // clear our stored data
-  instance()->m_returnedValue.clear();
-
-  BACNET_APPLICATION_DATA_VALUE value;
-  memset((void *)&value, 0, sizeof(value));
-
-  uint8_t *application_data = 0;
-  int application_data_len = 0;
-
-  if (address_match(&(instance()->m_targetAddress), src) &&
-      (service_data->invoke_id == instance()->m_invokeID))
-    {
-      if (instance()->m_debugging)
-        cerr << __FUNCTION__ << ": got readProp ack" << endl;
-
-      len = rp_ack_decode_service_request(service_request, service_len,
-                                          &data);
-
-      // store any delivered data elements
-      if (len > 0)
-        {
-          application_data_len = data.application_data_len;
-          application_data = data.application_data;
-
-          while (true)
-            {
-              len = bacapp_decode_application_data(application_data,
-                                                   application_data_len,
-                                                   &value);
-              if (len > 0)
-                {
-                  // store a copy
-                  instance()->m_returnedValue.push_back(value);
-
-                  if (len < application_data_len)
-                    {
-                      // there is more data
-                      application_data += len;
-                      application_data_len -= len;
-                    }
-                  else
-                    {
-                      // we are done
-                      break;
-                    }
-                }
-              else
-                {
-                  // shouldn't happen?
-                  cerr << __FUNCTION__ << ": decode app data failed" << endl;
-                  break;
-                }
-            }
-        }
-    }
-
-  if (instance()->m_debugging)
-    cerr << __FUNCTION__ << ": STORED "
-         << instance()->m_returnedValue.size()
-         << " data elements." << endl;
-}
-
-void BACNETMSTP::handlerWritePropertyAck(BACNET_ADDRESS* src,
-                                         uint8_t invoke_id)
-{
-  if (address_match(&(instance()->m_targetAddress), src) &&
-      (invoke_id == instance()->m_invokeID))
-    {
-      if (instance()->m_debugging)
-        cerr << __FUNCTION__ << ": got writeProp ack" << endl;
-    }
-}
-
-void BACNETMSTP::initServiceHandlers()
-{
-  // this is in device-client.c
-  Device_Init(NULL);
-
-  // These are service requests we must handle from other masters
-
-  // we need to handle who-is to support dynamic device binding to us
-  apdu_set_unconfirmed_handler(SERVICE_UNCONFIRMED_WHO_IS, handler_who_is);
-
-  // handle i-am to support binding to other devices
-  apdu_set_unconfirmed_handler(SERVICE_UNCONFIRMED_I_AM, handler_i_am_bind);
-
-  // set the handler for all the services we don't implement
-
-  // It is required to send the proper reject message...
-  apdu_set_unrecognized_service_handler_handler(handler_unrecognized_service);
-
-  // we must implement read property (it's required)
-  apdu_set_confirmed_handler(SERVICE_CONFIRMED_READ_PROPERTY,
-                             handler_read_property);
-
-  // These are related to requests we make
-
-  // handle the data coming back from confirmed readProp requests
-  apdu_set_confirmed_ack_handler(SERVICE_CONFIRMED_READ_PROPERTY,
-                                 handlerReadPropertyAck);
-
-  // handle the simple ack for confirmed writeProp requests
-  apdu_set_confirmed_simple_ack_handler(SERVICE_CONFIRMED_WRITE_PROPERTY,
-                                        handlerWritePropertyAck);
-
-  // handle any errors coming back
-  apdu_set_error_handler(SERVICE_CONFIRMED_READ_PROPERTY, handlerError);
-  apdu_set_abort_handler(handlerAbort);
-  apdu_set_reject_handler(handlerReject);
-}
-
-BACNETMSTP* BACNETMSTP::instance()
-{
-  if (!m_instance)
-    m_instance = new BACNETMSTP;
-
-  return m_instance;
-}
-
-void BACNETMSTP::initMaster(string port, int baudRate,
-                            int deviceInstanceID, int macAddr, int maxMaster,
-                            int maxInfoFrames)
-{
-  // first some checking
-
-  // if we are already initialized, then it's too late to change things now
-  if (m_initialized)
-    {
-      if (m_debugging)
-        cerr << __FUNCTION__ << ": Instance is already initialized, ignored."
-             << endl;
-      return;
-    }
-
-  // baudrate
-  // The standard allows (as of at least 2010) the following baud rates
-  if ( !(baudRate == 9600 || baudRate == 19200 || baudRate == 38400
-         || baudRate == 57600 || baudRate == 76800 || baudRate == 115200) )
-    {
-      throw invalid_argument(string(__FUNCTION__)
-                                  + ": baudRate must be 9600, 19200, 38400, "
-                                  + " 57600, 76800, or 115200");
-    }
-
-  // maxMaster
-  // maxMaster must be less than or equal to 127
-  if (maxMaster < 0 || maxMaster > DEFAULT_MAX_MASTER)
-    {
-      throw out_of_range(string(__FUNCTION__)
-                              + ": maxMaster must be between 0 and "
-                              + to_string(DEFAULT_MAX_MASTER));
-    }
-
-  // As a master ourselves, we must have a MAC address also within the
-  // constraints of maxMaster
-  if (macAddr < 0 || macAddr > DEFAULT_MAX_MASTER)
-    {
-      throw out_of_range(string(__FUNCTION__)
-                              + ": macAddr must be between 0 and "
-                              + to_string(DEFAULT_MAX_MASTER));
-    }
-
-  // this should be unique on the network
-  if (deviceInstanceID >= BACNET_MAX_INSTANCE)
-    {
-      throw out_of_range(string(__FUNCTION__)
-                              + ": deviceInstanceID must be less than "
-                              + to_string(BACNET_MAX_INSTANCE)
-                              + ", and must be unique on the network");
-    }
-
-  m_port = port;
-  m_baudRate = baudRate;
-  m_maxInfoFrames = maxInfoFrames;
-  m_macAddr = macAddr;
-  m_maxMaster = maxMaster;
-  m_deviceInstanceID = deviceInstanceID;
-
-  // Let the fun begin...
-
-  // setup our info
-  Device_Set_Object_Instance_Number(m_deviceInstanceID);
-  address_init();
-
-  initServiceHandlers();
-
-  dlmstp_set_max_info_frames(m_maxInfoFrames);
-  dlmstp_set_max_master(m_maxMaster);
-  dlmstp_set_baud_rate(m_baudRate);
-  dlmstp_set_mac_address(m_macAddr);
-
-  // FIXME - allow to change?
-  apdu_timeout_set(m_adpuTimeoutMS);
-
-  // Ordinarily, I'd like to check the return value of this function,
-  // but even in the face of errors, it always returns true :( This
-  // function starts the ball rolling, and initializes the Master FSM
-  // thread.  Unfortunately, it doesn't appear this can be turned back
-  // off without exiting the application.
-  datalink_init((char *)port.c_str());
-
-  m_initialized = true;
-}
-
-bool BACNETMSTP::dispatchRequest()
-{
-  uint16_t pdu_len = 0;
-  unsigned timeout = 100;     // milliseconds
-  unsigned max_apdu = 0;
-  time_t elapsed_seconds = 0;
-  time_t last_seconds = 0;
-  time_t current_seconds = 0;
-  time_t timeout_seconds = 0;
-  bool found = false;
-
-  // address where message came from
-  BACNET_ADDRESS src = {0};
-
-  clearErrors();
-  m_errorDetected = false;
-
-  uint32_t targetDeviceInstanceID = BACNET_MAX_INSTANCE;
-
-  switch (m_command.cmd)
-    {
-    case BACCMD_READ_PROPERTY:
-      targetDeviceInstanceID = m_command.readPropArgs.targetDeviceInstanceID;
-      break;
-
-    case BACCMD_WRITE_PROPERTY:
-      targetDeviceInstanceID = m_command.writePropArgs.targetDeviceInstanceID;
-      break;
-
-    case BACCMD_NONE:
-      {
-        m_errorType = BACERR_TYPE_UPM;
-        m_upmErrorString = string(__FUNCTION__) +
-          ": called with BACCMD_NONE, ignoring";
-
-        return true; // error
-      }
-
-      break;
-
-    default:
-      {
-        // should this throw?
-        m_errorType = BACERR_TYPE_UPM;
-        m_upmErrorString = string(__FUNCTION__) +
-          ": internal error, called with unknown command, ignoring";
-
-        return true; // error
-      }
-
-      break;
-    }
-
-  // timeouts
-  last_seconds = time(NULL);
-  timeout_seconds = (apdu_timeout() / 1000) * apdu_retries();
-
-  // we use 0 to indicate that request hasn't been made yet, so that
-  // it will be made once the address is bound.
-  m_invokeID = 0;
-
-  // bind to the device first.
-  found = address_bind_request(targetDeviceInstanceID, &max_apdu,
-                               &(instance()->m_targetAddress));
-
-  if (!found)
-    {
-      if (m_debugging)
-        cerr << __FUNCTION__ << ": Address not found, Sending WhoIs..." << endl;
-
-      Send_WhoIs(targetDeviceInstanceID, targetDeviceInstanceID);
-    }
-  else
-    {
-      if (m_debugging)
-        cerr << __FUNCTION__ << ": Address was found" << endl;
-    }
-
-  // loop until either we get our data, an error occurs, or we timeout
-  while (true)
-    {
-      current_seconds = time(NULL);
-
-      // at least one second has passed
-      if (current_seconds != last_seconds)
-        tsm_timer_milliseconds((uint16_t) ((current_seconds -
-                                            last_seconds) * 1000));
-      if (m_errorDetected)
-        break;
-
-      // we have to wait until the address is bound before proceeding
-      if (!found)
-        {
-          found =
-            address_bind_request(targetDeviceInstanceID, &max_apdu,
-                                 &(instance()->m_targetAddress));
-        }
-
-      if (found)
-        {
-          // address is bound, and we have not sent our request yet.  Make it so.
-          if (m_invokeID == 0)
-            {
-              switch (m_command.cmd)
-                {
-                case BACCMD_READ_PROPERTY:
-                  m_invokeID =
-                    Send_Read_Property_Request(targetDeviceInstanceID,
-                                               m_command.readPropArgs.objType,
-                                               m_command.readPropArgs.objInstance,
-                                               m_command.readPropArgs.objProperty,
-                                               m_command.readPropArgs.arrayIndex);
-                  if (m_debugging)
-                    cerr << __FUNCTION__
-                         << ": Called Send_Read_Property_Request(), m_invokeID = "
-                         << (int)m_invokeID << endl;
-
-                  break;
-
-                case BACCMD_WRITE_PROPERTY:
-                  m_invokeID =
-                    Send_Write_Property_Request(targetDeviceInstanceID,
-                                                m_command.writePropArgs.objType,
-                                                m_command.writePropArgs.objInstance,
-                                                m_command.writePropArgs.objProperty,
-                                                m_command.writePropArgs.propValue,
-                                                m_command.writePropArgs.propPriority,
-                                                m_command.writePropArgs.arrayIndex);
-                  if (m_debugging)
-                    cerr << __FUNCTION__
-                         << ": Called Send_Write_Property_Request(), m_invokeID = "
-                         << (int)m_invokeID << endl;
-
-                  break;
-                default:
-                  syslog(LOG_WARNING, "%s: switch case not defined",
-                          string(__FUNCTION__).c_str());
-                }
-            }
-          else if (tsm_invoke_id_free(m_invokeID))
-            {
-              // transaction completed successfully
-
-              if (m_debugging)
-                cerr << __FUNCTION__ << ": Success, m_invokeID = "
-                     << (int)m_invokeID << endl;
-
-              break;
-            }
-          else if (tsm_invoke_id_failed(m_invokeID))
-            {
-              // transaction state machine failed, most likely timeout
-              tsm_free_invoke_id(m_invokeID);
-
-              m_errorType = BACERR_TYPE_UPM;
-              m_upmErrorString = string(__FUNCTION__) +
-                ": TSM Timed Out.";
-
-              if (m_debugging)
-                cerr << m_upmErrorString << endl;
-
-              m_errorDetected = true;
-
-              break;
-            }
-        }
-      else
-        {
-          // still waiting to bind.  timeout if we've waited too long.
-          elapsed_seconds += (current_seconds - last_seconds);
-          if (elapsed_seconds > timeout_seconds)
-            {
-              m_errorType = BACERR_TYPE_UPM;
-              m_upmErrorString = string(__FUNCTION__) +
-                ": Timed out waiting to bind address.";
-
-              // We output this error unconditionally as this is an
-              // error you will get if you supply a non-existant
-              // Device Obeject Instance ID.
-
-              cerr << m_upmErrorString << endl;
-              cerr << __FUNCTION__
-                   << ": Did you supply the correct Device Object Instance ID "
-                   << "for your device?"
-                   << endl;
-
-              m_errorDetected = true;
-              break;
-            }
-        }
-
-      // returns 0 bytes on timeout
-      pdu_len = datalink_receive(&src, m_rxBuffer, MAX_MPDU, timeout);
-
-      // process the packet if valid.  This will call our handlers as needed.
-      if (pdu_len)
-        npdu_handler(&src, m_rxBuffer, pdu_len);
-
-      // keep track of time for next check
-      last_seconds = current_seconds;
-    }
-
-  return m_errorDetected;
-}
-
-bool BACNETMSTP::readProperty(uint32_t targetDeviceInstanceID,
-                              BACNET_OBJECT_TYPE objType,
-                              uint32_t objInstance,
-                              BACNET_PROPERTY_ID objProperty,
-                              uint32_t arrayIndex)
-{
-  // some sanity checking...
-  if (objInstance >= BACNET_MAX_INSTANCE)
-    {
-      throw out_of_range(string(__FUNCTION__)
-                              + ": objInstance must be less than "
-                              + to_string(BACNET_MAX_INSTANCE));
-    }
-
-  // fill in the command structure and dispatch
-  m_command.cmd = BACCMD_READ_PROPERTY;
-  m_command.readPropArgs.targetDeviceInstanceID = targetDeviceInstanceID;
-  m_command.readPropArgs.objType = objType;
-  m_command.readPropArgs.objInstance = objInstance;
-  m_command.readPropArgs.objProperty = objProperty;
-  m_command.readPropArgs.arrayIndex = arrayIndex;
-
-  if (m_debugging)
-    cerr << __FUNCTION__  << ": calling dispatchRequest()..." << endl;
-
-  // send it off
-  bool error = dispatchRequest();
-
-  // clear the command to avoid accidental re-calls
-  m_command.cmd = BACCMD_NONE;
-
-  return error;
-}
-
-bool BACNETMSTP::writeProperty(uint32_t targetDeviceInstanceID,
-                               BACNET_OBJECT_TYPE objType,
-                               uint32_t objInstance,
-                               BACNET_PROPERTY_ID objProperty,
-                               BACNET_APPLICATION_DATA_VALUE* propValue,
-                               uint8_t propPriority,
-                               int32_t arrayIndex)
-{
-  // some sanity checking...
-  if (objInstance >= BACNET_MAX_INSTANCE)
-    {
-      throw out_of_range(string(__FUNCTION__)
-                              + ": objInstance must be less than "
-                              + to_string(BACNET_MAX_INSTANCE));
-    }
-
-  // fill in the command structure and dispatch
-  m_command.cmd = BACCMD_WRITE_PROPERTY;
-  m_command.writePropArgs.targetDeviceInstanceID = targetDeviceInstanceID;
-  m_command.writePropArgs.objType = objType;
-  m_command.writePropArgs.objInstance = objInstance;
-  m_command.writePropArgs.objProperty = objProperty;
-  m_command.writePropArgs.propValue = propValue;
-  m_command.writePropArgs.propPriority = propPriority;
-  m_command.writePropArgs.arrayIndex = arrayIndex;
-
-  if (m_debugging)
-    cerr << __FUNCTION__  << ": calling dispatchRequest()..." << endl;
-
-  // send it off
-  bool error = dispatchRequest();
-
-  // clear the command to avoid accidental re-calls
-  m_command.cmd = BACCMD_NONE;
-
-  return error;
-}
-
-BACNET_APPLICATION_DATA_VALUE BACNETMSTP::getData(int index)
-{
-  return m_returnedValue.at(index);
-}
-
-int BACNETMSTP::getDataNumElements()
-{
-  return m_returnedValue.size();
-}
-
-uint8_t BACNETMSTP::getDataType(int index)
-{
-  return m_returnedValue.at(index).tag;
-}
-
-float BACNETMSTP::getDataTypeReal(int index)
-{
-  if (getDataType(index) == BACNET_APPLICATION_TAG_REAL)
-    return m_returnedValue.at(index).type.Real;
-  else
-    {
-      if (m_debugging)
-        cerr << __FUNCTION__ << ": Not of Real type, trying to convert..." << endl;
-
-      // try to convert or throw
-      switch (getDataType(index))
-        {
-        case BACNET_APPLICATION_TAG_BOOLEAN:
-          return (getDataTypeBoolean(index) ? 1.0 : 0.0);
-        case BACNET_APPLICATION_TAG_UNSIGNED_INT:
-          return float(getDataTypeUnsignedInt(index));
-        case BACNET_APPLICATION_TAG_SIGNED_INT:
-          return float(getDataTypeSignedInt(index));
-        default:
-          throw invalid_argument(string(__FUNCTION__)
-                                      + ": data type ("
-                                      + to_string(int(getDataType(index)))
-                                      + ") is not convertible to Real");
-        }
-    }
-}
-
-bool BACNETMSTP::getDataTypeBoolean(int index)
-{
-  if (getDataType(index) == BACNET_APPLICATION_TAG_BOOLEAN)
-    return ((m_returnedValue.at(index).type.Boolean) ? true : false);
-  else
-    throw invalid_argument(string(__FUNCTION__)
-                                + ": data type ("
-                                + to_string(int(getDataType(index)))
-                                + ") is not convertible to Bool");
-}
-
-unsigned int BACNETMSTP::getDataTypeUnsignedInt(int index)
-{
-  if (getDataType(index) == BACNET_APPLICATION_TAG_UNSIGNED_INT)
-    return m_returnedValue.at(index).type.Unsigned_Int;
-  else
-    throw invalid_argument(string(__FUNCTION__)
-                                + ": data type ("
-                                + to_string(int(getDataType(index)))
-                                + ") is not convertible to UnsignedInt");
-}
-
-int BACNETMSTP::getDataTypeSignedInt(int index)
-{
-  if (getDataType(index) == BACNET_APPLICATION_TAG_SIGNED_INT)
-    return m_returnedValue.at(index).type.Signed_Int;
-  else
-    throw invalid_argument(string(__FUNCTION__)
-                                + ": data type ("
-                                + to_string(int(getDataType(index)))
-                                + ") is not convertible to SignedInt");
-}
-
-#if defined(BACAPP_DOUBLE)
-double BACNETMSTP::getDataTypeDouble(int index)
-{
-  if (getDataType() == BACNET_APPLICATION_TAG_DOUBLE)
-    return m_returnedValue.at(index).type.Double;
-  else
-    {
-      if (m_debugging)
-        cerr << __FUNCTION__ << ": Not of Double type, trying to convert..." << endl;
-
-      // try to convert or throw
-      switch (getDataType(index))
-        {
-        case BACNET_APPLICATION_TAG_REAL:
-          return double(getDataTypeReal(index));
-        case BACNET_APPLICATION_TAG_BOOLEAN:
-          return (getDataTypeBoolean(index) ? 1.0 : 0.0);
-        case BACNET_APPLICATION_TAG_UNSIGNED_INT:
-          return double(getDataTypeUnsignedInt(index));
-        case BACNET_APPLICATION_TAG_SIGNED_INT:
-          return double(getDataTypeSignedInt(index));
-        default:
-          throw invalid_argument(string(__FUNCTION__)
-                                      + ": data type ("
-                                      + to_string(int(getDataType(index)))
-                                      + ") is not convertible to Double");
-        }
-    }
-}
-#endif // BACAPP_DOUBLE
-
-unsigned int BACNETMSTP::getDataTypeEnum(int index)
-{
-  if (getDataType(index) == BACNET_APPLICATION_TAG_ENUMERATED)
-    return m_returnedValue.at(index).type.Enumerated;
-  else
-    throw invalid_argument(string(__FUNCTION__)
-                                + ": data type ("
-                                + to_string(int(getDataType(index)))
-                                + ") is not convertible to Enum");
-}
-
-string BACNETMSTP::getDataTypeString(int index)
-{
-    string retval;
-
-  // Here, we can try to accomodate all the types
-  switch(getDataType(index))
-    {
-    case BACNET_APPLICATION_TAG_REAL:
-      retval = to_string(getDataTypeReal(index));
-      break;
-
-#if defined(BACAPP_DOUBLE)
-    case BACNET_APPLICATION_TAG_DOUBLE:
-      retval = to_string(getDataTypeDouble(index));
-      break;
-#endif // BACAPP_DOUBLE
-
-    case BACNET_APPLICATION_TAG_UNSIGNED_INT:
-      retval = to_string(getDataTypeUnsignedInt(index));
-      break;
-
-    case BACNET_APPLICATION_TAG_SIGNED_INT:
-      retval = to_string(getDataTypeSignedInt(index));
-      break;
-
-    case BACNET_APPLICATION_TAG_BOOLEAN:
-      retval = (getDataTypeBoolean(index) ? string("true") : string("false"));
-      break;
-
-    case BACNET_APPLICATION_TAG_CHARACTER_STRING:
-      retval = string(characterstring_value(&m_returnedValue.at(index).type.Character_String),
-
-                      characterstring_length(&m_returnedValue.at(index).type.Character_String));
-      break;
-
-    case BACNET_APPLICATION_TAG_OCTET_STRING:
-      {
-          string tmpstr((char *)octetstring_value(&m_returnedValue.at(index).type.Octet_String),
-
-                      octetstring_length(&m_returnedValue.at(index).type.Octet_String));
-        retval = string2HexString(tmpstr);
-      }
-
-      break;
-
-    case BACNET_APPLICATION_TAG_BIT_STRING:
-      {
-        int len = bitstring_bits_used(&m_returnedValue.at(index).type.Bit_String);
-
-        for (int i=0; i<len; i++)
-          {
-            if (bitstring_bit(&m_returnedValue.at(index).type.Bit_String,
-                              uint8_t(i)))
-              retval += "1";
-            else
-              retval += "0";
-
-            if (i != 0 && ((i % 8) == 0))
-              retval += " ";
-          }
-      }
-
-      break;
-
-    default:
-      throw invalid_argument(string(__FUNCTION__)
-                                  + ": data type ("
-                                  + to_string(int(getDataType(index)))
-                                  + ") is not convertible to String");
-      break;
-    }
-
-  return retval;
-}
-
-BACNET_APPLICATION_DATA_VALUE BACNETMSTP::createDataReal(float value)
-{
-  BACNET_APPLICATION_DATA_VALUE data;
-
-  memset(&data, 0, sizeof(BACNET_APPLICATION_DATA_VALUE));
-
-  data.tag = BACNET_APPLICATION_TAG_REAL;
-  data.type.Real = value;
-
-  return data;
-}
-
-BACNET_APPLICATION_DATA_VALUE BACNETMSTP::createDataBool(bool value)
-{
-  BACNET_APPLICATION_DATA_VALUE data;
-
-  memset(&data, 0, sizeof(BACNET_APPLICATION_DATA_VALUE));
-
-  data.tag = BACNET_APPLICATION_TAG_BOOLEAN;
-  data.type.Boolean = value;
-
-  return data;
-}
-
-BACNET_APPLICATION_DATA_VALUE BACNETMSTP::createDataSignedInt(int value)
-{
-  BACNET_APPLICATION_DATA_VALUE data;
-
-  memset(&data, 0, sizeof(BACNET_APPLICATION_DATA_VALUE));
-
-  data.tag = BACNET_APPLICATION_TAG_SIGNED_INT;
-  data.type.Signed_Int = value;
-
-  return data;
-}
-
-BACNET_APPLICATION_DATA_VALUE BACNETMSTP::createDataUnsignedInt(unsigned int value)
-{
-  BACNET_APPLICATION_DATA_VALUE data;
-
-  memset(&data, 0, sizeof(BACNET_APPLICATION_DATA_VALUE));
-
-  data.tag = BACNET_APPLICATION_TAG_UNSIGNED_INT;
-  data.type.Unsigned_Int = value;
-
-  return data;
-}
-
-BACNET_APPLICATION_DATA_VALUE BACNETMSTP::createDataString(string value)
-{
-  if (value.size() > (MAX_CHARACTER_STRING_BYTES - 1))
-    {
-      throw invalid_argument(string(__FUNCTION__)
-                                  + ": value must be less than or equal to "
-                                  + to_string(MAX_CHARACTER_STRING_BYTES - 1)
-                                  + " characters long");
-    }
-
-  BACNET_APPLICATION_DATA_VALUE data;
-
-  memset(&data, 0, sizeof(BACNET_APPLICATION_DATA_VALUE));
-
-  data.tag = BACNET_APPLICATION_TAG_CHARACTER_STRING;
-
-  characterstring_init_ansi(&data.type.Character_String, value.c_str());
-
-  return data;
-}
-
-BACNET_APPLICATION_DATA_VALUE BACNETMSTP::createDataEnum(uint32_t value)
-{
-  BACNET_APPLICATION_DATA_VALUE data;
-
-  memset(&data, 0, sizeof(BACNET_APPLICATION_DATA_VALUE));
-
-  data.tag = BACNET_APPLICATION_TAG_ENUMERATED;
-  data.type.Enumerated = value;
-
-  return data;
-}
-
-string BACNETMSTP::string2HexString(string input)
-{
-  static const char* const lut = "0123456789abcdef";
-  size_t len = input.size();
-
-  string output;
-  output.reserve(3 * len);
-  for (size_t i = 0; i < len; ++i)
-    {
-      const unsigned char c = input[i];
-      output.push_back(lut[c >> 4]);
-      output.push_back(lut[c & 15]);
-      output.push_back(' ');
-    }
-
-  return output;
-}
diff --git a/src/bacnetmstp/bacnetmstp.hpp b/src/bacnetmstp/bacnetmstp.hpp
deleted file mode 100644
index 7ad3ad1..0000000
--- a/src/bacnetmstp/bacnetmstp.hpp
+++ /dev/null
@@ -1,754 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <vector>
-
-// we only support a BACnet RS-485 MS/TP datalink
-#define BACDL_MSTP 1
-#undef BACDL_ALL
-
-// get a variety of bacnet-stack includes...
-#include "bacdef.h"
-#include "config.h"
-#include "bactext.h"
-#include "bacerror.h"
-#include "iam.h"
-#include "arf.h"
-#include "tsm.h"
-#include "address.h"
-#include "npdu.h"
-#include "apdu.h"
-#include "device.h"
-#include "datalink.h"
-#include "whois.h"
-#include "mstpdef.h"
-#include "dlmstp.h"
-
-
-namespace upm {
-
-  /**
-   * @brief BACNETMSTP Library
-   * @defgroup bacnetmstp libupm-bacnetmstp
-   * @ingroup uart
-   */
-
-  /**
-   * @library bacnetmstp
-   * @sensor bacnetmstp
-   * @comname UPM API for BACNET MS/TP Communications
-   * @con uart
-   * @web http://bacnet.sourceforge.net/
-   * @brief UPM API for BACNETMSTP
-   *
-   * This is a singleton class that provides services to UPM BACnet
-   * drivers (like E50HX) based on the bacnet-stack at
-   * http://bacnet.sourceforge.net .  This class is implemented as a
-   * singleton due to the fact that the bacnet-stack implementation
-   * does not currently allow multiple simultaneous datalinks.  We are
-   * using 0.8.3 of bacnet-stack.  In the future this restriction may
-   * be lifted depending on bacnet-stack, but for now, you are
-   * stuck with only a single BACnet MS/TP datalink.
-   *
-   * This driver is not intended to be used by end users.  It is
-   * intended for use with other UPM drivers that require access to a
-   * BACnet MS/TP (Master Slave/Token Passing) network over RS-485.
-   *
-   * For this reason, no examples are provided.  If you wish to
-   * implement your own BACnet MS/TP driver, please look at the E50HX
-   * driver to see how this class can be used.
-   *
-   * Currently, only readProperty and writeProperty BACnet requests
-   * are supported.  In the future, any other BACnet requests could be
-   * supported as well.  readProperty and writeProperty should provide
-   * most of what you will need when communicating with BACnet
-   * devices.  Since the source code is open, feel free to add other
-   * services as you see fit :)
-   *
-   * In order to make requests over an MS/TP network, you must be a
-   * BACnet master.  initMaster() is responsible for configuring your
-   * underlying RS-485 network and starting a Master FSM (finite state
-   * machine) thread that will be responsible for identifying other
-   * Masters on the network and negotiating token passing.  Your
-   * master can only transmit when it has the token.
-   *
-   * Fortunately, all of these messy details are handled for you by
-   * this class, or the underlying bacnet-stack library this class
-   * relies on.
-
-   */
-
-  class BACNETMSTP {
-    // Constructor and destructor are protected
-
-  public:
-
-    // error types
-    typedef enum {
-      BACERR_TYPE_NONE                = 0,
-      BACERR_TYPE_REJECT,
-      BACERR_TYPE_ABORT,
-      BACERR_TYPE_ERROR,
-      BACERR_TYPE_UPM
-    } BACERR_TYPE_T;
-
-    // command types we currently support
-    typedef enum {
-      BACCMD_NONE                     = 0,
-      BACCMD_READ_PROPERTY,
-      BACCMD_WRITE_PROPERTY
-    } BACCMD_TYPE_T;
-
-    /**
-     * Get our singleton instance, initializing it if neccessary.  All
-     * requests to this class should be done through this instance
-     * accessor.
-     *
-     * @return static pointer to our class instance
-     */
-    static BACNETMSTP* instance();
-
-    /**
-     * This function initializes the underlying BACNETMSTP Master
-     * singleton in the event it has not already been initialized.  If
-     * the BACNETMSTP Master singleton has already been initialized,
-     * then this call will be ignored.  There can be only one.
-     *
-     * @param port The serial port that the RS-485 interface is
-     * connected to.
-     * @param baudRate The baudrate of the RS-485 interface.  All
-     * devices on a BACnet RS-485 bus must run at the same baudrate.
-     * Valid values are 9600, 19200, 38400, 57600, 76800, and 115200.
-     * @param deviceInstanceNumber This is the unique Device Object
-     * Instance number that will be used for our BACnet Master in
-     * order to communicate over the BACnet interface.  This number
-     * must be between 1-4194302 and must be unique on the BACnet
-     * network.
-     * @param macAddr This is the MAC address of our BACnet Master.
-     * It must be unique on the BACnet segment, and must be between
-     * 1-127.
-     * @param maxMaster This specifies to our Master the maximum MAC
-     * address used by any other Masters on the BACnet network.  This
-     * must be between 1-127, the default is 127.  Do not change this
-     * unless you know what you are doing or you could introduce
-     * token passing errors on the BACnet network.
-     * @param maxInfoFrames This number specifies the maximum number
-     * of transmissions (like requests for data) our Master is allowed
-     * to make before passing the token to the next Master.  The
-     * default is 1.
-     */
-    void initMaster(std::string port, int baudRate, int deviceInstanceNumber,
-                    int macAddr, int maxMaster=DEFAULT_MAX_MASTER,
-                    int maxInfoFrames=1);
-
-
-    /**
-     * Perform a BACnet readProperty transaction.  This function will
-     * return when either the transaction has completed, or an error
-     * has occurred.  It requests the value of a property, belonging
-     * to a specific object instance on a specific device.
-     *
-     * @param targetDeviceInstanceID This is the Device Object
-     * Instance ID of the device to send the request to.  This number
-     * will be unique for every device on the network.  An address
-     * lookup will be performed the first time a request is made to a
-     * device using the WhoHas BACnet service.  The result will be
-     * cached for further use.
-     * @param objType This is the BACnet object type of the object you
-     * wish to query.  It should be one of the BACNET_OBJECT_TYPE
-     * values.
-     * @param objInstance This is the instance number of the Object
-     * you wish to access. It is an integer starting from 1.
-     * @param objProperty This is the property of the Object and
-     * instance you wish to access.  It should be one of the
-     * BACNET_PROPERTY_ID values.
-     * @param arrayIndex This specifies the index number of an array
-     * property. The default is BACNET_ARRAY_ALL.
-     * @return true if an error occurred, false otherwise.
-     */
-    bool readProperty(uint32_t targetDeviceInstanceID,
-                      BACNET_OBJECT_TYPE objType,
-                      uint32_t objInstance,
-                      BACNET_PROPERTY_ID objProperty,
-                      uint32_t arrayIndex=BACNET_ARRAY_ALL);
-
-    /**
-     * Perform a BACnet writeProperty transaction.  This function will
-     * return when either the transaction has completed, or an error
-     * has occurred.  It writes the supplied value to a property,
-     * belonging to a specific object instance on a specific device.
-     *
-     * @param targetDeviceInstanceID This is the Device Object
-     * Instance ID of the device to send the request to.  This number
-     * will be unique for every device on the network.  An address
-     * lookup will be performed the first time a request is made to a
-     * device using the WhoHas BACnet service.  The result will be
-     * cached for further use.
-     * @param objType This is the BACnet object type of the object you
-     * wish to query.  It should be one of the BACNET_OBJECT_TYPE
-     * values.
-     * @param objInstance This is the instance number of the Object
-     * you wish to access. It is an integer starting from 1.
-     * @param objProperty This is the property of the Object and
-     * instance you wish to access.  It should be one of the
-     * BACNET_PROPERTY_ID values.
-     * @param propValue This is a pointer to a
-     * BACNET_APPLICATION_DATA_VALUE structure containg the data value
-     * to write to the property. Use the createData*() methods to
-     * properly create these structures.
-     * @param propPriority This specifies the priority of a
-     * commandable property.  Leave it at the default unless you know
-     * what you are doing.  In addition, there is conflicting
-     * information in the bacnet-stack documentation as to whether
-     * this is even supported.
-     * @param arrayIndex This specifies the index number of an array
-     * property. The default is BACNET_ARRAY_ALL.
-     * @return true if an error occurred, false otherwise.
-     */
-    bool writeProperty(uint32_t targetDeviceInstanceID,
-                       BACNET_OBJECT_TYPE objType,
-                       uint32_t objInstance,
-                       BACNET_PROPERTY_ID objProperty,
-                       BACNET_APPLICATION_DATA_VALUE* propValue,
-                       uint8_t propPriority=BACNET_NO_PRIORITY,
-                       int32_t arrayIndex=BACNET_ARRAY_ALL);
-
-    /**
-     * After a successful readProperty request, this method can be used
-     * to return a BACNET_APPLICATION_DATA_VALUE structure containing
-     * the returned data.
-     *
-     * @param index into the list of returned data. 0 (first) is the
-     * default.
-     * @return a BACNET_APPLICATION_DATA_VALUE structure containing
-     * the returned data.
-     */
-    BACNET_APPLICATION_DATA_VALUE getData(int index=0);
-
-    /**
-     * After a successful readProperty request, this method can be
-     * used to return the number of data elements returned.  This will
-     * usually be 1, unless reading an array.
-     *
-     * @return The number of data elements received.
-     */
-    int getDataNumElements();
-
-    /**
-     * After a successful readProperty request, this method can be
-     * used to return the BACnet data type of the returned data.  It
-     * will be one of the BACNET_APPLICATION_TAG_* values.
-     *
-     * @param index into the list of returned data. 0 (first) is the
-     * default.
-     * @return A BACNET_APPLICATION_TAG_* value
-     */
-    uint8_t getDataType(int index=0);
-
-    /**
-     * After a successful readProperty request, this method can be
-     * used to return the BACnet dataype of the returned data as a
-     * Real.  If the data type (getDataType()) is not a
-     * BACNET_APPLICATION_TAG_REAL, and the value returned cannot be
-     * safely converted, an exception is thrown.
-     *
-     * @param index into the list of returned data. 0 (first) is the
-     * default.
-     * @return A floating point value representing the returned data
-     */
-    float getDataTypeReal(int index=0);
-
-    /**
-     * After a successful readProperty request, this method can be
-     * used to return the BACnet dataype of the returned data as a
-     * Boolean.  If the data type (getDataType()) is not a
-     * BACNET_APPLICATION_TAG_BOOLEAN, and the value returned cannot
-     * be safely converted, an exception is thrown.
-     *
-     * @param index into the list of returned data. 0 (first) is the
-     * default.
-     * @return A boolean value representing the returned data
-     */
-    bool getDataTypeBoolean(int index=0);
-
-    /**
-     * After a successful readProperty request, this method can be
-     * used to return the BACnet dataype of the returned data as a
-     * unsigned int.  If the data type (getDataType()) is not a
-     * BACNET_APPLICATION_TAG_UNSIGNED_INT, and the value returned
-     * cannot be safely converted, an exception is thrown.
-     *
-     * @param index into the list of returned data. 0 (first) is the
-     * default.
-     * @return An unsigned int value representing the returned data
-     */
-    unsigned int getDataTypeUnsignedInt(int index=0);
-
-    /**
-     * After a successful readProperty request, this method can be
-     * used to return the BACnet dataype of the returned data as a
-     * signed int.  If the data type (getDataType()) is not a
-     * BACNET_APPLICATION_TAG_SIGNED_INT, and the value returned
-     * cannot be safely converted, an exception is thrown.
-     *
-     * @param index into the list of returned data. 0 (first) is the
-     * default.
-     * @return A signed int value representing the returned data
-     */
-    int getDataTypeSignedInt(int index=0);
-
-    /**
-     * After a successful readProperty request, this method can be
-     * used to return the BACnet dataype of the returned data as a
-     * string.  Most of the data types except Enum can be converted to
-     * a string.  If the data type (getDataType()) is not a
-     * BACNET_APPLICATION_TAG_CHARACTER_STRING, and the value returned
-     * cannot be safely converted, an exception is thrown.
-     *
-     * @param index into the list of returned data. 0 (first) is the
-     * default.
-     * @return A string value representing the returned data
-     */
-    std::string getDataTypeString(int index=0);
-
-    /**
-     * After a successful readProperty request, this method can be
-     * used to return the BACnet dataype of the returned data as an
-     * enumeration.  If the data type (getDataType()) is not a
-     * BACNET_APPLICATION_TAG_ENUMERATED an exception is thrown.
-     *
-     * @param index into the list of returned data. 0 (first) is the
-     * default.
-     * @return An unsigned int representing a BACnet enumerant
-     */
-    unsigned int getDataTypeEnum(int index=0);
-
-#if defined(BACAPP_DOUBLE)
-    /**
-     * After a successful readProperty request, this method can be
-     * used to return the BACnet dataype of the returned data as a
-     * double.  If the data type (getDataType()) is not a
-     * BACNET_APPLICATION_TAG_DOUBLE, and the value returned cannot be
-     * safely converted, an exception is thrown.
-     *
-     * @param index into the list of returned data. 0 (first) is the
-     * default.
-     * @return A double floating point value representing the returned data
-     */
-    double getDataTypeDouble(int index=0);
-#endif // BACAPP_DOUBLE
-
-    /**
-     * This method is used to create and return an initialized
-     * BACNET_APPLICATION_DATA_VALUE containing a real (floating point
-     * value).  A pointer to this returned structure can then be used
-     * with writeProperty().
-     *
-     * @param value The floating point value to initialize the structure to.
-     * @return An initialized structure containing the value
-     */
-    BACNET_APPLICATION_DATA_VALUE createDataReal(float Real);
-
-    /**
-     * This method is used to create and return an initialized
-     * BACNET_APPLICATION_DATA_VALUE containing a boolean.  A pointer
-     * to this returned structure can then be used with
-     * writeProperty().
-     *
-     * @param value The boolean value to initialize the structure to.
-     * @return An initialized structure containing the value
-     */
-    BACNET_APPLICATION_DATA_VALUE createDataBool(bool value);
-
-    /**
-     * This method is used to create and return an initialized
-     * BACNET_APPLICATION_DATA_VALUE containing a signed integer.  A
-     * pointer to this returned structure can then be used with
-     * writeProperty().
-     *
-     * @param value The signed integer value to initialize the structure to.
-     * @return An initialized structure containing the value
-     */
-    BACNET_APPLICATION_DATA_VALUE createDataSignedInt(int value);
-
-    /**
-     * This method is used to create and return an initialized
-     * BACNET_APPLICATION_DATA_VALUE containing a unsigned integer.  A
-     * pointer to this returned structure can then be used with
-     * writeProperty().
-     *
-     * @param value The unsigned integer value to initialize the
-     * structure to.
-     * @return An initialized structure containing the value
-     */
-    BACNET_APPLICATION_DATA_VALUE createDataUnsignedInt(unsigned int value);
-
-    /**
-     * This method is used to create and return an initialized
-     * BACNET_APPLICATION_DATA_VALUE containing a character string.  A
-     * pointer to this returned structure can then be used with
-     * writeProperty().  Strings are typically limited to 63 characters.
-     *
-     * @param value The character string value to initialize the
-     * structure to.
-     * @return An initialized structure containing the value
-     */
-    BACNET_APPLICATION_DATA_VALUE createDataString(std::string value);
-
-    /**
-     * This method is used to create and return an initialized
-     * BACNET_APPLICATION_DATA_VALUE containing an enumeration.  A
-     * pointer to this returned structure can then be used with
-     * writeProperty().
-     *
-     * @param value The BACnet enumeration to initialize the
-     * structure to.
-     * @return An initialized structure containing the value
-     */
-    BACNET_APPLICATION_DATA_VALUE createDataEnum(uint32_t value);
-
-    /**
-     * Return an enumration of the last error type to occur.  The
-     * value returned will be one of the BACERR_TYPE_T values.
-     *
-     * @return The last error type to occur, one of the BACERR_TYPE_T
-     * values.
-     */
-    BACERR_TYPE_T getErrorType()
-    {
-      return m_errorType;
-    };
-
-    /**
-     * In the event of a BACnet Reject error, return the error code.
-     *
-     * @return The Reject error code.
-     */
-    uint8_t getRejectReason()
-    {
-      return m_rejectReason;
-    };
-
-    /**
-     * In the event of a BACnet Reject error, return the error string.
-     *
-     * @return The Reject error string.
-     */
-    std::string getRejectString()
-    {
-      return m_rejectString;
-    };
-
-    /**
-     * In the event of a BACnet Abort error, return the Abort reason code.
-     *
-     * @return The Abort reason code.
-     */
-    uint8_t getAbortReason()
-    {
-      return m_abortReason;
-    };
-
-    /**
-     * In the event of a BACnet Abort error, return the Abort string.
-     *
-     * @return The Abort error string.
-     */
-    std::string getAbortString()
-    {
-      return m_abortString;
-    };
-
-    /**
-     * In the event of a general BACnet error, return the BACnet error class.
-     *
-     * @return One of the BACNET_ERROR_CLASS error class codes
-     */
-    BACNET_ERROR_CLASS getErrorClass()
-    {
-      return m_errorClass;
-    };
-
-    /**
-     * In the event of a general BACnet error, return the BACnet error code.
-     *
-     * @return One of the BACNET_ERROR_CODE error codes
-     */
-    BACNET_ERROR_CODE getErrorCode()
-    {
-      return m_errorCode;
-    };
-
-    /**
-     * In the event of a general BACnet error, return the BACnet error
-     * string.
-     *
-     * @return A string representing the BACnet error class and code.
-     */
-    std::string getErrorString()
-    {
-      return m_errorString;
-    };
-
-    /**
-     * In the event of a non-BACnet UPM error, return a string
-     * describing the error.
-     *
-     * @return A string representing the UPM error.
-     */
-    std::string getUPMErrorString()
-    {
-      return m_upmErrorString;
-    };
-
-    /**
-     * Check to see if initMaster) has already been called, and out
-     * master is initialized.
-     *
-     * @return true if the master is initialized, false otherwise
-     */
-    bool isInitialized()
-    {
-      return m_initialized;
-    };
-
-    /**
-     * Return the port that was specified to initMaster().
-     *
-     * @return The port specified to initMaster().
-     */
-    std::string getPort()
-    {
-      return m_port;
-    };
-
-    /**
-     * Return the Object Device Instance ID for our Master was
-     * specified to initMaster().
-     *
-     * @return The Object Device Instance ID for our Master.
-     */
-    uint32_t getDeviceInstanceID()
-    {
-      return m_deviceInstanceID;
-    };
-
-    /**
-     * Return the maxInfoFrames parameter that was specified to initMaster().
-     *
-     * @return The maxInfoFrames parameter specified to initMaster().
-     */
-    int getMaxInfoFrames()
-    {
-      return m_maxInfoFrames;
-    };
-
-    /**
-     * Return the maxMaster parameter that was specified to initMaster().
-     *
-     * @return The maxMaster parameter specified to initMaster().
-     */
-    int getMaxMaster()
-    {
-      return m_maxMaster;
-    };
-
-    /**
-     * Return the baud rate parameter that was specified to initMaster().
-     *
-     * @return The baud rate parameter specified to initMaster().
-     */
-    int getBaudRate()
-    {
-      return m_baudRate;
-    };
-
-    /**
-     * Return the MAC address parameter that was specified to initMaster().
-     *
-     * @return The MAC address parameter specified to initMaster().
-     */
-    int getMACAddress()
-    {
-      return m_macAddr;
-    };
-
-    /**
-     * Enable or disable debugging output.
-     *
-     * @param enable true to enable debugging, false otherwise
-     */
-    void setDebug(bool enable);
-
-  protected:
-    /**
-     * BACNETMSTP constructor
-     */
-    BACNETMSTP();
-
-    /**
-     * BACNETMSTP Destructor
-     */
-    ~BACNETMSTP();
-
-    // clear/reset error states
-    void clearErrors();
-
-    // error handler
-    static void handlerError(BACNET_ADDRESS * src,
-                             uint8_t invoke_id,
-                             BACNET_ERROR_CLASS error_class,
-                             BACNET_ERROR_CODE error_code);
-
-    // abort handler
-    static void handlerAbort(BACNET_ADDRESS * src,
-                             uint8_t invoke_id,
-                             uint8_t abort_reason,
-                             bool server);
-
-    // reject handler
-    static void handlerReject(BACNET_ADDRESS * src,
-                              uint8_t invoke_id,
-                              uint8_t reject_reason);
-
-
-    // our handler for dealing with return data from a ReadProperty call
-    static void handlerReadPropertyAck(uint8_t* service_request,
-                                       uint16_t service_len,
-                                       BACNET_ADDRESS* src,
-                                       BACNET_CONFIRMED_SERVICE_ACK_DATA* service_data);
-
-    // our handler for writeProp acks
-    static void handlerWritePropertyAck(BACNET_ADDRESS* src,
-                                        uint8_t invoke_id);
-
-    // initialize our service handlers
-    void initServiceHandlers();
-
-    // utility function
-    std::string string2HexString(std::string input);
-
-    // responsible for dispatching a request to the BACnet network
-    bool dispatchRequest();
-
-  private:
-    // prevent copying and assignment
-    BACNETMSTP(BACNETMSTP const &) = delete;
-    BACNETMSTP& operator=(BACNETMSTP const&) = delete;
-
-    // our class instance
-    static BACNETMSTP* m_instance;
-
-    // has the class been created yet?
-    bool m_initialized;
-
-    // Some items we can set for our master
-    std::string m_port;
-    int m_maxInfoFrames;
-    int m_maxMaster;
-    int m_baudRate;
-    int m_macAddr;
-
-    // the unique Instance Number of our Master Device Object
-    uint32_t m_deviceInstanceID;
-
-    // adpu timeout in milliseconds
-    uint16_t m_adpuTimeoutMS;
-
-    // buffer used for receiving data
-    uint8_t m_rxBuffer[MAX_MPDU];
-
-    // our error classfication
-    BACERR_TYPE_T m_errorType;
-
-    // BACnet reject info
-    uint8_t m_rejectReason;
-    std::string m_rejectString;
-
-    // BACnet abort info
-    uint8_t m_abortReason;
-    std::string m_abortString;
-
-    // BACnet error info
-    BACNET_ERROR_CLASS m_errorClass;
-    BACNET_ERROR_CODE  m_errorCode;
-    std::string m_errorString;
-
-    // generic UPM related errors - we just set the error text to
-    // something informative.
-    std::string m_upmErrorString;
-
-    // our returned data from readProperty()
-    std::vector<BACNET_APPLICATION_DATA_VALUE> m_returnedValue;
-
-    // current bound target address of dispatched service request
-    // (read/write prop, etc)
-    BACNET_ADDRESS m_targetAddress;
-
-    // current invokeID (for transaction handling)
-    uint8_t m_invokeID;
-
-    // error detected flag
-    bool m_errorDetected;
-
-    // Commands - we create a struct to hold the arguments for each
-    // command type we support.  Then, we create a command struct
-    // which contains the command type and a union containing the
-    // relevant arguments.  This is used by dispatchRequest() to issue
-    // the correct request.
-
-    // these may generate SWIG warnings, but they can be ignored as we
-    // do not expose these outside the class
-    typedef struct {
-      uint32_t targetDeviceInstanceID;
-      BACNET_OBJECT_TYPE objType;
-      uint32_t objInstance;
-      BACNET_PROPERTY_ID objProperty;
-      uint32_t arrayIndex;
-    } READ_PROPERTY_ARGS_T;
-
-    typedef struct {
-      uint32_t targetDeviceInstanceID;
-      BACNET_OBJECT_TYPE objType;
-      uint32_t objInstance;
-      BACNET_PROPERTY_ID objProperty;
-      BACNET_APPLICATION_DATA_VALUE* propValue;
-      uint8_t propPriority;
-      int32_t arrayIndex;
-    } WRITE_PROPERTY_ARGS_T;
-
-    struct {
-      BACCMD_TYPE_T cmd;
-
-      union {
-        READ_PROPERTY_ARGS_T readPropArgs;
-        WRITE_PROPERTY_ARGS_T writePropArgs;
-      };
-    } m_command;
-
-    bool m_debugging;
-  };
-}
diff --git a/src/bacnetmstp/bacnetmstp.i b/src/bacnetmstp/bacnetmstp.i
deleted file mode 100644
index e05cc99..0000000
--- a/src/bacnetmstp/bacnetmstp.i
+++ /dev/null
@@ -1,16 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "../carrays_uint32_t.i"
-JAVA_JNI_LOADLIBRARY(javaupm_bacnetmstp)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%pointer_functions(float, floatp);
-%{
-#include "bacnetmstp.hpp"
-%}
-%include "bacnetmstp.hpp"
-/* END Common SWIG syntax */
diff --git a/src/bacnetmstp/bacnetutil.cxx b/src/bacnetmstp/bacnetutil.cxx
deleted file mode 100644
index beec702..0000000
--- a/src/bacnetmstp/bacnetutil.cxx
+++ /dev/null
@@ -1,927 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <assert.h>
-#include <errno.h>
-#include <iostream>
-#include <stdexcept>
-#include <string>
-
-#include "bacnetutil.hpp"
-
-using namespace upm;
-using namespace std;
-
-
-BACNETUTIL::BACNETUTIL(uint32_t targetDeviceObjectID) :
-  m_instance(0)
-{
-  // Save our device's ID
-  m_targetDeviceObjectID = targetDeviceObjectID;
-
-  // create the BACNETMSTP instance here if it does not already exist,
-  // and store the pointer in our class to save on some typing.
-
-  m_instance = BACNETMSTP::instance();
-
-  // now see if it has been initialized yet for init()
-  m_initialized = m_instance->isInitialized();
-
-  setDebug(false);
-
-  // we disable this by default for performance reasons
-  checkReliability(false);
-
-  // empty our unit caches
-  m_avUnitCache.clear();
-  m_aiUnitCache.clear();
-
-  // empty our msv info store
-  m_msvInfo.clear();
-
-  // empty our binary info stores
-  m_bvInfo.clear();
-  m_biInfo.clear();
-}
-
-BACNETUTIL::~BACNETUTIL()
-{
-}
-
-void BACNETUTIL::initMaster(string port, int baudRate,
-                            int deviceInstanceID, int macAddr, int maxMaster,
-                            int maxInfoFrames)
-{
-  // first we check to see if the bacnetmstp instance has already been
-  // initialized (determined in the ctor).  If not, we will do so here
-  // with the arguments specified.  If it has already been
-  // initialized, then we do not bother calling bacnetmstp's init
-  // again as it will just be ignored.
-
-  if (!m_initialized)
-    m_instance->initMaster(port, baudRate, deviceInstanceID,
-                           macAddr, maxMaster, maxInfoFrames);
-
-  // either it threw an exception, was already initialized or it's
-  // initialized now...
-  m_initialized = true;
-}
-
-void BACNETUTIL::setDebug(bool enable)
-{
-  m_debugging = enable;
-
-  // we also enable/disable debugging in BACNETMSTP
-  m_instance->setDebug(enable);
-}
-
-float BACNETUTIL::getAnalogValue(uint32_t objInstance)
-{
-  // check reliability first, if enabled
-  if (m_checkReliability)
-    {
-      if (m_instance->readProperty(m_targetDeviceObjectID, OBJECT_ANALOG_VALUE,
-                                   objInstance, PROP_RELIABILITY))
-        {
-          if (m_debugging)
-            cerr << __FUNCTION__ << ": (reliability): " << getAllErrorString()
-                 << endl;
-
-          throw runtime_error(string(__FUNCTION__)
-                                   + getAllErrorString());
-        }
-
-      BACNET_RELIABILITY reliable =
-        static_cast<BACNET_RELIABILITY>(m_instance->getDataTypeEnum());
-
-      if (reliable != RELIABILITY_NO_FAULT_DETECTED)
-        {
-          if (m_debugging)
-            cerr << __FUNCTION__ << ": Reliability check failed" << endl;
-
-          throw runtime_error(string(__FUNCTION__)
-                                   + ": Reliability check failed");
-        }
-    }
-
-  // now get the value
-  if (m_instance->readProperty(m_targetDeviceObjectID, OBJECT_ANALOG_VALUE,
-                               objInstance, PROP_PRESENT_VALUE))
-    {
-      if (m_debugging)
-        cerr << __FUNCTION__ << ": (value): " << getAllErrorString()
-             << endl;
-
-      throw runtime_error(string(__FUNCTION__)
-                               + ": "
-                               + getAllErrorString());
-    }
-
-  return m_instance->getDataTypeReal();
-}
-
-void BACNETUTIL::setAnalogValue(uint32_t objInstance,
-                                float value)
-{
-  // Write the value
-  BACNET_APPLICATION_DATA_VALUE myData =
-    m_instance->createDataReal(value);
-
-  // write it
-  if (m_instance->writeProperty(m_targetDeviceObjectID, OBJECT_ANALOG_VALUE,
-                                objInstance, PROP_PRESENT_VALUE,
-                                &myData))
-    {
-      // error occurred
-      if (m_debugging)
-        cerr << __FUNCTION__ << ": " << getAllErrorString() << endl;
-
-      throw runtime_error(string(__FUNCTION__)
-                               + ": "
-                               + getAllErrorString());
-    }
-}
-
-string BACNETUTIL::getAnalogValueUnits(uint32_t objInstance)
-{
-  // see if it exists
-  if (m_avUnitCache.count(objInstance) == 0)
-    {
-      // then we need to fetch it
-      if (m_instance->readProperty(m_targetDeviceObjectID, OBJECT_ANALOG_VALUE,
-                                   objInstance, PROP_UNITS))
-        {
-          if (m_debugging)
-            cerr << __FUNCTION__ << ": " << getAllErrorString() << endl;
-          // set to empty string
-          m_avUnitCache[objInstance] = string("");
-        }
-      else
-        {
-          // cache it for future calls
-          m_avUnitCache[objInstance] =
-            string(bactext_engineering_unit_name(m_instance->getDataTypeEnum()));
-        }
-    }
-
-  return m_avUnitCache[objInstance];
-}
-
-float BACNETUTIL::getAnalogInput(uint32_t objInstance)
-{
-  // check reliability first, if enabled
-  if (m_checkReliability)
-    {
-      if (m_instance->readProperty(m_targetDeviceObjectID, OBJECT_ANALOG_INPUT,
-                                   objInstance, PROP_RELIABILITY))
-        {
-          if (m_debugging)
-            cerr << __FUNCTION__ << ": (reliability): "
-                 << getAllErrorString() << endl;
-
-          throw runtime_error(string(__FUNCTION__)
-                                   + getAllErrorString());
-        }
-
-      BACNET_RELIABILITY reliable =
-        static_cast<BACNET_RELIABILITY>(m_instance->getDataTypeEnum());
-
-      if (reliable != RELIABILITY_NO_FAULT_DETECTED)
-        {
-          if (m_debugging)
-            cerr << __FUNCTION__ << ": Reliability check failed" << endl;
-
-          throw runtime_error(string(__FUNCTION__)
-                                   + ": Reliability check failed");
-        }
-    }
-
-  // now get the value
-  if (m_instance->readProperty(m_targetDeviceObjectID, OBJECT_ANALOG_INPUT,
-                               objInstance, PROP_PRESENT_VALUE))
-    {
-      if (m_debugging)
-        cerr << __FUNCTION__ << ": (value): " << getAllErrorString() << endl;
-
-      throw runtime_error(string(__FUNCTION__)
-                               + ": "
-                               + getAllErrorString());
-    }
-
-  return m_instance->getDataTypeReal();
-}
-
-bool BACNETUTIL::getBinaryInput(uint32_t objInstance)
-{
-  // check the BV info, and update/cache the data if needed
-  updateBinaryInputInfo(objInstance);
-
-  // check reliability first, if enabled
-  if (m_checkReliability)
-    {
-      if (m_instance->readProperty(m_targetDeviceObjectID, OBJECT_BINARY_INPUT,
-                                   objInstance, PROP_RELIABILITY))
-        {
-          if (m_debugging)
-            cerr << __FUNCTION__ << ": (reliability): "
-                 << getAllErrorString() << endl;
-
-          throw runtime_error(string(__FUNCTION__)
-                                   + getAllErrorString());
-        }
-
-      BACNET_RELIABILITY reliable =
-        static_cast<BACNET_RELIABILITY>(m_instance->getDataTypeEnum());
-
-      if (reliable != RELIABILITY_NO_FAULT_DETECTED)
-        {
-          if (m_debugging)
-            cerr << __FUNCTION__ << ": Reliability check failed" << endl;
-
-          throw runtime_error(string(__FUNCTION__)
-                                   + ": Reliability check failed");
-        }
-    }
-
-  // now get the value
-  if (m_instance->readProperty(m_targetDeviceObjectID, OBJECT_BINARY_INPUT,
-                               objInstance, PROP_PRESENT_VALUE))
-    {
-      if (m_debugging)
-        cerr << __FUNCTION__ << ": (value): " << getAllErrorString() << endl;
-
-      throw runtime_error(string(__FUNCTION__)
-                               + ": "
-                               + getAllErrorString());
-    }
-
-  BACNET_BINARY_PV bpv =
-    static_cast<BACNET_BINARY_PV>(m_instance->getDataTypeEnum());
-
-  return (bpv == BINARY_INACTIVE) ? false : true;
-}
-
-bool BACNETUTIL::getBinaryValue(uint32_t objInstance)
-{
-  // check the BV info, and update/cache the data if needed
-  updateBinaryValueInfo(objInstance);
-
-  // check reliability first, if enabled
-  if (m_checkReliability)
-    {
-      if (m_instance->readProperty(m_targetDeviceObjectID, OBJECT_BINARY_VALUE,
-                                   objInstance, PROP_RELIABILITY))
-        {
-          if (m_debugging)
-            cerr << __FUNCTION__ << ": (reliability): "
-                 << getAllErrorString() << endl;
-
-          throw runtime_error(string(__FUNCTION__)
-                                   + getAllErrorString());
-        }
-
-      BACNET_RELIABILITY reliable =
-        static_cast<BACNET_RELIABILITY>(m_instance->getDataTypeEnum());
-
-      if (reliable != RELIABILITY_NO_FAULT_DETECTED)
-        {
-          if (m_debugging)
-            cerr << __FUNCTION__ << ": Reliability check failed" << endl;
-
-          throw runtime_error(string(__FUNCTION__)
-                                   + ": Reliability check failed");
-        }
-    }
-
-  // now get the value
-  if (m_instance->readProperty(m_targetDeviceObjectID, OBJECT_BINARY_VALUE,
-                               objInstance, PROP_PRESENT_VALUE))
-    {
-      if (m_debugging)
-        cerr << __FUNCTION__ << ": (value): " << getAllErrorString() << endl;
-
-      throw runtime_error(string(__FUNCTION__)
-                               + ": "
-                               + getAllErrorString());
-    }
-
-  BACNET_BINARY_PV bpv =
-    static_cast<BACNET_BINARY_PV>(m_instance->getDataTypeEnum());
-
-  return (bpv == BINARY_INACTIVE) ? false : true;
-}
-
-void BACNETUTIL::setBinaryValue(uint32_t objInstance,
-                                bool value)
-{
-  BACNET_BINARY_PV bpv = (value) ? BINARY_ACTIVE : BINARY_INACTIVE;
-
-  // Write the value
-  BACNET_APPLICATION_DATA_VALUE myData =
-    m_instance->createDataEnum(bpv);
-
-  // write it
-  if (m_instance->writeProperty(m_targetDeviceObjectID, OBJECT_BINARY_VALUE,
-                                objInstance, PROP_PRESENT_VALUE,
-                                &myData))
-    {
-      // error occurred
-      if (m_debugging)
-        cerr << __FUNCTION__ << ": " << getAllErrorString() << endl;
-
-      throw runtime_error(string(__FUNCTION__)
-                               + ": "
-                               + getAllErrorString());
-    }
-}
-
-string BACNETUTIL::getAnalogInputUnits(uint32_t objInstance)
-{
-  // see if it exists
-  if (m_aiUnitCache.count(objInstance) == 0)
-    {
-      // then we need to fetch it
-      if (m_instance->readProperty(m_targetDeviceObjectID, OBJECT_ANALOG_INPUT,
-                                   objInstance, PROP_UNITS))
-        {
-          if (m_debugging)
-            cerr << __FUNCTION__ << ": " << getAllErrorString() << endl;
-          // set to empty string
-          m_aiUnitCache[objInstance] = string("");
-        }
-      else
-        {
-          // cache it for future calls
-          m_aiUnitCache[objInstance] =
-            string(bactext_engineering_unit_name(m_instance->getDataTypeEnum()));
-        }
-    }
-
-  return m_aiUnitCache[objInstance];
-}
-
-unsigned int BACNETUTIL::getMultiStateValue(uint32_t objInstance)
-{
-  // check the MSV info, and update/cache the data if needed
-  updateMultiStateValueInfo(objInstance);
-
-  // check reliability first, if enabled
-  if (m_checkReliability)
-    {
-      if (m_instance->readProperty(m_targetDeviceObjectID,
-                                   OBJECT_MULTI_STATE_VALUE,
-                                   objInstance, PROP_RELIABILITY))
-        {
-          if (m_debugging)
-            cerr << __FUNCTION__ << ": (reliability): "
-                 << getAllErrorString() << endl;
-
-          throw runtime_error(string(__FUNCTION__)
-                                   + getAllErrorString());
-        }
-
-      BACNET_RELIABILITY reliable =
-        static_cast<BACNET_RELIABILITY>(m_instance->getDataTypeEnum());
-
-      if (reliable != RELIABILITY_NO_FAULT_DETECTED)
-        {
-          if (m_debugging)
-            cerr << __FUNCTION__ << ": Reliability check failed" << endl;
-
-          throw runtime_error(string(__FUNCTION__)
-                                   + ": Reliability check failed");
-        }
-    }
-
-  // now get the value
-  if (m_instance->readProperty(m_targetDeviceObjectID,
-                               OBJECT_MULTI_STATE_VALUE,
-                               objInstance, PROP_PRESENT_VALUE))
-    {
-      if (m_debugging)
-        cerr << __FUNCTION__ << ": (value): " << getAllErrorString() << endl;
-
-      throw runtime_error(string(__FUNCTION__)
-                               + ": "
-                               + getAllErrorString());
-    }
-
-  return m_instance->getDataTypeUnsignedInt();
-}
-
-void BACNETUTIL::updateMultiStateValueInfo(uint32_t objInstance)
-{
-  // bail if we already have information on this msv
-  if (m_msvInfo.count(objInstance) != 0)
-    return;
-
-  // we need to fetch information on MSV's - number of states, and
-  // possibly the state-text, if present
-
-  // get the number of values possible (required)
-  if (m_instance->readProperty(m_targetDeviceObjectID,
-                               OBJECT_MULTI_STATE_VALUE,
-                               objInstance, PROP_NUMBER_OF_STATES))
-    {
-      if (m_debugging)
-        cerr << __FUNCTION__
-             << ": (number of states): "
-             << getAllErrorString()
-             << endl;
-
-      throw runtime_error(string(__FUNCTION__)
-                               + ": "
-                               + getAllErrorString());
-    }
-
-  // Add the entry...
-  m_msvInfo[objInstance].numStates = m_instance->getDataTypeUnsignedInt();
-
-  if (m_debugging)
-    cerr << __FUNCTION__
-         << ": number of states: "
-         << m_msvInfo[objInstance].numStates
-         << endl;
-
-  // now get the state-text.  This is optional, so we will not throw
-  // here.
-  if (m_instance->readProperty(m_targetDeviceObjectID,
-                               OBJECT_MULTI_STATE_VALUE,
-                               objInstance, PROP_STATE_TEXT))
-    {
-      if (m_debugging)
-        cerr << __FUNCTION__
-             << ": (state-text): "
-             << getAllErrorString()
-             << endl;
-    }
-
-  // store them
-  int numElements = m_instance->getDataNumElements();
-
-  if (m_debugging)
-    cerr << __FUNCTION__ << ": numElements: " << numElements << endl;
-
-  if (numElements > 0)
-    {
-      for (int i=0; i<numElements; i++)
-        {
-          m_msvInfo[objInstance].stateList.push_back(m_instance->getDataTypeString(i));
-
-          if (m_debugging)
-            cerr << __FUNCTION__ << ": " << int(objInstance) << ", "
-                 << i << ": "
-                 << "added state text string: "
-                 << m_msvInfo[objInstance].stateList.at(i)
-                 << endl;
-        }
-    }
-
-  return;
-}
-
-void BACNETUTIL::deleteMultiStateValueInfo(uint32_t objInstance)
-{
-  // if there is no data stored for this objInstance yet, then we do
-  // not need to do anything.
-  if (m_msvInfo.count(objInstance) == 0)
-    return;
-
-  // Now, we just erase the entry, and it will be updated the next
-  // time the MSV is accessed.
-  m_msvInfo.erase(objInstance);
-
-  return;
-}
-
-string BACNETUTIL::lookupMultiStateValueText(uint32_t objInstance,
-                                             unsigned int value)
-{
-  // verify that we have the relevant object data cached. If not, go
-  // get it.
-  updateMultiStateValueInfo(objInstance);
-
-  // verify that value is valid for this object
-  if (value == 0 || value > m_msvInfo[objInstance].numStates)
-    throw out_of_range(string(__FUNCTION__)
-                            + ": value supplied is invalid. Maximum "
-                            + "allowed values are 1 to "
-                            + to_string(m_msvInfo[objInstance].numStates)
-                            + " for this object");
-
-
-  // at this point either it failed or suceeded.  If it suceeded, then
-  // we will see if any state text was retrieved.  If no text is
-  // available (it is an optional property), then we will simply
-  // return the value itself as a string.
-
-  if (m_msvInfo[objInstance].stateList.size() > 0)
-    {
-      // we have state-text and a usable value.
-
-      // value should never be 0 at this point, so compensate for
-      // indexing into stateList which is 0-based.
-      value--;
-
-      return m_msvInfo[objInstance].stateList.at(value);
-    }
-
-  // no stateList text available, so just return value as a string
-  return to_string(value);
-}
-
-unsigned int BACNETUTIL::getMultiStateValueMaxStates(uint32_t objInstance)
-{
-  // check the MSV info, and update/cache the data if needed
-  updateMultiStateValueInfo(objInstance);
-
-  return m_msvInfo[objInstance].numStates;
-}
-
-string BACNETUTIL::getMultiStateValueText(uint32_t objInstance)
-{
-  unsigned int value = getMultiStateValue(objInstance);
-
-  return lookupMultiStateValueText(objInstance, value);
-}
-
-void BACNETUTIL::setMultiStateValue(uint32_t objInstance,
-                                    unsigned int value)
-{
-  // check the MSV info, and update/cache the data if needed
-  updateMultiStateValueInfo(objInstance);
-
-  // Check value against the valid limits
-
-  if (value == 0 || value > m_msvInfo[objInstance].numStates)
-    throw invalid_argument(string(__FUNCTION__)
-                                + ": value supplied is invalid. Maximum "
-                                + "allowed values are 1 to "
-                                + to_string(m_msvInfo[objInstance].numStates)
-                                + " for this object");
-
-  // Write the value
-  BACNET_APPLICATION_DATA_VALUE myData =
-    m_instance->createDataUnsignedInt(value);
-
-  // write it
-  if (m_instance->writeProperty(m_targetDeviceObjectID,
-                                OBJECT_MULTI_STATE_VALUE,
-                                objInstance, PROP_PRESENT_VALUE,
-                                &myData))
-    {
-      // error occurred
-      if (m_debugging)
-        cerr << __FUNCTION__ << ": " << getAllErrorString() << endl;
-
-      throw runtime_error(string(__FUNCTION__)
-                               + ": "
-                               + getAllErrorString());
-    }
-}
-
-void BACNETUTIL::updateBinaryValueInfo(uint32_t objInstance)
-{
-  // bail if we already have information on this object
-  if (m_bvInfo.count(objInstance) != 0)
-    return;
-
-  // fetch inactive/active text.  These are optional accordingto the
-  // spec, so we will not throw if they do not exist.
-
-  // get inactive text
-  if (m_instance->readProperty(m_targetDeviceObjectID,
-                               OBJECT_BINARY_VALUE,
-                               objInstance, PROP_INACTIVE_TEXT))
-    {
-      if (m_debugging)
-        cerr << __FUNCTION__
-             << ": (inactive text): "
-             << getAllErrorString()
-             << endl;
-
-      m_bvInfo[objInstance].inactiveText = "inactive";
-    }
-  else
-    {
-      m_bvInfo[objInstance].inactiveText = m_instance->getDataTypeString();
-    }
-
-  // get active text
-  if (m_instance->readProperty(m_targetDeviceObjectID,
-                               OBJECT_BINARY_VALUE,
-                               objInstance, PROP_ACTIVE_TEXT))
-    {
-      if (m_debugging)
-        cerr << __FUNCTION__
-             << ": (active text): "
-             << getAllErrorString()
-             << endl;
-
-      m_bvInfo[objInstance].activeText = "active";
-    }
-  else
-    {
-      m_bvInfo[objInstance].activeText = m_instance->getDataTypeString();
-    }
-
-  return;
-}
-
-void BACNETUTIL::deleteBinaryValueInfo(uint32_t objInstance)
-{
-  // if there is no data stored for this objInstance yet, then we do
-  // not need to do anything.
-  if (m_bvInfo.count(objInstance) == 0)
-    return;
-
-  // Now, we just erase the entry, and it will be updated the next
-  // time it is accessed.
-  m_bvInfo.erase(objInstance);
-
-  return;
-}
-
-void BACNETUTIL::updateBinaryInputInfo(uint32_t objInstance)
-{
-  // bail if we already have information on this object
-  if (m_biInfo.count(objInstance) != 0)
-    return;
-
-  // fetch inactive/active text.  These are optional accordingto the
-  // spec, so we will not throw if they do not exist.
-
-  // get inactive text
-  if (m_instance->readProperty(m_targetDeviceObjectID,
-                               OBJECT_BINARY_INPUT,
-                               objInstance, PROP_INACTIVE_TEXT))
-    {
-      if (m_debugging)
-        cerr << __FUNCTION__
-             << ": (inactive text): "
-             << getAllErrorString()
-             << endl;
-
-      m_biInfo[objInstance].inactiveText = "inactive";
-    }
-  else
-    {
-      m_biInfo[objInstance].inactiveText = m_instance->getDataTypeString();
-    }
-
-  // get active text
-  if (m_instance->readProperty(m_targetDeviceObjectID,
-                               OBJECT_BINARY_INPUT,
-                               objInstance, PROP_ACTIVE_TEXT))
-    {
-      if (m_debugging)
-        cerr << __FUNCTION__
-             << ": (active text): "
-             << getAllErrorString()
-             << endl;
-
-      m_biInfo[objInstance].activeText = "active";
-    }
-  else
-    {
-      m_biInfo[objInstance].activeText = m_instance->getDataTypeString();
-    }
-
-  return;
-}
-
-void BACNETUTIL::deleteBinaryInputInfo(uint32_t objInstance)
-{
-  // if there is no data stored for this objInstance yet, then we do
-  // not need to do anything.
-  if (m_biInfo.count(objInstance) == 0)
-    return;
-
-  // Now, we just erase the entry, and it will be updated the next
-  // time it is accessed.
-  m_biInfo.erase(objInstance);
-
-  return;
-}
-
-string BACNETUTIL::lookupBinaryInputText(uint32_t objInstance, bool value)
-{
-  // cache relevant data if necessary
-  updateBinaryInputInfo(objInstance);
-
- if (value)
-    return m_biInfo[objInstance].activeText;
-  else
-    return m_biInfo[objInstance].inactiveText;
-}
-
-string BACNETUTIL::getBinaryInputText(uint32_t objInstance)
-{
-  bool value = getBinaryInput(objInstance);
-
-  return lookupBinaryInputText(objInstance, value);
-}
-
-string BACNETUTIL::lookupBinaryValueText(uint32_t objInstance, bool value)
-{
-  // cache relevant data if necessary
-  updateBinaryValueInfo(objInstance);
-
- if (value)
-    return m_bvInfo[objInstance].activeText;
-  else
-    return m_bvInfo[objInstance].inactiveText;
-}
-
-string BACNETUTIL::getBinaryValueText(uint32_t objInstance)
-{
-  bool value = getBinaryValue(objInstance);
-
-  return lookupBinaryValueText(objInstance, value);
-}
-
-BACNETMSTP::BACERR_TYPE_T BACNETUTIL::getErrorType()
-{
-  return m_instance->getErrorType();
-}
-
-uint8_t BACNETUTIL::getRejectReason()
-{
-  return m_instance->getRejectReason();
-}
-
-string BACNETUTIL::getRejectString()
-{
-  return m_instance->getRejectString();
-}
-
-uint8_t BACNETUTIL::getAbortReason()
-{
-  return m_instance->getAbortReason();
-}
-
-string BACNETUTIL::getAbortString()
-{
-  return m_instance->getAbortString();
-}
-
-BACNET_ERROR_CLASS BACNETUTIL::getErrorClass()
-{
-  return m_instance->getErrorClass();
-}
-
-BACNET_ERROR_CODE BACNETUTIL::getErrorCode()
-{
-  return m_instance->getErrorCode();
-}
-
-string BACNETUTIL::getUPMErrorString()
-{
-  return m_instance->getUPMErrorString();
-}
-
-string BACNETUTIL::getErrorString()
-{
-  return m_instance->getErrorString();
-};
-
-string BACNETUTIL::getAllErrorString()
-{
-  switch (m_instance->getErrorType())
-    {
-    case BACNETMSTP::BACERR_TYPE_NONE:
-      return string("No Error");
-      break;
-
-    case BACNETMSTP::BACERR_TYPE_REJECT:
-      return string("Reject: ") + getRejectString();
-      break;
-
-    case BACNETMSTP::BACERR_TYPE_ABORT:
-      return string("Abort: ") + getAbortString();
-      break;
-
-    case BACNETMSTP::BACERR_TYPE_ERROR:
-      return string("Error: ") + getErrorString();
-      break;
-
-    case BACNETMSTP::BACERR_TYPE_UPM:
-      return string("UPM Error: ") + getUPMErrorString();
-      break;
-    }
-
-  return string("Internal Error: Unknown ErrorType");
-}
-
-string BACNETUTIL::getDeviceDescription()
-{
-  if (m_instance->readProperty(m_targetDeviceObjectID, OBJECT_DEVICE,
-                               m_targetDeviceObjectID, PROP_DESCRIPTION))
-    {
-      // error occurred
-      if (m_debugging)
-        cerr << __FUNCTION__ << ": " << getAllErrorString() << endl;
-
-      return "";
-    }
-
-  return m_instance->getDataTypeString();
-}
-
-string BACNETUTIL::getDeviceLocation()
-{
-  if (m_instance->readProperty(m_targetDeviceObjectID, OBJECT_DEVICE,
-                               m_targetDeviceObjectID, PROP_LOCATION))
-    {
-      // error occurred
-      if (m_debugging)
-        cerr << __FUNCTION__ << ": " << getAllErrorString() << endl;
-
-      return "";
-    }
-
-  return m_instance->getDataTypeString();
-}
-
-bool BACNETUTIL::setDeviceLocation(string location)
-{
-  BACNET_APPLICATION_DATA_VALUE myLocation =
-    m_instance->createDataString(location);
-
-  // write the Device Object Location
-  if (m_instance->writeProperty(m_targetDeviceObjectID, OBJECT_DEVICE,
-                                m_targetDeviceObjectID, PROP_LOCATION,
-                                &myLocation))
-    {
-      // error occurred
-      if (m_debugging)
-        cerr << __FUNCTION__ << ": " << getAllErrorString() << endl;
-
-      return false;
-    }
-
-  return true;
-}
-
-string BACNETUTIL::getDeviceName()
-{
-  if (m_instance->readProperty(m_targetDeviceObjectID, OBJECT_DEVICE,
-                               m_targetDeviceObjectID, PROP_OBJECT_NAME))
-    {
-      // error occurred
-      if (m_debugging)
-        cerr << __FUNCTION__ << ": " << getAllErrorString() << endl;
-
-      return "";
-    }
-
-  return m_instance->getDataTypeString();
-}
-
-bool BACNETUTIL::setDeviceName(string name)
-{
-  if (name.size() < 1)
-    {
-      throw invalid_argument(string(__FUNCTION__)
-                                  + ": name must have at least one character");
-    }
-
-  BACNET_APPLICATION_DATA_VALUE myName =
-    m_instance->createDataString(name);
-
-  // write the Device Object Location
-  if (m_instance->writeProperty(m_targetDeviceObjectID, OBJECT_DEVICE,
-                                m_targetDeviceObjectID, PROP_OBJECT_NAME,
-                                &myName))
-    {
-      // error occurred
-      if (m_debugging)
-        cerr << __FUNCTION__ << ": " << getAllErrorString() << endl;
-
-      return false;
-    }
-
-  return true;
-}
diff --git a/src/bacnetmstp/bacnetutil.hpp b/src/bacnetmstp/bacnetutil.hpp
deleted file mode 100644
index 3c40526..0000000
--- a/src/bacnetmstp/bacnetutil.hpp
+++ /dev/null
@@ -1,559 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <map>
-#include <vector>
-
-#include "bacnetmstp.hpp"
-
-namespace upm {
-
-  /**
-   * @library bacnetmstp
-   * @comname Utility API for BACnet
-   * @con uart
-   *
-   * @brief UPM Utility API for BACnet
-   *
-   * This class implements some common access functions that are
-   * useful to any driver making use of the bacnetmstp driver.
-   *
-   * It provides some basic functionality for reading and writing a
-   * proprty (with and without relability checking) as well as access
-   * to error conditions.  It is intended to be inherited by your
-   * driver class.
-   */
-
-  class BACNETUTIL {
-  public:
-
-    /**
-     * BACNETUTIL constructor
-     *
-     */
-    BACNETUTIL(uint32_t targetDeviceObjectID);
-
-    /**
-     * BACNETUTIL Destructor
-     */
-    virtual ~BACNETUTIL();
-
-    /**
-     * This function initializes the underlying BACNETMSTP Master
-     * singleton in the event it has not already been initialized.  If
-     * the BACNETMSTP Master singleton has already been initialized,
-     * then this call will be ignored.
-     *
-     * @param port The serial port that the RS-485 interface is
-     * connected to.
-     * @param baudRate The baudrate of the RS-485 interface.  All
-     * devices on a BACnet RS-485 bus must run at the same baudrate.
-     * Valid values are 9600, 19200, 38400, 57600, 76800, and 115200.
-     * @param deviceInstanceNumber This is the unique Device Object
-     * Instance number that will be used for our BACnet Master in
-     * order to communicate over the BACnet interface.  This number
-     * must be between 1-4194302 and must be unique on the BACnet
-     * network.
-     * @param macAddr This is the MAC address of our BACnet Master.
-     * It must be unique on the BACnet segment, and must be between
-     * 1-127.
-     * @param maxMaster This specifies to our Master the maximum MAC
-     * address used by any other Masters on the BACnet network.  This
-     * must be between 1-127, the default is 127.  Do not change this
-     * unless you know what you are doing or you could introduce
-     * token passing errors on the BACnet network.
-     * @param maxInfoFrames This number specifies the maximum number
-     * of transmissions (like requests for data) our Master is allowed
-     * to make before passing the token to the next Master.  The
-     * default is 1.
-     */
-    virtual void initMaster(std::string port, int baudRate,
-                            int deviceInstanceNumber,
-                            int macAddr, int maxMaster=DEFAULT_MAX_MASTER,
-                            int maxInfoFrames=1);
-
-    /**
-     * Enable some debugging output in this module as well as the
-     * BACNETMSTP module.  Debugging is disabled by default.
-     *
-     * @param enable true to enable, false to disable.
-     */
-    virtual void setDebug(bool enable);
-
-    /**
-     * Retrieve the Present_Value property of an Analog Value object.
-     * If checkReliability() has been enabled, then the Reliability
-     * property of the object will be retrieved first.  If the
-     * Reliability property is anything other than
-     * RELIABILITY_NO_FAULT_DETECTED, then the method will throw.
-     * Reliability checking is disabled by default for performance
-     * reasons.
-     *
-     * @param objInstance The Analog Value Object instance.
-     * @return The floating point value requested.
-     */
-    virtual float getAnalogValue(uint32_t objInstance);
-
-    /**
-     * Set the Present_Value property of an Analog Value object.  This
-     * method will throw on an error.
-     *
-     * @param objInstance The Analog Value Object instance.
-     * @param value The data value to write.
-     */
-    virtual void setAnalogValue(uint32_t objInstance,
-                                float value);
-
-    /**
-     * Retrieve the Present_Value property of an Analog Input object.
-     * If checkReliability() has been enabled, then the Reliability
-     * property of the object will be retrieved first.  If the
-     * Reliability property is anything other than
-     * RELIABILITY_NO_FAULT_DETECTED, then the method will throw.
-     * Reliability checking is disabled by default for performance
-     * reasons.
-     *
-     * @param objInstance The Analog Input Object instance.
-     * @return the floating point value requested.
-     */
-    virtual float getAnalogInput(uint32_t objInstance);
-
-    /**
-     * Query an Analog Value object for the unit code, translate it
-     * into a string and cache the result for future use.  Return the
-     * BACnet text for the Unit enumeration.  Unit enumerations are
-     * things like 'kilowatt-hours', 'volts', etc.  For Objects which
-     * do not have a Units property defined for them, or for which
-     * Units has no meaning, 'no-units' will typically be returned and
-     * cached for the object.
-     *
-     * @param objInstance The Analog Value Object instance.
-     * @return A string representing the Object's Unit property.
-     */
-    virtual std::string getAnalogValueUnits(uint32_t objInstance);
-
-    /**
-     * Query an Analog Input object for the unit code, translate it
-     * into a string and cache the result for future use.  Return the
-     * BACnet text for the Unit enumeration.  Unit enumerations are
-     * things like 'kilowatt-hours', 'volts', etc.  For Objects which
-     * do not have a Units property defined for them, or for which
-     * Units has no meaning, 'no-units' will typically be returned and
-     * cached for the object.
-     *
-     * @param objInstance The Analog Input Object instance.
-     * @return A string representing the Object's Unit property.
-     */
-    virtual std::string getAnalogInputUnits(uint32_t objInstance);
-
-    /**
-     * Retrieve the Present_Value property of a Binary Input object.
-     * If checkReliability() has been enabled, then the Reliability
-     * property of the object will be retrieved first.  If the
-     * Reliability property is anything other than
-     * RELIABILITY_NO_FAULT_DETECTED, then the method will throw.
-     * Reliability checking is disabled by default for performance
-     * reasons.
-     *
-     * @param objInstance The Object Instance number to query
-     * @return the boolean point value requested
-     */
-    virtual bool getBinaryInput(uint32_t objInstance);
-
-    /**
-     * Lookup (retrieve if necessary) the Inactive_Text and
-     * Active_Text properties of a Binary Input object.  These text
-     * properties are optional and can provide a string representing a
-     * given state (true/false) that can be more informational than
-     * just the boolean value the object represents.  This is useful
-     * in applications that display this data to a user for example.
-     * If this text is not present in the object (as it is not
-     * required), then a string representation of the value will be
-     * returned instead ("active" and "inactive").
-     *
-     * @param objInstance The Object Instance number of the object
-     * @param value The value you want to lookup the text
-     * representation for.
-     * @return The string representing the value.
-     */
-    virtual std::string lookupBinaryInputText(uint32_t objInstance, bool value);
-
-    /**
-     * Return a string representation of the Present_Value property of
-     * a BinaryInput object.  This method just calls getBinaryInput()
-     * on the object, uses lookupBinaryInputText() to lookup the
-     * corresponding text value, and returns the result.
-     *
-     * @param objInstance The Object Instance number of the object.
-     * @return The string representing the value.
-     */
-    virtual std::string getBinaryInputText(uint32_t objInstance);
-
-    /**
-     * Retrieve the Present_Value property of a Binary Value object.
-     * If checkReliability() has been enabled, then the Reliability
-     * property of the object will be retrieved first.  If the
-     * Reliability property is anything other than
-     * RELIABILITY_NO_FAULT_DETECTED, then the method will throw.
-     * Reliability checking is disabled by default for performance
-     * reasons.
-     *
-     * @param objInstance The Object Instance number to query
-     * @return the boolean point value requested
-     */
-    virtual bool getBinaryValue(uint32_t objInstance);
-
-    /**
-     * Set the Present_Value property of a Binary Value object.  This
-     * method will throw on an error.
-     *
-     * @param objInstance The Analog Value Object instance.
-     * @param value The data value to write
-     */
-    virtual void setBinaryValue(uint32_t objInstance,
-                                bool value);
-
-    /**
-     * Lookup (retrieve if necessary) the Inactive_Text and
-     * Active_Text properties of a Binary Value object.  These text
-     * properties are optional and can provide a string representing a
-     * given state (true/false) that can be more informational than
-     * just the boolean value the object represents.  This is useful
-     * in applications that display this data to a user for example.
-     * If this text is not present in the object (as it is not
-     * required), then a string representation of the value will be
-     * returned instead ("active" and "inactive").
-     *
-     * @param objInstance The Object Instance number of the object.
-     * @param value The value you want to lookup the text
-     * representation for.
-     * @return The string representing the value.
-     */
-    virtual std::string lookupBinaryValueText(uint32_t objInstance, bool value);
-
-    /**
-     * Return a string representation of the Present_Value property of
-     * a Binary Value object.  This method just calls getBinaryValue()
-     * on the object, uses lookupBinaryValueText() to lookup the
-     * corresponding text value, and returns the result.
-     *
-     * @param objInstance The Object Instance number of the object.
-     * @return The string representing the value.
-     */
-    virtual std::string getBinaryValueText(uint32_t objInstance);
-
-    /**
-     * Retrieve the Present_Value property of a Multi State Value
-     * object.  If checkReliability() has been enabled, then the
-     * Reliability property of the object will be retrieved first.  If
-     * the Reliability property is anything other than
-     * RELIABILITY_NO_FAULT_DETECTED, then the method will throw.
-     * Reliability checking is disabled by default for performance
-     * reasons.
-     *
-     * @param objInstance The Object Instance number to query.
-     * @return The Present_Value property of the object.
-     */
-    virtual unsigned int getMultiStateValue(uint32_t objInstance);
-
-    /**
-     * Lookup (retrieve if necessary) the State_Text strings
-     * corresponding to the supplied value of a MultiStateValue
-     * object.  State_Text is an optional property that can provide
-     * strings representing a given state that can be more
-     * informational than just the unsigned integer the object
-     * represents.  This is useful in applications that display this
-     * data to a user for example.  If this text is not present in the
-     * object (as it is not required), then a string representation of
-     * the integer value will be returned instead.
-     *
-     * @param objInstance The Object Instance number of the object.
-     * @param value The value you want to lookup the text
-     * representation for.
-     * @return The string representing the value.
-     */
-    virtual std::string lookupMultiStateValueText(uint32_t objInstance,
-                                                  unsigned int value);
-
-    /**
-     * Return a string representation of the Present_Value property of
-     * a MultiStateValue object.  This method just calls
-     * getMultiStateValue() on the object, uses
-     * lookupMultiStateValueText() to lookup the corresponding
-     * State_Text value, and returns the result.
-     *
-     * @param objInstance The Object Instance number of the object.
-     * @return The string representing the value.
-     */
-    virtual std::string getMultiStateValueText(uint32_t objInstance);
-
-    /**
-     * Return the maximum legal value of a Multi State Value Object.
-     * The value represents the highest value the Present_Value
-     * porperty of the object will allow.
-     *
-     * @param objInstance The Object Instance number of the object.
-     * @return The highest Present_Value the object supports.
-     */
-    virtual unsigned int getMultiStateValueMaxStates(uint32_t objInstance);
-
-    /**
-     * Set the Present_Value property of a Multi State Value object.
-     * The value provided must not be 0, and must not exceed the
-     * object's Number_Of_States property. Use
-     * getMultiStateValueMaxStates() to determine the maximum value
-     * the object supports. This method will throw on an error.
-     *
-     * @param objInstance The MultiStateValue Object instance.
-     * @param value The data value to write.
-     */
-    virtual void setMultiStateValue(uint32_t objInstance,
-                                    unsigned int value);
-
-    /**
-     * Enable or disable reliability checking.  When retrieving data,
-     * the Present_Value property is returned.  There is also an
-     * optional property called Reliability that can be checked to
-     * ensure that the Present_Value property is currently valid.
-     *
-     * Enabling Reliability Checking has the data retrieval functions
-     * check for a RELIABILITY_NO_FAULT_DETECTED value for the
-     * Reliability property before querying the Present_Value
-     * property.  If anything other than RELIABILITY_NO_FAULT_DETECTED
-     * is set, then the method will throw.
-     *
-     * This checking is disabled by default since it will double the
-     * number of queries needed to retrieve a given value.  In
-     * addition, since it is an optional property, calling it for an
-     * object that does not support it will also throw.  However, if
-     * you need to ensure that the values returned are always
-     * completely valid as determined by the device firmware, and the
-     * objects you are querying support the reliability property, you
-     * can enable this.
-     *
-     * @param enable true to check Reliability before returning a
-     * value, false otherwise.
-     */
-    virtual void checkReliability(bool enable)
-    {
-      m_checkReliability = enable;
-    };
-
-    /**
-     * Query the Device Object of the device and return it's
-     * Description property.  This typically contains information like
-     * the Vendor, model and serial number of a device.
-     *
-     * @return A string containing the Device Object's Description property.
-     */
-    virtual std::string getDeviceDescription();
-
-    /**
-     * Query the Device Object of the device and return it's Location
-     * property.  This typically contains a string indication of a
-     * customer specific value.  Use setLocation() to change.
-     *
-     * @return A string containing the Device Object's Location property.
-     */
-    virtual std::string getDeviceLocation();
-
-    /**
-     * Set the Device Object's Location property.  This must be a
-     * string containing no more than 63 characters.  Not all devices
-     * allow setting the location.
-     *
-     * @param location The new location to set, if supported.
-     * @return true if the operation succeeded, otherwise false.
-     */
-    virtual bool setDeviceLocation(std::string location);
-
-    /**
-     * Query the Device Object of the device and return it's Name
-     * property.  This should contain a unique string value.  Use
-     * setName() to change.  Note, according to the spec, the Device
-     * Object Name must be unique within a given BACnet network.
-     *
-     * @return A string containing the Object's Name property.
-     */
-    virtual std::string getDeviceName();
-
-    /**
-     * Set the Device Object's Name property.  This must be a string
-     * containing at least one character and no more than 63
-     * characters.  Note, according to the spec, the Device Object
-     * Name must be unique within a given BACnet network.
-     *
-     * @param name The name to set.
-     * @return true if the operation succeeded, false otherwise
-     */
-    virtual bool setDeviceName(std::string name);
-
-    /**
-     * This is a utility function that will return a string reporting
-     * on the various types of errors that can occur in BACnet
-     * operation.
-     *
-     * @return A string containing the last error message.
-     */
-    virtual std::string getAllErrorString();
-
-    /**
-     * Return an enumration of the last error type to occur.  The
-     * value returned will be one of the BACNETMSTP::BACERR_TYPE_T
-     * values.
-     *
-     * @return The last error type to occur, one of the
-     * BACNETMSTP::BACERR_TYPE_T values.
-     */
-    virtual BACNETMSTP::BACERR_TYPE_T getErrorType();
-
-    /**
-     * In the event of a BACnet Reject error, return the error code.
-     *
-     * @return The Reject error code.
-     */
-    virtual uint8_t getRejectReason();
-
-    /**
-     * In the event of a BACnet Reject error, return the error string.
-     *
-     * @return The Reject error string.
-     */
-    virtual std::string getRejectString();
-
-    /**
-     * In the event of a BACnet Abort error, return the Abort reason code.
-     *
-     * @return The Abort reason code.
-     */
-    virtual uint8_t getAbortReason();
-
-    /**
-     * In the event of a BACnet Abort error, return the Abort string.
-     *
-     * @return The Abort error string.
-     */
-    virtual std::string getAbortString();
-
-    /**
-     * In the event of a general BACnet error, return the BACnet error class.
-     *
-     * @return One of the BACNET_ERROR_CLASS error class codes
-     */
-    virtual BACNET_ERROR_CLASS getErrorClass();
-
-    /**
-     * In the event of a general BACnet error, return the BACnet error code.
-     *
-     * @return One of the BACNET_ERROR_CODE error codes
-     */
-    virtual BACNET_ERROR_CODE getErrorCode();
-
-    /**
-     * In the event of a general BACnet error, return the BACnet error
-     * string.
-     *
-     * @return A string representing the BACnet error class and code.
-     */
-    virtual std::string getErrorString();
-
-    /**
-     * In the event of a non-BACnet UPM error, return a string
-     * describing the error.
-     *
-     * @return A string representing the UPM error.
-     */
-    virtual std::string getUPMErrorString();
-
-  protected:
-    // update our stored info for an MSV
-    virtual void updateMultiStateValueInfo(uint32_t objInstance);
-    // delete our stored info for an MSV
-    virtual void deleteMultiStateValueInfo(uint32_t objInstance);
-
-    // update our stored info for a BV
-    virtual void updateBinaryValueInfo(uint32_t objInstance);
-    // delete our stored info for a BV
-    virtual void deleteBinaryValueInfo(uint32_t objInstance);
-
-    // update our stored info for a BI
-    virtual void updateBinaryInputInfo(uint32_t objInstance);
-    // delete our stored info for a BI
-    virtual void deleteBinaryInputInfo(uint32_t objInstance);
-
-    // also enable mstp debugging in BACNETMSTP
-    bool m_debugging;
-
-    // whether or not to verify reliability before reading a value.
-    bool m_checkReliability;
-
-    // our target Device Object ID
-    uint32_t m_targetDeviceObjectID;
-
-    // a copy of the BACNETMSTP singleton instance pointer
-    BACNETMSTP* m_instance;
-
-    // are we initialized?
-    bool m_initialized;
-
-    // storage for Binary Input and Binary Value Data.  This will
-    // generate SWIG warnings which can be ignored as we do not expose
-    // this struct outside the class.
-    typedef struct {
-      std::string inactiveText;
-      std::string activeText;
-    } binaryData_t;
-
-    typedef std::map<uint32_t, binaryData_t> binaryInfo_t;
-
-    // storage for binary input/value information
-    binaryInfo_t m_bvInfo;
-    binaryInfo_t m_biInfo;
-
-    // storage for multi-state data.  This will generate SWIG
-    // warnings which can be ignored as we do not expose this struct
-    // outside the class.
-    typedef struct {
-      unsigned int numStates;
-      std::vector<std::string>stateList;
-    } multiStateData_t;
-
-    // our information storage for MSV's
-    typedef std::map<uint32_t, multiStateData_t> multiStateInfo_t;
-
-    multiStateInfo_t m_msvInfo;
-
-    // Unit cache for AV
-    typedef std::map<uint32_t, std::string> avCacheMap_t;
-    avCacheMap_t m_avUnitCache;
-
-    // Unit cache for AI
-    typedef std::map<uint32_t, std::string> aiCacheMap_t;
-    aiCacheMap_t m_aiUnitCache;
-
-  private:
-  };
-}
diff --git a/src/bacnetmstp/device-client.c b/src/bacnetmstp/device-client.c
deleted file mode 100644
index 3671f4e..0000000
--- a/src/bacnetmstp/device-client.c
+++ /dev/null
@@ -1,1028 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/**************************************************************************
-*
-* Copyright (C) 2011 Steve Karg <skarg@users.sourceforge.net>
-*
-* Permission is hereby granted, free of charge, to any person obtaining
-* a copy of this software and associated documentation files (the
-* "Software"), to deal in the Software without restriction, including
-* without limitation the rights to use, copy, modify, merge, publish,
-* distribute, sublicense, and/or sell copies of the Software, and to
-* permit persons to whom the Software is furnished to do so, subject to
-* the following conditions:
-*
-* The above copyright notice and this permission notice shall be included
-* in all copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*
-*********************************************************************/
-
-/** @file device-client.c Lightweight base "class" for handling all
- * BACnet objects belonging to a BACnet device, as well as
- * Device-specific properties.  This Device instance is designed to
- * meet minimal functionality for simple clients. */
-
-#include <stdbool.h>
-#include <stdint.h>
-#include <string.h>     /* for memmove */
-// __USE_XOPEN needed for timezone
-#define __USE_XOPEN
-#include <time.h>       /* for timezone, localtime */
-
-#define BACDL_MSTP 1
-#undef BACDL_ALL
-
-
-/* OS specific include*/
-//#include "net.h"
-#include "timer.h"
-/* BACnet includes */
-#include "bacdef.h"
-#include "bacdcode.h"
-#include "bacenum.h"
-#include "bacapp.h"
-#include "config.h"     /* the custom stuff */
-#include "apdu.h"
-#include "rp.h" /* ReadProperty handling */
-#include "version.h"
-#include "handlers.h"
-#include "datalink.h"
-#include "address.h"
-/* include the device object */
-#include "device.h"     /* me */
-
-#if defined(__BORLANDC__) || defined(_WIN32)
-/* seems to not be defined in time.h as specified by The Open Group */
-/* difference from UTC and local standard time  */
-long int timezone;
-#endif
-
-/* note: you really only need to define variables for
-   properties that are writable or that may change.
-   The properties that are constant can be hard coded
-   into the read-property encoding. */
-
-static uint32_t Object_Instance_Number = 260001;
-static BACNET_CHARACTER_STRING My_Object_Name;
-static BACNET_DEVICE_STATUS System_Status = STATUS_OPERATIONAL;
-static char *Vendor_Name = BACNET_VENDOR_NAME;
-static uint16_t Vendor_Identifier = BACNET_VENDOR_ID;
-static char *Model_Name = "UPM Bacnet-o-matic MS/TP";
-static char *Application_Software_Version = "1.0";
-static char *Location = "Unknown";
-static char *Description = "UPM BACNET MS/TP driver";
-/* static uint8_t Protocol_Version = 1; - constant, not settable */
-/* static uint8_t Protocol_Revision = 4; - constant, not settable */
-/* Protocol_Services_Supported - dynamically generated */
-/* Protocol_Object_Types_Supported - in RP encoding */
-/* Object_List - dynamically generated */
-/* static BACNET_SEGMENTATION Segmentation_Supported = SEGMENTATION_NONE; */
-/* static uint8_t Max_Segments_Accepted = 0; */
-/* VT_Classes_Supported */
-/* Active_VT_Sessions */
-static BACNET_TIME Local_Time;  /* rely on OS, if there is one */
-static BACNET_DATE Local_Date;  /* rely on OS, if there is one */
-/* NOTE: BACnet UTC Offset is inverse of common practice.
-   If your UTC offset is -5hours of GMT,
-   then BACnet UTC offset is +5hours.
-   BACnet UTC offset is expressed in minutes. */
-static int32_t UTC_Offset = 5 * 60;
-static bool Daylight_Savings_Status = false;    /* rely on OS */
-/* List_Of_Session_Keys */
-/* Time_Synchronization_Recipients */
-/* Max_Master - rely on MS/TP subsystem, if there is one */
-/* Max_Info_Frames - rely on MS/TP subsystem, if there is one */
-/* Device_Address_Binding - required, but relies on binding cache */
-static uint32_t Database_Revision = 0;
-/* Configuration_Files */
-/* Last_Restore_Time */
-/* Backup_Failure_Timeout */
-/* Active_COV_Subscriptions */
-/* Slave_Proxy_Enable */
-/* Manual_Slave_Address_Binding */
-/* Auto_Slave_Discovery */
-/* Slave_Address_Binding */
-/* Profile_Name */
-
-/* local forward (semi-private) and external prototypes */
-int Device_Read_Property_Local(
-    BACNET_READ_PROPERTY_DATA * rpdata);
-extern int Routed_Device_Read_Property_Local(
-    BACNET_READ_PROPERTY_DATA * rpdata);
-extern bool Routed_Device_Write_Property_Local(
-    BACNET_WRITE_PROPERTY_DATA * wp_data);
-
-/* All included BACnet objects */
-static object_functions_t Object_Table[] = {
-    {OBJECT_DEVICE,
-            NULL /* Init - don't init Device or it will recourse! */ ,
-            Device_Count,
-            Device_Index_To_Instance,
-            Device_Valid_Object_Instance_Number,
-            Device_Object_Name,
-            Device_Read_Property_Local,
-            NULL /* Write_Property */ ,
-            NULL /* Property_Lists */ ,
-            NULL /* ReadRangeInfo */ ,
-            NULL /* Iterator */ ,
-            NULL /* Value_Lists */ ,
-            NULL /* COV */ ,
-            NULL /* COV Clear */ ,
-        NULL /* Intrinsic Reporting */ },
-    {MAX_BACNET_OBJECT_TYPE,
-            NULL /* Init */ ,
-            NULL /* Count */ ,
-            NULL /* Index_To_Instance */ ,
-            NULL /* Valid_Instance */ ,
-            NULL /* Object_Name */ ,
-            NULL /* Read_Property */ ,
-            NULL /* Write_Property */ ,
-            NULL /* Property_Lists */ ,
-            NULL /* ReadRangeInfo */ ,
-            NULL /* Iterator */ ,
-            NULL /* Value_Lists */ ,
-            NULL /* COV */ ,
-            NULL /* COV Clear */ ,
-        NULL /* Intrinsic Reporting */ }
-};
-
-/** Glue function to let the Device object, when called by a handler,
- * lookup which Object type needs to be invoked.
- * @ingroup ObjHelpers
- * @param Object_Type [in] The type of BACnet Object the handler wants to access.
- * @return Pointer to the group of object helper functions that implement this
- *         type of Object.
- */
-static struct object_functions *Device_Objects_Find_Functions(
-    BACNET_OBJECT_TYPE Object_Type)
-{
-    struct object_functions *pObject = NULL;
-
-    pObject = &Object_Table[0];
-    while (pObject->Object_Type < MAX_BACNET_OBJECT_TYPE) {
-        /* handle each object type */
-        if (pObject->Object_Type == Object_Type) {
-            return (pObject);
-        }
-
-        pObject++;
-    }
-
-    return (NULL);
-}
-
-unsigned Device_Count(
-    void)
-{
-    return 1;
-}
-
-uint32_t Device_Index_To_Instance(
-    unsigned index)
-{
-    //index = index;
-    return Object_Instance_Number;
-}
-
-/* methods to manipulate the data */
-
-/** Return the Object Instance number for our (single) Device Object.
- * This is a key function, widely invoked by the handler code, since
- * it provides "our" (ie, local) address.
- * @ingroup ObjIntf
- * @return The Instance number used in the BACNET_OBJECT_ID for the Device.
- */
-uint32_t Device_Object_Instance_Number(
-    void)
-{
-#ifdef BAC_ROUTING
-    return Routed_Device_Object_Instance_Number();
-#else
-    return Object_Instance_Number;
-#endif
-}
-
-bool Device_Set_Object_Instance_Number(
-    uint32_t object_id)
-{
-    bool status = true; /* return value */
-
-    if (object_id <= BACNET_MAX_INSTANCE) {
-        /* Make the change and update the database revision */
-        Object_Instance_Number = object_id;
-        Device_Inc_Database_Revision();
-    } else
-        status = false;
-
-    return status;
-}
-
-bool Device_Valid_Object_Instance_Number(
-    uint32_t object_id)
-{
-    return (Object_Instance_Number == object_id);
-}
-
-bool Device_Object_Name(
-    uint32_t object_instance,
-    BACNET_CHARACTER_STRING * object_name)
-{
-    bool status = false;
-
-    if (object_instance == Object_Instance_Number) {
-        status = characterstring_copy(object_name, &My_Object_Name);
-    }
-
-    return status;
-}
-
-bool Device_Set_Object_Name(
-    BACNET_CHARACTER_STRING * object_name)
-{
-    bool status = false;        /*return value */
-
-    if (!characterstring_same(&My_Object_Name, object_name)) {
-        /* Make the change and update the database revision */
-        status = characterstring_copy(&My_Object_Name, object_name);
-        Device_Inc_Database_Revision();
-    }
-
-    return status;
-}
-
-BACNET_DEVICE_STATUS Device_System_Status(
-    void)
-{
-    return System_Status;
-}
-
-int Device_Set_System_Status(
-    BACNET_DEVICE_STATUS status,
-    bool local)
-{
-    int result = 0;     /*return value - 0 = ok, -1 = bad value, -2 = not allowed */
-
-    /* We limit the options available depending on whether the source is
-     * internal or external. */
-    if (local) {
-        switch (status) {
-            case STATUS_OPERATIONAL:
-            case STATUS_OPERATIONAL_READ_ONLY:
-            case STATUS_DOWNLOAD_REQUIRED:
-            case STATUS_DOWNLOAD_IN_PROGRESS:
-            case STATUS_NON_OPERATIONAL:
-                System_Status = status;
-                break;
-
-                /* Don't support backup at present so don't allow setting */
-            case STATUS_BACKUP_IN_PROGRESS:
-                result = -2;
-                break;
-
-            default:
-                result = -1;
-                break;
-        }
-    } else {
-        switch (status) {
-                /* Allow these for the moment as a way to easily alter
-                 * overall device operation. The lack of password protection
-                 * or other authentication makes allowing writes to this
-                 * property a risky facility to provide.
-                 */
-            case STATUS_OPERATIONAL:
-            case STATUS_OPERATIONAL_READ_ONLY:
-            case STATUS_NON_OPERATIONAL:
-                System_Status = status;
-                break;
-
-                /* Don't allow outsider set this - it should probably
-                 * be set if the device config is incomplete or
-                 * corrupted or perhaps after some sort of operator
-                 * wipe operation.
-                 */
-            case STATUS_DOWNLOAD_REQUIRED:
-                /* Don't allow outsider set this - it should be set
-                 * internally at the start of a multi packet download
-                 * perhaps indirectly via PT or WF to a config file.
-                 */
-            case STATUS_DOWNLOAD_IN_PROGRESS:
-                /* Don't support backup at present so don't allow setting */
-            case STATUS_BACKUP_IN_PROGRESS:
-                result = -2;
-                break;
-
-            default:
-                result = -1;
-                break;
-        }
-    }
-
-    return (result);
-}
-
-const char *Device_Vendor_Name(
-    void)
-{
-    return Vendor_Name;
-}
-
-/** Returns the Vendor ID for this Device.
- * See the assignments at http://www.bacnet.org/VendorID/BACnet%20Vendor%20IDs.htm
- * @return The Vendor ID of this Device.
- */
-uint16_t Device_Vendor_Identifier(
-    void)
-{
-    return Vendor_Identifier;
-}
-
-void Device_Set_Vendor_Identifier(
-    uint16_t vendor_id)
-{
-    Vendor_Identifier = vendor_id;
-}
-
-const char *Device_Model_Name(
-    void)
-{
-    return Model_Name;
-}
-
-bool Device_Set_Model_Name(
-    const char *name,
-    size_t length)
-{
-    bool status = false;        /*return value */
-
-    if (length < sizeof(Model_Name)) {
-        memmove(Model_Name, name, length);
-        Model_Name[length] = 0;
-        status = true;
-    }
-
-    return status;
-}
-
-const char *Device_Firmware_Revision(
-    void)
-{
-    return BACnet_Version;
-}
-
-const char *Device_Application_Software_Version(
-    void)
-{
-    return Application_Software_Version;
-}
-
-bool Device_Set_Application_Software_Version(
-    const char *name,
-    size_t length)
-{
-    bool status = false;        /*return value */
-
-    if (length < sizeof(Application_Software_Version)) {
-        memmove(Application_Software_Version, name, length);
-        Application_Software_Version[length] = 0;
-        status = true;
-    }
-
-    return status;
-}
-
-const char *Device_Description(
-    void)
-{
-    return Description;
-}
-
-bool Device_Set_Description(
-    const char *name,
-    size_t length)
-{
-    bool status = false;        /*return value */
-
-    if (length < sizeof(Description)) {
-        memmove(Description, name, length);
-        Description[length] = 0;
-        status = true;
-    }
-
-    return status;
-}
-
-const char *Device_Location(
-    void)
-{
-    return Location;
-}
-
-bool Device_Set_Location(
-    const char *name,
-    size_t length)
-{
-    bool status = false;        /*return value */
-
-    if (length < sizeof(Location)) {
-        memmove(Location, name, length);
-        Location[length] = 0;
-        status = true;
-    }
-
-    return status;
-}
-
-uint8_t Device_Protocol_Version(
-    void)
-{
-    return BACNET_PROTOCOL_VERSION;
-}
-
-uint8_t Device_Protocol_Revision(
-    void)
-{
-    return BACNET_PROTOCOL_REVISION;
-}
-
-BACNET_SEGMENTATION Device_Segmentation_Supported(
-    void)
-{
-    return SEGMENTATION_NONE;
-}
-
-uint32_t Device_Database_Revision(
-    void)
-{
-    return Database_Revision;
-}
-
-void Device_Set_Database_Revision(
-    uint32_t revision)
-{
-    Database_Revision = revision;
-}
-
-/*
- * Shortcut for incrementing database revision as this is potentially
- * the most common operation if changing object names and ids is
- * implemented.
- */
-void Device_Inc_Database_Revision(
-    void)
-{
-    Database_Revision++;
-}
-
-/** Get the total count of objects supported by this Device Object.
- * @note Since many network clients depend on the object list
- *       for discovery, it must be consistent!
- * @return The count of objects, for all supported Object types.
- */
-unsigned Device_Object_List_Count(
-    void)
-{
-    unsigned count = 0; /* number of objects */
-    struct object_functions *pObject = NULL;
-
-    /* initialize the default return values */
-    pObject = &Object_Table[0];
-    while (pObject->Object_Type < MAX_BACNET_OBJECT_TYPE) {
-        if (pObject->Object_Count) {
-            count += pObject->Object_Count();
-        }
-        pObject++;
-    }
-
-    return count;
-}
-
-/** Lookup the Object at the given array index in the Device's Object List.
- * Even though we don't keep a single linear array of objects in the Device,
- * this method acts as though we do and works through a virtual, concatenated
- * array of all of our object type arrays.
- *
- * @param array_index [in] The desired array index (1 to N)
- * @param object_type [out] The object's type, if found.
- * @param instance [out] The object's instance number, if found.
- * @return True if found, else false.
- */
-bool Device_Object_List_Identifier(
-    unsigned array_index,
-    int *object_type,
-    uint32_t * instance)
-{
-    bool status = false;
-    unsigned count = 0;
-    unsigned object_index = 0;
-    unsigned temp_index = 0;
-    struct object_functions *pObject = NULL;
-
-    /* array index zero is length - so invalid */
-    if (array_index == 0) {
-        return status;
-    }
-    object_index = array_index - 1;
-    /* initialize the default return values */
-    pObject = &Object_Table[0];
-    while (pObject->Object_Type < MAX_BACNET_OBJECT_TYPE) {
-        if (pObject->Object_Count) {
-            object_index -= count;
-            count = pObject->Object_Count();
-            if (object_index < count) {
-                /* Use the iterator function if available otherwise
-                 * look for the index to instance to get the ID */
-                if (pObject->Object_Iterator) {
-                    /* First find the first object */
-                    temp_index = pObject->Object_Iterator(~(unsigned) 0);
-                    /* Then step through the objects to find the nth */
-                    while (object_index != 0) {
-                        temp_index = pObject->Object_Iterator(temp_index);
-                        object_index--;
-                    }
-                    /* set the object_index up before falling through to next bit */
-                    object_index = temp_index;
-                }
-                if (pObject->Object_Index_To_Instance) {
-                    *object_type = pObject->Object_Type;
-                    *instance =
-                        pObject->Object_Index_To_Instance(object_index);
-                    status = true;
-                    break;
-                }
-            }
-        }
-        pObject++;
-    }
-
-    return status;
-}
-
-/** Determine if we have an object with the given object_name.
- * If the object_type and object_instance pointers are not null,
- * and the lookup succeeds, they will be given the resulting values.
- * @param object_name [in] The desired Object Name to look for.
- * @param object_type [out] The BACNET_OBJECT_TYPE of the matching Object.
- * @param object_instance [out] The object instance number of the matching Object.
- * @return True on success or else False if not found.
- */
-bool Device_Valid_Object_Name(
-    BACNET_CHARACTER_STRING * object_name1,
-    int *object_type,
-    uint32_t * object_instance)
-{
-    bool found = false;
-    int type = 0;
-    uint32_t instance;
-    unsigned max_objects = 0, i = 0;
-    bool check_id = false;
-    BACNET_CHARACTER_STRING object_name2;
-    struct object_functions *pObject = NULL;
-
-    max_objects = Device_Object_List_Count();
-    for (i = 1; i <= max_objects; i++) {
-        check_id = Device_Object_List_Identifier(i, &type, &instance);
-        if (check_id) {
-            pObject = Device_Objects_Find_Functions(type);
-            if ((pObject != NULL) && (pObject->Object_Name != NULL) &&
-                (pObject->Object_Name(instance, &object_name2) &&
-                    characterstring_same(object_name1, &object_name2))) {
-                found = true;
-                if (object_type) {
-                    *object_type = type;
-                }
-                if (object_instance) {
-                    *object_instance = instance;
-                }
-                break;
-            }
-        }
-    }
-
-    return found;
-}
-
-/** Determine if we have an object of this type and instance number.
- * @param object_type [in] The desired BACNET_OBJECT_TYPE
- * @param object_instance [in] The object instance number to be looked up.
- * @return True if found, else False if no such Object in this device.
- */
-bool Device_Valid_Object_Id(
-    int object_type,
-    uint32_t object_instance)
-{
-    bool status = false;        /* return value */
-    struct object_functions *pObject = NULL;
-
-    pObject = Device_Objects_Find_Functions(object_type);
-    if ((pObject != NULL) && (pObject->Object_Valid_Instance != NULL)) {
-        status = pObject->Object_Valid_Instance(object_instance);
-    }
-
-    return status;
-}
-
-/** Copy a child object's object_name value, given its ID.
- * @param object_type [in] The BACNET_OBJECT_TYPE of the child Object.
- * @param object_instance [in] The object instance number of the child Object.
- * @param object_name [out] The Object Name found for this child Object.
- * @return True on success or else False if not found.
- */
-bool Device_Object_Name_Copy(
-    BACNET_OBJECT_TYPE object_type,
-    uint32_t object_instance,
-    BACNET_CHARACTER_STRING * object_name)
-{
-    struct object_functions *pObject = NULL;
-    bool found = false;
-
-    pObject = Device_Objects_Find_Functions(object_type);
-    if ((pObject != NULL) && (pObject->Object_Name != NULL)) {
-        found = pObject->Object_Name(object_instance, object_name);
-    }
-
-    return found;
-}
-
-static void Update_Current_Time(
-    void)
-{
-    struct tm *tblock = NULL;
-#if defined(_MSC_VER)
-    time_t tTemp;
-#else
-    struct timeval tv;
-#endif
-/*
-struct tm
-
-int    tm_sec   Seconds [0,60].
-int    tm_min   Minutes [0,59].
-int    tm_hour  Hour [0,23].
-int    tm_mday  Day of month [1,31].
-int    tm_mon   Month of year [0,11].
-int    tm_year  Years since 1900.
-int    tm_wday  Day of week [0,6] (Sunday =0).
-int    tm_yday  Day of year [0,365].
-int    tm_isdst Daylight Savings flag.
-*/
-#if defined(_MSC_VER)
-    time(&tTemp);
-    tblock = (struct tm *)localtime(&tTemp);
-#else
-    if (gettimeofday(&tv, NULL) == 0) {
-        tblock = (struct tm *)localtime((const time_t *)&tv.tv_sec);
-    }
-#endif
-
-    if (tblock) {
-        datetime_set_date(&Local_Date, (uint16_t) tblock->tm_year + 1900,
-            (uint8_t) tblock->tm_mon + 1, (uint8_t) tblock->tm_mday);
-#if !defined(_MSC_VER)
-        datetime_set_time(&Local_Time, (uint8_t) tblock->tm_hour,
-            (uint8_t) tblock->tm_min, (uint8_t) tblock->tm_sec,
-            (uint8_t) (tv.tv_usec / 10000));
-#else
-        datetime_set_time(&Local_Time, (uint8_t) tblock->tm_hour,
-            (uint8_t) tblock->tm_min, (uint8_t) tblock->tm_sec, 0);
-#endif
-        if (tblock->tm_isdst) {
-            Daylight_Savings_Status = true;
-        } else {
-            Daylight_Savings_Status = false;
-        }
-        /* note: timezone is declared in <time.h> stdlib. */
-        UTC_Offset = timezone / 60;
-    } else {
-        datetime_date_wildcard_set(&Local_Date);
-        datetime_time_wildcard_set(&Local_Time);
-        Daylight_Savings_Status = false;
-    }
-}
-
-void Device_getCurrentDateTime(
-    BACNET_DATE_TIME * DateTime)
-{
-    Update_Current_Time();
-
-    DateTime->date = Local_Date;
-    DateTime->time = Local_Time;
-}
-
-int32_t Device_UTC_Offset(void)
-{
-    Update_Current_Time();
-
-    return UTC_Offset;
-}
-
-bool Device_Daylight_Savings_Status(void)
-{
-    return Daylight_Savings_Status;
-}
-
-/* return the length of the apdu encoded or BACNET_STATUS_ERROR for error or
-   BACNET_STATUS_ABORT for abort message */
-int Device_Read_Property_Local(
-    BACNET_READ_PROPERTY_DATA * rpdata)
-{
-    int apdu_len = 0;   /* return value */
-    int len = 0;        /* apdu len intermediate value */
-    BACNET_BIT_STRING bit_string;
-    BACNET_CHARACTER_STRING char_string;
-    unsigned i = 0;
-    int object_type = 0;
-    uint32_t instance = 0;
-    unsigned count = 0;
-    uint8_t *apdu = NULL;
-    struct object_functions *pObject = NULL;
-    bool found = false;
-
-    if ((rpdata == NULL) || (rpdata->application_data == NULL) ||
-        (rpdata->application_data_len == 0)) {
-        return 0;
-    }
-    apdu = rpdata->application_data;
-    switch (rpdata->object_property) {
-        case PROP_OBJECT_IDENTIFIER:
-            apdu_len =
-                encode_application_object_id(&apdu[0], OBJECT_DEVICE,
-                Object_Instance_Number);
-            break;
-        case PROP_OBJECT_NAME:
-            apdu_len =
-                encode_application_character_string(&apdu[0], &My_Object_Name);
-            break;
-        case PROP_OBJECT_TYPE:
-            apdu_len = encode_application_enumerated(&apdu[0], OBJECT_DEVICE);
-            break;
-        case PROP_DESCRIPTION:
-            characterstring_init_ansi(&char_string, Description);
-            apdu_len =
-                encode_application_character_string(&apdu[0], &char_string);
-            break;
-        case PROP_SYSTEM_STATUS:
-            apdu_len = encode_application_enumerated(&apdu[0], System_Status);
-            break;
-        case PROP_VENDOR_NAME:
-            characterstring_init_ansi(&char_string, Vendor_Name);
-            apdu_len =
-                encode_application_character_string(&apdu[0], &char_string);
-            break;
-        case PROP_VENDOR_IDENTIFIER:
-            apdu_len =
-                encode_application_unsigned(&apdu[0], Vendor_Identifier);
-            break;
-        case PROP_MODEL_NAME:
-            characterstring_init_ansi(&char_string, Model_Name);
-            apdu_len =
-                encode_application_character_string(&apdu[0], &char_string);
-            break;
-        case PROP_FIRMWARE_REVISION:
-            characterstring_init_ansi(&char_string, BACnet_Version);
-            apdu_len =
-                encode_application_character_string(&apdu[0], &char_string);
-            break;
-        case PROP_APPLICATION_SOFTWARE_VERSION:
-            characterstring_init_ansi(&char_string,
-                Application_Software_Version);
-            apdu_len =
-                encode_application_character_string(&apdu[0], &char_string);
-            break;
-        case PROP_LOCATION:
-            characterstring_init_ansi(&char_string, Location);
-            apdu_len =
-                encode_application_character_string(&apdu[0], &char_string);
-            break;
-        case PROP_PROTOCOL_VERSION:
-            apdu_len =
-                encode_application_unsigned(&apdu[0],
-                Device_Protocol_Version());
-            break;
-        case PROP_PROTOCOL_REVISION:
-            apdu_len =
-                encode_application_unsigned(&apdu[0],
-                Device_Protocol_Revision());
-            break;
-        case PROP_PROTOCOL_SERVICES_SUPPORTED:
-            /* Note: list of services that are executed, not initiated. */
-            bitstring_init(&bit_string);
-            for (i = 0; i < MAX_BACNET_SERVICES_SUPPORTED; i++) {
-                /* automatic lookup based on handlers set */
-                bitstring_set_bit(&bit_string, (uint8_t) i,
-                    apdu_service_supported((BACNET_SERVICES_SUPPORTED) i));
-            }
-            apdu_len = encode_application_bitstring(&apdu[0], &bit_string);
-            break;
-        case PROP_PROTOCOL_OBJECT_TYPES_SUPPORTED:
-            /* Note: this is the list of objects that can be in this device,
-               not a list of objects that this device can access */
-            bitstring_init(&bit_string);
-            for (i = 0; i < MAX_ASHRAE_OBJECT_TYPE; i++) {
-                /* initialize all the object types to not-supported */
-                bitstring_set_bit(&bit_string, (uint8_t) i, false);
-            }
-            /* set the object types with objects to supported */
-
-            pObject = &Object_Table[0];
-            while (pObject->Object_Type < MAX_BACNET_OBJECT_TYPE) {
-                if ((pObject->Object_Count) && (pObject->Object_Count() > 0)) {
-                    bitstring_set_bit(&bit_string, pObject->Object_Type, true);
-                }
-                pObject++;
-            }
-            apdu_len = encode_application_bitstring(&apdu[0], &bit_string);
-            break;
-        case PROP_OBJECT_LIST:
-            count = Device_Object_List_Count();
-            /* Array element zero is the number of objects in the list */
-            if (rpdata->array_index == 0)
-                apdu_len = encode_application_unsigned(&apdu[0], count);
-            /* if no index was specified, then try to encode the entire list */
-            /* into one packet.  Note that more than likely you will have */
-            /* to return an error if the number of encoded objects exceeds */
-            /* your maximum APDU size. */
-            else if (rpdata->array_index == BACNET_ARRAY_ALL) {
-                for (i = 1; i <= count; i++) {
-                    found =
-                        Device_Object_List_Identifier(i, &object_type,
-                        &instance);
-                    if (found) {
-                        len =
-                            encode_application_object_id(&apdu[apdu_len],
-                            object_type, instance);
-                        apdu_len += len;
-                        /* assume next one is the same size as this one */
-                        /* can we all fit into the APDU? Don't check for last entry */
-                        if ((i != count) && (apdu_len + len) >= MAX_APDU) {
-                            /* Abort response */
-                            rpdata->error_code =
-                                ERROR_CODE_ABORT_SEGMENTATION_NOT_SUPPORTED;
-                            apdu_len = BACNET_STATUS_ABORT;
-                            break;
-                        }
-                    } else {
-                        /* error: internal error? */
-                        rpdata->error_class = ERROR_CLASS_SERVICES;
-                        rpdata->error_code = ERROR_CODE_OTHER;
-                        apdu_len = BACNET_STATUS_ERROR;
-                        break;
-                    }
-                }
-            } else {
-                found =
-                    Device_Object_List_Identifier(rpdata->array_index,
-                    &object_type, &instance);
-                if (found) {
-                    apdu_len =
-                        encode_application_object_id(&apdu[0], object_type,
-                        instance);
-                } else {
-                    rpdata->error_class = ERROR_CLASS_PROPERTY;
-                    rpdata->error_code = ERROR_CODE_INVALID_ARRAY_INDEX;
-                    apdu_len = BACNET_STATUS_ERROR;
-                }
-            }
-            break;
-        case PROP_MAX_APDU_LENGTH_ACCEPTED:
-            apdu_len = encode_application_unsigned(&apdu[0], MAX_APDU);
-            break;
-        case PROP_SEGMENTATION_SUPPORTED:
-            apdu_len =
-                encode_application_enumerated(&apdu[0],
-                Device_Segmentation_Supported());
-            break;
-        case PROP_APDU_TIMEOUT:
-            apdu_len = encode_application_unsigned(&apdu[0], apdu_timeout());
-            break;
-        case PROP_NUMBER_OF_APDU_RETRIES:
-            apdu_len = encode_application_unsigned(&apdu[0], apdu_retries());
-            break;
-        case PROP_DEVICE_ADDRESS_BINDING:
-            /* FIXME: the real max apdu remaining should be passed into function */
-            apdu_len = address_list_encode(&apdu[0], MAX_APDU);
-            break;
-        case PROP_DATABASE_REVISION:
-            apdu_len =
-                encode_application_unsigned(&apdu[0], Database_Revision);
-            break;
-#if defined(BACDL_MSTP)
-        case PROP_MAX_INFO_FRAMES:
-            apdu_len =
-                encode_application_unsigned(&apdu[0],
-                dlmstp_max_info_frames());
-            break;
-        case PROP_MAX_MASTER:
-            apdu_len =
-                encode_application_unsigned(&apdu[0], dlmstp_max_master());
-            break;
-#endif
-        case PROP_ACTIVE_COV_SUBSCRIPTIONS:
-            break;
-        default:
-            rpdata->error_class = ERROR_CLASS_PROPERTY;
-            rpdata->error_code = ERROR_CODE_UNKNOWN_PROPERTY;
-            apdu_len = BACNET_STATUS_ERROR;
-            break;
-    }
-    /*  only array properties can have array options */
-    if ((apdu_len >= 0) && (rpdata->object_property != PROP_OBJECT_LIST) &&
-        (rpdata->array_index != BACNET_ARRAY_ALL)) {
-        rpdata->error_class = ERROR_CLASS_PROPERTY;
-        rpdata->error_code = ERROR_CODE_PROPERTY_IS_NOT_AN_ARRAY;
-        apdu_len = BACNET_STATUS_ERROR;
-    }
-
-    return apdu_len;
-}
-
-/** Looks up the requested Object and Property, and encodes its Value in an APDU.
- * @ingroup ObjIntf
- * If the Object or Property can't be found, sets the error class and code.
- *
- * @param rpdata [in,out] Structure with the desired Object and Property info
- *                 on entry, and APDU message on return.
- * @return The length of the APDU on success, else BACNET_STATUS_ERROR
- */
-int Device_Read_Property(
-    BACNET_READ_PROPERTY_DATA * rpdata)
-{
-    int apdu_len = BACNET_STATUS_ERROR;
-    struct object_functions *pObject = NULL;
-
-    /* initialize the default return values */
-    rpdata->error_class = ERROR_CLASS_OBJECT;
-    rpdata->error_code = ERROR_CODE_UNKNOWN_OBJECT;
-    pObject = Device_Objects_Find_Functions(rpdata->object_type);
-    if (pObject != NULL) {
-        if (pObject->Object_Valid_Instance &&
-            pObject->Object_Valid_Instance(rpdata->object_instance)) {
-            if (pObject->Object_Read_Property) {
-                apdu_len = pObject->Object_Read_Property(rpdata);
-            }
-        } else {
-            rpdata->error_class = ERROR_CLASS_OBJECT;
-            rpdata->error_code = ERROR_CODE_UNKNOWN_OBJECT;
-        }
-    } else {
-        rpdata->error_class = ERROR_CLASS_OBJECT;
-        rpdata->error_code = ERROR_CODE_UNKNOWN_OBJECT;
-    }
-
-    return apdu_len;
-}
-
-/** Initialize the Device Object.
- Initialize the group of object helper functions for any supported Object.
- Initialize each of the Device Object child Object instances.
- * @ingroup ObjIntf
- * @param object_table [in,out] array of structure with object functions.
- *  Each Child Object must provide some implementation of each of these
- *  functions in order to properly support the default handlers.
- */
-void Device_Init(
-    object_functions_t * object_table)
-{
-    struct object_functions *pObject = NULL;
-
-    characterstring_init_ansi(&My_Object_Name, "SimpleClient");
-    /* we don't use the object table passed in */
-    (void) object_table;
-    pObject = &Object_Table[0];
-    while (pObject->Object_Type < MAX_BACNET_OBJECT_TYPE) {
-        if (pObject->Object_Init) {
-            pObject->Object_Init();
-        }
-        pObject++;
-    }
-}
diff --git a/src/bacnetmstp/device.h b/src/bacnetmstp/device.h
deleted file mode 100644
index 0c7f1ac..0000000
--- a/src/bacnetmstp/device.h
+++ /dev/null
@@ -1,466 +0,0 @@
-/**************************************************************************
-*
-* Copyright (C) 2005 Steve Karg <skarg@users.sourceforge.net>
-*
-* Permission is hereby granted, free of charge, to any person obtaining
-* a copy of this software and associated documentation files (the
-* "Software"), to deal in the Software without restriction, including
-* without limitation the rights to use, copy, modify, merge, publish,
-* distribute, sublicense, and/or sell copies of the Software, and to
-* permit persons to whom the Software is furnished to do so, subject to
-* the following conditions:
-*
-* The above copyright notice and this permission notice shall be included
-* in all copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*
-*********************************************************************/
-
-/** @file device.h Defines functions for handling all BACnet objects belonging
- *                 to a BACnet device, as well as Device-specific properties. */
-
-#ifndef DEVICE_H
-#define DEVICE_H
-
-#include <stdbool.h>
-#include <stdint.h>
-#include "bacdef.h"
-#include "bacenum.h"
-#include "wp.h"
-#include "rd.h"
-#include "rp.h"
-#include "rpm.h"
-#include "readrange.h"
-
-/** Called so a BACnet object can perform any necessary initialization.
- * @ingroup ObjHelpers
- */
-typedef void (
-    *object_init_function) (
-    void);
-
-/** Counts the number of objects of this type.
- * @ingroup ObjHelpers
- * @return Count of implemented objects of this type.
- */
-typedef unsigned (
-    *object_count_function) (
-    void);
-
-/** Maps an object index position to its corresponding BACnet object instance number.
- * @ingroup ObjHelpers
- * @param index [in] The index of the object, in the array of objects of its type.
- * @return The BACnet object instance number to be used in a BACNET_OBJECT_ID.
- */
-typedef uint32_t(
-    *object_index_to_instance_function)
-        (
-    unsigned index);
-
-/** Provides the BACnet Object_Name for a given object instance of this type.
- * @ingroup ObjHelpers
- * @param object_instance [in] The object instance number to be looked up.
- * @param object_name [in,out] Pointer to a character_string structure that
- *         will hold a copy of the object name if this is a valid object_instance.
- * @return True if the object_instance is valid and object_name has been
- *         filled with a copy of the Object's name.
- */
-typedef bool(
-    *object_name_function)
-        (
-    uint32_t object_instance,
-    BACNET_CHARACTER_STRING * object_name);
-
-/** Look in the table of objects of this type, and see if this is a valid
- *  instance number.
- * @ingroup ObjHelpers
- * @param [in] The object instance number to be looked up.
- * @return True if the object instance refers to a valid object of this type.
- */
-typedef bool(
-    *object_valid_instance_function) (
-    uint32_t object_instance);
-
-/** Helper function to step through an array of objects and find either the
- * first one or the next one of a given type. Used to step through an array
- * of objects which is not necessarily contiguious for each type i.e. the
- * index for the 'n'th object of a given type is not necessarily 'n'.
- * @ingroup ObjHelpers
- * @param [in] The index of the current object or a value of ~0 to indicate
- * start at the beginning.
- * @return The index of the next object of the required type or ~0 (all bits
- * == 1) to indicate no more objects found.
- */
-typedef unsigned (
-    *object_iterate_function) (
-    unsigned current_index);
-
-/** Look in the table of objects of this type, and get the COV Value List.
- * @ingroup ObjHelpers
- * @param [in] The object instance number to be looked up.
- * @param [out] The value list
- * @return True if the object instance supports this feature, and has changed.
- */
-typedef bool(
-    *object_value_list_function) (
-    uint32_t object_instance,
-    BACNET_PROPERTY_VALUE * value_list);
-
-/** Look in the table of objects for this instance to see if value changed.
- * @ingroup ObjHelpers
- * @param [in] The object instance number to be looked up.
- * @return True if the object instance has changed.
- */
-typedef bool(
-    *object_cov_function) (
-    uint32_t object_instance);
-
-/** Look in the table of objects for this instance to clear the changed flag.
- * @ingroup ObjHelpers
- * @param [in] The object instance number to be looked up.
- */
-typedef void (
-    *object_cov_clear_function) (
-    uint32_t object_instance);
-
-/** Intrinsic Reporting funcionality.
- * @ingroup ObjHelpers
- * @param [in] Object instance.
- */
-typedef void (
-    *object_intrinsic_reporting_function) (
-    uint32_t object_instance);
-
-
-/** Defines the group of object helper functions for any supported Object.
- * @ingroup ObjHelpers
- * Each Object must provide some implementation of each of these helpers
- * in order to properly support the handlers.  Eg, the ReadProperty handler
- * handler_read_property() relies on the instance of Object_Read_Property
- * for each Object type, or configure the function as NULL.
- * In both appearance and operation, this group of functions acts like
- * they are member functions of a C++ Object base class.
- */
-typedef struct object_functions {
-    BACNET_OBJECT_TYPE Object_Type;
-    object_init_function Object_Init;
-    object_count_function Object_Count;
-    object_index_to_instance_function Object_Index_To_Instance;
-    object_valid_instance_function Object_Valid_Instance;
-    object_name_function Object_Name;
-    read_property_function Object_Read_Property;
-    write_property_function Object_Write_Property;
-    rpm_property_lists_function Object_RPM_List;
-    rr_info_function Object_RR_Info;
-    object_iterate_function Object_Iterator;
-    object_value_list_function Object_Value_List;
-    object_cov_function Object_COV;
-    object_cov_clear_function Object_COV_Clear;
-    object_intrinsic_reporting_function Object_Intrinsic_Reporting;
-} object_functions_t;
-
-/* String Lengths - excluding any nul terminator */
-#define MAX_DEV_NAME_LEN 32
-#define MAX_DEV_LOC_LEN  64
-#define MAX_DEV_MOD_LEN  32
-#define MAX_DEV_VER_LEN  16
-#define MAX_DEV_DESC_LEN 64
-
-/** Structure to define the Object Properties common to all Objects. */
-typedef struct commonBacObj_s {
-
-    /** The BACnet type of this object (ie, what class is this object from?).
-     * This property, of type BACnetObjectType, indicates membership in a
-     * particular object type class. Each inherited class will be of one type.
-     */
-    BACNET_OBJECT_TYPE mObject_Type;
-
-    /** The instance number for this class instance. */
-    uint32_t Object_Instance_Number;
-
-    /** Object Name; must be unique.
-     * This property, of type CharacterString, shall represent a name for
-     * the object that is unique within the BACnet Device that maintains it.
-     */
-    char Object_Name[MAX_DEV_NAME_LEN];
-
-} COMMON_BAC_OBJECT;
-
-
-/** Structure to define the Properties of Device Objects which distinguish
- *  one instance from another.
- *  This structure only defines fields for properties that are unique to
- *  a given Device object.  The rest may be fixed in device.c or hard-coded
- *  into the read-property encoding.
- *  This may be useful for implementations which manage multiple Devices,
- *  eg, a Gateway.
- */
-typedef struct devObj_s {
-    /** The BACnet Device Address for this device; ->len depends on DLL type. */
-    BACNET_ADDRESS bacDevAddr;
-
-    /** Structure for the Object Properties common to all Objects. */
-    COMMON_BAC_OBJECT bacObj;
-
-    /** Device Description. */
-    char Description[MAX_DEV_DESC_LEN];
-
-    /** The upcounter that shows if the Device ID or object structure has changed. */
-    uint32_t Database_Revision;
-} DEVICE_OBJECT_DATA;
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-    void Device_Init(
-        object_functions_t * object_table);
-
-    bool Device_Reinitialize(
-        BACNET_REINITIALIZE_DEVICE_DATA * rd_data);
-
-    BACNET_REINITIALIZED_STATE Device_Reinitialized_State(
-        void);
-
-    rr_info_function Device_Objects_RR_Info(
-        BACNET_OBJECT_TYPE object_type);
-
-    void Device_getCurrentDateTime(
-        BACNET_DATE_TIME * DateTime);
-    int32_t Device_UTC_Offset(void);
-    bool Device_Daylight_Savings_Status(void);
-
-    void Device_Property_Lists(
-        const int **pRequired,
-        const int **pOptional,
-        const int **pProprietary);
-    void Device_Objects_Property_List(
-        BACNET_OBJECT_TYPE object_type,
-        struct special_property_list_t *pPropertyList);
-    /* functions to support COV */
-    bool Device_Encode_Value_List(
-        BACNET_OBJECT_TYPE object_type,
-        uint32_t object_instance,
-        BACNET_PROPERTY_VALUE * value_list);
-    bool Device_Value_List_Supported(
-        BACNET_OBJECT_TYPE object_type);
-    bool Device_COV(
-        BACNET_OBJECT_TYPE object_type,
-        uint32_t object_instance);
-    void Device_COV_Clear(
-        BACNET_OBJECT_TYPE object_type,
-        uint32_t object_instance);
-
-    uint32_t Device_Object_Instance_Number(
-        void);
-    bool Device_Set_Object_Instance_Number(
-        uint32_t object_id);
-    bool Device_Valid_Object_Instance_Number(
-        uint32_t object_id);
-    unsigned Device_Object_List_Count(
-        void);
-    bool Device_Object_List_Identifier(
-        unsigned array_index,
-        int *object_type,
-        uint32_t * instance);
-
-    unsigned Device_Count(
-        void);
-    uint32_t Device_Index_To_Instance(
-        unsigned index);
-
-    bool Device_Object_Name(
-        uint32_t object_instance,
-        BACNET_CHARACTER_STRING * object_name);
-    bool Device_Set_Object_Name(
-        BACNET_CHARACTER_STRING * object_name);
-    /* Copy a child object name, given its ID. */
-    bool Device_Object_Name_Copy(
-        BACNET_OBJECT_TYPE object_type,
-        uint32_t object_instance,
-        BACNET_CHARACTER_STRING * object_name);
-    bool Device_Object_Name_ANSI_Init(const char * value);
-
-    BACNET_DEVICE_STATUS Device_System_Status(
-        void);
-    int Device_Set_System_Status(
-        BACNET_DEVICE_STATUS status,
-        bool local);
-
-    const char *Device_Vendor_Name(
-        void);
-
-    uint16_t Device_Vendor_Identifier(
-        void);
-    void Device_Set_Vendor_Identifier(
-        uint16_t vendor_id);
-
-    const char *Device_Model_Name(
-        void);
-    bool Device_Set_Model_Name(
-        const char *name,
-        size_t length);
-
-    const char *Device_Firmware_Revision(
-        void);
-
-    const char *Device_Application_Software_Version(
-        void);
-    bool Device_Set_Application_Software_Version(
-        const char *name,
-        size_t length);
-
-    const char *Device_Description(
-        void);
-    bool Device_Set_Description(
-        const char *name,
-        size_t length);
-
-    const char *Device_Location(
-        void);
-    bool Device_Set_Location(
-        const char *name,
-        size_t length);
-
-    /* some stack-centric constant values - no set methods */
-    uint8_t Device_Protocol_Version(
-        void);
-    uint8_t Device_Protocol_Revision(
-        void);
-    BACNET_SEGMENTATION Device_Segmentation_Supported(
-        void);
-
-    uint32_t Device_Database_Revision(
-        void);
-    void Device_Set_Database_Revision(
-        uint32_t revision);
-    void Device_Inc_Database_Revision(
-        void);
-
-    bool Device_Valid_Object_Name(
-        BACNET_CHARACTER_STRING * object_name,
-        int *object_type,
-        uint32_t * object_instance);
-    bool Device_Valid_Object_Id(
-        int object_type,
-        uint32_t object_instance);
-
-    int Device_Read_Property(
-        BACNET_READ_PROPERTY_DATA * rpdata);
-    bool Device_Write_Property(
-        BACNET_WRITE_PROPERTY_DATA * wp_data);
-
-    bool DeviceGetRRInfo(
-        BACNET_READ_RANGE_DATA * pRequest,      /* Info on the request */
-        RR_PROP_INFO * pInfo);  /* Where to put the information */
-
-    int Device_Read_Property_Local(
-        BACNET_READ_PROPERTY_DATA * rpdata);
-    bool Device_Write_Property_Local(
-        BACNET_WRITE_PROPERTY_DATA * wp_data);
-
-#if defined(INTRINSIC_REPORTING)
-    void Device_local_reporting(
-        void);
-#endif
-
-/* Prototypes for Routing functionality in the Device Object.
- * Enable by defining BAC_ROUTING in config.h and including gw_device.c
- * in the build (lib/Makefile).
- */
-    void Routing_Device_Init(
-        uint32_t first_object_instance);
-
-    uint16_t Add_Routed_Device(
-        uint32_t Object_Instance,
-        BACNET_CHARACTER_STRING * Object_Name,
-        const char *Description);
-    DEVICE_OBJECT_DATA *Get_Routed_Device_Object(
-        int idx);
-    BACNET_ADDRESS *Get_Routed_Device_Address(
-        int idx);
-
-    void routed_get_my_address(
-        BACNET_ADDRESS * my_address);
-
-    bool Routed_Device_Address_Lookup(
-        int idx,
-        uint8_t address_len,
-        uint8_t * mac_adress);
-    bool Routed_Device_GetNext(
-        BACNET_ADDRESS * dest,
-        int *DNET_list,
-        int *cursor);
-    bool Routed_Device_Is_Valid_Network(
-        uint16_t dest_net,
-        int *DNET_list);
-
-    uint32_t Routed_Device_Index_To_Instance(
-        unsigned index);
-    bool Routed_Device_Valid_Object_Instance_Number(
-        uint32_t object_id);
-    bool Routed_Device_Name(
-        uint32_t object_instance,
-        BACNET_CHARACTER_STRING * object_name);
-    uint32_t Routed_Device_Object_Instance_Number(
-        void);
-    bool Routed_Device_Set_Object_Instance_Number(
-        uint32_t object_id);
-    bool Routed_Device_Set_Object_Name(
-        uint8_t encoding,
-        const char *value,
-        size_t length);
-    bool Routed_Device_Set_Description(
-        const char *name,
-        size_t length);
-    void Routed_Device_Inc_Database_Revision(
-        void);
-    int Routed_Device_Service_Approval(
-        BACNET_CONFIRMED_SERVICE service,
-        int service_argument,
-        uint8_t * apdu_buff,
-        uint8_t invoke_id);
-
-
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-/** @defgroup ObjFrmwk Object Framework
- * @ingroup bacnetmstp
- * The modules in this section describe the BACnet-stack's framework for
- * BACnet-defined Objects (Device, Analog Input, etc). There are two submodules
- * to describe this arrangement:
- *  - The "object helper functions" which provide C++-like common functionality
- *    to all supported object types.
- *  - The interface between the implemented Objects and the BAC-stack services,
- *    specifically the handlers, which are mediated through function calls to
- *    the Device object.
- *//** @defgroup ObjHelpers Object Helper Functions
- * @ingroup ObjFrmwk
- * This section describes the function templates for the helper functions that
- * provide common object support.
- *//** @defgroup ObjIntf Handler-to-Object Interface Functions
- * @ingroup ObjFrmwk
- * This section describes the fairly limited set of functions that link the
- * BAC-stack handlers to the BACnet Object instances.  All of these calls are
- * situated in the Device Object, which "knows" how to reach its child Objects.
- *
- * Most of these calls have a common operation:
- *  -# Call Device_Objects_Find_Functions( for the desired Object_Type )
- *   - Gets a pointer to the object_functions for this Type of Object.
- *  -# Call the Object's Object_Valid_Instance( for the desired object_instance )
- *     to make sure there is such an instance.
- *  -# Call the Object helper function needed by the handler,
- *     eg Object_Read_Property() for the RP handler.
- *
- */
-#endif
diff --git a/src/bacnetmstp/timer.h b/src/bacnetmstp/timer.h
deleted file mode 100644
index a2fff78..0000000
--- a/src/bacnetmstp/timer.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/**************************************************************************
-*
-* Copyright (C) 2009 Steve Karg <skarg@users.sourceforge.net>
-*
-* Permission is hereby granted, free of charge, to any person obtaining
-* a copy of this software and associated documentation files (the
-* "Software"), to deal in the Software without restriction, including
-* without limitation the rights to use, copy, modify, merge, publish,
-* distribute, sublicense, and/or sell copies of the Software, and to
-* permit persons to whom the Software is furnished to do so, subject to
-* the following conditions:
-*
-* The above copyright notice and this permission notice shall be included
-* in all copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*********************************************************************/
-#ifndef TIMER_H
-#define TIMER_H
-
-#include <stdbool.h>
-#include <stdint.h>
-#include <sys/time.h>   /* for timeval */
-
-/* Timer Module */
-#ifndef MAX_MILLISECOND_TIMERS
-#define TIMER_SILENCE 0
-#define MAX_MILLISECOND_TIMERS 1
-#endif
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-    uint32_t timeGetTime(
-        void);
-
-    void timer_init(
-        void);
-    uint32_t timer_milliseconds(
-        unsigned index);
-    bool timer_elapsed_milliseconds(
-        unsigned index,
-        uint32_t value);
-    bool timer_elapsed_seconds(
-        unsigned index,
-        uint32_t value);
-    bool timer_elapsed_minutes(
-        unsigned index,
-        uint32_t seconds);
-    uint32_t timer_milliseconds_set(
-        unsigned index,
-        uint32_t value);
-    uint32_t timer_reset(
-        unsigned index);
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-#endif
diff --git a/src/bh1749/CMakeLists.txt b/src/bh1749/CMakeLists.txt
deleted file mode 100755
index c7e65d1..0000000
--- a/src/bh1749/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-upm_mixed_module_init (NAME bh1749
-    DESCRIPTION "ROHM Color Sensor"
-    C_HDR bh1749.h bh1749_registers.h
-    C_SRC bh1749.c
-    CPP_HDR bh1749.hpp
-    CPP_SRC bh1749.cxx
-    CPP_WRAPS_C
-    REQUIRES mraa)
diff --git a/src/bh1749/bh1749.c b/src/bh1749/bh1749.c
deleted file mode 100755
index 7dc72ca..0000000
--- a/src/bh1749/bh1749.c
+++ /dev/null
@@ -1,702 +0,0 @@
-/*
-* The MIT License (MIT)
-*
-* Author: Assam Boudjelthia
-* Copyright (c) 2018 Rohm Semiconductor.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy of
-* this software and associated documentation files (the "Software"), to deal in
-* the Software without restriction, including without limitation the rights to
-* use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-* the Software, and to permit persons to whom the Software is furnished to do so,
-* subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in all
-* copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-* COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-#include <stdio.h>
-#include "bh1749.h"
-
-#define DEFAULT_OP_MODE INT_JUDGE_1
-#define DEFAULT_MEAS_TIME MEAS_240MS
-#define DEFAULT_RGB_GAIN RGB_GAIN_1X
-#define DEFAULT_IR_GAIN IR_GAIN_1X
-#define DEFAULT_INT_SOURCE RED
-#define DEFUALT_THRESHOLD_HIGH 511
-
-/**
- * @brief Reads the value of a register
- *
- * @param dev The sensor context
- * @param reg Register address
- * @param data Pointer of uint8_t to save register value
- * @return UPM result
- */
-static upm_result_t bh1749_read_register(bh1749_context dev, uint8_t reg, uint8_t *data)
-{
-    uint8_t value = mraa_i2c_read_byte_data(dev->i2c, reg);
-    if(value < 0) {
-        printf("%s: mraa_i2c_read_byte_data() failed\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    *data = value;
-    return UPM_SUCCESS;
-}
-
-/**
- * @brief Reads the values of a set of registers
- *
- * @param dev The sensor context
- * @param reg Register address
- * @param data Pointer of uint8_t to save registers values
- * @return UPM result
- */
-static upm_result_t bh1749_read_registers(bh1749_context dev, uint8_t reg, uint8_t *data, uint8_t len)
-{
-    uint8_t value;
-
-    for(int i = 0; i < len; i++) {
-        if(bh1749_read_register(dev, reg + i, &value) != UPM_SUCCESS) {
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-
-        *(data + i) = value;
-    }
-
-    return UPM_SUCCESS;
-}
-
-/**
- * @brief Writes a value to a register
- *
- * @param dev The sensor context
- * @param value Value to write
- * @param reg Register address
- * @return UPM result
- */
-static upm_result_t bh1749_write_register(bh1749_context dev, uint8_t value, uint8_t reg)
-{
-    if (mraa_i2c_write_byte_data(dev->i2c, value, reg) != MRAA_SUCCESS) {
-        printf("%s: mraa_i2c_write_byte_data() failed\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-/**
- * @brief Sets a bit on in a register with a bit mask
- *
- * @param dev The sensor context
- * @param reg Register address
- * @param bit_mask Mask to use
- * @return UPM result
- */
-static upm_result_t bh1749_set_bit_on(bh1749_context dev, uint8_t reg, uint8_t bit_mask)
-{
-    uint8_t reg_value;
-    int status;
-
-    status = bh1749_read_register(dev, reg, &reg_value);
-    if(status < 0) {
-        printf("%s: Failed to read register 0x%2X\n", __FUNCTION__, reg);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    reg_value |= bit_mask;
-    return bh1749_write_register(dev, reg_value, reg);
-}
-
-/**
- * @brief Sets a bit off in a register with a bit mask
- *
- * @param dev The sensor context
- * @param reg Register address
- * @param bit_mask Mask to use
- * @return UPM result
- */
-static upm_result_t bh1749_set_bit_off(bh1749_context dev, uint8_t reg, uint8_t bit_mask)
-{
-    uint8_t reg_value;
-    int status;
-
-    status = bh1749_read_register(dev, reg, &reg_value);
-    if(status < 0) {
-        printf("%s: Failed to read register 0x%2X\n", __FUNCTION__, reg);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    reg_value &= ~bit_mask;
-    return bh1749_write_register(dev, reg_value, reg);
-}
-
-/**
- * @brief Sets the value of a register as a given pattern with a bit mask
- *
- * @param dev The sensor context
- * @param reg Register address
- * @param value Value to write
- * @param bit_mask Mask to use
- * @return UPM result
- */
-static upm_result_t bh1749_set_bits_with_mask(bh1749_context dev, uint8_t reg, uint8_t value, uint8_t bit_mask)
-{
-    uint8_t reg_value;
-    int status;
-
-    status = bh1749_read_register(dev, reg, &reg_value);
-    if(status < 0) {
-        printf("%s: Failed to read register 0x%2X\n", __FUNCTION__, reg);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    reg_value &= ~bit_mask;
-    reg_value |= value;
-    return bh1749_write_register(dev, reg_value, reg);
-}
-
-upm_result_t bh1749_check_who_am_i(bh1749_context dev)
-{
-    uint8_t partId;
-    if(bh1749_read_register(dev, BH1749_SYSTEM_CONTROL, &partId) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    partId &= BH1749_SYSTEM_CONTROL_PART_MASK;
-    if(partId != BH1749_SYSTEM_CONTROL_PART_ID) {
-        printf("%s: wrong manufacturer ID\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-bh1749_context bh1749_init(int bus, int addr)
-{
-    bh1749_context dev = (bh1749_context)malloc(sizeof(struct _bh1749_context));
-    if (!dev)
-        return NULL;
-
-    dev->i2c = NULL;
-    dev->interrupt = NULL;
-
-    if (mraa_init() != MRAA_SUCCESS) {
-        printf("%s: mraa_init() failed.\n", __FUNCTION__);
-        bh1749_close(dev);
-        return NULL;
-    }
-
-    if (!(dev->i2c = mraa_i2c_init(bus))) {
-        printf("%s: mraa_i2c_init() failed.\n", __FUNCTION__);
-        bh1749_close(dev);
-        return NULL;
-    }
-
-    if (mraa_i2c_address(dev->i2c, addr)) {
-        printf("%s: mraa_i2c_address() failed.\n", __FUNCTION__);
-        bh1749_close(dev);
-        return NULL;
-    }
-
-    if(bh1749_check_who_am_i(dev) != UPM_SUCCESS)
-        return NULL;
-
-    dev->enabled = false;
-    dev->isrEnabled = false;
-    if(bh1749_sensor_init(dev, DEFAULT_OP_MODE, DEFAULT_MEAS_TIME,
-        DEFAULT_RGB_GAIN, DEFAULT_IR_GAIN, DEFAULT_INT_SOURCE) != UPM_SUCCESS)
-        return NULL;
-    bh1749_set_threshold_high(dev, DEFUALT_THRESHOLD_HIGH);
-
-    return dev;
-}
-
-void bh1749_close(bh1749_context dev)
-{
-    if(dev->isrEnabled)
-        bh1749_remove_isr(dev);
-
-    if (dev->i2c)
-        mraa_i2c_stop(dev->i2c);
-
-    free(dev);
-}
-
-upm_result_t bh1749_enable(bh1749_context dev)
-{
-    int status;
-
-    status = bh1749_set_bit_on(dev, BH1749_MODE_CONTROL2,
-                BH1749_MODE_CONTROL2_RGB_MEASUREMENT_MASK);
-    if(status != UPM_SUCCESS) {
-        printf("%s: Failed to bh1749_enable RGB measurement\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-    dev->enabled = true;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1749_disable(bh1749_context dev)
-{
-    int status;
-
-    status = bh1749_set_bit_off(dev, BH1749_MODE_CONTROL2,
-                BH1749_MODE_CONTROL2_RGB_MEASUREMENT_MASK);
-    if(status != UPM_SUCCESS) {
-        printf("%s: Failed to bh1749_disable RGB measurement\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-    dev->enabled = false;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1749_sensor_init(bh1749_context dev, OPERATING_MODES opMode,
-                        MEAS_TIMES measTime,
-                        RGB_GAINS rgbGain,
-                        IR_GAINS irGain,
-                        INT_SOURCES intSource)
-{
-    if(bh1749_set_operating_mode(dev, opMode) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-    if(bh1749_set_measurement_time(dev, measTime) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-    if(bh1749_set_rgb_gain(dev, rgbGain) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-    if(bh1749_set_ir_gain(dev, irGain) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-    return bh1749_set_int_source(dev, intSource);
-}
-
-upm_result_t bh1749_set_operating_mode(bh1749_context dev, OPERATING_MODES opMode)
-{
-    if(bh1749_write_register(dev, opMode, BH1749_PERSISTENCE) != UPM_SUCCESS) {
-        printf("%s: Setting operating mode failed\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-    dev->operating_mode = opMode;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1749_get_operating_mode(bh1749_context dev, uint8_t *opMode)
-{
-    uint8_t value;
-
-    if(bh1749_read_register(dev, BH1749_PERSISTENCE, &value) != UPM_SUCCESS) {
-        printf("%s: Failed to read operating mode\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    value &= BH1749_PERSISTENCE_MODE_MASK;
-    if(value != INT_JUDGE_0 && value != INT_JUDGE_1 &&
-        value != INT_JUDGE_4 && value != INT_JUDGE_4) {
-            printf("%s: Returned invalid mode\n", __FUNCTION__);
-            return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    *opMode = value;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1749_set_measurement_time(bh1749_context dev, MEAS_TIMES measTime)
-{
-    if(bh1749_set_bits_with_mask(dev, BH1749_MODE_CONTROL1, measTime,
-                        BH1749_MODE_CONTROL1_ODR_MASK) != UPM_SUCCESS) {
-        printf("%s: Failed setting measurement time\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-    dev->meas_time = measTime;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1749_get_measurement_time(bh1749_context dev, uint8_t *meas_time)
-{
-    uint8_t time_reg;
-
-    if(bh1749_read_register(dev, BH1749_MODE_CONTROL1, &time_reg) != UPM_SUCCESS) {
-        printf("%s: Failed to read measurement time\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    time_reg &= BH1749_MODE_CONTROL1_ODR_MASK;
-    if(time_reg == MEAS_35MS)
-        *meas_time = 35;
-    else if(time_reg == MEAS_120MS)
-        *meas_time = 120;
-    else if(time_reg == MEAS_240MS)
-        *meas_time = 240;
-    else {
-        printf("%s: Returned invalid time\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1749_set_rgb_gain(bh1749_context dev, RGB_GAINS rgbGain)
-{
-    if(bh1749_set_bits_with_mask(dev, BH1749_MODE_CONTROL1, rgbGain,
-                        BH1749_MODE_CONTROL1_RGB_GAIN_MASK) != UPM_SUCCESS) {
-        printf("%s: Failed setting RGB gain\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-    dev->rgb_gain = rgbGain;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1749_get_rgb_gain(bh1749_context dev, uint8_t *gain)
-{
-    uint8_t rgb_gain;
-
-    if(bh1749_read_register(dev, BH1749_MODE_CONTROL1, &rgb_gain) != UPM_SUCCESS) {
-        printf("%s: Failed to read rgb gain\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    rgb_gain &= BH1749_MODE_CONTROL1_RGB_GAIN_MASK;
-    if(rgb_gain == RGB_GAIN_1X)
-        *gain = 1;
-    else if(rgb_gain == RGB_GAIN_32X)
-        *gain = 32;
-    else {
-        printf("%s: Returned invalid gain\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1749_set_ir_gain(bh1749_context dev, IR_GAINS irGain)
-{
-    if(bh1749_set_bits_with_mask(dev, BH1749_MODE_CONTROL1, irGain,
-                        BH1749_MODE_CONTROL1_IR_GAIN_MASK) != UPM_SUCCESS) {
-        printf("%s: Failed setting IR gain\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-    dev->ir_gain = irGain;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1749_get_ir_gain(bh1749_context dev, uint8_t *gain)
-{
-    uint8_t ir_gain;
-
-    if(bh1749_read_register(dev, BH1749_MODE_CONTROL1, &ir_gain) != UPM_SUCCESS) {
-        printf("%s: Failed to read rgb gain\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    ir_gain &= BH1749_MODE_CONTROL1_IR_GAIN_MASK;
-    if(ir_gain == IR_GAIN_1X)
-        *gain = 1;
-    else if(ir_gain == IR_GAIN_32X)
-        *gain = 32;
-    else {
-        printf("%s: Returned invalid gain\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1749_set_int_source(bh1749_context dev, INT_SOURCES intSource)
-{
-    if(bh1749_set_bits_with_mask(dev, BH1749_INTERRUPT, intSource,
-                        BH1749_INTERRUPT_SOURCE_MASK) != UPM_SUCCESS) {
-        printf("%s: Failed setting interrupt source gain\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-    dev->int_src = intSource;
-
-    return UPM_SUCCESS;
-}
-
-char bh1749_get_interrupt_source_char(bh1749_context dev)
-{
-    char intSourceChar = ' ';
-    uint8_t intSource;
-
-    if(bh1749_read_register(dev, BH1749_INTERRUPT, &intSource) != UPM_SUCCESS) {
-        printf("%s: Failed to read interrupt source\n", __FUNCTION__);
-        return intSourceChar;
-    }
-
-    intSource &= BH1749_INTERRUPT_SOURCE_MASK;
-    if(intSource == RED)
-        intSourceChar = 'r';
-    else if(intSource == GREEN)
-        intSourceChar = 'g';
-    else if(intSource == BLUE)
-        intSourceChar = 'b';
-    else {
-        printf("%s: Returned invalid interrupt source\n", __FUNCTION__);
-        return intSourceChar;
-    }
-
-    return intSourceChar;
-}
-
-upm_result_t bh1749_enable_interrupt(bh1749_context dev)
-{
-    if(bh1749_set_bit_on(dev, BH1749_INTERRUPT, BH1749_INTERRUPT_EN_MASK) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-    return bh1749_reset_interrupt(dev);
-}
-
-upm_result_t bh1749_disable_interrupt(bh1749_context dev)
-{
-    return bh1749_set_bit_off(dev, BH1749_INTERRUPT, BH1749_INTERRUPT_EN_MASK);
-}
-
-upm_result_t bh1749_reset_interrupt(bh1749_context dev)
-{
-    return bh1749_set_bit_on(dev, BH1749_SYSTEM_CONTROL, BH1749_SYSTEM_CONTROL_INT_RESET);
-}
-
-bool bh1749_is_interrupted(bh1749_context dev)
-{
-    uint8_t intStatus;
-
-    if(bh1749_read_register(dev, BH1749_INTERRUPT, &intStatus) != UPM_SUCCESS) {
-        printf("%s: Failed to read interrupt status\n", __FUNCTION__);
-        return false;
-    }
-
-    intStatus &= BH1749_INTERRUPT_STATUS_MASK;
-    if(intStatus != BH1749_INTERRUPT_STATUS_ACTIVE)
-            return false;
-
-    return true;
-}
-
-bool bh1749_is_interrupt_enabled(bh1749_context dev)
-{
-    uint8_t intStatus;
-
-    if(bh1749_read_register(dev, BH1749_INTERRUPT, &intStatus) != UPM_SUCCESS) {
-        printf("%s: Failed to read interrupt enabled\n", __FUNCTION__);
-        return false;
-    }
-
-    intStatus &= BH1749_INTERRUPT_EN_MASK;
-    if(intStatus != BH1749_INTERRUPT_EN_ENABLE)
-        return false;
-
-    return true;
-}
-
-upm_result_t bh1749_soft_reset(bh1749_context dev)
-{
-    return bh1749_set_bit_on(dev, BH1749_SYSTEM_CONTROL, BH1749_SYSTEM_CONTROL_SW_RESET_MASK);
-}
-
-upm_result_t bh1749_set_threshold_high(bh1749_context dev, uint16_t threshold)
-{
-    if(bh1749_write_register(dev, threshold, BH1749_TH_LSBS) != UPM_SUCCESS ||
-        bh1749_write_register(dev, threshold >> 8, BH1749_TH_MSBS) != UPM_SUCCESS) {
-        printf("%s: Failed to write high threshold\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-    dev->int_thh = threshold;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1749_get_threshold_high(bh1749_context dev, uint16_t *threshold)
-{
-    uint8_t data[2];
-
-    if(bh1749_read_register(dev, BH1749_TH_MSBS, &data[0]) ||
-        bh1749_read_register(dev, BH1749_TH_LSBS, &data[1]) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    *threshold = data[0] << 8 | data[1];
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1749_set_threshold_low(bh1749_context dev, uint16_t threshold)
-{
-    if(bh1749_write_register(dev, threshold, BH1749_TL_LSBS) != UPM_SUCCESS ||
-        bh1749_write_register(dev, threshold >> 8, BH1749_TL_MSBS) != UPM_SUCCESS) {
-        printf("%s: Failed to write low threshold\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-    dev->int_thl = threshold;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1749_get_threshold_low(bh1749_context dev, uint16_t *threshold)
-{
-
-    uint8_t data[2];
-
-    if(bh1749_read_register(dev, BH1749_TL_MSBS, &data[0]) ||
-        bh1749_read_register(dev, BH1749_TL_LSBS, &data[1]) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    *threshold = data[0] << 8 | data[1];
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1749_get_red(bh1749_context dev, uint16_t *red)
-{
-    uint8_t data[2];
-
-    if(bh1749_read_register(dev, BH1749_RED_DATA_MSBS, &data[0]) != UPM_SUCCESS ||
-        bh1749_read_register(dev, BH1749_RED_DATA_LSBS, &data[1]) != UPM_SUCCESS)
-        return -UPM_ERROR_OPERATION_FAILED;
-
-    *red = data[0] << 8 | data[1];
-
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1749_get_green(bh1749_context dev, uint16_t *green)
-{
-    uint8_t data[2];
-
-    if(bh1749_read_register(dev, BH1749_GREEN_DATA_MSBS, &data[0]) != UPM_SUCCESS ||
-        bh1749_read_register(dev, BH1749_GREEN_DATA_LSBS, &data[1]) != UPM_SUCCESS)
-        return -UPM_ERROR_OPERATION_FAILED;
-
-    *green = data[0] << 8 | data[1];
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1749_get_blue(bh1749_context dev, uint16_t *blue)
-{
-    uint8_t data[2];
-
-    if(bh1749_read_register(dev, BH1749_BLUE_DATA_MSBS, &data[0]) != UPM_SUCCESS ||
-        bh1749_read_register(dev, BH1749_BLUE_DATA_LSBS, &data[1]) != UPM_SUCCESS)
-        return -UPM_ERROR_OPERATION_FAILED;
-
-    *blue = data[0] << 8 | data[1];
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1749_get_ir(bh1749_context dev, uint16_t *ir)
-{
-    uint8_t data[2];
-
-    if(bh1749_read_register(dev, BH1749_IR_DATA_MSBS, &data[0]) != UPM_SUCCESS ||
-        bh1749_read_register(dev, BH1749_IR_DATA_LSBS, &data[1]) != UPM_SUCCESS)
-        return -UPM_ERROR_OPERATION_FAILED;
-
-    *ir = data[0] << 8 | data[1];
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1749_get_green2(bh1749_context dev, uint16_t *green2)
-{
-    uint8_t data[2];
-
-    if(bh1749_read_register(dev, BH1749_GREEN2_DATA_MSBS, &data[0]) != UPM_SUCCESS ||
-        bh1749_read_register(dev, BH1749_GREEN2_DATA_LSBS, &data[1]) != UPM_SUCCESS)
-        return -UPM_ERROR_OPERATION_FAILED;
-
-    *green2 = data[0] << 8 | data[1];
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1749_get_measurements(bh1749_context dev, uint16_t *result)
-{
-    uint16_t value;
-    int step = 0;
-
-    if(bh1749_get_red(dev, &value) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-    *(result + step++) = value;
-    if(bh1749_get_green(dev, &value) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-    *(result + step++) = value;
-    if(bh1749_get_blue(dev, &value) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-    *(result + step++) = value;
-    if(bh1749_get_ir(dev, &value) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-    *(result + step++) = value;
-    if(bh1749_get_green2(dev, &value) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-    *(result + step++) = value;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1749_install_isr(bh1749_context dev, mraa_gpio_edge_t edge, int pin,
-                        void (*isr)(void *), void *isr_args)
-{
-    if(dev->isrEnabled)
-        bh1749_remove_isr(dev);
-
-    mraa_gpio_context isr_gpio = NULL;
-
-    if (!(isr_gpio = mraa_gpio_init(pin))) {
-        printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    mraa_gpio_dir(isr_gpio, MRAA_GPIO_IN);
-
-    if (mraa_gpio_isr(isr_gpio, edge, isr, isr_args) != MRAA_SUCCESS) {
-        mraa_gpio_close(isr_gpio);
-        printf("%s: mraa_gpio_isr() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    dev->interrupt = isr_gpio;
-    dev->isrEnabled = true;
-
-    return UPM_SUCCESS;
-}
-
-void bh1749_remove_isr(bh1749_context dev)
-{
-    mraa_gpio_isr_exit(dev->interrupt);
-    mraa_gpio_close(dev->interrupt);
-    dev->interrupt = NULL;
-    dev->isrEnabled = false;
-}
-
-upm_result_t bh1749_registers_dump(bh1749_context dev, char *dump)
-{
-    uint8_t reg_values[10];
-    int count = 0;
-    int len = 3;
-
-    if(bh1749_read_registers(dev, BH1749_SYSTEM_CONTROL, reg_values, len) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-    count += sprintf(dump, "0x40 ");
-    for(int i = 0; i < len; i++)
-        count += sprintf(dump + count, "%02X ", reg_values[i]);
-    sprintf(dump + count - 1, "\n");
-
-    len = 6;
-    if(bh1749_read_registers(dev, BH1749_INTERRUPT, reg_values, len) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-    count += sprintf(dump + count, "0x60 ");
-    for(int i = 0; i < len; i++)
-        count += sprintf(dump + count, "%02X ", reg_values[i]);
-
-    return UPM_SUCCESS;
-}
diff --git a/src/bh1749/bh1749.cxx b/src/bh1749/bh1749.cxx
deleted file mode 100755
index ce3b75c..0000000
--- a/src/bh1749/bh1749.cxx
+++ /dev/null
@@ -1,304 +0,0 @@
-/*
-* The MIT License (MIT)
-*
-* Author: Assam Boudjelthia
-* Copyright (c) 2018 Rohm Semiconductor.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy of
-* this software and associated documentation files (the "Software"), to deal in
-* the Software without restriction, including without limitation the rights to
-* use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-* the Software, and to permit persons to whom the Software is furnished to do so,
-* subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in all
-* copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-* COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-#include "bh1749.hpp"
-
-using namespace upm;
-
-void BH1749::CheckWhoAmI()
-{
-    if(bh1749_check_who_am_i(m_bh1749) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_check_who_am_i() failed");
-}
-
-BH1749::BH1749(int bus, int addr) : m_bh1749(bh1749_init(bus, addr))
-{
-    if(!m_bh1749)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_init() failed");
-}
-
-BH1749::~BH1749()
-{
-    bh1749_close(m_bh1749);
-}
-
-void BH1749::Enable()
-{
-    if(bh1749_enable(m_bh1749) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_enable() failed");
-}
-
-void BH1749::Disable()
-{
-    if(bh1749_disable(m_bh1749) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_disable() failed");
-}
-
-void BH1749::SensorInit(OPERATING_MODES opMode,
-                        MEAS_TIMES measTime,
-                        RGB_GAINS rgbGain,
-                        IR_GAINS irGain,
-                        INT_SOURCES intSource)
-{
-    if(bh1749_sensor_init(m_bh1749, opMode, measTime, rgbGain, irGain, intSource) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_sensor_init() failed");
-}
-
-void BH1749::SetOperatingMode(OPERATING_MODES opMode)
-{
-    if(bh1749_set_operating_mode(m_bh1749, opMode) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_set_operating_mode() failed");
-}
-
-int BH1749::GetOperatingMode()
-{
-    uint8_t opMode;
-    if(bh1749_get_operating_mode(m_bh1749, &opMode) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_get_operating_mode() failed");
-    return opMode;
-}
-
-void BH1749::SetMeasurementTime(MEAS_TIMES measTime)
-{
-    if(bh1749_set_measurement_time(m_bh1749, measTime) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_set_measurement_time() failed");
-}
-
-int BH1749::GetMeasurementTime()
-{
-    uint8_t measTime;
-    if(bh1749_get_measurement_time(m_bh1749, &measTime) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_get_measurement_time() failed");
-    return measTime;
-}
-
-void BH1749::SetRgbGain(RGB_GAINS rgbGain)
-{
-    if(bh1749_set_rgb_gain(m_bh1749, rgbGain) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_set_rgb_gain() failed");
-}
-
-int BH1749::GetRgbGain()
-{
-    uint8_t rgbGain;
-    if(bh1749_get_rgb_gain(m_bh1749, &rgbGain) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_get_rgb_gain() failed");
-    return rgbGain;
-}
-
-void BH1749::SetIrGain(IR_GAINS irGain)
-{
-    if(bh1749_set_ir_gain(m_bh1749, irGain) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_set_ir_gain() failed");
-}
-
-int BH1749::GetIrGain()
-{
-    uint8_t irGain;
-    if(bh1749_get_ir_gain(m_bh1749, &irGain) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_get_ir_gain() failed");
-    return irGain;
-}
-
-void BH1749::SetIntSource(INT_SOURCES intSource)
-{
-    if(bh1749_set_int_source(m_bh1749, intSource) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_set_int_source() failed");
-}
-
-char BH1749::GetInterruptSourceChar()
-{
-    char intSource = bh1749_get_interrupt_source_char(m_bh1749);
-    if( intSource == ' ')
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_get_interrupt_source_char() failed");
-    return intSource;
-}
-
-void BH1749::EnableInterrupt()
-{
-    if(bh1749_enable_interrupt(m_bh1749) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_enable_interrupt() failed");
-}
-
-void BH1749::DisableInterrupt()
-{
-    if(bh1749_disable_interrupt(m_bh1749) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_disable_interrupt() failed");
-}
-
-void BH1749::ResetInterrupt()
-{
-    if(bh1749_reset_interrupt(m_bh1749) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_reset_interrupt() failed");
-}
-
-bool BH1749::IsInterrupted()
-{
-    return bh1749_is_interrupted(m_bh1749);
-}
-
-bool BH1749::IsInterruptEnabled()
-{
-    return bh1749_is_interrupt_enabled(m_bh1749);
-}
-
-void BH1749::SoftReset()
-{
-    if(bh1749_soft_reset(m_bh1749) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_soft_reset() failed");
-}
-
-void BH1749::SetThresholdHigh(uint16_t threshold)
-{
-    if(bh1749_set_threshold_high(m_bh1749, threshold) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_set_threshold_high() failed");
-}
-
-int BH1749::GetThresholdHigh()
-{
-    uint16_t threhold;
-    if(bh1749_get_threshold_high(m_bh1749, &threhold) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_get_threshold_high() failed");
-    return threhold;
-}
-
-void BH1749::SetThresholdLow(uint16_t threshold)
-{
-    if(bh1749_set_threshold_low(m_bh1749, threshold) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_set_threshold_low() failed");
-}
-
-int BH1749::GetThresholdLow()
-{
-    uint16_t threhold;
-    if(bh1749_get_threshold_low(m_bh1749, &threhold) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_get_threshold_low() failed");
-    return threhold;
-}
-
-uint16_t BH1749::GetRed()
-{
-    uint16_t red;
-    if(bh1749_get_red(m_bh1749, &red) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_get_red() failed");
-    return red;
-}
-
-uint16_t BH1749::GetGreen()
-{
-    uint16_t green;
-    if(bh1749_get_green(m_bh1749, &green) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_get_green() failed");
-    return green;
-}
-
-uint16_t BH1749::GetBlue()
-{
-    uint16_t blue;
-    if(bh1749_get_blue(m_bh1749, &blue) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_get_blue() failed");
-    return blue;
-}
-
-uint16_t BH1749::GetIr()
-{
-    uint16_t ir;
-    if(bh1749_get_ir(m_bh1749, &ir) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_get_ir() failed");
-    return ir;
-}
-
-uint16_t BH1749::GetGeen2()
-{
-    uint16_t green2;
-    if(bh1749_get_green2(m_bh1749, &green2) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_get_green2() failed");
-    return green2;
-}
-
-std::vector<uint16_t> BH1749::GetMeasurements()
-{
-    uint16_t res[5];
-    if(bh1749_get_measurements(m_bh1749, res) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_get_measurements() failed");
-
-    std::vector<uint16_t> result(res, res + sizeof res / sizeof res[0]);
-    return result;
-}
-
-void BH1749::InstallISR(mraa_gpio_edge_t edge, int pin, void (*isr)(void *), void *isr_args)
-{
-    if(bh1749_install_isr(m_bh1749, edge, pin, isr, isr_args) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_install_isr() failed");
-}
-
-void BH1749::RemoveISR()
-{
-    bh1749_remove_isr(m_bh1749);
-}
-
-std::string BH1749::RegistersDump()
-{
-    char dump[255];
-    std::string dumpStr;
-
-    if(bh1749_registers_dump(m_bh1749, dump) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1749_registers_dump() failed");
-    dumpStr = dump;
-    return dumpStr;
-}
diff --git a/src/bh1749/bh1749.h b/src/bh1749/bh1749.h
deleted file mode 100755
index 3109ec4..0000000
--- a/src/bh1749/bh1749.h
+++ /dev/null
@@ -1,429 +0,0 @@
-/*
-* The MIT License (MIT)
-*
-* Author: Assam Boudjelthia
-* Copyright (c) 2018 Rohm Semiconductor.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy of
-* this software and associated documentation files (the "Software"), to deal in
-* the Software without restriction, including without limitation the rights to
-* use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-* the Software, and to permit persons to whom the Software is furnished to do so,
-* subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in all
-* copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-* COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-#pragma once
-
-#ifdef __cplusplus
-extern "C"
-{
-#endif
-
-#include <mraa/i2c.h>
-#include <mraa/gpio.h>
-#include <unistd.h>
-#include <upm_types.h>
-#include "bh1749_registers.h"
-
-/**
- * @file bh1749.h
- * @library bh1749
- * @brief C API for the bh1749 driver
- *
- * @include bh1749.c
- */
-
-/**
- * @brief Operation modes enum for interrupt modes (persistance)
- */
-typedef enum {
-    INT_JUDGE_0 = BH1749_PERSISTENCE_MODE_STATUS_ACTIVE_AFTER_MEASUREMENT,
-    INT_JUDGE_1 = BH1749_PERSISTENCE_MODE_STATUS_UPDATE_AFTER_MEASUREMENT,
-    INT_JUDGE_4 = BH1749_PERSISTENCE_MODE_STATUS_UPDATE_AFTER_4_SAME,
-    INT_JUDGE_8 = BH1749_PERSISTENCE_MODE_STATUS_UPDATE_AFTER_8_SAME,
-} OPERATING_MODES;
-
-/**
- * @brief Measuremnt time choices
- */
-typedef enum {
-    MEAS_35MS = BH1749_MODE_CONTROL1_ODR_28P6,
-    MEAS_120MS = BH1749_MODE_CONTROL1_ODR_8P333,
-    MEAS_240MS = BH1749_MODE_CONTROL1_ODR_4P167
-} MEAS_TIMES;
-
-/**
- * @brief RGB gain choices
- */
-typedef enum {
-    RGB_GAIN_1X = BH1749_MODE_CONTROL1_RGB_GAIN_1X,
-    RGB_GAIN_32X = BH1749_MODE_CONTROL1_RGB_GAIN_32X
-} RGB_GAINS;
-
-/**
- * @brief IR gain choices
- */
-typedef enum {
-    IR_GAIN_1X = BH1749_MODE_CONTROL1_IR_GAIN_1X,
-    IR_GAIN_32X = BH1749_MODE_CONTROL1_IR_GAIN_32X
-} IR_GAINS;
-
-/**
- * @brief Interrupt source choices
- */
-typedef enum {
-    RED = BH1749_INTERRUPT_SOURCE_SELECT_RED,
-    GREEN = BH1749_INTERRUPT_SOURCE_SELECT_GREEN,
-    BLUE = BH1749_INTERRUPT_SOURCE_SELECT_BLUE
-} INT_SOURCES;
-
-/**
- * @brief The full sensor context
- */
-typedef struct _bh1749_context
-{
-    mraa_i2c_context i2c;
-    mraa_gpio_context interrupt;
-    bool enabled;
-    bool isrEnabled;
-    uint16_t int_thh;
-    uint16_t int_thl;
-    INT_SOURCES int_src;
-    IR_GAINS ir_gain;
-    RGB_GAINS rgb_gain;
-    MEAS_TIMES meas_time;
-    OPERATING_MODES operating_mode;
-} *bh1749_context;
-
-/**
- * @brief Check "who am I" register value to identify the sensor
- *
- * @param dev Sensor context
- * @return UPM result
- */
-upm_result_t bh1749_check_who_am_i(bh1749_context dev);
-
-/**
- * @brief Init the sensor with specific bus and address. This function calls
- * the sensor_init() function to set default values for operating mode, gains,
- * measurement time, interrupt source and then sets threshold high to 511.
- *
- * @param bus I2C bus number
- * @param addr I2C sensor address
- * @return context of initialized sensor
- */
-bh1749_context bh1749_init(int bus, int addr);
-
-/**
- * @brief Close and free sensor context
- *
- * @param dev Sensor context
- */
-void bh1749_close(bh1749_context dev);
-
-/**
- * @brief Enables RGB color measurement on the sensor
- *
- * @param dev Sensor context
- * @return UPM result
- */
-upm_result_t bh1749_enable(bh1749_context dev);
-
-/**
- * @brief Disables RGB color measurement on the sensor
- *
- * @param dev Sensor context
- * @return UPM result
- */
-upm_result_t bh1749_disable(bh1749_context dev);
-
-/**
- * @brief Initializes (writes) configuration values to sensor
- *
- * @param dev Sensor context
- * @param opMode Operating mode choice, a value of OPERATING_MODES enum
- * @param measTime Measurement time choice, a value of MEAS_TIMES enum
- * @param rgbGain RGB gain choice, a value of RGB_GAINS enum
- * @param irGain IR gain choice, a value of IR_GAINS enum
- * @param intSource interrupt source choice, a value of INT_SOURCES enum
- * @return UPM result
- */
-upm_result_t bh1749_sensor_init(bh1749_context dev, OPERATING_MODES opMode,
-                        MEAS_TIMES measTime,
-                        RGB_GAINS rgbGain,
-                        IR_GAINS irGain,
-                        INT_SOURCES intSource);
-
-/**
- * @brief Sets operating mode (interrupt persistance)
- *
- * @param dev Sensor context
- * @param opMode Operating mode choice, a value of OPERATING_MODES enum
- * @return UPM result
- */
-upm_result_t bh1749_set_operating_mode(bh1749_context dev, OPERATING_MODES opMode);
-
-/**
- * @brief Gets operating mode (interrupt persistance) value
- *
- * @param dev Sensor context
- * @param opMode pointer (uint8_t) to save value
- * @return UPM result
- */
-upm_result_t bh1749_get_operating_mode(bh1749_context dev, uint8_t *opMode);
-
-/**
- * @brief Sets measurement time (ODR)
- *
- * @param dev Sensor context
- * @param measTime measurement time choice, a value of MEAS_TIMES enum
- * @return UPM result
- */
-upm_result_t bh1749_set_measurement_time(bh1749_context dev, MEAS_TIMES measTime);
-
-/**
- * @brief Sets measurement time (ODR)
- *
- * @param dev Sensor context
- * @param meas_time pointer (uint8_t) to save value
- * @return UPM result
- */
-upm_result_t bh1749_get_measurement_time(bh1749_context dev, uint8_t *meas_time);
-
-/**
- * @brief Sets RGB gain values
- *
- * @param dev Sensor context
- * @param rgbGain RGB gain choice, a value of RGB_GAINS enum
- * @return UPM result
- */
-upm_result_t bh1749_set_rgb_gain(bh1749_context dev, RGB_GAINS rgbGain);
-
-/**
- * @brief Gets RGB gain value
- *
- * @param dev Sensor context
- * @param gain pointer (uint8_t) to save value
- * @return UPM result
- */
-upm_result_t bh1749_get_rgb_gain(bh1749_context dev, uint8_t *gain);
-
-/**
- * @brief Sets IR gain values
- *
- * @param dev Sensor context
- * @param irGain IR gain choice, a value of IR_GAINS enum
- * @return UPM result
- */
-upm_result_t bh1749_set_ir_gain(bh1749_context dev, IR_GAINS irGain);
-
-/**
- * @brief Gets IR gain value
- *
- * @param dev Sensor context
- * @param gain pointer (uint8_t) to save value
- * @return UPM result
- */
-upm_result_t bh1749_get_ir_gain(bh1749_context dev, uint8_t *gain);
-
-/**
- * @brief Sets interrupt source value
- *
- * @param dev Sensor context
- * @param intSource interrupt source choice, a value of INT_SOURCES enum
- * @return UPM result
- */
-upm_result_t bh1749_set_int_source(bh1749_context dev, INT_SOURCES intSource);
-
-/**
- * @brief Gets interrupt source value
- *
- * @param dev Sensor context
- * @return character of interrupt source
- */
-char bh1749_get_interrupt_source_char(bh1749_context dev);
-
-/**
- * @brief Enables interrupt mode and resets the interrupt status (clear)
- *
- * @param dev Sensor context
- * @return UPM result
- */
-upm_result_t bh1749_enable_interrupt(bh1749_context dev);
-
-/**
- * @brief Disables interrupt mode
- *
- * @param dev Sensor context
- * @return UPM result
- */
-upm_result_t bh1749_disable_interrupt(bh1749_context dev);
-
-/**
- * @brief Resets interrupt status (clear) to allow new interrupts
- *
- * @param dev Sensor context
- * @return UPM result
- */
-upm_result_t bh1749_reset_interrupt(bh1749_context dev);
-
-/**
- * @brief Checks the status of the interrupt
- *
- * @param dev Sensor context
- * @return true if there is interrupt, otherwise false
- */
-bool bh1749_is_interrupted(bh1749_context dev);
-
-/**
- * @brief Checks whether interrupt mode is enabled
- *
- * @param dev Sensor context
- * @return true if interrupt is enabled, otherwise false
- */
-bool bh1749_is_interrupt_enabled(bh1749_context dev);
-
-/**
- * @brief Initiates a software reset to the sensor. All register values will
- * be written to their defaults, thus sensor_init() must be called after this,
- * and thresholds also needs to be set.
- *
- * @param dev Sensor context
- * @return UPM result
- */
-upm_result_t bh1749_soft_reset(bh1749_context dev);
-
-/**
- * @brief Sets interrupt threshold high value
- *
- * @param dev Sensor context
- * @param threshold Value to be written, range 0-65536
- * @return UPM result
- */
-upm_result_t bh1749_set_threshold_high(bh1749_context dev, uint16_t threshold);
-
-/**
- * @brief Gets interrupt threshold high value
- *
- * @param dev Sensor context
- * @param threshold Pointer (uint16_t) to write value
- * @return UPM result
- */
-upm_result_t bh1749_get_threshold_high(bh1749_context dev, uint16_t *threshold);
-
-/**
- * @brief Sets interrupt threshold low value
- *
- * @param dev Sensor context
- * @param threshold Value to be written, range 0-65536
- * @return UPM result
- */
-upm_result_t bh1749_set_threshold_low(bh1749_context dev, uint16_t threshold);
-
-/**
- * @brief Gets interrupt threshold low value
- *
- * @param dev Sensor context
- * @param threshold Pointer (uint16_t) to write value
- * @return UPM result
- */
-upm_result_t bh1749_get_threshold_low(bh1749_context dev, uint16_t *threshold);
-
-/**
- * @brief Gets value of Red color channel
- *
- * @param dev Sensor context
- * @param red Pointer (uint16_t) to write value
- * @return UPM result
- */
-upm_result_t bh1749_get_red(bh1749_context dev, uint16_t *red);
-
-/**
- * @brief Gets value of Green color channel
- *
- * @param dev Sensor context
- * @param green Pointer (uint16_t) to write value
- * @return UPM result
- */
-upm_result_t bh1749_get_green(bh1749_context dev, uint16_t *green);
-
-/**
- * @brief Gets value of Blue color channel
- *
- * @param dev Sensor context
- * @param blue Pointer (uint16_t) to write value
- * @return UPM result
- */
-upm_result_t bh1749_get_blue(bh1749_context dev, uint16_t *blue);
-
-/**
- * @brief Gets value of IR color channel
- *
- * @param dev Sensor context
- * @param ir Pointer (uint16_t) to write value
- * @return UPM result
- */
-upm_result_t bh1749_get_ir(bh1749_context dev, uint16_t *ir);
-
-/**
- * @brief Gets value of Green2 color channel
- *
- * @param dev Sensor context
- * @param green Pointer (uint16_t) to write value
- * @return UPM result
- */
-upm_result_t bh1749_get_green2(bh1749_context dev, uint16_t *green2);
-
-/**
- * @brief Gets all channels measurements values
- *
- * @param dev Sensor context
- * @param result Pointer of uint16_t to write all values ordered as:
- * Red, Green, Blue, IR, Green2
- *
- * @return UPM result
- */
-upm_result_t bh1749_get_measurements(bh1749_context dev, uint16_t *result);
-
-/**
- * @brief Installs the ISR to a given GPIO pin
- *
- * @param dev Sensor context
- * @param edge Edge type to raise ISR with, of type mraa_gpio_edge_t
- * @param pin GPIO pin number
- * @param isr Pointer to ISR function
- * @param isr_args Arguments to pass the ISR function
- * @return UPM result
- */
-upm_result_t bh1749_install_isr(bh1749_context dev, mraa_gpio_edge_t edge, int pin,
-                        void (*isr)(void *), void *isr_args);
-
-/**
- * @brief Removes the ISR if it is installed
- *
- * @param dev Sensor context
- */
-void bh1749_remove_isr(bh1749_context dev);
-
-/**
- * @brief Gets a dump of configuration registers as a string
- *
- * @param dev Sensor context
- * @param dump Pointer of char to save dump string
- * @return UPM result
- */
-upm_result_t bh1749_registers_dump(bh1749_context dev, char *dump);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/bh1749/bh1749.hpp b/src/bh1749/bh1749.hpp
deleted file mode 100755
index 9cea65f..0000000
--- a/src/bh1749/bh1749.hpp
+++ /dev/null
@@ -1,345 +0,0 @@
-/*
-* The MIT License (MIT)
-*
-* Author: Assam Boudjelthia
-* Copyright (c) 2018 Rohm Semiconductor.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy of
-* this software and associated documentation files (the "Software"), to deal in
-* the Software without restriction, including without limitation the rights to
-* use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-* the Software, and to permit persons to whom the Software is furnished to do so,
-* subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in all
-* copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-* COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-#pragma once
-
-#include <vector>
-#include "bh1749.h"
-
-/**
- * @brief BH1749 Color Sensor
- * @defgroup bh1749 libupm-bh1749
- * @ingroup rohm i2c color
- */
-
-/**
- * @library bh1749
- * @sensor bh1749
- * @comname Color Sensor
- * @type color sensor
- * @man rohm
- * @con i2c
- *
- * @brief C++ API wrapper for the bh1749 driver
- *
- * @snippet bh1749.cxx Interesting
- */
-
-namespace upm {
-    class BH1749 {
-    public:
-        /**
-         * @brief Initialize a sensor instance with bus and address.
-         *
-         * This calls SensorInit() to set default values for operating mode,
-         * gains, measurement time, interrupt source and then sets threshold
-         * high to 511.
-         *
-         * @param bus I2C bus number
-         * @param addr I2C sensor address
-         * @throws std::runtime_error on initialization failure
-         */
-        BH1749(int bus = 0, int addr = 0x39);
-
-        /**
-         * @brief Close and free sensor
-         */
-        virtual ~BH1749();
-
-        /**
-         * @brief Enables RGB color measurement on the sensor
-         *
-         * @throws std::runtime_error if bh1749_enable() fails
-         */
-        void Enable();
-
-        /**
-         * @brief Disables RGB color measurement on the sensor
-         *
-         * @throws std::runtime_error if bh1749_disable() fails
-         */
-        void Disable();
-
-        /**
-         * @brief Check "who am I" register value to identify the sensor
-         *
-         * @throws std::runtime_error if this value is incorrect
-         */
-        void CheckWhoAmI();
-
-        /**
-         * @brief Initializes (writes) configuration values to sensor
-         *
-         * @param opMode Operating mode choice, a value of OPERATING_MODES enum
-         * @param measTime Measurement time choice, a value of MEAS_TIMES enum
-         * @param rgbGain RGB gain choice, a value of RGB_GAINS enum
-         * @param irGain IR gain choice, a value of IR_GAINS enum
-         * @param intSource interrupt source choice, a value of INT_SOURCES enum
-         *
-         * @throws std::runtime_error if one of values setting fails
-         */
-        void SensorInit(OPERATING_MODES opMode,
-                        MEAS_TIMES measTime,
-                        RGB_GAINS rgbGain,
-                        IR_GAINS irGain,
-                        INT_SOURCES intSource);
-
-        /**
-         * @brief Sets operating mode (interrupt persistance)
-         *
-         * @param opMode Operating mode choice, a value of OPERATING_MODES enum
-         * @throws std::runtime_error if writing value fails
-         */
-        void SetOperatingMode(OPERATING_MODES opMode);
-
-        /**
-         * @brief Gets operating mode (interrupt persistance) value
-         *
-         * @param opMode pointer (uint8_t) to save value
-         * @return operating mode value
-         * @throws std::runtime_error if reading the value fails
-         */
-        int GetOperatingMode();
-
-        /**
-         * @brief Sets measurement time (ODR)
-         *
-         * @param measTime measurement time choice, a value of MEAS_TIMES enum
-         * @throws std::runtime_error if writing value fails
-         */
-        void SetMeasurementTime(MEAS_TIMES measTime);
-
-        /**
-         * @brief Gets measurement time (ODR) value
-         *
-         * @return measurement time value
-         * @throws std::runtime_error if reading the value fails
-         */
-        int GetMeasurementTime();
-
-        /**
-         * @brief Sets RGB gain value
-         *
-         * @param rgbGain RGB gain choice, a value of RGB_GAINS enum
-         * @throws std::runtime_error if writing value fails
-         */
-        void SetRgbGain(RGB_GAINS rgbGain);
-
-        /**
-         * @brief Gets RGB gain value
-         *
-         * @return RGB gain value value
-         * @throws std::runtime_error if reading the value fails
-         */
-        int GetRgbGain();
-
-        /**
-         * @brief Sets IR gain value
-         *
-         * @param irGain IR gain choice, a value of IR_GAINS enum
-         * @throws std::runtime_error if writing value fails
-         */
-        void SetIrGain(IR_GAINS irGain);
-
-        /**
-         * @brief Gets IR gain value
-         *
-         * @return IR gain value value
-         * @throws std::runtime_error if reading the value fails
-         */
-        int GetIrGain();
-
-        /**
-         * @brief Sets interrupt source value
-         *
-         * @param intSource interrupt source choice, a value of INT_SOURCES enum
-         * @throws std::runtime_error if writing value fails
-         */
-        void SetIntSource(INT_SOURCES intSource);
-
-        /**
-         * @brief Gets interrupt source value
-         *
-         * @return interrupt source value
-         * @throws std::runtime_error if reading the value fails
-         */
-        char GetInterruptSourceChar();
-
-        /**
-         * @brief Enables interrupt mode
-         *
-         * @throws std::runtime_error if writing enable bit fails
-         */
-        void EnableInterrupt();
-
-        /**
-         * @brief Disables interrupt mode
-         *
-         * @throws std::runtime_error if writing disable bit fails
-         */
-        void DisableInterrupt();
-
-        /**
-         * @brief Resets interrupt status (clear) to allow new interrupt reads
-         *
-         * @throws std::runtime_error if writing reset bit fails
-         */
-        void ResetInterrupt();
-
-        /**
-         * @brief Gets interrupt status, whether interrupt is raised or not
-         *
-         * @return true if interrupt is raised, otherwise false
-         */
-        bool IsInterrupted();
-
-        /**
-         * @brief Gets interrupt mode status
-         *
-         * @return true if interrupt is enabled, otherwise false
-         */
-        bool IsInterruptEnabled();
-
-        /**
-         * @brief Initiates a software reset to the sensor. All register values
-         * will be written to their defaults, thus sensor_init() must be called
-         * after this, and thresholds also needs to be set.
-         *
-         * @throws std::runtime_error if writing reset bit fails
-         */
-        void SoftReset();
-
-        /**
-         * @brief Sets threshold high value
-         *
-         * @param threshold interrupt threshold high value, range 0-65536
-         * @throws std::runtime_error if writing value fails
-         */
-        void SetThresholdHigh(uint16_t threshold);
-
-        /**
-         * @brief Gets threshold high value
-         *
-         * @return threshold high value
-         * @throws std::runtime_error if reading the value fails
-         */
-        int GetThresholdHigh();
-
-        /**
-         * @brief Sets threshold low value
-         *
-         * @param threshold interrupt threshold low value, range 0-65536
-         * @throws std::runtime_error if writing value fails
-         */
-        void SetThresholdLow(uint16_t threshold);
-
-        /**
-         * @brief Gets threshold low value
-         *
-         * @return threshold low value
-         * @throws std::runtime_error if reading the value fails
-         */
-        int GetThresholdLow();
-
-        /**
-         * @brief Gets value of Red color channel
-         *
-         * @return red channel value
-         * @throws std::runtime_error if reading the value fails
-         */
-        uint16_t GetRed();
-
-        /**
-         * @brief Gets value of Green color channel
-         *
-         * @return green channel value
-         * @throws std::runtime_error if reading the value fails
-         */
-        uint16_t GetGreen();
-
-        /**
-         * @brief Gets value of Blue color channel
-         *
-         * @return blue channel value
-         * @throws std::runtime_error if reading the value fails
-         */
-        uint16_t GetBlue();
-
-        /**
-         * @brief Gets value of IR color channel
-         *
-         * @return ir channel value
-         * @throws std::runtime_error if reading the value fails
-         */
-        uint16_t GetIr();
-
-        /**
-         * @brief Gets value of Green2 color channel
-         *
-         * @return green2 channel value
-         * @throws std::runtime_error if reading the value fails
-         */
-        uint16_t GetGeen2();
-
-        /**
-         * @brief Gets all channels measurements values
-         *
-         * @return vector with all channels values ordered as:
-         * Red, Green, Blue, IR, Green2
-         * @throws std::runtime_error if reading one of the values fails
-         */
-        std::vector<uint16_t> GetMeasurements();
-
-        /**
-         * @brief Installs the ISR to a given GPIO pin
-         *
-         * @param edge Edge type to raise ISR with, of type mraa_gpio_edge_t
-         * @param pin GPIO pin number
-         * @param isr Pointer to ISR function
-         * @param isr_args Arguments to pass the ISR function
-         * @throws std::runtime_error if installing ISR fails
-         */
-        void InstallISR(mraa_gpio_edge_t edge, int pin, void (*isr)(void *), void *isr_args);
-
-        /**
-         * @brief Removes the ISR if it is installed
-         */
-        void RemoveISR();
-
-        /**
-         * @brief Gets a dump of configuration registers as a string
-         *
-         * @return string of dumped registers
-         * @throws std::runtime_error if reading one of the registers fails
-         */
-        std::string RegistersDump();
-
-    private:
-        bh1749_context m_bh1749;
-
-        /* Disable implicit copy and assignment operators */
-        BH1749(const BH1749 &) = delete;
-        BH1749 &operator=(const BH1749 &) = delete;
-    };
-}
\ No newline at end of file
diff --git a/src/bh1749/bh1749.i b/src/bh1749/bh1749.i
deleted file mode 100755
index 8ef0140..0000000
--- a/src/bh1749/bh1749.i
+++ /dev/null
@@ -1,18 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_bh1749)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%include "std_vector.i"
-%template(uint16Vector) std::vector<uint16_t>;
-
-%{
-#include "bh1749.hpp"
-%}
-%include "bh1749.h"
-%include "bh1749.hpp"
-/* END Common SWIG syntax */
diff --git a/src/bh1749/bh1749.json b/src/bh1749/bh1749.json
deleted file mode 100755
index 0bcb52b..0000000
--- a/src/bh1749/bh1749.json
+++ /dev/null
@@ -1,49 +0,0 @@
-{
-    "Library": "BH1749",
-    "Description": "ROHM BH1749 Color sensor (16-bit) library",
-    "Sensor Class": {
-        "BH1749": {
-            "Name": "ROHM BH1749 Color sensor (16-bit)",
-            "Description": "BH1749NUC is a digital color sensor IC with I2C bus interface. This IC senses Red, Green, Blue (RGB) and Infrared and converts them to digital values. The high sensitivity, wide dynamic range and excellent Ircut characteristics make it possible for this IC to obtain the accurate illuminance and color temperature of ambient light. It is ideal for adjusting LCD backlight of TV, mobile phone and tablet PC.",
-            "Categories": ["color sensor"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["ROHM"],
-            "Examples": {
-                "C++": ["bh1749.cxx"],
-                "C": ["bh1749.c"],
-                "Java": ["BH1749_Example.java"],
-                "Python": ["bh1749.py"],
-                "Node.js": ["bh1749.js"]
-            },
-            "Specifications": {
-                "Supply Voltage (VDD)": {
-                    "unit": "V",
-                    "min": 2.3,
-                    "max": 3.6
-                },
-                "Supply Current": {
-                    "unit": "uA",
-                    "min": 0.8,
-                    "max": 190
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                }, "Illumination Detection": {
-                    "unit" : "klx",
-                    "value": 80
-                }
-            },
-            "Urls": {
-                "Product Pages": [
-                    "https://www.rohm.com/products/sensors-mems/color-sensor-ics/bh1745nuc-product"
-                ],
-                "Datasheets": [
-                    "https://www.rohm.com/datasheet/BH1749NUC/bh1749nuc-e"
-                ]
-            }
-        }
-    }
-}
diff --git a/src/bh1749/bh1749_registers.h b/src/bh1749/bh1749_registers.h
deleted file mode 100755
index 821524c..0000000
--- a/src/bh1749/bh1749_registers.h
+++ /dev/null
@@ -1,160 +0,0 @@
-/*
-The MIT License (MIT)
-Copyright (c) 2017 Rohm Semiconductor
-
-Permission is hereby granted, free of charge, to any person obtaining a
-copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sublicense, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice shall be included
-in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-#ifndef __BH1749_REGISTERS_H__
-#define __BH1749_REGISTERS_H__
-/* registers */
-#define BH1749_REGISTER_DUMP_START 0x40
-#define BH1749_SYSTEM_CONTROL 0x40
-#define BH1749_MODE_CONTROL1 0x41
-#define BH1749_MODE_CONTROL2 0x42
-// Least significant byte of uint16 RED measurement value
-#define BH1749_RED_DATA_LSBS 0x50
-// Most significant byte of uint16 RED measurement value
-#define BH1749_RED_DATA_MSBS 0x51
-// Least significant byte of uint16 GREEN measurement value
-#define BH1749_GREEN_DATA_LSBS 0x52
-// Most significant byte of uint16 GREEN measurement value
-#define BH1749_GREEN_DATA_MSBS 0x53
-// Least significant byte of uint16 BLUE measurement value
-#define BH1749_BLUE_DATA_LSBS 0x54
-// Most significant byte of uint16 BLUE measurement value
-#define BH1749_BLUE_DATA_MSBS 0x55
-// Least significant byte of uint16 IR measurement value
-#define BH1749_IR_DATA_LSBS 0x58
-// Most significant byte of uint16 IR measurement value
-#define BH1749_IR_DATA_MSBS 0x59
-// Least significant byte of uint16 GREEN2 measurement value
-#define BH1749_GREEN2_DATA_LSBS 0x5A
-// Most significant byte of uint16 GREEN2 measurement value
-#define BH1749_GREEN2_DATA_MSBS 0x5B
-// Interrupt control register
-#define BH1749_INTERRUPT 0x60
-// Interrupt status update control register
-#define BH1749_PERSISTENCE 0x61
-// Least significant byte of interrupt threshold high level
-#define BH1749_TH_LSBS 0x62
-// Most significant byte of interrupt threshold high level
-#define BH1749_TH_MSBS 0x63
-// Least significant byte of interrupt threshold low level
-#define BH1749_TL_LSBS 0x64
-// Most significant byte of interrupt threshold low level
-#define BH1749_TL_MSBS 0x65
-#define BH1749_ID_REG 0x92
-#define BH1749_REGISTER_DUMP_END 0x92
-/* registers bits */
-// Software reset is not done
-#define BH1749_SYSTEM_CONTROL_SW_RESET_NOT_DONE (0x00 << 7)
-// Software reset is done
-#define BH1749_SYSTEM_CONTROL_SW_RESET_DONE (0x01 << 7)
-// INT pin status is not changed
-#define BH1749_SYSTEM_CONTROL_INT_NO_ACTION (0x00 << 6)
-// INT pin becomes inactive (high impedance)
-#define BH1749_SYSTEM_CONTROL_INT_RESET (0x01 << 6)
-#define BH1749_SYSTEM_CONTROL_PART_ID (0x0D << 0)
-#define BH1749_MODE_CONTROL1_RESERVED7_WRITE0 (0x00 << 7)
-#define BH1749_MODE_CONTROL1_IR_GAIN_RESERVED0 (0x00 << 5)
-#define BH1749_MODE_CONTROL1_IR_GAIN_1X (0x01 << 5)
-#define BH1749_MODE_CONTROL1_IR_GAIN_RESERVED1 (0x02 << 5)
-#define BH1749_MODE_CONTROL1_IR_GAIN_32X (0x03 << 5)
-#define BH1749_MODE_CONTROL1_RGB_GAIN_RESERVED0 (0x00 << 3)
-#define BH1749_MODE_CONTROL1_RGB_GAIN_1X (0x01 << 3)
-#define BH1749_MODE_CONTROL1_RGB_GAIN_RESERVED1 (0x02 << 3)
-#define BH1749_MODE_CONTROL1_RGB_GAIN_32X (0x03 << 3)
-// Reserved value
-#define BH1749_MODE_CONTROL1_ODR_RESERVED0 (0x00 << 0)
-// Reserved value
-#define BH1749_MODE_CONTROL1_ODR_RESERVED1 (0x01 << 0)
-// 120ms measurement time
-#define BH1749_MODE_CONTROL1_ODR_8P333 (0x02 << 0)
-// 240ms measurement time
-#define BH1749_MODE_CONTROL1_ODR_4P167 (0x03 << 0)
-// Reserved value
-#define BH1749_MODE_CONTROL1_ODR_RESERVED2 (0x04 << 0)
-// 35ms measurement time
-#define BH1749_MODE_CONTROL1_ODR_28P6 (0x05 << 0)
-// Reserved value
-#define BH1749_MODE_CONTROL1_ODR_RESERVED3 (0x06 << 0)
-// Reserved value
-#define BH1749_MODE_CONTROL1_ODR_RESERVED4 (0x07 << 0)
-#define BH1749_MODE_CONTROL2_VALID_NO (0x00 << 7)
-#define BH1749_MODE_CONTROL2_VALID_YES (0x01 << 7)
-#define BH1749_MODE_CONTROL2_RESERVED65_WRITE00 (0x00 << 5)
-#define BH1749_MODE_CONTROL2_RGB_MEASUREMENT_INACTIVE (0x00 << 4)
-#define BH1749_MODE_CONTROL2_RGB_MEASUREMENT_ACTIVE (0x01 << 4)
-#define BH1749_MODE_CONTROL2_RESERVED30_WRITE0000 (0x00 << 0)
-#define BH1749_INTERRUPT_STATUS_INACTIVE (0x00 << 7)
-#define BH1749_INTERRUPT_STATUS_ACTIVE (0x01 << 7)
-#define BH1749_INTERRUPT_RESERVED64_WRITE000 (0x00 << 4)
-// red channel
-#define BH1749_INTERRUPT_SOURCE_SELECT_RED (0x00 << 2)
-// green channel
-#define BH1749_INTERRUPT_SOURCE_SELECT_GREEN (0x01 << 2)
-// blue channel
-#define BH1749_INTERRUPT_SOURCE_SELECT_BLUE (0x02 << 2)
-// Reserved value
-#define BH1749_INTERRUPT_SOURCE_RESERVED0 (0x03 << 2)
-#define BH1749_INTERRUPT_RESERVED1_WRITE0 (0x00 << 1)
-#define BH1749_INTERRUPT_EN_DISABLE (0x00 << 0)
-#define BH1749_INTERRUPT_EN_ENABLE (0x01 << 0)
-#define BH1749_PERSISTENCE_RESERVED72_WRITE000000 (0x00 << 2)
-// Interrupt status becomes active at each measurement end.
-#define BH1749_PERSISTENCE_MODE_STATUS_ACTIVE_AFTER_MEASUREMENT (0x00 << 0)
-// Interrupt status is updated at each measurement end.
-#define BH1749_PERSISTENCE_MODE_STATUS_UPDATE_AFTER_MEASUREMENT (0x01 << 0)
-// Interrupt status is updated if 4 consecutive threshold judgements are the same
-#define BH1749_PERSISTENCE_MODE_STATUS_UPDATE_AFTER_4_SAME (0x02 << 0)
-// Interrupt status is updated if 8 consecutive threshold judgements are the same
-#define BH1749_PERSISTENCE_MODE_STATUS_UPDATE_AFTER_8_SAME (0x03 << 0)
-// Manufacturer ID
-#define BH1749_ID_REG_MANUFACTURER_ID (0xE0 << 0)
- /*registers bit masks */
-#define BH1749_SYSTEM_CONTROL_SW_RESET_MASK 0x80
-
-#define BH1749_SYSTEM_CONTROL_INT_MASK 0x40
-
-#define BH1749_SYSTEM_CONTROL_PART_MASK 0x3F
-#define BH1749_MODE_CONTROL1_RESERVED7_MASK 0x80
-#define BH1749_MODE_CONTROL1_IR_GAIN_MASK 0x60
-#define BH1749_MODE_CONTROL1_RGB_GAIN_MASK 0x18
-#define BH1749_MODE_CONTROL1_ODR_MASK 0x07
-// Measurement data update flag. Sets to 0 if MODE_CONTROL1/2 reg,
-// MODE_CONTROL2, INTERRUPT, T(H/L)_(LSB/MSB) is written or
-// MODE_CONTROL2 read. In specification named as VALID.
-#define BH1749_MODE_CONTROL2_VALID_MASK 0x80
-#define BH1749_MODE_CONTROL2_RESERVED65_MASK 0x60
-#define BH1749_MODE_CONTROL2_RGB_MEASUREMENT_MASK 0x10
-#define BH1749_MODE_CONTROL2_RESERVED30_MASK 0x0F
-#define BH1749_INTERRUPT_STATUS_MASK 0x80
-#define BH1749_INTERRUPT_RESERVED64_MASK 0x70
-#define BH1749_INTERRUPT_SOURCE_MASK 0x0C
-// Write 0
-#define BH1749_INTERRUPT_RESERVED1_MASK 0x02
-#define BH1749_INTERRUPT_EN_MASK 0x01
-#define BH1749_PERSISTENCE_RESERVED72_MASK 0xFC
-#define BH1749_PERSISTENCE_MODE_MASK 0x03
-
-#define BH1749_ID_REG_MANUFACTURER_MASK 0xFF
-#endif
-
diff --git a/src/bh1750/CMakeLists.txt b/src/bh1750/CMakeLists.txt
deleted file mode 100644
index 0ffc6ea..0000000
--- a/src/bh1750/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME bh1750
-    DESCRIPTION "Digital Light Sensor"
-    C_HDR bh1750.h bh1750_defs.h
-    C_SRC bh1750.c
-    CPP_HDR bh1750.hpp
-    CPP_SRC bh1750.cxx
-    FTI_SRC bh1750_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/bh1750/bh1750.c b/src/bh1750/bh1750.c
deleted file mode 100644
index a539076..0000000
--- a/src/bh1750/bh1750.c
+++ /dev/null
@@ -1,307 +0,0 @@
-/*
- * Authors: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <stdio.h>
-#include <assert.h>
-
-#include "bh1750.h"
-#include "upm_utilities.h"
-
-bh1750_context bh1750_init(int bus, uint8_t addr, BH1750_OPMODES_T mode)
-{
-  // make sure MRAA is initialized
-  int mraa_rv;
-  if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-  {
-      printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-      return NULL;
-  }
-
-  bh1750_context dev =
-    (bh1750_context)malloc(sizeof(struct _bh1750_context));
-
-  if (!dev)
-    {
-      printf("%s: context allocation failed.\n", __FUNCTION__);
-
-      return NULL;
-    }
-
-  dev->bus = bus;
-  dev->is_continuous = false;
-
-  // init the i2c context
-  if (!(dev->i2c = mraa_i2c_init(dev->bus)))
-    {
-      printf("%s: mraa_i2c_init failed.\n", __FUNCTION__);
-      free(dev);
-
-      return NULL;
-    }
-
-  // now check the address...
-  if (mraa_i2c_address(dev->i2c, addr) != MRAA_SUCCESS)
-    {
-      printf("%s: mraa_i2c_address failed.\n", __FUNCTION__);
-
-      bh1750_close(dev);
-
-      return NULL;
-    }
-
-  // set the mode
-  if (bh1750_set_opmode(dev, mode) != UPM_SUCCESS)
-    {
-      printf("%s: bh1750_set_mode failed.\n", __FUNCTION__);
-
-      bh1750_close(dev);
-
-      return NULL;
-    }
-
-  return dev;
-}
-
-void bh1750_close(const bh1750_context dev)
-{
-  assert(dev != NULL);
-
-  if (dev->i2c)
-    mraa_i2c_stop(dev->i2c);
-
-  free(dev);
-}
-
-upm_result_t bh1750_get_lux(const bh1750_context dev, float* lux)
-{
-  assert(dev != NULL);
-
-  // from the datasheet, page 7
-  static const float coeff = 1.2;
-
-  uint16_t raw_lux = 0;
-
-  upm_result_t rv;
-  if ((rv = bh1750_read_data(dev, &raw_lux)) != UPM_SUCCESS)
-    {
-      printf("%s: bh1750_read_data failed.\n", __FUNCTION__);
-
-      return rv;
-    }
-
-  *lux = (float)raw_lux;
-  *lux /= coeff;
-
-  return rv;
-}
-
-bool bh1750_power_up(const bh1750_context dev)
-{
-  assert(dev != NULL);
-  
-  if (bh1750_send_command(dev, BH1750_CMD_POWER_UP))
-    {
-      printf("%s: bh1750_send_command failed.\n", __FUNCTION__);
-      
-      return false;
-    }
-
-  return true;
-}
-  
-bool bh1750_power_down(const bh1750_context dev)
-{
-  assert(dev != NULL);
-  
-  if (bh1750_send_command(dev, BH1750_CMD_POWER_DOWN))
-    {
-      printf("%s: bh1750_send_command failed.\n", __FUNCTION__);
-      
-      return false;
-    }
-
-  return true;
-}
-
-bool bh1750_reset(const bh1750_context dev)
-{
-  assert(dev != NULL);
-  
-  if (bh1750_send_command(dev, BH1750_CMD_RESET))
-    {
-      printf("%s: bh1750_send_command failed.\n", __FUNCTION__);
-      
-      return false;
-    }
-
-  return true;
-}
-
-upm_result_t bh1750_send_command(const bh1750_context dev, uint8_t cmd)
-{
-  assert(dev != NULL);
-
-  if (mraa_i2c_write_byte(dev->i2c, cmd))
-    {
-      printf("%s: mraa_i2c_write_byte failed.\n", __FUNCTION__);
-      
-      return UPM_ERROR_OPERATION_FAILED;
-    }
-
-  return UPM_SUCCESS;
-}
-
-upm_result_t bh1750_read_data(const bh1750_context dev, uint16_t* data)
-{
-  assert(dev != NULL);
-
-  // if we are in a non-continuous mode, we need to power up the
-  // device and send the measurement mode command we are interested
-  // in.  After the measurement has been read, the device will then
-  // power down again.
-
-  if (!dev->is_continuous)
-    {
-      // power up
-      if (!bh1750_power_up(dev))
-        {
-          printf("%s: bh1750_power_up failed.\n", __FUNCTION__);
-          
-          return UPM_ERROR_OPERATION_FAILED;
-        }
-
-      // send the command, and delay appropriately
-      if (bh1750_send_command(dev, dev->opmode))
-        {
-          printf("%s: bh1750_send_command failed.\n", __FUNCTION__);
-          
-          return UPM_ERROR_OPERATION_FAILED;
-        }
-
-      upm_delay_ms(dev->delayms);
-    }
-
-  // now get our data...
-  const int num_bytes = 2;
-  uint8_t bytes[num_bytes];
-
-  int bytes_read = 0;
-  if ((bytes_read = mraa_i2c_read(dev->i2c, bytes, num_bytes)) != num_bytes)
-    {
-      printf("%s: mraa_i2c_read failed.\n", __FUNCTION__);
-      
-      return UPM_ERROR_NO_DATA;
-    }
-
-  // uncompensated, raw data
-  *data = (bytes[0] << 8) | bytes[1];
-
-  return UPM_SUCCESS;
-}
-
-upm_result_t bh1750_set_opmode(const bh1750_context dev,
-                               BH1750_OPMODES_T mode)
-{
-  assert(dev != NULL);
-
-  switch(mode)
-    {
-    case BH1750_OPMODE_H1_CONT:
-      dev->is_continuous = true;
-      dev->delayms = BH1750_MAX_MEAS_TIME_H;
-      dev->opmode = BH1750_CMD_CONT_H_RES_MODE1;
-      break;
-
-    case BH1750_OPMODE_H2_CONT:
-      dev->is_continuous = true;
-      dev->delayms = BH1750_MAX_MEAS_TIME_H;
-      dev->opmode = BH1750_CMD_CONT_H_RES_MODE2;
-      break;
-
-    case BH1750_OPMODE_H1_ONCE:
-      dev->is_continuous = false;
-      dev->delayms = BH1750_MAX_MEAS_TIME_H;
-      dev->opmode = BH1750_CMD_ONETIME_H_RES_MODE1;
-      break;
-
-    case BH1750_OPMODE_H2_ONCE:
-      dev->is_continuous = false;
-      dev->delayms = BH1750_MAX_MEAS_TIME_H;
-      dev->opmode = BH1750_CMD_ONETIME_H_RES_MODE2;
-      break;
-
-    case BH1750_OPMODE_L_CONT:
-      dev->is_continuous = true;
-      dev->delayms = BH1750_MAX_MEAS_TIME_L;
-      dev->opmode = BH1750_CMD_CONT_L_RES_MODE;
-      break;
-
-    case BH1750_OPMODE_L_ONCE:
-      dev->is_continuous = false;
-      dev->delayms = BH1750_MAX_MEAS_TIME_L;
-      dev->opmode = BH1750_CMD_ONETIME_L_RES_MODE;
-      break;
-
-    default:
-      printf("%s: Invalid mode.\n", __FUNCTION__);
-      return UPM_ERROR_INVALID_PARAMETER;
-    }
-
-  // If we are in a continuous mode, power on the device and start
-  // measuring.
-  
-  if (dev->is_continuous)
-    {
-      if (!bh1750_power_up(dev))
-        {
-          printf("%s: bh1750_power_up failed.\n", __FUNCTION__);
-          
-          return UPM_ERROR_OPERATION_FAILED;
-        }
-
-      if (bh1750_send_command(dev, dev->opmode))
-        {
-          printf("%s: bh1750_send_command failed.\n", __FUNCTION__);
-          
-          return UPM_ERROR_OPERATION_FAILED;
-        }
-
-      upm_delay_ms(dev->delayms);
-    }
-  else
-    {
-      // if we are not in a continuous mode, power the device off
-      if (!bh1750_power_down(dev))
-        {
-          printf("%s: bh1750_power_down failed.\n", __FUNCTION__);
-          
-          return UPM_ERROR_OPERATION_FAILED;
-        }
-    }
-
-  return UPM_SUCCESS;
-}
-
-
-
diff --git a/src/bh1750/bh1750.cxx b/src/bh1750/bh1750.cxx
deleted file mode 100644
index 112e2f6..0000000
--- a/src/bh1750/bh1750.cxx
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <stdexcept>
-
-#include "bh1750.hpp"
-
-using namespace upm;
-using namespace std;
-
-BH1750::BH1750(int bus, int addr, BH1750_OPMODES_T mode) :
-  m_bh1750(bh1750_init(bus, addr, mode))
-{
-  if (!m_bh1750)
-    throw std::runtime_error(string(__FUNCTION__) +
-                             ": bh1750_init() failed");
-}
-
-BH1750::~BH1750()
-{
-  bh1750_close(m_bh1750);
-}
-
-void BH1750::reset()
-{
-  bh1750_reset(m_bh1750);
-}
-
-float BH1750::getLux()
-{
-  float lux = 0.0;
-
-  if (bh1750_get_lux(m_bh1750, &lux) != UPM_SUCCESS)
-    throw std::runtime_error(string(__FUNCTION__) +
-                             ": bh1750_get_lux() failed");
-
-  return lux;
-}
-
-void BH1750::powerUp()
-{
-  if (bh1750_power_up(m_bh1750) != UPM_SUCCESS)
-    throw std::runtime_error(string(__FUNCTION__) +
-                             ": bh1750_power_up() failed");
-}
-
-void BH1750::powerDown()
-{
-  if (bh1750_power_down(m_bh1750) != UPM_SUCCESS)
-    throw std::runtime_error(string(__FUNCTION__) +
-                             ": bh1750_power_down() failed");
-}
-
-void BH1750::setOpmode(BH1750_OPMODES_T mode)
-{
-  if (bh1750_set_opmode(m_bh1750, mode) != UPM_SUCCESS)
-    throw std::runtime_error(string(__FUNCTION__) +
-                             ": bh1750_set_opmode() failed");
-}
-
-void BH1750::sendCommand(uint8_t cmd)
-{
-  if (bh1750_send_command(m_bh1750, cmd) != UPM_SUCCESS)
-    throw std::runtime_error(string(__FUNCTION__) +
-                             ": bh1750_send_command() failed");
-}
-
-uint16_t BH1750::readData()
-{
-  uint16_t data = 0;
-
-  if (bh1750_read_data(m_bh1750, &data) != UPM_SUCCESS)
-    throw std::runtime_error(string(__FUNCTION__) +
-                             ": bh1750_read_data() failed");
-
-  return data;
-}
diff --git a/src/bh1750/bh1750.h b/src/bh1750/bh1750.h
deleted file mode 100644
index 9a54001..0000000
--- a/src/bh1750/bh1750.h
+++ /dev/null
@@ -1,145 +0,0 @@
-/*
- * Authors: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <stdint.h>
-
-#include "mraa/i2c.h"
-
-#include "upm.h"
-#include "upm_types.h"
-
-#include "bh1750_defs.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif // __cplusplus
-
-/**
- * @file bh1750.h
- * @library bh1750
- * @brief C API for the BH1750 Light Sensor
- *
- * @include bh1750.c
- */
-
-/**
- * device context
- */
-typedef struct _bh1750_context
-{
-  int                 bus;
-  mraa_i2c_context    i2c;
-
-  // these are set by bh1750_set_opmode()
-  uint8_t             opmode;
-  bool                is_continuous;
-  int                 delayms;
-} *bh1750_context;
-
-/**
- * Initialize the BH1750
- *
- * @param bus I2C bus
- * @param addr I2C address
- * @param mode operating mode, one of the BH1750_OPMODES_T values
- * @return bh1750_context for the new device context
- */
-bh1750_context bh1750_init(int bus, uint8_t addr, BH1750_OPMODES_T mode);
-
-/**
- * Sensor destructor function.  Frees any allocated resources.
- *
- * @param dev The device context
- */
-void bh1750_close(const bh1750_context dev);
-
-/**
- * Gets the Lux value.
- *
- * @param dev The device context
- * @param lux float pointer in which to store the lux value
- * @return upm_result_t UPM success/error code
- */
-upm_result_t bh1750_get_lux(const bh1750_context dev, float* lux);
-
-/**
- * Power up the device.
- *
- * @param dev The device context
- * @return true if the command was successful, false otherwise
- */
-bool bh1750_power_up(const bh1750_context dev);
-
-/**
- * Power down the device.
- *
- * @param dev The device context
- * @return true if the command was successful, false otherwise
- */
-bool bh1750_power_down(const bh1750_context dev);
-
-/**
- * Reset the device.  This doesn't really have much purpose.  The
- * device must be powered up for this command to work.  In addition,
- * this command will simply clear the measurement register to 0.
- *
- * @param dev The device context
- * @return true if the command was successful, false otherwise
- */
-bool bh1750_reset(const bh1750_context dev);
-
-/**
- * Write a command to the device via I2C.
- *
- * @param dev The device context
- * @param cmd The command to write, one of the BH1750_CMD* values
- * @return upm_result_t UPM success/error code
- */
-upm_result_t bh1750_send_command(const bh1750_context dev, uint8_t cmd);
-
-/**
- * Read the 2 result bytes from the device via I2C.
- *
- * @param dev The device context
- * @param data Data read in from the device as a uint16_t
- * @return upm_result_t UPM success/error code
- */
-upm_result_t bh1750_read_data(const bh1750_context dev, uint16_t* data);
-
-/**
- * Setup the device context parameters and the device to match the
- * selected operating mode.
- *
- * @param dev The device context
- * @param mode operating mode, one of the BH1750_OPMODES_T values
- * @return upm_result_t UPM success/error code
- */
-upm_result_t bh1750_set_opmode(const bh1750_context dev,
-                               BH1750_OPMODES_T mode);
-
-#ifdef __cplusplus
-}
-#endif // __cplusplus
diff --git a/src/bh1750/bh1750.hpp b/src/bh1750/bh1750.hpp
deleted file mode 100644
index d915967..0000000
--- a/src/bh1750/bh1750.hpp
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <iostream>
-
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-
-#include "bh1750.h"
-
-namespace upm {
-    /**
-     * @brief BH1750 Light Sensor
-     * @defgroup bh1750 libupm-bh1750
-     * @ingroup rohm dfrobot i2c
-     */
-
-    /**
-     * @library bh1750
-     * @sensor bh1750
-     * @comname Digital Light Sensor
-     * @type light
-     * @man rohm dfrobot
-     * @con i2c
-     * @web http://www.dfrobot.com/index.php?route=product/product&product_id=531
-     *
-     * @brief UPM C API for the DFRobot I2C BH1750 Light Sensor
-     *
-     * This driver was developed with the DFRobot Light Sensor based on
-     * the BH1750.  It has a sensitivity of .5 10 65535 Lux.  It supports
-     * voltages from 3-5vdc and is connected via I2C.
-     *
-     * @snippet bh1750.cxx Interesting
-     */
-
-  class BH1750 {
-  public:
-
-    /**
-     * BH1750 object constructor (Analog mode)
-     *
-     * @param bus The I2C bus to use
-     * @param addr The I2C address of the device
-     * @param mode The mode to start operation under.  One of the
-     * BH1750_OPMODES_T values.  The default is the highest precision,
-     * lowest power mode.
-     */
-    BH1750(int bus=BH1750_DEFAULT_I2C_BUS, int addr=BH1750_DEFAULT_I2C_ADDR,
-           BH1750_OPMODES_T mode=BH1750_OPMODE_H2_ONCE);
-
-    /**
-     * BH1750 object destructor
-     */
-    ~BH1750();
-
-    /**
-     * Reset the device.  This doesn't really have much purpose.  The
-     * device must be powered up for this command to work.  In
-     * addition, this command will simply clear the measurement
-     * register to 0.
-     */
-    void reset();
-
-    /**
-     * Get the measured light intensity in Lux.
-     *
-     * @return The measured light intensity in Lux.
-     */
-    float getLux();
-
-    /**
-     * Power up the device.
-     */
-    void powerUp();
-
-    /**
-     * Power down the device.
-     */
-    void powerDown();
-
-    /**
-     * Setup the device to match the selected operating mode.
-     *
-     * @param mode operating mode, one of the BH1750_OPMODES_T values
-     */
-    void setOpmode(BH1750_OPMODES_T mode);
-
-  protected:
-    // bh1750 device context
-    bh1750_context m_bh1750;
-
-    /**
-     * Sends a command to the device via I2C.
-     *
-     * @param cmd The command to write, one of the BH1750_CMD* values
-     */
-    void sendCommand(uint8_t cmd);
-
-    /**
-     * Read the 2 result bytes from the device via I2C.
-     *
-     * @return Data read in from the device as a uint16_t
-     */
-    uint16_t readData();
-
-  private:
-    /* Disable implicit copy and assignment operators */
-    BH1750(const BH1750&) = delete;
-    BH1750 &operator=(const BH1750&) = delete;
-  };
-}
diff --git a/src/bh1750/bh1750.i b/src/bh1750/bh1750.i
deleted file mode 100644
index e5778e8..0000000
--- a/src/bh1750/bh1750.i
+++ /dev/null
@@ -1,16 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_bh1750)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "bh1750_defs.h"
-#include "bh1750.hpp"
-%}
-%include "bh1750_defs.h"
-%include "bh1750.hpp"
-/* END Common SWIG syntax */
diff --git a/src/bh1750/bh1750.json b/src/bh1750/bh1750.json
deleted file mode 100644
index a070369..0000000
--- a/src/bh1750/bh1750.json
+++ /dev/null
@@ -1,50 +0,0 @@
-{
-    "Library": "bh1750",
-    "Description": "DFRobot BH1750 light intensity sensor library",
-    "Sensor Class": {
-        "BH1750": {
-            "Name": "DFRobot BH1750 light intensity sensor",
-            "Description": "This is the UPM Module for the DFRobot bh1750 light intensity sensor. This sensor outputs light level data directly in Lux(Lx), eliminating complicated voltage calculations from your program. Offers a large range of Lx sensativity, with high resolution and i2c communication.",
-            "Aliases": ["bh1750", "DFRobot - Light Sensor - BH1750"],
-            "Categories": ["light"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping", "industrial", "commercial"],
-            "Manufacturers": ["DFRobot", "Rohm"],
-            "Examples": {
-                "Java": ["BH1750_Example.java"],
-                "Python": ["bh1750.py"],
-                "Node.js": ["bh1750.js"],
-                "C++": ["bh1750.cxx"],
-                "C": ["bh1750.c"]
-            },
-            "Specifications": {
-                "Vdd": {
-                    "unit": "V",
-                    "min": 3,
-                    "max": 5
-                },
-                "Supply Current Digital": {
-                    "Normal mode": {
-                        "unit": "uA",
-                        "typ": "120",
-                        "max": "190"
-                    }
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Detection Range": {
-                    "unit": "Lux",
-                    "min" : 1,
-                    "max" : 65535
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.dfrobot.com/product-531.html"],
-                "Datasheets": ["http://image.dfrobot.com/image/data/SEN0097/BH1750FVI.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/bh1750/bh1750_defs.h b/src/bh1750/bh1750_defs.h
deleted file mode 100644
index 54ff198..0000000
--- a/src/bh1750/bh1750_defs.h
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Authors: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#ifdef __cplusplus
-extern "C" {
-#endif // __cplusplus
-
-#define BH1750_DEFAULT_I2C_BUS              0
-#define BH1750_DEFAULT_I2C_ADDR             0x23
-
-// BH1750 commands
-
-#define BH1750_CMD_POWER_DOWN               0x00
-#define BH1750_CMD_POWER_UP                 0x01
-
-#define BH1750_CMD_RESET                    0x07
-
-// continuous modes
-#define BH1750_CMD_CONT_H_RES_MODE1         0x10 // 1 lx resolution
-#define BH1750_CMD_CONT_H_RES_MODE2         0x11 // .5 lx resolution
-#define BH1750_CMD_CONT_L_RES_MODE          0x13 // 4 lx resolution
-
-// one-time modes
-#define BH1750_CMD_ONETIME_H_RES_MODE1      0x20
-#define BH1750_CMD_ONETIME_H_RES_MODE2      0x21
-#define BH1750_CMD_ONETIME_L_RES_MODE       0x23
-
-// max measurement time in ms (for H modes)
-#define BH1750_MAX_MEAS_TIME_H              180
-
-// max measurement time in ms (for L modes)
-#define BH1750_MAX_MEAS_TIME_L              30
-
-// an enum for the operating mode to pass to init
-    typedef enum {
-        BH1750_OPMODE_H1_CONT, // continuous 1 lx high resolution
-        BH1750_OPMODE_H2_CONT, // continuous .5 lx high resolution
-        BH1750_OPMODE_L_CONT,  // continuous 4 lx low resolution
-        BH1750_OPMODE_H1_ONCE, // onetime 1 lx high resolution
-        BH1750_OPMODE_H2_ONCE, // onetime .5 lx high resolution
-        BH1750_OPMODE_L_ONCE,  // onetime 4 lx low resolution
-    } BH1750_OPMODES_T;
-
-#ifdef __cplusplus
-}
-#endif // __cplusplus
diff --git a/src/bh1750/bh1750_fti.c b/src/bh1750/bh1750_fti.c
deleted file mode 100644
index f908e44..0000000
--- a/src/bh1750/bh1750_fti.c
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- * Authors: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "bh1750.h"
-
-#include "upm_fti.h"
-
-/**
- * This file implements the Function Table Interface (FTI) for this device
- */
-
-
-// our descriptor data
-
-static const char upm_bh1750_name[] = "BH1750";
-static const char upm_bh1750_description[] = "DFRobot Digital Light Sensor";
-static const upm_protocol_t upm_bh1750_protocol[] = {UPM_I2C};
-static const upm_sensor_t upm_bh1750_category[] = {UPM_LIGHT};
-
-// Forward declarations
-void *upm_bh1750_init_name();
-void upm_bh1750_close(void* dev);
-upm_result_t upm_bh1750_get_lux(const void* dev, float* lux);
-
-static const upm_sensor_descriptor_t usd = {
-  .name = upm_bh1750_name,
-  .description = upm_bh1750_description,
-  .protocol_size = 1,
-  .protocol = upm_bh1750_protocol,
-  .category_size = 1,
-  .category = upm_bh1750_category,
-};
-  
-const upm_sensor_descriptor_t upm_bh1750_get_descriptor()
-{
-  return usd;
-}
-
-// our generic sensor FT
-static const upm_sensor_ft generic_ft =
-{
-  .upm_sensor_init_name = upm_bh1750_init_name,
-  .upm_sensor_close = upm_bh1750_close,
-  .upm_sensor_get_descriptor = upm_bh1750_get_descriptor,
-};
-
-// our generic light FT
-static const upm_light_ft light_ft =
-{
-  .upm_light_get_value = upm_bh1750_get_lux,
-};
-
-const void *upm_bh1750_get_ft(upm_sensor_t sensor_type)
-{
-  switch (sensor_type)
-    {
-    case UPM_SENSOR:
-      return &generic_ft;
-      
-    case UPM_LIGHT:
-      return &light_ft;
-      
-    default:
-      return NULL;
-    }
-}
-
-void *upm_bh1750_init_name()
-{
-  // not implemented, for now call the driver init
-  printf("init_name not implemented, calling bh1750_init() with defaults\n");
-  return bh1750_init(BH1750_DEFAULT_I2C_BUS, BH1750_DEFAULT_I2C_ADDR,
-                     BH1750_OPMODE_H2_ONCE);
-}
-
-void upm_bh1750_close(void* dev)
-{
-  bh1750_close((bh1750_context)dev);
-}
-
-// sensor specific
-
-upm_result_t upm_bh1750_get_lux(const void* dev, float* lux)
-{
-  return bh1750_get_lux((bh1750_context)dev, lux);
-}
-
-
-
-
-
diff --git a/src/bh1792/CMakeLists.txt b/src/bh1792/CMakeLists.txt
deleted file mode 100755
index 38cfd6a..0000000
--- a/src/bh1792/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-upm_mixed_module_init (NAME bh1792
-    DESCRIPTION "ROHM Color Sensor"
-    C_HDR bh1792.h bh1792glc_registers.h
-    C_SRC bh1792.c
-    CPP_HDR bh1792.hpp
-    CPP_SRC bh1792.cxx
-    CPP_WRAPS_C
-    REQUIRES mraa)
diff --git a/src/bh1792/bh1792.c b/src/bh1792/bh1792.c
deleted file mode 100755
index 810fb5f..0000000
--- a/src/bh1792/bh1792.c
+++ /dev/null
@@ -1,889 +0,0 @@
-/*
-* The MIT License (MIT)
-*
-* Author: Assam Boudjelthia
-* Copyright (c) 2018 Rohm Semiconductor.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy of
-* this software and associated documentation files (the "Software"), to deal in
-* the Software without restriction, including without limitation the rights to
-* use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-* the Software, and to permit persons to whom the Software is furnished to do so,
-* subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in all
-* copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-* COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-#include <stdio.h>
-#include "bh1792.h"
-
-/**
- * @brief Reads the value of a register
- *
- * @param dev The sensor context
- * @param reg Register address
- * @param data Pointer of uint8_t to save register value
- * @return UPM result
- */
-static upm_result_t bh1792_read_register(bh1792_context dev, uint8_t reg,
-                                            uint8_t *data);
-
-/**
- * @brief Reads the values of a set of registers
- *
- * @param dev The sensor context
- * @param reg Register address
- * @param data Pointer of uint8_t to save registers values
- * @return UPM result
- */
-static upm_result_t bh1792_read_registers(bh1792_context dev, uint8_t reg,
-                                            uint8_t *data, uint8_t len);
-
-/**
- * @brief Writes a value to a register
- *
- * @param dev The sensor context
- * @param value Value to write
- * @param reg Register address
- * @return UPM result
- */
-static upm_result_t bh1792_write_register(bh1792_context dev, uint8_t value,
-                                            uint8_t reg);
-
-/**
- * @brief Sets a bit on in a register with a bit mask
- *
- * @param dev The sensor context
- * @param reg Register address
- * @param bit_mask Mask to use
- * @return UPM result
- */
-static upm_result_t bh1792_set_bit_on(bh1792_context dev, uint8_t reg,
-                                        uint8_t bit_mask);
-
-/**
- * @brief Sets a bit off in a register with a bit mask
- *
- * @param dev The sensor context
- * @param reg Register address
- * @param bit_mask Mask to use
- * @return UPM result
- */
-static upm_result_t bh1792_set_bit_off(bh1792_context dev, uint8_t reg,
-                                        uint8_t bit_mask);
-
-/**
- * @brief Sets the value of a register as a given pattern with a bit mask
- *
- * @param dev The sensor context
- * @param reg Register address
- * @param value Value to write
- * @param bit_mask Mask to use
- * @return UPM result
- */
-static upm_result_t bh1792_set_bits_with_mask(bh1792_context dev, uint8_t reg,
-                                            uint8_t value, uint8_t bit_mask);
-
-/**
- * @brief Writes sync bit each 1 second. This function is used in a thread.
- *
- * @param dev The sensor context
- */
-static void *bh1792_sync_measurement(void *args);
-
-/**
- * @brief Sets the measurement time for synchronized mode
- *
- * @param dev The sensor context
- * @param meas_mode Measurement mode choice, take a value of MEAS_MODES
- * @return UPM result
- */
-static upm_result_t bh1792_set_sync_meas_mode(bh1792_context dev, uint16_t meas_freq);
-
-/**
- * @brief Selects the LED light type to use for measurement
- *
- * @param dev The sensor context
- * @param led_type Can take a value of GREEN or IR
- * @return UPM result
- */
-static upm_result_t bh1792_select_led_type(bh1792_context dev, LED_TYPES led_type);
-
-/**
- * @brief Sets the interrupt mode to be used, this is called when choosing
- * operation mode
- *
- * @param dev The sensor context
- * @param int_mode Interrupt mode, one of INTERRUPT_MODES values
- * @return UPM result
- */
-static upm_result_t bh1792_set_interrupt_mode(bh1792_context dev, INTERRUPT_MODES int_mode);
-
-/**
- * @brief Sets the RDY bit of the sensor
- *
- * @param dev The sensor context
- * @return UPM result
- */
-static upm_result_t bh1792_set_rdy_bit(bh1792_context dev);
-
-
-static upm_result_t bh1792_read_register(bh1792_context dev, uint8_t reg,
-                                            uint8_t *data)
-{
-    if(!dev)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t value = mraa_i2c_read_byte_data(dev->i2c, reg);
-    if(value < 0) {
-        printf("%s: mraa_i2c_read_byte_data() failed\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    *data = value;
-    return UPM_SUCCESS;
-}
-
-static upm_result_t bh1792_read_registers(bh1792_context dev, uint8_t reg,
-                                            uint8_t *data, uint8_t len)
-{
-    if(!dev)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t value;
-
-    for(int i = 0; i < len; i++) {
-        if(bh1792_read_register(dev, reg + i, &value) != UPM_SUCCESS) {
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-
-        *(data + i) = value;
-    }
-
-    return UPM_SUCCESS;
-}
-
-static upm_result_t bh1792_write_register(bh1792_context dev, uint8_t value,
-                                            uint8_t reg)
-{
-    if(!dev)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if (mraa_i2c_write_byte_data(dev->i2c, value, reg) != MRAA_SUCCESS) {
-        printf("%s: mraa_i2c_write_byte_data() failed\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-static upm_result_t bh1792_set_bit_on(bh1792_context dev, uint8_t reg,
-                                        uint8_t bit_mask)
-{
-    if(!dev)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t reg_value;
-    int status;
-
-    status = bh1792_read_register(dev, reg, &reg_value);
-    if(status < 0) {
-        printf("%s: Failed to read register 0x%2X\n", __FUNCTION__, reg);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    reg_value |= bit_mask;
-    return bh1792_write_register(dev, reg_value, reg);
-}
-
-static upm_result_t bh1792_set_bit_off(bh1792_context dev, uint8_t reg,
-                                        uint8_t bit_mask)
-{
-    if(!dev)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t reg_value;
-    int status;
-
-    status = bh1792_read_register(dev, reg, &reg_value);
-    if(status < 0) {
-        printf("%s: Failed to read register 0x%2X\n", __FUNCTION__, reg);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    reg_value &= ~bit_mask;
-    return bh1792_write_register(dev, reg_value, reg);
-}
-
-static upm_result_t bh1792_set_bits_with_mask(bh1792_context dev, uint8_t reg,
-                                            uint8_t value, uint8_t bit_mask)
-{
-    if(!dev)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t reg_value;
-    int status;
-
-    status = bh1792_read_register(dev, reg, &reg_value);
-    if(status < 0) {
-        printf("%s: Failed to read register 0x%2X\n", __FUNCTION__, reg);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    reg_value &= ~bit_mask;
-    reg_value |= value;
-    return bh1792_write_register(dev, reg_value, reg);
-}
-
-bh1792_context bh1792_init(int bus, int addr)
-{
-    bh1792_context dev = (bh1792_context)malloc(sizeof(struct _bh1792_context));
-    if (!dev)
-        return NULL;
-
-    dev->i2c = NULL;
-    dev->interrupt = NULL;
-
-    if (mraa_init() != MRAA_SUCCESS) {
-        printf("%s: mraa_init() failed.\n", __FUNCTION__);
-        bh1792_close(dev);
-        return NULL;
-    }
-
-    if (!(dev->i2c = mraa_i2c_init(bus))) {
-        printf("%s: mraa_i2c_init() failed.\n", __FUNCTION__);
-        bh1792_close(dev);
-        return NULL;
-    }
-
-    if (mraa_i2c_address(dev->i2c, addr)) {
-        printf("%s: mraa_i2c_address() failed.\n", __FUNCTION__);
-        bh1792_close(dev);
-        return NULL;
-    }
-
-    if(bh1792_check_who_am_i(dev) != UPM_SUCCESS)
-        return NULL;
-
-    dev->enabled = false;
-    dev->isrEnabled = false;
-    dev->sync_thread_alive = false;
-
-    return dev;
-}
-
-void bh1792_close(bh1792_context dev)
-{
-    if(dev) {
-        bh1792_stop_measurement(dev);
-        if(dev->isrEnabled)
-            bh1792_remove_isr(dev);
-
-        if (dev->i2c)
-            mraa_i2c_stop(dev->i2c);
-
-        if(dev->sync_thread_alive) {
-            dev->sync_thread_alive = false;
-            pthread_join(dev->sync_thread, NULL);
-        }
-
-        free(dev);
-    }
-}
-
-upm_result_t bh1792_check_who_am_i(bh1792_context dev)
-{
-    if(!dev)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t who_am_i;
-    if(bh1792_read_register(dev, BH1792_MANUFACTURER_REG, &who_am_i) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if(who_am_i != BH1792_MANUFACTURER_REG_MANUFACTURER_ID) {
-        printf("%s: wrong manufacturer ID\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    if(bh1792_read_register(dev, BH1792_PARTID_REG, &who_am_i) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if(who_am_i != BH1792_PARTID_REG_PART_ID) {
-        printf("%s: wrong part ID\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-static upm_result_t bh1792_set_rdy_bit(bh1792_context dev)
-{
-    return bh1792_set_bit_on(dev, BH1792_MEAS_CONTROL1, BH1792_MEAS_CONTROL1_RDY);
-}
-
-bool bh1792_is_enabled(bh1792_context dev)
-{
-    if(!dev)
-        return false;
-
-    return dev->enabled;
-}
-
-upm_result_t bh1792_soft_reset(bh1792_context dev)
-{
-    return bh1792_set_bit_on(dev, BH1792_RESET, BH1792_RESET_SWRESET);
-}
-
-static upm_result_t bh1792_select_led_type(bh1792_context dev, LED_TYPES led_type)
-{
-    if(!dev)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t status;
-
-    if(led_type == GREEN) {
-        status = bh1792_set_bit_off(dev, BH1792_MEAS_CONTROL1,
-                                    BH1792_MEAS_CONTROL1_SEL_ADC_MASK);
-        if(status != UPM_SUCCESS)
-            return UPM_ERROR_OPERATION_FAILED;
-
-    } else {
-        if(dev->op_mode == SYNCHRONIZED) {
-            printf("%s: IR LED only for single & non-sync modes\n", __FUNCTION__);
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-
-        status = bh1792_set_bit_on(dev, BH1792_MEAS_CONTROL1,
-                                BH1792_MEAS_CONTROL1_SEL_ADC_MASK);
-        if(status != UPM_SUCCESS)
-            return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    dev->led_type = led_type;
-
-    return UPM_SUCCESS;
-}
-
-static upm_result_t bh1792_set_sync_meas_mode(bh1792_context dev, uint16_t meas_freq)
-{
-    if(!dev)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t status;
-
-    MEAS_MODES meas_mode;
-    switch(meas_freq) {
-        case 32:
-            meas_mode = MSR_32Hz;
-            break;
-        case 64:
-            meas_mode = MSR_64Hz;
-            break;
-        case 128:
-            meas_mode = MSR_128Hz;
-            break;
-        case 256:
-            meas_mode = MSR_256Hz;
-            break;
-        case 1024:
-            meas_mode = MSR_1024Hz;
-            break;
-        default:
-            return UPM_ERROR_INVALID_PARAMETER;
-    }
-
-    status = bh1792_set_bits_with_mask(dev, BH1792_MEAS_CONTROL1, meas_mode,
-                                    BH1792_MEAS_CONTROL1_MSR_MASK);
-    if(status != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-    dev->meas_freq = meas_freq;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1792_get_meas_time_ms(bh1792_context dev, float *meas_time_ms)
-{
-    if(!dev)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t meas_time_reg;
-
-    if(bh1792_read_register(dev, BH1792_MEAS_CONTROL1, &meas_time_reg) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-    switch(meas_time_reg & BH1792_MEAS_CONTROL1_MSR_MASK) {
-        case MSR_32Hz:
-            *meas_time_ms = 1000 / (float)32;
-            break;
-        case MSR_64Hz:
-            *meas_time_ms = 1000 / (float)64;
-            break;
-        case MSR_128Hz:
-            *meas_time_ms = 1000 / (float)128;
-            break;
-        case MSR_256Hz:
-            *meas_time_ms = 1000 / (float)256;
-            break;
-        case MSR_1024Hz:
-            *meas_time_ms = 1000 / (float)1024;
-            break;
-        case MSR_SINGLE:
-        case MSR_NON_SYNC:
-            *meas_time_ms = 1000 / (float)4;
-            break;
-        default:
-            return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1792_set_green_leds_current(bh1792_context dev, uint8_t current)
-{
-    if(!dev)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if(current > LED_CURRENT_MAX)
-        return UPM_ERROR_OUT_OF_RANGE;
-
-    uint8_t status;
-
-    status = bh1792_set_bits_with_mask(dev, BH1792_MEAS_CONTROL2,
-                    current & BH1792_MEAS_CONTROL2_LED_CURRENT1_MASK,
-                    BH1792_MEAS_CONTROL2_LED_CURRENT1_MASK);
-    if(status != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-    dev->green_current = current;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1792_get_green_leds_current(bh1792_context dev, uint8_t *current)
-{
-    if(!dev)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t data;
-
-    if(bh1792_read_register(dev, BH1792_MEAS_CONTROL2, &data) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    *current = data & BH1792_MEAS_CONTROL2_LED_CURRENT1_MASK;
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1792_set_ir_led_current(bh1792_context dev, uint8_t current)
-{
-    if(!dev)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if(current > LED_CURRENT_MAX)
-        return UPM_ERROR_OUT_OF_RANGE;
-
-    uint8_t status;
-
-    status = bh1792_set_bits_with_mask(dev, BH1792_MEAS_CONTROL3,
-                    current & BH1792_MEAS_CONTROL3_LED_CURRENT2_MASK,
-                    BH1792_MEAS_CONTROL3_LED_CURRENT2_MASK);
-    if(status != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-    dev->ir_current = current;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1792_get_ir_led_current(bh1792_context dev, uint8_t *current)
-{
-    if(!dev)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t data;
-
-    if(bh1792_read_register(dev, BH1792_MEAS_CONTROL3, &data) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    *current = data & BH1792_MEAS_CONTROL3_LED_CURRENT2_MASK;
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1792_set_ir_threshold(bh1792_context dev, uint16_t threshold)
-{
-    if(!dev)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if(bh1792_write_register(dev, threshold, BH1792_MEAS_CONTROL4_L) != UPM_SUCCESS ||
-        bh1792_write_register(dev, threshold >> 8, BH1792_MEAS_CONTROL4_H) != UPM_SUCCESS) {
-        printf("%s: Failed to write high threshold\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    dev->threshold = threshold;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1792_get_ir_threshold(bh1792_context dev, uint16_t *threshold)
-{
-    if(!dev)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t data[2];
-
-    if(bh1792_read_register(dev, BH1792_MEAS_CONTROL4_H, &data[1]) != UPM_SUCCESS ||
-        bh1792_read_register(dev, BH1792_MEAS_CONTROL4_L, &data[0]) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    *threshold = data[1] << 8 | data[0];
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1792_get_fifo_size(bh1792_context dev, uint8_t *count)
-{
-    if(!dev)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t fifo_count;
-
-    if(bh1792_read_register(dev, BH1792_FIFO_LEV, &fifo_count) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    *count = fifo_count & BH1792_FIFO_LEV_LEVEL_MASK;
-    return UPM_SUCCESS;
-}
-
-static upm_result_t bh1792_set_interrupt_mode(bh1792_context dev, INTERRUPT_MODES int_mode)
-{
-    if(!dev)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if(bh1792_set_bits_with_mask(dev, BH1792_MEAS_CONTROL5, int_mode,
-                            BH1792_MEAS_CONTROL5_INT_SEL_MASK) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-    dev->interrupt_mode = int_mode;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1792_disable_interrupt(bh1792_context dev)
-{
-    return bh1792_set_bits_with_mask(dev, BH1792_MEAS_CONTROL5, 0,
-                                BH1792_MEAS_CONTROL5_INT_SEL_MASK);
-}
-
-upm_result_t bh1792_clear_interrupt(bh1792_context dev)
-{
-    uint8_t data;
-    return bh1792_read_register(dev, BH1792_INT_CLEAR, &data);
-}
-
-static void *bh1792_sync_measurement(void *args)
-{
-    bh1792_context dev = (bh1792_context)args;
-
-    dev->sync_thread_alive = true;
-    while(dev->sync_thread_alive) {
-        bh1792_set_bit_on(dev, BH1792_MEAS_SYNC, BH1792_MEAS_SYNC_MEAS_SYNC);
-        usleep(ONE_SEC_IN_MIRCO_SEC);
-    }
-
-    return (void *)UPM_SUCCESS;
-}
-
-upm_result_t bh1792_start_measurement(bh1792_context dev)
-{
-    if(!dev)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if(dev->op_mode == SYNCHRONIZED) {
-        if(dev->sync_thread_alive) {
-            dev->sync_thread_alive = false;
-            pthread_join(dev->sync_thread, NULL);
-        }
-        pthread_create(&dev->sync_thread, NULL, &bh1792_sync_measurement, dev);
-    }
-
-    if(bh1792_set_bit_on(dev, BH1792_MEAS_START, BH1792_MEAS_START_MEAS_ST) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    dev->enabled = true;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1792_stop_measurement(bh1792_context dev)
-{
-    if(!dev)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if(bh1792_soft_reset(dev) != UPM_SUCCESS)
-        return UPM_SUCCESS;
-
-    dev->enabled = false;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1792_restart_measurement(bh1792_context dev)
-{
-    if(!dev)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t status;
-
-    status = bh1792_stop_measurement(dev);
-    if(status != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if(status != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    switch(dev->op_mode) {
-        case SYNCHRONIZED:
-            status = bh1792_enable_sync_mode(dev, dev->meas_freq, dev->green_current);
-            break;
-        case NON_SYNCHRONIZED:
-            status = bh1792_enable_non_sync_mode(dev, dev->ir_current, dev->threshold);
-            break;
-        case SINGLE_GREEN:
-            status = bh1792_enable_single_mode(dev, GREEN, dev->green_current);
-            break;
-        case SINGLE_IR:
-            status = bh1792_enable_single_mode(dev, IR, dev->ir_current);
-            break;
-    }
-
-    if(status != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return bh1792_start_measurement(dev);
-}
-
-upm_result_t bh1792_get_fifo_data(bh1792_context dev, uint16_t fifo_led_off[],
-                                    uint16_t fifo_led_on[])
-{
-    if(!dev)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if(dev->op_mode != SYNCHRONIZED)
-        return UPM_ERROR_NO_DATA;
-
-    uint8_t data[4];
-    for(int i = 0; i < FIFO_WATERMARK; i++) {
-        if(bh1792_read_registers(dev, BH1792_FIFO_DATA0_L, data, 4) != UPM_SUCCESS)
-            return UPM_ERROR_OPERATION_FAILED;
-
-        fifo_led_off[i] = data[1] << 8 | data[0];
-        fifo_led_on[i] = data[3] << 8 | data[2];
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1792_discard_fifo_data(bh1792_context dev)
-{
-    if(!dev)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t data[4];
-
-    for(int i = 0; i < FIFO_WATERMARK; i++)
-        bh1792_read_registers(dev, BH1792_FIFO_DATA0_L, data, 4);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1792_get_green_data(bh1792_context dev, uint16_t *green_led_off,
-                                        uint16_t *green_led_on)
-{
-    if(!dev)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if(dev->op_mode == NON_SYNCHRONIZED || dev->op_mode == SINGLE_IR)
-        return UPM_ERROR_NO_DATA;
-
-    uint8_t data[4];
-
-    if(bh1792_read_registers(dev, BH1792_DATAOUT_LEDOFF_L, data, 4) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    *green_led_off = data[1] << 8 | data[0];
-    *green_led_on = data[3] << 8 | data[2];
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1792_get_ir_data(bh1792_context dev, uint16_t *ir_led_off,
-                                        uint16_t *ir_led_on)
-{
-    if(!dev)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if(dev->op_mode != NON_SYNCHRONIZED && dev->op_mode != SINGLE_IR)
-        return UPM_ERROR_NO_DATA;
-
-    uint8_t data[4];
-
-    if(bh1792_read_registers(dev, BH1792_IRDATA_LEDOFF_L, data, 4) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    *ir_led_off = data[1] << 8 | data[0];
-    *ir_led_on = data[3] << 8 | data[2];
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1792_enable_sync_mode(bh1792_context dev, uint16_t meas_freq,
-                                        uint8_t green_current)
-{
-    if(!dev)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t status;
-
-    if(bh1792_set_rdy_bit(dev) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if(bh1792_set_green_leds_current(dev, green_current) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if(bh1792_select_led_type(dev, GREEN) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    status = bh1792_set_sync_meas_mode(dev, meas_freq);
-    if(status != UPM_SUCCESS)
-        return status;
-
-    dev->op_mode = SYNCHRONIZED;
-    return bh1792_set_interrupt_mode(dev, WATER_MARK);
-}
-
-upm_result_t bh1792_enable_non_sync_mode(bh1792_context dev, uint8_t ir_current,
-                                        uint16_t threshold)
-{
-    if(!dev)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if(bh1792_set_rdy_bit(dev) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if(bh1792_set_ir_led_current(dev, ir_current) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if(bh1792_select_led_type(dev, IR) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-    if(bh1792_set_sync_meas_mode(dev, MSR_NON_SYNC) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    dev->op_mode = NON_SYNCHRONIZED;
-    return bh1792_set_interrupt_mode(dev, IR_THRESHOLD_JUDGE);
-}
-
-upm_result_t bh1792_enable_single_mode(bh1792_context dev, LED_TYPES led_type,
-                                        uint8_t current)
-{
-    if(!dev)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if(bh1792_set_rdy_bit(dev) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if(led_type == GREEN) {
-        if(bh1792_set_green_leds_current(dev, current) != UPM_SUCCESS)
-            return UPM_ERROR_OPERATION_FAILED;
-    } else {
-        if(bh1792_set_ir_led_current(dev, current) != UPM_SUCCESS)
-            return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    if(bh1792_select_led_type(dev, led_type) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if(bh1792_set_sync_meas_mode(dev, MSR_SINGLE) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if(led_type == GREEN)
-        dev->op_mode = SINGLE_GREEN;
-    else
-        dev->op_mode = SINGLE_IR;
-
-    return bh1792_set_interrupt_mode(dev, ON_COMPLETE);
-}
-
-upm_result_t bh1792_install_isr(bh1792_context dev, mraa_gpio_edge_t edge,
-                                int pin, void (*isr)(void *), void *isr_args)
-{
-    if(!dev)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if(dev->isrEnabled)
-        bh1792_remove_isr(dev);
-
-    mraa_gpio_context isr_gpio = NULL;
-
-    if (!(isr_gpio = mraa_gpio_init(pin))) {
-        printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    mraa_gpio_dir(isr_gpio, MRAA_GPIO_IN);
-
-    if (mraa_gpio_isr(isr_gpio, edge, isr, isr_args) != MRAA_SUCCESS) {
-        mraa_gpio_close(isr_gpio);
-        printf("%s: mraa_gpio_isr() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    dev->interrupt = isr_gpio;
-    dev->isrEnabled = true;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bh1792_install_isr_falling_edge(bh1792_context dev, int pin,
-                                void (*isr)(void *), void *isr_args)
-{
-    return bh1792_install_isr(dev, MRAA_GPIO_EDGE_FALLING, pin, isr, isr_args);
-}
-
-void bh1792_remove_isr(bh1792_context dev)
-{
-    if(dev) {
-        mraa_gpio_isr_exit(dev->interrupt);
-        mraa_gpio_close(dev->interrupt);
-        dev->interrupt = NULL;
-        dev->isrEnabled = false;
-    }
-}
-
-upm_result_t bh1792_registers_dump(bh1792_context dev, char *dump)
-{
-    if(!dev)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t reg_values[10];
-    int count = 0;
-    int len = 8;
-
-    if(bh1792_read_registers(dev, BH1792_MEAS_CONTROL1, reg_values, len) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-    count += sprintf(dump, "0x41 ");
-    for(int i = 0; i < len; i++)
-        count += sprintf(dump + count, "%02X ", reg_values[i]);
-    sprintf(dump + count - 1, "\n");
-
-    len = 1;
-    if(bh1792_read_registers(dev, BH1792_FIFO_LEV, reg_values, len) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-    count += sprintf(dump + count, "0x4B ");
-    for(int i = 0; i < len; i++)
-        count += sprintf(dump + count, "%02X ", reg_values[i]);
-
-    return UPM_SUCCESS;
-}
diff --git a/src/bh1792/bh1792.cxx b/src/bh1792/bh1792.cxx
deleted file mode 100755
index 35b808a..0000000
--- a/src/bh1792/bh1792.cxx
+++ /dev/null
@@ -1,305 +0,0 @@
-/*
-* The MIT License (MIT)
-*
-* Author: Assam Boudjelthia
-* Copyright (c) 2018 Rohm Semiconductor.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy of
-* this software and associated documentation files (the "Software"), to deal in
-* the Software without restriction, including without limitation the rights to
-* use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-* the Software, and to permit persons to whom the Software is furnished to do so,
-* subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in all
-* copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-* COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-#include <iostream>
-#include <stdexcept>
-#include "bh1792.hpp"
-
-using namespace upm;
-
-BH1792::BH1792(int bus, int addr) : m_bh1792(bh1792_init(bus, addr))
-{
-    if(!m_bh1792)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1792_init() failed");
-}
-
-BH1792::~BH1792()
-{
-    bh1792_close(m_bh1792);
-}
-
-void BH1792::CheckWhoAmI()
-{
-    if(bh1792_check_who_am_i(m_bh1792) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1792_check_who_am_i() failed");
-}
-
-bool BH1792::IsEnabled()
-{
-    return bh1792_is_enabled(m_bh1792);
-}
-
-void BH1792::SoftReset()
-{
-    if(bh1792_soft_reset(m_bh1792) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1792_soft_reset() failed");
-}
-
-float BH1792::GetMeasurementTimeMS()
-{
-    float meas_time;
-
-    if(bh1792_get_meas_time_ms(m_bh1792, &meas_time) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1792_get_meas_time_ms() failed");
-
-    return meas_time;
-}
-
-void BH1792::SetGreenLedsCurrent(uint16_t current)
-{
-    uint8_t status;
-
-    status = bh1792_set_green_leds_current(m_bh1792, current);
-    if(status == UPM_ERROR_OUT_OF_RANGE) {
-        throw std::range_error(std::string(__FUNCTION__) +
-                "bh1792_set_green_leds_current() failed, current not in range");
-    } else if(status != UPM_SUCCESS) {
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1792_set_green_leds_current() failed");
-    }
-}
-
-int BH1792::GetGreenLedsCurrent()
-{
-    uint8_t current;
-
-    if(bh1792_get_green_leds_current(m_bh1792, &current) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1792_get_green_leds_current() failed");
-
-    return (int)current;
-}
-
-void BH1792::SetIrLedCurrent(uint16_t current)
-{
-    uint8_t status;
-
-    status = bh1792_set_ir_led_current(m_bh1792, current);
-    if(status == UPM_ERROR_OUT_OF_RANGE) {
-        throw std::range_error(std::string(__FUNCTION__) +
-                "bh1792_set_ir_led_current() failed, current not in range");
-    } else if(status != UPM_SUCCESS) {
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1792_set_ir_led_current() failed");
-    }
-}
-
-int BH1792::GetIrLedCurrent()
-{
-    uint8_t current;
-
-    if(bh1792_get_ir_led_current(m_bh1792, &current) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1792_get_ir_led_current() failed");
-
-    return (int)current;
-}
-
-void BH1792::SetIrThreshold(uint16_t threshold)
-{
-    if(bh1792_set_ir_threshold(m_bh1792, threshold) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1792_set_ir_threshold() failed");
-}
-
-int BH1792::GetIrThreshold()
-{
-    uint16_t threshold;
-
-    if(bh1792_get_ir_threshold(m_bh1792, &threshold) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1792_get_ir_threshold() failed");
-
-    return (int)threshold;
-}
-
-int BH1792::GetFifoSize()
-{
-    uint8_t size;
-
-    if(bh1792_get_fifo_size(m_bh1792, &size) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1792_get_fifo_size() failed");
-
-    return (int)size;
-}
-
-void BH1792::DisableInterrupt()
-{
-    if(bh1792_disable_interrupt(m_bh1792) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1792_disable_interrupt() failed");
-}
-
-void BH1792::ClearInterrupt()
-{
-    if(bh1792_clear_interrupt(m_bh1792) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1792_clear_interrupt() failed");
-}
-
-void BH1792::StartMeasurement()
-{
-    if(bh1792_start_measurement(m_bh1792) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1792_start_measurement() failed");
-}
-
-void BH1792::StopMeasurement()
-{
-    if(bh1792_stop_measurement(m_bh1792) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1792_stop_measurement() failed");
-}
-
-void BH1792::RestartMeasurement()
-{
-    if(bh1792_restart_measurement(m_bh1792) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1792_restart_measurement() failed");
-}
-
-std::vector<std::vector<int>> BH1792::GetFifoData()
-{
-    uint16_t fifo_off[FIFO_WATERMARK], fifo_on[FIFO_WATERMARK];
-
-    if(bh1792_get_fifo_data(m_bh1792, fifo_off, fifo_on) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1792_get_fifo_data() failed");
-
-    std::vector<int> item;
-    std::vector<std::vector<int>> result;
-    item.reserve(2);
-    result.reserve(FIFO_WATERMARK);
-    for(int i = 0; i < FIFO_WATERMARK; i++) {
-        item.clear();
-        item.push_back(fifo_off[i]);
-        item.push_back(fifo_on[i]);
-        result.push_back(item);
-    }
-
-    return result;
-}
-
-void BH1792::DiscardFifoData()
-{
-    if(bh1792_discard_fifo_data(m_bh1792) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1792_discard_fifo_data() failed");
-}
-
-std::vector<int> BH1792::GetGreenData()
-{
-    uint16_t green_off, green_on;
-
-    if(bh1792_get_green_data(m_bh1792, &green_off, &green_on) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1792_get_green_data() failed");
-
-    std::vector<int> result;
-    result.reserve(2);
-    result.push_back(green_off);
-    result.push_back(green_on);
-
-    return result;
-}
-
-std::vector<int> BH1792::GetIrData()
-{
-    uint16_t ir_off, ir_on;
-
-    if(bh1792_get_ir_data(m_bh1792, &ir_off, &ir_on) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1792_get_ir_data() failed");
-
-    std::vector<int> result;
-    result.reserve(2);
-    result.push_back(ir_off);
-    result.push_back(ir_on);
-
-    return result;
-}
-
-void BH1792::EnableSyncMode(uint16_t measFreq, uint16_t green_current)
-{
-    uint8_t status;
-
-    status = bh1792_enable_sync_mode(m_bh1792, measFreq, green_current);
-    if(status == UPM_ERROR_INVALID_PARAMETER) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                "bh1792_enable_sync_mode() failed, invalid measurement frequncy");
-    } else if(status != UPM_SUCCESS) {
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1792_enable_sync_mode() failed");
-    }
-}
-
-void BH1792::EnableNonSyncMode(uint16_t ir_current, uint16_t threshold)
-{
-    if(bh1792_enable_non_sync_mode(m_bh1792, ir_current, threshold) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1792_enable_non_sync_mode() failed");
-}
-
-void BH1792::EnableSingleMode(LED_TYPES led_type, uint16_t current)
-{
-    if(bh1792_enable_single_mode(m_bh1792, led_type, current) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1792_enable_single_mode() failed");
-}
-
-void BH1792::InstallISR(mraa_gpio_edge_t edge, int pin, void (*isr)(void *), void *isr_args)
-{
-    if(bh1792_install_isr(m_bh1792, edge, pin, isr, isr_args) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1792_install_isr() failed");
-}
-
-void BH1792::InstallISR(int pin, void (*isr)(void *), void *isr_args)
-{
-    if(bh1792_install_isr_falling_edge(m_bh1792, pin, isr, isr_args) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1792_install_isr_falling_edge() failed");
-}
-
-void BH1792::RemoveISR()
-{
-    bh1792_remove_isr(m_bh1792);
-}
-
-std::string BH1792::RegistersDump()
-{
-    char dump[255];
-    std::string dumpStr;
-
-    if(bh1792_registers_dump(m_bh1792, dump) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                "bh1792_registers_dump() failed");
-    dumpStr = dump;
-    return dumpStr;
-}
diff --git a/src/bh1792/bh1792.h b/src/bh1792/bh1792.h
deleted file mode 100755
index 27303dd..0000000
--- a/src/bh1792/bh1792.h
+++ /dev/null
@@ -1,411 +0,0 @@
-/*
-* The MIT License (MIT)
-*
-* Author: Assam Boudjelthia
-* Copyright (c) 2018 Rohm Semiconductor.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy of
-* this software and associated documentation files (the "Software"), to deal in
-* the Software without restriction, including without limitation the rights to
-* use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-* the Software, and to permit persons to whom the Software is furnished to do so,
-* subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in all
-* copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-* COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-#pragma once
-
-#ifdef __cplusplus
-extern "C"
-{
-#endif
-
-#include <mraa/i2c.h>
-#include <mraa/gpio.h>
-#include <unistd.h>
-#include <upm_types.h>
-#include <pthread.h>
-#include "bh1792glc_registers.h"
-
-/**
- * @file bh1792.h
- * @library bh1792
- * @brief C API for the bh1792 driver
- *
- * @include bh1792.c
- */
-
-#define ONE_SEC_IN_MIRCO_SEC 1000000
-#define FIFO_WATERMARK 32
-#define LED_CURRENT_MAX 63
-
-/**
- * @brief Measurement modes, for synchronized time modes, non synchronized
- * and single modes.
- */
-typedef enum {
-    MSR_64Hz = BH1792_MEAS_CONTROL1_MSR_64HZ,
-    MSR_32Hz = BH1792_MEAS_CONTROL1_MSR_32HZ,
-    MSR_128Hz = BH1792_MEAS_CONTROL1_MSR_128HZ,
-    MSR_256Hz = BH1792_MEAS_CONTROL1_MSR_256HZ,
-    MSR_1024Hz = BH1792_MEAS_CONTROL1_MSR_1024HZ,
-    MSR_NON_SYNC = BH1792_MEAS_CONTROL1_MSR_NON_SYNCH_MODE,
-    MSR_SINGLE = BH1792_MEAS_CONTROL1_MSR_SINGLE_MEAS_MODE
-} MEAS_MODES;
-
-/**
- * @brief LED light types
- */
-typedef enum {
-    GREEN,
-    IR
-} LED_TYPES;
-
-/**
- * @brief Interrupt modes of the sensor
- */
-typedef enum {
-    WATER_MARK = BH1792_MEAS_CONTROL5_INT_SEL_FIFO_WATERMARK,
-    IR_THRESHOLD_JUDGE = BH1792_MEAS_CONTROL5_INT_SEL_IR_THRESHOLD,
-    ON_COMPLETE = BH1792_MEAS_CONTROL5_INT_SEL_ON_COMPLETE
-} INTERRUPT_MODES;
-
-/**
- * @brief Operations modes available with the sensor
- */
-typedef enum {
-    SYNCHRONIZED,
-    NON_SYNCHRONIZED,
-    SINGLE_GREEN,
-    SINGLE_IR
-} OP_MODES;
-
-/**
- * @brief bh1792 sensor context
- */
-typedef struct _bh1792_context
-{
-    mraa_i2c_context i2c;
-    mraa_gpio_context interrupt;
-    bool enabled;
-    bool isrEnabled;
-    OP_MODES op_mode;
-    pthread_t sync_thread;
-    bool sync_thread_alive;
-    LED_TYPES led_type;
-    INTERRUPT_MODES interrupt_mode;
-    uint16_t meas_freq;
-    uint8_t green_current;
-    uint8_t ir_current;
-    uint16_t threshold;
-} *bh1792_context;
-
-/**
- * @brief Init the sensor with specific bus and address. Before starting
- * measurement, one of (bh1792_enable_sync_mode, bh1792_enable_non_sync_mode,
- * or bh1792_enable_single_mode) have to be called.
- *
- * @param bus I2C bus number
- * @param addr I2C sensor address
- * @return context of initialized sensor
- */
-bh1792_context bh1792_init(int bus, int addr);
-
-/**
- * @brief Close and free sensor context
- *
- * @param dev Sensor context
- */
-void bh1792_close(bh1792_context dev);
-
-/**
- * @brief Check "who am I" register value to identify the sensor
- *
- * @param dev Sensor context
- * @return UPM result
- */
-upm_result_t bh1792_check_who_am_i(bh1792_context dev);
-
-/**
- * @brief Checks if the measuremnt on sensor is enabled
- *
- * @param The sensor context
- * @return True if measurement is enabled, or false otherwise
- */
-bool bh1792_is_enabled(bh1792_context dev);
-
-/**
- * @brief Initiates a software reset to the sensor. All register values will
- * be written to their defaults, thus intended operation mode need to be
- * enabled.
- *
- * @param dev Sensor context
- * @return UPM result
- */
-upm_result_t bh1792_soft_reset(bh1792_context dev);
-
-/**
- * @brief Gets the value of measurement time is milli-seconds
- *
- * @param dev The sensor context
- * @param meas_time_ms Float pointer to store value of measurement time
- * @return UPM result
- */
-upm_result_t bh1792_get_meas_time_ms(bh1792_context dev, float *meas_time);
-
-/**
- * @brief Sets the green LED Current value
- *
- * @param dev The sensor context
- * @param current The current value, accepted values are between 0-63
- * @return UPM result
- */
-upm_result_t bh1792_set_green_leds_current(bh1792_context dev, uint8_t current);
-
-/**
- * @brief Gets the green LED current value
- *
- * @param dev The sensor context
- * @param current Pointer to store the read current value
- * @return UPM result
- */
-upm_result_t bh1792_get_green_leds_current(bh1792_context dev, uint8_t *current);
-
-/**
- * @brief Sets the IR LED Current value
- *
- * @param dev The sensor context
- * @param current The current value, accepted values are between 0-63
- * @return UPM result
- */
-upm_result_t bh1792_set_ir_led_current(bh1792_context dev, uint8_t current);
-
-/**
- * @brief Gets the IR LED current value
- *
- * @param dev The sensor context
- * @param current Pointer to store the read current value
- * @return UPM result
- */
-upm_result_t bh1792_get_ir_led_current(bh1792_context dev, uint8_t *current);
-
-/**
- * @brief Sets interrupt ir threshold value for non-synchronized mode
- *
- * @param dev Sensor context
- * @param threshold Value to be written, range 0-65536
- * @return UPM result
- */
-upm_result_t bh1792_set_ir_threshold(bh1792_context dev, uint16_t threshold);
-
-/**
- * @brief Gets interrupt ir threshold value
- *
- * @param dev Sensor context
- * @param threshold Pointer (uint16_t) to write value
- * @return UPM result
- */
-upm_result_t bh1792_get_ir_threshold(bh1792_context dev, uint16_t *threshold);
-
-/**
- * @brief Gets the current size of built-in FIFO
- *
- * @param dev The sensor context
- * @param count The pointer to store the size
- * @return UPM result
- */
-upm_result_t bh1792_get_fifo_size(bh1792_context dev, uint8_t *count);
-
-/**
- * @brief Disables interrupt function. Interrupt is enabled by default on all
- * operation modes, so this have to be called after enabling a specific
- * operation mode
- *
- * @param dev The sensor context
- * @return UPM result
- */
-upm_result_t bh1792_disable_interrupt(bh1792_context dev);
-
-/**
- * @brief Clears the interrupt flag allowing more interrupts to be raised
- *
- * @param dev The sensor context
- * @return UPM result
- */
-upm_result_t bh1792_clear_interrupt(bh1792_context dev);
-
-/**
- * @brief Starts the measuremnt on sensor or enable the sensor
- *
- * @param dev The sensor context
- * @return UPM result
- */
-upm_result_t bh1792_start_measurement(bh1792_context dev);
-
-/**
- * @breif Stops the measurement by setting the software reset bit. This
- * function will reset all config registers. To resume from previous
- * configuration call bh1792_restart_measurement().
- *
- * @param dev The sensor context
- * @return UPM result
- */
-upm_result_t bh1792_stop_measurement(bh1792_context dev);
-
-/**
- * @brief Restart the measurement, This function stops measurement, then
- * re-writes the configuration registers again and start measurement with same
- * configuration.
- *
- * @param dev The sensor context
- * @return UPM result
- */
-upm_result_t bh1792_restart_measurement(bh1792_context dev);
-
-/**
- * @brief Gets the fifo data of 32 entries and resets the WATERMARK interrupt
- * flag.
- *
- * @param dev The sensor context
- * @param fifo_led_off Array/Pointer to store 32 entries of fifo LED_OFF data
- * @param fifo_led_on Array/Pointer to store 32 entries of fifo LED_ON data
- * @return UPM result
- */
-upm_result_t bh1792_get_fifo_data(bh1792_context dev, uint16_t fifo_led_off[],
-                                    uint16_t fifo_led_on[]);
-
-/**
- * @brief Reads and discard the 32 FIFO entries to reset the WATERMARK
- * interrupt flag.
- *
- * @param dev The sensor context
- * @return UPM result
- */
-upm_result_t bh1792_discard_fifo_data(bh1792_context dev);
-
-/**
- * @brief Gets the values from using green LED light
- *
- * @param dev The sensor context
- * @param green_led_off Pointer to store the reading value of LED_OFF
- * @param green_led_on Pointer to store the reading value of LED_ON
- * @return UPM result
- */
-upm_result_t bh1792_get_green_data(bh1792_context dev, uint16_t *green_led_off,
-                                    uint16_t *green_led_on);
-
-/**
- * @brief Gets the values from using IR LED light
- *
- * @param dev The sensor context
- * @param ir_led_off Pointer to store the reading value of LED_OFF
- * @param ir_led_on Pointer to store the reading value of LED_ON
- * @return UPM result
- */
-upm_result_t bh1792_get_ir_data(bh1792_context dev, uint16_t *ir_led_off,
-                                uint16_t *ir_led_on);
-
-/**
- * @brief Enables and configures the sensor to use synchronized mode. This will
- * use the built-in FIFO and raises a WATERMARK interrupt when FIFO size
- * reaches 32 entries. To clear that interrupt flag FIFO must be read or
- * discarded. This mode uses only green LED.
- *
- * You need to call bh1792_start_measurement() after this.
- *
- * @param dev The sensor context
- * @param meas_freq Measurement frequncy mode, valid values 32, 64, 128, 256,
- * 1024
- * @param green_current Green LED current value
- * @return UPM result
- */
-upm_result_t bh1792_enable_sync_mode(bh1792_context dev, uint16_t meas_freq,
-                                    uint8_t green_current);
-
-/**
- * @brief Enabled and configures the sensor to use non-synchronized mode. This
- * mode uses IR_THRESHOLD interrupt, it will raise an interrupt if IR LED ON
- * value is equal or greater than the threshold value. Interrupt must be
- * cleared before receiving new interrupts. This mode uses only IR LED.
- *
- * You need to call bh1792_start_measurement() after this.
- *
- * @param dev The sensor context
- * @param ir_current The IR LED current value
- * @param threshold The IR LED interrupt threshold value
- * @return UPM result
- */
-upm_result_t bh1792_enable_non_sync_mode(bh1792_context dev, uint8_t ir_current,
-                                        uint16_t threshold);
-
-/**
- * @brief Enables and configures the sensor to use single mode. This sets the
- * sensor to take only one measurement and raise an interrupt after measurement
- * is finished. Interrupt flags has to be cleared to recieved new interrupts.
- * This mode uses both green and IR LEDs.
- *
- * You need to call bh1792_start_measurement() after this. If you need to get
- * continuous values, clear interrupt and bh1792_start_measurement()
- * continuously.
- *
- * @param dev The sensor context
- * @param led_type LED light type to use, takes GREEN or IR values
- * @param current The chosen led_type current value
- * @return UPM result
- */
-upm_result_t bh1792_enable_single_mode(bh1792_context dev, LED_TYPES led_type,
-                                        uint8_t current);
-
-/**
- * @brief Installs the ISR to a given GPIO pin
- *
- * @param dev Sensor context
- * @param edge Edge type to raise ISR with, of type mraa_gpio_edge_t
- * @param pin GPIO pin number
- * @param isr Pointer to ISR function
- * @param isr_args Arguments to pass the ISR function
- * @return UPM result
- */
-upm_result_t bh1792_install_isr(bh1792_context dev, mraa_gpio_edge_t edge,
-                                int pin, void (*isr)(void *), void *isr_args);
-
-/**
- * @brief Installs the ISR to a given GPIO pin
- *
- * @param dev Sensor context
- * @param pin GPIO pin number
- * @param isr Pointer to ISR function
- * @param isr_args Arguments to pass the ISR function
- * @return UPM result
- */
-upm_result_t bh1792_install_isr_falling_edge(bh1792_context dev, int pin,
-                                void (*isr)(void *), void *isr_args);
-
-/**
- * @brief Removes the ISR if it is installed
- *
- * @param dev Sensor context
- */
-void bh1792_remove_isr(bh1792_context dev);
-
-/**
- * @brief Gets a dump of configuration registers as a string
- *
- * @param dev Sensor context
- * @param dump Pointer of char to save dump string
- * @return UPM result
- */
-upm_result_t bh1792_registers_dump(bh1792_context dev, char *dump);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/bh1792/bh1792.hpp b/src/bh1792/bh1792.hpp
deleted file mode 100755
index bc557af..0000000
--- a/src/bh1792/bh1792.hpp
+++ /dev/null
@@ -1,324 +0,0 @@
-/*
-* The MIT License (MIT)
-*
-* Author: Assam Boudjelthia
-* Copyright (c) 2018 Rohm Semiconductor.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy of
-* this software and associated documentation files (the "Software"), to deal in
-* the Software without restriction, including without limitation the rights to
-* use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-* the Software, and to permit persons to whom the Software is furnished to do so,
-* subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in all
-* copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-* COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-#pragma once
-
-#include <vector>
-#include <string>
-#include "bh1792.h"
-
-/**
- * @brief BH1792 Heart Rate Sensor
- * @defgroup bh1792 libupm-bh1792
- * @ingroup rohm i2c medical
- */
-/**
- * @library bh1792
- * @sensor bh1792
- * @comname Heart Rate Sensor
- * @type medical
- * @man rohm
- * @con i2c
- *
- * @brief C++ API for the bh1792 driver
- *
- * @snippet bh1792.cxx Interesting
- */
-
-namespace upm {
-    class BH1792 {
-    public:
-
-        /**
-         * @brief Init the sensor with specific bus and address. Before
-         * starting measurement, one of (EnableSyncMode, EnableNonSyncMode,
-         * or EnableSingleMode) has to be called.
-         *
-         * @param bus I2C bus number
-         * @param addr I2C sensor address
-         * @throws std::runtime_error on initialization failure
-         */
-        BH1792(int bus = 0, int addr = 0x5b);
-
-        /**
-         * @brief Close and free sensor
-         */
-        virtual ~BH1792();
-
-        /**
-         * @brief Check "who am I" register value to identify the sensor
-         *
-         * @throws std::runtime_error if this value is incorrect
-         */
-        void CheckWhoAmI();
-
-        /**
-         * @brief Checks if the measuremnt on sensor is enabled
-         *
-         * @return True if measurement is enabled, or false otherwise
-         */
-        bool IsEnabled();
-
-        /**
-         * @brief Initiates a software reset to the sensor. All register values
-         * will be written to their defaults, thus intended operation mode need
-         * to be enabled.
-         *
-         * @throws std::runtime_error if software reset fails
-         */
-        void SoftReset();
-
-        /**
-         * @brief Gets the value of measurement time is milli-seconds
-         *
-         * @return measurement time float in milli-seconds
-         * @throws std::runtime_error if reading measurement time fails
-         */
-        float GetMeasurementTimeMS();
-
-        /**
-         * @brief Sets the green LED Current value
-         *
-         * @param current The current value, accepted values are between 0-63
-         * @throws std::runtime_error if setting current fails
-         * @throws std::range_error if current value out of range
-         */
-        void SetGreenLedsCurrent(uint16_t current);
-
-        /**
-         * @brief Gets the green LED current value
-         *
-         * @return Green LED used current
-         * @throws std::runtime_error if reading current fails
-         */
-        int GetGreenLedsCurrent();
-
-        /**
-         * @brief Sets the IR LED Current value
-         *
-         * @param current The current value, accepted values are between 0-63
-         * @throws std::runtime_error if setting current fails
-         * @throws std::range_error if current value out of range
-         */
-        void SetIrLedCurrent(uint16_t current);
-
-        /**
-         * @brief Gets the green LED current value
-         *
-         * @return Green LED used current
-         * @throws std::runtime_error if reading current fails
-         */
-        int GetIrLedCurrent();
-
-        /**
-         * @brief Sets interrupt IR threshold value for non-synchronized mode
-         *
-         * @param threshold Value to be written, range 0-65536
-         * @throws std::runtime_error if setting threshold fails
-         */
-        void SetIrThreshold(uint16_t threshold);
-
-        /**
-         * @brief Gets interrupt IR threshold value
-         *
-         * @return Green LED used current
-         * @throws std::runtime_error if reading current fails
-         */
-        int GetIrThreshold();
-
-        /**
-         * @brief Gets the current size of built-in FIFO
-         *
-         * @return Number of entries store in FIFO
-         * @throws std::runtime_error if reading size fails
-         */
-        int GetFifoSize();
-
-        /**
-         * @brief Disables interrupt function. Interrupt is enabled by default
-         * on all operation modes, so this have to be called after enabling a
-         * specific operation mode
-         *
-         * @throws std::runtime_error if setting interrupt disable bits fails
-         */
-        void DisableInterrupt();
-
-        /**
-         * @brief Clears the interrupt flag allowing more interrupts to be
-         * raised
-         *
-         * @throws std::runtime_error if clearing interrupt fails
-         */
-        void ClearInterrupt();
-
-        /**
-         * @brief Starts the measuremnt on sensor or enable the sensor
-         *
-         * @throws std::runtime_error if starting measurement fails
-         */
-        void StartMeasurement();
-
-        /**
-         * @breif Stops the measurement by setting the software reset bit. This
-         * function will reset all config registers. To resume from previous
-         * configuration call RestartMeasurement().
-         *
-         * @throws std::runtime_error if disabling measurement fails
-         */
-        void StopMeasurement();
-
-        /**
-         * @brief Restart the measurement, This function stops measurement,
-         * then re-writes the configuration registers again and start
-         * measurement with same configuration.
-         *
-         * @throws std::runtime_error if restarting measurement fails
-         */
-        void RestartMeasurement();
-
-        /**
-         * @brief Gets the fifo data of 32 entries and resets the WATERMARK
-         * interrupt flag.
-         *
-         * @return vector of values of the retrieved FIFO values, which are
-         * vectors containing 2 values each (led off, led_on)
-         * @throws std::runtime_error if reading FIFO data fails
-         */
-        std::vector<std::vector<int>> GetFifoData();
-
-        /**
-         * @brief Reads and discard the 32 FIFO entries to reset the WATERMARK
-         * interrupt flag.
-         *
-         * @throws std::runtime_error if reading FIFO data fails
-         */
-        void DiscardFifoData();
-
-        /**
-         * @brief Gets the values from using green LED light
-         *
-         * @return vector of values (led off, led on) of green led values
-         * @throws std::runtime_error if reading green data fails
-         */
-        std::vector<int> GetGreenData();
-
-        /**
-         * @brief Gets the values from using IR LED light
-         *
-         * @return vector of values (led off, led on) of IR led values
-         * @throws std::runtime_error if reading IR data fails
-         */
-        std::vector<int> GetIrData();
-
-        /**
-         * @brief Enables and configures the sensor to use synchronized mode.
-         * This will use the built-in FIFO and raises a WATERMARK interrupt
-         * when FIFO size reaches 32 entries. To clear that interrupt flag FIFO
-         * must be read or discarded. This mode uses only green LED.
-         *
-         * You need to call StartMeasurement() after this.
-         *
-         * @param measFreq Measurement frequncy mode, valid values 32, 64, 128,
-         * 256, 1024
-         * @param green_current Green LED current value
-         * @throws std::runtime_error if enabling synchronized mode fails
-         * @throws std::invalid_argument if measurement frequency is invalid
-         */
-        void EnableSyncMode(uint16_t measFreq, uint16_t green_current);
-
-        /**
-         * @brief Enabled and configures the sensor to use non-synchronized
-         * mode. This mode uses IR_THRESHOLD interrupt, it will raise an
-         * interrupt if IR LED ON value is equal or greater than the threshold
-         * value. Interrupt must be cleared before receiving new interrupts.
-         * This mode uses only IR LED.
-         *
-         * You need to call StartMeasurement() after this.
-         *
-         * @param ir_current The IR LED current value
-         * @param threshold The IR LED interrupt threshold value
-         *
-         * @throws std::runtime_error if enabling non-synchronized mode fails
-         */
-        void EnableNonSyncMode(uint16_t ir_current, uint16_t threshold);
-
-        /**
-         * @brief Enables and configures the sensor to use single mode. This
-         * sets the sensor to take only one measurement and raise an interrupt
-         * after measurement is finished. Interrupt flags has to be cleared to
-         * recieved new interrupts. This mode uses both green and IR LEDs.
-         *
-         * You need to call StartMeasurement() after this. If you need to get
-         * continuous values, clear interrupt and StartMeasurement()
-         * continuously.
-         *
-         * @param led_type LED light type to use, takes GREEN or IR (0 or 1)
-         * @param current The chosen led_type current value
-         * @throws std::runtime_error if enabling single mode fails
-         */
-        void EnableSingleMode(LED_TYPES led_type, uint16_t current);
-
-        /**
-         * @brief Installs the ISR to a given GPIO pin
-         *
-         * @param edge Edge type to raise ISR with, of type mraa_gpio_edge_t
-         * @param pin GPIO pin number
-         * @param isr Pointer to ISR function
-         * @param isr_args Arguments to pass the ISR function
-         * @throws std::runtime_error if installing ISR fails
-         */
-        void InstallISR(mraa_gpio_edge_t edge, int pin, void (*isr)(void *),
-                        void *isr_args);
-
-        /**
-         * @brief Installs the ISR to a given GPIO pin
-         *
-         * @param pin GPIO pin number
-         * @param isr Pointer to ISR function
-         * @param isr_args Arguments to pass the ISR function
-         * @throws std::runtime_error if installing ISR fails
-         */
-        void InstallISR(int pin, void (*isr)(void *), void *isr_args);
-
-        /**
-         * @brief Removes the ISR if it is installed
-         */
-        void RemoveISR();
-
-        /**
-         * @brief Gets a dump of configuration registers as a string
-         *
-         * @return string of dumped registers
-         * @throws std::runtime_error if reading one of the registers fails
-         */
-        std::string RegistersDump();
-
-    private:
-        bh1792_context m_bh1792;
-
-        /* Disable implicit copy and assignment operators */
-        BH1792(const BH1792 &) = delete;
-        BH1792 &operator=(const BH1792 &) = delete;
-    };
-}
\ No newline at end of file
diff --git a/src/bh1792/bh1792.i b/src/bh1792/bh1792.i
deleted file mode 100755
index 9cc6b8b..0000000
--- a/src/bh1792/bh1792.i
+++ /dev/null
@@ -1,28 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%ignore InstallISR(mraa_gpio_edge_t, int, void *, void *);
-
-%extend upm::BH1792 {
-    void InstallISR(int pin, jobject runnable)
-    {
-        $self->InstallISR(pin, mraa_java_isr_callback, runnable);
-    }
-}
-
-JAVA_JNI_LOADLIBRARY(javaupm_bh1792)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%include "std_vector.i"
-%template(intVector) std::vector<int>;
-%template(intVector2D) std::vector<std::vector<int>>;
-
-%{
-#include "bh1792.hpp"
-%}
-%include "bh1792.h"
-%include "bh1792.hpp"
-/* END Common SWIG syntax */
diff --git a/src/bh1792/bh1792.json b/src/bh1792/bh1792.json
deleted file mode 100755
index fd60005..0000000
--- a/src/bh1792/bh1792.json
+++ /dev/null
@@ -1,62 +0,0 @@
-{
-    "Library": "BH1792",
-    "Description": "ROHM BH1792 Heart Rate Sensor library",
-    "Sensor Class": {
-        "BH1792": {
-            "Name": "ROHM BH1792 Heart Rate Sensor library",
-            "Description": "BH1792GLC is optical sensor for heart rate monitor IC in which LED driver, green light and IR detection photodiode are incorporated. This device drives LED and provides the intensity of light reflected from body. LED brightness can be adjusted by LED driver current. The photodiode having the high sensitivity for green light and excellent wavelength selectivity achieves accurate pulse wave detection.",
-            "Categories": ["medical"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["ROHM"],
-            "Examples": {
-                "C++": ["bh1792.cxx"],
-                "C": ["bh1792.c"],
-                "Java": ["BH1792_Example.java"],
-                "Python": ["bh1792.py"],
-                "Node.js": ["bh1792.js"]
-            },
-            "Specifications": {
-                "Supply Voltage (VDD)": {
-                    "unit": "V",
-                    "min": 2.5,
-                    "typical": 3.0,
-                    "max": 3.6
-                },
-                "Terminal Input Voltage": {
-                    "unit": "V",
-                    "min": 0.7,
-                    "max": 5.5
-                },
-                "Supply Current": {
-                    "unit": "uA",
-                    "min": 0.8,
-                    "max": 200
-                },
-                "LED Supply Current": {
-                    "unit": "mA",
-                    "typical": 1.4,
-                    "max": 3.0
-                },
-                "Standby Mode Current": {
-                    "unit": "uA",
-                    "typical": 0.8,
-                    "max": 1.5
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -20,
-                    "max": 85
-                }
-            },
-            "Urls": {
-                "Product Pages": [
-                    "https://www.rohm.com/sensor-shield-support/heart-rate-sensor2"
-                ],
-                "Datasheets": [
-                    "https://www.rohm.com/datasheet/BH1792GLC/bh1792glc-e"
-                ]
-            }
-        }
-    }
-}
diff --git a/src/bh1792/bh1792glc_registers.h b/src/bh1792/bh1792glc_registers.h
deleted file mode 100755
index 8d1ea81..0000000
--- a/src/bh1792/bh1792glc_registers.h
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
-The MIT License (MIT)
-Copyright (c) 2017 Rohm Semiconductor
-
-Permission is hereby granted, free of charge, to any person obtaining a
-copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sublicense, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice shall be included
-in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-#ifndef __BH1792GLC_REGISTERS_H__
-#define __BH1792GLC_REGISTERS_H__
-/* registers */
-#define BH1792_REGISTER_DUMP_START 0x0F
-#define BH1792_MANUFACTURER_REG 0x0F
-// WHO_AM_I -value
-#define BH1792_PARTID_REG 0x10
-// Soft reset
-#define BH1792_RESET 0x40
-// System control setting
-#define BH1792_MEAS_CONTROL1 0x41
-// LED 1 & 2 control register
-#define BH1792_MEAS_CONTROL2 0x42
-// LED 3 control register
-#define BH1792_MEAS_CONTROL3 0x43
-// IR Interrupt Threshold Value [7:0]
-#define BH1792_MEAS_CONTROL4_L 0x44
-// IR Interrupt Threshold Value [15:8]
-#define BH1792_MEAS_CONTROL4_H 0x45
-#define BH1792_MEAS_CONTROL5 0x46
-#define BH1792_MEAS_START 0x47
-#define BH1792_MEAS_SYNC 0x48
-#define BH1792_FIFO_LEV 0x4B
-// FIFO Output data 0 [7:0]
-#define BH1792_FIFO_DATA0_L 0x4C
-// FIFO Output data 0 [15:8]
-#define BH1792_FIFO_DATA0_H 0x4D
-// FIFO Output data 1 [7:0]
-#define BH1792_FIFO_DATA1_L 0x4E
-// FIFO Output data 1 [15:8]
-#define BH1792_FIFO_DATA1_H 0x4F
-// IR Data Count Value during no LED emission [7:0]
-#define BH1792_IRDATA_LEDOFF_L 0x50
-// IR Data Count Value during no LED emission [15:8]
-#define BH1792_IRDATA_LEDOFF_H 0x51
-// IR Data Count Value during LED emission [7:0]
-#define BH1792_IRDATA_LEDON_L 0x52
-// IR Data Count Value during LED emission [15:8]
-#define BH1792_IRDATA_LEDON_H 0x53
-// Green Data Count Value during no LED emission [7:0]
-#define BH1792_DATAOUT_LEDOFF_L 0x54
-// Green Data Count Value during no LED emission [15:8]
-#define BH1792_DATAOUT_LEDOFF_H 0x55
-// Green Data Count Value during LED emission [7:0]
-#define BH1792_DATAOUT_LEDON_L 0x56
-// Green Data Count Value during LED emission [15:8]
-#define BH1792_DATAOUT_LEDON_H 0x57
-// IR threshold judgement and measurement completion interrupt is cleared when reading this register.
-#define BH1792_INT_CLEAR 0x58
-#define BH1792_REGISTER_DUMP_END 0x58
-/* registers bits */
-#define BH1792_MANUFACTURER_REG_MANUFACTURER_ID (0xE0 << 0)
-#define BH1792_PARTID_REG_PART_ID (0x0E << 0)
-// 1 : Software reset is performed
-#define BH1792_RESET_SWRESET (0x01 << 7)
-// 1 : OSC block is active, 0: prohibited
-#define BH1792_MEAS_CONTROL1_RDY (0x01 << 7)
-// Green mode, leds 1 & 2 active
-#define BH1792_MEAS_CONTROL1_SEL_ADC_GREEN (0x00 << 4)
-// IR mode, led 3 active. Can be used only in single and non synch modes.
-#define BH1792_MEAS_CONTROL1_SEL_ADC_IR (0x01 << 4)
-// 32 Hz synchronous mode
-#define BH1792_MEAS_CONTROL1_MSR_32HZ (0x00 << 0)
-// 128 Hz synchronous mode
-#define BH1792_MEAS_CONTROL1_MSR_128HZ (0x01 << 0)
-// 64 Hz synchronous mode
-#define BH1792_MEAS_CONTROL1_MSR_64HZ (0x02 << 0)
-// 256 Hz synchronous mode
-#define BH1792_MEAS_CONTROL1_MSR_256HZ (0x03 << 0)
-#define BH1792_MEAS_CONTROL1_MSR_PROHIBITED (0x04 << 0)
-// 1024 Hz synchronous mode
-#define BH1792_MEAS_CONTROL1_MSR_1024HZ (0x05 << 0)
-// non synchronized measurement mode
-#define BH1792_MEAS_CONTROL1_MSR_NON_SYNCH_MODE (0x06 << 0)
-// single measurement mode
-#define BH1792_MEAS_CONTROL1_MSR_SINGLE_MEAS_MODE (0x07 << 0)
-// LED driver mode, for usage see datasheet
-#define BH1792_MEAS_CONTROL3_LED_EN2 (0x01 << 7)
-// No interrupt output.
-#define BH1792_MEAS_CONTROL5_INT_SEL_DISABLE (0x00 << 0)
-// Watermark interrupt FIFO, fires when number of stored samples reaches 32. Cleared when number of samples falls below 32.
-#define BH1792_MEAS_CONTROL5_INT_SEL_FIFO_WATERMARK (0x01 << 0)
-// IR threshold judgement interrupt. Used in non synchroniozed mode.
-#define BH1792_MEAS_CONTROL5_INT_SEL_IR_THRESHOLD (0x02 << 0)
-// Measurement completion interrupt. In single mode.
-#define BH1792_MEAS_CONTROL5_INT_SEL_ON_COMPLETE (0x03 << 0)
-// Flag of start measurement. MEAS_ST=1 after RDY=1 starts measurement. In single measurement mode MEAS_ST=1 restarts measurement.
-#define BH1792_MEAS_START_MEAS_ST (0x01 << 0)
-// Used in synhcronized measurement mode. Write once per second.
-#define BH1792_MEAS_SYNC_MEAS_SYNC (0x01 << 0)
- /*registers bit masks */
-#define BH1792_MANUFACTURER_REG_MANUFACTURER_MASK 0xFF
-#define BH1792_PARTID_REG_PART_MASK 0xFF
-// Select LED omitting frequency
-#define BH1792_MEAS_CONTROL1_SEL_ADC_MASK 0x10
-// Measurement mode
-#define BH1792_MEAS_CONTROL1_MSR_MASK 0x07
-#define BH1792_MEAS_CONTROL2_LED_EN1_MASK 0xC0
-#define BH1792_MEAS_CONTROL2_LED_CURRENT1_MASK 0x3F
-#define BH1792_MEAS_CONTROL3_LED_CURRENT2_MASK 0x3F
-// Interrupt function select
-#define BH1792_MEAS_CONTROL5_INT_SEL_MASK 0x03
-#define BH1792_FIFO_LEV_LEVEL_MASK 0x3F
-#endif
-
diff --git a/src/biss0001/CMakeLists.txt b/src/biss0001/CMakeLists.txt
deleted file mode 100644
index c07b7f5..0000000
--- a/src/biss0001/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME biss0001
-    DESCRIPTION "Passive Infrared (PIR) Motion Sensor"
-    C_HDR biss0001.h
-    C_SRC biss0001.c
-    CPP_HDR biss0001.hpp
-    CPP_SRC biss0001.cxx
-    FTI_SRC biss0001_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa)
diff --git a/src/biss0001/biss0001.c b/src/biss0001/biss0001.c
deleted file mode 100644
index 958f38f..0000000
--- a/src/biss0001/biss0001.c
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- *         Zion Orent <zorent@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <assert.h>
-#include "biss0001.h"
-
-biss0001_context biss0001_init(unsigned int pin)
-{
-    biss0001_context dev =
-        (biss0001_context)malloc(sizeof(struct _biss0001_context));
-
-    if (!dev)
-        return NULL;
-
-    dev->gpio = NULL;
-
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        biss0001_close(dev);
-        return NULL;
-    }
-
-    // initialize the MRAA context
-
-    if (!(dev->gpio = mraa_gpio_init(pin)))
-    {
-        printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
-        biss0001_close(dev);
-        return NULL;
-    }
-
-    mraa_gpio_dir(dev->gpio, MRAA_GPIO_IN);
-
-    return dev;
-}
-
-void biss0001_close(biss0001_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->gpio)
-        mraa_gpio_close(dev->gpio);
-
-    free(dev);
-}
-
-bool biss0001_motion_detected(const biss0001_context dev)
-{
-    assert(dev != NULL);
-
-    return (mraa_gpio_read(dev->gpio) ? true : false);
-}
diff --git a/src/biss0001/biss0001.cxx b/src/biss0001/biss0001.cxx
deleted file mode 100644
index c7a0e0d..0000000
--- a/src/biss0001/biss0001.cxx
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Author: Zion Orent <sorent@ics.com>
- *         Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014-2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "biss0001.hpp"
-
-using namespace upm;
-
-BISS0001::BISS0001(unsigned int pin) :
-    m_biss0001(biss0001_init(pin))
-{
-    if (!m_biss0001)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": biss0001_init() failed");
-}
-
-BISS0001::~BISS0001()
-{
-    biss0001_close(m_biss0001);
-}
-
-bool BISS0001::value()
-{
-    return biss0001_motion_detected(m_biss0001);
-}
diff --git a/src/biss0001/biss0001.h b/src/biss0001/biss0001.h
deleted file mode 100644
index dd152ff..0000000
--- a/src/biss0001/biss0001.h
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- *         Zion Orent <zorent@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <upm.h>
-#include <mraa/gpio.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    /**
-     * @file biss0001.h
-     * @library biss0001
-     * @brief C API for the BISS0001 Motion Sensor
-     *
-     * @include biss0001.c
-     */
-
-    /**
-     * Device context
-     */
-    typedef struct _biss0001_context {
-        mraa_gpio_context        gpio;
-    } *biss0001_context;
-
-    /**
-     * BISS0001 initilaizer
-     *
-     * @param pin Digital pin to use.
-     * @return an initialized device context on success, NULL on error.
-     */
-    biss0001_context biss0001_init(unsigned int pin);
-
-    /**
-     * BISS0001 close function
-     *
-     * @param dev The device context.
-     */
-    void biss0001_close(biss0001_context dev);
-
-    /**
-     * Gets the motion value from the sensor
-     *
-     * @param dev The device context.
-     * @return true if motion was detected, false otherwise
-     */
-    bool biss0001_motion_detected(const biss0001_context dev);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/biss0001/biss0001.hpp b/src/biss0001/biss0001.hpp
deleted file mode 100644
index 80c3511..0000000
--- a/src/biss0001/biss0001.hpp
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Author: Zion Orent <zorent@ics.com>
- *         Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014-2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <biss0001.h>
-
-namespace upm {
-    /**
-     * @brief BISS0001 Motion Sensor
-     * @defgroup biss0001 libupm-biss0001
-     * @ingroup seeed gpio light tsk
-     */
-
-    /**
-     * @library biss0001
-     * @sensor biss0001
-     * @comname Passive Infrared (PIR) Motion Sensor
-     * @altname Grove PIR Motion Sensor
-     * @type light
-     * @man seeed
-     * @web http://www.seeedstudio.com/depot/Grove-PIR-Motion-Sensor-p-802.html
-     * @con gpio
-     * @kit tsk
-     *
-     * @brief API for the BISS0001 Motion Sensor
-     *
-     * PIR sensors allow you to sense motion, almost always used to detect
-     * whether a human has moved in or out of the sensors range. They are
-     * small, inexpensive, low-power, easy to use and don't wear out. For that
-     * reason they are commonly found in appliances and gadgets used in homes
-     * or businesses. They are often referred to as PIR, "Passive Infrared",
-     * "Pyroelectric", or "IR motion" sensors.
-     *
-     * @image html biss0001.jpg
-     * @snippet biss0001.cxx Interesting
-     */
-
-  class BISS0001 {
-  public:
-      /**
-       * BISS0001 motion sensor constructor
-       *
-       * @param pin Digital pin to use
-       */
-      BISS0001(unsigned int pin);
-
-      /**
-       * BISS0001 destructor
-       */
-      ~BISS0001();
-
-      /**
-       * Gets the motion value from the sensor.
-       *
-       * @return true if motion was detected, false otherwise.
-       */
-      bool value();
-
-      /**
-       * Gets the motion value from the sensor.  This is a more
-       * informative method name, but we want to keep compatibility
-       * with the original for now.
-       *
-       * @return true if motion was detected, false otherwise.
-       */
-      bool motionDetected() { return value(); };
-
-  private:
-      /* Disable implicit copy and assignment operators */
-      BISS0001(const BISS0001&) = delete;
-      BISS0001 &operator=(const BISS0001&) = delete;
-
-      biss0001_context m_biss0001;
-  };
-}
-
-
diff --git a/src/biss0001/biss0001.json b/src/biss0001/biss0001.json
deleted file mode 100644
index efd9c66..0000000
--- a/src/biss0001/biss0001.json
+++ /dev/null
@@ -1,73 +0,0 @@
-{
-    "Library": "biss0001",
-    "Description": "Seeed PIR motion sensor library",
-    "Sensor Class": {
-        "BISS0001": {
-            "Name": "Seeed BISS0001 PIR motion detector",
-            "Description": "This is the UPM Module for the Seeed BISS0001 PIR motion detector. This sensor offers a 120 degree sensor arc, with a 3 to 6 meter detecting distance. It also offers adjustable detecting distance and hold times.",
-            "Aliases": ["biss0001", "Grove - PIR Motion Sensor"],
-            "Categories": ["light"],
-            "Connections": ["GPIO"],
-            "Project Type": ["prototyping", "home", "industrial"],
-            "Manufacturers": ["seeed"],
-            "Kits": ["tsk"],
-            "Image": "biss0001.jpg",
-            "Examples": {
-                "Java": ["BISS0001_Example.java"],
-                "Python": ["biss0001.py"],
-                "Node.js": ["biss0001.js"],
-                "C++": ["biss0001.cxx"],
-                "C": ["biss0001.c"]
-            },
-            "Specifications": {
-                "Vdd": {
-                    "unit": "V",
-                    "min": 3,
-                    "max": 5
-                },
-                "Supply Current Digital": {
-                    "5.0 Vdc": {
-                        "unit": "mA",
-                        "typ" : "10"
-                    }
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -20,
-                    "max": 70
-                },
-                "Storage Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 125
-                },
-                "Response Time Digital": {
-                    "unit": "s",
-                    "min" : 0.3,
-                    "max" : 25
-                },
-                "Detecting angle": {
-                    "unit": "degrees",
-                    "angle": 120
-                },
-                "Detecting distance": {
-                    "unit": "m",
-                    "min" : 3,
-                    "max" : 6
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Requires Seeed expansion board"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Requires Seeed expansion board"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-PIR-Motion-Sensor-p-802.html"],
-                "Datasheets": ["http://wiki.seeedstudio.com/images/2/2f/Twig_-_BISS0001.pdf"]
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/biss0001/biss0001_fti.c b/src/biss0001/biss0001_fti.c
deleted file mode 100644
index 639bc24..0000000
--- a/src/biss0001/biss0001_fti.c
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "biss0001.h"
-#include <upm_fti.h>
-
-/**
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_biss0001_name[] = "BISS0001";
-const char upm_biss0001_description[] = "PIR Motion Sensor";
-const upm_protocol_t upm_biss0001_protocol[] = {UPM_GPIO};
-const upm_sensor_t upm_biss0001_category[] = {UPM_BINARY};
-
-// forward declarations
-const void* upm_biss0001_get_ft(upm_sensor_t sensor_type);
-void* upm_biss0001_init_name();
-void upm_biss0001_close(void *dev);
-upm_result_t upm_biss0001_motion_detected(void *dev, bool *value);
-
-static const upm_sensor_ft ft =
-{
-  .upm_sensor_init_name = upm_biss0001_init_name,
-  .upm_sensor_close = upm_biss0001_close,
-};
-
-static const upm_binary_ft bft =
-{
-  .upm_binary_get_value = upm_biss0001_motion_detected,
-};
-
-const void* upm_biss0001_get_ft(upm_sensor_t sensor_type)
-{
-  switch(sensor_type)
-    {
-    case UPM_SENSOR:
-      return &ft;
-    case UPM_BINARY:
-      return &bft;
-    default:
-      return NULL;
-    }
-}
-
-void *upm_biss0001_init_name()
-{
-  return NULL;
-}
-
-void upm_biss0001_close(void *dev)
-{
-  biss0001_close((biss0001_context)dev);
-}
-
-upm_result_t upm_biss0001_motion_detected(void *dev, bool *value)
-{
-  *value = biss0001_motion_detected((biss0001_context)dev);
-
-  return UPM_SUCCESS;
-}
diff --git a/src/bma220/CMakeLists.txt b/src/bma220/CMakeLists.txt
deleted file mode 100644
index 0946db0..0000000
--- a/src/bma220/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "bma220")
-set (libdescription "Digital Triaxial Acceleration Sensor")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/bma220/bma220.cxx b/src/bma220/bma220.cxx
deleted file mode 100644
index 113fc39..0000000
--- a/src/bma220/bma220.cxx
+++ /dev/null
@@ -1,518 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <iostream>
-#include <stdexcept>
-#include <string>
-#include <string.h>
-
-#include "bma220.hpp"
-
-using namespace upm;
-using namespace std;
-
-
-BMA220::BMA220(int bus, uint8_t addr) :
-  m_i2c(bus), m_gpioIntr(0)
-{
-  m_addr = addr;
-
-  m_accelX = 0.0;
-  m_accelY = 0.0;
-  m_accelZ = 0.0;
-
-  m_accelScale = 0.0;
-
-  mraa::Result rv;
-  if ( (rv = m_i2c.address(m_addr)) != mraa::SUCCESS)
-    {
-      throw std::runtime_error(string(__FUNCTION__) +
-                               ": I2c.address() failed");
-      return;
-    }
-
-  // Init the accelerometer
-  enableAxes(true, true, true);
-
-  // set scaling rate
-  if (!setAccelerometerScale(FSL_RANGE_2G))
-    {
-      throw std::runtime_error(string(__FUNCTION__) +
-                               ": Unable to set accel scale");
-      return;
-    }
-}
-
-BMA220::~BMA220()
-{
-  uninstallISR();
-}
-
-void BMA220::update()
-{
-  updateAccelerometer();
-}
-
-void BMA220::updateAccelerometer()
-{
-  int x, y, z;
-  char buf = 0;
-
-  buf = (char)readReg(REG_ACC_X);
-  x = int(buf) / 4;
-
-  buf = (char)readReg(REG_ACC_Y);
-  y = int(buf) / 4;
-
-  buf = (char)readReg(REG_ACC_Z);
-  z = int(buf) / 4;
-
-  m_accelX = float(x);
-  m_accelY = float(y);
-  m_accelZ = float(z);
-}
-
-uint8_t BMA220::readReg(uint8_t reg)
-{
-  return m_i2c.readReg(reg);
-}
-
-bool BMA220::writeReg(uint8_t reg, uint8_t val)
-{
-  mraa::Result rv;
-  if ((rv = m_i2c.writeReg(reg, val)) != mraa::SUCCESS)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": I2c.writeReg() failed");
-      return false;
-    }
-
-  return true;
-}
-
-bool BMA220::setAccelerometerScale(FSL_RANGE_T scale)
-{
-  uint8_t reg = readReg(REG_SBIST_FSL_CONFIG);
-
-  reg &= ~(_REG_SBIST_FSL_RANGE_MASK << _REG_SBIST_FSL_RANGE_SHIFT);
-
-  reg |= (scale << _REG_SBIST_FSL_RANGE_SHIFT);
-
-  if (!writeReg(REG_SBIST_FSL_CONFIG, reg))
-    {
-      return false;
-    }
-
-  // store scaling factor
-
-  switch (scale)
-    {
-    case FSL_RANGE_2G:
-      m_accelScale = 16.0;
-      break;
-
-    case FSL_RANGE_4G:
-      m_accelScale = 8.0;
-      break;
-
-    case FSL_RANGE_8G:
-      m_accelScale = 4.0;
-      break;
-
-    case FSL_RANGE_16G:
-      m_accelScale = 2.0;
-      break;
-
-    default: // should never occur, but...
-      m_accelScale = 0.0;        // set a safe, though incorrect value
-      throw std::logic_error(string(__FUNCTION__) +
-                             ": internal error, unsupported scale");
-      break;
-    }
-
-  return true;
-}
-
-void BMA220::getAccelerometer(float *x, float *y, float *z)
-{
-  if (x)
-    *x = m_accelX / m_accelScale;
-
-  if (y)
-    *y = m_accelY / m_accelScale;
-
-  if (z)
-    *z = m_accelZ / m_accelScale;
-}
-
-std::vector<float> BMA220::getAccelerometer()
-{
-  std::vector<float> v(3);
-  getAccelerometer(&v[0], &v[1], &v[2]);
-  return v;
-}
-
-uint8_t BMA220::getChipID()
-{
-  return readReg(REG_CHIPID);
-}
-
-uint8_t BMA220::getChipRevision()
-{
-  return readReg(REG_REVISIONID);
-}
-
-bool BMA220::setFilterConfig(FILTER_CONFIG_T filter)
-{
-  uint8_t reg = readReg(REG_FILTER_CONFIG);
-
-  reg &= ~(_FILTER_CONFIG_FILTER_MASK << _FILTER_CONFIG_FILTER_SHIFT);
-
-  reg |= (filter << _FILTER_CONFIG_FILTER_SHIFT);
-
-  return writeReg(REG_FILTER_CONFIG, reg);
-}
-
-bool BMA220::setSerialHighBW(bool high)
-{
-  uint8_t reg = readReg(REG_FILTER_CONFIG);
-
-  if (high)
-    reg |= FILTER_CONFIG_SERIAL_HIGH_BW;
-  else
-    reg &= ~FILTER_CONFIG_SERIAL_HIGH_BW;
-
-  return writeReg(REG_FILTER_CONFIG, reg);
-}
-
-bool BMA220::enableAxes(bool xEn, bool yEn, bool zEn)
-{
-  uint8_t reg = readReg(REG_ENABLE_CONFIG3);
-
-  if (xEn)
-    reg |= ENABLE_CONFIG3_X_CHAN;
-  else
-    reg &= ~ENABLE_CONFIG3_X_CHAN;
-
-  if (yEn)
-    reg |= ENABLE_CONFIG3_Y_CHAN;
-  else
-    reg &= ~ENABLE_CONFIG3_Y_CHAN;
-
-  if (zEn)
-    reg |= ENABLE_CONFIG3_Z_CHAN;
-  else
-    reg &= ~ENABLE_CONFIG3_Z_CHAN;
-
-  return writeReg(REG_ENABLE_CONFIG3, reg);
-}
-
-uint8_t BMA220::suspend()
-{
-  return readReg(REG_SUSPEND);
-}
-
-uint8_t BMA220::softReset()
-{
-  return readReg(REG_SOFTRESET);
-}
-
-bool BMA220::sleep(bool enable)
-{
-  uint8_t reg = readReg(REG_ENABLE_CONFIG3);
-
-  if (enable)
-    reg |= ENABLE_CONFIG3_SLEEP_EN;
-  else
-    reg &= ~ENABLE_CONFIG3_SLEEP_EN;
-
-  return writeReg(REG_ENABLE_CONFIG3, reg);
-}
-
-bool BMA220::setSleepDuration(SLEEP_DUR_T dur)
-{
-  uint8_t reg = readReg(REG_ENABLE_CONFIG3);
-
-  reg &= ~(_ENABLE_CONFIG3_SLEEP_DUR_MASK << _ENABLE_CONFIG3_SLEEP_DUR_SHIFT);
-
-  reg |= (dur << _ENABLE_CONFIG3_SLEEP_DUR_SHIFT);
-
-  return writeReg(REG_ENABLE_CONFIG3, reg);
-}
-
-bool BMA220::setLowGThreshold(uint8_t thresh)
-{
-  uint8_t reg = readReg(REG_THRESHOLD);
-
-  thresh &= 0x0f;
-
-  reg &= ~(_THRESHOLD_LOW_MASK << _THRESHOLD_LOW_SHIFT);
-
-  reg |= (thresh << _THRESHOLD_LOW_SHIFT);
-
-  return writeReg(REG_THRESHOLD, reg);
-}
-
-bool BMA220::setHighGThreshold(uint8_t thresh)
-{
-  uint8_t reg = readReg(REG_THRESHOLD);
-
-  thresh &= 0x0f;
-
-  reg &= ~(_THRESHOLD_HIGH_MASK << _THRESHOLD_HIGH_SHIFT);
-
-  reg |= (thresh << _THRESHOLD_HIGH_SHIFT);
-
-  return writeReg(REG_THRESHOLD, reg);
-}
-
-bool BMA220::setLowGHysteresis(uint8_t hyst)
-{
-  uint8_t reg = readReg(REG_L_HYST_DUR);
-
-  hyst &= _L_HYST_DUR_LOW_HY_MASK;
-
-  reg &= ~(_L_HYST_DUR_LOW_HY_MASK << _L_HYST_DUR_LOW_HY_SHIFT);
-
-  reg |= (hyst << _L_HYST_DUR_LOW_HY_SHIFT);
-
-  return writeReg(REG_L_HYST_DUR, reg);
-}
-
-bool BMA220::setLowGDuration(uint8_t dur)
-{
-  uint8_t reg = readReg(REG_L_HYST_DUR);
-
-  dur &= _L_HYST_DUR_LOW_DUR_MASK;
-
-  reg &= ~(_L_HYST_DUR_LOW_DUR_MASK << _L_HYST_DUR_LOW_DUR_SHIFT);
-
-  reg |= (dur << _L_HYST_DUR_LOW_DUR_SHIFT);
-
-  return writeReg(REG_L_HYST_DUR, reg);
-}
-
-bool BMA220::setHighGHysteresis(uint8_t hyst)
-{
-  uint8_t reg = readReg(REG_H_HYST_DUR);
-
-  hyst &= _H_HYST_DUR_HIGH_HY_MASK;
-
-  reg &= ~(_H_HYST_DUR_HIGH_HY_MASK << _H_HYST_DUR_HIGH_HY_SHIFT);
-
-  reg |= (hyst << _H_HYST_DUR_HIGH_HY_SHIFT);
-
-  return writeReg(REG_H_HYST_DUR, reg);
-}
-
-bool BMA220::setHighGDuration(uint8_t dur)
-{
-  uint8_t reg = readReg(REG_H_HYST_DUR);
-
-  dur &= _H_HYST_DUR_HIGH_DUR_MASK;
-
-  reg &= ~(_H_HYST_DUR_HIGH_DUR_MASK << _H_HYST_DUR_HIGH_DUR_SHIFT);
-
-  reg |= (dur << _H_HYST_DUR_HIGH_DUR_SHIFT);
-
-  return writeReg(REG_H_HYST_DUR, reg);
-}
-
-bool BMA220::setTapDuration(uint8_t dur)
-{
-  uint8_t reg = readReg(REG_TAP_CONFIG);
-
-  dur &= _TAP_CONFIG_DUR_MASK;
-
-  reg &= ~(_TAP_CONFIG_DUR_MASK << _TAP_CONFIG_DUR_SHIFT);
-
-  reg |= (dur << _TAP_CONFIG_DUR_SHIFT);
-
-  return writeReg(REG_TAP_CONFIG, reg);
-}
-
-bool BMA220::setTapThreshold(uint8_t thresh)
-{
-  uint8_t reg = readReg(REG_TAP_CONFIG);
-
-  thresh &= _TAP_CONFIG_THRESH_MASK;
-
-  reg &= ~(_TAP_CONFIG_THRESH_MASK << _TAP_CONFIG_THRESH_SHIFT);
-
-  reg |= (thresh << _TAP_CONFIG_THRESH_SHIFT);
-
-  return writeReg(REG_TAP_CONFIG, reg);
-}
-
-bool BMA220::enableTapFilter(bool filt)
-{
-  uint8_t reg = readReg(REG_TAP_CONFIG);
-
-  if (filt)
-    reg |= TAP_CONFIG_FILTER;
-  else
-    reg &= ~TAP_CONFIG_FILTER;
-
-  return writeReg(REG_TAP_CONFIG, reg);
-}
-
-bool BMA220::setSlopeDuration(uint8_t dur)
-{
-  uint8_t reg = readReg(REG_SLOPE_CONFIG);
-
-  dur &= _SLOPE_CONFIG_DUR_MASK;
-
-  reg &= ~(_SLOPE_CONFIG_DUR_MASK << _SLOPE_CONFIG_DUR_SHIFT);
-
-  reg |= (dur << _SLOPE_CONFIG_DUR_SHIFT);
-
-  return writeReg(REG_SLOPE_CONFIG, reg);
-}
-
-bool BMA220::setSlopeThreshold(uint8_t thresh)
-{
-  uint8_t reg = readReg(REG_SLOPE_CONFIG);
-
-  thresh &= _SLOPE_CONFIG_THRESH_MASK;
-
-  reg &= ~(_SLOPE_CONFIG_THRESH_MASK << _SLOPE_CONFIG_THRESH_SHIFT);
-
-  reg |= (thresh << _SLOPE_CONFIG_THRESH_SHIFT);
-
-  return writeReg(REG_SLOPE_CONFIG, reg);
-}
-
-bool BMA220::enableSlopeFilter(bool filt)
-{
-  uint8_t reg = readReg(REG_SLOPE_CONFIG);
-
-  if (filt)
-    reg |= SLOPE_CONFIG_FILTER;
-  else
-    reg &= ~SLOPE_CONFIG_FILTER;
-
-  return writeReg(REG_SLOPE_CONFIG, reg);
-}
-
-uint8_t BMA220::getInterruptStatus1()
-{
-  return (readReg(REG_INT_STATUS1) & 0x8f);
-}
-
-BMA220::CONFIG_ORIENT_T BMA220::getOrient()
-{
-  uint8_t reg = readReg(REG_INT_STATUS2);
-
-  reg &= (_INT_STATUS1_ORIENT_MASK << _INT_STATUS1_ORIENT_SHIFT);
-
-  reg >>= _INT_STATUS1_ORIENT_SHIFT;
-
-  return (CONFIG_ORIENT_T)reg;
-}
-
-uint8_t BMA220::getInterruptStatus2()
-{
-  return (readReg(REG_INT_STATUS2) & 0x1f);
-}
-
-bool BMA220::setInterruptEnables1(uint8_t bits)
-{
-  return writeReg(REG_ENABLE_CONFIG, bits);
-}
-
-uint8_t BMA220::getInterruptEnables1()
-{
-  return readReg(REG_ENABLE_CONFIG);
-}
-
-bool BMA220::setInterruptEnables2(uint8_t bits)
-{
-  uint8_t reg = readReg(REG_ENABLE_CONFIG2);
-
-  // only the first 4 bits...
-  bits &= 0x0f;
-  reg &= 0x0f;
-
-  reg |= bits;
-
-  return writeReg(REG_ENABLE_CONFIG2, reg);
-}
-
-uint8_t BMA220::getInterruptEnables2()
-{
-  return (readReg(REG_ENABLE_CONFIG2) & 0x0f);
-}
-
-bool BMA220::setInterruptLatch(CONFIG2_LAT_T lat)
-{
-  uint8_t reg = readReg(REG_ENABLE_CONFIG2);
-
-  reg &= ~(_ENABLE_CONFIG2_LAT_INT_MASK << _ENABLE_CONFIG2_LAT_INT_SHIFT);
-
-  reg |= (lat << _ENABLE_CONFIG2_LAT_INT_SHIFT);
-
-  return writeReg(REG_ENABLE_CONFIG2, reg);
-}
-
-bool BMA220::resetInterrupts()
-{
-  // This resets the interrupt controller, and should be called
-  // whenever the interrupt configuration changes
-  uint8_t reg = readReg(REG_ENABLE_CONFIG2);
-
-  reg |= ENABLE_CONFIG2_RESET_INT;
-
-  return writeReg(REG_ENABLE_CONFIG2, reg);
-}
-
-
-void BMA220::installISR(int gpio, mraa::Edge level,
-                        void (*isr)(void *), void *arg)
-{
-  // delete any existing ISR and GPIO context
-  uninstallISR();
-
-  // create gpio context
-  m_gpioIntr = new mraa::Gpio(gpio);
-
-  m_gpioIntr->dir(mraa::DIR_IN);
-  m_gpioIntr->isr(level, isr, arg);
-}
-
-void BMA220::uninstallISR()
-{
-  if (m_gpioIntr)
-    {
-      m_gpioIntr->isrExit();
-      delete m_gpioIntr;
-
-      m_gpioIntr = 0;
-    }
-}
-
-mraa::Gpio* BMA220::get_gpioIntr()
-{
-  return m_gpioIntr;
-}
diff --git a/src/bma220/bma220.hpp b/src/bma220/bma220.hpp
deleted file mode 100644
index a188f6e..0000000
--- a/src/bma220/bma220.hpp
+++ /dev/null
@@ -1,824 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <vector>
-#include <mraa/common.hpp>
-#include <mraa/i2c.hpp>
-#include <mraa/gpio.hpp>
-
-#define BMA220_I2C_BUS 0
-#define BMA220_DEFAULT_ADDR 0x0a
-
-namespace upm {
-
-  /**
-   * @brief BMA220 Accelerometer
-   * @defgroup bma220 libupm-bma220
-   * @ingroup i2c gpio accelerometer bosch dfrobot
-   */
-
-  /**
-   * @library bma220
-   * @sensor bma220
-   * @comname Digital Triaxial Acceleration Sensor
-   * @type accelerometer
-   * @man bosch dfrobot
-   * @con i2c gpio
-   * @web http://www.dfrobot.com/index.php?route=product/product&product_id=1085
-   *
-   * @brief API for the BMA220 3-axis  Accelerometer
-   *
-   * The BMA220 is a low cost, very small 3-axis accelerometer with 6
-   * bits of resolution.  It can also detect orientation and tap events.
-   *
-   * The BMA220 has a linear acceleration full scale of
-   * 2g/4g/8g/16g.
-   *
-   * While not all of the functionality of this device is supported
-   * initially, methods and register definitions are provided that
-   * should allow an end user to implement whatever features are
-   * required.
-   *
-   * This driver was developed on a DFRobot BMA (Tiny).
-   *
-   * @image html bma220.jpg
-   * @snippet bma220.cxx Interesting
-   */
-
-  class BMA220 {
-  public:
-
-    // NOTE: reserved registers must not be written into or read from.
-    // Reserved bitfields must always be 0.  The registers aren't
-    // named in the datasheet, so I made up some hopefully useful
-    // names for them.  The whole I2C register map design is a little
-    // strange, IMO.
-
-    /**
-     * BMA220 Accelerometer registers
-     */
-    typedef enum {
-      REG_CHIPID                = 0x00,
-      REG_REVISIONID            = 0x02,
-
-      // 2 lsb bits of ACC regs are always 0, yeilding 6 bits resolution
-      REG_ACC_X                 = 0x04, // acceleration data
-      REG_ACC_Y                 = 0x06,
-      REG_ACC_Z                 = 0x08,
-
-      REG_H_HYST_DUR            = 0x0a, // high hysteresis/dur
-      REG_THRESHOLD             = 0x0c, // high/low threshold
-      REG_L_HYST_DUR            = 0x0e, // low hysteresis/dur
-
-      REG_TAP_CONFIG            = 0x10,
-
-      REG_SLOPE_CONFIG          = 0x12,
-      REG_TAP_CONFIG2           = 0x14,
-
-      REG_INT_STATUS1           = 0x16,
-      REG_INT_STATUS2           = 0x18,
-
-      REG_ENABLE_CONFIG         = 0x1a,
-      REG_ENABLE_CONFIG2        = 0x1c,
-      REG_ENABLE_CONFIG3        = 0x1e,
-
-      REG_FILTER_CONFIG         = 0x20,
-
-      REG_SBIST_FSL_CONFIG      = 0x22, // self test and full scale range
-
-      // 0x24 - 0x2c reserved
-
-      REG_I2C_WATCHDOG          = 0x2e, // + SPI 3-wire mode
-
-      REG_SUSPEND               = 0x30,
-      REG_SOFTRESET             = 0x32
-    } REG_T;
-
-
-    /**
-     * REG_H_HYST_DUR bits
-     */
-    typedef enum {
-      H_HYST_DUR_HIGH_DUR0         = 0x01,
-      H_HYST_DUR_HIGH_DUR1         = 0x02,
-      H_HYST_DUR_HIGH_DUR2         = 0x04,
-      H_HYST_DUR_HIGH_DUR3         = 0x08,
-      H_HYST_DUR_HIGH_DUR4         = 0x10,
-      H_HYST_DUR_HIGH_DUR5         = 0x20,
-      _H_HYST_DUR_HIGH_DUR_MASK    = 63,
-      _H_HYST_DUR_HIGH_DUR_SHIFT   = 0,
-
-      H_HYST_DUR_HIGH_HY1          = 0x40,
-      H_HYST_DUR_HIGH_HY2          = 0x80,
-      _H_HYST_DUR_HIGH_HY_MASK     = 3,
-      _H_HYST_DUR_HIGH_HY_SHIFT    = 6
-    } H_HYST_DUR_HIGH_BITS_T;
-
-    /**
-     * REG_THRESHOLD bits
-     */
-    typedef enum {
-      THRESHOLD_HIGH0              = 0x01,
-      THRESHOLD_HIGH1              = 0x02,
-      THRESHOLD_HIGH2              = 0x04,
-      THRESHOLD_HIGH3              = 0x08,
-      _THRESHOLD_HIGH_MASK         = 15,
-      _THRESHOLD_HIGH_SHIFT        = 0,
-
-      THRESHOLD_LOW0               = 0x10,
-      THRESHOLD_LOW1               = 0x20,
-      THRESHOLD_LOW2               = 0x40,
-      THRESHOLD_LOW3               = 0x80,
-      _THRESHOLD_LOW_MASK          = 15,
-      _THRESHOLD_LOW_SHIFT         = 4
-    } THRESHOLD_BITS_T;
-
-    /**
-     * REG_L_HYST_DUR bits
-     */
-    typedef enum {
-      L_HYST_DUR_LOW_DUR0          = 0x01,
-      L_HYST_DUR_LOW_DUR1          = 0x02,
-      L_HYST_DUR_LOW_DUR2          = 0x04,
-      L_HYST_DUR_LOW_DUR3          = 0x08,
-      L_HYST_DUR_LOW_DUR4          = 0x10,
-      L_HYST_DUR_LOW_DUR5          = 0x20,
-      _L_HYST_DUR_LOW_DUR_MASK     = 63,
-      _L_HYST_DUR_LOW_DUR_SHIFT    = 0,
-
-      L_HYST_DUR_LOW_HY1           = 0x40,
-      L_HYST_DUR_LOW_HY2           = 0x80,
-      _L_HYST_DUR_LOW_HY_MASK      = 3,
-      _L_HYST_DUR_LOW_HY_SHIFT     = 6
-    } L_HYST_DUR_LOW_BITS_T;
-
-    /**
-     * REG_TAP_CONFIG bits
-     */
-    typedef enum {
-      TAP_CONFIG_DUR0              = 0x01,
-      TAP_CONFIG_DUR1              = 0x02,
-      TAP_CONFIG_DUR2              = 0x04,
-      _TAP_CONFIG_DUR_MASK         = 7,
-      _TAP_CONFIG_DUR_SHIFT        = 0,
-
-      TAP_CONFIG_THRESH0           = 0x08,
-      TAP_CONFIG_THRESH1           = 0x10,
-      TAP_CONFIG_THRESH2           = 0x20,
-      TAP_CONFIG_THRESH3           = 0x40,
-      _TAP_CONFIG_THRESH_MASK      = 15,
-      _TAP_CONFIG_THRESH_SHIFT     = 3,
-
-      TAP_CONFIG_FILTER            = 0x80
-    } TAP_CONFIG_BITS_T;
-
-    /**
-     * REG_SLOPE_CONFIG bits
-     */
-    typedef enum {
-      SLOPE_CONFIG_DUR0            = 0x01,
-      SLOPE_CONFIG_DUR1            = 0x02,
-      _SLOPE_CONFIG_DUR_MASK       = 3,
-      _SLOPE_CONFIG_DUR_SHIFT      = 0,
-
-      SLOPE_CONFIG_THRESH0         = 0x04,
-      SLOPE_CONFIG_THRESH1         = 0x08,
-      SLOPE_CONFIG_THRESH2         = 0x10,
-      SLOPE_CONFIG_THRESH3         = 0x20,
-      _SLOPE_CONFIG_THRESH_MASK    = 15,
-      _SLOPE_CONFIG_THRESH_SHIFT   = 2,
-
-      SLOPE_CONFIG_FILTER          = 0x40,
-      SLOPE_CONFIG_ORIENT_EX       = 0x80 // exchange x and z axis for orient
-    } SLOPE_CONFIG_BITS_T;
-
-    /**
-     * REG_TAP_CONFIG2 bits
-     */
-    typedef enum {
-      TAP_CONFIG2_SAMP0            = 0x01,
-      TAP_CONFIG2_SAMP1            = 0x02,
-      _TAP_CONFIG2_SAMP_MASK       = 3,
-      _TAP_CONFIG2_SAMP_SHIFT      = 0,
-
-      TAP_CONFIG2_ORIENT_BLOCK0    = 0x04,
-      TAP_CONFIG2_ORIENT_BLOCK1    = 0x08,
-      _TAP_CONFIG2_ORIENT_BLOCK_MASK = 3,
-      _TAP_CONFIG2_ORIENT_BLOCK_SHIFT = 2,
-
-      TAP_CONFIG2_TIP_EN           = 0x10
-
-      // 0x20-0x80 reserved
-    } TAP_CONFIG2_BITS_T;
-
-    /**
-     * TAP_CONFIG2_SAMP values
-     */
-    typedef enum {
-      TAP_SAMP_2                   = 0, // 2 data samples after wakeup
-      TAP_SAMP_4                   = 1,
-      TAP_SAMP_8                   = 2,
-      TAP_SAMP_16                  = 3
-    } TAP_SAMP_T;
-
-    /**
-     * TAP_CONFIG2_ORIENT_BLOCK values
-     *
-     */
-    typedef enum {
-      TAP_ORIENT_BLOCK_0           = 0, // orient blocking disabled
-      TAP_ORIENT_BLOCK_2           = 1, // |z|>0.9g OR |x|+|y| < 0.2g OR m<0.2g
-      TAP_ORIENT_BLOCK_3           = 2, // |z|>0.9g OR |x|+|y| < 0.3g OR m<0.3g
-      TAP_ORIENT_BLOCK_4           = 3, // |z|>0.9g OR |x|+|y| < 0.4g OR m<0.4g
-    } TAP_ORIENT_BLOCK_T;
-
-    /**
-     * REG_INT_STATUS1 bits
-     */
-    typedef enum {
-      INT_STATUS1_SIGN              = 0x01,
-      INT_STATUS1_FIRST_Z           = 0x02,
-      INT_STATUS1_FIRST_Y           = 0x04,
-      INT_STATUS1_FIRST_X           = 0x08,
-
-      INT_STATUS1_ORIENT0           = 0x10,
-      INT_STATUS1_ORIENT1           = 0x20,
-      INT_STATUS1_ORIENT2           = 0x40,
-      _INT_STATUS1_ORIENT_MASK      = 7,
-      _INT_STATUS1_ORIENT_SHIFT     = 4,
-
-      INT_STATUS1_ORIENT_INT         = 0x80 // orient intr was generated
-    } INT_STATUS1_BITS_T;
-
-    /**
-     * INT_STATUS1_ORIENT values
-     *
-     * These are values reported by the device if orientation
-     * detection is enabled.
-     */
-    typedef enum {
-      CONFIG_ORI_UP_PORT_UPRIGHT     = 0, // up portrait
-      CONFIG_ORI_UP_PORT_UPSIDE_DOWN = 1,
-      CONFIG_ORI_UP_LAND_LEFT        = 2, // landscape
-      CONFIG_ORI_UP_LAND_RIGHT       = 3,
-      CONFIG_ORI_DN_PORT_UPRIGHT     = 4, // down portrait
-      CONFIG_ORI_DN_PORT_UPSIDE_DOWN = 5,
-      CONFIG_ORI_DN_LAND_LEFT        = 6, // landscape
-      CONFIG_ORI_DN_LAND_RIGHT       = 7
-    } CONFIG_ORIENT_T;
-
-    /**
-     * REG_INT_STATUS2 bits
-     */
-    typedef enum {
-      INT_STATUS2_SLOPE            = 0x01,
-      INT_STATUS2_DATA             = 0x02,
-      INT_STATUS2_HIGH             = 0x04,
-      INT_STATUS2_LOW              = 0x08,
-      INT_STATUS2_TAP              = 0x10
-
-      // 0x20-0x80 reserved
-    } INT_STATUS2_BITS_T;
-
-    /**
-     * REG_ENABLE_CONFIG bits
-     */
-    typedef enum {
-      ENABLE_CONFIG_TT_Z           = 0x01,
-      ENABLE_CONFIG_TT_Y           = 0x02,
-      ENABLE_CONFIG_TT_X           = 0x04,
-      ENABLE_CONFIG_SLOPE_Z        = 0x08,
-      ENABLE_CONFIG_SLOPE_Y        = 0x10,
-      ENABLE_CONFIG_SLOPE_X        = 0x20,
-      ENABLE_CONFIG_ORIENT         = 0x40,
-      ENABLE_CONFIG_DATA           = 0x80
-    } ENABLE_CONFIG_BITS_T;
-
-    /**
-     * REG_ENABLE_CONFIG2 bits
-     */
-    typedef enum {
-      ENABLE_CONFIG2_HIGH_Z        = 0x01,
-      ENABLE_CONFIG2_HIGH_Y        = 0x02,
-      ENABLE_CONFIG2_HIGH_X        = 0x04,
-
-      ENABLE_CONFIG2_LOW           = 0x08,
-
-      ENABLE_CONFIG2_LAT_INT0      = 0x10, // interrupt latching
-      ENABLE_CONFIG2_LAT_INT1      = 0x20,
-      ENABLE_CONFIG2_LAT_INT2      = 0x40,
-      _ENABLE_CONFIG2_LAT_INT_MASK = 7,
-      _ENABLE_CONFIG2_LAT_INT_SHIFT = 4,
-
-      ENABLE_CONFIG2_RESET_INT     = 0x80 // reset interrupts
-    } ENABLE_CONFIG2_BITS_T;
-
-    /**
-     * ENABLE_CONFIG2_LAT values
-     *
-     * These are values that define the interrupt latching behavior
-     */
-    typedef enum {
-      CONFIG2_LAT_UNLATCH          = 0, // unlatched intrs
-      CONFIG2_LAT_0_25             = 1, // latch intr for 0.25s
-      CONFIG2_LAT_0_5              = 2, // latch intr for 0.5s
-      CONFIG2_LAT_1                = 3, // latch intr for 1s
-      CONFIG2_LAT_2                = 4, // latch intr for 2s
-      CONFIG2_LAT_4                = 5, // latch intr for 4s
-      CONFIG2_LAT_8                = 6, // latch intr for 8s
-      CONFIG2_LAT_PERM             = 7  // latch permanently
-    } CONFIG2_LAT_T;
-
-    /**
-     * REG_ENABLE_CONFIG3 bits
-     */
-    typedef enum {
-      ENABLE_CONFIG3_Z_CHAN        = 0x01,
-      ENABLE_CONFIG3_Y_CHAN        = 0x02,
-      ENABLE_CONFIG3_X_CHAN        = 0x04,
-
-      ENABLE_CONFIG3_SLEEP_DUR0    = 0x08,
-      ENABLE_CONFIG3_SLEEP_DUR1    = 0x10,
-      ENABLE_CONFIG3_SLEEP_DUR2    = 0x20,
-      _ENABLE_CONFIG3_SLEEP_DUR_MASK = 7,
-      _ENABLE_CONFIG3_SLEEP_DUR_SHIFT = 3,
-
-      ENABLE_CONFIG3_SLEEP_EN      = 0x40
-
-      // 0x80 reserved
-    } ENABLE_CONFIG3_BITS_T;
-
-    /**
-     *  ENABLE_CONFIG3_SLEEP_DUR values
-     *
-     * These are values that define the length of time the device
-     * sleeps before sampling when in sleep mode.
-     */
-    typedef enum {
-      SLEEP_DUR_2MS                = 0, // 2 ms
-      SLEEP_DUR_10MS               = 1,
-      SLEEP_DUR_25MS               = 2,
-      SLEEP_DUR_50MS               = 3,
-      SLEEP_DUR_100MS              = 4,
-      SLEEP_DUR_500MS              = 5,
-      SLEEP_DUR_1S                 = 6, // 1 second
-      SLEEP_DUR_2S                 = 7
-    } SLEEP_DUR_T;
-
-    /**
-     * REG_FILTER_CONFIG bits
-     */
-    typedef enum {
-      FILTER_CONFIG_FILTER0        = 0x01,
-      FILTER_CONFIG_FILTER1        = 0x02,
-      FILTER_CONFIG_FILTER2        = 0x04,
-      FILTER_CONFIG_FILTER3        = 0x08,
-      _FILTER_CONFIG_FILTER_MASK   = 15,
-      _FILTER_CONFIG_FILTER_SHIFT  = 0,
-
-      // 0x10-0x40 reserved
-
-      FILTER_CONFIG_SERIAL_HIGH_BW = 0x80
-    } FILTER_CONFIG_BITS_T;
-
-    /**
-     * FILTER_CONFIG_FILTER values
-     *
-     * These are values that define the digital filtering frequency
-     */
-    typedef enum {
-      FILTER_CONFIG_1KHZ           = 0, // 1Khz
-      FILTER_CONFIG_500HZ          = 1,
-      FILTER_CONFIG_250HZ          = 2,
-      FILTER_CONFIG_125HZ          = 3,
-      FILTER_CONFIG_64HZ           = 4,
-      FILTER_CONFIG_32HZ           = 5
-    } FILTER_CONFIG_T;
-
-    /**
-     * REG_SBIST_FSL_CONFIG bits
-     */
-    typedef enum {
-      REG_SBIST_FSL_RANGE0         = 0x01, // full scale range
-      REG_SBIST_FSL_RANGE1         = 0x02,
-      _REG_SBIST_FSL_RANGE_MASK    = 3,
-      _REG_SBIST_FSL_RANGE_SHIFT   = 0,
-
-      REG_SBIST_FSL_SBIST0         = 0x04, // self test enables
-      REG_SBIST_FSL_SBIST1         = 0x08,
-      _REG_SBIST_FSL_SBIST_MASK    = 3,
-      _REG_SBIST_FSL_SBIST_SHIFT   = 2,
-
-      REG_SBIST_FSL_SBIST_SIGN     = 0x10 // signedness of self test
-
-      // 0x20-0x80 reserved
-    } SBIST_FSL_CONFIG_BITS_T;
-
-    /**
-     * REG_SBIST_FSL_RANGE values
-     *
-     * These are values that define the Full Scale configuration
-     */
-    typedef enum {
-      FSL_RANGE_2G                 = 0, // 2G FSL
-      FSL_RANGE_4G                 = 1,
-      FSL_RANGE_8G                 = 2,
-      FSL_RANGE_16G                = 3
-    } FSL_RANGE_T;
-
-    /**
-     * REG_SBIST_FSL_SBIST values
-     *
-     * These are values that enable self test mode
-     */
-    typedef enum {
-      SBIST_OFF                    = 0, // self test off
-      SBIST_X                      = 1, // self test X
-      SBIST_Y                      = 2,
-      SBIST_Z                      = 3
-    } SBIST_T;
-
-    /**
-     * REG_I2C_WATCHDOG bits
-     */
-    typedef enum {
-      I2C_WATCHDOG_SPI3            = 0x01, // SPI 3wire mode (SPI not supported)
-
-      I2C_WATCHDOG_TO_SEL          = 0x02,
-      I2C_WATCHDOG_TO_EN           = 0x04
-
-      // 0x08-0x80 reserved
-    } I2C_WATCHDOG_BITS_T;
-
-
-    /**
-     * BMA220 constructor
-     *
-     * @param bus i2c bus to use
-     * @param addr the address for this device
-     */
-    BMA220(int bus=BMA220_I2C_BUS, uint8_t addr=BMA220_DEFAULT_ADDR);
-
-    /**
-     * BMA220 Destructor
-     */
-    ~BMA220();
-
-    /**
-     * update the accelerometer values
-     */
-    void update();
-
-    /**
-     * read a register
-     *
-     * @param reg the register to read
-     * @return the value of the register
-     */
-    uint8_t readReg(uint8_t reg);
-
-    /**
-     * write to a register
-     *
-     * @param reg the register to write to
-     * @param val the value to write
-     * @return true if successful, false otherwise
-     */
-    bool writeReg(uint8_t reg, uint8_t val);
-
-    /**
-     * return the chip ID
-     *
-     * @return the chip ID (usually 0xdd)
-     */
-    uint8_t getChipID();
-
-    /**
-     * return the chip revision
-     *
-     * @return the chip revision (usually 0x00)
-     */
-    uint8_t getChipRevision();
-
-    /**
-     * set the scaling mode of the accelerometer (2g/4g/8g/16g)
-     *
-     * @param scale one of the FSL_RANGE_T values
-     * @return true if successful, false otherwise
-     */
-    bool setAccelerometerScale(FSL_RANGE_T scale);
-
-    /**
-     * get the accelerometer values in gravities
-     *
-     * @param x the returned x value, if arg is non-NULL
-     * @param y the returned y value, if arg is non-NULL
-     * @param z the returned z value, if arg is non-NULL
-     */
-    void getAccelerometer(float *x, float *y, float *z);
-
-    /**
-     * get the accelerometer values in gravities
-     *
-     * @return std::vector containing X, Y, Z acceleration values
-     */
-    std::vector<float> getAccelerometer();
-
-    /**
-     * set the filtering configuration
-     *
-     * @param filter one of the FILTER_CONFIG_T values
-     * @return true if successful
-     */
-    bool setFilterConfig(FILTER_CONFIG_T filter);
-
-    /**
-     * enable or disable high bandwidth serial access (1Khz).  This
-     * essentially disables filtering and makes the raw unfiltered
-     * data available in the axis registers.
-     *
-     * @param high true to enable high bw access, false otherwise
-     * @return true if successful
-     */
-    bool setSerialHighBW(bool high);
-
-    /**
-     * enable or disable axis channels
-     *
-     * @param xEn true to enable the axis, false otherwise
-     * @param yEn true to enable the axis, false otherwise
-     * @param zEn true to enable the axis, false otherwise
-     * @return true if successful
-     */
-    bool enableAxes(bool xEn, bool yEn, bool zEn);
-
-    /**
-     * place the device into, or take the device out of suspend mode
-     *
-     * @return 0x00 if the device was in active mode, 0xff if the
-     * device was in suspend mode
-     */
-    uint8_t suspend();
-
-    /**
-     * place the device into, or take the device out of soft reset mode
-     *
-     * @return 0x00 if the device was in active mode, 0xff if the
-     * device was in soft reset mode
-     */
-    uint8_t softReset();
-
-    /**
-     * place the device into, or take the device out of low power
-     * mode.  See the datasheet for information on how low power mode
-     * is implemented on this device.
-     *
-     * @param enable true to set low power mode, false otherwise
-     * @return true if successful
-     */
-    bool sleep(bool enable);
-
-    /**
-     * when in low power (sleep) mode, specify how often the device
-     * wakes up to acquire samples.
-     *
-     * @param dur one of the SLEEP_DUR_T values
-     * @return true if successful
-     */
-    bool setSleepDuration(SLEEP_DUR_T dur);
-
-    /**
-     * specify the threshold for low G detection
-     *
-     * @param thresh see the datasheet
-     * @return true if successful
-     */
-    bool setLowGThreshold(uint8_t thresh);
-
-    /**
-     * specify the threshold for high G detection
-     *
-     * @param thresh see the datasheet
-     * @return true if successful
-     */
-    bool setHighGThreshold(uint8_t thresh);
-
-    /**
-     * specify the hysteresis for low G detection
-     *
-     * @param hyst 2 bit hysteresis value
-     * @return true if successful
-     */
-    bool setLowGHysteresis(uint8_t hyst);
-
-    /**
-     * specify the sample duration for low G detection
-     *
-     * @param dur the number of samples (depends on bandwidth)
-     * @return true if successful
-     */
-    bool setLowGDuration(uint8_t dur);
-
-    /**
-     * specify the hysteresis for high G detection
-     *
-     * @param hyst 2 bit hysteresis value
-     * @return true if successful
-     */
-    bool setHighGHysteresis(uint8_t hyst);
-
-    /**
-     * specify the sample duration for high G detection
-     *
-     * @param dur the number of samples (depends on bandwidth)
-     * @return true if successful
-     */
-    bool setHighGDuration(uint8_t dur);
-
-    /**
-     * specify the sample duration for tap detection
-     *
-     * @param dur the number of samples (depends on bandwidth)
-     * @return true if successful
-     */
-    bool setTapDuration(uint8_t dur);
-
-    /**
-     * specify the threshold for tap detection
-     *
-     * @param thresh see the datasheet
-     * @return true if successful
-     */
-    bool setTapThreshold(uint8_t thresh);
-
-    /**
-     * unable to disable tap filtering
-     *
-     * @param filt true to enable, false otherwise
-     * @return true if successful
-     */
-    bool enableTapFilter(bool filt);
-
-    /**
-     * specify the sample duration for slope detection
-     *
-     * @param dur the number of samples (depends on bandwidth)
-     * @return true if successful
-     */
-    bool setSlopeDuration(uint8_t dur);
-
-    /**
-     * specify the threshold for slope detection
-     *
-     * @param thresh see the datasheet
-     * @return true if successful
-     */
-    bool setSlopeThreshold(uint8_t thresh);
-
-    /**
-     * enable or disable slope filtering
-     *
-     * @param filt true to enable filtering, false otherwise
-     * @return true if successful
-     */
-    bool enableSlopeFilter(bool filt);
-
-    /**
-     * return a bitmask of the interrupt status 1 register
-     *
-     * @return bitmask of INT_STATUS1_BITS_T bits (minus the orient value)
-     */
-    uint8_t getInterruptStatus1();
-
-    /**
-     * return the orient value from the interrupt status 1 register
-     *
-     * @return one of the CONFIG_ORIENT_T values
-     */
-    CONFIG_ORIENT_T getOrient();
-
-    /**
-     * return a bitmask of the interrupt status 2 register
-     *
-     * @return bitmask of INT_STATUS2_BITS_T bits
-     */
-    uint8_t getInterruptStatus2();
-
-    /**
-     * enable interrupts for events in interrupt config register 1
-     *
-     * @param bits bitmask of ENABLE_CONFIG_BITS_T values
-     * @return true if successful
-     */
-    bool setInterruptEnables1(uint8_t bits);
-
-    /**
-     * return the enabled interrupts for events in interrupt config register 1
-     *
-     * @return bitmask of ENABLE_CONFIG_BITS_T values
-     */
-    uint8_t getInterruptEnables1();
-
-    /**
-     * enable interrupts for events in interrupt config register 2
-     *
-     * @param bits bitmask of ENABLE_CONFIG2_BITS_T values
-     * @return true if successful
-     */
-    bool setInterruptEnables2(uint8_t bits);
-
-    /**
-     * return the enabled interrupts for events in interrupt config register 2
-     *
-     * @return bitmask of ENABLE_CONFIG2_BITS_T values
-     */
-    uint8_t getInterruptEnables2();
-
-    /**
-     * configure interrupt latching behavior
-     *
-     * @param lat one of the CONFIG2_LAT_T values
-     * @return true if successful
-     */
-    bool setInterruptLatch(CONFIG2_LAT_T lat);
-
-    /**
-     * reset the interrupt controller.  This should be called after
-     * any changes are made to interrupt configuration, or to reset
-     * interrupts if latched interrupts have been enabled and an
-     * interrupt has occurred..
-     *
-     * @return true if successful
-     */
-    bool resetInterrupts();
-
-
-    /**
-     * install an interrupt handler.
-     *
-     * @param gpio gpio pin to use as interrupt pin
-     * @param level the interrupt trigger level (one of mraa::Edge
-     * values).  Make sure that you have configured the interrupt pin
-     * properly for whatever level you choose.
-     * @param isr the interrupt handler, accepting a void * argument
-     * @param arg the argument to pass the the interrupt handler
-     */
-    void installISR(int gpio, mraa::Edge level,
-                    void (*isr)(void *), void *arg);
-
-   /**
-     * uninstall a previously installed interrupt handler
-     *
-     */
-    void uninstallISR();
-
-    mraa::Gpio* get_gpioIntr();
-
-  protected:
-    mraa::I2c m_i2c;
-    mraa::Gpio *m_gpioIntr;
-    uint8_t m_addr;
-
-    // uncompensated accelerometer values
-    float m_accelX;
-    float m_accelY;
-    float m_accelZ;
-
-    // accelerometer full scale
-    float m_accelScale;
-
-  private:
-    /* Disable implicit copy and assignment operators */
-    BMA220(const BMA220&) = delete;
-    BMA220 &operator=(const BMA220&) = delete;
-
-    /**
-     * update the accelerometer values
-     */
-    void updateAccelerometer();
-
-  };
-}
diff --git a/src/bma220/bma220.i b/src/bma220/bma220.i
deleted file mode 100644
index d36c611..0000000
--- a/src/bma220/bma220.i
+++ /dev/null
@@ -1,54 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "arrays_java.i";
-%include "../java_buffer.i"
-
-%apply int {mraa::Edge};
-%apply float *INOUT { float *x, float *y, float *z };
-
-%typemap(jni) float* "jfloatArray"
-%typemap(jstype) float* "float[]"
-%typemap(jtype) float* "float[]"
-
-%typemap(javaout) float* {
-    return $jnicall;
-}
-
-%typemap(out) float *getAccelerometer {
-    $result = JCALL1(NewFloatArray, jenv, 3);
-    JCALL4(SetFloatArrayRegion, jenv, $result, 0, 3, $1);
-    delete [] $1;
-}
-
-%ignore getAccelerometer(float *, float *, float *);
-%ignore installISR(int, mraa::Edge, void *, void *);
-
-%define GETTER get_gpioIntr();
-%enddef
-
-JAVA_ADD_INSTALLISR_GPIO(upm::BMA220)
-JAVA_JNI_LOADLIBRARY(javaupm_bma220)
-#endif
-/* END Java syntax */
-
-/* BEGIN Javascript syntax  ------------------------------------------------- */
-#ifdef SWIGJAVASCRIPT
-%include "../upm_vectortypes.i"
-%pointer_functions(float, floatp);
-#endif
-/* END Javascript syntax */
-
-/* BEGIN Python syntax  ----------------------------------------------------- */
-#ifdef SWIGPYTHON
-%include "../upm_vectortypes.i"
-%pointer_functions(float, floatp);
-#endif
-/* END Python syntax */
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "bma220.hpp"
-%}
-%include "bma220.hpp"
-/* END Common SWIG syntax */
diff --git a/src/bma220/bma220.json b/src/bma220/bma220.json
deleted file mode 100644
index 866aaff..0000000
--- a/src/bma220/bma220.json
+++ /dev/null
@@ -1,59 +0,0 @@
-{
-    "Library": "bma220",
-    "Description": "Bosch Sensortec accelerometer library",
-    "Sensor Class": {
-        "BMA220": {
-            "Name": "Bosch BMA220 accelerometer",
-            "Description": "This is the UPM Module for the Bosch BMA220 accelerometer. A triaxis accelerometer which measures acceleration in three perpendicular axes. It offers interruption pins, as well as motion interrupts, which can be triggered via orientation, shock, or taps. DFRobot offers this on an evaluation board, known as SEN0168.",
-            "Aliases": ["BMA220", "DFRobot SEN0168"],
-            "Categories": ["accelerometer"],
-            "Connections": ["i2c", "gpio"],
-            "Project Type": ["industrial", "commercial", "prototyping"],
-            "Manufacturers": ["bosch"],
-            "Image": "bma220.jpg",
-            "Examples": {
-                "Python": ["bma220.py"],
-                "Node.js": ["bma220.js"],
-                "C++": ["bma220.cxx"]
-            },
-            "Specifications": {
-                "Vdd": {
-                    "unit": "V",
-                    "min": 1.62,
-                    "max": 1.98
-                },
-                "Supply Current Digital": {
-                    "Normal mode": {
-                        "unit": "uA",
-                        "typ" : "250"
-                    },
-                    "Low power mode": {
-                        "unit": "uA",
-                        "typ" : "10"
-                    },
-                    "Suspend mode": {
-                        "unit": "uA",
-                        "min" : "<1"
-                    }
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Wake-up time": {
-                    "unit": "ms",
-                    "max" : 1.2
-                },
-                "Start-up time": {
-                    "unit": "ms",
-                    "typ" : 1.5
-                }
-            },
-            "Urls": {
-                "Product Pages": ["http://www.mouser.com/ProductDetail/Bosch-Sensortec/BMA220/?qs=d72FGnIDsgT670fCZvhfag%3D%3D"],
-                "Datasheets": ["http://www.mouser.com/ds/2/783/BST-BMA220-DS003-08-838368.pdf"]
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/bma250e/CMakeLists.txt b/src/bma250e/CMakeLists.txt
deleted file mode 100644
index 8c72bb7..0000000
--- a/src/bma250e/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME bma250e
-    DESCRIPTION "3-Axis Digital Accelerometer"
-    C_HDR bma250e.h bma250e_defs.h
-    C_SRC bma250e.c
-    CPP_HDR bma250e.hpp
-    CPP_SRC bma250e.cxx
-    FTI_SRC bma250e_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/bma250e/bma250e.c b/src/bma250e/bma250e.c
deleted file mode 100644
index 2f8f4fb..0000000
--- a/src/bma250e/bma250e.c
+++ /dev/null
@@ -1,967 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <assert.h>
-
-#include "upm_utilities.h"
-#include "bma250e.h"
-
-// macro for converting a uint8_t low/high pair into a float
-#define INT16_TO_FLOAT(h, l) \
-    (float)( (int16_t)( (l) | ((h) << 8) ) )
-
-// SPI CS on and off functions
-static void _csOn(const bma250e_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->gpioCS)
-        mraa_gpio_write(dev->gpioCS, 0);
-}
-
-static void _csOff(const bma250e_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->gpioCS)
-        mraa_gpio_write(dev->gpioCS, 1);
-}
-
-// init
-bma250e_context bma250e_init(int bus, int addr, int cs)
-{
-    bma250e_context dev =
-        (bma250e_context)malloc(sizeof(struct _bma250e_context));
-
-    if (!dev)
-        return NULL;
-
-    // zero out context
-    memset((void *)dev, 0, sizeof(struct _bma250e_context));
-
-    // make sure MRAA is initialized
-    if (mraa_init() != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed.\n", __FUNCTION__);
-        bma250e_close(dev);
-        return NULL;
-    }
-
-    if (addr < 0)
-        dev->isSPI = true;
-
-    if (dev->isSPI)
-    {
-        if (!(dev->spi = mraa_spi_init(bus)))
-        {
-            printf("%s: mraa_spi_init() failed.\n", __FUNCTION__);
-            bma250e_close(dev);
-            return NULL;
-        }
-
-        // Only create cs context if we are actually using a valid pin.
-        // A hardware controlled pin should specify cs as -1.
-        if (cs >= 0)
-        {
-            if (!(dev->gpioCS = mraa_gpio_init(cs)))
-            {
-                printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
-                bma250e_close(dev);
-                return NULL;
-            }
-            mraa_gpio_dir(dev->gpioCS, MRAA_GPIO_OUT);
-        }
-
-        mraa_spi_mode(dev->spi, MRAA_SPI_MODE0);
-        if (mraa_spi_frequency(dev->spi, 5000000))
-        {
-            printf("%s: mraa_spi_frequency() failed.\n", __FUNCTION__);
-            bma250e_close(dev);
-            return NULL;
-        }
-    }
-    else
-    {
-        // I2C
-
-        if (!(dev->i2c = mraa_i2c_init(bus)))
-        {
-            printf("%s: mraa_i2c_init() failed.\n", __FUNCTION__);
-            bma250e_close(dev);
-            return NULL;
-        }
-
-        if (mraa_i2c_address(dev->i2c, addr))
-        {
-            printf("%s: mraa_i2c_address() failed.\n", __FUNCTION__);
-            bma250e_close(dev);
-            return NULL;
-        }
-    }
-
-    // check the chip id
-
-    uint8_t chipID = bma250e_get_chip_id(dev);
-
-    // check the various chips id's and set appropriate capabilities.
-    // Bail if the chip id is unknown.
-    switch (chipID)
-    {
-    case 0xf9: // standalone bma250e
-        dev->resolution = BMA250E_RESOLUTION_10BITS;
-        dev->fifoAvailable = true;
-
-        break;
-
-    case 0xfa: // bmx055, bmi055 variants, 12b resolution
-        dev->resolution = BMA250E_RESOLUTION_12BITS;
-        dev->fifoAvailable = true;
-
-        break;
-
-    case 0x03: // bmc050 variant, no FIFO, 12b resolution
-        dev->resolution = BMA250E_RESOLUTION_12BITS;
-        dev->fifoAvailable = false;
-
-        break;
-
-    default:
-        printf("%s: invalid chip id: %02x.  Expected f9, fa, or 03\n",
-               __FUNCTION__, chipID);
-        bma250e_close(dev);
-        return NULL;
-    }
-
-    // call devinit with default options
-    if (bma250e_devinit(dev, BMA250E_POWER_MODE_NORMAL, BMA250E_RANGE_2G,
-                        BMA250E_BW_250))
-    {
-        printf("%s: bma250e_devinit() failed.\n", __FUNCTION__);
-        bma250e_close(dev);
-        return NULL;
-    }
-
-    return dev;
-}
-
-void bma250e_close(bma250e_context dev)
-{
-    assert(dev != NULL);
-
-    bma250e_uninstall_isr(dev, BMA250E_INTERRUPT_INT1);
-    bma250e_uninstall_isr(dev, BMA250E_INTERRUPT_INT2);
-
-    if (dev->i2c)
-        mraa_i2c_stop(dev->i2c);
-    if (dev->spi)
-        mraa_spi_stop(dev->spi);
-    if (dev->gpioCS)
-        mraa_gpio_close(dev->gpioCS);
-
-    free(dev);
-}
-
-upm_result_t bma250e_devinit(const bma250e_context dev,
-                             BMA250E_POWER_MODE_T pwr,
-                             BMA250E_RANGE_T range,
-                             BMA250E_BW_T bw)
-{
-    assert(dev != NULL);
-
-    if (bma250e_set_power_mode(dev, pwr))
-    {
-        printf("%s: bma250e_set_power_mode() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    upm_delay_ms(50); // 50ms, in case we are waking up
-
-    // set our range and bandwidth, make sure register shadowing is
-    // enabled, enable output filtering, and set our FIFO config
-
-    if (bma250e_set_range(dev, range)
-        || bma250e_set_bandwidth(dev, bw)
-        || bma250e_enable_register_shadowing(dev, true)
-        || bma250e_enable_output_filtering(dev, true)
-        || bma250e_fifo_config(dev, BMA250E_FIFO_MODE_BYPASS,
-                               BMA250E_FIFO_DATA_SEL_XYZ))
-    {
-        printf("%s: failed to set configuration parameters.\n",
-               __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    bma250e_enable_fifo(dev, true);
-
-    // make sure low power mode LPM2 is enabled in case we go to low
-    // power or suspend mode. LPM1 mode (the default) requires register
-    // writes to be drastically slowed down when enabled, which we
-    // cannot handle.
-    bma250e_set_low_power_mode2(dev);
-
-    // settle
-    upm_delay_ms(50);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bma250e_update(const bma250e_context dev)
-{
-    assert(dev != NULL);
-
-    int bufLen = 7; // max, non-FIFO
-    uint8_t startReg = BMA250E_REG_ACCD_X_LSB;
-
-    if (dev->useFIFO)
-    {
-        bufLen = 6;
-        startReg = BMA250E_REG_FIFO_DATA;
-    }
-
-    uint8_t buf[bufLen];
-
-    if (bma250e_read_regs(dev, startReg, buf, bufLen) != bufLen)
-    {
-        printf("%s: bma250e_read_regs() failed to read %d bytes\n",
-               __FUNCTION__, bufLen);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    uint8_t mask = 0, shift = 0;
-    float divisor = 1;
-
-    switch (dev->resolution)
-    {
-    case BMA250E_RESOLUTION_10BITS:
-        mask = _BMA250E_ACCD10_LSB_MASK;
-        shift = _BMA250E_ACCD10_LSB_SHIFT;
-        divisor = 64.0;
-
-        break;
-
-    case BMA250E_RESOLUTION_12BITS:
-        mask = _BMA250E_ACCD12_LSB_MASK;
-        shift = _BMA250E_ACCD12_LSB_SHIFT;
-        divisor = 16.0;
-
-        break;
-    }
-
-    // x                       msb     lsb
-    dev->accX = INT16_TO_FLOAT(buf[1], (buf[0] & (mask << shift))) / divisor;
-
-    // y
-    dev->accY = INT16_TO_FLOAT(buf[3], (buf[2] & (mask << shift))) / divisor;
-
-    // z
-    dev->accZ = INT16_TO_FLOAT(buf[5], (buf[4] & (mask << shift))) / divisor;
-
-    // get the temperature...
-
-    int8_t temp = 0;
-    if (dev->useFIFO)
-    {
-        // we have to read temperature separately...
-        temp = (int8_t)bma250e_read_reg(dev, BMA250E_REG_TEMP);
-    }
-    else
-    {
-        // we already got it
-        temp = (int8_t)buf[6];
-    }
-
-    // .5K/LSB, 23C center point
-    dev->temperature = ((float)temp / 2.0) + 23.0;
-
-    return UPM_SUCCESS;
-}
-
-void bma250e_enable_fifo(const bma250e_context dev, bool useFIFO)
-{
-    assert(dev != NULL);
-
-    if (dev->fifoAvailable)
-        dev->useFIFO = useFIFO;
-}
-
-uint8_t bma250e_read_reg(const bma250e_context dev, uint8_t reg)
-{
-    assert(dev != NULL);
-
-    if (dev->isSPI)
-    {
-        reg |= 0x80; // needed for read
-        uint8_t pkt[2] = {reg, 0};
-
-        _csOn(dev);
-        if (mraa_spi_transfer_buf(dev->spi, pkt, pkt, 2))
-        {
-            _csOff(dev);
-            printf("%s: mraa_spi_transfer_buf() failed.\n", __FUNCTION__);
-            return 0xff;
-        }
-        _csOff(dev);
-
-        return pkt[1];
-    }
-    else
-        return (uint8_t)mraa_i2c_read_byte_data(dev->i2c, reg);
-}
-
-int bma250e_read_regs(const bma250e_context dev, uint8_t reg,
-                      uint8_t *buffer, int len)
-{
-    assert(dev != NULL);
-
-    if (dev->isSPI)
-    {
-        reg |= 0x80; // needed for read
-
-        uint8_t sbuf[len + 1];
-        memset((char *)sbuf, 0, len + 1);
-        sbuf[0] = reg;
-
-        _csOn(dev);
-        if (mraa_spi_transfer_buf(dev->spi, sbuf, sbuf, len + 1))
-        {
-            _csOff(dev);
-            printf("%s: mraa_spi_transfer_buf() failed.\n", __FUNCTION__);
-            return -1;
-        }
-        _csOff(dev);
-
-        // now copy it into user buffer
-        for (int i=0; i<len; i++)
-            buffer[i] = sbuf[i + 1];
-    }
-    else
-    {
-        if (mraa_i2c_read_bytes_data(dev->i2c, reg, buffer, len) != len)
-            return -1;
-    }
-
-    return len;
-}
-
-upm_result_t bma250e_write_reg(const bma250e_context dev,
-                               uint8_t reg, uint8_t val)
-{
-    assert(dev != NULL);
-
-    if (dev->isSPI)
-    {
-        reg &= 0x7f; // mask off 0x80 for writing
-        uint8_t pkt[2] = {reg, val};
-
-        _csOn(dev);
-        if (mraa_spi_transfer_buf(dev->spi, pkt, NULL, 2))
-        {
-            _csOff(dev);
-            printf("%s: mraa_spi_transfer_buf() failed.\n",
-                   __FUNCTION__);
-
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-        _csOff(dev);
-    }
-    else
-    {
-        if (mraa_i2c_write_byte_data(dev->i2c, val, reg))
-        {
-            printf("%s: mraa_i2c_write_byte_data() failed.\n",
-                   __FUNCTION__);
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-    }
-
-    return UPM_SUCCESS;
-}
-
-uint8_t bma250e_get_chip_id(const bma250e_context dev)
-{
-    assert(dev != NULL);
-
-    return bma250e_read_reg(dev, BMA250E_REG_CHIP_ID);
-}
-
-void bma250e_get_accelerometer(const bma250e_context dev,
-                               float *x, float *y, float *z)
-{
-    assert(dev != NULL);
-
-    if (x)
-        *x = (dev->accX * dev->accScale) / 1000.0;
-
-    if (y)
-        *y = (dev->accY * dev->accScale) / 1000.0;
-
-    if (z)
-        *z = (dev->accZ * dev->accScale) / 1000.0;
-}
-
-float bma250e_get_temperature(const bma250e_context dev)
-{
-    assert(dev != NULL);
-
-    return dev->temperature;
-}
-
-upm_result_t bma250e_reset(const bma250e_context dev)
-{
-    assert(dev != NULL);
-
-    if (bma250e_write_reg(dev, BMA250E_REG_SOFTRESET, BMA250E_RESET_BYTE))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    upm_delay(1);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bma250e_set_range(const bma250e_context dev,
-                               BMA250E_RANGE_T range)
-{
-    assert(dev != NULL);
-
-    if (bma250e_write_reg(dev, BMA250E_REG_PMU_RANGE, range))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    switch (dev->resolution)
-    {
-    case BMA250E_RESOLUTION_10BITS:
-        switch(range)
-        {
-        case BMA250E_RANGE_2G:
-            dev->accScale = 3.91; // milli-gravities
-            break;
-
-        case BMA250E_RANGE_4G:
-            dev->accScale = 7.81;
-            break;
-
-        case BMA250E_RANGE_8G:
-            dev->accScale = 15.63;
-            break;
-
-        case BMA250E_RANGE_16G:
-            dev->accScale = 31.25;
-            break;
-        }
-
-        break;
-
-    case BMA250E_RESOLUTION_12BITS:
-        switch(range)
-        {
-        case BMA250E_RANGE_2G:
-            dev->accScale = 0.98; // milli-gravities
-            break;
-
-        case BMA250E_RANGE_4G:
-            dev->accScale = 1.95;
-            break;
-
-        case BMA250E_RANGE_8G:
-            dev->accScale = 3.91;
-            break;
-
-        case BMA250E_RANGE_16G:
-            dev->accScale = 7.81;
-            break;
-        }
-
-        break;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bma250e_set_bandwidth(const bma250e_context dev,
-                                   BMA250E_BW_T bw)
-{
-    assert(dev != NULL);
-
-    if (bma250e_write_reg(dev, BMA250E_REG_PMU_BW, bw))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bma250e_set_power_mode(const bma250e_context dev,
-                                    BMA250E_POWER_MODE_T power)
-{
-    assert(dev != NULL);
-
-    // mask off reserved bits first
-    uint8_t reg =
-        bma250e_read_reg(dev, BMA250E_REG_PMU_LPW)
-        & ~_BMA250E_PMU_LPW_RESERVED_MASK;
-
-    reg &= ~(_BMA250E_PMU_LPW_POWER_MODE_MASK
-             << _BMA250E_PMU_LPW_POWER_MODE_SHIFT);
-    reg |= (power << _BMA250E_PMU_LPW_POWER_MODE_SHIFT);
-
-    if (bma250e_write_reg(dev, BMA250E_REG_PMU_LPW, power))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bma250e_fifo_set_watermark(const bma250e_context dev, int wm)
-{
-    assert(dev != NULL);
-
-    if (!dev->fifoAvailable)
-        return UPM_ERROR_NOT_SUPPORTED;
-
-    // mask off illegal values
-    uint8_t reg = ((uint8_t)wm) & _BMA250E_FIFO_CONFIG_0_WATER_MARK_MASK;
-
-    if (bma250e_write_reg(dev, BMA250E_REG_FIFO_CONFIG_0, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bma250e_fifo_config(const bma250e_context dev,
-                                 BMA250E_FIFO_MODE_T mode,
-                                 BMA250E_FIFO_DATA_SEL_T axes)
-{
-    assert(dev != NULL);
-
-    if (!dev->fifoAvailable)
-        return UPM_ERROR_NOT_SUPPORTED;
-
-    uint8_t reg = ( (mode << _BMA250E_FIFO_CONFIG_1_FIFO_MODE_SHIFT) |
-                    (axes << _BMA250E_FIFO_CONFIG_1_FIFO_DATA_SHIFT) );
-
-    if (bma250e_write_reg(dev, BMA250E_REG_FIFO_CONFIG_1, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bma250e_set_self_test(const bma250e_context dev,
-                                   bool sign, bool amp,
-                                   BMA250E_SELFTTEST_AXIS_T axis)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = (axis << _BMA250E_PMU_SELFTTEST_AXIS_SHIFT);
-
-    if (amp)
-        reg |= BMA250E_PMU_SELFTTEST_AMP;
-
-    if (sign)
-        reg |= BMA250E_PMU_SELFTTEST_SIGN;
-
-    if (bma250e_write_reg(dev, BMA250E_REG_PMU_SELFTEST, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-uint8_t bma250e_get_interrupt_enable0(const bma250e_context dev)
-{
-    assert(dev != NULL);
-
-    return (bma250e_read_reg(dev, BMA250E_REG_INT_EN_0)
-            & ~_BMA250E_INT_EN_0_RESERVED_BITS);
-}
-
-upm_result_t bma250e_set_interrupt_enable0(const bma250e_context dev,
-                                           uint8_t bits)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = bits & ~_BMA250E_INT_EN_0_RESERVED_BITS;
-
-    if (bma250e_write_reg(dev, BMA250E_REG_INT_EN_0, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-uint8_t bma250e_get_interrupt_enable1(const bma250e_context dev)
-{
-    assert(dev != NULL);
-
-    return (bma250e_read_reg(dev, BMA250E_REG_INT_EN_1)
-            & ~_BMA250E_INT_EN_1_RESERVED_BITS);
-}
-
-upm_result_t bma250e_set_interrupt_enable1(const bma250e_context dev,
-                                           uint8_t bits)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = bits & ~_BMA250E_INT_EN_1_RESERVED_BITS;
-
-    if (bma250e_write_reg(dev, BMA250E_REG_INT_EN_1, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-uint8_t bma250e_get_interrupt_enable2(const bma250e_context dev)
-{
-    assert(dev != NULL);
-
-    return (bma250e_read_reg(dev, BMA250E_REG_INT_EN_2)
-            & ~_BMA250E_INT_EN_2_RESERVED_BITS);
-}
-
-upm_result_t bma250e_set_interrupt_enable2(const bma250e_context dev,
-                                           uint8_t bits)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = bits & ~_BMA250E_INT_EN_2_RESERVED_BITS;
-
-    if (bma250e_write_reg(dev, BMA250E_REG_INT_EN_2, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-uint8_t bma250e_get_interrupt_map0(const bma250e_context dev)
-{
-    assert(dev != NULL);
-
-    return bma250e_read_reg(dev, BMA250E_REG_INT_MAP_0);
-}
-
-upm_result_t bma250e_set_interrupt_map0(const bma250e_context dev, uint8_t bits)
-{
-    assert(dev != NULL);
-
-    if (bma250e_write_reg(dev, BMA250E_REG_INT_MAP_0, bits))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-uint8_t bma250e_get_interrupt_map1(const bma250e_context dev)
-{
-    assert(dev != NULL);
-
-    return (bma250e_read_reg(dev, BMA250E_REG_INT_MAP_1)
-            & ~_BMA250E_INT_MAP_1_INT1_RESERVED_BITS);
-}
-
-upm_result_t bma250e_set_interrupt_map1(const bma250e_context dev, uint8_t bits)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = bits & ~_BMA250E_INT_MAP_1_INT1_RESERVED_BITS;
-
-    if (bma250e_write_reg(dev, BMA250E_REG_INT_MAP_1, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-uint8_t bma250e_get_interrupt_map2(const bma250e_context dev)
-{
-    assert(dev != NULL);
-
-    return bma250e_read_reg(dev, BMA250E_REG_INT_MAP_2);
-}
-
-upm_result_t bma250e_set_interrupt_map2(const bma250e_context dev, uint8_t bits)
-{
-    assert(dev != NULL);
-
-    if (bma250e_write_reg(dev, BMA250E_REG_INT_MAP_2, bits))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-uint8_t bma250e_get_interrupt_src(const bma250e_context dev)
-{
-    assert(dev != NULL);
-
-    return (bma250e_read_reg(dev, BMA250E_REG_INT_SRC)
-            & ~_BMA250E_INT_SRC_RESERVED_BITS);
-}
-
-upm_result_t bma250e_set_interrupt_src(const bma250e_context dev, uint8_t bits)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = bits & ~_BMA250E_INT_SRC_RESERVED_BITS;
-
-    if (bma250e_write_reg(dev, BMA250E_REG_INT_SRC, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-uint8_t bma250e_get_interrupt_output_control(const bma250e_context dev)
-{
-    assert(dev != NULL);
-
-    return (bma250e_read_reg(dev, BMA250E_REG_INT_OUT_CTRL)
-            & ~_BMA250E_INT_OUT_CTRL_INT1_RESERVED_BITS);
-}
-
-upm_result_t bma250e_set_interrupt_output_control(const bma250e_context dev,
-                                                  uint8_t bits)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = bits & ~_BMA250E_INT_OUT_CTRL_INT1_RESERVED_BITS;
-
-    if (bma250e_write_reg(dev, BMA250E_REG_INT_OUT_CTRL, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bma250e_clear_interrupt_latches(const bma250e_context dev)
-{
-    assert(dev != NULL);
-
-    uint8_t reg =
-        (bma250e_read_reg(dev, BMA250E_REG_INT_RST_LATCH)
-         & ~_BMA250E_INT_RST_LATCH_RESERVED_BITS);
-
-    reg |= BMA250E_INT_RST_LATCH_RESET_INT;
-
-    if (bma250e_write_reg(dev, BMA250E_REG_INT_RST_LATCH, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-BMA250E_RST_LATCH_T bma250e_get_interrupt_latch_behavior(
-    const bma250e_context dev)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = (bma250e_read_reg(dev, BMA250E_REG_INT_RST_LATCH)
-                   & ~_BMA250E_INT_RST_LATCH_RESERVED_BITS);
-
-    reg &= (_BMA250E_INT_RST_LATCH_MASK << _BMA250E_INT_RST_LATCH_SHIFT);
-
-    return (BMA250E_RST_LATCH_T)reg;
-}
-
-upm_result_t bma250e_set_interrupt_latch_behavior(const bma250e_context dev,
-                                                  BMA250E_RST_LATCH_T latch)
-{
-    assert(dev != NULL);
-
-    uint8_t reg =
-        (bma250e_read_reg(dev, BMA250E_REG_INT_RST_LATCH)
-         & ~_BMA250E_INT_RST_LATCH_RESERVED_BITS);
-
-    reg &= ~(_BMA250E_INT_RST_LATCH_MASK << _BMA250E_INT_RST_LATCH_SHIFT);
-    reg |= (latch << _BMA250E_INT_RST_LATCH_SHIFT);
-
-    if (bma250e_write_reg(dev, BMA250E_REG_INT_RST_LATCH, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bma250e_enable_register_shadowing(const bma250e_context dev,
-                                               bool shadow)
-{
-    assert(dev != NULL);
-
-    uint8_t reg =
-        (bma250e_read_reg(dev, BMA250E_REG_ACC_HBW)
-         & ~_BMA250E_ACC_HBW_RESERVED_BITS);
-
-    if (shadow)
-        reg &= ~BMA250E_ACC_HBW_SHADOW_DIS;
-    else
-        reg |= BMA250E_ACC_HBW_SHADOW_DIS;
-
-    if (bma250e_write_reg(dev, BMA250E_REG_ACC_HBW, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bma250e_enable_output_filtering(const bma250e_context dev,
-                                             bool filter)
-{
-    assert(dev != NULL);
-
-    uint8_t reg =
-        (bma250e_read_reg(dev, BMA250E_REG_ACC_HBW)
-         & ~_BMA250E_ACC_HBW_RESERVED_BITS);
-
-    if (filter)
-        reg &= ~BMA250E_ACC_HBW_DATA_HIGH_BW;
-    else
-        reg |= BMA250E_ACC_HBW_DATA_HIGH_BW;
-
-    if (bma250e_write_reg(dev, BMA250E_REG_ACC_HBW, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-uint8_t bma250e_get_interrupt_status0(const bma250e_context dev)
-{
-    assert(dev != NULL);
-
-    return bma250e_read_reg(dev, BMA250E_REG_INT_STATUS_0);
-}
-
-uint8_t bma250e_get_interrupt_status1(const bma250e_context dev)
-{
-    assert(dev != NULL);
-
-    return (bma250e_read_reg(dev, BMA250E_REG_INT_STATUS_1)
-            & ~_BMA250E_INT_STATUS_1_RESERVED_BITS);
-}
-
-uint8_t bma250e_get_interrupt_status2(const bma250e_context dev)
-{
-    assert(dev != NULL);
-
-    return bma250e_read_reg(dev, BMA250E_REG_INT_STATUS_2);
-}
-
-uint8_t bma250e_get_interrupt_status3_bits(const bma250e_context dev)
-{
-    assert(dev != NULL);
-
-    // filter out the orientation bitfield..
-    return (bma250e_read_reg(dev, BMA250E_REG_INT_STATUS_3)
-            & ~(_BMA250E_INT_STATUS_3_ORIENT_MASK
-                << _BMA250E_INT_STATUS_3_ORIENT_SHIFT));
-}
-
-BMA250E_ORIENT_T bma250e_get_interrupt_status3_orientation(
-    const bma250e_context dev)
-{
-    assert(dev != NULL);
-
-    // grab just the orientation bitfield
-    uint8_t reg = (bma250e_read_reg(dev, BMA250E_REG_INT_STATUS_3)
-                   & (_BMA250E_INT_STATUS_3_ORIENT_MASK
-                      << _BMA250E_INT_STATUS_3_ORIENT_SHIFT));
-
-    reg >>= _BMA250E_INT_STATUS_3_ORIENT_SHIFT;
-
-    return (BMA250E_ORIENT_T)reg;
-}
-
-upm_result_t bma250e_set_low_power_mode2(const bma250e_context dev)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = (bma250e_read_reg(dev, BMA250E_REG_PMU_LOW_POWER)
-                   & ~_BMA250E_LOW_POWER_RESERVED_BITS);
-
-    // we simply set the low power mode to 2.  Low power mode 1 slows
-    // down register write accesses, and we can't handle that.  In the
-    // words of the late Admiral Akbar: "We cannot handle firepower of
-    // that magnitude!" :(
-
-    reg |= BMA250E_LOW_POWER_LOWPOWER_MODE;
-
-    if (bma250e_write_reg(dev, BMA250E_REG_PMU_LOW_POWER, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bma250e_install_isr(const bma250e_context dev,
-                                 BMA250E_INTERRUPT_PINS_T intr, int gpio,
-                                 mraa_gpio_edge_t level,
-                                 void (*isr)(void *), void *arg)
-{
-    assert(dev != NULL);
-
-    // delete any existing ISR and GPIO context for this interrupt
-    bma250e_uninstall_isr(dev, intr);
-
-    mraa_gpio_context gpio_isr = NULL;
-
-    // create gpio context
-    if (!(gpio_isr = mraa_gpio_init(gpio)))
-    {
-        printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    mraa_gpio_dir(gpio_isr, MRAA_GPIO_IN);
-
-    if (mraa_gpio_isr(gpio_isr, level, isr, arg))
-    {
-        mraa_gpio_close(gpio_isr);
-        printf("%s: mraa_gpio_isr() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    switch (intr)
-    {
-    case BMA250E_INTERRUPT_INT1:
-        dev->gpio1 = gpio_isr;
-        break;
-
-    case BMA250E_INTERRUPT_INT2:
-        dev->gpio2 = gpio_isr;
-        break;
-    }
-
-    return UPM_SUCCESS;
-}
-
-void bma250e_uninstall_isr(const bma250e_context dev,
-                           BMA250E_INTERRUPT_PINS_T intr)
-{
-    assert(dev != NULL);
-
-    switch (intr)
-    {
-    case BMA250E_INTERRUPT_INT1:
-        if (dev->gpio1)
-        {
-            mraa_gpio_isr_exit(dev->gpio1);
-            mraa_gpio_close(dev->gpio1);
-            dev->gpio1 = NULL;
-        }
-        break;
-
-    case BMA250E_INTERRUPT_INT2:
-        if (dev->gpio2)
-        {
-            mraa_gpio_isr_exit(dev->gpio2);
-            mraa_gpio_close(dev->gpio2);
-            dev->gpio2 = NULL;
-        }
-        break;
-    }
-}
diff --git a/src/bma250e/bma250e.cxx b/src/bma250e/bma250e.cxx
deleted file mode 100644
index 9575d5c..0000000
--- a/src/bma250e/bma250e.cxx
+++ /dev/null
@@ -1,350 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016-2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <iostream>
-#include <stdexcept>
-#include <string>
-
-#include "bma250e.hpp"
-
-using namespace upm;
-using namespace std;
-
-// conversion from celsius to fahrenheit
-
-static float c2f(float c)
-{
-    return (c * (9.0 / 5.0) + 32.0);
-}
-
-BMA250E::BMA250E(int bus, int addr, int cs) :
-    m_bma250e(bma250e_init(bus, addr, cs))
-{
-    if (!m_bma250e)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bma250e_init() failed");
-}
-
-BMA250E::~BMA250E()
-{
-    bma250e_close(m_bma250e);
-}
-
-void BMA250E::init(BMA250E_POWER_MODE_T pwr, BMA250E_RANGE_T range,
-                   BMA250E_BW_T bw)
-{
-    if (bma250e_devinit(m_bma250e, pwr, range, bw))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bma250e_devinit() failed");
-}
-
-void BMA250E::update()
-{
-    if (bma250e_update(m_bma250e))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bma250e_update() failed");
-}
-
-void BMA250E::enableFIFO(bool useFIFO)
-{
-    bma250e_enable_fifo(m_bma250e, useFIFO);
-}
-
-uint8_t BMA250E::readReg(uint8_t reg)
-{
-    return bma250e_read_reg(m_bma250e, reg);
-}
-
-int BMA250E::readRegs(uint8_t reg, uint8_t *buffer, int len)
-{
-    int rv = bma250e_read_regs(m_bma250e, reg, buffer, len);
-    if (rv < 0)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bma250e_read_regs() failed");
-
-    return rv;
-}
-
-void BMA250E::writeReg(uint8_t reg, uint8_t val)
-{
-    if (bma250e_write_reg(m_bma250e, reg, val))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bma250e_write_reg() failed");
-}
-
-uint8_t BMA250E::getChipID()
-{
-    return bma250e_get_chip_id(m_bma250e);
-}
-
-void BMA250E::getAccelerometer(float *x, float *y, float *z)
-{
-    bma250e_get_accelerometer(m_bma250e, x, y, z);
-}
-
-std::vector<float> BMA250E::getAccelerometer()
-{
-    float v[3];
-
-    getAccelerometer(&v[0], &v[1], &v[2]);
-    return std::vector<float>(v, v+3);
-}
-
-float BMA250E::getTemperature(bool fahrenheit)
-{
-    float temperature = bma250e_get_temperature(m_bma250e);
-    if (fahrenheit)
-        return c2f(temperature);
-    else
-        return temperature;
-}
-
-void BMA250E::reset()
-{
-    if (bma250e_reset(m_bma250e))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bma250e_reset() failed");
-}
-
-void BMA250E::setRange(BMA250E_RANGE_T range)
-{
-    if (bma250e_set_range(m_bma250e, range))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bma250e_set_range() failed");
-}
-
-void BMA250E::setBandwidth(BMA250E_BW_T bw)
-{
-    if (bma250e_set_bandwidth(m_bma250e, bw))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bma250e_set_power_mode() failed");
-}
-
-void BMA250E::setPowerMode(BMA250E_POWER_MODE_T power)
-{
-    if (bma250e_set_power_mode(m_bma250e, power))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bma250e_set_power_mode() failed");
-}
-
-void BMA250E::fifoSetWatermark(int wm)
-{
-    if (bma250e_fifo_set_watermark(m_bma250e, wm))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bma250e_fifo_set_watermark() failed");
-}
-
-void BMA250E::fifoConfig(BMA250E_FIFO_MODE_T mode,
-                         BMA250E_FIFO_DATA_SEL_T axes)
-{
-    if (bma250e_fifo_config(m_bma250e, mode, axes))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bma250e_fifo_config() failed");
-}
-
-void BMA250E::setSelfTest(bool sign, bool amp, BMA250E_SELFTTEST_AXIS_T axis)
-{
-    if (bma250e_set_self_test(m_bma250e, sign, amp, axis))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bma250e_fifo_config() failed");
-}
-
-uint8_t BMA250E::getInterruptEnable0()
-{
-    return bma250e_get_interrupt_enable0(m_bma250e);
-}
-
-void BMA250E::setInterruptEnable0(uint8_t bits)
-{
-    if (bma250e_set_interrupt_enable0(m_bma250e, bits))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bma250e_set_interrupt_enable0() failed");
-}
-
-uint8_t BMA250E::getInterruptEnable1()
-{
-    return bma250e_get_interrupt_enable1(m_bma250e);
-}
-
-void BMA250E::setInterruptEnable1(uint8_t bits)
-{
-    if (bma250e_set_interrupt_enable1(m_bma250e, bits))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bma250e_set_interrupt_enable1() failed");
-}
-
-uint8_t BMA250E::getInterruptEnable2()
-{
-    return bma250e_get_interrupt_enable2(m_bma250e);
-}
-
-void BMA250E::setInterruptEnable2(uint8_t bits)
-{
-    if (bma250e_set_interrupt_enable2(m_bma250e, bits))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bma250e_set_interrupt_enable2() failed");
-}
-
-uint8_t BMA250E::getInterruptMap0()
-{
-    return bma250e_get_interrupt_map0(m_bma250e);
-}
-
-void BMA250E::setInterruptMap0(uint8_t bits)
-{
-    if (bma250e_set_interrupt_map0(m_bma250e, bits))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bma250e_set_interrupt_map0() failed");
-}
-
-uint8_t BMA250E::getInterruptMap1()
-{
-    return bma250e_get_interrupt_map1(m_bma250e);
-}
-
-void BMA250E::setInterruptMap1(uint8_t bits)
-{
-    if (bma250e_set_interrupt_map1(m_bma250e, bits))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bma250e_set_interrupt_map1() failed");
-}
-
-uint8_t BMA250E::getInterruptMap2()
-{
-    return bma250e_get_interrupt_map2(m_bma250e);
-}
-
-void BMA250E::setInterruptMap2(uint8_t bits)
-{
-    if (bma250e_set_interrupt_map2(m_bma250e, bits))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bma250e_set_interrupt_map2() failed");
-}
-
-uint8_t BMA250E::getInterruptSrc()
-{
-    return bma250e_get_interrupt_src(m_bma250e);
-}
-
-void BMA250E::setInterruptSrc(uint8_t bits)
-{
-    if (bma250e_set_interrupt_src(m_bma250e, bits))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bma250e_set_interrupt_src() failed");
-}
-
-uint8_t BMA250E::getInterruptOutputControl()
-{
-    return bma250e_get_interrupt_output_control(m_bma250e);
-}
-
-void BMA250E::setInterruptOutputControl(uint8_t bits)
-{
-    if (bma250e_set_interrupt_output_control(m_bma250e, bits))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bma250e_set_interrupt_output_control() failed");
-}
-
-void BMA250E::clearInterruptLatches()
-{
-    if (bma250e_clear_interrupt_latches(m_bma250e))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bma250e_clear_interrupt_latches() failed");
-}
-
-BMA250E_RST_LATCH_T BMA250E::getInterruptLatchBehavior()
-{
-    return bma250e_get_interrupt_latch_behavior(m_bma250e);
-}
-
-void BMA250E::setInterruptLatchBehavior(BMA250E_RST_LATCH_T latch)
-{
-    if (bma250e_set_interrupt_latch_behavior(m_bma250e, latch))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bma250e_set_interrupt_latch_behavior() failed");
-}
-
-void BMA250E::enableRegisterShadowing(bool shadow)
-{
-    if (bma250e_enable_register_shadowing(m_bma250e, shadow))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bma250e_enable_register_shadowing() failed");
-}
-
-void BMA250E::enableOutputFiltering(bool filter)
-{
-    if (bma250e_enable_output_filtering(m_bma250e, filter))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bma250e_enable_output_filtering() failed");
-}
-
-uint8_t BMA250E::getInterruptStatus0()
-{
-    return bma250e_get_interrupt_status0(m_bma250e);
-}
-
-uint8_t BMA250E::getInterruptStatus1()
-{
-    return bma250e_get_interrupt_status1(m_bma250e);
-}
-
-uint8_t BMA250E::getInterruptStatus2()
-{
-    return bma250e_get_interrupt_status2(m_bma250e);
-}
-
-uint8_t BMA250E::getInterruptStatus3Bits()
-{
-    return bma250e_get_interrupt_status3_bits(m_bma250e);
-}
-
-BMA250E_ORIENT_T BMA250E::getInterruptStatus3Orientation()
-{
-    return bma250e_get_interrupt_status3_orientation(m_bma250e);
-}
-
-void BMA250E::setLowPowerMode2()
-{
-    if (bma250e_set_low_power_mode2(m_bma250e))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bma250e_set_low_power_mode2() failed");
-}
-
-void BMA250E::installISR(BMA250E_INTERRUPT_PINS_T intr, int gpio,
-                         mraa::Edge level,
-                         void (*isr)(void *), void *arg)
-{
-    if (bma250e_install_isr(m_bma250e, intr, gpio,
-                           (mraa_gpio_edge_t)level, isr, arg))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bma250e_install_isr() failed");
-}
-
-void BMA250E::uninstallISR(BMA250E_INTERRUPT_PINS_T intr)
-{
-    bma250e_uninstall_isr(m_bma250e, intr);
-}
diff --git a/src/bma250e/bma250e.h b/src/bma250e/bma250e.h
deleted file mode 100644
index bed6609..0000000
--- a/src/bma250e/bma250e.h
+++ /dev/null
@@ -1,635 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <unistd.h>
-#include <string.h>
-
-#include <mraa/i2c.h>
-#include <mraa/spi.h>
-#include <mraa/gpio.h>
-
-#include "upm.h"
-
-#include "bma250e_defs.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    /**
-     * @file bma250e.h
-     * @library bma250e
-     * @brief C API for the bma250e driver
-     *
-     * @include bma250e.c
-     */
-
-    /**
-     * Device context
-     */
-    typedef struct _bma250e_context {
-        mraa_i2c_context i2c;
-        mraa_spi_context spi;
-        mraa_gpio_context gpioCS; // SPI CS pin
-        mraa_gpio_context gpio1;  // intr 1
-        mraa_gpio_context gpio2;  // intr 2
-
-        // using SPI?
-        bool isSPI;
-        // use the FIFO?
-        bool useFIFO;
-
-        // always stored in C
-        float temperature;
-
-        // does this chip support the fifo?
-        bool fifoAvailable;
-
-        // supported resolution
-        BMA250E_RESOLUTION_T resolution;
-
-        // acc data
-        float accX;
-        float accY;
-        float accZ;
-
-        // acceleration scaling
-        float accScale;
-    } *bma250e_context;
-
-    /**
-     * BMA250E initialization.
-     *
-     * This device can support both I2C and SPI. For SPI, set the addr
-     * to -1, and specify a positive integer representing the Chip
-     * Select (CS) pin for the cs argument.  If you are using a
-     * hardware CS pin (like edison with arduino breakout), then you
-     * can connect the proper pin to the hardware CS pin on your MCU
-     * and supply -1 for cs.  The default operating mode is I2C.
-     *
-     * @param bus I2C or SPI bus to use.
-     * @param addr The address for this device, or -1 for SPI.
-     * @param cs The gpio pin to use for the SPI Chip Select.  Use -1
-     * for I2C or for SPI with a hardware controlled pin.
-     * @return The device context, or NULL if an error occurred.
-     */
-    bma250e_context bma250e_init(int bus, int addr, int cs);
-
-    /**
-     * BMA250E Destructor.
-     *
-     * @param dev The device context.
-     */
-    void bma250e_close(bma250e_context dev);
-
-    /**
-     * Update the internal stored values from sensor data.
-     *
-     * @param dev The device context.
-     * @return UPM result.
-     */
-    upm_result_t bma250e_update(const bma250e_context dev);
-
-    /**
-     * Return the chip ID.
-     *
-     * @param dev The device context.
-     * @return The chip ID.
-     */
-    uint8_t bma250e_get_chip_id(const bma250e_context dev);
-
-    /**
-     * Return accelerometer data in gravities.  bma250e_update() must
-     * have been called prior to calling this method.
-     *
-     * @param dev The device context.
-     * @param x Pointer to a floating point value that will have the
-     * current x component placed into it.
-     * @param y Pointer to a floating point value that will have the
-     * current y component placed into it.
-     * @param z Pointer to a floating point value that will have the
-     * current z component placed into it.
-     */
-    void bma250e_get_accelerometer(const bma250e_context dev,
-                                   float *x, float *y, float *z);
-
-    /**
-     * Return the current measured temperature.  Note, this is not
-     * ambient temperature.  bma250e_update() must have been called prior to
-     * calling this method.
-     *
-     * @param dev The device context.
-     * @return The temperature in degrees Celsius.
-     */
-    float bma250e_get_temperature(const bma250e_context dev);
-
-    /**
-     * Initialize the device and start operation.  This function is
-     * called from bma250e_init(), so it will not need to be called by
-     * a user unless the device is reset.
-     *
-     * @param dev The device context.
-     * @param pwr One of the BMA250E_POWER_MODE_T values.
-     * @param range One of the BMA250E_RANGE_T values.
-     * @param bw One of the filtering BMA250E_BW_T values.
-     * @return UPM result.
-     */
-    upm_result_t bma250e_devinit(const bma250e_context dev,
-                                 BMA250E_POWER_MODE_T pwr,
-                                 BMA250E_RANGE_T range,
-                                 BMA250E_BW_T bw);
-
-    /**
-     * Reset the device as if during a power on reset.  All configured
-     * values are lost when this happens.  You should call
-     * bma250e_devinit() afterwards, or at least perform the same
-     * initialization bma250e_devinit() does before continuing.
-     *
-     * @param dev The device context.
-     * @return UPM result.
-     */
-    upm_result_t bma250e_reset(const bma250e_context dev);
-
-    /**
-     * Set the acceleration scaling range.  This device supports 2, 4,
-     * 8, and 16g ranges.
-     *
-     * @param dev The device context.
-     * @param range One of the BMA250E_RANGE_T values.
-     * @return UPM result.
-     */
-    upm_result_t bma250e_set_range(const bma250e_context dev,
-                                   BMA250E_RANGE_T range);
-
-    /**
-     * Set the output filtering bandwidth of the device.
-     *
-     * @param dev The device context.
-     * @param bw One of the BMA250E_BW_T values.
-     * @return UPM result.
-     */
-    upm_result_t bma250e_set_bandwidth(const bma250e_context dev,
-                                       BMA250E_BW_T bw);
-
-    /**
-     * Set the power mode of the device.  Care must be taken when
-     * setting a low power or suspend mode.  By default
-     * bma250e_devinit() calls bma250e_set_low_power_mode2() to ensure
-     * that if any of these modes are entered we can still talk to the
-     * device.  The default low power mode is LPM1, which requires
-     * slowing down register writes, which we cannot support.
-     * bma250e_set_low_power_mode2() enables LPM2 which keeps the
-     * digital interface operational in low power or suspend modes.
-     * See the datasheet for details.
-     *
-     * In short, if you reset your device and don't call
-     * bma250e_devinit() or bma250e_set_low_power_mode2(), you could
-     * lose control of the device by calling this function with
-     * anything other than BMA250E_POWER_MODE_NORMAL.  You've been
-     * warned :)
-     *
-     * @param dev The device context.
-     * @param power One of the BMA250E_POWER_MODE_T values.
-     * @return UPM result.
-     */
-    upm_result_t bma250e_set_power_mode(const bma250e_context dev,
-                                        BMA250E_POWER_MODE_T power);
-
-    /**
-     * Enable bma250e_update() to read from the FIFO rather than the
-     * accelerometer axis registers directly, if the device supports a
-     * FIFO.  bma250e_devinit() enables this mode by default.  An
-     * advantage to this mode that all axis data is sampled from the
-     * same timeslice.  When reading directly from the accelerometer
-     * output registers, it's possible for one axis to be updated
-     * while another is being read, causing a temporal inconsistency.
-     *
-     * Using the FIFO removes this problem.
-     *
-     * @param dev The device context.
-     * @param useFIFO true to enable bma250e_update() to read from the FIFO.
-     * When false, update will read from the accelerometer output
-     * registers directly.
-     */
-    void bma250e_enable_fifo(const bma250e_context dev, bool useFIFO);
-
-    /**
-     * Set the FIFO watermark.  When the watermark is reached an
-     * interrupt (if enabled) will be generated.
-     *
-     * @param dev The device context.
-     * @param wm The FIFO watermark to use.  The maximum value is 63.
-     * @return UPM result.
-     */
-    upm_result_t bma250e_fifo_set_watermark(const bma250e_context dev, int wm);
-
-    /**
-     * Set the FIFO configuration.  bma250e_devinit() uses the
-     * BMA250E_FIFO_MODE_BYPASS mode with axes set to
-     * BMA250E_FIFO_DATA_SEL_XYZ by default.
-     *
-     * @param dev The device context.
-     * @param mode One of the BMA250E_FIFO_MODE_T values.
-     * @param axes One of the BMA250E_FIFO_DATA_SEL_T values.
-     * @return UPM result.
-     */
-    upm_result_t bma250e_fifo_config(const bma250e_context dev,
-                                     BMA250E_FIFO_MODE_T mode,
-                                     BMA250E_FIFO_DATA_SEL_T axes);
-
-    /**
-     * Enable, disable, and configure the built in self test on a per
-     * axis basis.  See the datasheet for details.
-     *
-     * @param sign True for a positive deflection, false for negative.
-     * @param amp True for a high deflection, false for a low deflection.
-     * @param axis One of the BMA250E_SELFTTEST_AXIS_T values.  Note,
-     * only one axis at a time can be tested.  Accelerometer output
-     * for other axes should be ignored.
-     * @return UPM result.
-     */
-    upm_result_t bma250e_set_self_test(const bma250e_context dev,
-                                       bool sign, bool amp,
-                                       BMA250E_SELFTTEST_AXIS_T axis);
-
-    /**
-     * Return the Interrupt Enables 0 register.  These registers
-     * allow you to enable various interrupt conditions.  See the
-     * datasheet for details.
-     *
-     * @param dev The device context.
-     * @return A bitmask of BMA250E_INT_EN_0_BITS_T bits.
-     */
-    uint8_t bma250e_get_interrupt_enable0(const bma250e_context dev);
-
-    /**
-     * Set the Interrupt Enables 0 register.  See the datasheet for
-     * details.
-     *
-     * @param dev The device context.
-     * @param bits A bitmask of BMA250E_INT_EN_0_BITS_T bits.
-     * @return UPM result.
-     */
-    upm_result_t bma250e_set_interrupt_enable0(const bma250e_context dev,
-                                               uint8_t bits);
-
-    /**
-     * Return the Interrupt Enables 1 register.  These registers
-     * allow you to enable various interrupt conditions.  See the
-     * datasheet for details.
-     *
-     * @param dev The device context.
-     * @return A bitmask of BMA250E_INT_EN_1_BITS_T bits.
-     */
-    uint8_t bma250e_get_interrupt_enable1(const bma250e_context dev);
-
-    /**
-     * Set the Interrupt Enables 1 register.  See the datasheet for
-     * details.
-     *
-     * @param dev The device context.
-     * @param bits A bitmask of BMA250E_INT_EN_1_BITS_T bits.
-     * @return UPM result.
-     */
-    upm_result_t bma250e_set_interrupt_enable1(const bma250e_context dev,
-                                               uint8_t bits);
-    /**
-     * Return the Interrupt Enables 2 register.  These registers
-     * allow you to enable various interrupt conditions.  See the
-     * datasheet for details.
-     *
-     * @param dev The device context.
-     * @return A bitmask of BMA250E_INT_EN_2_BITS_T bits.
-     */
-    uint8_t bma250e_get_interrupt_enable2(const bma250e_context dev);
-
-    /**
-     * Set the Interrupt Enables 2 register.  See the datasheet for
-     * details.
-     *
-     * @param dev The device context.
-     * @param bits A bitmask of BMA250E_INT_EN_2_BITS_T bits.
-     * @return UPM result.
-     */
-    upm_result_t bma250e_set_interrupt_enable2(const bma250e_context dev,
-                                               uint8_t bits);
-
-    /**
-     * Return the Interrupt Map 0 register.  These registers allow you
-     * to map specific interrupts to the interrupt 1 or interrupt 2
-     * pin.  See the datasheet for details.
-     *
-     * @param dev The device context.
-     * @return A bitmask of BMA250E_INT_MAP_0_BITS_T bits.
-     */
-    uint8_t bma250e_get_interrupt_map0(const bma250e_context dev);
-
-    /**
-     * Set the Interrupt Map 0 register.  These registers allow you
-     * to map specific interrupts to the interrupt 1 or interrupt 2
-     * pin.  See the datasheet for details.
-     *
-     * @param dev The device context.
-     * @param bits A bitmask of BMA250E_INT_MAP_0_BITS_T bits.
-     * @return UPM result.
-     */
-    upm_result_t bma250e_set_interrupt_map0(const bma250e_context dev,
-                                            uint8_t bits);
-
-    /**
-     * Return the Interrupt Map 1 register.  See the datasheet for
-     * details.
-     *
-     * @param dev The device context.
-     * @return A bitmask of BMA250E_INT_MAP_1_BITS_T bits.
-     */
-    uint8_t bma250e_get_interrupt_map1(const bma250e_context dev);
-
-    /**
-     * Set the Interrupt Map 1 register.  See the datasheet for
-     * details.
-     *
-     * @param dev The device context.
-     * @param bits A bitmask of BMA250E_INT_MAP_1_BITS_T bits.
-     * @return UPM result.
-     */
-    upm_result_t bma250e_set_interrupt_map1(const bma250e_context dev,
-                                            uint8_t bits);
-
-    /**
-     * Return the Interrupt Map 2 register.  See the datasheet for
-     * details.
-     *
-     * @param dev The device context.
-     * @return A bitmask of BMA250E_INT_MAP_2_BITS_T bits.
-     */
-    uint8_t bma250e_get_interrupt_map2(const bma250e_context dev);
-
-    /**
-     * Set the Interrupt Map 2 register.  See the datasheet for
-     * details.
-     *
-     * @param dev The device context.
-     * @param bits A bitmask of BMA250E_INT_MAP_2_BITS_T bits.
-     * @return UPM result.
-     */
-    upm_result_t bma250e_set_interrupt_map2(const bma250e_context dev,
-                                            uint8_t bits);
-
-    /**
-     * Return the Interrupt source register.  This register allows
-     * determining where data comes from (filtered/unfiltered) for
-     * those interrupt sources where this is selectable.  See the
-     * datasheet for details.
-     *
-     * @param dev The device context.
-     * @return A bitmask of BMA250E_INT_SRC_BITS_T bits.
-     */
-    uint8_t bma250e_get_interrupt_src(const bma250e_context dev);
-
-    /**
-     * Set the Interrupt source register.  This register allows
-     * determining where data comes from (filtered/unfiltered) for
-     * those interrupt sources where this is selectable.  See the
-     * datasheet for details.
-     *
-     * @param dev The device context.
-     * @param bits A bitmask of BMA250E_INT_SRC_BITS_T bits.
-     * @return UPM result.
-     */
-    upm_result_t bma250e_set_interrupt_src(const bma250e_context dev,
-                                           uint8_t bits);
-
-    /**
-     * Return the Interrupt output control register.  This register
-     * allows determining the electrical characteristics of the 2
-     * interrupt pins (open-drain/push-pull and level/edge
-     * triggering).  See the datasheet for details.
-     *
-     * @param dev The device context.
-     * @return A bitmask of BMA250E_INT_OUT_CTRL_BITS_T bits.
-     */
-    uint8_t bma250e_get_interrupt_output_control(const bma250e_context dev);
-
-    /**
-     * Set the Interrupt output control register.  This register
-     * allows determining the electrical characteristics of the 2
-     * interrupt pins (open-drain/push-pull and level/edge
-     * triggering).  See the datasheet for details.
-     *
-     * @param dev The device context.
-     * @param bits A bitmask of BMA250E_INT_OUT_CTRL_BITS_T bits.
-     * @return UPM result.
-     */
-    upm_result_t bma250e_set_interrupt_output_control(const bma250e_context dev,
-                                                      uint8_t bits);
-
-    /**
-     * Clear all latched interrupts.  See the datasheet for details.
-     *
-     * @param dev The device context.
-     * @return UPM result.
-     */
-    upm_result_t bma250e_clear_interrupt_latches(const bma250e_context dev);
-
-    /**
-     * Return the current interrupt latching behavior.  See the
-     * datasheet for details.
-     *
-     * @param dev The device context.
-     * @return One of the BMA250E_RST_LATCH_T values.
-     */
-    BMA250E_RST_LATCH_T bma250e_get_interrupt_latch_behavior(
-        const bma250e_context dev);
-
-    /**
-     * Set the current interrupt latching behavior.  See the datasheet
-     * for details.
-     *
-     * @param dev The device context.
-     * @param latch One of the BMA250E_RST_LATCH_T values.
-     * @return UPM result.
-     */
-    upm_result_t bma250e_set_interrupt_latch_behavior(
-        const bma250e_context dev,
-        BMA250E_RST_LATCH_T latch);
-
-    /**
-     * Return the interrupt status 0 register.  These registers
-     * indicate which interrupts have been triggered.  See the
-     * datasheet for details.
-     *
-     * @param dev The device context.
-     * @return a bitmask of BMA250E_INT_STATUS_0_BITS_T bits.
-     */
-    uint8_t bma250e_get_interrupt_status0(const bma250e_context dev);
-
-    /**
-     * Return the interrupt status 1 register.  See the datasheet for
-     * details.
-     *
-     * @param dev The device context.
-     * @return a bitmask of BMA250E_INT_STATUS_1_BITS_T bits.
-     */
-    uint8_t bma250e_get_interrupt_status1(const bma250e_context dev);
-
-    /**
-     * Return the interrupt status 2 register.  See the datasheet for
-     * details.
-     *
-     * @param dev The device context.
-     * @return a bitmask of BMA250E_INT_STATUS_2_BITS_T bits.
-     */
-    uint8_t bma250e_get_interrupt_status2(const bma250e_context dev);
-
-    /**
-     * Return the interrupt status 3 register bitfields.  See the
-     * datasheet for details.  The Orientation value is not returned
-     * by this function, see
-     * bma250e_get_interrupt_status3_orientation() for that
-     * information.
-     *
-     * @param dev The device context.
-     * @return a bitmask of BMA250E_INT_STATUS_3_BITS_T bits only.
-     */
-    uint8_t bma250e_get_interrupt_status3_bits(const bma250e_context dev);
-
-    /**
-     * Return the interrupt status 3 register Orientation value.  See the
-     * datasheet for details.
-     *
-     * @param dev The device context.
-     * @return One of the BMA250E_ORIENT_T values.
-     */
-    BMA250E_ORIENT_T bma250e_get_interrupt_status3_orientation(
-        const bma250e_context dev);
-
-    /**
-     * Enable shadowing of the accelerometer output registers.  When
-     * enabled, a read of an axis LSB register automatically locks the
-     * MSB register of that axis until it has been read.  This is
-     * usually a good thing to have enabled.  bma250e_devinit() enables
-     * this by default.  If disabled, then it becomes possible for
-     * part of an axis value to change while another part is being
-     * read, causing inconsistent data.
-     *
-     * @param dev The device context.
-     * @param shadow true to enable axis register shadowing, false otherwise.
-     * @return UPM result.
-     */
-    upm_result_t bma250e_enable_register_shadowing(const bma250e_context dev,
-                                                   bool shadow);
-
-    /**
-     * Enable filtering of the accelerometer axis data.
-     * bma250e_devinit() enables this by default.  If disabled, then
-     * accelerometer data that is read will be raw and unfiltered
-     * (rated NC-17, mature audiences only).  See the datasheet for
-     * details.
-     *
-     * @param dev The device context.
-     * @param filter true to enable filtering, false to disable.
-     * @return UPM result.
-     */
-    upm_result_t bma250e_enable_output_filtering(const bma250e_context dev,
-                                                 bool filter);
-
-    /**
-     * Make sure low power mode config (LPM2) is set in case we later
-     * go into the low power or suspend power modes.  LPM1 mode (the
-     * default) requires drastically slowed register writes which we
-     * cannot handle.
-     *
-     * @param dev The device context.
-     * @return UPM result.
-     */
-    upm_result_t bma250e_set_low_power_mode2(const bma250e_context dev);
-
-    /**
-     * install an interrupt handler.
-     *
-     * @param dev The device context.
-     * @param intr One of the BMA250E_INTERRUPT_PINS_T values
-     * specifying which interrupt pin you are installing.
-     * @param gpio GPIO pin to use as interrupt pin
-     * @param level The interrupt trigger level (one of the
-     * mraa_gpio_edge_t values).  Make sure that you have configured
-     * the interrupt pin properly for whatever level you choose.
-     * @param isr The interrupt handler, accepting a void * argument
-     * @param arg The argument to pass to the interrupt handler
-     * @return UPM result.
-     */
-    upm_result_t bma250e_install_isr(const bma250e_context dev,
-                                     BMA250E_INTERRUPT_PINS_T intr, int gpio,
-                                     mraa_gpio_edge_t level,
-                                     void (*isr)(void *), void *arg);
-
-    /**
-     * uninstall a previously installed interrupt handler
-     *
-     * @param dev The device context.
-     * @param intr One of the BMA250E_INTERRUPT_PINS_T values
-     * specifying which interrupt pin you are removing.
-     */
-    void bma250e_uninstall_isr(const bma250e_context dev,
-                               BMA250E_INTERRUPT_PINS_T intr);
-
-    /**
-     * Read a register.
-     *
-     * @param dev The device context.
-     * @param reg The register to read.
-     * @return The value of the register.
-     */
-    uint8_t bma250e_read_reg(const bma250e_context dev, uint8_t reg);
-
-    /**
-     * Read contiguous registers into a buffer.
-     *
-     * @param dev The device context.
-     * @param buffer The buffer to store the results.
-     * @param len The number of registers to read.
-     * @return The number of bytes read, or -1 on error.
-     */
-    int bma250e_read_regs(const bma250e_context dev, uint8_t reg,
-                          uint8_t *buffer, int len);
-
-    /**
-     * Write to a register.
-     *
-     * @param dev The device context.
-     * @param reg The register to write to.
-     * @param val The value to write.
-     * @return UPM result.
-     */
-    upm_result_t bma250e_write_reg(const bma250e_context dev,
-                                   uint8_t reg, uint8_t val);
-
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/bma250e/bma250e.hpp b/src/bma250e/bma250e.hpp
deleted file mode 100644
index 5ebaba7..0000000
--- a/src/bma250e/bma250e.hpp
+++ /dev/null
@@ -1,582 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016-2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <vector>
-
-#include <mraa/gpio.hpp>
-#include "bma250e.h"
-
-namespace upm {
-
-    /**
-     * @brief BMA250E 3-axis Accelerometer
-     * @defgroup bma250e libupm-bma250e
-     * @ingroup i2c spi gpio bosch accelerometer
-     */
-
-    /**
-     * @library bma250e
-     * @sensor bma250e
-     * @comname Digital Triaxial Acceleration Sensor
-     * @type accelerometer
-     * @man bosch
-     * @con i2c spi gpio
-     * @web https://www.bosch-sensortec.com/bst/products/all_products/bma250e
-     *
-     * @brief API for the BMA250E 10 bit Triaxial Accelerometer
-     *
-     * The BMA250E is a triaxial, low-g acceleration sensor with digital
-     * output for consumer applications. It allows measurements of
-     * acceleration in three perpendicular axes. An evaluation circuitry
-     * (ASIC) converts the output of a micromechanical
-     * acceleration-sensing structure (MEMS) that works according to the
-     * differential capacitance principle.
-     *
-     * Not all functionality of this chip has been implemented in this
-     * driver, however all the pieces are present to add any desired
-     * functionality.  This driver supports both I2C (default) and SPI
-     * operation.
-     *
-     * This driver attempts to support verious flavors of this chip,
-     * such as the version on the BMX050, BMI050 (chipid 0xfa) and the
-     * version on the bmc050 (chipid 0x03).  Not all functionality is
-     * appropriate, or even present on all chips.  Consult the relevant
-     * datasheets.
-     *
-     * This device requires 3.3v operation.
-     *
-     * @snippet bma250e.cxx Interesting
-     */
-
-    class BMA250E {
-    public:
-
-        /**
-         * BMA250E constructor.
-         *
-         * This device can support both I2C and SPI. For SPI, set the addr
-         * to -1, and specify a positive integer representing the Chip
-         * Select (CS) pin for the cs argument.  If you are using a
-         * hardware CS pin (like edison with arduino breakout), then you
-         * can connect the proper pin to the hardware CS pin on your MCU
-         * and supply -1 for cs.  The default operating mode is I2C.
-         *
-         * @param bus I2C or SPI bus to use.
-         * @param addr The address for this device.  -1 for SPI.
-         * @param cs The gpio pin to use for the SPI Chip Select.  -1 for
-         * I2C or for SPI with a hardware controlled pin.
-         * @throws std::runtime_error on initialization failure.
-         */
-        BMA250E(int bus=BMA250E_DEFAULT_I2C_BUS,
-                int addr=BMA250E_DEFAULT_ADDR,
-                int cs=-1);
-
-        /**
-         * BMA250E Destructor.
-         */
-        ~BMA250E();
-
-        /**
-         * Update the internal stored values from sensor data.
-         *
-         * @throws std::runtime_error on failure.
-         */
-        void update();
-
-        /**
-         * Return the chip ID.
-         *
-         * @return The chip ID.
-         */
-        uint8_t getChipID();
-
-        /**
-         * Return accelerometer data in gravities.  update() must have
-         * been called prior to calling this method.
-         *
-         * @param x Pointer to a floating point value that will have the
-         * current x component placed into it.
-         * @param y Pointer to a floating point value that will have the
-         * current y component placed into it.
-         * @param z Pointer to a floating point value that will have the
-         * current z component placed into it.
-         */
-        void getAccelerometer(float *x, float *y, float *z);
-
-        /**
-         * Return accelerometer data in gravities in the form of a
-         * floating point vector.  update() must have been called
-         * prior to calling this method.
-         *
-         * @return A floating point vector containing x, y, and z in
-         * that order.
-         */
-        std::vector<float> getAccelerometer();
-
-        /**
-         * Return the current measured temperature.  Note, this is not
-         * ambient temperature.  update() must have been called prior to
-         * calling this method.
-         *
-         * @param fahrenheit true to return data in Fahrenheit, false for
-         * Celicus.  Celsius is the default.
-         * @return The temperature in degrees Celsius or Fahrenheit.
-         */
-        float getTemperature(bool fahrenheit=false);
-
-        /**
-         * Initialize the device and start operation.  This function is
-         * called from the constructor so will not typically need to be
-         * called by a user unless the device is reset.
-         *
-         * @param pwr One of the BMA250E_POWER_MODE_T values.  The default is
-         * BMA250E_POWER_MODE_NORMAL.
-         * @param range One of the BMA250E_RANGE_T values.  The default is
-         * BMA250E_RANGE_2G.
-         * @param bw One of the filtering BMA250E_BW_T values.  The default is
-         * BMA250E_BW_250.
-         * @throws std::runtime_error on failure.
-         */
-        void init(BMA250E_POWER_MODE_T pwr=BMA250E_POWER_MODE_NORMAL,
-                  BMA250E_RANGE_T range=BMA250E_RANGE_2G,
-                  BMA250E_BW_T bw=BMA250E_BW_250);
-
-        /**
-         * Reset the device as if during a power on reset.  All configured
-         * values are lost when this happens.  You should call init()
-         * afterwards, or at least perform the same initialization init()
-         * does before continuing.
-         *
-         * @throws std::runtime_error on failure.
-         */
-        void reset();
-
-        /**
-         * Set the acceleration scaling range.  This device supports 2, 4,
-         * 8, and 16g ranges.
-         *
-         * @param range One of the BMA250E_RANGE_T values.
-         * @throws std::runtime_error on failure.
-         */
-        void setRange(BMA250E_RANGE_T range);
-
-        /**
-         * Set the output filtering bandwidth of the device.
-         *
-         * @param bw One of the BMA250E_BW_T values.
-         * @throws std::runtime_error on failure.
-         */
-        void setBandwidth(BMA250E_BW_T bw);
-
-        /**
-         * Set the power mode of the device.  Care must be taken when
-         * setting a low power or suspend mode.  By default init() calls
-         * setLowPowerMode2() to ensure that if any of these modes are
-         * entered we can still talk to the device.  The default low power
-         * mode is LPM1, which requires slowing down register writes,
-         * which we cannot support.  setLowPowerMode2() enables LPM2 which
-         * keeps the digital interface operational in low power or suspend
-         * modes.  See the datasheet for details.
-         *
-         * So if you reset your device and don't call init() or
-         * setLowPowerMode2(), you could lose control of the device by
-         * calling this function with anything other than
-         * POWER_MODE_NORMAL.  You've been warned :)
-         *
-         * @param power One of the BMA250E_POWER_MODE_T values.
-         * @throws std::runtime_error on failure.
-         */
-        void setPowerMode(BMA250E_POWER_MODE_T power);
-
-        /**
-         * Enable update() to read from the FIFO rather than the
-         * acceleration axis registers directly.  init() enables this mode
-         * by default if the chip variant supports a FIFO.  An advantage
-         * to this mode that all axis data is sampled from the same
-         * timeslice.  When reading directly from the acceleration output
-         * registers, it's possible for one axis to be updated while
-         * another is being read, causing a temporal anomaly that even
-         * Captain Picard can't resolve.  If there is no FIFO present,
-         * this call is ignored.
-         *
-         * Using the FIFO removes this problem.
-         *
-         * @param useFIFO True to enable update() to read from the FIFO.
-         * When false, update will read from the acceleration output
-         * registers directly.
-         */
-        void enableFIFO(bool useFIFO);
-
-        /**
-         * Set the FIFO watermark.  When the watermark is reached an
-         * interrupt (if enabled) will be generated.  If there is no FIFO
-         * present, this call is ignored.
-         *
-         * @param wm The FIFO watermark to use.  The maximum value is 63.
-         * @throws std::runtime_error on failure.
-         */
-        void fifoSetWatermark(int wm);
-
-        /**
-         * Set the FIFO configuration.  init() uses the FIFO_MODE_BYPASS
-         * mode with axes set to FIFO_DATA_SEL_XYZ by default.  If there
-         * is no FIFO present, this call is ignored.
-         *
-         * @param mode One of the BMA250E_FIFO_MODE_T values.
-         * @param axes One of the BMA250E_FIFO_DATA_SEL_T values.
-         * @throws std::runtime_error on failure.
-         */
-        void fifoConfig(BMA250E_FIFO_MODE_T mode,
-                        BMA250E_FIFO_DATA_SEL_T axes);
-
-        /**
-         * Enable, disable, and configure the built in self test on a per
-         * axis basis.  See the datasheet for details.
-         *
-         * @param sign True for a positive deflection, false for negative
-         * @param amp True for a high deflection, false for a low deflection
-         * @param axis One of the BMA250E_SELFTTEST_AXIS_T values.
-         * Note, only one axis at a time can be tested.  Accelerometer
-         * output for other axes should be ignored.
-         * @throws std::runtime_error on failure.
-         */
-        void setSelfTest(bool sign, bool amp, BMA250E_SELFTTEST_AXIS_T axis);
-
-        /**
-         * Return the Interrupt Enables 0 register.  These registers
-         * allow you to enable various interrupt conditions.  See the
-         * datasheet for details.
-         *
-         * @return A bitmask of BMA250E_INT_EN_0_BITS_T bits.
-         */
-        uint8_t getInterruptEnable0();
-
-        /**
-         * Set the Interrupt Enables 0 register.  See the datasheet for
-         * details.
-         *
-         * @param bits A bitmask of BMA250E_INT_EN_0_BITS_T bits.
-         * @throws std::runtime_error on failure.
-         */
-        void setInterruptEnable0(uint8_t bits);
-
-        /**
-         * Return the Interrupt Enables 1 register.  See the datasheet for
-         * details.
-         *
-         * @return A bitmask of BMA250E_INT_EN_1_BITS_T bits.
-         */
-        uint8_t getInterruptEnable1();
-
-        /**
-         * Set the Interrupt Enables 1 register.  See the datasheet for
-         * details.
-         *
-         * @param bits A bitmask of BMA250E_INT_EN_1_BITS_T bits.
-         * @throws std::runtime_error on failure.
-         */
-        void setInterruptEnable1(uint8_t bits);
-
-        /**
-         * Return the Interrupt Enables 2 register.  See the datasheet for
-         * details.
-         *
-         * @return A bitmask of BMA250E_INT_EN_2_BITS_T bits.
-         */
-        uint8_t getInterruptEnable2();
-
-        /**
-         * Set the Interrupt Enables 2 register.  See the datasheet for
-         * details.
-         *
-         * @param bits A bitmask of BMA250E_INT_EN_2_BITS_T bits.
-         * @throws std::runtime_error on failure.
-         */
-        void setInterruptEnable2(uint8_t bits);
-
-        /**
-         * Return the Interrupt Map 0 register.  These registers allow you
-         * to map specific interrupts to the interrupt 1 or interrupt 2
-         * pin.  See the datasheet for details.
-         *
-         * @return A bitmask of BMA250E_INT_MAP_0_BITS_T bits.
-         */
-        uint8_t getInterruptMap0();
-
-        /**
-         * Set the Interrupt Map 0 register.  These registers allow you
-         * to map specific interrupts to the interrupt 1 or interrupt 2
-         * pin.  See the datasheet for details.
-         *
-         * @param bits A bitmask of BMA250E_INT_MAP_0_BITS_T bits.
-         * @throws std::runtime_error on failure.
-         */
-        void setInterruptMap0(uint8_t bits);
-
-        /**
-         * Return the Interrupt Map 1 register.  See the datasheet for
-         * details.
-         *
-         * @return A bitmask of BMA250E_INT_MAP_1_BITS_T bits.
-         */
-        uint8_t getInterruptMap1();
-
-        /**
-         * Set the Interrupt Map 1 register.  See the datasheet for
-         * details.
-         *
-         * @param bits A bitmask of BMA250E_INT_MAP_1_BITS_T bits.
-         * @throws std::runtime_error on failure.
-         */
-        void setInterruptMap1(uint8_t bits);
-
-        /**
-         * Return the Interrupt Map 2 register.  See the datasheet for
-         * details.
-         *
-         * @return A bitmask of BMA250E_INT_MAP_2_BITS_T bits.
-         */
-        uint8_t getInterruptMap2();
-
-        /**
-         * Set the Interrupt Map 2 register.  See the datasheet for
-         * details.
-         *
-         * @param bits A bitmask of BMA250E_INT_MAP_2_BITS_T bits.
-         * @throws std::runtime_error on failure.
-         */
-        void setInterruptMap2(uint8_t bits);
-
-        /**
-         * Return the Interrupt source register.  This register allows
-         * determining where data comes from (filtered/unfiltered) for
-         * those interrupt sources where this is selectable.  See the
-         * datasheet for details.
-         *
-         * @return A bitmask of BMA250E_INT_SRC_BITS_T bits.
-         */
-        uint8_t getInterruptSrc();
-
-        /**
-         * Set the Interrupt source register.  This register allows
-         * determining where data comes from (filtered/unfiltered) for
-         * those interrupt sources where this is selectable.  See the
-         * datasheet for details.
-         *
-         * @param bits A bitmask of BMA250E_INT_SRC_BITS_T bits.
-         * @throws std::runtime_error on failure.
-         */
-        void setInterruptSrc(uint8_t bits);
-
-        /**
-         * Return the Interrupt output control register.  This register
-         * allows determining the electrical characteristics of the 2
-         * interrupt pins (open-drain/push-pull and level/edge
-         * triggering).  See the datasheet for details.
-         *
-         * @return A bitmask of BMA250E_INT_OUT_CTRL_BITS_T bits.
-         */
-        uint8_t getInterruptOutputControl();
-
-        /**
-         * Set the Interrupt output control register.  This register
-         * allows determining the electrical characteristics of the 2
-         * interrupt pins (open-drain/push-pull and level/edge
-         * triggering).  See the datasheet for details.
-         *
-         * @param bits A bitmask of BMA250E_INT_OUT_CTRL_BITS_T bits.
-         * @throws std::runtime_error on failure.
-         */
-        void setInterruptOutputControl(uint8_t bits);
-
-        /**
-         * Clear all latched interrupts.  See the datasheet for details.
-         *
-         * @throws std::runtime_error on failure.
-         */
-        void clearInterruptLatches();
-
-        /**
-         * Return the current interrupt latching behavior.  See the
-         * datasheet for details.
-         *
-         * @return One of the BMA250E_RST_LATCH_T values.
-         */
-        BMA250E_RST_LATCH_T getInterruptLatchBehavior();
-
-        /**
-         * Set the current interrupt latching behavior.  See the datasheet
-         * for details.
-         *
-         * @param latch One of the BMA250E_RST_LATCH_T values.
-         * @throws std::runtime_error on failure.
-         */
-        void setInterruptLatchBehavior(BMA250E_RST_LATCH_T latch);
-
-        /**
-         * Return the interrupt status 0 register.  These registers
-         * indicate which interrupts have been triggered.  See the
-         * datasheet for details.
-         *
-         * @return A bitmask of BMA250E_INT_STATUS_0_BITS_T bits.
-         */
-        uint8_t getInterruptStatus0();
-
-        /**
-         * Return the interrupt status 1 register.  See the datasheet for
-         * details.
-         *
-         * @return A bitmask of BMA250E_INT_STATUS_1_BITS_T bits.
-         */
-        uint8_t getInterruptStatus1();
-
-        /**
-         * Return the interrupt status 2 register.  See the datasheet for
-         * details.
-         *
-         * @return A bitmask of BMA250E_INT_STATUS_2_BITS_T bits.
-         */
-        uint8_t getInterruptStatus2();
-
-        /**
-         * Return the interrupt status 3 register bitfields.  See the
-         * datasheet for details.  The Orientation value is not returned by
-         * this function, see getInterruptStatus3Orientation() for that
-         * information.
-         *
-         * @return A bitmask of BMA250E_INT_STATUS_3_BITS_T bits ONLY.
-         */
-        uint8_t getInterruptStatus3Bits();
-
-        /**
-         * Return the interrupt status 3 register Orientation value.  See the
-         * datasheet for details.
-         *
-         * @return One of the BMA250E_ORIENT_T values.
-         */
-        BMA250E_ORIENT_T getInterruptStatus3Orientation();
-
-        /**
-         * Enable shadowing of the accelerometer output registers.  When
-         * enabled, a read of an axis LSB register automatically locks the
-         * MSB register of that axis until it has been read.  This is
-         * usually a good thing to have enabled.  init() enables this by
-         * default.  If disabled, then it becomes possible for part of an
-         * axis value to change while another part is being read, causing
-         * inconsistent data.
-         *
-         * @param shadow True to enable axis register shadowing, false
-         * otherwise.
-         * @throws std::runtime_error on failure.
-         */
-        void enableRegisterShadowing(bool shadow);
-
-        /**
-         * Enable filtering of the accelerometer axis data.  init()
-         * enables this by default.  If disabled, then accelerometer data
-         * that is read will be raw and unfiltered (rated R).  See the
-         * datasheet for details.
-         *
-         * @param filter True to enable filtering, false to disable.
-         * @throws std::runtime_error on failure.
-         */
-        void enableOutputFiltering(bool filter);
-
-        /**
-         * Make sure low power mode config (LPM2) is set in case we later
-         * go into the low power or suspend power modes.  LPM1 mode (the
-         * default) requires drastically slowed register writes which we
-         * cannot handle.
-         *
-         * @throws std::runtime_error on failure.
-         */
-        void setLowPowerMode2();
-
-
-    /**
-         * install an interrupt handler.
-         *
-         * @param intr One of the BMA250E_INTERRUPT_PINS_T values
-         * specifying which interrupt pin you are installing.
-         * @param gpio GPIO pin to use as interrupt pin.
-         * @param level The interrupt trigger level (one of mraa::Edge
-         * values).  Make sure that you have configured the interrupt pin
-         * properly for whatever level you choose.
-         * @param isr The interrupt handler, accepting a void * argument.
-         * @param arg The argument to pass the the interrupt handler.
-         * @throws std::runtime_error on failure.
-         */
-        void installISR(BMA250E_INTERRUPT_PINS_T intr, int gpio,
-                        mraa::Edge level,
-                        void (*isr)(void *), void *arg);
-
-        /**
-         * uninstall a previously installed interrupt handler
-         *
-         * @param intr One of the BMA250E_INTERRUPT_PINS_T values
-         * specifying which interrupt pin you are removing.
-         */
-        void uninstallISR(BMA250E_INTERRUPT_PINS_T intr);
-
-        /**
-         * Read a register.
-         *
-         * @param reg The register to read.
-         * @return The value of the register.
-         */
-        uint8_t readReg(uint8_t reg);
-
-        /**
-         * Read contiguous registers into a buffer.
-         *
-         * @param buffer The buffer to store the results.
-         * @param len The number of registers to read.
-         * @return The number of bytes read.
-         * @throws std::runtime_error on failure.
-         */
-        int readRegs(uint8_t reg, uint8_t *buffer, int len);
-
-        /**
-         * Write to a register.
-         *
-         * @param reg The register to write to.
-         * @param val The value to write.
-         * @throws std::runtime_error on failure.
-         */
-        void writeReg(uint8_t reg, uint8_t val);
-
-    protected:
-        bma250e_context m_bma250e;
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        BMA250E(const BMA250E&) = delete;
-        BMA250E &operator=(const BMA250E&) = delete;
-        
-    };
-}
diff --git a/src/bma250e/bma250e.i b/src/bma250e/bma250e.i
deleted file mode 100644
index 523ecde..0000000
--- a/src/bma250e/bma250e.i
+++ /dev/null
@@ -1,56 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "../upm_javastdvector.i"
-
-%ignore getAccelerometer(float *, float *, float *);
-%ignore installISR (BMA250E_INTERRUPT_PINS_T, int, mraa::Edge , void *, void *);
-
-%typemap(javaimports) SWIGTYPE %{
-import java.util.AbstractList;
-import java.lang.Float;
-%}
-
-%typemap(javaout) upm::BMA250E {
-    return new $&javaclassname($jnicall, true);
-}
-%typemap(javaout) std::vector<float> {
-    return (AbstractList<Float>)(new $&javaclassname($jnicall, true));
-}
-%typemap(jstype) std::vector<float> "AbstractList<Float>"
-
-%template(floatVector) std::vector<float>;
-
-%define INTERRUPT BMA250E_INTERRUPT_PINS_T
-%enddef
-
-JAVA_ADD_INSTALLISR_INTERRUPT(upm::BMA250E)
-JAVA_JNI_LOADLIBRARY(javaupm_bma250e)
-#endif
-/* END Java syntax */
-
-/* BEGIN Javascript syntax  ------------------------------------------------- */
-#ifdef SWIGJAVASCRIPT
-%include "../upm_vectortypes.i"
-%pointer_functions(int, intp);
-%pointer_functions(float, floatp);
-#endif
-/* END Javascript syntax */
-
-/* BEGIN Python syntax  ----------------------------------------------------- */
-#ifdef SWIGPYTHON
-%include "../upm_vectortypes.i"
-%pointer_functions(int, intp);
-%pointer_functions(float, floatp);
-#endif
-/* END Python syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "bma250e_defs.h"
-#include "bma250e.hpp"
-%}
-%include "bma250e_defs.h"
-%include "bma250e.hpp"
-/* END Common SWIG syntax */
diff --git a/src/bma250e/bma250e.json b/src/bma250e/bma250e.json
deleted file mode 100644
index df35962..0000000
--- a/src/bma250e/bma250e.json
+++ /dev/null
@@ -1,74 +0,0 @@
-{
-    "Library": "bma250e",
-    "Description": "Bosch Sensortec accelerometer library",
-    "Sensor Class": {
-        "BMA250E": {
-            "Name": "Bosch BMA250E accelerometer",
-            "Description": "This is the UPM Module for the Bosch BMA250E accelerometer. This sensor offers triaxial low-g acceleration detection, and offers spi and i2c interfaces. It also offers interrupts, which can be activated by input, such as new data, motion, taps, or even different orientations.",
-            "Aliases": ["bma250e"],
-            "Categories": ["accelerometer"],
-            "Connections": ["i2c", "spi", "gpio"],
-            "Project Type": ["industrial", "commercial"],
-            "Manufacturers": ["bosch"],
-            "Examples": {
-                "Java": ["BMA250E_Example.java"],
-                "Python": ["bma250e.py"],
-                "Node.js": ["bma250e.js"],
-                "C++": ["bma250e.cxx"],
-                "C": ["bma250e.c"]
-            },
-            "Specifications": {
-                "Vdd": {
-                    "unit": "V",
-                    "min": 1.62,
-                    "max": 3.6
-                },
-                "Supply Current Digital": {
-                    "Normal mode": {
-                        "unit": "uA",
-                        "typ" : "130"
-                    },
-                    "Suspend mode": {
-                        "unit": "uA",
-                        "typ" : "2.1"
-                    },
-                    "Deep suspend mode": {
-                        "unit": "uA",
-                        "typ" : "1"
-                    },
-                    "Low-power mode 1": {
-                        "unit": "uA",
-                        "typ" : "6.5"
-                    },
-                    "Low-power mode 2": {
-                        "unit": "uA",
-                        "typ" : "66"
-                    }
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Start-up time": {
-                    "unit": "ms",
-                    "max" : "1.2"
-                },
-                "Wake-up time 1": {
-                    "unit": "ms",
-                    "typ" : "1.3",
-                    "max" : "1.8"
-                },
-                "Wake-up time 2": {
-                    "unit": "ms",
-                    "typ" : "1",
-                    "max" : "1.2"
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.bosch-sensortec.com/bst/products/all_products/bma250e"],
-                "Datasheets": ["https://ae-bst.resource.bosch.com/media/_tech/media/datasheets/BST-BMA250E-DS004-06.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/bma250e/bma250e_defs.h b/src/bma250e/bma250e_defs.h
deleted file mode 100644
index 4bf82b1..0000000
--- a/src/bma250e/bma250e_defs.h
+++ /dev/null
@@ -1,935 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define BMA250E_DEFAULT_I2C_BUS 0
-#define BMA250E_DEFAULT_SPI_BUS 0
-#define BMA250E_DEFAULT_ADDR 0x18
-
-// special reset byte
-#define BMA250E_RESET_BYTE 0xb6
-
-    // NOTE: Reserved registers must not be written into.  Reading
-    // from them may return indeterminate values.  Registers
-    // containing reserved bitfields must be written as 0.  Reading
-    // reserved bitfields may return indeterminate values.
-
-    /**
-     * BMA250E registers
-     */
-    typedef enum  {
-        BMA250E_REG_CHIP_ID                      = 0x00,
-
-        // 0x01 reserved
-
-        BMA250E_REG_ACCD_X_LSB                   = 0x02,
-        BMA250E_REG_ACCD_X_MSB                   = 0x03,
-        BMA250E_REG_ACCD_Y_LSB                   = 0x04,
-        BMA250E_REG_ACCD_Y_MSB                   = 0x05,
-        BMA250E_REG_ACCD_Z_LSB                   = 0x06,
-        BMA250E_REG_ACCD_Z_MSB                   = 0x07,
-
-        BMA250E_REG_TEMP                         = 0x08,
-
-        BMA250E_REG_INT_STATUS_0                 = 0x09,
-        BMA250E_REG_INT_STATUS_1                 = 0x0a,
-        BMA250E_REG_INT_STATUS_2                 = 0x0b,
-        BMA250E_REG_INT_STATUS_3                 = 0x0c,
-
-        // 0x0d reserved
-
-        BMA250E_REG_FIFO_STATUS                  = 0x0e,
-
-        BMA250E_REG_PMU_RANGE                    = 0x0f,
-        BMA250E_REG_PMU_BW                       = 0x10,
-        BMA250E_REG_PMU_LPW                      = 0x11,
-        BMA250E_REG_PMU_LOW_POWER                = 0x12,
-
-        BMA250E_REG_ACC_HBW                      = 0x13,
-
-        BMA250E_REG_SOFTRESET                    = 0x14,
-
-        // 0x15 reserved
-
-        BMA250E_REG_INT_EN_0                     = 0x16,
-        BMA250E_REG_INT_EN_1                     = 0x17,
-        BMA250E_REG_INT_EN_2                     = 0x18,
-
-        BMA250E_REG_INT_MAP_0                    = 0x19,
-        BMA250E_REG_INT_MAP_1                    = 0x1a,
-        BMA250E_REG_INT_MAP_2                    = 0x1b,
-
-        // 0x1c-0x1d reserved
-
-        BMA250E_REG_INT_SRC                      = 0x1e,
-
-        // 0x1f reserved
-
-        BMA250E_REG_INT_OUT_CTRL                 = 0x20,
-        BMA250E_REG_INT_RST_LATCH                = 0x21,
-
-        BMA250E_REG_INT_0                        = 0x22,
-        BMA250E_REG_INT_1                        = 0x23,
-        BMA250E_REG_INT_2                        = 0x24,
-        BMA250E_REG_INT_3                        = 0x25,
-        BMA250E_REG_INT_4                        = 0x26,
-        BMA250E_REG_INT_5                        = 0x27,
-        BMA250E_REG_INT_6                        = 0x28,
-        BMA250E_REG_INT_7                        = 0x29,
-        BMA250E_REG_INT_8                        = 0x2a,
-        BMA250E_REG_INT_9                        = 0x2b,
-        BMA250E_REG_INT_A                        = 0x2c,
-        BMA250E_REG_INT_B                        = 0x2d,
-        BMA250E_REG_INT_C                        = 0x2e,
-        BMA250E_REG_INT_D                        = 0x2f,
-
-        BMA250E_REG_FIFO_CONFIG_0                = 0x30,
-
-        // 0x31 reserved
-
-        BMA250E_REG_PMU_SELFTEST                 = 0x32,
-
-        BMA250E_REG_TRIM_NVM_CTRL                = 0x33,
-
-        BMA250E_REG_SPI3_WDT                     = 0x34,
-
-        // 0x35 reserved
-
-        BMA250E_REG_OFC_CTRL                     = 0x36,
-        BMA250E_REG_OFC_SETTING                  = 0x37,
-
-        BMA250E_REG_OFC_OFFSET_X                 = 0x38,
-        BMA250E_REG_OFC_OFFSET_Y                 = 0x39,
-        BMA250E_REG_OFC_OFFSET_Z                 = 0x3a,
-
-        BMA250E_REG_TRIM_GP0                     = 0x3b,
-        BMA250E_REG_TRIM_GP1                     = 0x3c,
-
-        // 0x3d reserved
-
-        BMA250E_REG_FIFO_CONFIG_1                = 0x3e,
-        BMA250E_REG_FIFO_DATA                    = 0x3f
-
-    } BMA250E_REGS_T;
-
-    /**
-     * REG_ACCD_*_LSB bits - handle X, Y, and Z LSB regs, for 10 bit
-     * resolution
-     */
-    typedef enum {
-        BMA250E_ACCD10_LSB_NEW_DATA              = 0x01, // data
-                                                         // updated
-                                                         // since last
-                                                         // read
-
-        // 0x02-0x20 reserved
-
-        BMA250E_ACCD10_LSB0                      = 0x40, // lower 2
-                                                         // bits of
-                                                         // LSB data
-        BMA250E_ACCD10_LSB1                      = 0x80,
-        _BMA250E_ACCD10_LSB_MASK                 = 3,
-        _BMA250E_ACCD10_LSB_SHIFT                = 6
-    } BMA250E_ACCD10_LSB_BITS_T;
-
-    /**
-     * REG_ACCD_*_LSB bits - handle X, Y, and Z LSB regs, for 12 bit
-     * resolution
-     */
-    typedef enum {
-        BMA250E_ACCD12_LSB_NEW_DATA              = 0x01, // data
-                                                         // updated
-                                                         // since last
-                                                         // read
-
-        // 0x02-0x08 reserved
-
-        BMA250E_ACCD12_LSB0                      = 0x10, // lower 4
-                                                         // bits of
-                                                         // LSB data
-        BMA250E_ACCD12_LSB1                      = 0x20,
-        BMA250E_ACCD12_LSB2                      = 0x40,
-        BMA250E_ACCD12_LSB3                      = 0x80,
-        _BMA250E_ACCD12_LSB_MASK                 = 15,
-        _BMA250E_ACCD12_LSB_SHIFT                = 4
-    } BMA250E_ACCD12_LSB_BITS_T;
-
-    /**
-     * REG_INT_STATUS_0 bits
-     */
-    typedef enum {
-        BMA250E_INT_STATUS_0_LOW                 = 0x01,
-        BMA250E_INT_STATUS_0_HIGH                = 0x02,
-        BMA250E_INT_STATUS_0_SLOPE               = 0x04,
-        BMA250E_INT_STATUS_0_SLO_NOT_MOT         = 0x08,
-        BMA250E_INT_STATUS_0_D_TAP               = 0x10,
-        BMA250E_INT_STATUS_0_S_TAP               = 0x20,
-        BMA250E_INT_STATUS_0_ORIENT              = 0x40,
-        BMA250E_INT_STATUS_0_FLAT                = 0x80
-    } BMA250E_INT_STATUS_0_BITS_T;
-
-    /**
-     * REG_INT_STATUS_1 bits
-     */
-    typedef enum {
-        _BMA250E_INT_STATUS_1_RESERVED_BITS      = 0x0f | 0x10,
-        // 0x01-0x10 reserved
-        BMA250E_INT_STATUS_1_FIFO_FULL           = 0x20,
-        BMA250E_INT_STATUS_1_FIFO_WM             = 0x40,
-        BMA250E_INT_STATUS_1_DATA                = 0x80 // data ready int
-    } BMA250E_INT_STATUS_1_BITS_T;
-
-    /**
-     * REG_INT_STATUS_2 bits
-     */
-    typedef enum {
-        BMA250E_INT_STATUS_2_SLOPE_FIRST_X       = 0x01,
-        BMA250E_INT_STATUS_2_SLOPE_FIRST_Y       = 0x02,
-        BMA250E_INT_STATUS_2_SLOPE_FIRST_Z       = 0x04,
-        BMA250E_INT_STATUS_2_SLOPE_SIGN          = 0x08,
-        BMA250E_INT_STATUS_2_TAP_FIRST_X         = 0x10,
-        BMA250E_INT_STATUS_2_TAP_FIRST_Y         = 0x20,
-        BMA250E_INT_STATUS_2_TAP_FIRST_Z         = 0x40,
-        BMA250E_INT_STATUS_2_TAP_SIGN            = 0x80
-    } BMA250E_INT_STATUS_2_BITS_T;
-
-    /**
-     * REG_INT_STATUS_3 bits
-     */
-    typedef enum {
-        BMA250E_INT_STATUS_3_HIGH_FIRST_X        = 0x01,
-        BMA250E_INT_STATUS_3_HIGH_FIRST_Y        = 0x02,
-        BMA250E_INT_STATUS_3_HIGH_FIRST_Z        = 0x04,
-        BMA250E_INT_STATUS_3_HIGH_SIGN           = 0x08,
-
-        BMA250E_INT_STATUS_3_ORIENT0             = 0x10,
-        BMA250E_INT_STATUS_3_ORIENT1             = 0x20,
-        BMA250E_INT_STATUS_3_ORIENT2             = 0x40,
-        _BMA250E_INT_STATUS_3_ORIENT_MASK        = 7,
-        _BMA250E_INT_STATUS_3_ORIENT_SHIFT       = 4,
-
-        BMA250E_INT_STATUS_3_FLAT                = 0x80
-    } INT_STATUS_3_BITS_T;
-
-    /**
-     * INT_STATUS_3_ORIENT values
-     */
-    typedef enum {
-        BMA250E_ORIENT_POTRAIT_UPRIGHT           = 0,
-        BMA250E_ORIENT_POTRAIT_UPSIDE_DOWN       = 1,
-        BMA250E_ORIENT_LANDSCAPE_LEFT            = 2,
-        BMA250E_ORIENT_LANDSCAPE_RIGHT           = 3,
-    } BMA250E_ORIENT_T;
-
-    /**
-     * REG_FIFO_STATUS bits
-     */
-    typedef enum {
-        BMA250E_FIFO_STATUS_FRAME_COUNTER0       = 0x01,
-        BMA250E_FIFO_STATUS_FRAME_COUNTER1       = 0x02,
-        BMA250E_FIFO_STATUS_FRAME_COUNTER2       = 0x04,
-        BMA250E_FIFO_STATUS_FRAME_COUNTER3       = 0x08,
-        BMA250E_FIFO_STATUS_FRAME_COUNTER4       = 0x10,
-        BMA250E_FIFO_STATUS_FRAME_COUNTER5       = 0x20,
-        BMA250E_FIFO_STATUS_FRAME_COUNTER6       = 0x40,
-        _BMA250E_FIFO_STATUS_FRAME_COUNTER_MASK  = 127,
-        _BMA250E_FIFO_STATUS_FRAME_COUNTER_SHIFT = 0,
-
-        BMA250E_FIFO_STATUS_FIFO_OVERRUN         = 0x80
-    } BMA250E_FIFO_STATUS_BITS_T;
-
-    /**
-     * REG_PMU_RANGE bits
-     */
-    typedef enum {
-        BMA250E_PMU_RANGE0                       = 0x01,
-        BMA250E_PMU_RANGE1                       = 0x02,
-        BMA250E_PMU_RANGE2                       = 0x04,
-        BMA250E_PMU_RANGE3                       = 0x08,
-        _BMA250E_PMU_RANGE_MASK                  = 15,
-        _BMA250E_PMU_RANGE_SHIFT                 = 0
-
-        // 0x10-0x80 reserved
-    } BMA250E_PMU_RANGE_BITS_T;
-
-    /**
-     * PMU_RANGE (accelerometer g-range) values
-     */
-    typedef enum {
-        BMA250E_RANGE_2G                         = 3,
-        BMA250E_RANGE_4G                         = 5,
-        BMA250E_RANGE_8G                         = 8,
-        BMA250E_RANGE_16G                        = 12
-    } BMA250E_RANGE_T;
-
-    /**
-     * REG_PMU_BW bits
-     */
-    typedef enum {
-        BMA250E_PMU_BW0                          = 0x01,
-        BMA250E_PMU_BW1                          = 0x02,
-        BMA250E_PMU_BW2                          = 0x04,
-        BMA250E_PMU_BW3                          = 0x08,
-        BMA250E_PMU_BW4                          = 0x10,
-        _BMA250E_PMU_BW_MASK                     = 31,
-        _BMA250E_PMU_BW_SHIFT                    = 0
-
-        // 0x20-0x80 reserved
-    } BMA250E_PMU_BW_BITS_T;
-
-    /**
-     * PMU_BW (accelerometer filter bandwidth) values
-     */
-    typedef enum {
-        BMA250E_BW_7_81                          = 8, // 7.81 Hz
-        BMA250E_BW_15_63                         = 9,
-        BMA250E_BW_31_25                         = 10,
-        BMA250E_BW_62_5                          = 11,
-        BMA250E_BW_125                           = 12,
-        BMA250E_BW_250                           = 13,
-        BMA250E_BW_500                           = 14,
-        BMA250E_BW_1000                          = 15
-    } BMA250E_BW_T;
-
-    /**
-     * REG_PMU_LPW bits
-     */
-    typedef enum {
-        // 0x01 reserved
-        _BMA250E_PMU_LPW_RESERVED_MASK           = 0x01,
-
-        BMA250E_PMU_LPW_SLEEP_DUR0               = 0x02, // sleep dur
-                                                         // in low
-                                                         // power mode
-        BMA250E_PMU_LPW_SLEEP_DUR1               = 0x04,
-        BMA250E_PMU_LPW_SLEEP_DUR2               = 0x08,
-        BMA250E_PMU_LPW_SLEEP_DUR3               = 0x10,
-        _BMA250E_PMU_LPW_SLEEP_MASK              = 15,
-        _BMA250E_PMU_LPW_SLEEP_SHIFT             = 1,
-
-        // These are separate bits, deep_suspend, lowpower_en and
-        // suspend (and if all 0, normal).  Since only specific
-        // combinations are allowed, we will treat this as a 3 bit
-        // bitfield called POWER_MODE.
-        BMA250E_PMU_LPW_POWER_MODE0              = 0x20, // deep_suspend
-        BMA250E_PMU_LPW_POWER_MODE1              = 0x40, // lowpower_en
-        BMA250E_PMU_LPW_POWER_MODE2              = 0x80, // suspend
-        _BMA250E_PMU_LPW_POWER_MODE_MASK         = 7,
-        _BMA250E_PMU_LPW_POWER_MODE_SHIFT        = 5
-    } BMA250E_PMU_LPW_BITS_T;
-
-    /**
-     * SLEEP_DUR values
-     */
-    typedef enum {
-        BMA250E_SLEEP_DUR_0_5                    = 0, // 0.5ms
-        BMA250E_SLEEP_DUR_1                      = 6,
-        BMA250E_SLEEP_DUR_2                      = 7,
-        BMA250E_SLEEP_DUR_4                      = 8,
-        BMA250E_SLEEP_DUR_6                      = 9,
-        BMA250E_SLEEP_DUR_10                     = 10,
-        BMA250E_SLEEP_DUR_25                     = 11,
-        BMA250E_SLEEP_DUR_50                     = 12,
-        BMA250E_SLEEP_DUR_100                    = 13,
-        BMA250E_SLEEP_DUR_500                    = 14,
-        BMA250E_SLEEP_DUR_1000                   = 15
-    } BMA250E_SLEEP_DUR_T;
-
-    /**
-     * POWER_MODE values
-     */
-    typedef enum {
-        BMA250E_POWER_MODE_NORMAL                = 0,
-        BMA250E_POWER_MODE_DEEP_SUSPEND          = 1,
-        BMA250E_POWER_MODE_LOW_POWER             = 2,
-        BMA250E_POWER_MODE_SUSPEND               = 4
-    } BMA250E_POWER_MODE_T;
-
-    /**
-     * REG_PMU_LOW_POWER bits
-     */
-    typedef enum {
-        _BMA250E_LOW_POWER_RESERVED_BITS         = 0x0f | 0x10 | 0x80,
-
-        // 0x01-0x10 reserved
-        BMA250E_LOW_POWER_SLEEPTIMER_MODE        = 0x20,
-        BMA250E_LOW_POWER_LOWPOWER_MODE          = 0x40  // LPM1 or
-                                                         // LPM2
-                                                         // mode. see
-                                                         // DS.
-        // 0x80 reserved
-    } BMA250E_LOW_POWER_BITS_T;
-
-    /**
-     * REG_ACC_HBW bits
-     */
-    typedef enum {
-        _BMA250E_ACC_HBW_RESERVED_BITS           = 0x0f | 0x10 | 0x20,
-
-        // 0x01-0x20 reserved
-        BMA250E_ACC_HBW_SHADOW_DIS               = 0x40,
-        BMA250E_ACC_HBW_DATA_HIGH_BW             = 0x80
-    } BMA250E_ACC_HBW_BITS_T;
-
-    /**
-     * REG_INT_EN_0 bits
-     */
-    typedef enum {
-        _BMA250E_INT_EN_0_RESERVED_BITS          = 0x08,
-
-        BMA250E_INT_EN_0_SLOPE_EN_X              = 0x01,
-        BMA250E_INT_EN_0_SLOPE_EN_Y              = 0x02,
-        BMA250E_INT_EN_0_SLOPE_EN_Z              = 0x04,
-
-        // 0x08 reserved
-
-        BMA250E_INT_EN_0_D_TAP_EN                = 0x10,
-        BMA250E_INT_EN_0_S_TAP_EN                = 0x20,
-        BMA250E_INT_EN_0_ORIENT_EN               = 0x40,
-        BMA250E_INT_EN_0_FLAT_EN                 = 0x80
-    } BMA250E_INT_EN_0_BITS_T;
-
-    /**
-     * REG_INT_EN_1 bits
-     */
-    typedef enum {
-        _BMA250E_INT_EN_1_RESERVED_BITS          = 0x80,
-
-        BMA250E_INT_EN_1_HIGH_EN_X               = 0x01,
-        BMA250E_INT_EN_1_HIGH_EN_Y               = 0x02,
-        BMA250E_INT_EN_1_HIGH_EN_Z               = 0x04,
-        BMA250E_INT_EN_1_LOW_EN                  = 0x08,
-        BMA250E_INT_EN_1_DATA_EN                 = 0x10,
-        BMA250E_INT_EN_1_INT_FFULL_EN            = 0x20, // fifo full
-        BMA250E_INT_EN_1_INT_FWM_EN              = 0x40  // fifo watermark
-
-        // 0x80 reserved
-    } BMA250E_INT_EN_1_BITS_T;
-
-    /**
-     * REG_INT_EN_2 bits
-     */
-    typedef enum {
-        _BMA250E_INT_EN_2_RESERVED_BITS          = 0xf0,
-
-        BMA250E_INT_EN_2_SLO_NO_MOT_EN_X         = 0x01,
-        BMA250E_INT_EN_2_SLO_NO_MOT_EN_Y         = 0x02,
-        BMA250E_INT_EN_2_SLO_NO_MOT_EN_Z         = 0x04,
-        BMA250E_INT_EN_2_SLO_NO_MOT_SEL          = 0x08
-
-        // 0x10-0x80 reserved
-    } BMA250E_INT_EN_2_BITS_T;
-
-    /**
-     * REG_INT_MAP_0 bits
-     */
-    typedef enum {
-        BMA250E_INT_MAP_0_INT1_LOW               = 0x01,
-        BMA250E_INT_MAP_0_INT1_HIGH              = 0x02,
-        BMA250E_INT_MAP_0_INT1_SLOPE             = 0x04,
-        BMA250E_INT_MAP_0_INT1_SLO_NO_MOT        = 0x08,
-        BMA250E_INT_MAP_0_INT1_D_TAP             = 0x10,
-        BMA250E_INT_MAP_0_INT1_S_TAP             = 0x20,
-        BMA250E_INT_MAP_0_INT1_ORIENT            = 0x40,
-        BMA250E_INT_MAP_0_INT1_FLAT              = 0x80
-    } BMA250E_INT_MAP_0_BITS_T;
-
-    /**
-     * REG_INT_MAP_1 bits
-     */
-    typedef enum {
-        _BMA250E_INT_MAP_1_INT1_RESERVED_BITS    = 0x08 | 0x10,
-
-        BMA250E_INT_MAP_1_INT1_DATA              = 0x01,
-        BMA250E_INT_MAP_1_INT1_FWM               = 0x02,
-        BMA250E_INT_MAP_1_INT1_FFULL             = 0x04,
-
-        // 0x08-0x10 reserved
-
-        BMA250E_INT_MAP_1_INT2_FFULL             = 0x20,
-        BMA250E_INT_MAP_1_INT2_FWM               = 0x40,
-        BMA250E_INT_MAP_1_INT2_DATA              = 0x80
-    } BMA250E_INT_MAP_1_BITS_T;
-
-    /**
-     * REG_INT_MAP_2 bits
-     */
-    typedef enum {
-        BMA250E_INT_MAP_2_INT2_LOW               = 0x01,
-        BMA250E_INT_MAP_2_INT2_HIGH              = 0x02,
-        BMA250E_INT_MAP_2_INT2_SLOPE             = 0x04,
-        BMA250E_INT_MAP_2_INT2_SLO_NO_MOT        = 0x08,
-        BMA250E_INT_MAP_2_INT2_D_TAP             = 0x10,
-        BMA250E_INT_MAP_2_INT2_S_TAP             = 0x20,
-        BMA250E_INT_MAP_2_INT2_ORIENT            = 0x40,
-        BMA250E_INT_MAP_2_INT2_FLAT              = 0x80
-    } BMA250E_INT_MAP_2_BITS_T;
-
-    /**
-     * REG_INT_SRC bits
-     */
-    typedef enum {
-        _BMA250E_INT_SRC_RESERVED_BITS           = 0x40 | 0x80,
-
-        BMA250E_INT_SRC_LOW                      = 0x01,
-        BMA250E_INT_SRC_HIGH                     = 0x02,
-        BMA250E_INT_SRC_SLO_NO_MOT               = 0x04,
-        BMA250E_INT_SRC_SLOPE                    = 0x08,
-        BMA250E_INT_SRC_TAP                      = 0x10,
-        BMA250E_INT_SRC_DATA                     = 0x20
-
-        // 0x40-0x80 reserved
-    } BMA250E_INT_SRC_BITS_T;
-
-    /**
-     * REG_INT_OUT_CTRL bits
-     */
-    typedef enum {
-        _BMA250E_INT_OUT_CTRL_INT1_RESERVED_BITS = 0xf0,
-
-        BMA250E_INT_OUT_CTRL_INT1_LVL            = 0x01, // level or edge
-        BMA250E_INT_OUT_CTRL_INT1_OD             = 0x02, // push-pull
-                                                         // or open
-                                                         // drain
-        BMA250E_INT_OUT_CTRL_INT2_LVL            = 0x04,
-        BMA250E_INT_OUT_CTRL_INT2_OD             = 0x08
-
-        // 0x10-0x80 reserved
-    } BMA250E_INT_OUT_CTRL_BITS_T;
-
-    /**
-     * REG_INT_RST_LATCH bits
-     */
-    typedef enum {
-        _BMA250E_INT_RST_LATCH_RESERVED_BITS     = 0x10 | 0x20 | 0x40,
-
-        BMA250E_INT_RST_LATCH0                   = 0x01,
-        BMA250E_INT_RST_LATCH1                   = 0x02,
-        BMA250E_INT_RST_LATCH2                   = 0x04,
-        BMA250E_INT_RST_LATCH3                   = 0x08,
-        _BMA250E_INT_RST_LATCH_MASK              = 15,
-        _BMA250E_INT_RST_LATCH_SHIFT             = 0,
-
-        // 0x10-0x40 reserved
-
-        BMA250E_INT_RST_LATCH_RESET_INT          = 0x80
-    } BMA250E_INT_RST_LATCH_BITS_T;
-
-    /**
-     * RST_LATCH values
-     */
-    typedef enum {
-        BMA250E_RST_LATCH_NON_LATCHED            = 0,
-        BMA250E_RST_LATCH_TEMPORARY_250MS        = 1,
-        BMA250E_RST_LATCH_TEMPORARY_500MS        = 2,
-        BMA250E_RST_LATCH_TEMPORARY_1S           = 3,
-        BMA250E_RST_LATCH_TEMPORARY_2S           = 4,
-        BMA250E_RST_LATCH_TEMPORARY_4S           = 5,
-        BMA250E_RST_LATCH_TEMPORARY_8S           = 6,
-        BMA250E_RST_LATCH_LATCHED                = 7,
-
-        // 8 == non latched
-
-        BMA250E_RST_LATCH_TEMPORARY_250US        = 9,
-        BMA250E_RST_LATCH_TEMPORARY_500US        = 10,
-        BMA250E_RST_LATCH_TEMPORARY_1MS          = 11,
-        BMA250E_RST_LATCH_TEMPORARY_12_5MS       = 12,
-        BMA250E_RST_LATCH_TEMPORARY_25MS         = 13,
-        BMA250E_RST_LATCH_TEMPORARY_50MS         = 14
-
-        // 15 == latched
-    } BMA250E_RST_LATCH_T;
-
-    /**
-     * REG_INT_2 bits
-     */
-    typedef enum {
-        BMA250E_INT_2_LOW_HY0                    = 0x01,
-        BMA250E_INT_2_LOW_HY1                    = 0x02,
-        _BMA250E_INT_2_LOW_HY_MASK               = 3,
-        _BMA250E_INT_2_LOW_HY_SHIFT              = 0,
-
-        BMA250E_INT_2_LOW_MODE                   = 0x04,
-
-        // 0x08-0x20 reserved
-
-        BMA250E_INT_2_HIGH_HY0                   = 0x40,
-        BMA250E_INT_2_HIGH_HY1                   = 0x80,
-        _BMA250E_INT_2_HIGH_HY_MASK              = 3,
-        _BMA250E_INT_2_HIGH_HY_SHIFT             = 6
-    } BMA250E_INT_2_BITS_T;
-
-    /**
-     * REG_INT_5 bits
-     */
-    typedef enum {
-        BMA250E_INT_5_SLOPE_DUR0                 = 0x01,
-        BMA250E_INT_5_SLOPE_DUR1                 = 0x02,
-        _BMA250E_INT_5_SLOPE_DUR_MASK            = 3,
-        _BMA250E_INT_5_SLOPE_DUR_SHIFT           = 0,
-
-        BMA250E_INT_5_SLO_NO_MOT_DUR0            = 0x04,
-        BMA250E_INT_5_SLO_NO_MOT_DUR1            = 0x08,
-        BMA250E_INT_5_SLO_NO_MOT_DUR2            = 0x10,
-        BMA250E_INT_5_SLO_NO_MOT_DUR3            = 0x20,
-        BMA250E_INT_5_SLO_NO_MOT_DUR4            = 0x40,
-        BMA250E_INT_5_SLO_NO_MOT_DUR5            = 0x80,
-        _BMA250E_INT_5_SLO_NO_MOT_DUR_MASK       = 63,
-        _BMA250E_INT_5_SLO_NO_MOT_DUR_SHIFT      = 2
-    } BMA250E_INT_5_BITS_T;
-
-    /**
-     * REG_INT_8 bits
-     */
-    typedef enum {
-        BMA250E_INT_8_TAP_DUR0                   = 0x01,
-        BMA250E_INT_8_TAP_DUR1                   = 0x02,
-        BMA250E_INT_8_TAP_DUR2                   = 0x04,
-        _BMA250E_INT_8_TAP_DUR_MASK              = 7,
-        _BMA250E_INT_8_TAP_DUR_SHIFT             = 0,
-
-        // 0x08-0x20 reserved
-
-        BMA250E_INT_8_TAP_SHOCK                  = 0x40,
-        BMA250E_INT_8_TAP_QUIET                  = 0x80
-    } BMA250E_INT_8_BITS_T;
-
-    /**
-     * REG_INT_9 bits
-     */
-    typedef enum {
-        BMA250E_INT_9_TAP_TH0                    = 0x01,
-        BMA250E_INT_9_TAP_TH1                    = 0x02,
-        BMA250E_INT_9_TAP_TH2                    = 0x04,
-        BMA250E_INT_9_TAP_TH3                    = 0x08,
-        BMA250E_INT_9_TAP_TH4                    = 0x10,
-        _BMA250E_INT_5_TAP_TH_MASK               = 31,
-        _BMA250E_INT_5_TAP_TH_SHIFT              = 0,
-
-        // 0x20 reserved
-
-        BMA250E_INT_9_TAP_SAMP0                  = 0x40,
-        BMA250E_INT_9_TAP_SAMP1                  = 0x80,
-        BMA250E_INT_9_TAP_SAMP1_MASK             = 3,
-        BMA250E_INT_9_TAP_SAMP1_SHIFT            = 6
-    } BMA250E_INT_9_BITS_T;
-
-    /**
-     * REG_INT_A bits
-     */
-    typedef enum {
-        BMA250E_INT_A_ORIENT_MODE0               = 0x01,
-        BMA250E_INT_A_ORIENT_MODE1               = 0x02,
-        _BMA250E_INT_A_ORIENT_MODE_MASK          = 3,
-        _BMA250E_INT_A_ORIENT_MODE_SHIFT         = 0,
-
-        BMA250E_INT_A_ORIENT_BLOCKING0           = 0x04,
-        BMA250E_INT_A_ORIENT_BLOCKING1           = 0x08,
-        _BMA250E_INT_A_ORIENT_BLOCKING_MASK      = 3,
-        _BMA250E_INT_A_ORIENT_BLOCKING_SHIFT     = 2,
-
-        BMA250E_INT_A_ORIENT_HYST0               = 0x10,
-        BMA250E_INT_A_ORIENT_HYST1               = 0x20,
-        BMA250E_INT_A_ORIENT_HYST2               = 0x40,
-        _BMA250E_INT_A_ORIENT_HYST_MASK          = 7,
-        _BMA250E_INT_A_ORIENT_HYST_SHIFT         = 4
-
-        // 0x80 reserved
-    } BMA250E_INT_A_BITS_T;
-
-    /**
-     * INT_A_ORIENT_MODE values
-     */
-    typedef enum {
-        BMA250E_ORIENT_MODE_SYMETRICAL           = 0,
-        BMA250E_ORIENT_MODE_HIGH_ASYMETRICAL     = 1,
-        BMA250E_ORIENT_MODE_LOW_ASYMETRICAL      = 2
-    } BMA250E_ORIENT_MODE_T;
-
-    /**
-     * INT_A_ORIENT_BLOCKING values
-     */
-    typedef enum {
-        BMA250E_ORIENT_BLOCKING_NONE             = 0,
-        BMA250E_ORIENT_BLOCKING_THETA_ACC_1_5G   = 1,
-        BMA250E_ORIENT_BLOCKING_THETA_ACC_0_2G_1_5G = 2,
-        BMA250E_ORIENT_BLOCKING_THETA_ACC_0_4G_1_5G = 3
-    } BMA250E_ORIENT_BLOCKING_T;
-
-    /**
-     * REG_INT_B bits
-     */
-    typedef enum {
-        BMA250E_INT_B_ORIENT_THETA0              = 0x01,
-        BMA250E_INT_B_ORIENT_THETA1              = 0x02,
-        BMA250E_INT_B_ORIENT_THETA2              = 0x04,
-        BMA250E_INT_B_ORIENT_THETA3              = 0x08,
-        BMA250E_INT_B_ORIENT_THETA4              = 0x10,
-        BMA250E_INT_B_ORIENT_THETA5              = 0x20,
-        _BMA250E_INT_B_ORIENT_THETA_MASK         = 63,
-        _BMA250E_INT_B_ORIENT_THETA_SHIFT        = 0,
-
-        BMA250E_INT_B_ORIENT_UD_EN               = 0x40
-        // 0x80 reserved
-    } BMA250E_INT_B_BITS_T;
-
-    /**
-     * REG_INT_C bits
-     */
-    typedef enum {
-        BMA250E_INT_B_FLAT_THETA0               = 0x01,
-        BMA250E_INT_B_FLAT_THETA1               = 0x02,
-        BMA250E_INT_B_FLAT_THETA2               = 0x04,
-        BMA250E_INT_B_FLAT_THETA3               = 0x08,
-        BMA250E_INT_B_FLAT_THETA4               = 0x10,
-        BMA250E_INT_B_FLAT_THETA5               = 0x20,
-        _BMA250E_INT_B_FLAT_THETA_MASK          = 63,
-        _BMA250E_INT_B_FLAT_THETA_SHIFT         = 0,
-
-        // 0x40-0x80 reserved
-    } BMA250E_INT_C_BITS_T;
-
-    /**
-     * REG_INT_D bits
-     */
-    typedef enum {
-        BMA250E_INT_D_FLAT_HY0                  = 0x01,
-        BMA250E_INT_D_FLAT_HY1                  = 0x02,
-        BMA250E_INT_D_FLAT_HY2                  = 0x04,
-        _BMA250E_INT_B_FLAT_HY_MASK             = 7,
-        _BMA250E_INT_B_FLAT_HY_SHIFT            = 0,
-
-        // 0x08 reserved
-
-        BMA250E_INT_D_FLAT_HOLD_TIME0           = 0x10,
-        BMA250E_INT_D_FLAT_HOLD_TIME1           = 0x20,
-        _BMA250E_INT_B_FLAT_HOLD_TIME_MASK      = 3,
-        _BMA250E_INT_B_FLAT_HOLD_TIME_SHIFT     = 4
-
-        // 0x40-0x80 reserved
-    } BMA250E_INT_D_BITS_T;
-
-    /**
-     * REG_FIFO_CONFIG_0 bits
-     */
-    typedef enum {
-        _BMA250E_FIFO_CONFIG_0_RESERVED_BITS    = 0x80 | 0x40,
-
-        BMA250E_FIFO_CONFIG_0_WATER_MARK0       = 0x01,
-        BMA250E_FIFO_CONFIG_0_WATER_MARK1       = 0x02,
-        BMA250E_FIFO_CONFIG_0_WATER_MARK2       = 0x04,
-        BMA250E_FIFO_CONFIG_0_WATER_MARK3       = 0x08,
-        BMA250E_FIFO_CONFIG_0_WATER_MARK4       = 0x10,
-        BMA250E_FIFO_CONFIG_0_WATER_MARK5       = 0x20,
-        _BMA250E_FIFO_CONFIG_0_WATER_MARK_MASK  = 63,
-        _BMA250E_FIFO_CONFIG_0_WATER_MARK_SHIFT = 0
-    } BMA250E_FIFO_CONFIG_0_BITS_T;
-
-    /**
-     * REG_PMU_SELFTTEST bits
-     */
-    typedef enum {
-        BMA250E_PMU_SELFTTEST_AXIS0             = 0x01,
-        BMA250E_PMU_SELFTTEST_AXIS1             = 0x02,
-        _BMA250E_PMU_SELFTTEST_AXIS_MASK        = 3,
-        _BMA250E_PMU_SELFTTEST_AXIS_SHIFT       = 0,
-
-        BMA250E_PMU_SELFTTEST_SIGN              = 0x04,
-
-        // 0x08 reserved
-
-        BMA250E_PMU_SELFTTEST_AMP               = 0x10,
-
-        // 0x20-0x80 reserved
-    } BMA250E_PMU_SELFTTEST_BITS_T;
-
-    /**
-     * PMU_SELFTTEST_AXIS values
-     */
-    typedef enum {
-        BMA250E_SELFTTEST_AXIS_NONE             = 0,
-        BMA250E_SELFTTEST_AXIS_X                = 1,
-        BMA250E_SELFTTEST_AXIS_Y                = 2,
-        BMA250E_SELFTTEST_AXIS_Z                = 3,
-    } BMA250E_SELFTTEST_AXIS_T;
-
-    /**
-     * REG_TRIM_NVM_CTRL bits
-     */
-    typedef enum {
-        BMA250E_TRIM_NVM_CTRL_NVM_PROG_MODE     = 0x01,
-        BMA250E_TRIM_NVM_CTRL_NVM_PROG_TRIG     = 0x02,
-        BMA250E_TRIM_NVM_CTRL_NVM_PROG_RDY      = 0x04,
-        BMA250E_TRIM_NVM_CTRL_NVM_PROG_LOAD     = 0x08,
-
-        BMA250E_TRIM_NVM_CTRL_NVM_REMAIN0       = 0x10,
-        BMA250E_TRIM_NVM_CTRL_NVM_REMAIN1       = 0x20,
-        BMA250E_TRIM_NVM_CTRL_NVM_REMAIN2       = 0x40,
-        BMA250E_TRIM_NVM_CTRL_NVM_REMAIN3       = 0x80,
-        _BMA250E_TRIM_NVM_CTRL_NVM_REMAIN_MASK  = 15,
-        _BMA250E_TRIM_NVM_CTRL_NVM_REMAIN_SHIFT = 4
-    } BMA250E_TRIM_NVM_CTRL_BITS_T;
-
-    /**
-     * REG_SPI3_WDT bits
-     */
-    typedef enum {
-        _BMA250E_SPI3_WDT_RESERVED_BITS         = 0xf0 | 0x08,
-
-        BMA250E_SPI3_WDT_SPI3                   = 0x01, // 3-wire SPI
-                                                        // - NOT
-                                                        // SUPPORTED
-
-        BMA250E_SPI3_WDT_I2C_WDT_SEL            = 0x02,
-        BMA250E_SPI3_WDT_I2C_WDT_EN             = 0x04
-
-        // 0x08-0x80 reserved
-    } BMA250E_SPI3_WDT_BITS_T;
-
-    /**
-     * REG_OFC_CTRL bits
-     */
-    typedef enum {
-        BMA250E_OFC_CTRL_HP_X_EN                = 0x01,
-        BMA250E_OFC_CTRL_HP_Y_EN                = 0x02,
-        BMA250E_OFC_CTRL_HP_Z_EN                = 0x04,
-
-        // 0x08 reserved
-
-        BMA250E_OFC_CTRL_CAL_RDY                = 0x10,
-
-        BMA250E_OFC_CTRL_CAL_TRIGGER0           = 0x20,
-        BMA250E_OFC_CTRL_CAL_TRIGGER1           = 0x40,
-        _BMA250E_OFC_CTRL_CAL_TRIGGER_MASK      = 3,
-        _BMA250E_OFC_CTRL_CAL_TRIGGER_SHIFT     = 5,
-
-        BMA250E_OFC_CTRL_OFFSET_RESET           = 0x80
-
-    } BMA250E_OFC_CTRL_BITS_T;
-
-    /**
-     * OFC_CTRL_CAL_TRIGGER values
-     */
-    typedef enum {
-        BMA250E_CAL_TRIGGER_NONE                = 0,
-        BMA250E_CAL_TRIGGER_X                   = 1,
-        BMA250E_CAL_TRIGGER_Y                   = 2,
-        BMA250E_CAL_TRIGGER_Z                   = 3
-    } BMA250E_CAL_TRIGGER_T;
-
-    /**
-     * REG_OFC_SETTING bits
-     */
-    typedef enum {
-        BMA250E_OFC_SETTING_CUT_OFF             = 0x01,
-
-        BMA250E_OFC_SETTING_OFFSET_TARGET_X0    = 0x02,
-        BMA250E_OFC_SETTING_OFFSET_TARGET_X1    = 0x04,
-        _BMA250E_OFC_SETTING_OFFSET_TARGET_X_MASK = 3,
-        _BMA250E_OFC_SETTING_OFFSET_TARGET_X_SHIFT = 1,
-
-        BMA250E_OFC_SETTING_OFFSET_TARGET_Y0    = 0x08,
-        BMA250E_OFC_SETTING_OFFSET_TARGET_Y1    = 0x10,
-        _BMA250E_OFC_SETTING_OFFSET_TARGET_Y_MASK = 3,
-        _BMA250E_OFC_SETTING_OFFSET_TARGET_Y_SHIFT = 3,
-
-        BMA250E_OFC_SETTING_OFFSET_TARGET_Z0    = 0x20,
-        BMA250E_OFC_SETTING_OFFSET_TARGET_Z1    = 0x40,
-        _BMA250E_OFC_SETTING_OFFSET_TARGET_Z_MASK = 3,
-        _BMA250E_OFC_SETTING_OFFSET_TARGET_Z_SHIFT = 5
-
-        // 0x80 reserved
-    } BMA250E_OFC_SETTING_BITS_T;
-
-    /**
-     * OFC_SETTING_OFFSET_TARGET (for X, Y and Z axis) values
-     */
-    typedef enum {
-        BMA250E_OFFSET_TARGET_0G                = 0,
-        BMA250E_OFFSET_TARGET_PLUS_1G           = 1,
-        BMA250E_OFFSET_TARGET_MINUS_1G          = 2,
-        // 3 == 0G
-    } BMA250E_OFFSET_TARGET_T;
-
-    /**
-     * REG_FIFO_CONFIG_1 bits
-     */
-    typedef enum {
-        BMA250E_FIFO_CONFIG_1_FIFO_DATA_SEL0     = 0x01,
-        BMA250E_FIFO_CONFIG_1_FIFO_DATA_SEL1     = 0x02,
-        _BMA250E_FIFO_CONFIG_1_FIFO_DATA_SEL     = 3,
-        _BMA250E_FIFO_CONFIG_1_FIFO_DATA_SHIFT   = 0,
-
-        // 0x04-0x20 reserved
-
-        BMA250E_FIFO_CONFIG_1_FIFO_MODE0         = 0x40,
-        BMA250E_FIFO_CONFIG_1_FIFO_MODE1         = 0x80,
-        _BMA250E_FIFO_CONFIG_1_FIFO_MODE_MASK    = 3,
-        _BMA250E_FIFO_CONFIG_1_FIFO_MODE_SHIFT   = 5
-    } BMA250E_FIFO_CONFIG_1_BITS_T;
-
-    /**
-     * FIFO_DATA_SEL values
-     */
-    typedef enum {
-        BMA250E_FIFO_DATA_SEL_XYZ               = 0,
-        BMA250E_FIFO_DATA_SEL_X                 = 1,
-        BMA250E_FIFO_DATA_SEL_Y                 = 2,
-        BMA250E_FIFO_DATA_SEL_Z                 = 3
-    } BMA250E_FIFO_DATA_SEL_T;
-
-    /**
-     * FIFO_MODE values
-     */
-    typedef enum {
-        BMA250E_FIFO_MODE_BYPASS                = 0,
-        BMA250E_FIFO_MODE_FIFO                  = 1,
-        BMA250E_FIFO_MODE_STREAM                = 2
-
-        // 3 == reserved (execute self-destruct :)
-    } BMA250E_FIFO_MODE_T;
-
-    // interrupt selection for installISR() and uninstallISR()
-    typedef enum {
-        BMA250E_INTERRUPT_INT1,
-        BMA250E_INTERRUPT_INT2
-    } BMA250E_INTERRUPT_PINS_T;
-
-    // Different variants of this chip support different resolutions.
-    // The 0xf9 variant supports 10b, while the 0xfa variant (bmx055)
-    // supports 12 bits.
-    typedef enum {
-        BMA250E_RESOLUTION_10BITS,
-        BMA250E_RESOLUTION_12BITS
-    } BMA250E_RESOLUTION_T;
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/bma250e/bma250e_fti.c b/src/bma250e/bma250e_fti.c
deleted file mode 100644
index 2f25dc4..0000000
--- a/src/bma250e/bma250e_fti.c
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "bma250e.h"
-#include "upm_fti.h"
-
-/**
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_bma250e_name[] = "BMA250E";
-const char upm_bma250e_description[] = "Triple Axis Digital Accelerometer";
-const upm_protocol_t upm_bma250e_protocol[] = {UPM_I2C, UPM_SPI, UPM_GPIO};
-const upm_sensor_t upm_bma250e_category[] = {UPM_ACCELEROMETER};
-
-// forward declarations
-const void* upm_bma250e_get_ft(upm_sensor_t sensor_type);
-void* upm_bma250e_init_name();
-void upm_bma250e_close(void *dev);
-upm_result_t upm_bma250e_get_value(void *dev, float *value,
-                                   upm_acceleration_u unit);
-
-const upm_sensor_descriptor_t upm_bma250e_get_descriptor()
-{
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_bma250e_name;
-    usd.description = upm_bma250e_description;
-    usd.protocol_size = 3;
-    usd.protocol = upm_bma250e_protocol;
-    usd.category_size = 1;
-    usd.category = upm_bma250e_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = &upm_bma250e_init_name,
-    .upm_sensor_close = &upm_bma250e_close,
-};
-
-static const upm_acceleration_ft aft =
-{
-    .upm_acceleration_get_value = &upm_bma250e_get_value
-};
-
-const void* upm_bma250e_get_ft(upm_sensor_t sensor_type)
-{
-  switch(sensor_type)
-    {
-    case UPM_SENSOR:
-      return &ft;
-
-    case UPM_ACCELEROMETER:
-      return &aft;
-
-    default:
-      return NULL;
-    }
-}
-
-void* upm_bma250e_init_name()
-{
-    return NULL;
-}
-
-
-void upm_bma250e_close(void *dev)
-{
-    bma250e_close((bma250e_context)dev);
-}
-
-upm_result_t upm_bma250e_get_value(void *dev, float *value,
-                                   upm_acceleration_u unit)
-{
-    if (bma250e_update((bma250e_context)dev))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    // no conversion facility in place yet, so we don't do anything
-    // with units
-
-    float x, y, z;
-
-    bma250e_get_accelerometer(dev, &x, &y, &z);
-
-    value[0] = x;
-    value[1] = y;
-    value[2] = z;
-
-    return UPM_SUCCESS;
-}
diff --git a/src/bmg160/CMakeLists.txt b/src/bmg160/CMakeLists.txt
deleted file mode 100644
index eee87db..0000000
--- a/src/bmg160/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME bmg160
-    DESCRIPTION "3-Axis Digital Gyroscope"
-    C_HDR bmg160.h bmg160_defs.h
-    C_SRC bmg160.c
-    CPP_HDR bmg160.hpp
-    CPP_SRC bmg160.cxx
-    FTI_SRC bmg160_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/bmg160/bmg160.c b/src/bmg160/bmg160.c
deleted file mode 100644
index 7390dea..0000000
--- a/src/bmg160/bmg160.c
+++ /dev/null
@@ -1,777 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <assert.h>
-
-#include "upm_utilities.h"
-#include "bmg160.h"
-
-// macro for converting a uint8_t low/high pair into a float
-#define INT16_TO_FLOAT(h, l) \
-    (float)( (int16_t)( (l) | ((h) << 8) ) )
-
-// SPI CS on and off functions
-static void _csOn(const bmg160_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->gpioCS)
-        mraa_gpio_write(dev->gpioCS, 0);
-}
-
-static void _csOff(const bmg160_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->gpioCS)
-        mraa_gpio_write(dev->gpioCS, 1);
-}
-
-// init
-bmg160_context bmg160_init(int bus, int addr, int cs)
-{
-    bmg160_context dev =
-        (bmg160_context)malloc(sizeof(struct _bmg160_context));
-
-    if (!dev)
-        return NULL;
-
-    // zero out context
-    memset((void *)dev, 0, sizeof(struct _bmg160_context));
-
-    // make sure MRAA is initialized
-    if (mraa_init() != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed.\n", __FUNCTION__);
-        bmg160_close(dev);
-        return NULL;
-    }
-
-    if (addr < 0)
-        dev->isSPI = true;
-
-    if (dev->isSPI)
-    {
-        if (!(dev->spi = mraa_spi_init(bus)))
-        {
-            printf("%s: mraa_spi_init() failed.\n", __FUNCTION__);
-            bmg160_close(dev);
-            return NULL;
-        }
-
-        // Only create cs context if we are actually using a valid pin.
-        // A hardware controlled pin should specify cs as -1.
-        if (cs >= 0)
-        {
-            if (!(dev->gpioCS = mraa_gpio_init(cs)))
-            {
-                printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
-                bmg160_close(dev);
-                return NULL;
-            }
-            mraa_gpio_dir(dev->gpioCS, MRAA_GPIO_OUT);
-        }
-
-        mraa_spi_mode(dev->spi, MRAA_SPI_MODE0);
-        if (mraa_spi_frequency(dev->spi, 5000000))
-        {
-            printf("%s: mraa_spi_frequency() failed.\n", __FUNCTION__);
-            bmg160_close(dev);
-            return NULL;
-        }
-    }
-    else
-    {
-        // I2C
-
-        if (!(dev->i2c = mraa_i2c_init(bus)))
-        {
-            printf("%s: mraa_i2c_init() failed.\n", __FUNCTION__);
-            bmg160_close(dev);
-            return NULL;
-        }
-
-        if (mraa_i2c_address(dev->i2c, addr))
-        {
-            printf("%s: mraa_i2c_address() failed.\n", __FUNCTION__);
-            bmg160_close(dev);
-            return NULL;
-        }
-    }
-
-    // check the chip id
-
-    uint8_t chipID = bmg160_get_chip_id(dev);
-    if (chipID != BMG160_CHIPID)
-    {
-        printf("%s: invalid chip id: %02x.  Expected %02x\n",
-               __FUNCTION__, chipID, BMG160_CHIPID);
-        bmg160_close(dev);
-        return NULL;
-    }
-
-    // call devinit with default options
-    if (bmg160_devinit(dev, BMG160_POWER_MODE_NORMAL, BMG160_RANGE_250,
-                       BMG160_BW_400_47))
-    {
-        printf("%s: bmg160_devinit() failed.\n", __FUNCTION__);
-        bmg160_close(dev);
-        return NULL;
-    }
-
-    return dev;
-}
-
-void bmg160_close(bmg160_context dev)
-{
-    assert(dev != NULL);
-
-    bmg160_uninstall_isr(dev, BMG160_INTERRUPT_INT1);
-    bmg160_uninstall_isr(dev, BMG160_INTERRUPT_INT2);
-
-    if (dev->i2c)
-        mraa_i2c_stop(dev->i2c);
-    if (dev->spi)
-        mraa_spi_stop(dev->spi);
-    if (dev->gpioCS)
-        mraa_gpio_close(dev->gpioCS);
-
-    free(dev);
-}
-
-upm_result_t bmg160_devinit(const bmg160_context dev,
-                            BMG160_POWER_MODE_T pwr,
-                            BMG160_RANGE_T range,
-                            BMG160_BW_T bw)
-{
-    assert(dev != NULL);
-
-    if (bmg160_set_power_mode(dev, pwr))
-    {
-        printf("%s: bmg160_set_power_mode() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    upm_delay_ms(50); // 50ms, in case we are waking up
-
-    // set our range and bandwidth, make sure register shadowing is
-    // enabled, enable output filtering, and set our FIFO config
-
-    if (bmg160_set_range(dev, range)
-        || bmg160_set_bandwidth(dev, bw)
-        || bmg160_enable_register_shadowing(dev, true)
-        || bmg160_enable_output_filtering(dev, true)
-        || bmg160_fifo_config(dev, BMG160_FIFO_MODE_BYPASS,
-                              BMG160_FIFO_DATA_SEL_XYZ))
-    {
-        printf("%s: failed to set configuration parameters.\n",
-               __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    bmg160_enable_fifo(dev, true);
-
-    // settle
-    upm_delay_ms(50);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bmg160_update(const bmg160_context dev)
-{
-    assert(dev != NULL);
-
-    int bufLen = 7; // max, non-FIFO
-    uint8_t startReg = BMG160_REG_RATE_X_LSB;
-
-    if (dev->useFIFO)
-    {
-        bufLen = 6;
-        startReg = BMG160_REG_FIFO_DATA;
-    }
-
-    uint8_t buf[bufLen];
-
-    if (bmg160_read_regs(dev, startReg, buf, bufLen) != bufLen)
-    {
-        printf("%s: bmg160_read_regs() failed to read %d bytes\n",
-               __FUNCTION__, bufLen);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // x                       msb     lsb
-    dev->gyrX = INT16_TO_FLOAT(buf[1], buf[0]);
-
-    // y
-    dev->gyrY = INT16_TO_FLOAT(buf[3], buf[2]);
-
-    // z
-    dev->gyrZ = INT16_TO_FLOAT(buf[5], buf[4]);
-
-    // get the temperature...
-
-    int8_t temp = 0;
-    if (dev->useFIFO)
-    {
-        // we have to read temperature separately...
-        temp = (int8_t)bmg160_read_reg(dev, BMG160_REG_TEMP);
-    }
-    else
-    {
-        // we already got it
-        temp = (int8_t)buf[6];
-    }
-
-    // .5K/LSB, 23C center point
-    dev->temperature = ((float)temp / 2.0) + 23.0;
-
-    return UPM_SUCCESS;
-}
-
-void bmg160_enable_fifo(const bmg160_context dev, bool useFIFO)
-{
-    assert(dev != NULL);
-
-    dev->useFIFO = useFIFO;
-}
-
-uint8_t bmg160_read_reg(const bmg160_context dev, uint8_t reg)
-{
-    assert(dev != NULL);
-
-    if (dev->isSPI)
-    {
-        reg |= 0x80; // needed for read
-        uint8_t pkt[2] = {reg, 0};
-
-        _csOn(dev);
-        if (mraa_spi_transfer_buf(dev->spi, pkt, pkt, 2))
-        {
-            _csOff(dev);
-            printf("%s: mraa_spi_transfer_buf() failed.\n", __FUNCTION__);
-            return 0xff;
-        }
-        _csOff(dev);
-
-        return pkt[1];
-    }
-    else
-        return (uint8_t)mraa_i2c_read_byte_data(dev->i2c, reg);
-}
-
-int bmg160_read_regs(const bmg160_context dev, uint8_t reg,
-                     uint8_t *buffer, int len)
-{
-    assert(dev != NULL);
-
-    if (dev->isSPI)
-    {
-        reg |= 0x80; // needed for read
-
-        uint8_t sbuf[len + 1];
-        memset((char *)sbuf, 0, len + 1);
-        sbuf[0] = reg;
-
-        // We need to do it this way for edison - ie: use a single
-        // transfer rather than breaking it up into two like we used to.
-        // This means a buffer copy is now required, but that's the way
-        // it goes.
-
-        _csOn(dev);
-        if (mraa_spi_transfer_buf(dev->spi, sbuf, sbuf, len + 1))
-        {
-            _csOff(dev);
-            printf("%s: mraa_spi_transfer_buf() failed.\n", __FUNCTION__);
-            return -1;
-        }
-        _csOff(dev);
-
-        // now copy it into user buffer
-        for (int i=0; i<len; i++)
-            buffer[i] = sbuf[i + 1];
-    }
-    else
-    {
-        if (mraa_i2c_read_bytes_data(dev->i2c, reg, buffer, len) != len)
-            return -1;
-    }
-
-    return len;
-}
-
-upm_result_t bmg160_write_reg(const bmg160_context dev,
-                              uint8_t reg, uint8_t val)
-{
-    assert(dev != NULL);
-
-    if (dev->isSPI)
-    {
-        reg &= 0x7f; // mask off 0x80 for writing
-        uint8_t pkt[2] = {reg, val};
-
-        _csOn(dev);
-        if (mraa_spi_transfer_buf(dev->spi, pkt, NULL, 2))
-        {
-            _csOff(dev);
-            printf("%s: mraa_spi_transfer_buf() failed.",
-                   __FUNCTION__);
-
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-        _csOff(dev);
-    }
-    else
-    {
-        if (mraa_i2c_write_byte_data(dev->i2c, val, reg))
-        {
-            printf("%s: mraa_i2c_write_byte_data() failed.",
-                   __FUNCTION__);
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-    }
-
-    return UPM_SUCCESS;
-}
-
-uint8_t bmg160_get_chip_id(const bmg160_context dev)
-{
-    assert(dev != NULL);
-
-    return bmg160_read_reg(dev, BMG160_REG_CHIP_ID);
-}
-
-void bmg160_get_gyroscope(const bmg160_context dev,
-                          float *x, float *y, float *z)
-{
-    assert(dev != NULL);
-
-    if (x)
-        *x = (dev->gyrX * dev->gyrScale) / 1000.0;
-
-    if (y)
-        *y = (dev->gyrY * dev->gyrScale) / 1000.0;
-
-    if (z)
-        *z = (dev->gyrZ * dev->gyrScale) / 1000.0;
-}
-
-float bmg160_get_temperature(const bmg160_context dev)
-{
-    assert(dev != NULL);
-
-    return dev->temperature;
-}
-
-upm_result_t bmg160_reset(const bmg160_context dev)
-{
-    assert(dev != NULL);
-
-    if (bmg160_write_reg(dev, BMG160_REG_SOFTRESET, BMG160_RESET_BYTE))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    upm_delay(1);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bmg160_set_range(const bmg160_context dev,
-                              BMG160_RANGE_T range)
-{
-    assert(dev != NULL);
-
-    // we also have to write a fixed '0x10' to the high-order bits for
-    // some reason (according to datasheet)
-    uint8_t reg = range | (_BMG160_GYR_RANGE_FIXED_VALUE
-                           << _BMG160_GYR_RANGE_FIXED_SHIFT);
-    if (bmg160_write_reg(dev, BMG160_REG_GYR_RANGE, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    switch(range)
-    {
-    case BMG160_RANGE_125:
-        dev->gyrScale = 3.8; // milli-degrees
-        break;
-
-    case BMG160_RANGE_250:
-        dev->gyrScale = 7.6;
-        break;
-
-    case BMG160_RANGE_500:
-        dev->gyrScale = 15.3;
-        break;
-
-    case BMG160_RANGE_1000:
-        dev->gyrScale = 30.5;
-        break;
-
-    case BMG160_RANGE_2000:
-        dev->gyrScale = 61.0;
-        break;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bmg160_set_bandwidth(const bmg160_context dev,
-                                  BMG160_BW_T bw)
-{
-    assert(dev != NULL);
-
-    if (bmg160_write_reg(dev, BMG160_REG_GYR_BW, bw))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bmg160_set_power_mode(const bmg160_context dev,
-                                   BMG160_POWER_MODE_T power)
-{
-    assert(dev != NULL);
-
-    // mask off reserved bits first
-    uint8_t reg =
-        bmg160_read_reg(dev, BMG160_REG_LPM1) & ~_BMG160_LPM1_RESERVED_BITS;
-
-    reg &= ~(_BMG160_LPM1_POWER_MODE_MASK << _BMG160_LPM1_POWER_MODE_SHIFT);
-    reg |= (power << _BMG160_LPM1_POWER_MODE_SHIFT);
-
-    if (bmg160_write_reg(dev, BMG160_REG_LPM1, power))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bmg160_fifo_set_watermark(const bmg160_context dev, int wm)
-{
-    assert(dev != NULL);
-
-    // mask off illegal values
-    uint8_t reg = ((uint8_t)wm) & _BMG160_FIFO_CONFIG_0_WATER_MARK_MASK;
-
-    if (bmg160_write_reg(dev, BMG160_REG_FIFO_CONFIG_0, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bmg160_fifo_config(const bmg160_context dev,
-                                BMG160_FIFO_MODE_T mode,
-                                BMG160_FIFO_DATA_SEL_T axes)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = ( (mode << _BMG160_FIFO_CONFIG_1_FIFO_MODE_SHIFT) |
-                    (axes << _BMG160_FIFO_CONFIG_1_FIFO_DATA_SHIFT) );
-
-    if (bmg160_write_reg(dev, BMG160_REG_FIFO_CONFIG_1, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-uint8_t bmg160_get_interrupt_enable0(const bmg160_context dev)
-{
-    assert(dev != NULL);
-
-    return (bmg160_read_reg(dev, BMG160_REG_INT_EN_0)
-            & ~_BMG160_INT_EN_0_RESERVED_BITS);
-}
-
-upm_result_t bmg160_set_interrupt_enable0(const bmg160_context dev,
-                                          uint8_t bits)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = bits & ~_BMG160_INT_EN_0_RESERVED_BITS;
-
-    if (bmg160_write_reg(dev, BMG160_REG_INT_EN_0, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-uint8_t bmg160_get_interrupt_map0(const bmg160_context dev)
-{
-    assert(dev != NULL);
-
-    return bmg160_read_reg(dev, BMG160_REG_INT_MAP_0)
-        & ~_BMG160_INT_MAP_0_RESERVED_BITS;
-}
-
-upm_result_t bmg160_set_interrupt_map0(const bmg160_context dev, uint8_t bits)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = bits & ~_BMG160_INT_MAP_0_RESERVED_BITS;
-
-    if (bmg160_write_reg(dev, BMG160_REG_INT_MAP_0, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-uint8_t bmg160_get_interrupt_map1(const bmg160_context dev)
-{
-    assert(dev != NULL);
-
-    return bmg160_read_reg(dev, BMG160_REG_INT_MAP_1);
-}
-
-upm_result_t bmg160_set_interrupt_map1(const bmg160_context dev, uint8_t bits)
-{
-    assert(dev != NULL);
-
-    if (bmg160_write_reg(dev, BMG160_REG_INT_MAP_1, bits))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-// REG_INT_EN1, for some strange reason
-uint8_t bmg160_get_interrupt_src(const bmg160_context dev)
-{
-    assert(dev != NULL);
-
-    return (bmg160_read_reg(dev, BMG160_REG_INT_EN_1)
-            & ~_BMG160_INT_EN_1_INT1_RESERVED_BITS);
-}
-
-upm_result_t bmg160_set_interrupt_src(const bmg160_context dev, uint8_t bits)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = bits & ~_BMG160_INT_EN_1_INT1_RESERVED_BITS;
-
-    if (bmg160_write_reg(dev, BMG160_REG_INT_EN_1, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-uint8_t bmg160_get_interrupt_output_control(const bmg160_context dev)
-{
-    assert(dev != NULL);
-
-    return (bmg160_read_reg(dev, BMG160_REG_INT_EN_1)
-            & ~_BMG160_INT_EN_1_INT1_RESERVED_BITS);
-}
-
-upm_result_t bmg160_set_interrupt_output_control(const bmg160_context dev,
-                                                 uint8_t bits)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = bits & ~_BMG160_INT_EN_1_INT1_RESERVED_BITS;
-
-    if (bmg160_write_reg(dev, BMG160_REG_INT_EN_1, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bmg160_clear_interrupt_latches(const bmg160_context dev)
-{
-    assert(dev != NULL);
-
-    uint8_t reg =
-        bmg160_read_reg(dev, BMG160_REG_INT_RST_LATCH) & ~_BMG160_INT_RST_LATCH_RESERVED_BITS;
-
-    reg |= BMG160_INT_RST_LATCH_RESET_INT;
-
-    if (bmg160_write_reg(dev, BMG160_REG_INT_RST_LATCH, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-BMG160_RST_LATCH_T bmg160_get_interrupt_latch_behavior(const bmg160_context dev)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = bmg160_read_reg(dev, BMG160_REG_INT_RST_LATCH)
-        & ~_BMG160_INT_RST_LATCH_RESERVED_BITS;
-
-    reg &= (_BMG160_INT_RST_LATCH_MASK << _BMG160_INT_RST_LATCH_SHIFT);
-
-    return (BMG160_RST_LATCH_T)reg;
-}
-
-upm_result_t bmg160_set_interrupt_latch_behavior(const bmg160_context dev,
-                                                 BMG160_RST_LATCH_T latch)
-{
-    assert(dev != NULL);
-
-    uint8_t reg =
-        bmg160_read_reg(dev, BMG160_REG_INT_RST_LATCH) & ~_BMG160_INT_RST_LATCH_RESERVED_BITS;
-
-    reg &= ~(_BMG160_INT_RST_LATCH_MASK << _BMG160_INT_RST_LATCH_SHIFT);
-    reg |= (latch << _BMG160_INT_RST_LATCH_SHIFT);
-
-    if (bmg160_write_reg(dev, BMG160_REG_INT_RST_LATCH, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bmg160_enable_register_shadowing(const bmg160_context dev,
-                                              bool shadow)
-{
-    assert(dev != NULL);
-
-    uint8_t reg =
-        bmg160_read_reg(dev, BMG160_REG_RATE_HBW) & ~_BMG160_RATE_HBW_RESERVED_BITS;
-
-    if (shadow)
-        reg &= ~BMG160_RATE_HBW_SHADOW_DIS;
-    else
-        reg |= BMG160_RATE_HBW_SHADOW_DIS;
-
-    if (bmg160_write_reg(dev, BMG160_REG_RATE_HBW, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bmg160_enable_output_filtering(const bmg160_context dev,
-                                            bool filter)
-{
-    assert(dev != NULL);
-
-    uint8_t reg =
-        bmg160_read_reg(dev, BMG160_REG_RATE_HBW) & ~_BMG160_RATE_HBW_RESERVED_BITS;
-
-    if (filter)
-        reg &= ~BMG160_RATE_HBW_DATA_HIGH_BW;
-    else
-        reg |= BMG160_RATE_HBW_DATA_HIGH_BW;
-
-    if (bmg160_write_reg(dev, BMG160_REG_RATE_HBW, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-uint8_t bmg160_get_interrupt_status0(const bmg160_context dev)
-{
-    assert(dev != NULL);
-
-    return (bmg160_read_reg(dev, BMG160_REG_INT_STATUS_0)
-            & ~_BMG160_INT_STATUS_0_RESERVED_BITS);
-}
-
-uint8_t bmg160_get_interrupt_status1(const bmg160_context dev)
-{
-    assert(dev != NULL);
-
-    return (bmg160_read_reg(dev, BMG160_REG_INT_STATUS_1)
-            & ~_BMG160_INT_STATUS_1_RESERVED_BITS);
-}
-
-uint8_t bmg160_get_interrupt_status2(const bmg160_context dev)
-{
-    assert(dev != NULL);
-
-    return (bmg160_read_reg(dev, BMG160_REG_INT_STATUS_2)
-            & ~_BMG160_INT_STATUS_2_RESERVED_BITS);
-}
-
-uint8_t bmg160_get_interrupt_status3(const bmg160_context dev)
-{
-    assert(dev != NULL);
-
-    return (bmg160_read_reg(dev, BMG160_REG_INT_STATUS_3)
-            & ~_BMG160_INT_STATUS_3_RESERVED_BITS);
-}
-
-upm_result_t bmg160_install_isr(const bmg160_context dev,
-                                BMG160_INTERRUPT_PINS_T intr, int gpio,
-                                mraa_gpio_edge_t level,
-                                void (*isr)(void *), void *arg)
-{
-    assert(dev != NULL);
-
-    // delete any existing ISR and GPIO context for this interrupt
-    bmg160_uninstall_isr(dev, intr);
-
-    mraa_gpio_context gpio_isr = NULL;
-
-    // create gpio context
-    if (!(gpio_isr = mraa_gpio_init(gpio)))
-    {
-        printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    mraa_gpio_dir(gpio_isr, MRAA_GPIO_IN);
-
-    if (mraa_gpio_isr(gpio_isr, level, isr, arg))
-    {
-        mraa_gpio_close(gpio_isr);
-        printf("%s: mraa_gpio_isr() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    switch (intr)
-    {
-    case BMG160_INTERRUPT_INT1:
-        dev->gpio1 = gpio_isr;
-        break;
-
-    case BMG160_INTERRUPT_INT2:
-        dev->gpio2 = gpio_isr;
-        break;
-    }
-
-    return UPM_SUCCESS;
-}
-
-void bmg160_uninstall_isr(const bmg160_context dev,
-                          BMG160_INTERRUPT_PINS_T intr)
-{
-    assert(dev != NULL);
-
-    switch (intr)
-    {
-    case BMG160_INTERRUPT_INT1:
-        if (dev->gpio1)
-        {
-            mraa_gpio_isr_exit(dev->gpio1);
-            mraa_gpio_close(dev->gpio1);
-            dev->gpio1 = NULL;
-        }
-        break;
-
-    case BMG160_INTERRUPT_INT2:
-        if (dev->gpio2)
-        {
-            mraa_gpio_isr_exit(dev->gpio2);
-            mraa_gpio_close(dev->gpio2);
-            dev->gpio2 = NULL;
-        }
-        break;
-    }
-}
diff --git a/src/bmg160/bmg160.cxx b/src/bmg160/bmg160.cxx
deleted file mode 100644
index 342dee5..0000000
--- a/src/bmg160/bmg160.cxx
+++ /dev/null
@@ -1,294 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016-2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <iostream>
-#include <stdexcept>
-#include <string>
-
-#include "bmg160.hpp"
-
-using namespace upm;
-using namespace std;
-
-// conversion from Celsius to Fahrenheit
-
-static float c2f(float c)
-{
-    return (c * (9.0 / 5.0) + 32.0);
-}
-
-BMG160::BMG160(int bus, int addr, int cs) :
-    m_bmg160(bmg160_init(bus, addr, cs))
-{
-    if (!m_bmg160)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmg160_init() failed");
-}
-
-BMG160::~BMG160()
-{
-    bmg160_close(m_bmg160);
-}
-
-void BMG160::init(BMG160_POWER_MODE_T pwr, BMG160_RANGE_T range,
-                  BMG160_BW_T bw)
-{
-    if (bmg160_devinit(m_bmg160, pwr, range, bw))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmg160_devinit() failed");
-}
-
-void BMG160::update()
-{
-    if (bmg160_update(m_bmg160))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmg160_update() failed");
-}
-
-void BMG160::enableFIFO(bool useFIFO)
-{
-    bmg160_enable_fifo(m_bmg160, useFIFO);
-}
-
-uint8_t BMG160::readReg(uint8_t reg)
-{
-    return bmg160_read_reg(m_bmg160, reg);
-}
-
-int BMG160::readRegs(uint8_t reg, uint8_t *buffer, int len)
-{
-    int rv = bmg160_read_regs(m_bmg160, reg, buffer, len);
-    if (rv < 0)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmg160_read_regs() failed");
-
-    return rv;
-}
-
-void BMG160::writeReg(uint8_t reg, uint8_t val)
-{
-    if (bmg160_write_reg(m_bmg160, reg, val))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmg160_write_reg() failed");
-}
-
-uint8_t BMG160::getChipID()
-{
-    return bmg160_get_chip_id(m_bmg160);
-}
-
-void BMG160::getGyroscope(float *x, float *y, float *z)
-{
-    bmg160_get_gyroscope(m_bmg160, x, y, z);
-}
-
-std::vector<float> BMG160::getGyroscope()
-{
-    float v[3];
-
-    getGyroscope(&v[0], &v[1], &v[2]);
-    return std::vector<float>(v, v+3);
-}
-
-float BMG160::getTemperature(bool fahrenheit)
-{
-    float temperature = bmg160_get_temperature(m_bmg160);
-    if (fahrenheit)
-        return c2f(temperature);
-    else
-        return temperature;
-}
-
-void BMG160::reset()
-{
-    if (bmg160_reset(m_bmg160))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmg160_reset() failed");
-}
-
-void BMG160::setRange(BMG160_RANGE_T range)
-{
-    if (bmg160_set_range(m_bmg160, range))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmg160_set_range() failed");
-}
-
-void BMG160::setBandwidth(BMG160_BW_T bw)
-{
-    if (bmg160_set_bandwidth(m_bmg160, bw))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmg160_set_bandwidth() failed");
-}
-
-void BMG160::setPowerMode(BMG160_POWER_MODE_T power)
-{
-    if (bmg160_set_power_mode(m_bmg160, power))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmg160_set_power_mode() failed");
-}
-
-void BMG160::fifoSetWatermark(int wm)
-{
-    if (bmg160_fifo_set_watermark(m_bmg160, wm))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmg160_fifo_set_watermark() failed");
-}
-
-void BMG160::fifoConfig(BMG160_FIFO_MODE_T mode, BMG160_FIFO_DATA_SEL_T axes)
-{
-    if (bmg160_fifo_config(m_bmg160, mode, axes))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmg160_fifo_config() failed");
-}
-
-uint8_t BMG160::getInterruptEnable0()
-{
-    return bmg160_get_interrupt_enable0(m_bmg160);
-}
-
-void BMG160::setInterruptEnable0(uint8_t bits)
-{
-    if (bmg160_set_interrupt_enable0(m_bmg160, bits))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmg160_set_interrupt_enable0() failed");
-}
-
-uint8_t BMG160::getInterruptMap0()
-{
-    return bmg160_get_interrupt_map0(m_bmg160);
-}
-
-void BMG160::setInterruptMap0(uint8_t bits)
-{
-    if (bmg160_set_interrupt_map0(m_bmg160, bits))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmg160_set_interrupt_map0() failed");
-}
-
-uint8_t BMG160::getInterruptMap1()
-{
-    return bmg160_get_interrupt_map1(m_bmg160);
-}
-
-void BMG160::setInterruptMap1(uint8_t bits)
-{
-    if (bmg160_set_interrupt_map1(m_bmg160, bits))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmg160_set_interrupt_map1() failed");
-}
-
-uint8_t BMG160::getInterruptSrc()
-{
-    return bmg160_get_interrupt_src(m_bmg160);
-}
-
-void BMG160::setInterruptSrc(uint8_t bits)
-{
-    if (bmg160_set_interrupt_src(m_bmg160, bits))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmg160_set_interrupt_src() failed");
-}
-
-uint8_t BMG160::getInterruptOutputControl()
-{
-    return bmg160_get_interrupt_output_control(m_bmg160);
-}
-
-void BMG160::setInterruptOutputControl(uint8_t bits)
-{
-    if (bmg160_set_interrupt_output_control(m_bmg160, bits))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmg160_set_interrupt_output_control() failed");
-}
-
-void BMG160::clearInterruptLatches()
-{
-    if (bmg160_clear_interrupt_latches(m_bmg160))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmg160_clear_interrupt_latches() failed");
-}
-
-BMG160_RST_LATCH_T BMG160::getInterruptLatchBehavior()
-{
-    return bmg160_get_interrupt_latch_behavior(m_bmg160);
-}
-
-void BMG160::setInterruptLatchBehavior(BMG160_RST_LATCH_T latch)
-{
-    if (bmg160_set_interrupt_latch_behavior(m_bmg160, latch))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmg160_set_interrupt_latch_behavior() failed");
-}
-
-void BMG160::enableRegisterShadowing(bool shadow)
-{
-    if (bmg160_enable_register_shadowing(m_bmg160, shadow))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmg160_enable_register_shadowing() failed");
-}
-
-void BMG160::enableOutputFiltering(bool filter)
-{
-    if (bmg160_enable_output_filtering(m_bmg160, filter))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmg160_enable_output_filtering() failed");
-}
-
-uint8_t BMG160::getInterruptStatus0()
-{
-    return bmg160_get_interrupt_status0(m_bmg160);
-}
-
-uint8_t BMG160::getInterruptStatus1()
-{
-    return bmg160_get_interrupt_status1(m_bmg160);
-}
-
-uint8_t BMG160::getInterruptStatus2()
-{
-    return bmg160_get_interrupt_status2(m_bmg160);
-}
-
-uint8_t BMG160::getInterruptStatus3()
-{
-    return bmg160_get_interrupt_status3(m_bmg160);
-}
-
-void BMG160::installISR(BMG160_INTERRUPT_PINS_T intr, int gpio,
-                        mraa::Edge level,
-                        void (*isr)(void *), void *arg)
-{
-    if (bmg160_install_isr(m_bmg160, intr, gpio,
-                           (mraa_gpio_edge_t)level, isr, arg))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmg160_install_isr() failed");
-}
-
-void BMG160::uninstallISR(BMG160_INTERRUPT_PINS_T intr)
-{
-    bmg160_uninstall_isr(m_bmg160, intr);
-}
diff --git a/src/bmg160/bmg160.h b/src/bmg160/bmg160.h
deleted file mode 100644
index 351c36b..0000000
--- a/src/bmg160/bmg160.h
+++ /dev/null
@@ -1,519 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <unistd.h>
-#include <string.h>
-
-#include <mraa/i2c.h>
-#include <mraa/spi.h>
-#include <mraa/gpio.h>
-
-#include "upm.h"
-
-#include "bmg160_defs.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    /**
-     * @file bmg160.h
-     * @library bmg160
-     * @brief C API for the bmg160 driver
-     *
-     * @include bmg160.c
-     */
-
-    /**
-     * Device context
-     */
-    typedef struct _bmg160_context {
-        mraa_i2c_context i2c;
-        mraa_spi_context spi;
-        mraa_gpio_context gpioCS; // SPI CS pin
-        mraa_gpio_context gpio1;  // intr 1
-        mraa_gpio_context gpio2;  // intr 2
-
-        // using SPI?
-        bool isSPI;
-        // use the FIFO?
-        bool useFIFO;
-
-        // always stored in C
-        float temperature;
-
-        // gyr data
-        float gyrX;
-        float gyrY;
-        float gyrZ;
-
-        // gyr scaling
-        float gyrScale;
-    } *bmg160_context;
-
-    /**
-     * BMG160 initialization.
-     *
-     * This device can support both I2C and SPI. For SPI, set the addr
-     * to -1, and specify a positive integer representing the Chip
-     * Select (CS) pin for the cs argument.  If you are using a
-     * hardware CS pin (like Intel Edison with Arduino breakout), then
-     * you can connect the proper pin to the hardware CS pin on your
-     * MCU and supply -1 for cs.
-     *
-     * @param bus I2C or SPI bus to use.
-     * @param addr The address for this device, or -1 for SPI.
-     * @param cs The gpio pin to use for the SPI Chip Select.  Use -1 for
-     * I2C or for SPI with a hardware controlled pin.
-     * @return The device context, or NULL on error.
-     */
-    bmg160_context bmg160_init(int bus, int addr, int cs);
-
-    /**
-     * BMG160 Destructor.
-     *
-     * @param dev The device context.
-     */
-    void bmg160_close(bmg160_context dev);
-
-    /**
-     * Update the internal stored values from sensor data.
-     *
-     * @param dev The device context.
-     * @return UPM result.
-     */
-    upm_result_t bmg160_update(const bmg160_context dev);
-
-    /**
-     * Return the chip ID.
-     *
-     * @param dev The device context.
-     * @return The chip ID (BMG160_CHIPID).
-     */
-    uint8_t bmg160_get_chip_id(const bmg160_context dev);
-
-    /**
-     * Return gyroscope data in degrees per second.  bmg160_update() must
-     * have been called prior to calling this method.
-     *
-     * @param dev The device context.
-     * @param x Pointer to a floating point value that will have the
-     * current x component placed into it.
-     * @param y Pointer to a floating point value that will have the
-     * current y component placed into it.
-     * @param z Pointer to a floating point value that will have the
-     * current z component placed into it.
-     */
-    void bmg160_get_gyroscope(const bmg160_context dev,
-                              float *x, float *y, float *z);
-
-    /**
-     * Return the current measured temperature.  Note, this is not
-     * ambient temperature.  bmg160_update() must have been called prior to
-     * calling this method.
-     *
-     * @param dev The device context.
-     * @return The temperature in degrees Celsius.
-     */
-    float bmg160_get_temperature(const bmg160_context dev);
-
-    /**
-     * Initialize the device and start operation.  This function is
-     * called from bmg160_init(), so it will not need to be called by
-     * a user unless the device is reset.
-     *
-     * In addition, it will enable register shadowing and enable the
-     * FIFO in bypass mode.
-     *
-     * @param dev The device context.
-     * @param pwr One of the BMG160_POWER_MODE_T values.
-     * @param range One of the BMG160_RANGE_T values.
-     * @param bw One of the filtering BMG160_BW_T values.
-     * @return UPM result.
-     */
-    upm_result_t bmg160_devinit(const bmg160_context dev,
-                                BMG160_POWER_MODE_T pwr,
-                                BMG160_RANGE_T range,
-                                BMG160_BW_T bw);
-
-    /**
-     * Reset the device as if during a power on reset.  All configured
-     * values are lost when this happens.  You should call
-     * bmg160_devinit() afterwards, or at least perform the same
-     * initialization bmg160_devinit() does before continuing.
-     *
-     * @param dev The device context.
-     * @return UPM result.
-     */
-    upm_result_t bmg160_reset(const bmg160_context dev);
-
-    /**
-     * Set the gyroscope detection scaling range.  This device
-     * supports 125, 250, 500, 1000, and 2000 degree/s ranges.
-     *
-     * @param dev The device context.
-     * @param range One of the BMG160_RANGE_T values.
-     * @return UPM result.
-     */
-    upm_result_t bmg160_set_range(const bmg160_context dev,
-                                  BMG160_RANGE_T range);
-
-    /**
-     * Set the output filtering bandwidth of the device.
-     *
-     * @param dev The device context.
-     * @param bw One of the BMG160_BW_T values.
-     * @return UPM result.
-     */
-    upm_result_t bmg160_set_bandwidth(const bmg160_context dev,
-                                      BMG160_BW_T bw);
-
-    /**
-     * Set the power mode of the device.  Care must be taken when
-     * setting a low power or suspend mode.  See the datasheet for
-     * details.  In certain power modes, register write must be
-     * drastically slowed down, which we cannot support.
-     *
-     * @param dev The device context.
-     * @param power One of the BMG160_POWER_MODE_T values.
-     * @return UPM result.
-     */
-    upm_result_t bmg160_set_power_mode(const bmg160_context dev,
-                                       BMG160_POWER_MODE_T power);
-
-    /**
-     * Enable bmg160_update() to read from the FIFO rather than the gyroscope
-     * axis registers directly.  bmg160_devinit() enables this mode by default.
-     * An advantage to this mode that all axis data is sampled from
-     * the same timeslice.  When reading directly from the gyroscope
-     * output registers, it's possible for one axis to be updated
-     * while another is being read, causing a temporal
-     * inconsistency.
-     *
-     * Using the FIFO removes this problem.
-     *
-     * @param dev The device context.
-     * @param useFIFO true to enable bmg160_update() to read from the FIFO.
-     * When false, update will read from the gyroscope output
-     * registers directly.
-     */
-    void bmg160_enable_fifo(const bmg160_context dev, bool useFIFO);
-
-    /**
-     * Set the FIFO watermark.  When the watermark is reached an
-     * interrupt (if enabled) will be generated.
-     *
-     * @param dev The device context.
-     * @param wm The FIFO watermark to use.  The maximum value is 63.
-     * @return UPM result.
-     */
-    upm_result_t bmg160_fifo_set_watermark(const bmg160_context dev, int wm);
-
-    /**
-     * Set the FIFO configuration.  bmg160_devinit() uses the
-     * BMG160_FIFO_MODE_BYPASS mode with axes set to
-     * BMG160_FIFO_DATA_SEL_XYZ by default.
-     *
-     * @param dev The device context.
-     * @param mode One of the BMG160_FIFO_MODE_T values.
-     * @param axes One of the BMG160_FIFO_DATA_SEL_T values.
-     * @return UPM result.
-     */
-    upm_result_t bmg160_fifo_config(const bmg160_context dev,
-                                    BMG160_FIFO_MODE_T mode,
-                                    BMG160_FIFO_DATA_SEL_T axes);
-
-    /**
-     * Return the Interrupt Enables 0 register.  These registers
-     * allow you to enable various interrupt conditions.  See the
-     * datasheet for details.
-     *
-     * @param dev The device context.
-     * @return A bitmask of BMG160_INT_EN_0_BITS_T bits.
-     */
-    uint8_t bmg160_get_interrupt_enable0(const bmg160_context dev);
-
-    /**
-     * Set the Interrupt Enables 0 register.  See the datasheet for
-     * details.
-     *
-     * @param dev The device context.
-     * @param bits A bitmask of BMG160_INT_EN_0_BITS_T bits.
-     * @return UPM result.
-     */
-    upm_result_t bmg160_set_interrupt_enable0(const bmg160_context dev,
-                                              uint8_t bits);
-
-    /**
-     * Return the Interrupt Map 0 register.  These registers allow you
-     * to map specific interrupts to the interrupt 1 or interrupt 2
-     * pin.  See the datasheet for details.
-     *
-     * @param dev The device context.
-     * @return A bitmask of BMG160_INT_MAP_0_BITS_T bits.
-     */
-    uint8_t bmg160_get_interrupt_map0(const bmg160_context dev);
-
-    /**
-     * Set the Interrupt Map 0 register.  These registers allow you
-     * to map specific interrupts to the interrupt 1 or interrupt 2
-     * pin.  See the datasheet for details.
-     *
-     * @param dev The device context.
-     * @param bits A bitmask of BMG160_INT_MAP_0_BITS_T bits.
-     * @return UPM result.
-     */
-    upm_result_t bmg160_set_interrupt_map0(const bmg160_context dev,
-                                           uint8_t bits);
-
-    /**
-     * Return the Interrupt Map 1 register.  See the datasheet for
-     * details.
-     *
-     * @param dev The device context.
-     * @return A bitmask of BMG160_INT_MAP_1_BITS_T bits.
-     */
-    uint8_t bmg160_get_interrupt_map1(const bmg160_context dev);
-
-    /**
-     * Set the Interrupt Map 1 register.  See the datasheet for
-     * details.
-     *
-     * @param dev The device context.
-     * @param bits A bitmask of BMG160_INT_MAP_1_BITS_T bits.
-     * @return UPM result.
-     */
-    upm_result_t bmg160_set_interrupt_map1(const bmg160_context dev,
-                                           uint8_t bits);
-
-    /**
-     * Return the Interrupt source register.  This register allows
-     * determining where data comes from (filtered/unfiltered) for
-     * those interrupt sources where this is selectable.  See the
-     * datasheet for details.
-     *
-     * @param dev The device context.
-     * @return A bitmask of BMG160_INT_1A_BITS_T bits.
-     */
-    uint8_t bmg160_get_interrupt_src(const bmg160_context dev);
-
-    /**
-     * Set the Interrupt source register.  This register allows
-     * determining where data comes from (filtered/unfiltered) for
-     * those interrupt sources where this is selectable.  See the
-     * datasheet for details.
-     *
-     * @param dev The device context.
-     * @param bits A bitmask of BMG160_INT_1A_BITS_T bits.
-     * @return UPM result.
-     */
-    upm_result_t bmg160_set_interrupt_src(const bmg160_context dev,
-                                          uint8_t bits);
-
-    /**
-     * Return the Interrupt output control register.  This register
-     * allows determining the electrical characteristics of the 2
-     * interrupt pins (open-drain/push-pull and level/edge
-     * triggering).  See the datasheet for details.
-     *
-     * @param dev The device context.
-     * @return A bitmask of BMG160_INT_EN_1_BITS_T bits.
-     */
-    uint8_t bmg160_get_interrupt_output_control(const bmg160_context dev);
-
-    /**
-     * Set the Interrupt output control register.  This register
-     * allows determining the electrical characteristics of the 2
-     * interrupt pins (open-drain/push-pull and level/edge
-     * triggering).  See the datasheet for details.
-     *
-     * @param dev The device context.
-     * @param bits A bitmask of BMG160_INT_EN_1_BITS_T bits.
-     * @return UPM result.
-     */
-    upm_result_t bmg160_set_interrupt_output_control(const bmg160_context dev,
-                                                     uint8_t bits);
-
-    /**
-     * Clear all latched interrupts.  See the datasheet for details.
-     *
-     * @param dev The device context.
-     * @return UPM result.
-     */
-    upm_result_t bmg160_clear_interrupt_latches(const bmg160_context dev);
-
-    /**
-     * Return the current interrupt latching behavior.  See the
-     * datasheet for details.
-     *
-     * @param dev The device context.
-     * @return One of the BMG160_RST_LATCH_T values.
-     */
-    BMG160_RST_LATCH_T bmg160_get_interrupt_latch_behavior(
-        const bmg160_context dev);
-
-    /**
-     * Set the current interrupt latching behavior.  See the datasheet
-     * for details.
-     *
-     * @param dev The device context.
-     * @param latch One of the BMG160_RST_LATCH_T values.
-     * @return UPM result.
-     */
-    upm_result_t bmg160_set_interrupt_latch_behavior(const bmg160_context dev,
-                                                     BMG160_RST_LATCH_T latch);
-
-    /**
-     * Return the interrupt status 0 register.  These registers
-     * indicate which interrupts have been triggered.  See the
-     * datasheet for details.
-     *
-     * @param dev The device context.
-     * @return a bitmask of BMG160_INT_STATUS_0_BITS_T bits.
-     */
-    uint8_t bmg160_get_interrupt_status0(const bmg160_context dev);
-
-    /**
-     * Return the interrupt status 1 register.  See the datasheet for
-     * details.
-     *
-     * @param dev The device context.
-     * @return a bitmask of BMG160_INT_STATUS_1_BITS_T bits.
-     */
-    uint8_t bmg160_get_interrupt_status1(const bmg160_context dev);
-
-    /**
-     * Return the interrupt status 2 register.  See the datasheet for
-     * details.
-     *
-     * @param dev The device context.
-     * @return a bitmask of BMG160_INT_STATUS_2_BITS_T bits.
-     */
-    uint8_t bmg160_get_interrupt_status2(const bmg160_context dev);
-
-    /**
-     * Return the interrupt status 3 register.  See the datasheet for
-     * details.
-     *
-     * @param dev The device context.
-     * @return a bitmask of BMG160_INT_STATUS_3_BITS_T bits.
-     */
-    uint8_t bmg160_get_interrupt_status3(const bmg160_context dev);
-
-    /**
-     * Enable shadowing of the gyroscope output registers.  When
-     * enabled, a read of an axis LSB register automatically locks the
-     * MSB register of that axis until it has been read.  This is
-     * usually a good thing to have enabled.  bmg160_devinit() enables this by
-     * default.  If disabled, then it becomes possible for part of an
-     * axis value to change while another part is being read, causing
-     * inconsistent data.
-     *
-     * @param dev The device context.
-     * @param shadow true to enable axis register shadowing, false otherwise.
-     * @return UPM result.
-     */
-    upm_result_t bmg160_enable_register_shadowing(const bmg160_context dev,
-                                                  bool shadow);
-
-    /**
-     * Enable filtering of the gyroscope axis data.  bmg160_devinit()
-     * enables this by default.  If disabled, then gyroscope data
-     * that is read will be raw and unfiltered (rated R).  See the
-     * datasheet for details.
-     *
-     * @param dev The device context.
-     * @param filter true to enable filtering, false to disable.
-     * @return UPM result.
-     */
-    upm_result_t bmg160_enable_output_filtering(const bmg160_context dev,
-                                                bool filter);
-
-    /**
-     * install an interrupt handler.
-     *
-     * @param dev The device context.
-     * @param intr One of the BMG160_INTERRUPT_PINS_T values
-     * specifying which interrupt pin you are installing.
-     * @param gpio GPIO pin to use as interrupt pin
-     * @param level The interrupt trigger level (one of mraa_gpio_edge_t
-     * values).  Make sure that you have configured the interrupt pin
-     * properly for whatever level you choose.
-     * @param isr The interrupt handler, accepting a void * argument
-     * @param arg The argument to pass the the interrupt handler
-     * @return UPM result.
-     */
-    upm_result_t bmg160_install_isr(const bmg160_context dev,
-                                    BMG160_INTERRUPT_PINS_T intr, int gpio,
-                                    mraa_gpio_edge_t level,
-                                    void (*isr)(void *), void *arg);
-
-   /**
-     * uninstall a previously installed interrupt handler
-     *
-     * @param dev The device context.
-     * @param intr One of the BMG160_INTERRUPT_PINS_T values
-     * specifying which interrupt pin you are removing.
-     */
-    void bmg160_uninstall_isr(const bmg160_context dev,
-                              BMG160_INTERRUPT_PINS_T intr);
-
-    /**
-     * Read a register.
-     *
-     * @param dev The device context.
-     * @param reg The register to read.
-     * @return The value of the register.
-     */
-    uint8_t bmg160_read_reg(const bmg160_context dev, uint8_t reg);
-
-    /**
-     * Read contiguous registers into a buffer.
-     *
-     * @param dev The device context.
-     * @param buffer The buffer to store the results.
-     * @param len The number of registers to read.
-     * @return The number of bytes read, or -1 on error.
-     */
-    int bmg160_read_regs(const bmg160_context dev, uint8_t reg,
-                         uint8_t *buffer, int len);
-
-    /**
-     * Write to a register.
-     *
-     * @param dev The device context.
-     * @param reg The register to write to.
-     * @param val The value to write.
-     * @return UPM result.
-     */
-    upm_result_t bmg160_write_reg(const bmg160_context dev,
-                                  uint8_t reg, uint8_t val);
-
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/bmg160/bmg160.hpp b/src/bmg160/bmg160.hpp
deleted file mode 100644
index b7fcf42..0000000
--- a/src/bmg160/bmg160.hpp
+++ /dev/null
@@ -1,480 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016-2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <vector>
-
-#include <mraa/gpio.hpp>
-#include "bmg160.h"
-
-namespace upm {
-
-    /**
-     * @brief BMG160 3-axis Gyroscope
-     * @defgroup bmg160 libupm-bmg160
-     * @ingroup i2c spi gpio bosch gyro
-     */
-
-    /**
-     * @library bmg160
-     * @sensor bmg160
-     * @comname 3-axis Gyroscope Sensor
-     * @type gyro
-     * @man bosch
-     * @con i2c spi gpio
-     * @web https://www.bosch-sensortec.com/bst/products/all_products/bmg160
-     *
-     * @brief API for the BMG160 16 bit Triaxial Gyroscope
-     *
-     * The BMG160 is a 3-axis angular rate sensor that is made of a
-     * surface micro machined sensing element and an evaluation ASIC.
-     * Both parts are packed into one single LGA 3.0mm x 3.0mm x 0.95mm
-     * housing.  The BMG160 is designed to meet requirements for
-     * consumer applications such as image stabilization (DSC and
-     * camera-phone), gaming and pointing devices. It is capable to
-     * measure angular rates in three perpendicular room dimensions, the
-     * x-, y- and z-axis, and to provide the corresponding output
-     * signals. The BMG160 is fitted with digital bi-directional SPI and
-     * I2C interfaces for optimum system integration.
-     *
-     * Not all functionality of this chip has been implemented in this
-     * driver, however all the pieces are present to add any desired
-     * functionality.  This driver supports both I2C (default) and SPI
-     * operation.
-     *
-     * This device requires 3.3v operation.
-     *
-     * @snippet bmg160.cxx Interesting
-     */
-
-    class BMG160 {
-    public:
-        /**
-         * BMG160 constructor.
-         *
-         * This device can support both I2C and SPI. For SPI, set the addr
-         * to -1, and specify a positive integer representing the Chip
-         * Select (CS) pin for the cs argument.  If you are using a
-         * hardware CS pin (like edison with arduino breakout), then you
-         * can connect the proper pin to the hardware CS pin on your MCU
-         * and supply -1 for cs.  The default operating mode is I2C.
-         *
-         * @param bus I2C or SPI bus to use.
-         * @param addr The address for this device.  -1 for SPI.
-         * @param cs The gpio pin to use for the SPI Chip Select.  -1 for
-         * I2C or for SPI with a hardware controlled pin.
-         * @throws std::runtime_error on initialization failure.
-         */
-        BMG160(int bus=BMG160_DEFAULT_I2C_BUS, int addr=BMG160_DEFAULT_ADDR,
-               int cs=-1);
-
-        /**
-         * BMG160 Destructor.
-         */
-        ~BMG160();
-
-        /**
-         * Update the internal stored values from sensor data.
-         *
-         * @throws std::runtime_error on failure.
-         */
-        void update();
-
-        /**
-         * Return the chip ID.
-         *
-         * @return The chip ID (BMG160_CHIPID).
-         */
-        uint8_t getChipID();
-
-        /**
-         * Return gyroscope data in degrees per second.  update() must
-         * have been called prior to calling this method.
-         *
-         * @param x Pointer to a floating point value that will have the
-         * current x component placed into it.
-         * @param y Pointer to a floating point value that will have the
-         * current y component placed into it.
-         * @param z Pointer to a floating point value that will have the
-         * current z component placed into it.
-         */
-        void getGyroscope(float *x, float *y, float *z);
-
-        /**
-         * Return gyroscope data in degrees per second in the form of
-         * a floating point vector.  update() must have been called
-         * prior to calling this method.
-         *
-         * @return A floating point vector containing x, y, and z in
-         * that order.
-         */
-        std::vector<float> getGyroscope();
-
-        /**
-         * Return the current measured temperature.  Note, this is not
-         * ambient temperature.  update() must have been called prior to
-         * calling this method.
-         *
-         * @param fahrenheit true to return data in Fahrenheit, false for
-         * Celicus.  Celsius is the default.
-         * @return The temperature in degrees Celsius or Fahrenheit.
-         */
-        float getTemperature(bool fahrenheit=false);
-
-        /**
-         * Initialize the device and start operation.  This function is
-         * called from the constructor so will not typically need to be
-         * called by a user unless the device is reset.
-         *
-         * @param pwr One of the BMG160_POWER_MODE_T values.  The default is
-         * BMG160_POWER_MODE_NORMAL.
-         * @param range One of the BMG160_RANGE_T values.  The default is
-         * BMG160_RANGE_250.
-         * @param bw One of the filtering BMG160_BW_T values.  The default is
-         * BMG160_BW_400_47.
-         * @throws std::runtime_error on failure.
-         */
-        void init(BMG160_POWER_MODE_T pwr=BMG160_POWER_MODE_NORMAL,
-                  BMG160_RANGE_T range=BMG160_RANGE_250,
-                  BMG160_BW_T bw=BMG160_BW_400_47);
-
-        /**
-         * Reset the device as if during a power on reset.  All configured
-         * values are lost when this happens.  You should call init()
-         * afterwards, or at least perform the same initialization init()
-         * does before continuing.
-         *
-         * @throws std::runtime_error on failure.
-         */
-        void reset();
-
-        /**
-         * Set the gyroscope detection scaling range.  This device
-         * supports 125, 250, 500, 1000, and 2000 degree/s ranges.
-         *
-         * @param range One of the BMG160_RANGE_T values.
-         * @throws std::runtime_error on failure.
-         */
-        void setRange(BMG160_RANGE_T range);
-
-        /**
-         * Set the output filtering bandwidth of the device.
-         *
-         * @param bw One of the BMG160_BW_T values.
-         * @throws std::runtime_error on failure.
-         */
-        void setBandwidth(BMG160_BW_T bw);
-
-        /**
-         * Set the power mode of the device.  Care must be taken when
-         * setting a low power or suspend mode.  See the datasheet for
-         * details.  I ncertain power modes, register write must be
-         * drastically slowed down. which we cannot support.
-         *
-         * @param power One of the POWER_MODE_T values.
-         * @throws std::runtime_error on failure.
-         */
-        void setPowerMode(BMG160_POWER_MODE_T power);
-
-        /**
-         * Enable update() to read from the FIFO rather than the gyroscope
-         * axis registers directly.  init() enables this mode by default.
-         * An advantage to this mode that all axis data is sampled from
-         * the same timeslice.  When reading directly from the gyroscope
-         * output registers, it's possible for one axis to be updated
-         * while another is being read, causing a temporal
-         * inconsistancy..
-         *
-         * Using the FIFO removes this problem.
-         *
-         * @param useFIFO true to enable update() to read from the FIFO.
-         * When false, update will read from the gyroscope output
-         * registers directly.
-         */
-        void enableFIFO(bool useFIFO);
-
-        /**
-         * Set the FIFO watermark.  When the watermark is reached an
-         * interrupt (if enabled) will be generated.
-         *
-         * @param wm The FIFO watermark to use.  The maximum value is 63.
-         * @throws std::runtime_error on failure.
-         */
-        void fifoSetWatermark(int wm);
-
-        /**
-         * Set the FIFO configuration.  init() uses the
-         * BMG160_FIFO_MODE_BYPASS mode with axes set to
-         * BMG160_FIFO_DATA_SEL_XYZ by default.
-         *
-         * @param mode One of the BMG160_FIFO_MODE_T values.
-         * @param axes One of the BMG160_FIFO_DATA_SEL_T values.
-         * @throws std::runtime_error on failure.
-         */
-        void fifoConfig(BMG160_FIFO_MODE_T mode, BMG160_FIFO_DATA_SEL_T axes);
-
-        /**
-         * Return the Interrupt Enables 0 register.  These registers
-         * allow you to enable various interrupt conditions.  See the
-         * datasheet for details.
-         *
-         * @return A bitmask of INT_EN_0_BITS_T bits.
-         */
-        uint8_t getInterruptEnable0();
-
-        /**
-         * Set the Interrupt Enables 0 register.  See the datasheet for
-         * details.
-         *
-         * @param bits A bitmask of BMG160_INT_EN_0_BITS_T bits.
-         * @throws std::runtime_error on failure.
-         */
-        void setInterruptEnable0(uint8_t bits);
-
-        /**
-         * Return the Interrupt Map 0 register.  These registers allow you
-         * to map specific interrupts to the interrupt 1 or interrupt 2
-         * pin.  See the datasheet for details.
-         *
-         * @return A bitmask of INT_MAP_0_BITS_T bits.
-         */
-        uint8_t getInterruptMap0();
-
-        /**
-         * Set the Interrupt Map 0 register.  These registers allow you
-         * to map specific interrupts to the interrupt 1 or interrupt 2
-         * pin.  See the datasheet for details.
-         *
-         * @param bits A bitmask of BMG160_INT_MAP_0_BITS_T bits.
-         * @throws std::runtime_error on failure.
-         */
-        void setInterruptMap0(uint8_t bits);
-
-        /**
-         * Return the Interrupt Map 1 register.  See the datasheet for
-         * details.
-         *
-         * @return A bitmask of BMG160_INT_MAP_1_BITS_T bits.
-         */
-        uint8_t getInterruptMap1();
-
-        /**
-         * Set the Interrupt Map 1 register.  See the datasheet for
-         * details.
-         *
-         * @param bits A bitmask of BMG160_INT_MAP_1_BITS_T bits.
-         * @throws std::runtime_error on failure.
-         */
-        void setInterruptMap1(uint8_t bits);
-
-        /**
-         * Return the Interrupt source register.  This register allows
-         * determining where data comes from (filtered/unfiltered) for
-         * those interrupt sources where this is selectable.  See the
-         * datasheet for details.
-         *
-         * @return A bitmask of INT_1A_BITS_T bits.
-         */
-        uint8_t getInterruptSrc();
-
-        /**
-         * Set the Interrupt source register.  This register allows
-         * determining where data comes from (filtered/unfiltered) for
-         * those interrupt sources where this is selectable.  See the
-         * datasheet for details.
-         *
-         * @param bits A bitmask of INT_1A_BITS_T bits.
-         * @throws std::runtime_error on failure.
-         */
-        void setInterruptSrc(uint8_t bits);
-
-        /**
-         * Return the Interrupt output control register.  This register
-         * allows determining the electrical characteristics of the 2
-         * interrupt pins (open-drain/push-pull and level/edge
-         * triggering).  See the datasheet for details.
-         *
-         * @return A bitmask of INT_EN_1_BITS_T bits.
-         */
-        uint8_t getInterruptOutputControl();
-
-        /**
-         * Set the Interrupt output control register.  This register
-         * allows determining the electrical characteristics of the 2
-         * interrupt pins (open-drain/push-pull and level/edge
-         * triggering).  See the datasheet for details.
-         *
-         * @param bits A bitmask of INT_EN_1_BITS_T bits.
-         * @throws std::runtime_error on failure.
-         */
-        void setInterruptOutputControl(uint8_t bits);
-
-        /**
-         * Clear all latched interrupts.  See the datasheet for details.
-         *
-         * @throws std::runtime_error on failure.
-         */
-        void clearInterruptLatches();
-
-        /**
-         * Return the current interrupt latching behavior.  See the
-         * datasheet for details.
-         *
-         * @return One of the RST_LATCH_T values.
-         */
-        BMG160_RST_LATCH_T getInterruptLatchBehavior();
-
-        /**
-         * Set the current interrupt latching behavior.  See the datasheet
-         * for details.
-         *
-         * @param latch One of the RST_LATCH_T values.
-         * @throws std::runtime_error on failure.
-         */
-        void setInterruptLatchBehavior(BMG160_RST_LATCH_T latch);
-
-        /**
-         * Return the interrupt status 0 register.  These registers
-         * indicate which interrupts have been triggered.  See the
-         * datasheet for details.
-         *
-         * @return a bitmask of INT_STATUS_0_BITS_T bits.
-         */
-        uint8_t getInterruptStatus0();
-
-        /**
-         * Return the interrupt status 1 register.  See the datasheet for
-         * details.
-         *
-         * @return a bitmask of INT_STATUS_1_BITS_T bits.
-         */
-        uint8_t getInterruptStatus1();
-
-        /**
-         * Return the interrupt status 2 register.  See the datasheet for
-         * details.
-         *
-         * @return a bitmask of INT_STATUS_2_BITS_T bits.
-         */
-        uint8_t getInterruptStatus2();
-
-        /**
-         * Return the interrupt status 3 register.  See the datasheet for
-         * details.
-         *
-         * @return a bitmask of INT_STATUS_3_BITS_T bits.
-         */
-        uint8_t getInterruptStatus3();
-
-        /**
-         * Enable shadowing of the gyroscope output registers.  When
-         * enabled, a read of an axis LSB register automatically locks the
-         * MSB register of that axis until it has been read.  This is
-         * usually a good thing to have enabled.  init() enables this by
-         * default.  If disabled, then it becomes possible for part of an
-         * axis value to change while another part is being read, causing
-         * inconsistent data.
-         *
-         * @param shadow true to enable axis register shadowing, false
-         * otherwise.
-         * @throws std::runtime_error on failure.
-         */
-        void enableRegisterShadowing(bool shadow);
-
-        /**
-         * Enable filtering of the gyroscope axis data.  init()
-         * enables this by default.  If disabled, then gyroscope data
-         * that is read will be raw and unfiltered (rated R).  See the
-         * datasheet for details.
-         *
-         * @param filter true to enable filtering, false to disable.
-         */
-        void enableOutputFiltering(bool filter);
-
-        /**
-         * install an interrupt handler.
-         *
-         * @param intr One of the BMG160_INTERRUPT_PINS_T values
-         * specifying which interrupt pin you are installing.
-         * @param gpio GPIO pin to use as interrupt pin.
-         * @param level The interrupt trigger level (one of the
-         * mraa::Edge values).  Make sure that you have
-         * configured the interrupt pin properly for whatever level
-         * you choose.
-         * @param isr The interrupt handler, accepting a void * argument.
-         * @param arg The argument to pass the the interrupt handler.
-         * @throws std::runtime_error on failure.
-         */
-        void installISR(BMG160_INTERRUPT_PINS_T intr, int gpio,
-                        mraa::Edge level,
-                        void (*isr)(void *), void *arg);
-
-        /**
-         * uninstall a previously installed interrupt handler
-         *
-         * @param intr one of the INTERRUPT_PINS_T values specifying which
-         * interrupt pin you are removing.
-         */
-        void uninstallISR(BMG160_INTERRUPT_PINS_T intr);
-
-        /**
-         * Read a register.
-         *
-         * @param reg The register to read.
-         * @return The value of the register.
-         */
-        uint8_t readReg(uint8_t reg);
-
-        /**
-         * Read contiguous registers into a buffer.
-         *
-         * @param buffer The buffer to store the results.
-         * @param len The number of registers to read.
-         * @return The number of bytes read.
-         * @throws std::runtime_error on failure.
-         */
-        int readRegs(uint8_t reg, uint8_t *buffer, int len);
-
-        /**
-         * Write to a register
-         *
-         * @param reg The register to write to.
-         * @param val The value to write.
-         * @throws std::runtime_error on failure.
-         */
-        void writeReg(uint8_t reg, uint8_t val);
-
-    protected:
-        bmg160_context m_bmg160;
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        BMG160(const BMG160&) = delete;
-        BMG160 &operator=(const BMG160&) = delete;
-
-    };
-}
diff --git a/src/bmg160/bmg160.i b/src/bmg160/bmg160.i
deleted file mode 100644
index 5b7c1a9..0000000
--- a/src/bmg160/bmg160.i
+++ /dev/null
@@ -1,56 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "../upm_javastdvector.i"
-
-%ignore installISR (BMG160_INTERRUPT_PINS_T , int   mraa::Edge ,  void *, void *);
-%ignore getGyroscope(float *, float *, float *);
-
-%typemap(javaimports) SWIGTYPE %{
-import java.util.AbstractList;
-import java.lang.Float;
-%}
-
-%typemap(javaout) SWIGTYPE {
-    return new $&javaclassname($jnicall, true);
-}
-%typemap(javaout) std::vector<float> {
-    return (AbstractList<Float>)(new $&javaclassname($jnicall, true));
-}
-%typemap(jstype) std::vector<float> "AbstractList<Float>"
-
-%template(floatVector) std::vector<float>;
-
-%define INTERRUPT BMG160_INTERRUPT_PINS_T
-%enddef
-
-JAVA_ADD_INSTALLISR_INTERRUPT(upm::BMG160)
-JAVA_JNI_LOADLIBRARY(javaupm_bmg160)
-#endif
-/* END Java syntax */
-
-/* BEGIN Javascript syntax  ------------------------------------------------- */
-#ifdef SWIGJAVASCRIPT
-%include "../upm_vectortypes.i"
-%pointer_functions(int, intp);
-%pointer_functions(float, floatp);
-#endif
-/* END Javascript syntax */
-
-/* BEGIN Python syntax  ----------------------------------------------------- */
-#ifdef SWIGPYTHON
-%include "../upm_vectortypes.i"
-%pointer_functions(int, intp);
-%pointer_functions(float, floatp);
-#endif
-/* END Python syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "bmg160_defs.h"
-#include "bmg160.hpp"
-%}
-%include "bmg160_defs.h"
-%include "bmg160.hpp"
-/* END Common SWIG syntax */
diff --git a/src/bmg160/bmg160.json b/src/bmg160/bmg160.json
deleted file mode 100644
index 772fa74..0000000
--- a/src/bmg160/bmg160.json
+++ /dev/null
@@ -1,61 +0,0 @@
-{
-    "Library": "bmg",
-    "Description": "Bosch Sensortec 3-axis gyroscope library",
-    "Sensor Class": {
-        "BMG160": {
-            "Name": "Bosch 3-Axis gyroscope",
-            "Description": "This is the UPM Module for the Bosch BMG160 3-Axis gyroscope. Offers 16 bit digital resolution, with 5 scale ranges. Supports interrupts and low power modes. Offers i2c and SPI interfaces.",
-            "Aliases": ["bmg160"],
-            "Categories": ["gyroscope"],
-            "Connections": ["i2c", "spi", "gpio"],
-            "Project Type": ["industrial", "commercial"],
-            "Manufacturers": ["bosch"],
-            "Examples": {
-                "Java": ["BMG160_Example.java"],
-                "Python": ["bmg160.py"],
-                "Node.js": ["bmg160.js"],
-                "C++": ["bmg160.cxx"],
-                "C": ["bmg160.c"]
-            },
-            "Specifications": {
-                "Vdd": {
-                    "unit": "V",
-                    "min": 2.4,
-                    "max": 3.6
-                },
-                "Supply Current Digital": {
-                    "Normal mode": {
-                        "unit": "mA",
-                        "typ" : "2.5"
-                    },
-                    "Sleep mode": {
-                        "unit": "uA",
-                        "typ" : "25"
-                    },
-                    "Deep sleep mode": {
-                        "unit": "uA",
-                        "typ" : "<5"
-                    }
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Start up time": {
-                    "unit": "ms",
-                    "time": 3
-                },
-                "Wake-up time": {
-                    "unit": "ms",
-                    "min" : 10,
-                    "max" : 30
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.bosch-sensortec.com/bst/products/all_products/bmg160"],
-                "Datasheets": ["https://ae-bst.resource.bosch.com/media/_tech/media/datasheets/BST-BMG160-DS000-09.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/bmg160/bmg160_defs.h b/src/bmg160/bmg160_defs.h
deleted file mode 100644
index 98490c9..0000000
--- a/src/bmg160/bmg160_defs.h
+++ /dev/null
@@ -1,793 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define BMG160_DEFAULT_I2C_BUS 0
-#define BMG160_DEFAULT_SPI_BUS 0
-#define BMG160_DEFAULT_ADDR 0x68
-
-// special reset byte
-#define BMG160_RESET_BYTE 0xb6
-
-#define BMG160_CHIPID 0x0f
-
-    // NOTE: Reserved registers must not be written into.  Reading
-    // from them may return indeterminate values.  Registers
-    // containing reserved bitfields must be written as 0.  Reading
-    // reserved bitfields may return indeterminate values.
-
-    /**
-     * BMG160 registers
-     */
-    typedef enum {
-        BMG160_REG_CHIP_ID                      = 0x00,
-
-        // 0x01 reserved
-
-        BMG160_REG_RATE_X_LSB                   = 0x02,
-        BMG160_REG_RATE_X_MSB                   = 0x03,
-        BMG160_REG_RATE_Y_LSB                   = 0x04,
-        BMG160_REG_RATE_Y_MSB                   = 0x05,
-        BMG160_REG_RATE_Z_LSB                   = 0x06,
-        BMG160_REG_RATE_Z_MSB                   = 0x07,
-
-        BMG160_REG_TEMP                         = 0x08,
-
-        BMG160_REG_INT_STATUS_0                 = 0x09,
-        BMG160_REG_INT_STATUS_1                 = 0x0a,
-        BMG160_REG_INT_STATUS_2                 = 0x0b,
-        BMG160_REG_INT_STATUS_3                 = 0x0c,
-
-        // 0x0d reserved
-
-        BMG160_REG_FIFO_STATUS                  = 0x0e,
-
-        BMG160_REG_GYR_RANGE                    = 0x0f,
-        BMG160_REG_GYR_BW                       = 0x10,
-        BMG160_REG_LPM1                         = 0x11,
-        BMG160_REG_LPM2                         = 0x12,
-
-        BMG160_REG_RATE_HBW                     = 0x13,
-
-        BMG160_REG_SOFTRESET                    = 0x14,
-
-        BMG160_REG_INT_EN_0                     = 0x15,
-        BMG160_REG_INT_EN_1                     = 0x16,
-
-        BMG160_REG_INT_MAP_0                    = 0x17,
-        BMG160_REG_INT_MAP_1                    = 0x18,
-        BMG160_REG_INT_MAP_2                    = 0x19,
-
-        BMG160_REG_INT_1A                       = 0x1a,
-        BMG160_REG_INT_1B                       = 0x1b,
-        BMG160_REG_INT_1C                       = 0x1c,
-
-        // 0x1d reserved
-
-        BMG160_REG_INT_1E                       = 0x1e,
-
-        // 0x1f-0x20 reserved
-
-        BMG160_REG_INT_RST_LATCH                = 0x21,
-
-        BMG160_REG_HIGH_TH_X                    = 0x22,
-        BMG160_REG_HIGH_DUR_X                   = 0x23,
-        BMG160_REG_HIGH_TH_Y                    = 0x24,
-        BMG160_REG_HIGH_DUR_Y                   = 0x25,
-        BMG160_REG_HIGH_TH_Z                    = 0x26,
-        BMG160_REG_HIGH_DUR_Z                   = 0x27,
-
-        // 0x28-0x30 reserved
-
-        BMG160_REG_SOC                          = 0x31,
-        BMG160_REG_A_FOC                        = 0x32,
-
-        BMG160_REG_TRIM_NVM_CTRL                = 0x33,
-
-        BMG160_REG_SPI3_WDT                     = 0x34,
-
-        // 0x35 reserved
-
-        BMG160_REG_OFC1                         = 0x36,
-        BMG160_REG_OFC2                         = 0x37,
-        BMG160_REG_OFC3                         = 0x38,
-        BMG160_REG_OFC4                         = 0x39,
-
-        BMG160_REG_TRIM_GP0                     = 0x3a,
-        BMG160_REG_TRIM_GP1                     = 0x3b,
-
-        BMG160_REG_BIST                         = 0x3c,
-
-        BMG160_REG_FIFO_CONFIG_0                = 0x3d,
-        BMG160_REG_FIFO_CONFIG_1                = 0x3e,
-
-        BMG160_REG_FIFO_DATA                    = 0x3f
-
-    } BMG160_REGS_T;
-
-    /**
-     * REG_INT_STATUS_0 bits
-     */
-    typedef enum {
-        _BMG160_INT_STATUS_0_RESERVED_BITS      = 0xf0 | 0x08 | 0x01,
-
-        BMG160_INT_STATUS_0_HIGH_INT            = 0x02,
-        BMG160_INT_STATUS_0_ANY_INT             = 0x04
-    } BMG160_INT_STATUS_0_BITS_T;
-
-    /**
-     * REG_INT_STATUS_1 bits
-     */
-    typedef enum {
-        _BMG160_INT_STATUS_1_RESERVED_BITS      = 0x0f,
-
-        BMG160_INT_STATUS_1_FIFO_INT            = 0x10,
-        BMG160_INT_STATUS_1_FAST_OFFSET_INT     = 0x20,
-        BMG160_INT_STATUS_1_AUTO_OFFSET_INT     = 0x40,
-        BMG160_INT_STATUS_1_DATA_INT            = 0x80
-    } BMG160_INT_STATUS_1_BITS_T;
-
-    /**
-     * REG_INT_STATUS_2 bits
-     */
-    typedef enum {
-        _BMG160_INT_STATUS_2_RESERVED_BITS      = 0xf0,
-
-        BMG160_INT_STATUS_2_ANY_FIRST_X         = 0x01,
-        BMG160_INT_STATUS_2_ANY_FIRST_Y         = 0x02,
-        BMG160_INT_STATUS_2_ANY_FIRST_Z         = 0x04,
-        BMG160_INT_STATUS_2_ANY_SIGN            = 0x08
-    } BMG160_INT_STATUS_2_BITS_T;
-
-    /**
-     * REG_INT_STATUS_3 bits
-     */
-    typedef enum {
-        _BMG160_INT_STATUS_3_RESERVED_BITS      = 0xf0,
-
-        BMG160_INT_STATUS_3_HIGH_FIRST_X        = 0x01,
-        BMG160_INT_STATUS_3_HIGH_FIRST_Y        = 0x02,
-        BMG160_INT_STATUS_3_HIGH_FIRST_Z        = 0x04,
-        BMG160_INT_STATUS_3_HIGH_SIGN           = 0x08
-    } BMG160_INT_STATUS_3_BITS_T;
-
-    /**
-     * REG_FIFO_STATUS bits
-     */
-    typedef enum {
-        BMG160_FIFO_STATUS_FRAME_COUNTER0       = 0x01,
-        BMG160_FIFO_STATUS_FRAME_COUNTER1       = 0x02,
-        BMG160_FIFO_STATUS_FRAME_COUNTER2       = 0x04,
-        BMG160_FIFO_STATUS_FRAME_COUNTER3       = 0x08,
-        BMG160_FIFO_STATUS_FRAME_COUNTER4       = 0x10,
-        BMG160_FIFO_STATUS_FRAME_COUNTER5       = 0x20,
-        BMG160_FIFO_STATUS_FRAME_COUNTER6       = 0x40,
-        _BMG160_FIFO_STATUS_FRAME_COUNTER_MASK  = 127,
-        _BMG160_FIFO_STATUS_FRAME_COUNTER_SHIFT = 0,
-
-        BMG160_FIFO_STATUS_FIFO_OVERRUN         = 0x80
-    } BMG160_FIFO_STATUS_BITS_T;
-
-    /**
-     * REG_GYR_RANGE bits
-     */
-    typedef enum {
-        _BMG160_GYR_RANGE_RESERVED_BITS         = 0x20 | 0x10 | 0x08,
-
-        BMG160_GYR_RANGE0                       = 0x01,
-        BMG160_GYR_RANGE1                       = 0x02,
-        BMG160_GYR_RANGE2                       = 0x04,
-        _BMG160_GYR_RANGE_MASK                  = 7,
-        _BMG160_GYR_RANGE_SHIFT                 = 0,
-
-        BMG160_GYR_RANGE_FIXED0                 = 0x40, // bits need
-                                                        // hardcoding
-                                                        // to 0b10
-        BMG160_GYR_RANGE_FIXED1                 = 0x80, // for some
-                                                        // odd
-                                                        // reason...
-        _BMG160_GYR_RANGE_FIXED_MASK            = 3,
-        _BMG160_GYR_RANGE_FIXED_SHIFT           = 6,
-        _BMG160_GYR_RANGE_FIXED_VALUE           = 2    // 0b10
-    } BMG160_GYR_RANGE_BITS_T;
-
-    /**
-     * GYR_RANGE (gyroscope deg/s range) values
-     */
-    typedef enum {
-        BMG160_RANGE_2000                       = 0, // degrees/sec
-        BMG160_RANGE_1000                       = 1,
-        BMG160_RANGE_500                        = 2,
-        BMG160_RANGE_250                        = 3,
-        BMG160_RANGE_125                        = 4
-    } BMG160_RANGE_T;
-
-    /**
-     * REG_GYR_BW bits
-     */
-    typedef enum {
-        _BMG160_GYR_BW_RESERVED_BITS            = 0xf0,
-
-        BMG160_GYR_BW0                          = 0x01,
-        BMG160_GYR_BW1                          = 0x02,
-        BMG160_GYR_BW2                          = 0x04,
-        BMG160_GYR_BW3                          = 0x08,
-        _BMG160_GYR_BW_MASK                     = 15,
-        _BMG160_GYR_BW_SHIFT                    = 0
-    } BMG160_GYR_BW_BITS_T;
-
-    /**
-     * GYR_BW (gyroscope filter bandwidth) values
-     */
-    typedef enum {
-        BMG160_BW_2000_UNFILTERED               = 0, // ODR/Filter BW
-        BMG160_BW_2000_230                      = 1, // ODR 2000Hz,
-                                                     // Filter BW
-                                                     // 230Hz
-        BMG160_BW_1000_116                      = 2,
-        BMG160_BW_400_47                        = 3,
-        BMG160_BW_200_23                        = 4,
-        BMG160_BW_100_12                        = 5,
-        BMG160_BW_200_64                        = 6,
-        BMG160_BW_100_32                        = 7
-    } BMG160_BW_T;
-
-    /**
-     * REG_LPM1 bits
-     */
-    typedef enum {
-        // 0x01 reserved
-        _BMG160_LPM1_RESERVED_BITS              = 0x40 | 0x10 | 0x01,
-
-        BMG160_LPM1_SLEEP_DUR0                  = 0x02, // sleep dur
-                                                        // in low
-                                                        // power mode
-        BMG160_LPM1_SLEEP_DUR1                  = 0x04,
-        BMG160_LPM1_SLEEP_DUR2                  = 0x08,
-        _BMG160_LPM1_SLEEP_MASK                 = 7,
-        _BMG160_LPM1_SLEEP_SHIFT                = 1,
-
-        // These are separate bits, deep_suspend and suspend (and if all
-        // 0, normal).  Since only specific combinations are allowed, we
-        // will treat this as a 3 bit bitfield called POWER_MODE.
-        BMG160_LPM1_POWER_MODE0                 = 0x20, // deep_suspend
-        BMG160_LPM1_POWER_MODE1                 = 0x40, // must always be 0!
-        BMG160_LPM1_POWER_MODE2                 = 0x80, // suspend
-        _BMG160_LPM1_POWER_MODE_MASK            = 7,
-        _BMG160_LPM1_POWER_MODE_SHIFT           = 5
-    } BMG160_LPM1_BITS_T;
-
-    /**
-     * SLEEP_DUR values
-     */
-    typedef enum {
-        BMG160_SLEEP_DUR_2                      = 0, // 2ms
-        BMG160_SLEEP_DUR_4                      = 1,
-        BMG160_SLEEP_DUR_5                      = 2,
-        BMG160_SLEEP_DUR_8                      = 3,
-        BMG160_SLEEP_DUR_10                     = 4,
-        BMG160_SLEEP_DUR_15                     = 5,
-        BMG160_SLEEP_DUR_18                     = 6,
-        BMG160_SLEEP_DUR_20                     = 7
-    } BMG160_SLEEP_DUR_T;
-
-    /**
-     * POWER_MODE values
-     */
-    typedef enum {
-        BMG160_POWER_MODE_NORMAL                = 0,
-        BMG160_POWER_MODE_DEEP_SUSPEND          = 1,
-        BMG160_POWER_MODE_SUSPEND               = 4
-    } BMG160_POWER_MODE_T;
-
-    /**
-     * REG_LPM2 bits
-     */
-    typedef enum {
-        _BMG160_LPM2_RESERVED_BITS              = 0x08,
-
-        BMG160_LPM2_AUTOSLEEP_DUR0              = 0x01,
-        BMG160_LPM2_AUTOSLEEP_DUR1              = 0x02,
-        BMG160_LPM2_AUTOSLEEP_DUR2              = 0x04,
-        _BMG160_LPM2_AUTOSLEEP_DUR_MASK         = 7,
-        _BMG160_LPM2_AUTOSLEEP_DUR_SHIFT        = 0,
-
-        BMG160_LPM2_EXT_TRIG_SEL0               = 0x10,
-        BMG160_LPM2_EXT_TRIG_SEL1               = 0x20,
-        _BMG160_LPM2_EXT_TRIG_SEL_MASK          = 3,
-        _BMG160_LPM2_EXT_TRIG_SEL_SHIFT         = 4,
-
-        BMG160_LPM2_POWER_SAVE_MODE             = 0x40,
-        BMG160_LPM2_FAST_POWERUP                = 0x80
-    } BMG160_LPM2_BITS_T;
-
-
-    /**
-     * LPM2_AUTOSLEEP_DUR values
-     */
-    typedef enum {
-        BMG160_AUTOSLEEP_DUR_NONE               = 0,
-        BMG160_AUTOSLEEP_DUR_4MS                = 1,
-        BMG160_AUTOSLEEP_DUR_5MS                = 2,
-        BMG160_AUTOSLEEP_DUR_8MS                = 3,
-        BMG160_AUTOSLEEP_DUR_10MS               = 4,
-        BMG160_AUTOSLEEP_DUR_15MS               = 5,
-        BMG160_AUTOSLEEP_DUR_20MS               = 6,
-        BMG160_AUTOSLEEP_DUR_40MS               = 7
-    } BMG160_AUTOSLEEP_DUR_T;
-
-    /**
-     * LPM2_EXT_TRIG_SEL values
-     */
-    typedef enum {
-        BMG160_EXT_TRIG_SEL_NONE                = 0,
-        BMG160_EXT_TRIG_SEL_INT1                = 1,
-        BMG160_EXT_TRIG_SEL_INT2                = 2,
-        BMG160_EXT_TRIG_SEL_SDO                 = 3 // if SPI3 mode
-                                                    // (unsupported)
-    } BMG160_EXT_TRIG_SEL_T;
-
-    /**
-     * REG_RATE_HBW bits
-     */
-    typedef enum {
-        _BMG160_RATE_HBW_RESERVED_BITS          = 0x0f | 0x10 | 0x20,
-
-        BMG160_RATE_HBW_SHADOW_DIS              = 0x40,
-        BMG160_RATE_HBW_DATA_HIGH_BW            = 0x80
-    } BMG160_RATE_HBW_BITS_T;
-
-    /**
-     * REG_INT_EN_0 bits
-     */
-    typedef enum {
-        _BMG160_INT_EN_0_RESERVED_BITS          = 0x20 | 0x10 | 0x08 | 0x02
-                                                  | 0x01,
-
-        BMG160_INT_EN_0_AUTO_OFFSET_EN          = 0x04,
-
-        BMG160_INT_EN_0_FIFO_EN                 = 0x40,
-        BMG160_INT_EN_0_DATA_EN                 = 0x80
-    } BMG160_INT_EN_0_BITS_T;
-
-    /**
-     * REG_INT_EN_1 bits
-     */
-    typedef enum {
-        _BMG160_INT_EN_1_INT1_RESERVED_BITS     = 0xf0,
-
-        BMG160_INT_EN_1_INT1_LVL                = 0x01, // level or edge
-        BMG160_INT_EN_1_INT1_OD                 = 0x02, // push-pull
-                                                        // or open
-                                                        // drain
-        BMG160_INT_EN_1_INT2_LVL                = 0x04,
-        BMG160_INT_EN_1_INT2_OD                 = 0x08
-    } BMG160_INT_EN_1_BITS_T;
-
-    /**
-     * REG_INT_MAP_0 bits
-     */
-    typedef enum {
-        _BMG160_INT_MAP_0_RESERVED_BITS         = 0xf0 | 0x04 | 0x01,
-
-        BMG160_INT_MAP_0_INT1_ANY               = 0x02,
-        BMG160_INT_MAP_0_INT1_HIGH              = 0x08
-    } BMG160_INT_MAP_0_BITS_T;
-
-    /**
-     * REG_INT_MAP_1 bits
-     */
-    typedef enum {
-        BMG160_INT_MAP_1_INT1_DATA              = 0x01,
-        BMG160_INT_MAP_1_INT1_FAST_OFFSET       = 0x02,
-        BMG160_INT_MAP_1_INT1_FIFO              = 0x04,
-        BMG160_INT_MAP_1_INT1_AUTO_OFFSET       = 0x08,
-        BMG160_INT_MAP_1_INT2_AUTO_OFFSET       = 0x10,
-        BMG160_INT_MAP_1_INT2_FIFO              = 0x20,
-        BMG160_INT_MAP_1_INT2_FAST_OFFSET       = 0x40,
-        BMG160_INT_MAP_1_INT2_DATA              = 0x80
-    } BMG160_INT_MAP_1_BITS_T;
-
-    /**
-     * REG_INT_1A bits
-     */
-    typedef enum {
-        _BMG160_INT_1A_RESERVED_BITS           = 0xd5,
-
-        BMG160_INT_1A_ANY_UNFILT_DATA          = 0x02,
-        BMG160_INT_1A_HIGH_UNFILT_DATA         = 0x08,
-        BMG160_INT_1A_SLOW_OFFSET_UNFILT       = 0x20
-    } BMG160_INT_1A_BITS_T;
-
-    /**
-     * REG_INT_1B bits
-     */
-    typedef enum {
-        BMG160_INT_1B_ANY_TH0                  = 0x01,
-        BMG160_INT_1B_ANY_TH1                  = 0x02,
-        BMG160_INT_1B_ANY_TH2                  = 0x04,
-        BMG160_INT_1B_ANY_TH3                  = 0x08,
-        BMG160_INT_1B_ANY_TH4                  = 0x10,
-        BMG160_INT_1B_ANY_TH5                  = 0x20,
-        BMG160_INT_1B_ANY_TH6                  = 0x40,
-        _BMG160_INT_1B_ANY_TH_MASK             = 127,
-        _BMG160_INT_1B_ANY_TH_SHIFT            = 0,
-
-        BMG160_INT_1B_FAST_OFFSET_UNFILT       = 0x80
-    } BMG160_INT_1B_BITS_T;
-
-    /**
-     * REG_INT_1C bits
-     */
-    typedef enum {
-        _BMG160_INT_1C_RESERVED_BITS           = 0x08,
-
-        BMG160_INT_1C_ANY_EN_X                 = 0x01,
-        BMG160_INT_1C_ANY_EN_Y                 = 0x02,
-        BMG160_INT_1C_ANY_EN_Z                 = 0x04,
-
-        BMG160_INT_1C_ANY_DUR_SAMPLE0          = 0x10,
-        BMG160_INT_1C_ANY_DUR_SAMPLE1          = 0x20,
-        BMG160_INT_1C_ANY_DUR_SAMPLE_MASK      = 3,
-        BMG160_INT_1C_ANY_DUR_SAMPLE_SHIFT     = 4,
-
-        BMG160_INT_1C_AWAKE_DUR0               = 0x40,
-        BMG160_INT_1C_AWAKE_DUR1               = 0x80,
-        BMG160_INT_1C_AWAKE_DUR_MASK           = 3,
-        BMG160_INT_1C_AWAKE_DUR_SHIFT          = 6
-    } BMG160_INT_1C_BITS_T;
-
-    /**
-     * INT_1C_ANY_DUR_SAMPLE values
-     */
-    typedef enum {
-        BMG160_ANY_DUR_SAMPLE_4                 = 0, // samples
-        BMG160_ANY_DUR_SAMPLE_8                 = 1,
-        BMG160_ANY_DUR_SAMPLE_12                = 2,
-        BMG160_ANY_DUR_SAMPLE_16                = 3
-    } BMG160_ANY_DUR_SAMPLE_T;
-
-    /**
-     * INT_1C_AWAKE_DUR values
-     */
-    typedef enum {
-        BMG160_AWAKE_DUR_SAMPLE_8               = 0, // samples
-        BMG160_AWAKE_DUR_SAMPLE_16              = 1,
-        BMG160_AWAKE_DUR_SAMPLE_32              = 2,
-        BMG160_AWAKE_DUR_SAMPLE_64              = 3
-    } BMG160_AWAKE_DUR_SAMPLE_T;
-
-    /**
-     * REG_INT_1E bits
-     */
-    typedef enum {
-        _BMG160_INT_1E_RESERVED_BITS           = 0x7f,
-
-        BMG160_INT_1E_FIFO_WM_EN               = 0x80
-    } BMG160_INT_1E_BITS_T;
-
-    /**
-     * REG_INT_RST_LATCH bits
-     */
-    typedef enum {
-        _BMG160_INT_RST_LATCH_RESERVED_BITS     = 0x20,
-
-        BMG160_INT_RST_LATCH0                   = 0x01,
-        BMG160_INT_RST_LATCH1                   = 0x02,
-        BMG160_INT_RST_LATCH2                   = 0x04,
-        BMG160_INT_RST_LATCH3                   = 0x08,
-        _BMG160_INT_RST_LATCH_MASK              = 15,
-        _BMG160_INT_RST_LATCH_SHIFT             = 0,
-
-        BMG160_INT_RST_LATCH_STATUS_BIT         = 0x10,
-
-        BMG160_INT_RST_LATCH_OFFSET_RESET       = 0x40,
-        BMG160_INT_RST_LATCH_RESET_INT          = 0x80
-    } BMG160_INT_RST_LATCH_BITS_T;
-
-    /**
-     * RST_LATCH values
-     */
-    typedef enum {
-        BMG160_RST_LATCH_NON_LATCHED            = 0,
-        BMG160_RST_LATCH_TEMPORARY_250MS        = 1,
-        BMG160_RST_LATCH_TEMPORARY_500MS        = 2,
-        BMG160_RST_LATCH_TEMPORARY_1S           = 3,
-        BMG160_RST_LATCH_TEMPORARY_2S           = 4,
-        BMG160_RST_LATCH_TEMPORARY_4S           = 5,
-        BMG160_RST_LATCH_TEMPORARY_8S           = 6,
-        BMG160_RST_LATCH_LATCHED                = 7,
-
-        // 8 == non latched
-
-        BMG160_RST_LATCH_TEMPORARY_250US        = 9,
-        BMG160_RST_LATCH_TEMPORARY_500US        = 10,
-        BMG160_RST_LATCH_TEMPORARY_1MS          = 11,
-        BMG160_RST_LATCH_TEMPORARY_12_5MS       = 12,
-        BMG160_RST_LATCH_TEMPORARY_25MS         = 13,
-        BMG160_RST_LATCH_TEMPORARY_50MS         = 14
-
-        // 15 == latched
-    } BMG160_RST_LATCH_T;
-
-    /**
-     * REG_HIGH_TH_* (X, Y, and Z) register bits
-     */
-    typedef enum {
-        BMG160_HIGH_TH_EN                       = 0x01,
-
-        BMG160_HIGH_TH_TH0                      = 0x02,
-        BMG160_HIGH_TH_TH1                      = 0x04,
-        BMG160_HIGH_TH_TH2                      = 0x08,
-        BMG160_HIGH_TH_TH3                      = 0x10,
-        BMG160_HIGH_TH_TH4                      = 0x20,
-        _BMG160_HIGH_TH_TH_MASK                 = 31,
-        _BMG160_HIGH_TH_TH_SHIFT                = 1,
-
-        BMG160_HIGH_TH_HY0                      = 0x40,
-        BMG160_HIGH_TH_HY1                      = 0x80,
-        _BMG160_HIGH_TH_HY_MASK                 = 3,
-        _BMG160_HIGH_TH_HY_SHIFT                = 6
-    } BMG160_HIGH_TH_BITS_T;
-
-    /**
-     * REG_SOC bits
-     */
-    typedef enum {
-        BMG160_SOC_SLOW_OFFSET_EN_X             = 0x01,
-        BMG160_SOC_SLOW_OFFSET_EN_Y             = 0x02,
-        BMG160_SOC_SLOW_OFFSET_EN_Z             = 0x04,
-
-        BMG160_SOC_SLOW_OFFSET_DUR0             = 0x08,
-        BMG160_SOC_SLOW_OFFSET_DUR1             = 0x10,
-        BMG160_SOC_SLOW_OFFSET_DUR2             = 0x20,
-        _BMG160_SOC_SLOW_OFFSET_DUR_MASK        = 7,
-        _BMG160_SOC_SLOW_OFFSET_DUR_SHIFT       = 3,
-
-        BMG160_SOC_SLOW_OFFSET_TH0              = 0x40,
-        BMG160_SOC_SLOW_OFFSET_TH1              = 0x80,
-        _BMG160_SOC_SLOW_OFFSET_TH_MASK         = 3,
-        _BMG160_SOC_SLOW_OFFSET_TH_SHIFT        = 6
-    } BMG160_SOC_BITS_T;
-
-    /**
-     * SOC_SLOW_OFFSET_DUR values
-     */
-    typedef enum {
-        BMG160_SLOW_OFFSET_DUR_40MS             = 0, // 40ms
-        BMG160_SLOW_OFFSET_DUR_80MS             = 1,
-        BMG160_SLOW_OFFSET_DUR_160MS            = 2,
-        BMG160_SLOW_OFFSET_DUR_320MS            = 3,
-        BMG160_SLOW_OFFSET_DUR_640MS            = 4,
-        BMG160_SLOW_OFFSET_DUR_1280MS           = 5
-    } BMG160_SLOW_OFFSET_DUR_T;
-
-    /**
-     * SOC_SLOW_OFFSET_TH values
-     */
-    typedef enum {
-        BMG160_SLOW_OFFSET_TH_0_1               = 0, // 0.1 degree/s
-        BMG160_SLOW_OFFSET_TH_0_2               = 1,
-        BMG160_SLOW_OFFSET_TH_0_5               = 2,
-        BMG160_SLOW_OFFSET_TH_1                 = 3
-    } BMG160_SLOW_OFFSET_TH_T;
-
-    /**
-     * REG_A_FOC bits
-     */
-    typedef enum {
-        BMG160_A_FOC_FAST_OFFSET_EN_X           = 0x01,
-        BMG160_A_FOC_FAST_OFFSET_EN_Y           = 0x02,
-        BMG160_A_FOC_FAST_OFFSET_EN_Z           = 0x04,
-
-        BMG160_A_FOC_FAST_OFFSET_EN             = 0x08,
-
-        BMG160_A_FOC_FAST_OFFSET_WORDLENGTH0    = 0x10,
-        BMG160_A_FOC_FAST_OFFSET_WORDLENGTH1    = 0x20,
-        _BMG160_A_FOC_FAST_OFFSET_WORDLENGTH_MASK = 3,
-        _BMG160_A_FOC_FAST_OFFSET_WORDLENGTH_SHIFT = 4,
-
-        BMG160_A_FOC_AUTO_OFFSET_WORDLENGTH0    = 0x40,
-        BMG160_A_FOC_AUTO_OFFSET_WORDLENGTH1    = 0x80,
-        _BMG160_A_FOC_AUTO_OFFSET_WORDLENGTH_MASK = 3,
-        _BMG160_A_FOC_AUTO_OFFSET_WORDLENGTH_SHIFT = 6
-    } BMG160_A_FOC_BITS_T;
-
-    /**
-     * FAST_OFFSET_WORDLENGTH values
-     */
-    typedef enum {
-        BMG160_FAST_OFFSET_WORDLENGTH_32        = 0, // samples
-        BMG160_FAST_OFFSET_WORDLENGTH_64        = 1,
-        BMG160_FAST_OFFSET_WORDLENGTH_128       = 2,
-        BMG160_FAST_OFFSET_WORDLENGTH_256       = 3
-    } BMG160_FAST_OFFSET_WORDLENGTH_T;
-
-    /**
-     * AUTO_OFFSET_WORDLENGTH values
-     */
-    typedef enum {
-        BMG160_AUTO_OFFSET_WORDLENGTH_32        = 0, // samples
-        BMG160_AUTO_OFFSET_WORDLENGTH_64        = 1,
-        BMG160_AUTO_OFFSET_WORDLENGTH_128       = 2,
-        BMG160_AUTO_OFFSET_WORDLENGTH_256       = 3
-    } BMG160_AUTO_OFFSET_WORDLENGTH_T;
-
-    /**
-     * REG_TRIM_NVM_CTRL bits
-     */
-    typedef enum {
-        BMG160_TRIM_NVM_CTRL_NVM_PROG_MODE     = 0x01,
-        BMG160_TRIM_NVM_CTRL_NVM_PROG_TRIG     = 0x02,
-        BMG160_TRIM_NVM_CTRL_NVM_PROG_RDY      = 0x04,
-        BMG160_TRIM_NVM_CTRL_NVM_PROG_LOAD     = 0x08,
-
-        BMG160_TRIM_NVM_CTRL_NVM_REMAIN0       = 0x10,
-        BMG160_TRIM_NVM_CTRL_NVM_REMAIN1       = 0x20,
-        BMG160_TRIM_NVM_CTRL_NVM_REMAIN2       = 0x40,
-        BMG160_TRIM_NVM_CTRL_NVM_REMAIN3       = 0x80,
-        _BMG160_TRIM_NVM_CTRL_NVM_REMAIN_MASK  = 15,
-        _BMG160_TRIM_NVM_CTRL_NVM_REMAIN_SHIFT = 4
-    } BMG160_TRIM_NVM_CTRL_BITS_T;
-
-    /**
-     * REG_SPI3_WDT bits
-     */
-    typedef enum {
-        _BMG160_SPI3_WDT_RESERVED_BITS         = 0xf0 | 0x08,
-
-        BMG160_SPI3_WDT_SPI3                   = 0x01, // 3-wire SPI -
-                                                       // NOT
-                                                       // SUPPORTED
-
-        BMG160_SPI3_WDT_I2C_WDT_SEL            = 0x02,
-        BMG160_SPI3_WDT_I2C_WDT_EN             = 0x04
-
-        // 0x08-0x80 reserved
-    } BMG160_SPI3_WDT_BITS_T;
-
-    /**
-     * REG_OFC1 bits, the missing x, y, and z llsb bits are in GP0
-     */
-    typedef enum {
-        BMG160_OFC1_OFFSET_Z0                  = 0x01, // Z lsb (3:1)
-        BMG160_OFC1_OFFSET_Z1                  = 0x02,
-        BMG160_OFC1_OFFSET_Z2                  = 0x04,
-        _BMG160_OFC1_OFFSET_Z_MASK             = 7,
-        _BMG160_OFC1_OFFSET_Z_SHIFT            = 0,
-
-        BMG160_OFC1_OFFSET_Y0                  = 0x08, // Y lsb (3:1)
-        BMG160_OFC1_OFFSET_Y1                  = 0x10,
-        BMG160_OFC1_OFFSET_Y2                  = 0x20,
-        _BMG160_OFC1_OFFSET_Y_MASK             = 7,
-        _BMG160_OFC1_OFFSET_Y_SHIFT            = 3,
-
-        BMG160_OFC1_OFFSET_X0                  = 0x08, // bits 3:2 of
-                                                       // X lsb. geez
-        BMG160_OFC1_OFFSET_X1                  = 0x10,
-        _BMG160_OFC1_OFFSET_X_MASK             = 3,
-        _BMG160_OFC1_OFFSET_X_SHIFT            = 6
-    } BMG160_OFC1_OFFSET_BITS_T;
-
-    /**
-     * REG_GP0 bits
-     */
-    typedef enum {
-        BMG160_GP0_OFFSET_Z                    = 0x01, // Z llsb (bit 0)
-        BMG160_GP0_OFFSET_Y                    = 0x02, // Y llsb (bit 0)
-
-        BMG160_GP0_OFFSET_X0                   = 0x04, // X llsbs (bits 1:0)
-        BMG160_GP0_OFFSET_X1                   = 0x08,
-        _BMG160_GP0_OFFSET_X_MASK              = 3,
-        _BMG160_GP0_OFFSET_X_SHIFT             = 2,
-
-        BMG160_GP0_GP00                        = 0x10,
-        BMG160_GP0_GP01                        = 0x20,
-        BMG160_GP0_GP02                        = 0x40,
-        BMG160_GP0_GP03                        = 0x80,
-        _BMG160_GP0_GP0_MASK                   = 15,
-        _BMG160_GP0_GP0_SHIFT                  = 4
-    } BMG160_GP0_BITS_T;
-
-    /**
-     * REG_BIST bits
-     */
-    typedef enum {
-        _BMG160_BIST_RESERVED_BITS             = 0x80 | 0x40 | 0x20 | 0x08,
-
-        BMG160_BIST_TRIG_BIST                  = 0x01,
-        BMG160_BIST_BIST_RDY                   = 0x02,
-        BMG160_BIST_BIST_FAIL                  = 0x04,
-
-        BMG160_BIST_RATE_OK                    = 0x10
-    } BMG160_BIST_BITS_T;
-
-    /**
-     * REG_FIFO_CONFIG_0 bits
-     */
-    typedef enum {
-        BMG160_FIFO_CONFIG_0_WATER_MARK0       = 0x01,
-        BMG160_FIFO_CONFIG_0_WATER_MARK1       = 0x02,
-        BMG160_FIFO_CONFIG_0_WATER_MARK2       = 0x04,
-        BMG160_FIFO_CONFIG_0_WATER_MARK3       = 0x08,
-        BMG160_FIFO_CONFIG_0_WATER_MARK4       = 0x10,
-        BMG160_FIFO_CONFIG_0_WATER_MARK5       = 0x20,
-        BMG160_FIFO_CONFIG_0_WATER_MARK6       = 0x40,
-        _BMG160_FIFO_CONFIG_0_WATER_MARK_MASK  = 127,
-        _BMG160_FIFO_CONFIG_0_WATER_MARK_SHIFT = 0,
-
-        BMG160_FIFO_CONFIG_0_TAG               = 0x80
-    } BMG160_FIFO_CONFIG_0_BITS_T;
-
-    /**
-     * REG_FIFO_CONFIG_1 bits
-     */
-    typedef enum {
-        _BMG160_FIFO_CONFIG_1_RESERVED_BITS     = 0x20 | 0x10 |0x08 | 0x04,
-
-        BMG160_FIFO_CONFIG_1_FIFO_DATA_SEL0     = 0x01,
-        BMG160_FIFO_CONFIG_1_FIFO_DATA_SEL1     = 0x02,
-        _BMG160_FIFO_CONFIG_1_FIFO_DATA_SEL     = 3,
-        _BMG160_FIFO_CONFIG_1_FIFO_DATA_SHIFT   = 0,
-
-        BMG160_FIFO_CONFIG_1_FIFO_MODE0         = 0x40,
-        BMG160_FIFO_CONFIG_1_FIFO_MODE1         = 0x80,
-        _BMG160_FIFO_CONFIG_1_FIFO_MODE_MASK    = 3,
-        _BMG160_FIFO_CONFIG_1_FIFO_MODE_SHIFT   = 6
-    } BMG160_FIFO_CONFIG_1_BITS_T;
-
-    /**
-     * FIFO_DATA_SEL values
-     */
-    typedef enum {
-        BMG160_FIFO_DATA_SEL_XYZ               = 0,
-        BMG160_FIFO_DATA_SEL_X                 = 1,
-        BMG160_FIFO_DATA_SEL_Y                 = 2,
-        BMG160_FIFO_DATA_SEL_Z                 = 3
-    } BMG160_FIFO_DATA_SEL_T;
-
-    /**
-     * FIFO_MODE values
-     */
-    typedef enum {
-        BMG160_FIFO_MODE_BYPASS                = 0,
-        BMG160_FIFO_MODE_FIFO                  = 1,
-        BMG160_FIFO_MODE_STREAM                = 2
-    } BMG160_FIFO_MODE_T;
-
-    // interrupt selection for installISR() and uninstallISR()
-    typedef enum {
-        BMG160_INTERRUPT_INT1,
-        BMG160_INTERRUPT_INT2
-    } BMG160_INTERRUPT_PINS_T;
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/bmg160/bmg160_fti.c b/src/bmg160/bmg160_fti.c
deleted file mode 100644
index d3a3f68..0000000
--- a/src/bmg160/bmg160_fti.c
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "bmg160.h"
-#include "upm_fti.h"
-
-/**
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_bmg160_name[] = "BMG160";
-const char upm_bmg160_description[] = "Triple Axis Digital Gyroscope";
-const upm_protocol_t upm_bmg160_protocol[] = {UPM_I2C, UPM_SPI, UPM_GPIO};
-const upm_sensor_t upm_bmg160_category[] = {UPM_GYROSCOPE};
-
-// forward declarations
-const void* upm_bmg160_get_ft(upm_sensor_t sensor_type);
-void* upm_bmg160_init_name();
-void upm_bmg160_close(void *dev);
-upm_result_t upm_bmg160_get_value(void *dev, float *value);
-
-const upm_sensor_descriptor_t upm_bmg160_get_descriptor()
-{
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_bmg160_name;
-    usd.description = upm_bmg160_description;
-    usd.protocol_size = 3;
-    usd.protocol = upm_bmg160_protocol;
-    usd.category_size = 1;
-    usd.category = upm_bmg160_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = &upm_bmg160_init_name,
-    .upm_sensor_close = &upm_bmg160_close,
-};
-
-static const upm_gyroscope_ft gft =
-{
-    .upm_gyroscope_get_value = &upm_bmg160_get_value
-};
-
-const void* upm_bmg160_get_ft(upm_sensor_t sensor_type)
-{
-  switch(sensor_type)
-    {
-    case UPM_SENSOR:
-      return &ft;
-
-    case UPM_GYROSCOPE:
-      return &gft;
-
-    default:
-      return NULL;
-    }
-}
-
-void* upm_bmg160_init_name()
-{
-    return NULL;
-}
-
-
-void upm_bmg160_close(void *dev)
-{
-    bmg160_close((bmg160_context)dev);
-}
-
-upm_result_t upm_bmg160_get_value(void *dev, float *value)
-{
-    if (bmg160_update((bmg160_context)dev))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    float x, y, z;
-
-    bmg160_get_gyroscope(dev, &x, &y, &z);
-
-    value[0] = x;
-    value[1] = y;
-    value[2] = z;
-
-    return UPM_SUCCESS;
-}
diff --git a/src/bmi160/CMakeLists.txt b/src/bmi160/CMakeLists.txt
deleted file mode 100644
index 283acfb..0000000
--- a/src/bmi160/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME bmi160
-    DESCRIPTION "Bosch Sensortec IMU (triaxial Accelerometer, Triaxial Gyroscope and Magnetometer Interface)"
-    C_HDR bmi160.h bmi160_defs.h bosch_bmi160.h
-    C_SRC bmi160.c bosch_bmi160.c
-    CPP_HDR bmi160.hpp
-    CPP_SRC bmi160.cxx
-#    FTI_SRC bmi160_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/bmi160/bmi160.c b/src/bmi160/bmi160.c
deleted file mode 100644
index 4a5a534..0000000
--- a/src/bmi160/bmi160.c
+++ /dev/null
@@ -1,588 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <string.h>
-#include <assert.h>
-#include <mraa/i2c.h>
-#include <mraa/spi.h>
-#include <mraa/gpio.h>
-
-#include "bmi160.h"
-
-#include <upm_utilities.h>
-
-// we have to do it the old skool way.  Note, this also means that
-// only one instance of the bmi160 driver can be active at a time.
-static mraa_i2c_context i2cContext = NULL;
-static mraa_spi_context spiContext = NULL;
-/* this is used for chip-select when using SPI */
-static mraa_gpio_context gpioContext = NULL;
-
-// whether we are doing I2C or SPI
-static bool isSPI = false;
-
-// Our bmi160 info structure
-struct bmi160_t s_bmi160;
-
-// For SPI, these are our CS on/off functions, if needed
-static void bmi160_cs_on()
-{
-    if (gpioContext)
-        mraa_gpio_write(gpioContext, 0);
-}
-
-static void bmi160_cs_off()
-{
-    if (gpioContext)
-        mraa_gpio_write(gpioContext, 1);
-}
-
-// i2c bus read and write functions for use with the bmi driver code
-s8 bmi160_bus_read(u8 dev_addr, u8 reg_addr, u8 *reg_data, u8 cnt)
-{
-    if (isSPI)
-    {
-        if (!spiContext)
-        {
-            printf("%s: spiContext is NULL.\n", __FUNCTION__);
-            return 1;
-        }
-
-        reg_addr |= 0x80; // needed for read
-
-        uint8_t sbuf[cnt + 1];
-        memset((char *)sbuf, 0, cnt + 1);
-        sbuf[0] = reg_addr;
-
-        bmi160_cs_on();
-
-        if (mraa_spi_transfer_buf(spiContext, sbuf, sbuf, cnt + 1))
-        {
-            bmi160_cs_off();
-            printf("%s: mraa_spi_transfer_buf() failed.\n", __FUNCTION__);
-            return 1;
-        }
-        bmi160_cs_off();
-
-      // now copy it into user buffer
-        int i;
-        for (i=0; i<cnt; i++)
-            reg_data[i] = sbuf[i + 1];
-
-        return 0;
-    }
-
-    // doing I2C
-
-    if (!i2cContext)
-    {
-        printf("%s: i2cContext is NULL.\n", __FUNCTION__);
-        return 1;
-    }
-
-    if (mraa_i2c_read_bytes_data(i2cContext, reg_addr, reg_data, cnt) < 0)
-    {
-        printf("%s: mraa_i2c_read_bytes() failed.\n", __FUNCTION__);
-        return 1;
-    }
-
-    return 0;
-}
-
-s8 bmi160_bus_write(u8 dev_addr, u8 reg_addr, u8 *reg_data, u8 cnt)
-{
-    if (isSPI)
-    {
-        if (!spiContext)
-        {
-            printf("%s: spiContext is NULL.\n", __FUNCTION__);
-            return 1;
-        }
-
-        reg_addr &= 0x7f; // mask off 0x80 for writing
-
-        uint8_t sbuf[cnt + 1];
-        memset((char *)sbuf, 0, cnt + 1);
-        sbuf[0] = reg_addr;
-
-        // copy in the data to write...
-        int i;
-        for (i=0; i<cnt; i++)
-            sbuf[i + 1] = reg_data[i];
-
-        bmi160_cs_on();
-
-        if (mraa_spi_transfer_buf(spiContext, sbuf, sbuf, cnt + 1))
-        {
-            bmi160_cs_off();
-            printf("%s: mraa_spi_transfer_buf() failed.\n", __FUNCTION__);
-            return 1;
-        }
-        bmi160_cs_off();
-
-        return 0;
-    }
-
-    // I2C...
-    if (!i2cContext)
-    {
-        printf("%s: i2cContext is NULL.\n", __FUNCTION__);
-        return 1;
-    }
-
-    uint8_t buffer[cnt + 1];
-
-    buffer[0] = reg_addr;
-    int i;
-    for (i=0; i<cnt; i++)
-        buffer[i+1] = reg_data[i];
-
-    mraa_result_t rv = mraa_i2c_write(i2cContext, buffer, cnt+1);
-
-    if (rv != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_i2c_write() failed.\n", __FUNCTION__);
-        return 1;
-    }
-
-    return 0;
-}
-
-// delay for some milliseconds
-void bmi160_delay_ms(u32 msek)
-{
-  upm_delay_ms(msek);
-}
-
-
-bmi160_context bmi160_init(unsigned int bus, int address, int cs_pin,
-                           bool enable_mag)
-{
-    bmi160_context dev =
-        (bmi160_context)malloc(sizeof(struct _bmi160_context));
-
-    if (!dev)
-        return NULL;
-
-    // zero out context
-    memset((void *)dev, 0, sizeof(struct _bmi160_context));
-
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        bmi160_close(dev);
-        return NULL;
-    }
-
-    if (address > 0)
-    {
-        // we are doing I2C
-        isSPI = false;
-
-        if (!(i2cContext = mraa_i2c_init(bus)))
-        {
-            printf("%s: mraa_i2c_init() failed.\n", __FUNCTION__);
-            bmi160_close(dev);
-            return NULL;
-        }
-
-        if (mraa_i2c_address(i2cContext, address) != MRAA_SUCCESS)
-        {
-            printf("%s: mraa_i2c_address() failed.\n", __FUNCTION__);
-            bmi160_close(dev);
-            return NULL;
-        }
-    }
-    else
-    {
-        // we are doing SPI
-        isSPI = true;
-
-        if (!(spiContext = mraa_spi_init(bus)))
-        {
-            printf("%s: mraa_spi_init() failed.\n", __FUNCTION__);
-            bmi160_close(dev);
-            return NULL;
-        }
-
-        // Only create cs context if we are actually using a valid pin.
-        // A hardware controlled pin should specify cs as -1.
-        if (cs_pin >= 0)
-        {
-            if (!(gpioContext = mraa_gpio_init(cs_pin)))
-            {
-                printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
-                bmi160_close(dev);
-                return NULL;
-            }
-
-            mraa_gpio_dir(gpioContext, MRAA_GPIO_OUT);
-            bmi160_cs_off();
-        }
-
-        if (mraa_spi_mode(spiContext, MRAA_SPI_MODE0))
-        {
-            printf("%s: mraa_spi_mode() failed.\n", __FUNCTION__);
-            bmi160_close(dev);
-            return NULL;
-        }
-
-        if (mraa_spi_frequency(spiContext, 5000000))
-        {
-            printf("%s: mraa_spi_frequency() failed.\n", __FUNCTION__);
-            bmi160_close(dev);
-            return NULL;
-        }
-    }
-
-    // init the driver interface functions
-    s_bmi160.bus_write = bmi160_bus_write;
-    s_bmi160.bus_read = bmi160_bus_read;
-    s_bmi160.delay_msec = bmi160_delay_ms;
-    if (isSPI)
-        s_bmi160.dev_addr = 0;
-    else
-        s_bmi160.dev_addr = address & 0xff;
-
-    // Init our driver interface pointers
-    if (bmi160_init_bus(&s_bmi160))
-    {
-        printf("%s: bmi160_bus_init() failed.\n", __FUNCTION__);
-        bmi160_close(dev);
-        return NULL;
-    }
-
-    // bmi160_init_bus will read the chip Id and deposit into our
-    // interface struct.  So, check it out and make sure it's correct.
-    if (s_bmi160.chip_id != BMI160_CHIP_ID)
-    {
-        printf("%s: Error: expected chip id %02x, but got %02x.\n",
-               __FUNCTION__, BMI160_CHIP_ID, s_bmi160.chip_id);
-        bmi160_close(dev);
-        return NULL;
-    }
-
-    dev->accelScale = 1.0;
-    dev->gyroScale = 1.0;
-    dev->magEnabled = false;
-
-    // This should be interesting...
-    const u32 C_BMI160_THIRTY_U8X = 30;
-
-    bmi160_enable_magnetometer(dev, enable_mag);
-
-    /* Set the accel mode as Normal write in the register 0x7E */
-    bmi160_set_command_register(ACCEL_MODE_NORMAL);
-
-    /* bmi160_delay_ms in ms */
-    bmi160_delay_ms(C_BMI160_THIRTY_U8X);
-
-    /* Set the gyro mode as Normal write in the register 0x7E */
-    bmi160_set_command_register(GYRO_MODE_NORMAL);
-
-    /* bmi160_delay_ms in ms */
-    bmi160_delay_ms(C_BMI160_THIRTY_U8X);
-
-    /* Set the accel bandwidth as OSRS4 */
-    bmi160_set_accel_bw(BMI160_ACCEL_OSR4_AVG1);
-    bmi160_delay_ms(BMI160_GEN_READ_WRITE_DELAY);
-
-    /* Set the gryo bandwidth as Normal */
-    bmi160_set_gyro_bw(BMI160_GYRO_NORMAL_MODE);
-    bmi160_delay_ms(BMI160_GEN_READ_WRITE_DELAY);
-
-    /* set gyro data rate as 200Hz */
-    bmi160_set_gyro_output_data_rate(BMI160_GYRO_OUTPUT_DATA_RATE_200HZ);
-    bmi160_delay_ms(BMI160_GEN_READ_WRITE_DELAY);
-
-    /* set accel data rate as 200Hz */
-    bmi160_set_accel_output_data_rate(BMI160_ACCEL_OUTPUT_DATA_RATE_200HZ,
-                                      BMI160_ACCEL_OSR4_AVG1);
-    bmi160_delay_ms(BMI160_GEN_READ_WRITE_DELAY);
-
-    bmi160_set_accelerometer_scale(dev, BMI160_ACC_RANGE_2G);
-    bmi160_set_gyroscope_scale(dev, BMI160_GYRO_RANGE_125);
-
-    return dev;
-}
-
-void bmi160_close(bmi160_context dev)
-{
-    assert(dev != NULL);
-
-    if (i2cContext)
-        mraa_i2c_stop(i2cContext);
-    i2cContext = NULL;
-
-    if (spiContext)
-        mraa_spi_stop(spiContext);
-    spiContext = NULL;
-
-    if (gpioContext)
-        mraa_gpio_close(gpioContext);
-    gpioContext = NULL;
-
-    free(dev);
-}
-
-void bmi160_update(const bmi160_context dev)
-{
-    assert(dev != NULL);
-
-    struct bmi160_gyro_t gyroxyz;
-    struct bmi160_accel_t accelxyz;
-    struct bmi160_mag_xyz_s32_t magxyz;
-
-    // read gyro data
-    bmi160_read_gyro_xyz(&gyroxyz);
-
-    // read accel data
-    bmi160_read_accel_xyz(&accelxyz);
-
-    // read mag data
-    if (dev->magEnabled)
-        bmi160_bmm150_mag_compensate_xyz(&magxyz);
-
-    // read the sensor time
-    u32 v_sensor_time;
-    bmi160_get_sensor_time(&v_sensor_time);
-    dev->sensorTime = (unsigned int)v_sensor_time;
-
-    dev->accelX = (float)accelxyz.x;
-    dev->accelY = (float)accelxyz.y;
-    dev->accelZ = (float)accelxyz.z;
-
-    dev->gyroX = (float)gyroxyz.x;
-    dev->gyroY = (float)gyroxyz.y;
-    dev->gyroZ = (float)gyroxyz.z;
-
-    if (dev->magEnabled)
-    {
-        dev->magX = (float)magxyz.x;
-        dev->magY = (float)magxyz.y;
-        dev->magZ = (float)magxyz.z;
-    }
-}
-
-void bmi160_set_accelerometer_scale(const bmi160_context dev,
-                                    BMI160_ACC_RANGE_T scale)
-{
-    assert(dev != NULL);
-
-    s8 v_range = BMI160_ACCEL_RANGE_2G;
-    // store scaling factor
-
-    switch (scale)
-    {
-    case BMI160_ACC_RANGE_2G:
-        v_range = BMI160_ACCEL_RANGE_2G;
-        dev->accelScale = 16384.0;
-        break;
-
-    case BMI160_ACC_RANGE_4G:
-        v_range = BMI160_ACCEL_RANGE_4G;
-        dev->accelScale = 8192.0;
-        break;
-
-    case BMI160_ACC_RANGE_8G:
-        v_range = BMI160_ACCEL_RANGE_8G;
-        dev->accelScale = 4096.0;
-        break;
-
-    case BMI160_ACC_RANGE_16G:
-        v_range = BMI160_ACCEL_RANGE_16G;
-        dev->accelScale = 2048.0;
-        break;
-
-    default: // should never occur, but...
-        dev->accelScale = 1.0;        // set a safe, though incorrect value
-        printf("%s: internal error, unsupported scale.\n", __FUNCTION__);
-        break;
-    }
-
-    bmi160_set_accel_range(v_range);
-
-    return;
-}
-
-void bmi160_set_gyroscope_scale(const bmi160_context dev,
-                                BMI160_GYRO_RANGE_T scale)
-{
-    assert(dev != NULL);
-
-    u8 v_range = BMI160_GYRO_RANGE_2000_DEG_SEC;
-
-    // store scaling factor
-
-    switch (scale)
-    {
-    case BMI160_GYRO_RANGE_125:
-        v_range = BMI160_GYRO_RANGE_125_DEG_SEC;
-        dev->gyroScale = 262.4;
-        break;
-
-    case BMI160_GYRO_RANGE_250:
-        v_range = BMI160_GYRO_RANGE_250_DEG_SEC;
-        dev->gyroScale = 131.2;
-        break;
-
-    case BMI160_GYRO_RANGE_500:
-        v_range = BMI160_GYRO_RANGE_500_DEG_SEC;
-        dev->gyroScale = 65.6;
-        break;
-
-    case BMI160_GYRO_RANGE_1000:
-        v_range = BMI160_GYRO_RANGE_1000_DEG_SEC;
-        dev->gyroScale = 32.8;
-        break;
-
-    case BMI160_GYRO_RANGE_2000:
-        v_range = BMI160_GYRO_RANGE_2000_DEG_SEC;
-        dev->gyroScale = 16.4;
-        break;
-
-    default: // should never occur, but...
-        dev->gyroScale = 1.0;        // set a safe, though incorrect value
-        printf("%s: internal error, unsupported scale.\n", __FUNCTION__);
-        break;
-    }
-
-    bmi160_set_gyro_range(v_range);
-
-    return;
-}
-
-void bmi160_get_accelerometer(const bmi160_context dev, float *x, float *y,
-                              float *z)
-{
-    assert(dev != NULL);
-
-    if (x)
-        *x = dev->accelX / dev->accelScale;
-
-    if (y)
-        *y = dev->accelY / dev->accelScale;
-
-    if (z)
-        *z = dev->accelZ / dev->accelScale;
-}
-
-void bmi160_get_gyroscope(const bmi160_context dev, float *x, float *y,
-                          float *z)
-{
-    assert(dev != NULL);
-
-    if (x)
-        *x = dev->gyroX / dev->gyroScale;
-
-    if (y)
-        *y = dev->gyroY / dev->gyroScale;
-
-    if (z)
-        *z = dev->gyroZ / dev->gyroScale;
-}
-
-void bmi160_get_magnetometer(const bmi160_context dev, float *x, float *y,
-                             float *z)
-{
-    assert(dev != NULL);
-
-    if (x)
-        *x = dev->magX;
-
-    if (y)
-        *y = dev->magY;
-
-    if (z)
-        *z = dev->magZ;
-}
-
-#if 0
-float *bmi160_get_ccelerometer()
-{
-    float *values = new float[3]; // x, y, and then z
-
-    getAccelerometer(&values[0], &values[1], &values[2]);
-
-    return values;
-}
-
-float *bmi160_getGyroscope()
-{
-    float *values = new float[3]; // x, y, and then z
-
-    getGyroscope(&values[0], &values[1], &values[2]);
-
-    return values;
-}
-
-float *bmi160_getMagnetometer()
-{
-    float *values = new float[3]; // x, y, and then z
-
-    getMagnetometer(&values[0], &values[1], &values[2]);
-
-    return values;
-}
-#endif
-
-void bmi160_enable_magnetometer(const bmi160_context dev, bool enable)
-{
-    assert(dev != NULL);
-
-    // butchered from support example
-    if (!enable)
-    {
-        bmi160_set_bmm150_mag_and_secondary_if_power_mode(MAG_SUSPEND_MODE);
-        bmi160_delay_ms(BMI160_GEN_READ_WRITE_DELAY);
-        bmi160_set_if_mode(0x00);
-        bmi160_delay_ms(BMI160_GEN_READ_WRITE_DELAY);
-
-        dev->magEnabled = false;
-        dev->magX = 0;
-        dev->magY = 0;
-        dev->magZ = 0;
-    }
-    else
-    {
-        u8 v_bmm_chip_id_u8 = BMI160_INIT_VALUE;
-        /* Init the magnetometer */
-        bmi160_bmm150_mag_interface_init(&v_bmm_chip_id_u8);
-
-        /* bmi160_delay_ms in ms*/
-        bmi160_delay_ms(BMI160_GEN_READ_WRITE_DELAY);
-
-        dev->magEnabled = true;
-    }
-}
-
-unsigned int bmi160_get_time(const bmi160_context dev)
-{
-    assert(dev != NULL);
-
-    return dev->sensorTime;
-}
diff --git a/src/bmi160/bmi160.cxx b/src/bmi160/bmi160.cxx
deleted file mode 100644
index 79426e8..0000000
--- a/src/bmi160/bmi160.cxx
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <iostream>
-#include <stdexcept>
-#include <string>
-
-#include "bmi160.hpp"
-
-using namespace upm;
-using namespace std;
-
-BMI160::BMI160(int bus, int address, int csPin, bool enableMag) :
-    m_bmi160(bmi160_init(bus, address, csPin, enableMag))
-{
-    if (!m_bmi160)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmi160_init() failed");
-}
-
-BMI160::~BMI160()
-{
-    bmi160_close(m_bmi160);
-}
-
-void BMI160::update()
-{
-    bmi160_update(m_bmi160);
-}
-
-void BMI160::setAccelerometerScale(BMI160_ACC_RANGE_T scale)
-{
-    bmi160_set_accelerometer_scale(m_bmi160, scale);
-}
-
-void BMI160::setGyroscopeScale(BMI160_GYRO_RANGE_T scale)
-{
-    bmi160_set_gyroscope_scale(m_bmi160, scale);
-}
-
-void BMI160::getAccelerometer(float *x, float *y, float *z)
-{
-    bmi160_get_accelerometer(m_bmi160, x, y, z);
-}
-
-void BMI160::getGyroscope(float *x, float *y, float *z)
-{
-    bmi160_get_gyroscope(m_bmi160, x, y, z);
-}
-
-void BMI160::getMagnetometer(float *x, float *y, float *z)
-{
-    bmi160_get_magnetometer(m_bmi160, x, y, z);
-}
-
-float *BMI160::getAccelerometer()
-{
-  static float values[3]; // x, y, and then z
-
-  getAccelerometer(&values[0], &values[1], &values[2]);
-
-  return values;
-}
-
-float *BMI160::getGyroscope()
-{
-  static float values[3]; // x, y, and then z
-
-  getGyroscope(&values[0], &values[1], &values[2]);
-
-  return values;
-}
-
-float *BMI160::getMagnetometer()
-{
-  static float values[3]; // x, y, and then z
-
-  getMagnetometer(&values[0], &values[1], &values[2]);
-
-  return values;
-}
-
-void BMI160::enableMagnetometer(bool enable)
-{
-    bmi160_enable_magnetometer(m_bmi160, enable);
-}
-
-unsigned int BMI160::getSensorTime()
-{
-    return bmi160_get_time(m_bmi160);
-}
-
-string BMI160::busRead(int addr, int reg, int len)
-{
-    u8 dev_addr = (u8)(addr & 0xff);
-    u8 reg_addr = (u8)(reg & 0xff);
-    u8 cnt = (u8)(len & 0xff);
-
-    u8 *data = new u8[cnt];
-
-    if (bmi160_bus_read(dev_addr, reg_addr, data, cnt))
-    {
-        delete [] data;
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmi160_bus_read() failed");
-    }
-
-    string dataStr((char *)data, cnt);
-    delete [] data;
-
-    return dataStr;
-}
-
-void BMI160::busWrite(int addr, int reg, string data)
-{
-    u8 dev_addr = (u8)(addr & 0xff);
-    u8 reg_addr = (u8)(reg & 0xff);
-
-    if (bmi160_bus_write(dev_addr, reg_addr, (u8 *)data.data(), data.size()))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmi160_bus_write() failed");
-}
diff --git a/src/bmi160/bmi160.h b/src/bmi160/bmi160.h
deleted file mode 100644
index 1a929a4..0000000
--- a/src/bmi160/bmi160.h
+++ /dev/null
@@ -1,234 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <stdint.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <upm.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include "bosch_bmi160.h"
-#include "bmi160_defs.h"
-
-  /**
-   * @brief BMI160 3-axis Accelerometer, Gyroscope and (optionally) a
-   * Magnetometer
-   *
-   * The Bosch BMI160 is a 3-axis Accelerometer and Gyroscope.
-   * Additionally it supports an external Magnetometer, accessed
-   * through the BMI160's register interface.  This driver was
-   * developed with a BMI160 "Shuttle" board, which included a BMM150
-   * Magnetometer.
-   *
-   * The device is driven by either 1.8v or 3.3vdc.  This driver
-   * incorporates the Bosch BMI160 driver code at
-   * https://github.com/BoschSensortec/BMI160_driver
-   *
-   * The Bosch driver code does not provide a mechanism for passing
-   * user data around (like the device context).  For this reason,
-   * only one instance of this driver can be used in a given process,
-   * due to the use of static data in the driver.
-   *
-   * While not all of the functionality of this device is supported
-   * initially, the inclusion of the Bosch driver in the source code
-   * makes it possible to support whatever features are required that
-   * the driver can support.
-   *
-   * @snippet bmi160.c Interesting
-   */
-
-    typedef struct _bmi160_context {
-        // uncompensated accelerometer and gyroscope values
-        float accelX;
-        float accelY;
-        float accelZ;
-
-        float gyroX;
-        float gyroY;
-        float gyroZ;
-
-        float magX;
-        float magY;
-        float magZ;
-
-        unsigned int sensorTime;
-
-        // accelerometer and gyro scaling factors, depending on their Full
-        // Scale (Range) settings.
-        float accelScale;
-        float gyroScale;
-
-        // is the magnetometer enabled?
-        bool magEnabled;
-
-    } *bmi160_context;
-
-    /**
-     * bmi160 constructor
-     *
-     * @param bus i2c/spi bus to use
-     * @param address The address for this device if using I2C.  If
-     * using SPI, supply -1 for this parameter.
-     * @param cs_pin The GPIO to use for Chip Select (CS).  This is
-     * only needed for SPI, and only if your SPI implementation
-     * requires it.  Otherwise, just pass -1 if not using SPI, or your
-     * CS is handled automatically by your SPI implementation.
-     * @param enable_mag True, if you want to enable the magnetometer
-     * @return an initialized device context on success, NULL on error.
-     */
-    bmi160_context bmi160_init(unsigned int bus, int address, int cs_pin,
-                               bool enable_mag);
-
-    /**
-     * BMI160 Destructor
-     *
-     * @param dev Device context.
-     */
-    void bmi160_close(bmi160_context dev);
-
-    /**
-     * Take a measurement and store the current sensor values
-     * internally.  This function must be called prior to retrieving
-     * any sensor values, for example getAccelerometer().
-     *
-     * @param dev Device context.
-     * @param dev sensor context
-     */
-    void bmi160_update(const bmi160_context dev);
-
-    /**
-     * set the scaling mode of the accelerometer
-     *
-     * @param dev Device context.
-     * @param scale one of the ACCEL_RANGE_T values
-     */
-    void bmi160_set_accelerometer_scale(const bmi160_context dev,
-                                        BMI160_ACC_RANGE_T scale);
-
-    /**
-     * set the scaling mode of the gyroscope
-     *
-     * @param dev Device context.
-     * @param scale one of the GYRO_RANGE_T values
-     */
-    void bmi160_set_gyroscope_scale(const bmi160_context dev,
-                                    BMI160_GYRO_RANGE_T scale);
-
-    /**
-     * Get the Accelerometer values.  The values returned are in
-     * gravities.  update() must have been called prior to calling
-     * this method.
-     *
-     * @param dev Device context.
-     * @param x A pointer into which the X value will be returned
-     * @param y A pointer into which the Y value will be returned
-     * @param z A pointer into which the Z value will be returned
-     */
-    void bmi160_get_accelerometer(const bmi160_context dev,
-                                  float *x, float *y, float *z);
-
-    /**
-     * Get the Gyroscope values.  The values returned are in degrees
-     * per second.  update() must have been called prior to calling
-     * this method.
-     *
-     * @param dev Device context.
-     * @param x A pointer into which the X value will be returned
-     * @param y A pointer into which the Y value will be returned
-     * @param z A pointer into which the Z value will be returned
-     */
-    void bmi160_get_gyroscope(const bmi160_context dev,
-                              float *x, float *y, float *z);
-
-    /**
-     * Get the Magnetometer values.  The values returned are in micro
-     * Teslas.  update() must have been called prior to calling this
-     * method.
-     *
-     * @param dev Device context.
-     * @param x A pointer into which the X value will be returned
-     * @param y A pointer into which the Y value will be returned
-     * @param z A pointer into which the Z value will be returned
-     */
-    void bmi160_get_magnetometer(const bmi160_context dev,
-                                 float *x, float *y, float *z);
-
-    /**
-     * Enable or disable the Magnetometer.  By default, the
-     * magnetometer is enabled.
-     *
-     * @param dev Device context.
-     * @param enable true to enable the magnetometer, false to disable.
-     */
-    void bmi160_enable_magnetometer(const bmi160_context dev, bool enable);
-
-    /**
-     * Return the sensor time.  This is a 24bit value that increments
-     * every 39us.  It will wrap around once the 24b resolution is
-     * exceeded.
-     *
-     * @param dev Device context.
-     * @return The current sensor time.
-     */
-    unsigned int bmi160_get_time(const bmi160_context dev);
-
-    /**
-     * Perform a bus read.  This function is bus agnostic, and is used
-     * by the bosch code to perform bus reads.  It is exposed here for
-     * those users wishing to perform their own low level accesses.
-     * This is a low level function, and should not be used unless you
-     * know what you are doing.
-     *
-     * @param dev_addr For I2C operation, this is the I2C address.
-     * For SPI, this argument is ignored.
-     * @param reg_addr The register address to access.
-     * @param reg_data A pointer to a buffer in which data will be read into.
-     * @param cnt The number of bytes to read.
-     * @return A return of 0 indicates no errors, non-zero indicates an error.
-     */
-    s8 bmi160_bus_read(u8 dev_addr, u8 reg_addr, u8 *reg_data, u8 cnt);
-
-    /**
-     * Perform a bus write.  This function is bus agnostic, and is used
-     * by the bosch code to perform bus writes.  It is exposed here for
-     * those users wishing to perform their own low level accesses.
-     * This is a low level function, and should not be used unless you
-     * know what you are doing.
-     *
-     * @param dev_addr For I2C operation, this is the I2C address.
-     * For SPI, this argument is ignored.
-     * @param reg_addr The register address to access.
-     * @param reg_data A pointer to a buffer containing data to write.
-     * @param cnt The number of bytes to write.
-     * @return A return of 0 indicates no errors, non-zero indicates an error.
-     */
-    s8 bmi160_bus_write(u8 dev_addr, u8 reg_addr, u8 *reg_data, u8 cnt);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/bmi160/bmi160.hpp b/src/bmi160/bmi160.hpp
deleted file mode 100644
index ad13584..0000000
--- a/src/bmi160/bmi160.hpp
+++ /dev/null
@@ -1,249 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-#include <string>
-#include "bmi160.h"
-
-#define BMI160_I2C_BUS 0
-#define BMI160_DEFAULT_I2C_ADDR 0x69
-
-namespace upm {
-
-    /**
-     * @brief BMI160 Inertial Measurement Unit
-     * @defgroup bmi160 libupm-bmi160
-     * @ingroup i2c accelerometer compass bosch mouser
-     */
-
-
-    /**
-     * @library bmi160
-     * @sensor bmi160
-     * @comname Low-power IMU (triaxial Accelerometer and Triaxial Gyroscope)
-     * and Magnetometer
-     * @type accelerometer compass
-     * @man bosch mouser
-     * @con i2c
-     * @web https://www.bosch-sensortec.com/bst/products/all_products/bmi160
-     *
-     * @brief UPM API for the BMI160 3-axis Accelerometer, Gyroscope and
-     * Magnetometer
-     *
-     * The Bosch BMI160 is a 3-axis Accelerometer and Gyroscope.
-     * Additionally it supports an external Magnetometer, accessed
-     * through the BMI160's register interface.  This driver was
-     * developed with a BMI160 "Shuttle" board, which included a BMM150
-     * Magnetometer.
-     *
-     * The device is driven by either 1.8v or 3.3vdc.  This driver
-     * incorporates the Bosch BMI160 driver code at
-     * https://github.com/BoschSensortec/BMI160_driver
-     *
-     * The Bosch driver code does not provide a mechanism for passing
-     * user data around (like the device context).  For this reason,
-     * only one instance of this driver can be used in a given process,
-     * due to the use of static data in the driver.
-     *
-     * While not all of the functionality of this device is supported
-     * initially, the inclusion of the Bosch driver in the source code
-     * makes it possible to support whatever features are required that
-     * the driver can support.
-     *
-     * @snippet bmi160.cxx Interesting
-     */
-    class BMI160 {
-    public:
-
-        /**
-         * BMI160 constructor.  The default arguments inititialize I2C
-         * operation and the default I2C address.
-         *
-         * @param bus i2c bus to use
-         * @param address The address for this device if using I2C.  If
-         * using SPI, supply -1 for this parameter.
-         * @param csPin The GPIO to use for Chip Select (CS).  This is
-         * only needed for SPI, and only if your SPI implementation
-         * requires it.  Otherwise, just pass -1 if not using SPI, or your
-         * CS is handled automatically by your SPI implementation.
-         * @param enableMag true to enable the magnetometer, false otherwise
-         */
-        BMI160(int bus=BMI160_I2C_BUS, int address=BMI160_DEFAULT_I2C_ADDR,
-               int csPin=-1, bool enableMag=true);
-
-        /**
-         * BMI160 Destructor
-         */
-        ~BMI160();
-
-        /**
-         * Take a measurement and store the current sensor values
-         * internally.  This function must be called prior to retrieving
-         * any sensor values, for example getAccelerometer().
-         *
-         */
-        void update();
-
-        /**
-         * set the scaling mode of the accelerometer
-         *
-         * @param scale one of the ACCEL_RANGE_T values
-         */
-        void setAccelerometerScale(BMI160_ACC_RANGE_T scale);
-
-        /**
-         * set the scaling mode of the gyroscope
-         *
-         * @param scale one of the GYRO_RANGE_T values
-         */
-        void setGyroscopeScale(BMI160_GYRO_RANGE_T scale);
-
-        /**
-         * Get the Accelerometer values.  This function returns a pointer
-         * to 3 floating point values: X, Y, and Z, in that order.  The
-         * values returned are in gravities.  update() must have been
-         * called prior to calling this method.
-         *
-         * The caller is reponsible for freeing the returned pointer.
-         *
-         * @return Pointer to 3 floating point values: X, Y, and Z in
-         * gravities.
-         */
-        float *getAccelerometer();
-
-        /**
-         * Get the Accelerometer values.  The values returned are in
-         * gravities.  update() must have been called prior to calling
-         * this method.
-         *
-         * @param x A pointer into which the X value will be returned
-         * @param y A pointer into which the Y value will be returned
-         * @param z A pointer into which the Z value will be returned
-         */
-        void getAccelerometer(float *x, float *y, float *z);
-
-        /**
-         * Get the Gyroscope values.  This function returns a pointer to 3
-         * floating point values: X, Y, and Z, in that order.  The values
-         * values returned are in degrees per second.  update() must have
-         * been called prior to calling this method.
-         *
-         * The caller is reponsible for freeing the returned pointer.
-         *
-         * @return Pointer to 3 floating point values: X, Y, and Z in
-         * degrees per second.
-         */
-        float *getGyroscope();
-
-        /**
-         * Get the Gyroscope values.  The values returned are in degrees
-         * per second.  update() must have been called prior to calling
-         * this method.
-         *
-         * @param x A pointer into which the X value will be returned
-         * @param y A pointer into which the Y value will be returned
-         * @param z A pointer into which the Z value will be returned
-         */
-        void getGyroscope(float *x, float *y, float *z);
-
-        /**
-         * Get the Magnetometer values.  This function returns a pointer
-         * to 3 floating point values: X, Y, and Z, in that order.  The
-         * values values returned are in micro Teslas.  update() must have
-         * been called prior to calling this method.  If the Magnetometer
-         * has been disabled, the return values will always be 0, 0, and
-         * 0.
-         *
-         * The caller is reponsible for freeing the returned pointer.
-         *
-         * @return Pointer to 3 floating point values: X, Y, and Z in
-         * micro Teslas.
-         */
-        float *getMagnetometer();
-
-        /**
-         * Get the Magnetometer values.  The values returned are in micro
-         * Teslas.  update() must have been called prior to calling this
-         * method.
-         *
-         * @param x A pointer into which the X value will be returned
-         * @param y A pointer into which the Y value will be returned
-         * @param z A pointer into which the Z value will be returned
-         */
-        void getMagnetometer(float *x, float *y, float *z);
-
-        /**
-         * Enable or disable the Magnetometer.  By default, the
-         * magnetometer is enabled.
-         *
-         * @param enable true to enable the magnetometer, false to disable.
-         */
-        void enableMagnetometer(bool enable);
-
-        /**
-         * Return the sensor time.  This is a 24bit value that increments
-         * every 39us.  It will wrap around once the 24b resolution is
-         * exceeded.
-         *
-         * @return The current sensor time.
-         */
-        unsigned int getSensorTime();
-
-    protected:
-        bmi160_context m_bmi160;
-
-        /**
-         * Perform a bus read.  This function is bus agnostic, and is used
-         * by the bosch code to perform bus reads.  It is exposed here for
-         * those users wishing to perform their own low level accesses.
-         * This is a low level function, and should not be used unless you
-         * know what you are doing.
-         *
-         * @param addr For I2C operation, this is the I2C address.
-         * For SPI, this argument is ignored.
-         * @param reg The register address to access.
-         * @param cnt The number of bytes to read.
-         * @return The data read
-         */
-        std::string busRead(int addr, int reg, int len);
-
-        /**
-         * Perform a bus write.  This function is bus agnostic, and is used
-         * by the bosch code to perform bus writes.  It is exposed here for
-         * those users wishing to perform their own low level accesses.
-         * This is a low level function, and should not be used unless you
-         * know what you are doing.
-         *
-         * @param addr For I2C operation, this is the I2C address.
-         * For SPI, this argument is ignored.
-         * @param addr The register address to access.
-         * @param data The string containing the data to write
-         */
-        void busWrite(int addr, int reg, std::string data);
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        BMI160(const BMI160&) = delete;
-        BMI160 &operator=(const BMI160&) = delete;
-    };
-}
diff --git a/src/bmi160/bmi160.i b/src/bmi160/bmi160.i
deleted file mode 100644
index 80f747c..0000000
--- a/src/bmi160/bmi160.i
+++ /dev/null
@@ -1,48 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "arrays_java.i"
-%include "../java_buffer.i"
-
-%typemap(jni) float * "jfloatArray"
-%typemap(jstype) float * "float[]"
-%typemap(jtype) float * "float[]"
-
-%typemap(javaout) float * {
-    return $jnicall;
-}
-
-%typemap(out) float * {
-    $result = JCALL1(NewFloatArray, jenv, 3);
-    JCALL4(SetFloatArrayRegion, jenv, $result, 0, 3, $1);
-}
-
-%ignore getAccelerometer(float *, float *, float *);
-%ignore getGyroscope(float *, float *, float *);
-%ignore getMagnetometer(float *, float *, float *);
-
-JAVA_JNI_LOADLIBRARY(javaupm_bmi160)
-#endif
-/* END Java syntax */
-
-/* BEGIN Javascript syntax  ------------------------------------------------- */
-#ifdef SWIGJAVASCRIPT
-%pointer_functions(float, floatp);
-#endif
-/* END Javascript syntax */
-
-/* BEGIN Python syntax  ----------------------------------------------------- */
-#ifdef SWIGPYTHON
-%pointer_functions(float, floatp);
-#endif
-/* END Python syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "bmi160_defs.h"
-#include "bmi160.hpp"
-%}
-%include "bmi160_defs.h"
-%include "bmi160.hpp"
-/* END Common SWIG syntax */
diff --git a/src/bmi160/bmi160.json b/src/bmi160/bmi160.json
deleted file mode 100644
index 1f698ea..0000000
--- a/src/bmi160/bmi160.json
+++ /dev/null
@@ -1,66 +0,0 @@
-{
-    "Library": "bmi160",
-    "Description": "Bosch Sensortec accelerometer and gyroscope library.",
-    "Sensor Class": {
-        "BMI160": {
-            "Name": "Bosch accelerometer and gyroscope",
-            "Description": "This is the UPM Module for the BMI160 Bosch low power inertial measurement unit. High performance hardware synchronized accelerometer and gyroscope, with very low power consumption. Extended i2c mode with 1 MHz clock frequencies. This sensor is able to handle external sensor data from other Bosch sensors.",
-            "Aliases": ["BMI160"],
-            "Categories": ["accelerometer", "gyroscope", "compass"],
-            "Connections": ["i2c"],
-            "Project Type": ["industrial", "commercial"],
-            "Manufacturers": ["bosch"],
-            "Examples": {
-                "Java": ["BMI160_Example.java"],
-                "Python": ["bmi160.py"],
-                "Node.js": ["bmi160.js"],
-                "C++": ["bmi160.cxx"],
-                "C": ["bmi160.c"]
-            },
-            "Specifications": {
-                "Vdd": {
-                    "unit": "V",
-                    "min": 1.71,
-                    "max": 3.6
-                },
-                "Supply Current Digital": {
-                    "Full operation": {
-                        "unit": "uA",
-                        "typ": "925",
-                        "max": "990"
-                    },
-                    "Suspended mode": {
-                        "unit": "uA",
-                        "typ": "3",
-                        "max": "10"
-                    },
-                    "Significant motion detection": {
-                        "unit": "uA",
-                        "max": "20"
-                    },
-                    "Step detector": {
-                        "unit": "uA",
-                        "max": "20"
-                    }
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Start up time accelerometer": {
-                    "unit": "ms",
-                    "time": 3.2
-                },
-                "Response time gyroscope": {
-                    "unit": "ms",
-                    "time": 55
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.bosch-sensortec.com/bst/products/all_products/bmi160"],
-                "Datasheets": ["https://ae-bst.resource.bosch.com/media/_tech/media/datasheets/BST-BMI160-DS000-07.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/bmi160/bmi160_defs.h b/src/bmi160/bmi160_defs.h
deleted file mode 100644
index fd4277c..0000000
--- a/src/bmi160/bmi160_defs.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define BMI160_CHIP_ID 0xd1
-
-    typedef enum {
-        BMI160_ACC_RANGE_2G                        = 0, // 2 Gravities
-        BMI160_ACC_RANGE_4G,
-        BMI160_ACC_RANGE_8G,
-        BMI160_ACC_RANGE_16G
-    } BMI160_ACC_RANGE_T;
-
-    typedef enum {
-        BMI160_GYRO_RANGE_125                      = 0, // 125 degrees/sec
-        BMI160_GYRO_RANGE_250,
-        BMI160_GYRO_RANGE_500,
-        BMI160_GYRO_RANGE_1000,
-        BMI160_GYRO_RANGE_2000
-    } BMI160_GYRO_RANGE_T;
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/bmi160/bosch_bmi160.c b/src/bmi160/bosch_bmi160.c
deleted file mode 100644
index 6fd8489..0000000
--- a/src/bmi160/bosch_bmi160.c
+++ /dev/null
@@ -1,20468 +0,0 @@
-/*
-****************************************************************************
-* Copyright (C) 2015 Bosch Sensortec GmbH
-*
-* bosch_bmi160.c
-* Date: 2014/10/27
-* Revision: 2.0.6 $
-*
-* Usage: Sensor Driver for BMI160 sensor
-*
-****************************************************************************
-* License:
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*
-*   Redistributions of source code must retain the above copyright
-*   notice, this list of conditions and the following disclaimer.
-*
-*   Redistributions in binary form must reproduce the above copyright
-*   notice, this list of conditions and the following disclaimer in the
-*   documentation and/or other materials provided with the distribution.
-*
-*   Neither the name of the copyright holder nor the names of the
-*   contributors may be used to endorse or promote products derived from
-*   this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
-* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
-* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDER
-* OR CONTRIBUTORS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
-* OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT NOT LIMITED TO,
-* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-* ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
-*
-* The information provided is believed to be accurate and reliable.
-* The copyright holder assumes no responsibility
-* for the consequences of use
-* of such information nor for any infringement of patents or
-* other rights of third parties which may result from its use.
-* No license is granted by implication or otherwise under any patent or
-* patent rights of the copyright holder.
-**************************************************************************/
-/*! file <BMI160 >
-    brief <Sensor driver for BMI160> */
-#include "bosch_bmi160.h"
-/* user defined code to be added here ... */
-struct bmi160_t *p_bmi160;
-/* used for reading the mag trim values for compensation*/
-struct trim_data_t mag_trim;
-/* the following variable used for avoiding the selecting of auto mode
-when it is running in the manual mode of BMM150 mag interface*/
-u8 V_bmm150_maual_auto_condition_u8 = BMI160_INIT_VALUE;
-/* used for reading the AKM compensating data */
-struct bst_akm_sensitivity_data_t akm_asa_data;
-/* FIFO data read for 1024 bytes of data */
-u8 v_fifo_data_u8[FIFO_FRAME] = {BMI160_INIT_VALUE,};
-/* YAMAHA-YAS532*/
-/* value of coeff*/
-static const int yas532_version_ac_coef[] = {YAS532_VERSION_AC_COEF_X,
-YAS532_VERSION_AC_COEF_Y1, YAS532_VERSION_AC_COEF_Y2};
-/* used for reading the yas532 calibration data*/
-struct yas532_t yas532_data;
-/* used for reading the yas537 calibration data*/
-struct yas537_t yas537_data;
-struct bmi160_mag_fifo_data_t mag_data;
-struct bmi160_mag_xyz_s32_t processed_data;
-struct yas532_vector fifo_xyz_data;
-struct yas_vector fifo_vector_xyz;
-
-
-
-/*!
- *	@brief
- *	This function is used for initialize
- *	bus read and bus write functions
- *	assign the chip id and device address
- *	chip id is read in the register 0x00 bit from 0 to 7
- *
- *	@param bmi160 : structure pointer
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *	@note
- *	While changing the parameter of the bmi160_t
- *	consider the following point:
- *	Changing the reference value of the parameter
- *	will changes the local copy or local reference
- *	make sure your changes will not
- *	affect the reference value of the parameter
- *	(Better case don't change the reference value of the parameter)
- *
-*/
-/* JET - renamed from bmi160_init to avoid conflict with UPM code */
-BMI160_RETURN_FUNCTION_TYPE bmi160_init_bus(struct bmi160_t *bmi160)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	u8 v_pmu_data_u8 = BMI160_INIT_VALUE;
-	/* assign bmi160 ptr */
-	p_bmi160 = bmi160;
-	com_rslt =
-	p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-	BMI160_USER_CHIP_ID__REG,
-	&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	/* read Chip Id */
-	p_bmi160->chip_id = v_data_u8;
-	/* To avoid gyro wakeup it is required to write 0x00 to 0x6C*/
-	com_rslt += bmi160_write_reg(BMI160_USER_PMU_TRIGGER_ADDR,
-	&v_pmu_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	return com_rslt;
-}
-/*!
- * @brief
- *	This API write the data to
- *	the given register
- *
- *
- *	@param v_addr_u8 -> Address of the register
- *	@param v_data_u8 -> The data from the register
- *	@param v_len_u8 -> no of bytes to read
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_write_reg(u8 v_addr_u8,
-u8 *v_data_u8, u8 v_len_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* write data from register*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->dev_addr,
-			v_addr_u8, v_data_u8, v_len_u8);
-		}
-	return com_rslt;
-}
-/*!
- * @brief
- *	This API reads the data from
- *	the given register
- *
- *
- *	@param v_addr_u8 -> Address of the register
- *	@param v_data_u8 -> The data from the register
- *	@param v_len_u8 -> no of bytes to read
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_reg(u8 v_addr_u8,
-u8 *v_data_u8, u8 v_len_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* Read data from register*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			v_addr_u8, v_data_u8, v_len_u8);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API used to reads the fatal error
- *	from the Register 0x02 bit 0
- *	This flag will be reset only by power-on-reset and soft reset
- *
- *
- *  @param v_fatal_err_u8 : The status of fatal error
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_fatal_err(u8
-*v_fatal_err_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* reading the fatal error status*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_FATAL_ERR__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_fatal_err_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_FATAL_ERR);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API used to read the error code
- *	from register 0x02 bit 1 to 4
- *
- *
- *  @param v_err_code_u8 : The status of error codes
- *	error_code  |    description
- *  ------------|---------------
- *	0x00        |no error
- *	0x01        |ACC_CONF error (accel ODR and bandwidth not compatible)
- *	0x02        |GYR_CONF error (Gyroscope ODR and bandwidth not compatible)
- *	0x03        |Under sampling mode and interrupt uses pre filtered data
- *	0x04        |reserved
- *	0x05        |Selected trigger-readout offset in
- *    -         |MAG_IF greater than selected ODR
- *	0x06        |FIFO configuration error for header less mode
- *	0x07        |Under sampling mode and pre filtered data as FIFO source
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_err_code(u8
-*v_err_code_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_ERR_CODE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_err_code_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_ERR_CODE);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API Reads the i2c error code from the
- *	Register 0x02 bit 5.
- *	This error occurred in I2C master detected
- *
- *  @param v_i2c_err_code_u8 : The status of i2c fail error
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_i2c_fail_err(u8
-*v_i2c_err_code_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_I2C_FAIL_ERR__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_i2c_err_code_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_I2C_FAIL_ERR);
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API Reads the dropped command error
- *	from the register 0x02 bit 6
- *
- *
- *  @param v_drop_cmd_err_u8 : The status of drop command error
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_drop_cmd_err(u8
-*v_drop_cmd_err_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_DROP_CMD_ERR__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_drop_cmd_err_u8 = BMI160_GET_BITSLICE(
-			v_data_u8,
-			BMI160_USER_DROP_CMD_ERR);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the magnetometer data ready
- *	interrupt not active.
- *	It reads from the error register 0x0x2 bit 7
- *
- *
- *
- *
- *  @param v_mag_data_rdy_err_u8 : The status of mag data ready interrupt
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_dada_rdy_err(
-u8 *v_mag_data_rdy_err_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_MAG_DADA_RDY_ERR__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_mag_data_rdy_err_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_MAG_DADA_RDY_ERR);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the error status
- *	from the error register 0x02 bit 0 to 7
- *
- *  @param v_mag_data_rdy_err_u8 : The status of mag data ready interrupt
- *  @param v_fatal_er_u8r : The status of fatal error
- *  @param v_err_code_u8 : The status of error code
- *  @param v_i2c_fail_err_u8 : The status of I2C fail error
- *  @param v_drop_cmd_err_u8 : The status of drop command error
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_error_status(u8 *v_fatal_er_u8r,
-u8 *v_err_code_u8, u8 *v_i2c_fail_err_u8,
-u8 *v_drop_cmd_err_u8, u8 *v_mag_data_rdy_err_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the error codes*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_ERR_STAT__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			/* fatal error*/
-			*v_fatal_er_u8r =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_FATAL_ERR);
-			/* user error*/
-			*v_err_code_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_ERR_CODE);
-			/* i2c fail error*/
-			*v_i2c_fail_err_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_I2C_FAIL_ERR);
-			/* drop command error*/
-			*v_drop_cmd_err_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_DROP_CMD_ERR);
-			/* mag data ready error*/
-			*v_mag_data_rdy_err_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_MAG_DADA_RDY_ERR);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the magnetometer power mode from
- *	PMU status register 0x03 bit 0 and 1
- *
- *  @param v_mag_power_mode_stat_u8 : The value of mag power mode
- *	mag_powermode    |   value
- * ------------------|----------
- *    SUSPEND        |   0x00
- *    NORMAL         |   0x01
- *   LOW POWER       |   0x02
- *
- *
- * @note The power mode of mag set by the 0x7E command register
- * @note using the function "bmi160_set_command_register()"
- *  value    |   mode
- *  ---------|----------------
- *   0x18    | MAG_MODE_SUSPEND
- *   0x19    | MAG_MODE_NORMAL
- *   0x1A    | MAG_MODE_LOWPOWER
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_power_mode_stat(u8
-*v_mag_power_mode_stat_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_MAG_POWER_MODE_STAT__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_mag_power_mode_stat_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_MAG_POWER_MODE_STAT);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the gyroscope power mode from
- *	PMU status register 0x03 bit 2 and 3
- *
- *  @param v_gyro_power_mode_stat_u8 :	The value of gyro power mode
- *	gyro_powermode   |   value
- * ------------------|----------
- *    SUSPEND        |   0x00
- *    NORMAL         |   0x01
- *   FAST POWER UP   |   0x03
- *
- * @note The power mode of gyro set by the 0x7E command register
- * @note using the function "bmi160_set_command_register()"
- *  value    |   mode
- *  ---------|----------------
- *   0x14    | GYRO_MODE_SUSPEND
- *   0x15    | GYRO_MODE_NORMAL
- *   0x17    | GYRO_MODE_FASTSTARTUP
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_power_mode_stat(u8
-*v_gyro_power_mode_stat_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_GYRO_POWER_MODE_STAT__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_gyro_power_mode_stat_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_GYRO_POWER_MODE_STAT);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the accelerometer power mode from
- *	PMU status register 0x03 bit 4 and 5
- *
- *
- *  @param v_accel_power_mode_stat_u8 :	The value of accel power mode
- *	accel_powermode  |   value
- * ------------------|----------
- *    SUSPEND        |   0x00
- *    NORMAL         |   0x01
- *  LOW POWER        |   0x02
- *
- * @note The power mode of accel set by the 0x7E command register
- * @note using the function "bmi160_set_command_register()"
- *  value    |   mode
- *  ---------|----------------
- *   0x11    | ACCEL_MODE_NORMAL
- *   0x12    | ACCEL_LOWPOWER
- *   0x10    | ACCEL_SUSPEND
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_power_mode_stat(u8
-*v_accel_power_mode_stat_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_ACCEL_POWER_MODE_STAT__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_accel_power_mode_stat_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_ACCEL_POWER_MODE_STAT);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API switch mag interface to normal mode
- *	and confirm whether the mode switching done successfully or not
-*
- *	@return results of bus communication function and current MAG_PMU result
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_interface_normal(void)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = BMI160_INIT_VALUE;
-	/* aim to check the result of switching mag normal */
-	u8 v_try_times_u8 = BMI160_MAG_NOAMRL_SWITCH_TIMES;
-	u8 v_mag_pum_status_u8 = BMI160_INIT_VALUE;
-
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	com_rslt = bmi160_set_command_register(MAG_MODE_NORMAL);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	while (v_try_times_u8) {
-		com_rslt = bmi160_get_mag_power_mode_stat(&v_mag_pum_status_u8);
-		if (v_mag_pum_status_u8 == MAG_INTERFACE_PMU_ENABLE)
-			break;
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		v_try_times_u8--;
-	}
-	if (v_mag_pum_status_u8 == MAG_INTERFACE_PMU_ENABLE)
-		com_rslt += SUCCESS;
-	else
-		com_rslt += E_BMI160_COMM_RES;
-
-	return com_rslt;
-}
-/*!
- *	@brief This API reads magnetometer data X values
- *	from the register 0x04 and 0x05
- *	@brief The mag sensor data read form auxiliary mag
- *
- *  @param v_mag_x_s16 : The value of mag x
- *  @param v_sensor_select_u8 : Mag selection value
- *  value    |   sensor
- *  ---------|----------------
- *   0       | BMM150
- *   1       | AKM09911 or AKM09912
- *
- *	@note For mag data output rate configuration use the following function
- *	@note bmi160_set_mag_output_data_rate()
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_mag_x(s16 *v_mag_x_s16,
-u8 v_sensor_select_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* Array contains the mag X lSB and MSB data
-		v_data_u8[0] - LSB
-		v_data_u8[1] - MSB*/
-	u8 v_data_u8[BMI160_MAG_X_DATA_SIZE] = {BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE};
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		switch (v_sensor_select_u8) {
-		case BST_BMM:
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_DATA_MAG_X_LSB__REG,
-			v_data_u8, BMI160_MAG_X_DATA_LENGTH);
-			/* X axis*/
-			v_data_u8[BMI160_MAG_X_LSB_BYTE] =
-			BMI160_GET_BITSLICE(v_data_u8[BMI160_MAG_X_LSB_BYTE],
-			BMI160_USER_DATA_MAG_X_LSB);
-			*v_mag_x_s16 = (s16)
-			((((s32)((s8)v_data_u8[BMI160_MAG_X_MSB_BYTE]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_05_BITS) |
-			(v_data_u8[BMI160_MAG_X_LSB_BYTE]));
-		break;
-		case BST_AKM:
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_DATA_0_MAG_X_LSB__REG,
-			v_data_u8, BMI160_MAG_X_DATA_LENGTH);
-			*v_mag_x_s16 = (s16)
-			((((s32)((s8)v_data_u8[BMI160_MAG_X_MSB_BYTE]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS) |
-			(v_data_u8[BMI160_MAG_X_LSB_BYTE]));
-		break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-		break;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads magnetometer data Y values
- *	from the register 0x06 and 0x07
- *	@brief The mag sensor data read form auxiliary mag
- *
- *  @param v_mag_y_s16 : The value of mag y
- *  @param v_sensor_select_u8 : Mag selection value
- *  value    |   sensor
- *  ---------|----------------
- *   0       | BMM150
- *   1       | AKM09911 or AKM09912
- *
- *	@note For mag data output rate configuration use the following function
- *	@note bmi160_set_mag_output_data_rate()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_mag_y(s16 *v_mag_y_s16,
-u8 v_sensor_select_u8)
-{
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_OUT_OF_RANGE;
-	/* Array contains the mag Y lSB and MSB data
-		v_data_u8[0] - LSB
-		v_data_u8[1] - MSB*/
-	u8 v_data_u8[BMI160_MAG_Y_DATA_SIZE] = {BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE};
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		switch (v_sensor_select_u8) {
-		case BST_BMM:
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_DATA_MAG_Y_LSB__REG,
-			v_data_u8, BMI160_MAG_Y_DATA_LENGTH);
-			/*Y-axis lsb value shifting*/
-			v_data_u8[BMI160_MAG_Y_LSB_BYTE] =
-			BMI160_GET_BITSLICE(v_data_u8[BMI160_MAG_Y_LSB_BYTE],
-			BMI160_USER_DATA_MAG_Y_LSB);
-			*v_mag_y_s16 = (s16)
-			((((s32)((s8)v_data_u8[BMI160_MAG_Y_MSB_BYTE]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_05_BITS) |
-			(v_data_u8[BMI160_MAG_Y_LSB_BYTE]));
-		break;
-		case BST_AKM:
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_DATA_2_MAG_Y_LSB__REG,
-			v_data_u8, BMI160_MAG_Y_DATA_LENGTH);
-			*v_mag_y_s16 = (s16)
-			((((s32)((s8)v_data_u8[BMI160_MAG_Y_MSB_BYTE]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS) |
-			(v_data_u8[BMI160_MAG_Y_LSB_BYTE]));
-		break;
-		default:
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		break;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads magnetometer data Z values
- *	from the register 0x08 and 0x09
- *	@brief The mag sensor data read form auxiliary mag
- *
- *  @param v_mag_z_s16 : The value of mag z
- *  @param v_sensor_select_u8 : Mag selection value
- *  value    |   sensor
- *  ---------|----------------
- *   0       | BMM150
- *   1       | AKM09911 or AKM09912
- *
- *	@note For mag data output rate configuration use the following function
- *	@note bmi160_set_mag_output_data_rate()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_mag_z(s16 *v_mag_z_s16,
-u8 v_sensor_select_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* Array contains the mag Z lSB and MSB data
-		v_data_u8[0] - LSB
-		v_data_u8[1] - MSB*/
-	u8 v_data_u8[BMI160_MAG_Z_DATA_SIZE] = {BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE};
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		switch (v_sensor_select_u8) {
-		case BST_BMM:
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_DATA_MAG_Z_LSB__REG,
-			v_data_u8, BMI160_MAG_Z_DATA_LENGTH);
-			/*Z-axis lsb value shifting*/
-			v_data_u8[BMI160_MAG_Z_LSB_BYTE] =
-			BMI160_GET_BITSLICE(v_data_u8[BMI160_MAG_Z_LSB_BYTE],
-			BMI160_USER_DATA_MAG_Z_LSB);
-			*v_mag_z_s16 = (s16)
-			((((s32)((s8)v_data_u8[BMI160_MAG_Z_MSB_BYTE]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_07_BITS) |
-			(v_data_u8[BMI160_MAG_Z_LSB_BYTE]));
-		break;
-		case BST_AKM:
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_DATA_4_MAG_Z_LSB__REG,
-			v_data_u8, BMI160_MAG_Z_DATA_LENGTH);
-			*v_mag_z_s16 = (s16)
-			((((s32)((s8)v_data_u8[BMI160_MAG_Z_MSB_BYTE]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS) | (
-			v_data_u8[BMI160_MAG_Z_LSB_BYTE]));
-		break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-		break;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads magnetometer data RHALL values
- *	from the register 0x0A and 0x0B
- *
- *
- *  @param v_mag_r_s16 : The value of BMM150 r data
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_mag_r(s16 *v_mag_r_s16)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* Array contains the mag R lSB and MSB data
-		v_data_u8[0] - LSB
-		v_data_u8[1] - MSB*/
-	u8 v_data_u8[BMI160_MAG_R_DATA_SIZE] = {BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE};
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_DATA_6_RHALL_LSB__REG,
-			v_data_u8, BMI160_MAG_R_DATA_LENGTH);
-			/*R-axis lsb value shifting*/
-			v_data_u8[BMI160_MAG_R_LSB_BYTE] =
-			BMI160_GET_BITSLICE(v_data_u8[BMI160_MAG_R_LSB_BYTE],
-			BMI160_USER_DATA_MAG_R_LSB);
-			*v_mag_r_s16 = (s16)
-			((((s32)((s8)v_data_u8[BMI160_MAG_R_MSB_BYTE]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_06_BITS) |
-			(v_data_u8[BMI160_MAG_R_LSB_BYTE]));
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads magnetometer data X,Y,Z values
- *	from the register 0x04 to 0x09
- *
- *	@brief The mag sensor data read form auxiliary mag
- *
- *  @param mag : The value of mag xyz data
- *  @param v_sensor_select_u8 : Mag selection value
- *  value    |   sensor
- *  ---------|----------------
- *   0       | BMM150
- *   1       | AKM09911 or AKM09912
- *
- *	@note For mag data output rate configuration use the following function
- *	@note bmi160_set_mag_output_data_rate()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_mag_xyz(
-struct bmi160_mag_t *mag, u8 v_sensor_select_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* Array contains the mag XYZ lSB and MSB data
-		v_data_u8[0] - X-LSB
-		v_data_u8[1] - X-MSB
-		v_data_u8[0] - Y-LSB
-		v_data_u8[1] - Y-MSB
-		v_data_u8[0] - Z-LSB
-		v_data_u8[1] - Z-MSB
-		*/
-	u8 v_data_u8[BMI160_MAG_XYZ_DATA_SIZE] = {
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE};
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		switch (v_sensor_select_u8) {
-		case BST_BMM:
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_DATA_MAG_X_LSB__REG,
-			v_data_u8, BMI160_MAG_XYZ_DATA_LENGTH);
-			/*X-axis lsb value shifting*/
-			v_data_u8[BMI160_DATA_FRAME_MAG_X_LSB_BYTE] =
-			BMI160_GET_BITSLICE(
-			v_data_u8[BMI160_DATA_FRAME_MAG_X_LSB_BYTE],
-			BMI160_USER_DATA_MAG_X_LSB);
-			/* Data X */
-			mag->x = (s16)
-			((((s32)((s8)v_data_u8[
-			BMI160_DATA_FRAME_MAG_X_MSB_BYTE]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_05_BITS) |
-			(v_data_u8[BMI160_DATA_FRAME_MAG_X_LSB_BYTE]));
-			/* Data Y */
-			/*Y-axis lsb value shifting*/
-			v_data_u8[BMI160_DATA_FRAME_MAG_Y_LSB_BYTE] =
-			BMI160_GET_BITSLICE(
-			v_data_u8[BMI160_DATA_FRAME_MAG_Y_LSB_BYTE],
-			BMI160_USER_DATA_MAG_Y_LSB);
-			mag->y = (s16)
-			((((s32)((s8)v_data_u8[
-			BMI160_DATA_FRAME_MAG_Y_MSB_BYTE]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_05_BITS) |
-			(v_data_u8[BMI160_DATA_FRAME_MAG_Y_LSB_BYTE]));
-
-			/* Data Z */
-			/*Z-axis lsb value shifting*/
-			v_data_u8[BMI160_DATA_FRAME_MAG_Z_LSB_BYTE]
-			= BMI160_GET_BITSLICE(
-			v_data_u8[BMI160_DATA_FRAME_MAG_Z_LSB_BYTE],
-			BMI160_USER_DATA_MAG_Z_LSB);
-			mag->z = (s16)
-			((((s32)((s8)v_data_u8[
-			BMI160_DATA_FRAME_MAG_Z_MSB_BYTE]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_07_BITS) |
-			(v_data_u8[BMI160_DATA_FRAME_MAG_Z_LSB_BYTE]));
-		break;
-		case BST_AKM:
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_DATA_0_MAG_X_LSB__REG,
-			v_data_u8, BMI160_MAG_XYZ_DATA_LENGTH);
-			/* Data X */
-			mag->x = (s16)
-			((((s32)((s8)v_data_u8[
-			BMI160_DATA_FRAME_MAG_X_MSB_BYTE]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS) |
-			(v_data_u8[BMI160_DATA_FRAME_MAG_X_LSB_BYTE]));
-			/* Data Y */
-			mag->y  = ((((s32)((s8)v_data_u8[
-			BMI160_DATA_FRAME_MAG_Y_MSB_BYTE]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS) |
-			(v_data_u8[BMI160_DATA_FRAME_MAG_Y_LSB_BYTE]));
-			/* Data Z */
-			mag->z = (s16)
-			((((s32)((s8)v_data_u8[
-			BMI160_DATA_FRAME_MAG_Z_MSB_BYTE]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS) |
-			(v_data_u8[BMI160_DATA_FRAME_MAG_Z_LSB_BYTE]));
-		break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-		break;
-		}
-	}
-	return com_rslt;
-}
- /*!*
- *	@brief This API reads magnetometer data X,Y,Z,r
- *	values from the register 0x04 to 0x0B
- *
- *	@brief The mag sensor data read form auxiliary mag
- *
- *  @param mag : The value of mag-BMM150 xyzr data
- *
- *	@note For mag data output rate configuration use the following function
- *	@note bmi160_set_mag_output_data_rate()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_mag_xyzr(
-struct bmi160_mag_xyzr_t *mag)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8[BMI160_MAG_XYZR_DATA_SIZE] = {
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE};
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_DATA_MAG_X_LSB__REG,
-			v_data_u8, BMI160_MAG_XYZR_DATA_LENGTH);
-
-			/* Data X */
-			/*X-axis lsb value shifting*/
-			v_data_u8[BMI160_DATA_FRAME_MAG_X_LSB_BYTE]
-			= BMI160_GET_BITSLICE(
-			v_data_u8[BMI160_DATA_FRAME_MAG_X_LSB_BYTE],
-			BMI160_USER_DATA_MAG_X_LSB);
-			mag->x = (s16)
-			((((s32)((s8)v_data_u8[
-			BMI160_DATA_FRAME_MAG_X_MSB_BYTE]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_05_BITS)
-			| (v_data_u8[BMI160_DATA_FRAME_MAG_X_LSB_BYTE]));
-			/* Data Y */
-			/*Y-axis lsb value shifting*/
-			v_data_u8[BMI160_DATA_FRAME_MAG_Y_LSB_BYTE]
-			= BMI160_GET_BITSLICE(
-			v_data_u8[BMI160_DATA_FRAME_MAG_Y_LSB_BYTE],
-			BMI160_USER_DATA_MAG_Y_LSB);
-			mag->y = (s16)
-			((((s32)((s8)v_data_u8[
-			BMI160_DATA_FRAME_MAG_Y_MSB_BYTE]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_05_BITS)
-			| (v_data_u8[
-			BMI160_DATA_FRAME_MAG_Y_LSB_BYTE]));
-
-			/* Data Z */
-			/*Z-axis lsb value shifting*/
-			v_data_u8[BMI160_DATA_FRAME_MAG_Z_LSB_BYTE]
-			= BMI160_GET_BITSLICE(
-			v_data_u8[BMI160_DATA_FRAME_MAG_Z_LSB_BYTE],
-			BMI160_USER_DATA_MAG_Z_LSB);
-			mag->z = (s16)
-			((((s32)((s8)v_data_u8[
-			BMI160_DATA_FRAME_MAG_Z_MSB_BYTE]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_07_BITS)
-			| (v_data_u8[BMI160_DATA_FRAME_MAG_Z_LSB_BYTE]));
-
-			/* RHall */
-			/*R-axis lsb value shifting*/
-			v_data_u8[BMI160_DATA_FRAME_MAG_R_LSB_BYTE]
-			= BMI160_GET_BITSLICE(
-			v_data_u8[BMI160_DATA_FRAME_MAG_R_LSB_BYTE],
-			BMI160_USER_DATA_MAG_R_LSB);
-			mag->r = (s16)
-			((((s32)((s8)v_data_u8[
-			BMI160_DATA_FRAME_MAG_R_MSB_BYTE]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_06_BITS)
-			| (v_data_u8[BMI160_DATA_FRAME_MAG_R_LSB_BYTE]));
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads gyro data X values
- *	form the register 0x0C and 0x0D
- *
- *
- *
- *
- *  @param v_gyro_x_s16 : The value of gyro x data
- *
- *	@note Gyro Configuration use the following function
- *	@note bmi160_set_gyro_output_data_rate()
- *	@note bmi160_set_gyro_bw()
- *	@note bmi160_set_gyro_range()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_gyro_x(s16 *v_gyro_x_s16)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* Array contains the gyro X lSB and MSB data
-		v_data_u8[0] - LSB
-		v_data_u8[MSB_ONE] - MSB*/
-	u8 v_data_u8[BMI160_GYRO_X_DATA_SIZE] = {BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE};
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_DATA_8_GYRO_X_LSB__REG,
-			v_data_u8, BMI160_GYRO_DATA_LENGTH);
-
-			*v_gyro_x_s16 = (s16)
-			((((s32)((s8)v_data_u8[BMI160_GYRO_X_MSB_BYTE]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			| (v_data_u8[BMI160_GYRO_X_LSB_BYTE]));
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads gyro data Y values
- *	form the register 0x0E and 0x0F
- *
- *
- *
- *
- *  @param v_gyro_y_s16 : The value of gyro y data
- *
- *	@note Gyro Configuration use the following function
- *	@note bmi160_set_gyro_output_data_rate()
- *	@note bmi160_set_gyro_bw()
- *	@note bmi160_set_gyro_range()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error result of communication routines
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_gyro_y(s16 *v_gyro_y_s16)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* Array contains the gyro Y lSB and MSB data
-		v_data_u8[LSB_ZERO] - LSB
-		v_data_u8[MSB_ONE] - MSB*/
-	u8 v_data_u8[BMI160_GYRO_Y_DATA_SIZE] = {BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE};
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read gyro y data*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_DATA_10_GYRO_Y_LSB__REG,
-			v_data_u8, BMI160_GYRO_DATA_LENGTH);
-
-			*v_gyro_y_s16 = (s16)
-			((((s32)((s8)v_data_u8[BMI160_GYRO_Y_MSB_BYTE]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			| (v_data_u8[BMI160_GYRO_Y_LSB_BYTE]));
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads gyro data Z values
- *	form the register 0x10 and 0x11
- *
- *
- *
- *
- *  @param v_gyro_z_s16 : The value of gyro z data
- *
- *	@note Gyro Configuration use the following function
- *	@note bmi160_set_gyro_output_data_rate()
- *	@note bmi160_set_gyro_bw()
- *	@note bmi160_set_gyro_range()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_gyro_z(s16 *v_gyro_z_s16)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* Array contains the gyro Z lSB and MSB data
-		v_data_u8[LSB_ZERO] - LSB
-		v_data_u8[MSB_ONE] - MSB*/
-	u8 v_data_u8[BMI160_GYRO_Z_DATA_SIZE] = {BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE};
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read gyro z data */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_DATA_12_GYRO_Z_LSB__REG,
-			v_data_u8, BMI160_GYRO_DATA_LENGTH);
-
-			*v_gyro_z_s16 = (s16)
-			((((s32)((s8)v_data_u8[BMI160_GYRO_Z_MSB_BYTE]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			| (v_data_u8[BMI160_GYRO_Z_LSB_BYTE]));
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads gyro data X,Y,Z values
- *	from the register 0x0C to 0x11
- *
- *
- *
- *
- *  @param gyro : The value of gyro xyz
- *
- *	@note Gyro Configuration use the following function
- *	@note bmi160_set_gyro_output_data_rate()
- *	@note bmi160_set_gyro_bw()
- *	@note bmi160_set_gyro_range()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_gyro_xyz(struct bmi160_gyro_t *gyro)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* Array contains the mag XYZ lSB and MSB data
-		v_data_u8[0] - X-LSB
-		v_data_u8[1] - X-MSB
-		v_data_u8[0] - Y-LSB
-		v_data_u8[1] - Y-MSB
-		v_data_u8[0] - Z-LSB
-		v_data_u8[1] - Z-MSB
-		*/
-	u8 v_data_u8[BMI160_GYRO_XYZ_DATA_SIZE] = {
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE};
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the gyro xyz data*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_DATA_8_GYRO_X_LSB__REG,
-			v_data_u8, BMI160_GYRO_XYZ_DATA_LENGTH);
-
-			/* Data X */
-			gyro->x = (s16)
-			((((s32)((s8)v_data_u8[
-			BMI160_DATA_FRAME_GYRO_X_MSB_BYTE]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			| (v_data_u8[BMI160_DATA_FRAME_GYRO_X_LSB_BYTE]));
-			/* Data Y */
-			gyro->y = (s16)
-			((((s32)((s8)v_data_u8[
-			BMI160_DATA_FRAME_GYRO_Y_MSB_BYTE]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			| (v_data_u8[BMI160_DATA_FRAME_GYRO_Y_LSB_BYTE]));
-
-			/* Data Z */
-			gyro->z = (s16)
-			((((s32)((s8)v_data_u8[
-			BMI160_DATA_FRAME_GYRO_Z_MSB_BYTE]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			| (v_data_u8[BMI160_DATA_FRAME_GYRO_Z_LSB_BYTE]));
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads accelerometer data X values
- *	form the register 0x12 and 0x13
- *
- *
- *
- *
- *  @param v_accel_x_s16 : The value of accel x
- *
- *	@note For accel configuration use the following functions
- *	@note bmi160_set_accel_output_data_rate()
- *	@note bmi160_set_accel_bw()
- *	@note bmi160_set_accel_under_sampling_parameter()
- *	@note bmi160_set_accel_range()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_accel_x(s16 *v_accel_x_s16)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* Array contains the accel X lSB and MSB data
-		v_data_u8[0] - LSB
-		v_data_u8[1] - MSB*/
-	u8 v_data_u8[BMI160_ACCEL_X_DATA_SIZE] = {BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE};
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_DATA_14_ACCEL_X_LSB__REG,
-			v_data_u8, BMI160_ACCEL_DATA_LENGTH);
-
-			*v_accel_x_s16 = (s16)
-			((((s32)((s8)v_data_u8[BMI160_ACCEL_X_MSB_BYTE]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			| (v_data_u8[BMI160_ACCEL_X_LSB_BYTE]));
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads accelerometer data Y values
- *	form the register 0x14 and 0x15
- *
- *
- *
- *
- *  @param v_accel_y_s16 : The value of accel y
- *
- *	@note For accel configuration use the following functions
- *	@note bmi160_set_accel_output_data_rate()
- *	@note bmi160_set_accel_bw()
- *	@note bmi160_set_accel_under_sampling_parameter()
- *	@note bmi160_set_accel_range()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_accel_y(s16 *v_accel_y_s16)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* Array contains the accel Y lSB and MSB data
-		v_data_u8[0] - LSB
-		v_data_u8[1] - MSB*/
-	u8 v_data_u8[BMI160_ACCEL_Y_DATA_SIZE] = {BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE};
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_DATA_16_ACCEL_Y_LSB__REG,
-			v_data_u8, BMI160_ACCEL_DATA_LENGTH);
-
-			*v_accel_y_s16 = (s16)
-			((((s32)((s8)v_data_u8[BMI160_ACCEL_Y_MSB_BYTE]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			| (v_data_u8[BMI160_ACCEL_Y_LSB_BYTE]));
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads accelerometer data Z values
- *	form the register 0x16 and 0x17
- *
- *
- *
- *
- *  @param v_accel_z_s16 : The value of accel z
- *
- *	@note For accel configuration use the following functions
- *	@note bmi160_set_accel_output_data_rate()
- *	@note bmi160_set_accel_bw()
- *	@note bmi160_set_accel_under_sampling_parameter()
- *	@note bmi160_set_accel_range()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_accel_z(s16 *v_accel_z_s16)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* Array contains the accel Z lSB and MSB data
-		a_data_u8r[LSB_ZERO] - LSB
-		a_data_u8r[MSB_ONE] - MSB*/
-	u8 a_data_u8r[BMI160_ACCEL_Z_DATA_SIZE] = {
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE};
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_DATA_18_ACCEL_Z_LSB__REG,
-			a_data_u8r, BMI160_ACCEL_DATA_LENGTH);
-
-			*v_accel_z_s16 = (s16)
-			((((s32)((s8)a_data_u8r[BMI160_ACCEL_Z_MSB_BYTE]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			| (a_data_u8r[BMI160_ACCEL_Z_LSB_BYTE]));
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads accelerometer data X,Y,Z values
- *	from the register 0x12 to 0x17
- *
- *
- *
- *
- *  @param accel :The value of accel xyz
- *
- *	@note For accel configuration use the following functions
- *	@note bmi160_set_accel_output_data_rate()
- *	@note bmi160_set_accel_bw()
- *	@note bmi160_set_accel_under_sampling_parameter()
- *	@note bmi160_set_accel_range()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_accel_xyz(
-struct bmi160_accel_t *accel)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* Array contains the accel XYZ lSB and MSB data
-	a_data_u8r[0] - X-LSB
-	a_data_u8r[1] - X-MSB
-	a_data_u8r[0] - Y-LSB
-	a_data_u8r[1] - Y-MSB
-	a_data_u8r[0] - Z-LSB
-	a_data_u8r[1] - Z-MSB
-	*/
-	u8 a_data_u8r[BMI160_ACCEL_XYZ_DATA_SIZE] = {
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE};
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_DATA_14_ACCEL_X_LSB__REG,
-			a_data_u8r, BMI160_ACCEL_XYZ_DATA_LENGTH);
-
-			/* Data X */
-			accel->x = (s16)
-			((((s32)((s8)a_data_u8r[
-			BMI160_DATA_FRAME_ACCEL_X_MSB_BYTE]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			| (a_data_u8r[BMI160_DATA_FRAME_ACCEL_X_LSB_BYTE]));
-			/* Data Y */
-			accel->y = (s16)
-			((((s32)((s8)a_data_u8r[
-			BMI160_DATA_FRAME_ACCEL_Y_MSB_BYTE]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			| (a_data_u8r[BMI160_DATA_FRAME_ACCEL_Y_LSB_BYTE]));
-
-			/* Data Z */
-			accel->z = (s16)
-			((((s32)((s8)a_data_u8r[
-			BMI160_DATA_FRAME_ACCEL_Z_MSB_BYTE]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			| (a_data_u8r[BMI160_DATA_FRAME_ACCEL_Z_LSB_BYTE]));
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads sensor_time from the register
- *	0x18 to 0x1A
- *
- *
- *  @param v_sensor_time_u32 : The value of sensor time
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_sensor_time(u32 *v_sensor_time_u32)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* Array contains the sensor time it is 32 bit data
-	a_data_u8r[0] - sensor time
-	a_data_u8r[1] - sensor time
-	a_data_u8r[0] - sensor time
-	*/
-	u8 a_data_u8r[BMI160_SENSOR_TIME_DATA_SIZE] = {BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE};
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_SENSORTIME_0_SENSOR_TIME_LSB__REG,
-			a_data_u8r, BMI160_SENSOR_TIME_LENGTH);
-
-			*v_sensor_time_u32 = (u32)
-			((((u32)a_data_u8r[BMI160_SENSOR_TIME_MSB_BYTE])
-			<< BMI160_SHIFT_BIT_POSITION_BY_16_BITS)
-			|(((u32)a_data_u8r[BMI160_SENSOR_TIME_XLSB_BYTE])
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			| (a_data_u8r[BMI160_SENSOR_TIME_LSB_BYTE]));
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the Gyroscope self test
- *	status from the register 0x1B bit 1
- *
- *
- *  @param v_gyro_selftest_u8 : The value of gyro self test status
- *  value    |   status
- *  ---------|----------------
- *   0       | Gyroscope self test is running or failed
- *   1       | Gyroscope self test completed successfully
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_selftest(u8
-*v_gyro_selftest_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_STAT_GYRO_SELFTEST_OK__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_gyro_selftest_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_STAT_GYRO_SELFTEST_OK);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the status of
- *	mag manual interface operation form the register 0x1B bit 2
- *
- *
- *
- *  @param v_mag_manual_stat_u8 : The value of mag manual operation status
- *  value    |   status
- *  ---------|----------------
- *   0       | Indicates no manual magnetometer
- *   -       | interface operation is ongoing
- *   1       | Indicates manual magnetometer
- *   -       | interface operation is ongoing
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_manual_operation_stat(u8
-*v_mag_manual_stat_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read manual operation*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_STAT_MAG_MANUAL_OPERATION__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_mag_manual_stat_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_STAT_MAG_MANUAL_OPERATION);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the fast offset compensation
- *	status form the register 0x1B bit 3
- *
- *
- *  @param v_foc_rdy_u8 : The status of fast compensation
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_foc_rdy(u8
-*v_foc_rdy_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the FOC status*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_STAT_FOC_RDY__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_foc_rdy_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_STAT_FOC_RDY);
-		}
-	return com_rslt;
-}
-/*!
- * @brief This API Reads the nvm_rdy status from the
- *	resister 0x1B bit 4
- *
- *
- *  @param v_nvm_rdy_u8 : The value of NVM ready status
- *  value    |   status
- *  ---------|----------------
- *   0       | NVM write operation in progress
- *   1       | NVM is ready to accept a new write trigger
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_nvm_rdy(u8
-*v_nvm_rdy_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the nvm ready status*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_STAT_NVM_RDY__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_nvm_rdy_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_STAT_NVM_RDY);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the status of mag data ready
- *	from the register 0x1B bit 5
- *	The status get reset when one mag data register is read out
- *
- *  @param v_data_rdy_u8 : The value of mag data ready status
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_data_rdy_mag(u8
-*v_data_rdy_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_STAT_DATA_RDY_MAG__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_data_rdy_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_STAT_DATA_RDY_MAG);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the status of gyro data ready form the
- *	register 0x1B bit 6
- *	The status get reset when gyro data register read out
- *
- *
- *	@param v_data_rdy_u8 :	The value of gyro data ready
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_data_rdy(u8
-*v_data_rdy_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_STAT_DATA_RDY_GYRO__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_data_rdy_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_STAT_DATA_RDY_GYRO);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the status of accel data ready form the
- *	register 0x1B bit 7
- *	The status get reset when accel data register read out
- *
- *
- *	@param v_data_rdy_u8 :	The value of accel data ready status
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_data_rdy(u8
-*v_data_rdy_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/*reads the status of accel data ready*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_STAT_DATA_RDY_ACCEL__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_data_rdy_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_STAT_DATA_RDY_ACCEL);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the step detector interrupt status
- *	from the register 0x1C bit 0
- *	flag is associated with a specific interrupt function.
- *	It is set when the single tab interrupt triggers. The
- *	setting of INT_LATCH controls if the interrupt
- *	signal and hence the
- *	respective interrupt flag will be
- *	permanently latched, temporarily latched
- *	or not latched.
- *
- *
- *
- *
- *  @param v_step_intr_u8 : The status of step detector interrupt
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_step_intr(u8
-*v_step_intr_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_INTR_STAT_0_STEP_INTR__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_step_intr_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_STAT_0_STEP_INTR);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the
- *	significant motion interrupt status
- *	from the register 0x1C bit 1
- *	flag is associated with a specific interrupt function.
- *	It is set when the single tab interrupt triggers. The
- *	setting of INT_LATCH controls if the interrupt
- *	signal and hence the
- *	respective interrupt flag will be
- *	permanently latched, temporarily latched
- *	or not latched.
- *
- *
- *
- *
- *
- *  @param v_significant_intr_u8 : The status of step
- *	motion interrupt
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_significant_intr(u8
-*v_significant_intr_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_INTR_STAT_0_SIGNIFICANT_INTR__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_significant_intr_u8  = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_STAT_0_SIGNIFICANT_INTR);
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API reads the any motion interrupt status
- *	from the register 0x1C bit 2
- *	flag is associated with a specific interrupt function.
- *	It is set when the single tab interrupt triggers. The
- *	setting of INT_LATCH controls if the interrupt
- *	signal and hence the
- *	respective interrupt flag will be
- *	permanently latched, temporarily latched
- *	or not latched.
- *
- *
- *
- *  @param v_any_motion_intr_u8 : The status of any-motion interrupt
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_any_motion_intr(u8
-*v_any_motion_intr_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_INTR_STAT_0_ANY_MOTION__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_any_motion_intr_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_STAT_0_ANY_MOTION);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the power mode trigger interrupt status
- *	from the register 0x1C bit 3
- *	flag is associated with a specific interrupt function.
- *	It is set when the single tab interrupt triggers. The
- *	setting of INT_LATCH controls if the interrupt
- *	signal and hence the
- *	respective interrupt flag will be
- *	permanently latched, temporarily latched
- *	or not latched.
- *
- *
- *
- *
- *
- *  @param v_pmu_trigger_intr_u8 : The status of power mode trigger interrupt
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_pmu_trigger_intr(u8
-*v_pmu_trigger_intr_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_INTR_STAT_0_PMU_TRIGGER__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_pmu_trigger_intr_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_STAT_0_PMU_TRIGGER);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the double tab status
- *	from the register 0x1C bit 4
- *	flag is associated with a specific interrupt function.
- *	It is set when the single tab interrupt triggers. The
- *	setting of INT_LATCH controls if the interrupt
- *	signal and hence the
- *	respective interrupt flag will be
- *	permanently latched, temporarily latched
- *	or not latched.
- *
- *
- *
- *
- *  @param v_double_tap_intr_u8 :The status of double tab interrupt
- *
- *	@note Double tap interrupt can be configured by the following functions
- *	@note INTERRUPT MAPPING
- *	@note bmi160_set_intr_double_tap()
- *	@note AXIS MAPPING
- *	@note bmi160_get_stat2_tap_first_x()
- *	@note bmi160_get_stat2_tap_first_y()
- *	@note bmi160_get_stat2_tap_first_z()
- *	@note DURATION
- *	@note bmi160_set_intr_tap_durn()
- *	@note THRESHOLD
- *	@note bmi160_set_intr_tap_thres()
- *	@note TAP QUIET
- *	@note bmi160_set_intr_tap_quiet()
- *	@note TAP SHOCK
- *	@note bmi160_set_intr_tap_shock()
- *	@note TAP SOURCE
- *	@note bmi160_set_intr_tap_source()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_double_tap_intr(u8
-*v_double_tap_intr_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_INTR_STAT_0_DOUBLE_TAP_INTR__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_double_tap_intr_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_STAT_0_DOUBLE_TAP_INTR);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the single tab status
- *	from the register 0x1C bit 5
- *	flag is associated with a specific interrupt function.
- *	It is set when the single tab interrupt triggers. The
- *	setting of INT_LATCH controls if the interrupt
- *	signal and hence the
- *	respective interrupt flag will be
- *	permanently latched, temporarily latched
- *	or not latched.
- *
- *
- *
- *
- *  @param v_single_tap_intr_u8 :The status of single tap interrupt
- *
- *	@note Single tap interrupt can be configured by the following functions
- *	@note INTERRUPT MAPPING
- *	@note bmi160_set_intr_single_tap()
- *	@note AXIS MAPPING
- *	@note bmi160_get_stat2_tap_first_x()
- *	@note bmi160_get_stat2_tap_first_y()
- *	@note bmi160_get_stat2_tap_first_z()
- *	@note DURATION
- *	@note bmi160_set_intr_tap_durn()
- *	@note THRESHOLD
- *	@note bmi160_set_intr_tap_thres()
- *	@note TAP QUIET
- *	@note bmi160_set_intr_tap_quiet()
- *	@note TAP SHOCK
- *	@note bmi160_set_intr_tap_shock()
- *	@note TAP SOURCE
- *	@note bmi160_set_intr_tap_source()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_single_tap_intr(u8
-*v_single_tap_intr_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_INTR_STAT_0_SINGLE_TAP_INTR__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_single_tap_intr_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_STAT_0_SINGLE_TAP_INTR);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the orient status
- *	from the register 0x1C bit 6
- *	flag is associated with a specific interrupt function.
- *	It is set when the orient interrupt triggers. The
- *	setting of INT_LATCH controls if the
- *	interrupt signal and hence the
- *	respective interrupt flag will be
- *	permanently latched, temporarily latched
- *	or not latched.
- *
- *
- *
- *
- *  @param v_orient_intr_u8 : The status of orient interrupt
- *
- *	@note For orient interrupt configuration use the following functions
- *	@note STATUS
- *	@note bmi160_get_stat0_orient_intr()
- *	@note AXIS MAPPING
- *	@note bmi160_get_stat3_orient_xy()
- *	@note bmi160_get_stat3_orient_z()
- *	@note bmi160_set_intr_orient_axes_enable()
- *	@note INTERRUPT MAPPING
- *	@note bmi160_set_intr_orient()
- *	@note INTERRUPT OUTPUT
- *	@note bmi160_set_intr_orient_ud_enable()
- *	@note THETA
- *	@note bmi160_set_intr_orient_theta()
- *	@note HYSTERESIS
- *	@note bmi160_set_intr_orient_hyst()
- *	@note BLOCKING
- *	@note bmi160_set_intr_orient_blocking()
- *	@note MODE
- *	@note bmi160_set_intr_orient_mode()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_orient_intr(u8
-*v_orient_intr_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_INTR_STAT_0_ORIENT__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_orient_intr_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_STAT_0_ORIENT);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the flat interrupt status
- *	from the register 0x1C bit 7
- *	flag is associated with a specific interrupt function.
- *	It is set when the flat interrupt triggers. The
- *	setting of INT_LATCH controls if the
- *	interrupt signal and hence the
- *	respective interrupt flag will be
- *	permanently latched, temporarily latched
- *	or not latched.
- *
- *
- *
- *
- *  @param v_flat_intr_u8 : The status of  flat interrupt
- *
- *	@note For flat configuration use the following functions
- *	@note STATS
- *	@note bmi160_get_stat0_flat_intr()
- *	@note bmi160_get_stat3_flat()
- *	@note INTERRUPT MAPPING
- *	@note bmi160_set_intr_flat()
- *	@note THETA
- *	@note bmi160_set_intr_flat_theta()
- *	@note HOLD TIME
- *	@note bmi160_set_intr_flat_hold()
- *	@note HYSTERESIS
- *	@note bmi160_set_intr_flat_hyst()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_flat_intr(u8
-*v_flat_intr_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_INTR_STAT_0_FLAT__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_flat_intr_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_STAT_0_FLAT);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the high_g interrupt status
- *	from the register 0x1D bit 2
- *	flag is associated with a specific interrupt function.
- *	It is set when the high g  interrupt triggers. The
- *	setting of INT_LATCH controls if the interrupt signal and hence the
- *	respective interrupt flag will be permanently
- *	latched, temporarily latched
- *	or not latched.
- *
- *
- *
- *
- *  @param v_high_g_intr_u8 : The status of high_g interrupt
- *
- *	@note High_g interrupt configured by following functions
- *	@note STATUS
- *	@note bmi160_get_stat1_high_g_intr()
- *	@note AXIS MAPPING
- *	@note bmi160_get_stat3_high_g_first_x()
- *	@note bmi160_get_stat3_high_g_first_y()
- *	@note bmi160_get_stat3_high_g_first_z()
- *	@note SIGN MAPPING
- *	@note bmi160_get_stat3_high_g_first_sign()
- *	@note INTERRUPT MAPPING
- *	@note bmi160_set_intr_high_g()
-  *	@note HYSTERESIS
- *	@note bmi160_set_intr_high_g_hyst()
- *	@note DURATION
- *	@note bmi160_set_intr_high_g_durn()
- *	@note THRESHOLD
- *	@note bmi160_set_intr_high_g_thres()
- *	@note SOURCE
- *	@note bmi160_set_intr_low_high_source()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat1_high_g_intr(u8
-*v_high_g_intr_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_INTR_STAT_1_HIGH_G_INTR__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_high_g_intr_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_STAT_1_HIGH_G_INTR);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the low g interrupt status
- *	from the register 0x1D bit 3
- *	flag is associated with a specific interrupt function.
- *	It is set when the low g  interrupt triggers. The
- *	setting of INT_LATCH controls if the interrupt signal and hence the
- *	respective interrupt flag will be
- *	permanently latched, temporarily latched
- *	or not latched.
- *
- *
- *
- *
- *  @param v_low_g_intr_u8 : The status of low_g interrupt
- *
- *	@note Low_g interrupt configured by following functions
- *	@note STATUS
- *	@note bmi160_get_stat1_low_g_intr()
- *	@note INTERRUPT MAPPING
- *	@note bmi160_set_intr_low_g()
- *	@note SOURCE
- *	@note bmi160_set_intr_low_high_source()
- *	@note DURATION
- *	@note bmi160_set_intr_low_g_durn()
- *	@note THRESHOLD
- *	@note bmi160_set_intr_low_g_thres()
- *	@note HYSTERESIS
- *	@note bmi160_set_intr_low_g_hyst()
- *	@note MODE
- *	@note bmi160_set_intr_low_g_mode()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat1_low_g_intr(u8
-*v_low_g_intr_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_INTR_STAT_1_LOW_G_INTR__REG, &v_data_u8,
-			 BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_low_g_intr_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_STAT_1_LOW_G_INTR);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads data ready interrupt status
- *	from the register 0x1D bit 4
- *	flag is associated with a specific interrupt function.
- *	It is set when the  data ready  interrupt triggers. The
- *	setting of INT_LATCH controls if the interrupt signal and hence the
- *	respective interrupt flag will be
- *	permanently latched, temporarily latched
- *	or not latched.
- *
- *
- *
- *
- *  @param v_data_rdy_intr_u8 : The status of data ready interrupt
- *
- *	@note Data ready interrupt configured by following functions
- *	@note STATUS
- *	@note bmi160_get_stat1_data_rdy_intr()
- *	@note INTERRUPT MAPPING
- *	@note bmi160_set_intr_data_rdy()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat1_data_rdy_intr(u8
-*v_data_rdy_intr_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_INTR_STAT_1_DATA_RDY_INTR__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_data_rdy_intr_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_STAT_1_DATA_RDY_INTR);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads data ready FIFO full interrupt status
- *	from the register 0x1D bit 5
- *	flag is associated with a specific interrupt function.
- *	It is set when the FIFO full interrupt triggers. The
- *	setting of INT_LATCH controls if the
- *	interrupt signal and hence the
- *	respective interrupt flag will
- *	be permanently latched, temporarily latched
- *	or not latched.
- *
- *
- *
- *
- *  @param v_fifo_full_intr_u8 : The status of fifo full interrupt
- *
- *	@note FIFO full interrupt can be configured by following functions
- *	@note bmi160_set_intr_fifo_full()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat1_fifo_full_intr(u8
-*v_fifo_full_intr_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_INTR_STAT_1_FIFO_FULL_INTR__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_fifo_full_intr_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_STAT_1_FIFO_FULL_INTR);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads data
- *	 ready FIFO watermark interrupt status
- *	from the register 0x1D bit 6
- *	flag is associated with a specific interrupt function.
- *	It is set when the FIFO watermark interrupt triggers. The
- *	setting of INT_LATCH controls if the
- *	interrupt signal and hence the
- *	respective interrupt flag will be
- *	permanently latched, temporarily latched
- *	or not latched.
- *
- *
- *
- *
- *  @param v_fifo_wm_intr_u8 : The status of fifo water mark interrupt
- *
- *	@note FIFO full interrupt can be configured by following functions
- *	@note bmi160_set_intr_fifo_wm()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat1_fifo_wm_intr(u8
-*v_fifo_wm_intr_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_INTR_STAT_1_FIFO_WM_INTR__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_fifo_wm_intr_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_STAT_1_FIFO_WM_INTR);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads data ready no motion interrupt status
- *	from the register 0x1D bit 7
- *	flag is associated with a specific interrupt function.
- *	It is set when the no motion  interrupt triggers. The
- *	setting of INT_LATCH controls if the interrupt signal and hence the
- *	respective interrupt flag will be permanently
- *	latched, temporarily latched
- *	or not latched.
- *
- *
- *
- *
- *  @param v_nomotion_intr_u8 : The status of no motion interrupt
- *
- *	@note No motion interrupt can be configured by following function
- *	@note STATUS
- *	@note bmi160_get_stat1_nomotion_intr()
- *	@note INTERRUPT MAPPING
- *	@note bmi160_set_intr_nomotion()
- *	@note DURATION
- *	@note bmi160_set_intr_slow_no_motion_durn()
- *	@note THRESHOLD
- *	@note bmi160_set_intr_slow_no_motion_thres()
- *	@note SLOW/NO MOTION SELECT
- *	@note bmi160_set_intr_slow_no_motion_select()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat1_nomotion_intr(u8
-*v_nomotion_intr_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the no motion interrupt*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_INTR_STAT_1_NOMOTION_INTR__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_nomotion_intr_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_STAT_1_NOMOTION_INTR);
-		}
-	return com_rslt;
-}
-/*!
- *@brief This API reads the status of any motion first x
- *	from the register 0x1E bit 0
- *
- *
- *@param v_anymotion_first_x_u8 : The status of any motion first x interrupt
- *  value     |  status
- * -----------|-------------
- *   0        | not triggered
- *   1        | triggered by x axis
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_any_motion_first_x(u8
-*v_anymotion_first_x_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the any motion first x interrupt*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_X__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_anymotion_first_x_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_X);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the status of any motion first y interrupt
- *	from the register 0x1E bit 1
- *
- *
- *
- *@param v_any_motion_first_y_u8 : The status of any motion first y interrupt
- *  value     |  status
- * -----------|-------------
- *   0        | not triggered
- *   1        | triggered by y axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_any_motion_first_y(u8
-*v_any_motion_first_y_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the any motion first y interrupt*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_Y__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_any_motion_first_y_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_Y);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the status of any motion first z interrupt
- *	from the register 0x1E bit 2
- *
- *
- *
- *
- *@param v_any_motion_first_z_u8 : The status of any motion first z interrupt
- *  value     |  status
- * -----------|-------------
- *   0        | not triggered
- *   1        | triggered by y axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_any_motion_first_z(u8
-*v_any_motion_first_z_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the any motion first z interrupt*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_Z__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_any_motion_first_z_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_Z);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the any motion sign status from the
- *	register 0x1E bit 3
- *
- *
- *
- *
- *  @param v_anymotion_sign_u8 : The status of any motion sign
- *  value     |  sign
- * -----------|-------------
- *   0        | positive
- *   1        | negative
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_any_motion_sign(u8
-*v_anymotion_sign_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read any motion sign interrupt status */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_INTR_STAT_2_ANY_MOTION_SIGN__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_anymotion_sign_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_STAT_2_ANY_MOTION_SIGN);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the any motion tap first x status from the
- *	register 0x1E bit 4
- *
- *
- *
- *
- *  @param v_tap_first_x_u8 :The status of any motion tap first x
- *  value     |  status
- * -----------|-------------
- *   0        | not triggered
- *   1        | triggered by x axis
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_tap_first_x(u8
-*v_tap_first_x_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read tap first x interrupt status */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_INTR_STAT_2_TAP_FIRST_X__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_tap_first_x_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_STAT_2_TAP_FIRST_X);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the tap first y interrupt status from the
- *	register 0x1E bit 5
- *
- *
- *
- *
- *  @param v_tap_first_y_u8 :The status of tap first y interrupt
- *  value     |  status
- * -----------|-------------
- *   0        | not triggered
- *   1        | triggered by y axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_tap_first_y(u8
-*v_tap_first_y_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read tap first y interrupt status */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_INTR_STAT_2_TAP_FIRST_Y__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_tap_first_y_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_STAT_2_TAP_FIRST_Y);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the tap first z interrupt status  from the
- *	register 0x1E bit 6
- *
- *
- *
- *
- *  @param v_tap_first_z_u8 :The status of tap first z interrupt
- *  value     |  status
- * -----------|-------------
- *   0        | not triggered
- *   1        | triggered by z axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_tap_first_z(u8
-*v_tap_first_z_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read tap first z interrupt status */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_INTR_STAT_2_TAP_FIRST_Z__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_tap_first_z_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_STAT_2_TAP_FIRST_Z);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the tap sign status from the
- *	register 0x1E bit 7
- *
- *
- *
- *
- *  @param v_tap_sign_u8 : The status of tap sign
- *  value     |  sign
- * -----------|-------------
- *   0        | positive
- *   1        | negative
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_tap_sign(u8
-*v_tap_sign_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read tap_sign interrupt status */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_INTR_STAT_2_TAP_SIGN__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_tap_sign_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_STAT_2_TAP_SIGN);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the high_g first x status from the
- *	register 0x1F bit 0
- *
- *
- *
- *
- *  @param v_high_g_first_x_u8 :The status of high_g first x
- *  value     |  status
- * -----------|-------------
- *   0        | not triggered
- *   1        | triggered by x axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat3_high_g_first_x(u8
-*v_high_g_first_x_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read highg_x interrupt status */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_X__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_high_g_first_x_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_X);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the high_g first y status from the
- *	register 0x1F bit 1
- *
- *
- *
- *
- *  @param v_high_g_first_y_u8 : The status of high_g first y
- *  value     |  status
- * -----------|-------------
- *   0        | not triggered
- *   1        | triggered by y axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat3_high_g_first_y(u8
-*v_high_g_first_y_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read highg_y interrupt status */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_Y__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_high_g_first_y_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_Y);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the high_g first z status from the
- *	register 0x1F bit 3
- *
- *
- *
- *
- *  @param v_high_g_first_z_u8 : The status of high_g first z
- *  value     |  status
- * -----------|-------------
- *   0        | not triggered
- *   1        | triggered by z axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat3_high_g_first_z(u8
-*v_high_g_first_z_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read highg_z interrupt status */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_Z__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_high_g_first_z_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_Z);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the high sign status from the
- *	register 0x1F bit 3
- *
- *
- *
- *
- *  @param v_high_g_sign_u8 :The status of high sign
- *  value     |  sign
- * -----------|-------------
- *   0        | positive
- *   1        | negative
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat3_high_g_sign(u8
-*v_high_g_sign_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read highg_sign interrupt status */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_INTR_STAT_3_HIGH_G_SIGN__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_high_g_sign_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_STAT_3_HIGH_G_SIGN);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the status of orient_xy plane
- *	from the register 0x1F bit 4 and 5
- *
- *
- *  @param v_orient_xy_u8 :The status of orient_xy plane
- *  value     |  status
- * -----------|-------------
- *   0x00     | portrait upright
- *   0x01     | portrait upside down
- *   0x02     | landscape left
- *   0x03     | landscape right
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat3_orient_xy(u8
-*v_orient_xy_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read orient plane xy interrupt status */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_INTR_STAT_3_ORIENT_XY__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_orient_xy_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_STAT_3_ORIENT_XY);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the status of orient z plane
- *	from the register 0x1F bit 6
- *
- *
- *  @param v_orient_z_u8 :The status of orient z
- *  value     |  status
- * -----------|-------------
- *   0x00     | upward looking
- *   0x01     | downward looking
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat3_orient_z(u8
-*v_orient_z_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read orient z plane interrupt status */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_INTR_STAT_3_ORIENT_Z__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_orient_z_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_STAT_3_ORIENT_Z);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the flat status from the register
- *	0x1F bit 7
- *
- *
- *  @param v_flat_u8 : The status of flat interrupt
- *  value     |  status
- * -----------|-------------
- *   0x00     | non flat
- *   0x01     | flat position
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat3_flat(u8
-*v_flat_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read flat interrupt status */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_INTR_STAT_3_FLAT__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_flat_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_STAT_3_FLAT);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the temperature of the sensor
- *	from the register 0x21 bit 0 to 7
- *
- *
- *
- *  @param v_temp_s16 : The value of temperature
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_temp(s16
-*v_temp_s16)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* Array contains the temperature lSB and MSB data
-	v_data_u8[0] - LSB
-	v_data_u8[1] - MSB*/
-	u8 v_data_u8[BMI160_TEMP_DATA_SIZE] = {BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE};
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read temperature data */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_TEMP_LSB_VALUE__REG, v_data_u8,
-			BMI160_TEMP_DATA_LENGTH);
-			*v_temp_s16 =
-			(s16)(((s32)((s8) (v_data_u8[BMI160_TEMP_MSB_BYTE]) <<
-			BMI160_SHIFT_BIT_POSITION_BY_08_BITS))
-			| v_data_u8[BMI160_TEMP_LSB_BYTE]);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the  of the sensor
- *	form the register 0x23 and 0x24 bit 0 to 7 and 0 to 2
- *	@brief this byte counter is updated each time a complete frame
- *	was read or writtern
- *
- *
- *  @param v_fifo_length_u32 : The value of fifo byte counter
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_fifo_length(u32 *v_fifo_length_u32)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* Array contains the fifo length data
-	v_data_u8[0] - fifo length
-	v_data_u8[1] - fifo length*/
-	u8 a_data_u8r[BMI160_FIFO_DATA_SIZE] = {BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE};
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read fifo length*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_FIFO_BYTE_COUNTER_LSB__REG, a_data_u8r,
-			 BMI160_FIFO_DATA_LENGTH);
-
-			a_data_u8r[BMI160_FIFO_LENGTH_MSB_BYTE] =
-			BMI160_GET_BITSLICE(
-			a_data_u8r[BMI160_FIFO_LENGTH_MSB_BYTE],
-			BMI160_USER_FIFO_BYTE_COUNTER_MSB);
-
-			*v_fifo_length_u32 =
-			(u32)(((u32)((u8) (
-			a_data_u8r[BMI160_FIFO_LENGTH_MSB_BYTE]) <<
-			BMI160_SHIFT_BIT_POSITION_BY_08_BITS))
-			| a_data_u8r[BMI160_FIFO_LENGTH_LSB_BYTE]);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the fifo data of the sensor
- *	from the register 0x24
- *	@brief Data format depends on the setting of register FIFO_CONFIG
- *
- *
- *
- *  @param v_fifodata_u8 : Pointer holding the fifo data
- *  @param fifo_length_u16 : The value of fifo length maximum
- *	1024
- *
- *	@note For reading FIFO data use the following functions
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_fifo_data(
-u8 *v_fifodata_u8, u16 v_fifo_length_u16)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read fifo data*/
-			com_rslt =
-			p_bmi160->BMI160_BURST_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_FIFO_DATA__REG,
-			v_fifodata_u8, v_fifo_length_u16);
-
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to get the
- *	accel output date rate form the register 0x40 bit 0 to 3
- *
- *
- *  @param  v_output_data_rate_u8 :The value of accel output date rate
- *  value |  output data rate
- * -------|--------------------------
- *	 0    |	BMI160_ACCEL_OUTPUT_DATA_RATE_RESERVED
- *	 1	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_0_78HZ
- *	 2	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_1_56HZ
- *	 3    |	BMI160_ACCEL_OUTPUT_DATA_RATE_3_12HZ
- *	 4    | BMI160_ACCEL_OUTPUT_DATA_RATE_6_25HZ
- *	 5	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_12_5HZ
- *	 6	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_25HZ
- *	 7	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_50HZ
- *	 8	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_100HZ
- *	 9	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_200HZ
- *	 10	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_400HZ
- *	 11	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_800HZ
- *	 12	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_1600HZ
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_output_data_rate(
-u8 *v_output_data_rate_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the accel output data rate*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_ACCEL_CONFIG_OUTPUT_DATA_RATE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_output_data_rate_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_ACCEL_CONFIG_OUTPUT_DATA_RATE);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to set the
- *	accel output date rate form the register 0x40 bit 0 to 3
- *
- *
- *  @param  v_output_data_rate_u8 :The value of accel output date rate
- *  value |  output data rate
- * -------|--------------------------
- *	 0    |	BMI160_ACCEL_OUTPUT_DATA_RATE_RESERVED
- *	 1	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_0_78HZ
- *	 2	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_1_56HZ
- *	 3    |	BMI160_ACCEL_OUTPUT_DATA_RATE_3_12HZ
- *	 4    | BMI160_ACCEL_OUTPUT_DATA_RATE_6_25HZ
- *	 5	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_12_5HZ
- *	 6	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_25HZ
- *	 7	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_50HZ
- *	 8	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_100HZ
- *	 9	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_200HZ
- *	 10	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_400HZ
- *	 11	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_800HZ
- *	 12	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_1600HZ
- *
- *  @param  v_accel_bw_u8 :The value of accel selected accel bandwidth
- *  value |  output data rate
- * -------|--------------------------
- *    0   |  BMI160_ACCEL_OSR4_AVG1
- *    1   |  BMI160_ACCEL_OSR2_AVG2
- *    2   |  BMI160_ACCEL_NORMAL_AVG4
- *    3   |  BMI160_ACCEL_CIC_AVG8
- *    4   |  BMI160_ACCEL_RES_AVG2
- *    5   |  BMI160_ACCEL_RES_AVG4
- *    6   |  BMI160_ACCEL_RES_AVG8
- *    7   |  BMI160_ACCEL_RES_AVG16
- *    8   |  BMI160_ACCEL_RES_AVG32
- *    9   |  BMI160_ACCEL_RES_AVG64
- *    10  |  BMI160_ACCEL_RES_AVG128
- *
- *
- *
- *
- *
- *	@note Verify the accel bandwidth before setting the
- *  output data rate
- *  bandwidth  | output data rate |  under sampling
- *-------------|------------------|----------------
- *   OSR4      |  12.5 TO 1600    |   0
- *   OSR2      |  12.5 TO 1600    |   0
- *  NORMAL     |  12.5 TO 1600    |   0
- *   CIC       |  12.5 TO 1600    |   0
- *   AVG2      |  0.78 TO 400     |   1
- *   AVG4      |  0.78 TO 200     |   1
- *   AVG8      |  0.78 TO 100     |   1
- *   AVG16     |  0.78 TO 50      |   1
- *   AVG32     |  0.78 TO 25      |   1
- *   AVG64     |  0.78 TO 12.5    |   1
- *   AVG128    |  0.78 TO 6.25    |   1
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_output_data_rate(
-u8 v_output_data_rate_u8, u8 v_accel_bw_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	u8 v_odr_u8 = BMI160_INIT_VALUE;
-	u8 v_assign_bw = BMI160_ASSIGN_DATA;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if ((v_accel_bw_u8 >= BMI160_ACCEL_RES_AVG2) &&
-		(v_accel_bw_u8 <= BMI160_ACCEL_RES_AVG128)) {
-			/* enable the under sampling*/
-			com_rslt = bmi160_set_accel_under_sampling_parameter(
-			BMI160_US_ENABLE);
-		} else if (((v_accel_bw_u8 > BMI160_ACCEL_OSR4_AVG1) &&
-		(v_accel_bw_u8 <= BMI160_ACCEL_CIC_AVG8))
-		|| (v_accel_bw_u8 == BMI160_ACCEL_OSR4_AVG1)) {
-			/* disable the under sampling*/
-			com_rslt = bmi160_set_accel_under_sampling_parameter(
-			BMI160_US_DISABLE);
-		}
-		/* assign the output data rate*/
-		switch (v_accel_bw_u8) {
-		case BMI160_ACCEL_RES_AVG2:
-			if (v_output_data_rate_u8
-			 >= BMI160_ACCEL_OUTPUT_DATA_RATE_0_78HZ
-			&& v_output_data_rate_u8
-			 <= BMI160_ACCEL_OUTPUT_DATA_RATE_400HZ) {
-				v_odr_u8 = v_output_data_rate_u8;
-				v_assign_bw = SUCCESS;
-			 } else {
-				com_rslt = E_BMI160_OUT_OF_RANGE;
-			 }
-		break;
-		case BMI160_ACCEL_RES_AVG4:
-			if (v_output_data_rate_u8
-			>= BMI160_ACCEL_OUTPUT_DATA_RATE_0_78HZ
-			&& v_output_data_rate_u8
-			<= BMI160_ACCEL_OUTPUT_DATA_RATE_200HZ) {
-				v_odr_u8 = v_output_data_rate_u8;
-				v_assign_bw = SUCCESS;
-			 } else {
-				com_rslt = E_BMI160_OUT_OF_RANGE;
-			 }
-		break;
-		case BMI160_ACCEL_RES_AVG8:
-			if (v_output_data_rate_u8
-			>= BMI160_ACCEL_OUTPUT_DATA_RATE_0_78HZ
-			&& v_output_data_rate_u8
-			 <= BMI160_ACCEL_OUTPUT_DATA_RATE_100HZ) {
-				v_odr_u8 = v_output_data_rate_u8;
-				v_assign_bw = SUCCESS;
-			 } else {
-				com_rslt = E_BMI160_OUT_OF_RANGE;
-			 }
-		break;
-		case BMI160_ACCEL_RES_AVG16:
-			if (v_output_data_rate_u8
-			>= BMI160_ACCEL_OUTPUT_DATA_RATE_0_78HZ
-			&& v_output_data_rate_u8
-			 <= BMI160_ACCEL_OUTPUT_DATA_RATE_50HZ) {
-				v_odr_u8 = v_output_data_rate_u8;
-				v_assign_bw = SUCCESS;
-			 } else {
-				com_rslt = E_BMI160_OUT_OF_RANGE;
-			 }
-		break;
-		case BMI160_ACCEL_RES_AVG32:
-			if (v_output_data_rate_u8
-			>= BMI160_ACCEL_OUTPUT_DATA_RATE_0_78HZ
-			&& v_output_data_rate_u8
-			<= BMI160_ACCEL_OUTPUT_DATA_RATE_25HZ) {
-				v_odr_u8 = v_output_data_rate_u8;
-				v_assign_bw = SUCCESS;
-			 } else {
-				com_rslt = E_BMI160_OUT_OF_RANGE;
-			 }
-		break;
-		case BMI160_ACCEL_RES_AVG64:
-		if (v_output_data_rate_u8
-		 >= BMI160_ACCEL_OUTPUT_DATA_RATE_0_78HZ
-		&& v_output_data_rate_u8
-		<= BMI160_ACCEL_OUTPUT_DATA_RATE_12_5HZ) {
-			v_odr_u8 = v_output_data_rate_u8;
-			v_assign_bw = SUCCESS;
-		 } else {
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-		 }
-		break;
-		case BMI160_ACCEL_RES_AVG128:
-			if (v_output_data_rate_u8
-			>= BMI160_ACCEL_OUTPUT_DATA_RATE_0_78HZ
-			&& v_output_data_rate_u8
-			<= BMI160_ACCEL_OUTPUT_DATA_RATE_6_25HZ) {
-				v_odr_u8 = v_output_data_rate_u8;
-				v_assign_bw = SUCCESS;
-			 } else {
-				com_rslt = E_BMI160_OUT_OF_RANGE;
-			 }
-		break;
-		case BMI160_ACCEL_OSR4_AVG1:
-			if ((v_output_data_rate_u8
-			>= BMI160_ACCEL_OUTPUT_DATA_RATE_12_5HZ)
-			&& (v_output_data_rate_u8
-			<= BMI160_ACCEL_OUTPUT_DATA_RATE_1600HZ)) {
-				v_odr_u8 = v_output_data_rate_u8;
-				v_assign_bw = SUCCESS;
-			 } else {
-				com_rslt = E_BMI160_OUT_OF_RANGE;
-			 }
-		break;
-		case BMI160_ACCEL_OSR2_AVG2:
-			if ((v_output_data_rate_u8
-			>= BMI160_ACCEL_OUTPUT_DATA_RATE_12_5HZ)
-			&& (v_output_data_rate_u8
-			<= BMI160_ACCEL_OUTPUT_DATA_RATE_1600HZ)) {
-				v_odr_u8 = v_output_data_rate_u8;
-				v_assign_bw = SUCCESS;
-			 } else {
-				com_rslt = E_BMI160_OUT_OF_RANGE;
-			 }
-		break;
-		case BMI160_ACCEL_NORMAL_AVG4:
-			if ((v_output_data_rate_u8
-			>= BMI160_ACCEL_OUTPUT_DATA_RATE_12_5HZ)
-			&& (v_output_data_rate_u8
-			<= BMI160_ACCEL_OUTPUT_DATA_RATE_1600HZ)) {
-				v_odr_u8 = v_output_data_rate_u8;
-				v_assign_bw = SUCCESS;
-			 } else {
-				com_rslt = E_BMI160_OUT_OF_RANGE;
-			 }
-		break;
-		case BMI160_ACCEL_CIC_AVG8:
-			if ((v_output_data_rate_u8
-			>= BMI160_ACCEL_OUTPUT_DATA_RATE_12_5HZ)
-			&& (v_output_data_rate_u8
-			<= BMI160_ACCEL_OUTPUT_DATA_RATE_1600HZ)) {
-				v_odr_u8 = v_output_data_rate_u8;
-				v_assign_bw = SUCCESS;
-			 } else {
-				com_rslt = E_BMI160_OUT_OF_RANGE;
-			 }
-		break;
-		default:
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		break;
-		}
-		if (v_assign_bw == SUCCESS) {
-			/* write accel output data rate */
-			com_rslt +=
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_ACCEL_CONFIG_OUTPUT_DATA_RATE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_ACCEL_CONFIG_OUTPUT_DATA_RATE,
-				v_odr_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_ACCEL_CONFIG_OUTPUT_DATA_RATE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to get the
- *	accel bandwidth from the register 0x40 bit 4 to 6
- *	@brief bandwidth parameter determines filter configuration(acc_us=0)
- *	and averaging for under sampling mode(acc_us=1)
- *
- *
- *  @param  v_bw_u8 : The value of accel bandwidth
- *
- *	@note accel bandwidth depends on under sampling parameter
- *	@note under sampling parameter cab be set by the function
- *	"BMI160_SET_ACCEL_UNDER_SAMPLING_PARAMETER"
- *
- *	@note Filter configuration
- *  accel_us  | Filter configuration
- * -----------|---------------------
- *    0x00    |  OSR4 mode
- *    0x01    |  OSR2 mode
- *    0x02    |  normal mode
- *    0x03    |  CIC mode
- *    0x04    |  Reserved
- *    0x05    |  Reserved
- *    0x06    |  Reserved
- *    0x07    |  Reserved
- *
- *	@note accel under sampling mode
- *  accel_us  | Under sampling mode
- * -----------|---------------------
- *    0x00    |  no averaging
- *    0x01    |  average 2 samples
- *    0x02    |  average 4 samples
- *    0x03    |  average 8 samples
- *    0x04    |  average 16 samples
- *    0x05    |  average 32 samples
- *    0x06    |  average 64 samples
- *    0x07    |  average 128 samples
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_bw(u8 *v_bw_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the accel bandwidth */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_ACCEL_CONFIG_ACCEL_BW__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_bw_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_ACCEL_CONFIG_ACCEL_BW);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to set the
- *	accel bandwidth from the register 0x40 bit 4 to 6
- *	@brief bandwidth parameter determines filter configuration(acc_us=0)
- *	and averaging for under sampling mode(acc_us=1)
- *
- *
- *  @param  v_bw_u8 : The value of accel bandwidth
- *
- *	@note accel bandwidth depends on under sampling parameter
- *	@note under sampling parameter cab be set by the function
- *	"BMI160_SET_ACCEL_UNDER_SAMPLING_PARAMETER"
- *
- *	@note Filter configuration
- *  accel_us  | Filter configuration
- * -----------|---------------------
- *    0x00    |  OSR4 mode
- *    0x01    |  OSR2 mode
- *    0x02    |  normal mode
- *    0x03    |  CIC mode
- *    0x04    |  Reserved
- *    0x05    |  Reserved
- *    0x06    |  Reserved
- *    0x07    |  Reserved
- *
- *	@note accel under sampling mode
- *  accel_us  | Under sampling mode
- * -----------|---------------------
- *    0x00    |  no averaging
- *    0x01    |  average 2 samples
- *    0x02    |  average 4 samples
- *    0x03    |  average 8 samples
- *    0x04    |  average 16 samples
- *    0x05    |  average 32 samples
- *    0x06    |  average 64 samples
- *    0x07    |  average 128 samples
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_bw(u8 v_bw_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		/* select accel bandwidth*/
-		if (v_bw_u8 <= BMI160_MAX_ACCEL_BW) {
-			/* write accel bandwidth*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_ACCEL_CONFIG_ACCEL_BW__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_ACCEL_CONFIG_ACCEL_BW,
-				v_bw_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_ACCEL_CONFIG_ACCEL_BW__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to get the accel
- *	under sampling parameter form the register 0x40 bit 7
- *
- *
- *
- *
- *	@param  v_accel_under_sampling_u8 : The value of accel under sampling
- *	value    | under_sampling
- * ----------|---------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_under_sampling_parameter(
-u8 *v_accel_under_sampling_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the accel under sampling parameter */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_ACCEL_CONFIG_ACCEL_UNDER_SAMPLING__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_accel_under_sampling_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_ACCEL_CONFIG_ACCEL_UNDER_SAMPLING);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to set the accel
- *	under sampling parameter form the register 0x40 bit 7
- *
- *
- *
- *
- *	@param  v_accel_under_sampling_u8 : The value of accel under sampling
- *	value    | under_sampling
- * ----------|---------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_under_sampling_parameter(
-u8 v_accel_under_sampling_u8)
-{
-/* variable used for return the status of communication result*/
-BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-	if (v_accel_under_sampling_u8 <= BMI160_MAX_UNDER_SAMPLING) {
-		com_rslt =
-		p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-		BMI160_USER_ACCEL_CONFIG_ACCEL_UNDER_SAMPLING__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			/* write the accel under sampling parameter */
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_ACCEL_CONFIG_ACCEL_UNDER_SAMPLING,
-			v_accel_under_sampling_u8);
-			com_rslt +=
-			p_bmi160->BMI160_BUS_WRITE_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_ACCEL_CONFIG_ACCEL_UNDER_SAMPLING__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-	} else {
-	com_rslt = E_BMI160_OUT_OF_RANGE;
-	}
-}
-return com_rslt;
-}
-/*!
- *	@brief This API is used to get the ranges
- *	(g values) of the accel from the register 0x41 bit 0 to 3
- *
- *
- *
- *
- *  @param v_range_u8 : The value of accel g range
- *	value    | g_range
- * ----------|-----------
- *   0x03    | BMI160_ACCEL_RANGE_2G
- *   0x05    | BMI160_ACCEL_RANGE_4G
- *   0x08    | BMI160_ACCEL_RANGE_8G
- *   0x0C    | BMI160_ACCEL_RANGE_16G
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_range(
-u8 *v_range_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the accel range*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_ACCEL_RANGE__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_range_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_ACCEL_RANGE);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to set the ranges
- *	(g values) of the accel from the register 0x41 bit 0 to 3
- *
- *
- *
- *
- *  @param v_range_u8 : The value of accel g range
- *	value    | g_range
- * ----------|-----------
- *   0x03    | BMI160_ACCEL_RANGE_2G
- *   0x05    | BMI160_ACCEL_RANGE_4G
- *   0x08    | BMI160_ACCEL_RANGE_8G
- *   0x0C    | BMI160_ACCEL_RANGE_16G
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_range(u8 v_range_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if ((v_range_u8 == BMI160_ACCEL_RANGE0) ||
-			(v_range_u8 == BMI160_ACCEL_RANGE1) ||
-			(v_range_u8 == BMI160_ACCEL_RANGE3) ||
-			(v_range_u8 == BMI160_ACCEL_RANGE4)) {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_ACCEL_RANGE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8  = BMI160_SET_BITSLICE(
-				v_data_u8, BMI160_USER_ACCEL_RANGE,
-				v_range_u8);
-				/* write the accel range*/
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_ACCEL_RANGE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to get the
- *	gyroscope output data rate from the register 0x42 bit 0 to 3
- *
- *
- *
- *
- *  @param  v_output_data_rate_u8 :The value of gyro output data rate
- *  value     |      gyro output data rate
- * -----------|-----------------------------
- *   0x00     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *   0x01     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *   0x02     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *   0x03     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *   0x04     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *   0x05     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *   0x06     | BMI160_GYRO_OUTPUT_DATA_RATE_25HZ
- *   0x07     | BMI160_GYRO_OUTPUT_DATA_RATE_50HZ
- *   0x08     | BMI160_GYRO_OUTPUT_DATA_RATE_100HZ
- *   0x09     | BMI160_GYRO_OUTPUT_DATA_RATE_200HZ
- *   0x0A     | BMI160_GYRO_OUTPUT_DATA_RATE_400HZ
- *   0x0B     | BMI160_GYRO_OUTPUT_DATA_RATE_800HZ
- *   0x0C     | BMI160_GYRO_OUTPUT_DATA_RATE_1600HZ
- *   0x0D     | BMI160_GYRO_OUTPUT_DATA_RATE_3200HZ
- *   0x0E     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *   0x0F     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_output_data_rate(
-u8 *v_output_data_rate_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the gyro output data rate*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_GYRO_CONFIG_OUTPUT_DATA_RATE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_output_data_rate_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_GYRO_CONFIG_OUTPUT_DATA_RATE);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to set the
- *	gyroscope output data rate from the register 0x42 bit 0 to 3
- *
- *
- *
- *
- *  @param  v_output_data_rate_u8 :The value of gyro output data rate
- *  value     |      gyro output data rate
- * -----------|-----------------------------
- *   0x00     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *   0x01     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *   0x02     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *   0x03     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *   0x04     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *   0x05     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *   0x06     | BMI160_GYRO_OUTPUT_DATA_RATE_25HZ
- *   0x07     | BMI160_GYRO_OUTPUT_DATA_RATE_50HZ
- *   0x08     | BMI160_GYRO_OUTPUT_DATA_RATE_100HZ
- *   0x09     | BMI160_GYRO_OUTPUT_DATA_RATE_200HZ
- *   0x0A     | BMI160_GYRO_OUTPUT_DATA_RATE_400HZ
- *   0x0B     | BMI160_GYRO_OUTPUT_DATA_RATE_800HZ
- *   0x0C     | BMI160_GYRO_OUTPUT_DATA_RATE_1600HZ
- *   0x0D     | BMI160_GYRO_OUTPUT_DATA_RATE_3200HZ
- *   0x0E     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *   0x0F     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_output_data_rate(
-u8 v_output_data_rate_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		/* select the gyro output data rate*/
-		if ((v_output_data_rate_u8 <  BMI160_OUTPUT_DATA_RATE6) &&
-		(v_output_data_rate_u8 != BMI160_INIT_VALUE)
-		&& (v_output_data_rate_u8 !=  BMI160_OUTPUT_DATA_RATE1)
-		&& (v_output_data_rate_u8 !=  BMI160_OUTPUT_DATA_RATE2)
-		&& (v_output_data_rate_u8 !=  BMI160_OUTPUT_DATA_RATE3)
-		&& (v_output_data_rate_u8 !=  BMI160_OUTPUT_DATA_RATE4)
-		&& (v_output_data_rate_u8 !=  BMI160_OUTPUT_DATA_RATE5)
-		&& (v_output_data_rate_u8 !=  BMI160_OUTPUT_DATA_RATE6)
-		&& (v_output_data_rate_u8 !=  BMI160_OUTPUT_DATA_RATE7)) {
-			/* write the gyro output data rate */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_GYRO_CONFIG_OUTPUT_DATA_RATE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_GYRO_CONFIG_OUTPUT_DATA_RATE,
-				v_output_data_rate_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
-				(p_bmi160->dev_addr,
-				BMI160_USER_GYRO_CONFIG_OUTPUT_DATA_RATE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to get the
- *	data of gyro from the register 0x42 bit 4 to 5
- *
- *
- *
- *
- *  @param  v_bw_u8 : The value of gyro bandwidth
- *  value     | gyro bandwidth
- *  ----------|----------------
- *   0x00     | BMI160_GYRO_OSR4_MODE
- *   0x01     | BMI160_GYRO_OSR2_MODE
- *   0x02     | BMI160_GYRO_NORMAL_MODE
- *   0x03     | BMI160_GYRO_CIC_MODE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_bw(u8 *v_bw_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read gyro bandwidth*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_GYRO_CONFIG_BW__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_bw_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_GYRO_CONFIG_BW);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to set the
- *	data of gyro from the register 0x42 bit 4 to 5
- *
- *
- *
- *
- *  @param  v_bw_u8 : The value of gyro bandwidth
- *  value     | gyro bandwidth
- *  ----------|----------------
- *   0x00     | BMI160_GYRO_OSR4_MODE
- *   0x01     | BMI160_GYRO_OSR2_MODE
- *   0x02     | BMI160_GYRO_NORMAL_MODE
- *   0x03     | BMI160_GYRO_CIC_MODE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_bw(u8 v_bw_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_bw_u8 <= BMI160_MAX_GYRO_BW) {
-			/* write the gyro bandwidth*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_GYRO_CONFIG_BW__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_GYRO_CONFIG_BW, v_bw_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_GYRO_CONFIG_BW__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads the range
- *	of gyro from the register 0x43 bit 0 to 2
- *
- *  @param  v_range_u8 : The value of gyro range
- *   value    |    range
- *  ----------|-------------------------------
- *    0x00    | BMI160_GYRO_RANGE_2000_DEG_SEC
- *    0x01    | BMI160_GYRO_RANGE_1000_DEG_SEC
- *    0x02    | BMI160_GYRO_RANGE_500_DEG_SEC
- *    0x03    | BMI160_GYRO_RANGE_250_DEG_SEC
- *    0x04    | BMI160_GYRO_RANGE_125_DEG_SEC
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_range(u8 *v_range_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the gyro range */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_GYRO_RANGE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_range_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_GYRO_RANGE);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API set the range
- *	of gyro from the register 0x43 bit 0 to 2
- *
- *  @param  v_range_u8 : The value of gyro range
- *   value    |    range
- *  ----------|-------------------------------
- *    0x00    | BMI160_GYRO_RANGE_2000_DEG_SEC
- *    0x01    | BMI160_GYRO_RANGE_1000_DEG_SEC
- *    0x02    | BMI160_GYRO_RANGE_500_DEG_SEC
- *    0x03    | BMI160_GYRO_RANGE_250_DEG_SEC
- *    0x04    | BMI160_GYRO_RANGE_125_DEG_SEC
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_range(u8 v_range_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_range_u8 <= BMI160_MAX_GYRO_RANGE) {
-			/* write the gyro range value */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_GYRO_RANGE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_GYRO_RANGE,
-				v_range_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
-				(p_bmi160->dev_addr,
-				BMI160_USER_GYRO_RANGE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to get the
- *	output data rate of magnetometer from the register 0x44 bit 0 to 3
- *
- *
- *
- *
- *  @param  v_output_data_rat_u8e : The value of mag output data rate
- *  value   |    mag output data rate
- * ---------|---------------------------
- *  0x00    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED
- *  0x01    |BMI160_MAG_OUTPUT_DATA_RATE_0_78HZ
- *  0x02    |BMI160_MAG_OUTPUT_DATA_RATE_1_56HZ
- *  0x03    |BMI160_MAG_OUTPUT_DATA_RATE_3_12HZ
- *  0x04    |BMI160_MAG_OUTPUT_DATA_RATE_6_25HZ
- *  0x05    |BMI160_MAG_OUTPUT_DATA_RATE_12_5HZ
- *  0x06    |BMI160_MAG_OUTPUT_DATA_RATE_25HZ
- *  0x07    |BMI160_MAG_OUTPUT_DATA_RATE_50HZ
- *  0x08    |BMI160_MAG_OUTPUT_DATA_RATE_100HZ
- *  0x09    |BMI160_MAG_OUTPUT_DATA_RATE_200HZ
- *  0x0A    |BMI160_MAG_OUTPUT_DATA_RATE_400HZ
- *  0x0B    |BMI160_MAG_OUTPUT_DATA_RATE_800HZ
- *  0x0C    |BMI160_MAG_OUTPUT_DATA_RATE_1600HZ
- *  0x0D    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED0
- *  0x0E    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED1
- *  0x0F    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED2
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_output_data_rate(
-u8 *v_output_data_rat_u8e)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the mag data output rate*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_MAG_CONFIG_OUTPUT_DATA_RATE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_output_data_rat_u8e = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_MAG_CONFIG_OUTPUT_DATA_RATE);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to set the
- *	output data rate of magnetometer from the register 0x44 bit 0 to 3
- *
- *
- *
- *
- *  @param  v_output_data_rat_u8e : The value of mag output data rate
- *  value   |    mag output data rate
- * ---------|---------------------------
- *  0x00    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED
- *  0x01    |BMI160_MAG_OUTPUT_DATA_RATE_0_78HZ
- *  0x02    |BMI160_MAG_OUTPUT_DATA_RATE_1_56HZ
- *  0x03    |BMI160_MAG_OUTPUT_DATA_RATE_3_12HZ
- *  0x04    |BMI160_MAG_OUTPUT_DATA_RATE_6_25HZ
- *  0x05    |BMI160_MAG_OUTPUT_DATA_RATE_12_5HZ
- *  0x06    |BMI160_MAG_OUTPUT_DATA_RATE_25HZ
- *  0x07    |BMI160_MAG_OUTPUT_DATA_RATE_50HZ
- *  0x08    |BMI160_MAG_OUTPUT_DATA_RATE_100HZ
- *  0x09    |BMI160_MAG_OUTPUT_DATA_RATE_200HZ
- *  0x0A    |BMI160_MAG_OUTPUT_DATA_RATE_400HZ
- *  0x0B    |BMI160_MAG_OUTPUT_DATA_RATE_800HZ
- *  0x0C    |BMI160_MAG_OUTPUT_DATA_RATE_1600HZ
- *  0x0D    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED0
- *  0x0E    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED1
- *  0x0F    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED2
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_output_data_rate(
-u8 v_output_data_rat_u8e)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		/* select the mag data output rate*/
-		if ((v_output_data_rat_u8e
-		<= BMI160_MAX_ACCEL_OUTPUT_DATA_RATE)
-		&& (v_output_data_rat_u8e
-		!= BMI160_OUTPUT_DATA_RATE0)
-		&& (v_output_data_rat_u8e
-		!=  BMI160_OUTPUT_DATA_RATE6)
-		&& (v_output_data_rat_u8e
-		!=  BMI160_OUTPUT_DATA_RATE7)) {
-			/* write the mag data output rate*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_MAG_CONFIG_OUTPUT_DATA_RATE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_MAG_CONFIG_OUTPUT_DATA_RATE,
-				v_output_data_rat_u8e);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_MAG_CONFIG_OUTPUT_DATA_RATE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
- /*!
- *	@brief This API is used to read Down sampling
- *	for gyro (2**downs_gyro) in the register 0x45 bit 0 to 2
- *
- *
- *
- *
- *  @param v_fifo_down_gyro_u8 :The value of gyro fifo down
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_down_gyro(
-u8 *v_fifo_down_gyro_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the gyro fifo down*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_FIFO_DOWN_GYRO__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_fifo_down_gyro_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_FIFO_DOWN_GYRO);
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API is used to set Down sampling
- *	for gyro (2**downs_gyro) in the register 0x45 bit 0 to 2
- *
- *
- *
- *
- *  @param v_fifo_down_gyro_u8 :The value of gyro fifo down
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_down_gyro(
-u8 v_fifo_down_gyro_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* write the gyro fifo down*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_FIFO_DOWN_GYRO__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(
-				v_data_u8,
-				BMI160_USER_FIFO_DOWN_GYRO,
-				v_fifo_down_gyro_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_FIFO_DOWN_GYRO__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to read gyro fifo filter data
- *	from the register 0x45 bit 3
- *
- *
- *
- *  @param v_gyro_fifo_filter_data_u8 :The value of gyro filter data
- *  value      |  gyro_fifo_filter_data
- * ------------|-------------------------
- *    0x00     |  Unfiltered data
- *    0x01     |  Filtered data
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_fifo_filter_data(
-u8 *v_gyro_fifo_filter_data_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the gyro fifo filter data */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_FIFO_FILTER_GYRO__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_gyro_fifo_filter_data_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_FIFO_FILTER_GYRO);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to set gyro fifo filter data
- *	from the register 0x45 bit 3
- *
- *
- *
- *  @param v_gyro_fifo_filter_data_u8 :The value of gyro filter data
- *  value      |  gyro_fifo_filter_data
- * ------------|-------------------------
- *    0x00     |  Unfiltered data
- *    0x01     |  Filtered data
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_fifo_filter_data(
-u8 v_gyro_fifo_filter_data_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_gyro_fifo_filter_data_u8
-		<= BMI160_MAX_VALUE_FIFO_FILTER) {
-			/* write the gyro fifo filter data */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_FIFO_FILTER_GYRO__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(
-				v_data_u8,
-				BMI160_USER_FIFO_FILTER_GYRO,
-				v_gyro_fifo_filter_data_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_FIFO_FILTER_GYRO__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to read Down sampling
- *	for accel (2*downs_accel) from the register 0x45 bit 4 to 6
- *
- *
- *
- *
- *  @param v_fifo_down_u8 :The value of accel fifo down
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_down_accel(
-u8 *v_fifo_down_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the accel fifo down data */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_FIFO_DOWN_ACCEL__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_fifo_down_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_FIFO_DOWN_ACCEL);
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API is used to set Down sampling
- *	for accel (2*downs_accel) from the register 0x45 bit 4 to 6
- *
- *
- *
- *
- *  @param v_fifo_down_u8 :The value of accel fifo down
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_down_accel(
-u8 v_fifo_down_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* write the accel fifo down data */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_FIFO_DOWN_ACCEL__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_FIFO_DOWN_ACCEL, v_fifo_down_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_FIFO_DOWN_ACCEL__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to read accel fifo filter data
- *	from the register 0x45 bit 7
- *
- *
- *
- *  @param accel_fifo_filter_u8 :The value of accel filter data
- *  value      |  accel_fifo_filter_u8
- * ------------|-------------------------
- *    0x00     |  Unfiltered data
- *    0x01     |  Filtered data
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_fifo_filter_data(
-u8 *accel_fifo_filter_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the accel fifo filter data */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_FIFO_FILTER_ACCEL__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*accel_fifo_filter_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_FIFO_FILTER_ACCEL);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to set accel fifo filter data
- *	from the register 0x45 bit 7
- *
- *
- *
- *  @param v_accel_fifo_filter_u8 :The value of accel filter data
- *  value      |  accel_fifo_filter_data
- * ------------|-------------------------
- *    0x00     |  Unfiltered data
- *    0x01     |  Filtered data
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_fifo_filter_data(
-u8 v_accel_fifo_filter_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_accel_fifo_filter_u8 <= BMI160_MAX_VALUE_FIFO_FILTER) {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_FIFO_FILTER_ACCEL__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				/* write accel fifo filter data */
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_FIFO_FILTER_ACCEL,
-				v_accel_fifo_filter_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_FIFO_FILTER_ACCEL__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to Trigger an interrupt
- *	when FIFO contains water mark level from the register 0x46 bit 0 to 7
- *
- *
- *
- *  @param  v_fifo_wm_u8 : The value of fifo water mark level
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_wm(
-u8 *v_fifo_wm_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the fifo water mark level*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_FIFO_WM__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_fifo_wm_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_FIFO_WM);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to Trigger an interrupt
- *	when FIFO contains water mark level from the register 0x46 bit 0 to 7
- *
- *
- *
- *  @param  v_fifo_wm_u8 : The value of fifo water mark level
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_wm(
-u8 v_fifo_wm_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* write the fifo water mark level*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_FIFO_WM__REG,
-			&v_fifo_wm_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads fifo sensor time
- *	frame after the last valid data frame form the register  0x47 bit 1
- *
- *
- *
- *
- *  @param v_fifo_time_enable_u8 : The value of sensor time
- *  value      |  fifo sensor time
- * ------------|-------------------------
- *    0x00     |  do not return sensortime frame
- *    0x01     |  return sensortime frame
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_time_enable(
-u8 *v_fifo_time_enable_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the fifo sensor time*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_FIFO_TIME_ENABLE__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_fifo_time_enable_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_FIFO_TIME_ENABLE);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API set fifo sensor time
- *	frame after the last valid data frame form the register  0x47 bit 1
- *
- *
- *
- *
- *  @param v_fifo_time_enable_u8 : The value of sensor time
- *  value      |  fifo sensor time
- * ------------|-------------------------
- *    0x00     |  do not return sensortime frame
- *    0x01     |  return sensortime frame
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_time_enable(
-u8 v_fifo_time_enable_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_fifo_time_enable_u8 <= BMI160_MAX_VALUE_FIFO_TIME) {
-			/* write the fifo sensor time*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_FIFO_TIME_ENABLE__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_FIFO_TIME_ENABLE,
-				v_fifo_time_enable_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_FIFO_TIME_ENABLE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads FIFO tag interrupt2 enable status
- *	from the resister 0x47 bit 2
- *
- *  @param v_fifo_tag_intr2_u8 : The value of fifo tag interrupt
- *	value    | fifo tag interrupt
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_tag_intr2_enable(
-u8 *v_fifo_tag_intr2_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the fifo tag interrupt2*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_FIFO_TAG_INTR2_ENABLE__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_fifo_tag_intr2_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_FIFO_TAG_INTR2_ENABLE);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API set FIFO tag interrupt2 enable status
- *	from the resister 0x47 bit 2
- *
- *  @param v_fifo_tag_intr2_u8 : The value of fifo tag interrupt
- *	value    | fifo tag interrupt
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_tag_intr2_enable(
-u8 v_fifo_tag_intr2_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_fifo_tag_intr2_u8 <= BMI160_MAX_VALUE_FIFO_INTR) {
-			/* write the fifo tag interrupt2*/
-			com_rslt = bmi160_set_input_enable(1,
-			v_fifo_tag_intr2_u8);
-			com_rslt +=
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_FIFO_TAG_INTR2_ENABLE__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_FIFO_TAG_INTR2_ENABLE,
-				v_fifo_tag_intr2_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_FIFO_TAG_INTR2_ENABLE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API get FIFO tag interrupt1 enable status
- *	from the resister 0x47 bit 3
- *
- *  @param v_fifo_tag_intr1_u8 :The value of fifo tag interrupt1
- *	value    | fifo tag interrupt
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_tag_intr1_enable(
-u8 *v_fifo_tag_intr1_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read fifo tag interrupt*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_FIFO_TAG_INTR1_ENABLE__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_fifo_tag_intr1_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_FIFO_TAG_INTR1_ENABLE);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API set FIFO tag interrupt1 enable status
- *	from the resister 0x47 bit 3
- *
- *  @param v_fifo_tag_intr1_u8 :The value of fifo tag interrupt1
- *	value    | fifo tag interrupt
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_tag_intr1_enable(
-u8 v_fifo_tag_intr1_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_fifo_tag_intr1_u8 <= BMI160_MAX_VALUE_FIFO_INTR) {
-			/* write the fifo tag interrupt*/
-			com_rslt = bmi160_set_input_enable(BMI160_INIT_VALUE,
-			v_fifo_tag_intr1_u8);
-			com_rslt +=
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_FIFO_TAG_INTR1_ENABLE__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_FIFO_TAG_INTR1_ENABLE,
-				v_fifo_tag_intr1_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_FIFO_TAG_INTR1_ENABLE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads FIFO frame
- *	header enable from the register 0x47 bit 4
- *
- *  @param v_fifo_header_u8 :The value of fifo header
- *	value    | fifo header
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_header_enable(
-u8 *v_fifo_header_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read fifo header */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_FIFO_HEADER_ENABLE__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_fifo_header_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_FIFO_HEADER_ENABLE);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API set FIFO frame
- *	header enable from the register 0x47 bit 4
- *
- *  @param v_fifo_header_u8 :The value of fifo header
- *	value    | fifo header
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_header_enable(
-u8 v_fifo_header_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_fifo_header_u8 <= BMI160_MAX_VALUE_FIFO_HEADER) {
-			/* write the fifo header */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_FIFO_HEADER_ENABLE__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_FIFO_HEADER_ENABLE,
-				v_fifo_header_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_FIFO_HEADER_ENABLE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to read stored
- *	magnetometer data in FIFO (all 3 axes) from the register 0x47 bit 5
- *
- *  @param v_fifo_mag_u8 : The value of fifo mag enble
- *	value    | fifo mag
- * ----------|-------------------
- *  0x00     |  no magnetometer data is stored
- *  0x01     |  magnetometer data is stored
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_mag_enable(
-u8 *v_fifo_mag_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the fifo mag enable*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_FIFO_MAG_ENABLE__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_fifo_mag_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_FIFO_MAG_ENABLE);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to set stored
- *	magnetometer data in FIFO (all 3 axes) from the register 0x47 bit 5
- *
- *  @param v_fifo_mag_u8 : The value of fifo mag enble
- *	value    | fifo mag
- * ----------|-------------------
- *  0x00     |  no magnetometer data is stored
- *  0x01     |  magnetometer data is stored
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_mag_enable(
-u8 v_fifo_mag_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			if (v_fifo_mag_u8 <= BMI160_MAX_VALUE_FIFO_MAG) {
-				/* write the fifo mag enable*/
-				com_rslt =
-				p_bmi160->BMI160_BUS_READ_FUNC
-				(p_bmi160->dev_addr,
-				BMI160_USER_FIFO_MAG_ENABLE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-				if (com_rslt == SUCCESS) {
-					v_data_u8 =
-					BMI160_SET_BITSLICE(v_data_u8,
-					BMI160_USER_FIFO_MAG_ENABLE,
-					v_fifo_mag_u8);
-					com_rslt +=
-					p_bmi160->BMI160_BUS_WRITE_FUNC
-					(p_bmi160->dev_addr,
-					BMI160_USER_FIFO_MAG_ENABLE__REG,
-					&v_data_u8,
-					BMI160_GEN_READ_WRITE_DATA_LENGTH);
-				}
-			} else {
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-			}
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to read stored
- *	accel data in FIFO (all 3 axes) from the register 0x47 bit 6
- *
- *  @param v_fifo_accel_u8 : The value of fifo accel enble
- *	value    | fifo accel
- * ----------|-------------------
- *  0x00     |  no accel data is stored
- *  0x01     |  accel data is stored
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_accel_enable(
-u8 *v_fifo_accel_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the accel fifo enable*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_FIFO_ACCEL_ENABLE__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_fifo_accel_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_FIFO_ACCEL_ENABLE);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to set stored
- *	accel data in FIFO (all 3 axes) from the register 0x47 bit 6
- *
- *  @param v_fifo_accel_u8 : The value of fifo accel enble
- *	value    | fifo accel
- * ----------|-------------------
- *  0x00     |  no accel data is stored
- *  0x01     |  accel data is stored
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_accel_enable(
-u8 v_fifo_accel_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_fifo_accel_u8 <= BMI160_MAX_VALUE_FIFO_ACCEL) {
-			/* write the fifo mag enables*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_FIFO_ACCEL_ENABLE__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_FIFO_ACCEL_ENABLE, v_fifo_accel_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_FIFO_ACCEL_ENABLE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to read stored
- *	 gyro data in FIFO (all 3 axes) from the resister 0x47 bit 7
- *
- *
- *  @param v_fifo_gyro_u8 : The value of fifo gyro enble
- *	value    | fifo gyro
- * ----------|-------------------
- *  0x00     |  no gyro data is stored
- *  0x01     |  gyro data is stored
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_gyro_enable(
-u8 *v_fifo_gyro_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read fifo gyro enable */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_FIFO_GYRO_ENABLE__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_fifo_gyro_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_FIFO_GYRO_ENABLE);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to set stored
- *	gyro data in FIFO (all 3 axes) from the resister 0x47 bit 7
- *
- *
- *  @param v_fifo_gyro_u8 : The value of fifo gyro enble
- *	value    | fifo gyro
- * ----------|-------------------
- *  0x00     |  no gyro data is stored
- *  0x01     |  gyro data is stored
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_gyro_enable(
-u8 v_fifo_gyro_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_fifo_gyro_u8 <= BMI160_MAX_VALUE_FIFO_GYRO) {
-			/* write fifo gyro enable*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_FIFO_GYRO_ENABLE__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_FIFO_GYRO_ENABLE, v_fifo_gyro_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_FIFO_GYRO_ENABLE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to read
- *	I2C device address of auxiliary mag from the register 0x4B bit 1 to 7
- *
- *
- *
- *
- *  @param v_i2c_device_addr_u8 : The value of mag I2C device address
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_i2c_device_addr(
-u8 *v_i2c_device_addr_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the mag I2C device address*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_I2C_DEVICE_ADDR__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_i2c_device_addr_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_I2C_DEVICE_ADDR);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to set
- *	I2C device address of auxiliary mag from the register 0x4B bit 1 to 7
- *
- *
- *
- *
- *  @param v_i2c_device_addr_u8 : The value of mag I2C device address
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_i2c_device_addr(
-u8 v_i2c_device_addr_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* write the mag I2C device address*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_I2C_DEVICE_ADDR__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_I2C_DEVICE_ADDR,
-				v_i2c_device_addr_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_I2C_DEVICE_ADDR__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to read
- *	Burst data length (1,2,6,8 byte) from the register 0x4C bit 0 to 1
- *
- *
- *
- *
- *  @param v_mag_burst_u8 : The data of mag burst read lenth
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_burst(
-u8 *v_mag_burst_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read mag burst mode length*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_MAG_BURST__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_mag_burst_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_MAG_BURST);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to set
- *	Burst data length (1,2,6,8 byte) from the register 0x4C bit 0 to 1
- *
- *
- *
- *
- *  @param v_mag_burst_u8 : The data of mag burst read lenth
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_burst(
-u8 v_mag_burst_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* write mag burst mode length*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_MAG_BURST__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 =
-				BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_MAG_BURST, v_mag_burst_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_MAG_BURST__REG, &v_data_u8,
-				BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to read
- *	trigger-readout offset in units of 2.5 ms. If set to zero,
- *	the offset is maximum, i.e. after readout a trigger
- *	is issued immediately. from the register 0x4C bit 2 to 5
- *
- *
- *
- *
- *  @param v_mag_offset_u8 : The value of mag offset
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_offset(
-u8 *v_mag_offset_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_MAG_OFFSET__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_mag_offset_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_MAG_OFFSET);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to set
- *	trigger-readout offset in units of 2.5 ms. If set to zero,
- *	the offset is maximum, i.e. after readout a trigger
- *	is issued immediately. from the register 0x4C bit 2 to 5
- *
- *
- *
- *
- *  @param v_mag_offset_u8 : The value of mag offset
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_offset(
-u8 v_mag_offset_u8)
-{
-/* variable used for return the status of communication result*/
-BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-		com_rslt =
-		p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-		BMI160_USER_MAG_OFFSET__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 =
-			BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_MAG_OFFSET, v_mag_offset_u8);
-			com_rslt +=
-			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_MAG_OFFSET__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-	}
-return com_rslt;
-}
-/*!
- *	@brief This API is used to read
- *	Enable register access on MAG_IF[2] or MAG_IF[3] writes.
- *	This implies that the DATA registers are not updated with
- *	magnetometer values. Accessing magnetometer requires
- *	the magnetometer in normal mode in PMU_STATUS.
- *	from the register 0x4C bit 7
- *
- *
- *
- *  @param v_mag_manual_u8 : The value of mag manual enable
- *	value    | mag manual
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_manual_enable(
-u8 *v_mag_manual_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read mag manual */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_MAG_MANUAL_ENABLE__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_mag_manual_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_MAG_MANUAL_ENABLE);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to set
- *	Enable register access on MAG_IF[2] or MAG_IF[3] writes.
- *	This implies that the DATA registers are not updated with
- *	magnetometer values. Accessing magnetometer requires
- *	the magnetometer in normal mode in PMU_STATUS.
- *	from the register 0x4C bit 7
- *
- *
- *
- *  @param v_mag_manual_u8 : The value of mag manual enable
- *	value    | mag manual
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_manual_enable(
-u8 v_mag_manual_u8)
-{
-/* variable used for return the status of communication result*/
-BMI160_RETURN_FUNCTION_TYPE com_rslt = BMI160_INIT_VALUE;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-		/* write the mag manual*/
-		com_rslt =
-		p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-		BMI160_USER_MAG_MANUAL_ENABLE__REG, &v_data_u8,
-		BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		if (com_rslt == SUCCESS) {
-			/* set the bit of mag manual enable*/
-			v_data_u8 =
-			BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_MAG_MANUAL_ENABLE, v_mag_manual_u8);
-			com_rslt +=
-			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_MAG_MANUAL_ENABLE__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-		if (com_rslt == SUCCESS)
-			p_bmi160->mag_manual_enable = v_mag_manual_u8;
-		else
-			p_bmi160->mag_manual_enable = E_BMI160_COMM_RES;
-	}
-return com_rslt;
-}
-/*!
- *	@brief This API is used to read data
- *	magnetometer address to read from the register 0x4D bit 0 to 7
- *	@brief It used to provide mag read address of auxiliary mag
- *
- *
- *
- *
- *  @param  v_mag_read_addr_u8 : The value of address need to be read
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_read_addr(
-u8 *v_mag_read_addr_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the written address*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_READ_ADDR__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_mag_read_addr_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_READ_ADDR);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to set
- *	magnetometer write address from the register 0x4D bit 0 to 7
- *	@brief mag write address writes the address of auxiliary mag to write
- *
- *
- *
- *  @param v_mag_read_addr_u8:
- *	The data of auxiliary mag address to write data
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_read_addr(
-u8 v_mag_read_addr_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* write the mag read address*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_READ_ADDR__REG, &v_mag_read_addr_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to read
- *	magnetometer write address from the register 0x4E bit 0 to 7
- *	@brief mag write address writes the address of auxiliary mag to write
- *
- *
- *
- *  @param  v_mag_write_addr_u8:
- *	The data of auxiliary mag address to write data
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_write_addr(
-u8 *v_mag_write_addr_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the address of last written */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_WRITE_ADDR__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_mag_write_addr_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_WRITE_ADDR);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to set
- *	magnetometer write address from the register 0x4E bit 0 to 7
- *	@brief mag write address writes the address of auxiliary mag to write
- *
- *
- *
- *  @param  v_mag_write_addr_u8:
- *	The data of auxiliary mag address to write data
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_write_addr(
-u8 v_mag_write_addr_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* write the data of mag address to write data */
-			com_rslt =
-			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_WRITE_ADDR__REG, &v_mag_write_addr_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to read magnetometer write data
- *	form the resister 0x4F bit 0 to 7
- *	@brief This writes the data will be wrote to mag
- *
- *
- *
- *  @param  v_mag_write_data_u8: The value of mag data
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_write_data(
-u8 *v_mag_write_data_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_WRITE_DATA__REG, &v_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_mag_write_data_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_WRITE_DATA);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to set magnetometer write data
- *	form the resister 0x4F bit 0 to 7
- *	@brief This writes the data will be wrote to mag
- *
- *
- *
- *  @param  v_mag_write_data_u8: The value of mag data
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_write_data(
-u8 v_mag_write_data_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt =
-			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_WRITE_DATA__REG, &v_mag_write_data_u8,
-			BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief  This API is used to read
- *	interrupt enable from the register 0x50 bit 0 to 7
- *
- *
- *
- *
- *	@param v_enable_u8 : Value to decided to select interrupt
- *   v_enable_u8   |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_ANY_MOTION_X_ENABLE
- *       1         | BMI160_ANY_MOTION_Y_ENABLE
- *       2         | BMI160_ANY_MOTION_Z_ENABLE
- *       3         | BMI160_DOUBLE_TAP_ENABLE
- *       4         | BMI160_SINGLE_TAP_ENABLE
- *       5         | BMI160_ORIENT_ENABLE
- *       6         | BMI160_FLAT_ENABLE
- *
- *	@param v_intr_enable_zero_u8 : The interrupt enable value
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_enable_0(
-u8 v_enable_u8, u8 *v_intr_enable_zero_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		/* select interrupt to read*/
-		switch (v_enable_u8) {
-		case BMI160_ANY_MOTION_X_ENABLE:
-			/* read the any motion interrupt x data */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_0_ANY_MOTION_X_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_enable_zero_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ENABLE_0_ANY_MOTION_X_ENABLE);
-		break;
-		case BMI160_ANY_MOTION_Y_ENABLE:
-			/* read the any motion interrupt y data */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Y_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_enable_zero_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Y_ENABLE);
-		break;
-		case BMI160_ANY_MOTION_Z_ENABLE:
-			/* read the any motion interrupt z data */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Z_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_enable_zero_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Z_ENABLE);
-		break;
-		case BMI160_DOUBLE_TAP_ENABLE:
-			/* read the double tap interrupt data */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_0_DOUBLE_TAP_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_enable_zero_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ENABLE_0_DOUBLE_TAP_ENABLE);
-		break;
-		case BMI160_SINGLE_TAP_ENABLE:
-			/* read the single tap interrupt data */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_0_SINGLE_TAP_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_enable_zero_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ENABLE_0_SINGLE_TAP_ENABLE);
-		break;
-		case BMI160_ORIENT_ENABLE:
-			/* read the orient interrupt data */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_ENABLE_0_ORIENT_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_enable_zero_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ENABLE_0_ORIENT_ENABLE);
-		break;
-		case BMI160_FLAT_ENABLE:
-			/* read the flat interrupt data */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_ENABLE_0_FLAT_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_enable_zero_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ENABLE_0_FLAT_ENABLE);
-		break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-		break;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief  This API is used to set
- *	interrupt enable from the register 0x50 bit 0 to 7
- *
- *
- *
- *
- *	@param v_enable_u8 : Value to decided to select interrupt
- *   v_enable_u8   |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_ANY_MOTION_X_ENABLE
- *       1         | BMI160_ANY_MOTION_Y_ENABLE
- *       2         | BMI160_ANY_MOTION_Z_ENABLE
- *       3         | BMI160_DOUBLE_TAP_ENABLE
- *       4         | BMI160_SINGLE_TAP_ENABLE
- *       5         | BMI160_ORIENT_ENABLE
- *       6         | BMI160_FLAT_ENABLE
- *
- *	@param v_intr_enable_zero_u8 : The interrupt enable value
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_enable_0(
-u8 v_enable_u8, u8 v_intr_enable_zero_u8)
-{
-/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-	switch (v_enable_u8) {
-	case BMI160_ANY_MOTION_X_ENABLE:
-		/* write any motion x*/
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr, BMI160_USER_INTR_ENABLE_0_ANY_MOTION_X_ENABLE__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ENABLE_0_ANY_MOTION_X_ENABLE,
-			v_intr_enable_zero_u8);
-			com_rslt +=
-			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_0_ANY_MOTION_X_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-		break;
-	case BMI160_ANY_MOTION_Y_ENABLE:
-		/* write any motion y*/
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr, BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Y_ENABLE__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Y_ENABLE,
-			v_intr_enable_zero_u8);
-			com_rslt +=
-			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Y_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-		break;
-	case BMI160_ANY_MOTION_Z_ENABLE:
-		/* write any motion z*/
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr, BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Z_ENABLE__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Z_ENABLE,
-			v_intr_enable_zero_u8);
-			com_rslt +=
-			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Z_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-		break;
-	case BMI160_DOUBLE_TAP_ENABLE:
-		/* write double tap*/
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr, BMI160_USER_INTR_ENABLE_0_DOUBLE_TAP_ENABLE__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ENABLE_0_DOUBLE_TAP_ENABLE,
-			v_intr_enable_zero_u8);
-			com_rslt +=
-			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_0_DOUBLE_TAP_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-		break;
-	case BMI160_SINGLE_TAP_ENABLE:
-		/* write single tap */
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr, BMI160_USER_INTR_ENABLE_0_SINGLE_TAP_ENABLE__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ENABLE_0_SINGLE_TAP_ENABLE,
-			v_intr_enable_zero_u8);
-			com_rslt +=
-			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_0_SINGLE_TAP_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-		break;
-	case BMI160_ORIENT_ENABLE:
-		/* write orient interrupt*/
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr, BMI160_USER_INTR_ENABLE_0_ORIENT_ENABLE__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ENABLE_0_ORIENT_ENABLE,
-			v_intr_enable_zero_u8);
-			com_rslt +=
-			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_0_ORIENT_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-		break;
-	case BMI160_FLAT_ENABLE:
-		/* write flat interrupt*/
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr, BMI160_USER_INTR_ENABLE_0_FLAT_ENABLE__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ENABLE_0_FLAT_ENABLE,
-			v_intr_enable_zero_u8);
-			com_rslt +=
-			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_0_FLAT_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-		break;
-	default:
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		break;
-	}
-}
-return com_rslt;
-}
-/*!
- *	@brief  This API is used to read
- *	interrupt enable byte1 from the register 0x51 bit 0 to 6
- *	@brief It read the high_g_x,high_g_y,high_g_z,low_g_enable
- *	data ready, fifo full and fifo water mark.
- *
- *
- *
- *  @param  v_enable_u8 :  The value of interrupt enable
- *	@param v_enable_u8 : Value to decided to select interrupt
- *   v_enable_u8   |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_HIGH_G_X_ENABLE
- *       1         | BMI160_HIGH_G_Y_ENABLE
- *       2         | BMI160_HIGH_G_Z_ENABLE
- *       3         | BMI160_LOW_G_ENABLE
- *       4         | BMI160_DATA_RDY_ENABLE
- *       5         | BMI160_FIFO_FULL_ENABLE
- *       6         | BMI160_FIFO_WM_ENABLE
- *
- *	@param v_intr_enable_1_u8 : The interrupt enable value
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_enable_1(
-u8 v_enable_u8, u8 *v_intr_enable_1_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		switch (v_enable_u8) {
-		case BMI160_HIGH_G_X_ENABLE:
-			/* read high_g_x interrupt*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_1_HIGH_G_X_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_enable_1_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ENABLE_1_HIGH_G_X_ENABLE);
-			break;
-		case BMI160_HIGH_G_Y_ENABLE:
-			/* read high_g_y interrupt*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_1_HIGH_G_Y_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_enable_1_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ENABLE_1_HIGH_G_Y_ENABLE);
-			break;
-		case BMI160_HIGH_G_Z_ENABLE:
-			/* read high_g_z interrupt*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_1_HIGH_G_Z_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_enable_1_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ENABLE_1_HIGH_G_Z_ENABLE);
-			break;
-		case BMI160_LOW_G_ENABLE:
-			/* read low_g interrupt */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_ENABLE_1_LOW_G_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_enable_1_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ENABLE_1_LOW_G_ENABLE);
-			break;
-		case BMI160_DATA_RDY_ENABLE:
-			/* read data ready interrupt */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_1_DATA_RDY_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_enable_1_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ENABLE_1_DATA_RDY_ENABLE);
-			break;
-		case BMI160_FIFO_FULL_ENABLE:
-			/* read fifo full interrupt */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_1_FIFO_FULL_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_enable_1_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ENABLE_1_FIFO_FULL_ENABLE);
-			break;
-		case BMI160_FIFO_WM_ENABLE:
-			/* read fifo water mark interrupt */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_1_FIFO_WM_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_enable_1_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ENABLE_1_FIFO_WM_ENABLE);
-			break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-			break;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief  This API is used to set
- *	interrupt enable byte1 from the register 0x51 bit 0 to 6
- *	@brief It read the high_g_x,high_g_y,high_g_z,low_g_enable
- *	data ready, fifo full and fifo water mark.
- *
- *
- *
- *  @param  v_enable_u8 :  The value of interrupt enable
- *	@param v_enable_u8 : Value to decided to select interrupt
- *   v_enable_u8   |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_HIGH_G_X_ENABLE
- *       1         | BMI160_HIGH_G_Y_ENABLE
- *       2         | BMI160_HIGH_G_Z_ENABLE
- *       3         | BMI160_LOW_G_ENABLE
- *       4         | BMI160_DATA_RDY_ENABLE
- *       5         | BMI160_FIFO_FULL_ENABLE
- *       6         | BMI160_FIFO_WM_ENABLE
- *
- *	@param v_intr_enable_1_u8 : The interrupt enable value
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_enable_1(
-u8 v_enable_u8, u8 v_intr_enable_1_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		switch (v_enable_u8) {
-		case BMI160_HIGH_G_X_ENABLE:
-			/* write high_g_x interrupt*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_1_HIGH_G_X_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR_ENABLE_1_HIGH_G_X_ENABLE,
-				v_intr_enable_1_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-				dev_addr,
-				BMI160_USER_INTR_ENABLE_1_HIGH_G_X_ENABLE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		break;
-		case BMI160_HIGH_G_Y_ENABLE:
-			/* write high_g_y interrupt*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_1_HIGH_G_Y_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR_ENABLE_1_HIGH_G_Y_ENABLE,
-				v_intr_enable_1_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-				dev_addr,
-				BMI160_USER_INTR_ENABLE_1_HIGH_G_Y_ENABLE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		break;
-		case BMI160_HIGH_G_Z_ENABLE:
-			/* write high_g_z interrupt*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_1_HIGH_G_Z_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR_ENABLE_1_HIGH_G_Z_ENABLE,
-				v_intr_enable_1_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-				dev_addr,
-				BMI160_USER_INTR_ENABLE_1_HIGH_G_Z_ENABLE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		break;
-		case BMI160_LOW_G_ENABLE:
-			/* write low_g interrupt*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_1_LOW_G_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR_ENABLE_1_LOW_G_ENABLE,
-				v_intr_enable_1_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-				dev_addr,
-				BMI160_USER_INTR_ENABLE_1_LOW_G_ENABLE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		break;
-		case BMI160_DATA_RDY_ENABLE:
-			/* write data ready interrupt*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_1_DATA_RDY_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR_ENABLE_1_DATA_RDY_ENABLE,
-				v_intr_enable_1_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-				dev_addr,
-				BMI160_USER_INTR_ENABLE_1_DATA_RDY_ENABLE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		break;
-		case BMI160_FIFO_FULL_ENABLE:
-			/* write fifo full interrupt*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_1_FIFO_FULL_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR_ENABLE_1_FIFO_FULL_ENABLE,
-				v_intr_enable_1_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-				dev_addr,
-				BMI160_USER_INTR_ENABLE_1_FIFO_FULL_ENABLE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		break;
-		case BMI160_FIFO_WM_ENABLE:
-			/* write fifo water mark interrupt*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_ENABLE_1_FIFO_WM_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR_ENABLE_1_FIFO_WM_ENABLE,
-				v_intr_enable_1_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-				dev_addr,
-				BMI160_USER_INTR_ENABLE_1_FIFO_WM_ENABLE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-		break;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief  This API is used to read
- *	interrupt enable byte2 from the register bit 0x52 bit 0 to 3
- *	@brief It reads no motion x,y and z
- *
- *
- *
- *	@param v_enable_u8: The value of interrupt enable
- *   v_enable_u8   |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_NOMOTION_X_ENABLE
- *       1         | BMI160_NOMOTION_Y_ENABLE
- *       2         | BMI160_NOMOTION_Z_ENABLE
- *
- *	@param v_intr_enable_2_u8 : The interrupt enable value
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_enable_2(
-u8 v_enable_u8, u8 *v_intr_enable_2_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		switch (v_enable_u8) {
-		case BMI160_NOMOTION_X_ENABLE:
-			/* read no motion x */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_2_NOMOTION_X_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_enable_2_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ENABLE_2_NOMOTION_X_ENABLE);
-			break;
-		case BMI160_NOMOTION_Y_ENABLE:
-			/* read no motion y */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_2_NOMOTION_Y_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_enable_2_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ENABLE_2_NOMOTION_Y_ENABLE);
-			break;
-		case BMI160_NOMOTION_Z_ENABLE:
-			/* read no motion z */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_2_NOMOTION_Z_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_enable_2_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ENABLE_2_NOMOTION_Z_ENABLE);
-			break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-			break;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief  This API is used to set
- *	interrupt enable byte2 from the register bit 0x52 bit 0 to 3
- *	@brief It reads no motion x,y and z
- *
- *
- *
- *	@param v_enable_u8: The value of interrupt enable
- *   v_enable_u8   |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_NOMOTION_X_ENABLE
- *       1         | BMI160_NOMOTION_Y_ENABLE
- *       2         | BMI160_NOMOTION_Z_ENABLE
- *
- *	@param v_intr_enable_2_u8 : The interrupt enable value
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_enable_2(
-u8 v_enable_u8, u8 v_intr_enable_2_u8)
-{
-/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-	switch (v_enable_u8) {
-	case BMI160_NOMOTION_X_ENABLE:
-		/* write no motion x */
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr,
-		BMI160_USER_INTR_ENABLE_2_NOMOTION_X_ENABLE__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ENABLE_2_NOMOTION_X_ENABLE,
-			v_intr_enable_2_u8);
-			com_rslt +=
-			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_2_NOMOTION_X_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-		break;
-	case BMI160_NOMOTION_Y_ENABLE:
-		/* write no motion y */
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr,
-		BMI160_USER_INTR_ENABLE_2_NOMOTION_Y_ENABLE__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ENABLE_2_NOMOTION_Y_ENABLE,
-			v_intr_enable_2_u8);
-			com_rslt +=
-			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_2_NOMOTION_Y_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-		break;
-	case BMI160_NOMOTION_Z_ENABLE:
-		/* write no motion z */
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr,
-		BMI160_USER_INTR_ENABLE_2_NOMOTION_Z_ENABLE__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ENABLE_2_NOMOTION_Z_ENABLE,
-			v_intr_enable_2_u8);
-			com_rslt +=
-			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_2_NOMOTION_Z_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-		break;
-	default:
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		break;
-	}
-}
-return com_rslt;
-}
- /*!
- *	@brief This API is used to read
- *	interrupt enable step detector interrupt from
- *	the register bit 0x52 bit 3
- *
- *
- *
- *
- *	@param v_step_intr_u8 : The value of step detector interrupt enable
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_step_detector_enable(
-u8 *v_step_intr_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the step detector interrupt*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_2_STEP_DETECTOR_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_step_intr_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ENABLE_2_STEP_DETECTOR_ENABLE);
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API is used to set
- *	interrupt enable step detector interrupt from
- *	the register bit 0x52 bit 3
- *
- *
- *
- *
- *	@param v_step_intr_u8 : The value of step detector interrupt enable
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_step_detector_enable(
-u8 v_step_intr_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr,
-		BMI160_USER_INTR_ENABLE_2_STEP_DETECTOR_ENABLE__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ENABLE_2_STEP_DETECTOR_ENABLE,
-			v_step_intr_u8);
-			com_rslt +=
-			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr,
-			BMI160_USER_INTR_ENABLE_2_STEP_DETECTOR_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief  Configure trigger condition of interrupt1
- *	and interrupt2 pin from the register 0x53
- *	@brief interrupt1 - bit 0
- *	@brief interrupt2 - bit 4
- *
- *  @param v_channel_u8: The value of edge trigger selection
- *   v_channel_u8  |   Edge trigger
- *  ---------------|---------------
- *       0         | BMI160_INTR1_EDGE_CTRL
- *       1         | BMI160_INTR2_EDGE_CTRL
- *
- *	@param v_intr_edge_ctrl_u8 : The value of edge trigger enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_EDGE
- *  0x00     |  BMI160_LEVEL
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_edge_ctrl(
-u8 v_channel_u8, u8 *v_intr_edge_ctrl_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		switch (v_channel_u8) {
-		case BMI160_INTR1_EDGE_CTRL:
-			/* read the edge trigger interrupt1*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR1_EDGE_CTRL__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_edge_ctrl_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR1_EDGE_CTRL);
-			break;
-		case BMI160_INTR2_EDGE_CTRL:
-			/* read the edge trigger interrupt2*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR2_EDGE_CTRL__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_edge_ctrl_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR2_EDGE_CTRL);
-			break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-			break;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief  Configure trigger condition of interrupt1
- *	and interrupt2 pin from the register 0x53
- *	@brief interrupt1 - bit 0
- *	@brief interrupt2 - bit 4
- *
- *  @param v_channel_u8: The value of edge trigger selection
- *   v_channel_u8  |   Edge trigger
- *  ---------------|---------------
- *       0         | BMI160_INTR1_EDGE_CTRL
- *       1         | BMI160_INTR2_EDGE_CTRL
- *
- *	@param v_intr_edge_ctrl_u8 : The value of edge trigger enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_EDGE
- *  0x00     |  BMI160_LEVEL
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_edge_ctrl(
-u8 v_channel_u8, u8 v_intr_edge_ctrl_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		switch (v_channel_u8) {
-		case BMI160_INTR1_EDGE_CTRL:
-			/* write the edge trigger interrupt1*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR1_EDGE_CTRL__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR1_EDGE_CTRL,
-				v_intr_edge_ctrl_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-				dev_addr, BMI160_USER_INTR1_EDGE_CTRL__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-			break;
-		case BMI160_INTR2_EDGE_CTRL:
-			/* write the edge trigger interrupt2*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR2_EDGE_CTRL__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR2_EDGE_CTRL,
-				v_intr_edge_ctrl_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-				dev_addr, BMI160_USER_INTR2_EDGE_CTRL__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-			break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-			break;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief  API used for get the Configure level condition of interrupt1
- *	and interrupt2 pin form the register 0x53
- *	@brief interrupt1 - bit 1
- *	@brief interrupt2 - bit 5
- *
- *  @param v_channel_u8: The value of level condition selection
- *   v_channel_u8  |   level selection
- *  ---------------|---------------
- *       0         | BMI160_INTR1_LEVEL
- *       1         | BMI160_INTR2_LEVEL
- *
- *	@param v_intr_level_u8 : The value of level of interrupt enable
- *	value    | Behaviour
- * ----------|-------------------
- *  0x01     |  BMI160_LEVEL_HIGH
- *  0x00     |  BMI160_LEVEL_LOW
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_level(
-u8 v_channel_u8, u8 *v_intr_level_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		switch (v_channel_u8) {
-		case BMI160_INTR1_LEVEL:
-			/* read the interrupt1 level*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR1_LEVEL__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_level_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR1_LEVEL);
-			break;
-		case BMI160_INTR2_LEVEL:
-			/* read the interrupt2 level*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR2_LEVEL__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_level_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR2_LEVEL);
-			break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-			break;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief  API used for set the Configure level condition of interrupt1
- *	and interrupt2 pin form the register 0x53
- *	@brief interrupt1 - bit 1
- *	@brief interrupt2 - bit 5
- *
- *  @param v_channel_u8: The value of level condition selection
- *   v_channel_u8  |   level selection
- *  ---------------|---------------
- *       0         | BMI160_INTR1_LEVEL
- *       1         | BMI160_INTR2_LEVEL
- *
- *	@param v_intr_level_u8 : The value of level of interrupt enable
- *	value    | Behaviour
- * ----------|-------------------
- *  0x01     |  BMI160_LEVEL_HIGH
- *  0x00     |  BMI160_LEVEL_LOW
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_level(
-u8 v_channel_u8, u8 v_intr_level_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		switch (v_channel_u8) {
-		case BMI160_INTR1_LEVEL:
-			/* write the interrupt1 level*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR1_LEVEL__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR1_LEVEL, v_intr_level_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-				dev_addr, BMI160_USER_INTR1_LEVEL__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-			break;
-		case BMI160_INTR2_LEVEL:
-			/* write the interrupt2 level*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR2_LEVEL__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR2_LEVEL, v_intr_level_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-				dev_addr, BMI160_USER_INTR2_LEVEL__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-			break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-			break;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief  API used to get configured output enable of interrupt1
- *	and interrupt2 from the register 0x53
- *	@brief interrupt1 - bit 2
- *	@brief interrupt2 - bit 6
- *
- *
- *  @param v_channel_u8: The value of output type enable selection
- *   v_channel_u8  |   level selection
- *  ---------------|---------------
- *       0         | BMI160_INTR1_OUTPUT_TYPE
- *       1         | BMI160_INTR2_OUTPUT_TYPE
- *
- *	@param v_intr_output_type_u8 :
- *	The value of output type of interrupt enable
- *	value    | Behaviour
- * ----------|-------------------
- *  0x01     |  BMI160_OPEN_DRAIN
- *  0x00     |  BMI160_PUSH_PULL
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_output_type(
-u8 v_channel_u8, u8 *v_intr_output_type_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		switch (v_channel_u8) {
-		case BMI160_INTR1_OUTPUT_TYPE:
-			/* read the output type of interrupt1*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR1_OUTPUT_TYPE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_output_type_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR1_OUTPUT_TYPE);
-			break;
-		case BMI160_INTR2_OUTPUT_TYPE:
-			/* read the output type of interrupt2*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR2_OUTPUT_TYPE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_output_type_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR2_OUTPUT_TYPE);
-			break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-			break;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief  API used to set output enable of interrupt1
- *	and interrupt2 from the register 0x53
- *	@brief interrupt1 - bit 2
- *	@brief interrupt2 - bit 6
- *
- *
- *  @param v_channel_u8: The value of output type enable selection
- *   v_channel_u8  |   level selection
- *  ---------------|---------------
- *       0         | BMI160_INTR1_OUTPUT_TYPE
- *       1         | BMI160_INTR2_OUTPUT_TYPE
- *
- *	@param v_intr_output_type_u8 :
- *	The value of output type of interrupt enable
- *	value    | Behaviour
- * ----------|-------------------
- *  0x01     |  BMI160_OPEN_DRAIN
- *  0x00     |  BMI160_PUSH_PULL
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_output_type(
-u8 v_channel_u8, u8 v_intr_output_type_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		switch (v_channel_u8) {
-		case BMI160_INTR1_OUTPUT_TYPE:
-			/* write the output type of interrupt1*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR1_OUTPUT_TYPE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR1_OUTPUT_TYPE,
-				v_intr_output_type_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-				dev_addr, BMI160_USER_INTR1_OUTPUT_TYPE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-			break;
-		case BMI160_INTR2_OUTPUT_TYPE:
-			/* write the output type of interrupt2*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR2_OUTPUT_TYPE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR2_OUTPUT_TYPE,
-				v_intr_output_type_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-				dev_addr, BMI160_USER_INTR2_OUTPUT_TYPE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-			break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-			break;
-		}
-	}
-	return com_rslt;
-}
- /*!
- *	@brief API used to get the Output enable for interrupt1
- *	and interrupt1 pin from the register 0x53
- *	@brief interrupt1 - bit 3
- *	@brief interrupt2 - bit 7
- *
- *  @param v_channel_u8: The value of output enable selection
- *   v_channel_u8  |   level selection
- *  ---------------|---------------
- *       0         | BMI160_INTR1_OUTPUT_TYPE
- *       1         | BMI160_INTR2_OUTPUT_TYPE
- *
- *	@param v_output_enable_u8 :
- *	The value of output enable of interrupt enable
- *	value    | Behaviour
- * ----------|-------------------
- *  0x01     |  BMI160_INPUT
- *  0x00     |  BMI160_OUTPUT
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_output_enable(
-u8 v_channel_u8, u8 *v_output_enable_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		switch (v_channel_u8) {
-		case BMI160_INTR1_OUTPUT_ENABLE:
-			/* read the output enable of interrupt1*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR1_OUTPUT_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_output_enable_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR1_OUTPUT_ENABLE);
-			break;
-		case BMI160_INTR2_OUTPUT_ENABLE:
-			/* read the output enable of interrupt2*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR2_OUTPUT_EN__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_output_enable_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR2_OUTPUT_EN);
-			break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-			break;
-		}
-	}
-	return com_rslt;
-}
- /*!
- *	@brief API used to set the Output enable for interrupt1
- *	and interrupt1 pin from the register 0x53
- *	@brief interrupt1 - bit 3
- *	@brief interrupt2 - bit 7
- *
- *  @param v_channel_u8: The value of output enable selection
- *   v_channel_u8  |   level selection
- *  ---------------|---------------
- *       0         | BMI160_INTR1_OUTPUT_TYPE
- *       1         | BMI160_INTR2_OUTPUT_TYPE
- *
- *	@param v_output_enable_u8 :
- *	The value of output enable of interrupt enable
- *	value    | Behaviour
- * ----------|-------------------
- *  0x01     |  BMI160_INPUT
- *  0x00     |  BMI160_OUTPUT
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_output_enable(
-u8 v_channel_u8, u8 v_output_enable_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		switch (v_channel_u8) {
-		case BMI160_INTR1_OUTPUT_ENABLE:
-			/* write the output enable of interrupt1*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR1_OUTPUT_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR1_OUTPUT_ENABLE,
-				v_output_enable_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-				dev_addr, BMI160_USER_INTR1_OUTPUT_ENABLE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		break;
-		case BMI160_INTR2_OUTPUT_ENABLE:
-			/* write the output enable of interrupt2*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR2_OUTPUT_EN__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR2_OUTPUT_EN,
-				v_output_enable_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-				dev_addr, BMI160_USER_INTR2_OUTPUT_EN__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-		break;
-		}
-	}
-	return com_rslt;
-}
-/*!
-*	@brief This API is used to get the latch duration
-*	from the register 0x54 bit 0 to 3
-*	@brief This latch selection is not applicable for data ready,
-*	orientation and flat interrupts.
-*
-*
-*
-*  @param v_latch_intr_u8 : The value of latch duration
-*	Latch Duration                      |     value
-* --------------------------------------|------------------
-*    BMI160_LATCH_DUR_NONE              |      0x00
-*    BMI160_LATCH_DUR_312_5_MICRO_SEC   |      0x01
-*    BMI160_LATCH_DUR_625_MICRO_SEC     |      0x02
-*    BMI160_LATCH_DUR_1_25_MILLI_SEC    |      0x03
-*    BMI160_LATCH_DUR_2_5_MILLI_SEC     |      0x04
-*    BMI160_LATCH_DUR_5_MILLI_SEC       |      0x05
-*    BMI160_LATCH_DUR_10_MILLI_SEC      |      0x06
-*    BMI160_LATCH_DUR_20_MILLI_SEC      |      0x07
-*    BMI160_LATCH_DUR_40_MILLI_SEC      |      0x08
-*    BMI160_LATCH_DUR_80_MILLI_SEC      |      0x09
-*    BMI160_LATCH_DUR_160_MILLI_SEC     |      0x0A
-*    BMI160_LATCH_DUR_320_MILLI_SEC     |      0x0B
-*    BMI160_LATCH_DUR_640_MILLI_SEC     |      0x0C
-*    BMI160_LATCH_DUR_1_28_SEC          |      0x0D
-*    BMI160_LATCH_DUR_2_56_SEC          |      0x0E
-*    BMI160_LATCHED                     |      0x0F
-*
-*
-*
-*	@return results of bus communication function
-*	@retval 0 -> Success
-*	@retval -1 -> Error
-*
-*
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_latch_intr(
-u8 *v_latch_intr_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the latch duration value */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_LATCH__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_latch_intr_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_LATCH);
-		}
-	return com_rslt;
-}
-/*!
-*	@brief This API is used to set the latch duration
-*	from the register 0x54 bit 0 to 3
-*	@brief This latch selection is not applicable for data ready,
-*	orientation and flat interrupts.
-*
-*
-*
-*  @param v_latch_intr_u8 : The value of latch duration
-*	Latch Duration                      |     value
-* --------------------------------------|------------------
-*    BMI160_LATCH_DUR_NONE              |      0x00
-*    BMI160_LATCH_DUR_312_5_MICRO_SEC   |      0x01
-*    BMI160_LATCH_DUR_625_MICRO_SEC     |      0x02
-*    BMI160_LATCH_DUR_1_25_MILLI_SEC    |      0x03
-*    BMI160_LATCH_DUR_2_5_MILLI_SEC     |      0x04
-*    BMI160_LATCH_DUR_5_MILLI_SEC       |      0x05
-*    BMI160_LATCH_DUR_10_MILLI_SEC      |      0x06
-*    BMI160_LATCH_DUR_20_MILLI_SEC      |      0x07
-*    BMI160_LATCH_DUR_40_MILLI_SEC      |      0x08
-*    BMI160_LATCH_DUR_80_MILLI_SEC      |      0x09
-*    BMI160_LATCH_DUR_160_MILLI_SEC     |      0x0A
-*    BMI160_LATCH_DUR_320_MILLI_SEC     |      0x0B
-*    BMI160_LATCH_DUR_640_MILLI_SEC     |      0x0C
-*    BMI160_LATCH_DUR_1_28_SEC          |      0x0D
-*    BMI160_LATCH_DUR_2_56_SEC          |      0x0E
-*    BMI160_LATCHED                     |      0x0F
-*
-*
-*
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
-*
-*
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_latch_intr(u8 v_latch_intr_u8)
-{
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_latch_intr_u8 <= BMI160_MAX_LATCH_INTR) {
-			/* write the latch duration value */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_LATCH__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR_LATCH, v_latch_intr_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-				dev_addr, BMI160_USER_INTR_LATCH__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief API used to get input enable for interrupt1
- *	and interrupt2 pin from the register 0x54
- *	@brief interrupt1 - bit 4
- *	@brief interrupt2 - bit 5
- *
- *  @param v_channel_u8: The value of input enable selection
- *   v_channel_u8  |   input selection
- *  ---------------|---------------
- *       0         | BMI160_INTR1_INPUT_ENABLE
- *       1         | BMI160_INTR2_INPUT_ENABLE
- *
- *	@param v_input_en_u8 :
- *	The value of input enable of interrupt enable
- *	value    | Behaviour
- * ----------|-------------------
- *  0x01     |  BMI160_INPUT
- *  0x00     |  BMI160_OUTPUT
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_input_enable(
-u8 v_channel_u8, u8 *v_input_en_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		switch (v_channel_u8) {
-		/* read input enable of interrup1 and interrupt2*/
-		case BMI160_INTR1_INPUT_ENABLE:
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR1_INPUT_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_input_en_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR1_INPUT_ENABLE);
-			break;
-		case BMI160_INTR2_INPUT_ENABLE:
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR2_INPUT_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_input_en_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR2_INPUT_ENABLE);
-			break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-			break;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief API used to set input enable for interrupt1
- *	and interrupt2 pin from the register 0x54
- *	@brief interrupt1 - bit 4
- *	@brief interrupt2 - bit 5
- *
- *  @param v_channel_u8: The value of input enable selection
- *   v_channel_u8  |   input selection
- *  ---------------|---------------
- *       0         | BMI160_INTR1_INPUT_ENABLE
- *       1         | BMI160_INTR2_INPUT_ENABLE
- *
- *	@param v_input_en_u8 :
- *	The value of input enable of interrupt enable
- *	value    | Behaviour
- * ----------|-------------------
- *  0x01     |  BMI160_INPUT
- *  0x00     |  BMI160_OUTPUT
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_input_enable(
-u8 v_channel_u8, u8 v_input_en_u8)
-{
-/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-	switch (v_channel_u8) {
-	/* write input enable of interrup1 and interrupt2*/
-	case BMI160_INTR1_INPUT_ENABLE:
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr, BMI160_USER_INTR1_INPUT_ENABLE__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR1_INPUT_ENABLE, v_input_en_u8);
-			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR1_INPUT_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-	break;
-	case BMI160_INTR2_INPUT_ENABLE:
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr, BMI160_USER_INTR2_INPUT_ENABLE__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR2_INPUT_ENABLE, v_input_en_u8);
-			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR2_INPUT_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-	break;
-	default:
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-	break;
-	}
-}
-return com_rslt;
-}
- /*!
- *	@brief reads the Low g interrupt mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 0 in the register 0x55
- *	@brief interrupt2 bit 0 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of low_g selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_LOW_G
- *       1         | BMI160_INTR2_MAP_LOW_G
- *
- *	@param v_intr_low_g_u8 : The value of low_g enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_low_g(
-u8 v_channel_u8, u8 *v_intr_low_g_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		switch (v_channel_u8) {
-		/* read the low_g interrupt */
-		case BMI160_INTR1_MAP_LOW_G:
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_LOW_G__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_low_g_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_0_INTR1_LOW_G);
-			break;
-		case BMI160_INTR2_MAP_LOW_G:
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_LOW_G__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_low_g_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_2_INTR2_LOW_G);
-			break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-			break;
-		}
-	}
-	return com_rslt;
-}
- /*!
- *	@brief set the Low g interrupt mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 0 in the register 0x55
- *	@brief interrupt2 bit 0 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of low_g selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_LOW_G
- *       1         | BMI160_INTR2_MAP_LOW_G
- *
- *	@param v_intr_low_g_u8 : The value of low_g enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_low_g(
-u8 v_channel_u8, u8 v_intr_low_g_u8)
-{
-/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-u8 v_step_cnt_stat_u8 = BMI160_INIT_VALUE;
-u8 v_step_det_stat_u8 = BMI160_INIT_VALUE;
-
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-	/* check the step detector interrupt enable status*/
-	com_rslt = bmi160_get_step_detector_enable(&v_step_det_stat_u8);
-	/* disable the step detector interrupt */
-	if (v_step_det_stat_u8 != BMI160_INIT_VALUE)
-		com_rslt += bmi160_set_step_detector_enable(BMI160_INIT_VALUE);
-	/* check the step counter interrupt enable status*/
-	com_rslt += bmi160_get_step_counter_enable(&v_step_cnt_stat_u8);
-	/* disable the step counter interrupt */
-	if (v_step_cnt_stat_u8 != BMI160_INIT_VALUE)
-			com_rslt += bmi160_set_step_counter_enable(
-			BMI160_INIT_VALUE);
-	switch (v_channel_u8) {
-	/* write the low_g interrupt*/
-	case BMI160_INTR1_MAP_LOW_G:
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr, BMI160_USER_INTR_MAP_0_INTR1_LOW_G__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_0_INTR1_LOW_G, v_intr_low_g_u8);
-			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_LOW_G__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-		break;
-	case BMI160_INTR2_MAP_LOW_G:
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr, BMI160_USER_INTR_MAP_2_INTR2_LOW_G__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_2_INTR2_LOW_G, v_intr_low_g_u8);
-			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_LOW_G__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-		break;
-	default:
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		break;
-	}
-}
-return com_rslt;
-}
-/*!
- *	@brief Reads the HIGH g interrupt mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 1 in the register 0x55
- *	@brief interrupt2 bit 1 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of high_g selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_HIGH_G
- *       1         | BMI160_INTR2_MAP_HIGH_G
- *
- *	@param v_intr_high_g_u8 : The value of high_g enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_high_g(
-u8 v_channel_u8, u8 *v_intr_high_g_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		/* read the high_g interrupt*/
-		switch (v_channel_u8) {
-		case BMI160_INTR1_MAP_HIGH_G:
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_HIGH_G__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_high_g_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_0_INTR1_HIGH_G);
-		break;
-		case BMI160_INTR2_MAP_HIGH_G:
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_HIGH_G__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_high_g_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_2_INTR2_HIGH_G);
-		break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-			break;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief Write the HIGH g interrupt mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 1 in the register 0x55
- *	@brief interrupt2 bit 1 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of high_g selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_HIGH_G
- *       1         | BMI160_INTR2_MAP_HIGH_G
- *
- *	@param v_intr_high_g_u8 : The value of high_g enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_high_g(
-u8 v_channel_u8, u8 v_intr_high_g_u8)
-{
-/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-	switch (v_channel_u8) {
-	/* write the high_g interrupt*/
-	case BMI160_INTR1_MAP_HIGH_G:
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr, BMI160_USER_INTR_MAP_0_INTR1_HIGH_G__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_0_INTR1_HIGH_G, v_intr_high_g_u8);
-			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_HIGH_G__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-	break;
-	case BMI160_INTR2_MAP_HIGH_G:
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr, BMI160_USER_INTR_MAP_2_INTR2_HIGH_G__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_2_INTR2_HIGH_G, v_intr_high_g_u8);
-			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_HIGH_G__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-	break;
-	default:
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-	break;
-	}
-}
-return com_rslt;
-}
-/*!
- *	@brief Reads the Any motion interrupt
- *	interrupt mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 2 in the register 0x55
- *	@brief interrupt2 bit 2 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of any motion selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_ANY_MOTION
- *       1         | BMI160_INTR2_MAP_ANY_MOTION
- *
- *	@param v_intr_any_motion_u8 : The value of any motion enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_any_motion(
-u8 v_channel_u8, u8 *v_intr_any_motion_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		switch (v_channel_u8) {
-		/* read the any motion interrupt */
-		case BMI160_INTR1_MAP_ANY_MOTION:
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_ANY_MOTION__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_any_motion_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_0_INTR1_ANY_MOTION);
-		break;
-		case BMI160_INTR2_MAP_ANY_MOTION:
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_ANY_MOTION__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_any_motion_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_2_INTR2_ANY_MOTION);
-		break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-		break;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief Write the Any motion interrupt
- *	interrupt mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 2 in the register 0x55
- *	@brief interrupt2 bit 2 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of any motion selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_ANY_MOTION
- *       1         | BMI160_INTR2_MAP_ANY_MOTION
- *
- *	@param v_intr_any_motion_u8 : The value of any motion enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_any_motion(
-u8 v_channel_u8, u8 v_intr_any_motion_u8)
-{
-/* variable used for return the status of communication result*/
-BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-u8 sig_mot_stat = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-	/* read the status of significant motion interrupt */
-	com_rslt = bmi160_get_intr_significant_motion_select(&sig_mot_stat);
-	/* disable the significant motion interrupt */
-	if (sig_mot_stat != BMI160_INIT_VALUE)
-		com_rslt += bmi160_set_intr_significant_motion_select(
-		BMI160_INIT_VALUE);
-	switch (v_channel_u8) {
-	/* write the any motion interrupt */
-	case BMI160_INTR1_MAP_ANY_MOTION:
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr, BMI160_USER_INTR_MAP_0_INTR1_ANY_MOTION__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_0_INTR1_ANY_MOTION,
-			v_intr_any_motion_u8);
-			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_ANY_MOTION__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-	break;
-	case BMI160_INTR2_MAP_ANY_MOTION:
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr, BMI160_USER_INTR_MAP_2_INTR2_ANY_MOTION__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_2_INTR2_ANY_MOTION,
-			v_intr_any_motion_u8);
-			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_ANY_MOTION__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-	break;
-	default:
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-	break;
-	}
-}
-return com_rslt;
-}
-/*!
- *	@brief Reads the No motion interrupt
- *	interrupt mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 3 in the register 0x55
- *	@brief interrupt2 bit 3 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of no motion selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_NOMO
- *       1         | BMI160_INTR2_MAP_NOMO
- *
- *	@param v_intr_nomotion_u8 : The value of no motion enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_nomotion(
-u8 v_channel_u8, u8 *v_intr_nomotion_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		switch (v_channel_u8) {
-		/* read the no motion interrupt*/
-		case BMI160_INTR1_MAP_NOMO:
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_NOMOTION__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_nomotion_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_0_INTR1_NOMOTION);
-			break;
-		case BMI160_INTR2_MAP_NOMO:
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_NOMOTION__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_nomotion_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_2_INTR2_NOMOTION);
-			break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-			break;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief Write the No motion interrupt
- *	interrupt mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 3 in the register 0x55
- *	@brief interrupt2 bit 3 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of no motion selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_NOMO
- *       1         | BMI160_INTR2_MAP_NOMO
- *
- *	@param v_intr_nomotion_u8 : The value of no motion enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_nomotion(
-u8 v_channel_u8, u8 v_intr_nomotion_u8)
-{
-/* variable used for return the status of communication result*/
-BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-	switch (v_channel_u8) {
-	/* write the no motion interrupt*/
-	case BMI160_INTR1_MAP_NOMO:
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr, BMI160_USER_INTR_MAP_0_INTR1_NOMOTION__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_0_INTR1_NOMOTION,
-			v_intr_nomotion_u8);
-			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_NOMOTION__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-		break;
-	case BMI160_INTR2_MAP_NOMO:
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr, BMI160_USER_INTR_MAP_2_INTR2_NOMOTION__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_2_INTR2_NOMOTION,
-			v_intr_nomotion_u8);
-			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_NOMOTION__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-		break;
-	default:
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		break;
-	}
-}
-return com_rslt;
-}
-/*!
- *	@brief Reads the Double Tap interrupt
- *	interrupt mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 4 in the register 0x55
- *	@brief interrupt2 bit 4 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of double tap interrupt selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_DOUBLE_TAP
- *       1         | BMI160_INTR2_MAP_DOUBLE_TAP
- *
- *	@param v_intr_double_tap_u8 : The value of double tap enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_double_tap(
-u8 v_channel_u8, u8 *v_intr_double_tap_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		switch (v_channel_u8) {
-		case BMI160_INTR1_MAP_DOUBLE_TAP:
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_DOUBLE_TAP__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_double_tap_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_0_INTR1_DOUBLE_TAP);
-			break;
-		case BMI160_INTR2_MAP_DOUBLE_TAP:
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_DOUBLE_TAP__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_double_tap_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_2_INTR2_DOUBLE_TAP);
-			break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-			break;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief Write the Double Tap interrupt
- *	interrupt mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 4 in the register 0x55
- *	@brief interrupt2 bit 4 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of double tap interrupt selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_DOUBLE_TAP
- *       1         | BMI160_INTR2_MAP_DOUBLE_TAP
- *
- *	@param v_intr_double_tap_u8 : The value of double tap enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_double_tap(
-u8 v_channel_u8, u8 v_intr_double_tap_u8)
-{
-/* variable used for return the status of communication result*/
-BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-	switch (v_channel_u8) {
-	/* set the double tap interrupt */
-	case BMI160_INTR1_MAP_DOUBLE_TAP:
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr, BMI160_USER_INTR_MAP_0_INTR1_DOUBLE_TAP__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_0_INTR1_DOUBLE_TAP,
-			v_intr_double_tap_u8);
-			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_DOUBLE_TAP__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-		break;
-	case BMI160_INTR2_MAP_DOUBLE_TAP:
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr, BMI160_USER_INTR_MAP_2_INTR2_DOUBLE_TAP__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_2_INTR2_DOUBLE_TAP,
-			v_intr_double_tap_u8);
-			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_DOUBLE_TAP__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-		break;
-	default:
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		break;
-	}
-}
-return com_rslt;
-}
-/*!
- *	@brief Reads the Single Tap interrupt
- *	interrupt mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 5 in the register 0x55
- *	@brief interrupt2 bit 5 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of single tap interrupt selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_SINGLE_TAP
- *       1         | BMI160_INTR2_MAP_SINGLE_TAP
- *
- *	@param v_intr_single_tap_u8 : The value of single tap  enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_single_tap(
-u8 v_channel_u8, u8 *v_intr_single_tap_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		switch (v_channel_u8) {
-		/* reads the single tap interrupt*/
-		case BMI160_INTR1_MAP_SINGLE_TAP:
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_SINGLE_TAP__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_single_tap_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_0_INTR1_SINGLE_TAP);
-			break;
-		case BMI160_INTR2_MAP_SINGLE_TAP:
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_SINGLE_TAP__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_single_tap_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_2_INTR2_SINGLE_TAP);
-			break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-			break;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief Write the Single Tap interrupt
- *	interrupt mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 5 in the register 0x55
- *	@brief interrupt2 bit 5 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of single tap interrupt selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_SINGLE_TAP
- *       1         | BMI160_INTR2_MAP_SINGLE_TAP
- *
- *	@param v_intr_single_tap_u8 : The value of single tap  enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_single_tap(
-u8 v_channel_u8, u8 v_intr_single_tap_u8)
-{
-/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-	switch (v_channel_u8) {
-	/* write the single tap interrupt */
-	case BMI160_INTR1_MAP_SINGLE_TAP:
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr, BMI160_USER_INTR_MAP_0_INTR1_SINGLE_TAP__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_0_INTR1_SINGLE_TAP,
-			v_intr_single_tap_u8);
-			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_SINGLE_TAP__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-		break;
-	case BMI160_INTR2_MAP_SINGLE_TAP:
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr, BMI160_USER_INTR_MAP_2_INTR2_SINGLE_TAP__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_2_INTR2_SINGLE_TAP,
-			v_intr_single_tap_u8);
-			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_SINGLE_TAP__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-		break;
-	default:
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		break;
-	}
-}
-return com_rslt;
-}
-/*!
- *	@brief Reads the Orient interrupt
- *	interrupt mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 6 in the register 0x55
- *	@brief interrupt2 bit 6 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of orient interrupt selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_ORIENT
- *       1         | BMI160_INTR2_MAP_ORIENT
- *
- *	@param v_intr_orient_u8 : The value of orient enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_orient(
-u8 v_channel_u8, u8 *v_intr_orient_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		switch (v_channel_u8) {
-		/* read the orientation interrupt*/
-		case BMI160_INTR1_MAP_ORIENT:
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_ORIENT__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_orient_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_0_INTR1_ORIENT);
-			break;
-		case BMI160_INTR2_MAP_ORIENT:
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_ORIENT__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_orient_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_2_INTR2_ORIENT);
-			break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-			break;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief Write the Orient interrupt
- *	interrupt mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 6 in the register 0x55
- *	@brief interrupt2 bit 6 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of orient interrupt selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_ORIENT
- *       1         | BMI160_INTR2_MAP_ORIENT
- *
- *	@param v_intr_orient_u8 : The value of orient enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_orient(
-u8 v_channel_u8, u8 v_intr_orient_u8)
-{
-/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-	switch (v_channel_u8) {
-	/* write the orientation interrupt*/
-	case BMI160_INTR1_MAP_ORIENT:
-		com_rslt =
-		p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr, BMI160_USER_INTR_MAP_0_INTR1_ORIENT__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_0_INTR1_ORIENT, v_intr_orient_u8);
-			com_rslt +=
-			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_ORIENT__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-		break;
-	case BMI160_INTR2_MAP_ORIENT:
-		com_rslt =
-		p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr, BMI160_USER_INTR_MAP_2_INTR2_ORIENT__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 =
-			BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_2_INTR2_ORIENT, v_intr_orient_u8);
-			com_rslt +=
-			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_ORIENT__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-		break;
-	default:
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		break;
-	}
-}
-return com_rslt;
-}
- /*!
- *	@brief Reads the Flat interrupt
- *	mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 7 in the register 0x55
- *	@brief interrupt2 bit 7 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of flat interrupt selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_FLAT
- *       1         | BMI160_INTR2_MAP_FLAT
- *
- *	@param v_intr_flat_u8 : The value of flat enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_flat(
-u8 v_channel_u8, u8 *v_intr_flat_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		switch (v_channel_u8) {
-		/* read the flat interrupt*/
-		case BMI160_INTR1_MAP_FLAT:
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_FLAT__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_flat_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_0_INTR1_FLAT);
-			break;
-		case BMI160_INTR2_MAP_FLAT:
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_FLAT__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_flat_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_2_INTR2_FLAT);
-			break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-			break;
-		}
-	}
-	return com_rslt;
-}
- /*!
- *	@brief Write the Flat interrupt
- *	mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 7 in the register 0x55
- *	@brief interrupt2 bit 7 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of flat interrupt selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_FLAT
- *       1         | BMI160_INTR2_MAP_FLAT
- *
- *	@param v_intr_flat_u8 : The value of flat enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_flat(
-u8 v_channel_u8, u8 v_intr_flat_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		switch (v_channel_u8) {
-		/* write the flat interrupt */
-		case BMI160_INTR1_MAP_FLAT:
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_FLAT__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 =
-				BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR_MAP_0_INTR1_FLAT,
-				v_intr_flat_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-				dev_addr,
-				BMI160_USER_INTR_MAP_0_INTR1_FLAT__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-			break;
-		case BMI160_INTR2_MAP_FLAT:
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_FLAT__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR_MAP_2_INTR2_FLAT,
-				v_intr_flat_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-				dev_addr,
-				BMI160_USER_INTR_MAP_2_INTR2_FLAT__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-			break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-			break;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief Reads PMU trigger interrupt mapped to interrupt1
- *	and interrupt2 form the register 0x56 bit 0 and 4
- *	@brief interrupt1 bit 0 in the register 0x56
- *	@brief interrupt2 bit 4 in the register 0x56
- *
- *
- *	@param v_channel_u8: The value of pmu trigger selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_PMUTRIG
- *       1         | BMI160_INTR2_MAP_PMUTRIG
- *
- *	@param v_intr_pmu_trig_u8 : The value of pmu trigger enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_pmu_trig(
-u8 v_channel_u8, u8 *v_intr_pmu_trig_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		switch (v_channel_u8) {
-		/* read the pmu trigger interrupt*/
-		case BMI160_INTR1_MAP_PMUTRIG:
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_1_INTR1_PMU_TRIG__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_pmu_trig_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_1_INTR1_PMU_TRIG);
-			break;
-		case BMI160_INTR2_MAP_PMUTRIG:
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_1_INTR2_PMU_TRIG__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_pmu_trig_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_1_INTR2_PMU_TRIG);
-			break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-			break;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief Write PMU trigger interrupt mapped to interrupt1
- *	and interrupt2 form the register 0x56 bit 0 and 4
- *	@brief interrupt1 bit 0 in the register 0x56
- *	@brief interrupt2 bit 4 in the register 0x56
- *
- *
- *	@param v_channel_u8: The value of pmu trigger selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_PMUTRIG
- *       1         | BMI160_INTR2_MAP_PMUTRIG
- *
- *	@param v_intr_pmu_trig_u8 : The value of pmu trigger enable
- *	value    | trigger enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_pmu_trig(
-u8 v_channel_u8, u8 v_intr_pmu_trig_u8)
-{
-/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-	switch (v_channel_u8) {
-	/* write the pmu trigger interrupt */
-	case BMI160_INTR1_MAP_PMUTRIG:
-		com_rslt =
-		p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr, BMI160_USER_INTR_MAP_1_INTR1_PMU_TRIG__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 =
-			BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_1_INTR1_PMU_TRIG,
-			v_intr_pmu_trig_u8);
-			com_rslt +=
-			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_1_INTR1_PMU_TRIG__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-	break;
-	case BMI160_INTR2_MAP_PMUTRIG:
-		com_rslt =
-		p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr, BMI160_USER_INTR_MAP_1_INTR2_PMU_TRIG__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 =
-			BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_1_INTR2_PMU_TRIG,
-			v_intr_pmu_trig_u8);
-			com_rslt +=
-			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_1_INTR2_PMU_TRIG__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-	break;
-	default:
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-	break;
-	}
-}
-return com_rslt;
-}
-/*!
- *	@brief Reads FIFO Full interrupt mapped to interrupt1
- *	and interrupt2 form the register 0x56 bit 5 and 1
- *	@brief interrupt1 bit 5 in the register 0x56
- *	@brief interrupt2 bit 1 in the register 0x56
- *
- *
- *	@param v_channel_u8: The value of fifo full interrupt selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_FIFO_FULL
- *       1         | BMI160_INTR2_MAP_FIFO_FULL
- *
- *	@param v_intr_fifo_full_u8 : The value of fifo full interrupt enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_fifo_full(
-u8 v_channel_u8, u8 *v_intr_fifo_full_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		switch (v_channel_u8) {
-		/* read the fifo full interrupt */
-		case BMI160_INTR1_MAP_FIFO_FULL:
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_1_INTR1_FIFO_FULL__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_fifo_full_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_1_INTR1_FIFO_FULL);
-		break;
-		case BMI160_INTR2_MAP_FIFO_FULL:
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_1_INTR2_FIFO_FULL__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_fifo_full_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_1_INTR2_FIFO_FULL);
-		break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-		break;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief Write FIFO Full interrupt mapped to interrupt1
- *	and interrupt2 form the register 0x56 bit 5 and 1
- *	@brief interrupt1 bit 5 in the register 0x56
- *	@brief interrupt2 bit 1 in the register 0x56
- *
- *
- *	@param v_channel_u8: The value of fifo full interrupt selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_FIFO_FULL
- *       1         | BMI160_INTR2_MAP_FIFO_FULL
- *
- *	@param v_intr_fifo_full_u8 : The value of fifo full interrupt enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_fifo_full(
-u8 v_channel_u8, u8 v_intr_fifo_full_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		switch (v_channel_u8) {
-		/* write the fifo full interrupt */
-		case BMI160_INTR1_MAP_FIFO_FULL:
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_1_INTR1_FIFO_FULL__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 =
-				BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR_MAP_1_INTR1_FIFO_FULL,
-				v_intr_fifo_full_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-				dev_addr,
-				BMI160_USER_INTR_MAP_1_INTR1_FIFO_FULL__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		break;
-		case BMI160_INTR2_MAP_FIFO_FULL:
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_1_INTR2_FIFO_FULL__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 =
-				BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR_MAP_1_INTR2_FIFO_FULL,
-				v_intr_fifo_full_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-				dev_addr,
-				BMI160_USER_INTR_MAP_1_INTR2_FIFO_FULL__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-		break;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief Reads FIFO Watermark interrupt mapped to interrupt1
- *	and interrupt2 form the register 0x56 bit 6 and 2
- *	@brief interrupt1 bit 6 in the register 0x56
- *	@brief interrupt2 bit 2 in the register 0x56
- *
- *
- *	@param v_channel_u8: The value of fifo Watermark interrupt selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_FIFO_WM
- *       1         | BMI160_INTR2_MAP_FIFO_WM
- *
- *	@param v_intr_fifo_wm_u8 : The value of fifo Watermark interrupt enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_fifo_wm(
-u8 v_channel_u8, u8 *v_intr_fifo_wm_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		switch (v_channel_u8) {
-		/* read the fifo water mark interrupt */
-		case BMI160_INTR1_MAP_FIFO_WM:
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_1_INTR1_FIFO_WM__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_fifo_wm_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_1_INTR1_FIFO_WM);
-			break;
-		case BMI160_INTR2_MAP_FIFO_WM:
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_1_INTR2_FIFO_WM__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_fifo_wm_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_1_INTR2_FIFO_WM);
-			break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-			break;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief Write FIFO Watermark interrupt mapped to interrupt1
- *	and interrupt2 form the register 0x56 bit 6 and 2
- *	@brief interrupt1 bit 6 in the register 0x56
- *	@brief interrupt2 bit 2 in the register 0x56
- *
- *
- *	@param v_channel_u8: The value of fifo Watermark interrupt selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_FIFO_WM
- *       1         | BMI160_INTR2_MAP_FIFO_WM
- *
- *	@param v_intr_fifo_wm_u8 : The value of fifo Watermark interrupt enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_fifo_wm(
-u8 v_channel_u8, u8 v_intr_fifo_wm_u8)
-{
-/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		switch (v_channel_u8) {
-		/* write the fifo water mark interrupt */
-		case BMI160_INTR1_MAP_FIFO_WM:
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_1_INTR1_FIFO_WM__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR_MAP_1_INTR1_FIFO_WM,
-				v_intr_fifo_wm_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-				dev_addr,
-				BMI160_USER_INTR_MAP_1_INTR1_FIFO_WM__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-			break;
-		case BMI160_INTR2_MAP_FIFO_WM:
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_1_INTR2_FIFO_WM__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR_MAP_1_INTR2_FIFO_WM,
-				v_intr_fifo_wm_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-				dev_addr,
-				BMI160_USER_INTR_MAP_1_INTR2_FIFO_WM__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-			break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-			break;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief Reads Data Ready interrupt mapped to interrupt1
- *	and interrupt2 form the register 0x56
- *	@brief interrupt1 bit 7 in the register 0x56
- *	@brief interrupt2 bit 3 in the register 0x56
- *
- *
- *	@param v_channel_u8: The value of data ready interrupt selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_DATA_RDY
- *       1         | BMI160_INTR2_MAP_DATA_RDY
- *
- *	@param v_intr_data_rdy_u8 : The value of data ready interrupt enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_data_rdy(
-u8 v_channel_u8, u8 *v_intr_data_rdy_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		switch (v_channel_u8) {
-		/*Read Data Ready interrupt*/
-		case BMI160_INTR1_MAP_DATA_RDY:
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_1_INTR1_DATA_RDY__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_data_rdy_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_1_INTR1_DATA_RDY);
-			break;
-		case BMI160_INTR2_MAP_DATA_RDY:
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_1_INTR2_DATA_RDY__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_data_rdy_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_1_INTR2_DATA_RDY);
-			break;
-		default:
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-			break;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief Write Data Ready interrupt mapped to interrupt1
- *	and interrupt2 form the register 0x56
- *	@brief interrupt1 bit 7 in the register 0x56
- *	@brief interrupt2 bit 3 in the register 0x56
- *
- *
- *	@param v_channel_u8: The value of data ready interrupt selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_DATA_RDY
- *       1         | BMI160_INTR2_MAP_DATA_RDY
- *
- *	@param v_intr_data_rdy_u8 : The value of data ready interrupt enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_data_rdy(
-u8 v_channel_u8, u8 v_intr_data_rdy_u8)
-{
-/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-	switch (v_channel_u8) {
-	/*Write Data Ready interrupt*/
-	case BMI160_INTR1_MAP_DATA_RDY:
-		com_rslt =
-		p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr, BMI160_USER_INTR_MAP_1_INTR1_DATA_RDY__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_1_INTR1_DATA_RDY,
-			v_intr_data_rdy_u8);
-			com_rslt +=
-			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_1_INTR1_DATA_RDY__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-	break;
-	case BMI160_INTR2_MAP_DATA_RDY:
-		com_rslt =
-		p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
-		dev_addr, BMI160_USER_INTR_MAP_1_INTR2_DATA_RDY__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MAP_1_INTR2_DATA_RDY,
-			v_intr_data_rdy_u8);
-			com_rslt +=
-			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
-			dev_addr, BMI160_USER_INTR_MAP_1_INTR2_DATA_RDY__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-	break;
-	default:
-	com_rslt = E_BMI160_OUT_OF_RANGE;
-	break;
-	}
-}
-return com_rslt;
-}
- /*!
- *	@brief This API reads data source for the interrupt
- *	engine for the single and double tap interrupts from the register
- *	0x58 bit 3
- *
- *
- *  @param v_tap_source_u8 : The value of the tap source
- *	value    | Description
- * ----------|-------------------
- *  0x01     |  UNFILTER_DATA
- *  0x00     |  FILTER_DATA
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_tap_source(u8 *v_tap_source_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the tap source interrupt */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_INTR_DATA_0_INTR_TAP_SOURCE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_tap_source_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_DATA_0_INTR_TAP_SOURCE);
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API write data source for the interrupt
- *	engine for the single and double tap interrupts from the register
- *	0x58 bit 3
- *
- *
- *  @param v_tap_source_u8 : The value of the tap source
- *	value    | Description
- * ----------|-------------------
- *  0x01     |  UNFILTER_DATA
- *  0x00     |  FILTER_DATA
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_tap_source(
-u8 v_tap_source_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_tap_source_u8 <= BMI160_MAX_VALUE_SOURCE_INTR) {
-			/* write the tap source interrupt */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_INTR_DATA_0_INTR_TAP_SOURCE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR_DATA_0_INTR_TAP_SOURCE,
-				v_tap_source_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
-				(p_bmi160->dev_addr,
-				BMI160_USER_INTR_DATA_0_INTR_TAP_SOURCE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
- /*!
- *	@brief This API Reads Data source for the
- *	interrupt engine for the low and high g interrupts
- *	from the register 0x58 bit 7
- *
- *  @param v_low_high_source_u8 : The value of the tap source
- *	value    | Description
- * ----------|-------------------
- *  0x01     |  UNFILTER_DATA
- *  0x00     |  FILTER_DATA
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_low_high_source(
-u8 *v_low_high_source_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the high_low_g source interrupt */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_INTR_DATA_0_INTR_LOW_HIGH_SOURCE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_low_high_source_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_DATA_0_INTR_LOW_HIGH_SOURCE);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API write Data source for the
- *	interrupt engine for the low and high g interrupts
- *	from the register 0x58 bit 7
- *
- *  @param v_low_high_source_u8 : The value of the tap source
- *	value    | Description
- * ----------|-------------------
- *  0x01     |  UNFILTER_DATA
- *  0x00     |  FILTER_DATA
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_low_high_source(
-u8 v_low_high_source_u8)
-{
-/* variable used for return the status of communication result*/
-BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-	if (v_low_high_source_u8 <= BMI160_MAX_VALUE_SOURCE_INTR) {
-		/* write the high_low_g source interrupt */
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-		(p_bmi160->dev_addr,
-		BMI160_USER_INTR_DATA_0_INTR_LOW_HIGH_SOURCE__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_DATA_0_INTR_LOW_HIGH_SOURCE,
-			v_low_high_source_u8);
-			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_INTR_DATA_0_INTR_LOW_HIGH_SOURCE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-	} else {
-	com_rslt = E_BMI160_OUT_OF_RANGE;
-	}
-}
-return com_rslt;
-}
- /*!
- *	@brief This API reads Data source for the
- *	interrupt engine for the nomotion and anymotion interrupts
- *	from the register 0x59 bit 7
- *
- *  @param v_motion_source_u8 :
- *	The value of the any/no motion interrupt source
- *	value    | Description
- * ----------|-------------------
- *  0x01     |  UNFILTER_DATA
- *  0x00     |  FILTER_DATA
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_motion_source(
-u8 *v_motion_source_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the any/no motion interrupt  */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_INTR_DATA_1_INTR_MOTION_SOURCE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_motion_source_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_DATA_1_INTR_MOTION_SOURCE);
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API write Data source for the
- *	interrupt engine for the nomotion and anymotion interrupts
- *	from the register 0x59 bit 7
- *
- *  @param v_motion_source_u8 :
- *	The value of the any/no motion interrupt source
- *	value    | Description
- * ----------|-------------------
- *  0x01     |  UNFILTER_DATA
- *  0x00     |  FILTER_DATA
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_motion_source(
-u8 v_motion_source_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_motion_source_u8 <= BMI160_MAX_VALUE_SOURCE_INTR) {
-			/* write the any/no motion interrupt  */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_INTR_DATA_1_INTR_MOTION_SOURCE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR_DATA_1_INTR_MOTION_SOURCE,
-				v_motion_source_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_INTR_DATA_1_INTR_MOTION_SOURCE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
- /*!
- *	@brief This API is used to read the low_g duration from register
- *	0x5A bit 0 to 7
- *
- *
- *
- *
- *  @param v_low_g_durn_u8 : The value of low_g duration
- *
- *	@note Low_g duration trigger trigger delay according to
- *	"(v_low_g_durn_u8 * 2.5)ms" in a range from 2.5ms to 640ms.
- *	the default corresponds delay is 20ms
- *	@note When low_g data source of interrupt is unfiltered
- *	the sensor must not be in low power mode
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_low_g_durn(
-u8 *v_low_g_durn_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the low_g interrupt */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_INTR_LOWHIGH_0_INTR_LOW_DURN__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_low_g_durn_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_LOWHIGH_0_INTR_LOW_DURN);
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API is used to write the low_g duration from register
- *	0x5A bit 0 to 7
- *
- *
- *
- *
- *  @param v_low_g_durn_u8 : The value of low_g duration
- *
- *	@note Low_g duration trigger trigger delay according to
- *	"(v_low_g_durn_u8 * 2.5)ms" in a range from 2.5ms to 640ms.
- *	the default corresponds delay is 20ms
- *	@note When low_g data source of interrupt is unfiltered
- *	the sensor must not be in low power mode
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_low_g_durn(u8 v_low_g_durn_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* write the low_g interrupt */
-			com_rslt = p_bmi160->BMI160_BUS_WRITE_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_INTR_LOWHIGH_0_INTR_LOW_DURN__REG,
-			&v_low_g_durn_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to read Threshold
- *	definition for the low-g interrupt from the register 0x5B bit 0 to 7
- *
- *
- *
- *
- *  @param v_low_g_thres_u8 : The value of low_g threshold
- *
- *	@note Low_g interrupt trigger threshold according to
- *	(v_low_g_thres_u8 * 7.81)mg for v_low_g_thres_u8 > 0
- *	3.91 mg for v_low_g_thres_u8 = 0
- *	The threshold range is form 3.91mg to 2.000mg
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_low_g_thres(
-u8 *v_low_g_thres_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read low_g threshold */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_INTR_LOWHIGH_1_INTR_LOW_THRES__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_low_g_thres_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_LOWHIGH_1_INTR_LOW_THRES);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to write Threshold
- *	definition for the low-g interrupt from the register 0x5B bit 0 to 7
- *
- *
- *
- *
- *  @param v_low_g_thres_u8 : The value of low_g threshold
- *
- *	@note Low_g interrupt trigger threshold according to
- *	(v_low_g_thres_u8 * 7.81)mg for v_low_g_thres_u8 > 0
- *	3.91 mg for v_low_g_thres_u8 = 0
- *	The threshold range is form 3.91mg to 2.000mg
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_low_g_thres(
-u8 v_low_g_thres_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* write low_g threshold */
-			com_rslt = p_bmi160->BMI160_BUS_WRITE_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_INTR_LOWHIGH_1_INTR_LOW_THRES__REG,
-			&v_low_g_thres_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API Reads Low-g interrupt hysteresis
- *	from the register 0x5C bit 0 to 1
- *
- *  @param v_low_hyst_u8 :The value of low_g hysteresis
- *
- *	@note Low_g hysteresis calculated by v_low_hyst_u8*125 mg
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_low_g_hyst(
-u8 *v_low_hyst_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read low_g hysteresis*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_HYST__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_low_hyst_u8 = BMI160_GET_BITSLICE(
-			v_data_u8,
-			BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_HYST);
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API write Low-g interrupt hysteresis
- *	from the register 0x5C bit 0 to 1
- *
- *  @param v_low_hyst_u8 :The value of low_g hysteresis
- *
- *	@note Low_g hysteresis calculated by v_low_hyst_u8*125 mg
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_low_g_hyst(
-u8 v_low_hyst_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* write low_g hysteresis*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_HYST__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_HYST,
-				v_low_hyst_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_HYST__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads Low-g interrupt mode
- *	from the register 0x5C bit 2
- *
- *  @param v_low_g_mode_u8 : The value of low_g mode
- *	Value    |  Description
- * ----------|-----------------
- *	   0     | single-axis
- *     1     | axis-summing
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_low_g_mode(u8 *v_low_g_mode_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/*read Low-g interrupt mode*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_MODE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_low_g_mode_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_MODE);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API write Low-g interrupt mode
- *	from the register 0x5C bit 2
- *
- *  @param v_low_g_mode_u8 : The value of low_g mode
- *	Value    |  Description
- * ----------|-----------------
- *	   0     | single-axis
- *     1     | axis-summing
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_low_g_mode(
-u8 v_low_g_mode_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_low_g_mode_u8 <= BMI160_MAX_VALUE_LOW_G_MODE) {
-			/*write Low-g interrupt mode*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_MODE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_MODE,
-				v_low_g_mode_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_MODE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads High-g interrupt hysteresis
- *	from the register 0x5C bit 6 and 7
- *
- *  @param v_high_g_hyst_u8 : The value of high hysteresis
- *
- *	@note High_g hysteresis changes according to accel g range
- *	accel g range can be set by the function ""
- *   accel_range    | high_g hysteresis
- *  ----------------|---------------------
- *      2g          |  high_hy*125 mg
- *      4g          |  high_hy*250 mg
- *      8g          |  high_hy*500 mg
- *      16g         |  high_hy*1000 mg
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_high_g_hyst(
-u8 *v_high_g_hyst_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read high_g hysteresis*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_INTR_LOWHIGH_2_INTR_HIGH_G_HYST__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_high_g_hyst_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_LOWHIGH_2_INTR_HIGH_G_HYST);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API write High-g interrupt hysteresis
- *	from the register 0x5C bit 6 and 7
- *
- *  @param v_high_g_hyst_u8 : The value of high hysteresis
- *
- *	@note High_g hysteresis changes according to accel g range
- *	accel g range can be set by the function ""
- *   accel_range    | high_g hysteresis
- *  ----------------|---------------------
- *      2g          |  high_hy*125 mg
- *      4g          |  high_hy*250 mg
- *      8g          |  high_hy*500 mg
- *      16g         |  high_hy*1000 mg
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_high_g_hyst(
-u8 v_high_g_hyst_u8)
-{
-/* variable used for return the status of communication result*/
-BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-		/* write high_g hysteresis*/
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-		p_bmi160->dev_addr,
-		BMI160_USER_INTR_LOWHIGH_2_INTR_HIGH_G_HYST__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_LOWHIGH_2_INTR_HIGH_G_HYST,
-			v_high_g_hyst_u8);
-			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_INTR_LOWHIGH_2_INTR_HIGH_G_HYST__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-	}
-return com_rslt;
-}
-/*!
- *	@brief This API is used to read Delay
- *	time definition for the high-g interrupt from the register
- *	0x5D bit 0 to 7
- *
- *
- *
- *  @param  v_high_g_durn_u8 :  The value of high duration
- *
- *	@note High_g interrupt delay triggered according to
- *	v_high_g_durn_u8 * 2.5ms in a range from 2.5ms to 640ms
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_high_g_durn(
-u8 *v_high_g_durn_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read high_g duration*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_INTR_LOWHIGH_3_INTR_HIGH_G_DURN__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_high_g_durn_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_LOWHIGH_3_INTR_HIGH_G_DURN);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to write Delay
- *	time definition for the high-g interrupt from the register
- *	0x5D bit 0 to 7
- *
- *
- *
- *  @param  v_high_g_durn_u8 :  The value of high duration
- *
- *	@note High_g interrupt delay triggered according to
- *	v_high_g_durn_u8 * 2.5ms in a range from 2.5ms to 640ms
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_high_g_durn(
-u8 v_high_g_durn_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* write high_g duration*/
-			com_rslt = p_bmi160->BMI160_BUS_WRITE_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_INTR_LOWHIGH_3_INTR_HIGH_G_DURN__REG,
-			&v_high_g_durn_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to read Threshold
- *	definition for the high-g interrupt from the register 0x5E 0 to 7
- *
- *
- *
- *
- *  @param  v_high_g_thres_u8 : Pointer holding the value of Threshold
- *	@note High_g threshold changes according to accel g range
- *	accel g range can be set by the function ""
- *   accel_range    | high_g threshold
- *  ----------------|---------------------
- *      2g          |  v_high_g_thres_u8*7.81 mg
- *      4g          |  v_high_g_thres_u8*15.63 mg
- *      8g          |  v_high_g_thres_u8*31.25 mg
- *      16g         |  v_high_g_thres_u8*62.5 mg
- *	@note when v_high_g_thres_u8 = 0
- *   accel_range    | high_g threshold
- *  ----------------|---------------------
- *      2g          |  3.91 mg
- *      4g          |  7.81 mg
- *      8g          |  15.63 mg
- *      16g         |  31.25 mg
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_high_g_thres(
-u8 *v_high_g_thres_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_INTR_LOWHIGH_4_INTR_HIGH_THRES__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_high_g_thres_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_LOWHIGH_4_INTR_HIGH_THRES);
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to write Threshold
- *	definition for the high-g interrupt from the register 0x5E 0 to 7
- *
- *
- *
- *
- *  @param  v_high_g_thres_u8 : Pointer holding the value of Threshold
- *	@note High_g threshold changes according to accel g range
- *	accel g range can be set by the function ""
- *   accel_range    | high_g threshold
- *  ----------------|---------------------
- *      2g          |  v_high_g_thres_u8*7.81 mg
- *      4g          |  v_high_g_thres_u8*15.63 mg
- *      8g          |  v_high_g_thres_u8*31.25 mg
- *      16g         |  v_high_g_thres_u8*62.5 mg
- *	@note when v_high_g_thres_u8 = 0
- *   accel_range    | high_g threshold
- *  ----------------|---------------------
- *      2g          |  3.91 mg
- *      4g          |  7.81 mg
- *      8g          |  15.63 mg
- *      16g         |  31.25 mg
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_high_g_thres(
-u8 v_high_g_thres_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		com_rslt = p_bmi160->BMI160_BUS_WRITE_FUNC(
-		p_bmi160->dev_addr,
-		BMI160_USER_INTR_LOWHIGH_4_INTR_HIGH_THRES__REG,
-		&v_high_g_thres_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads any motion duration
- *	from the register 0x5F bit 0 and 1
- *
- *  @param v_any_motion_durn_u8 : The value of any motion duration
- *
- *	@note Any motion duration can be calculated by "v_any_motion_durn_u8 + 1"
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_any_motion_durn(
-u8 *v_any_motion_durn_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		/* read any motion duration*/
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-		(p_bmi160->dev_addr,
-		BMI160_USER_INTR_MOTION_0_INTR_ANY_MOTION_DURN__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		*v_any_motion_durn_u8 = BMI160_GET_BITSLICE
-		(v_data_u8,
-		BMI160_USER_INTR_MOTION_0_INTR_ANY_MOTION_DURN);
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API write any motion duration
- *	from the register 0x5F bit 0 and 1
- *
- *  @param v_any_motion_durn_u8 : The value of any motion duration
- *
- *	@note Any motion duration can be calculated by "v_any_motion_durn_u8 + 1"
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_any_motion_durn(
-u8 v_any_motion_durn_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		/* write any motion duration*/
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-		(p_bmi160->dev_addr,
-		BMI160_USER_INTR_MOTION_0_INTR_ANY_MOTION_DURN__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MOTION_0_INTR_ANY_MOTION_DURN,
-			v_any_motion_durn_u8);
-			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_INTR_MOTION_0_INTR_ANY_MOTION_DURN__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-	}
-	return com_rslt;
-}
- /*!
- *	@brief This API read Slow/no-motion
- *	interrupt trigger delay duration from the register 0x5F bit 2 to 7
- *
- *  @param v_slow_no_motion_u8 :The value of slow no motion duration
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *	@note
- *	@note v_slow_no_motion_u8(5:4)=0b00 ->
- *	[v_slow_no_motion_u8(3:0) + 1] * 1.28s (1.28s-20.48s)
- *	@note v_slow_no_motion_u8(5:4)=1 ->
- *	[v_slow_no_motion_u8(3:0)+5] * 5.12s (25.6s-102.4s)
- *	@note v_slow_no_motion_u8(5)='1' ->
- *	[(v_slow_no_motion_u8:0)+11] * 10.24s (112.64s-430.08s);
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_slow_no_motion_durn(
-u8 *v_slow_no_motion_u8)
-{
-/* variable used for return the status of communication result*/
-BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-		/* read slow no motion duration*/
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-		(p_bmi160->dev_addr,
-		BMI160_USER_INTR_MOTION_0_INTR_SLOW_NO_MOTION_DURN__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		*v_slow_no_motion_u8 = BMI160_GET_BITSLICE
-		(v_data_u8,
-		BMI160_USER_INTR_MOTION_0_INTR_SLOW_NO_MOTION_DURN);
-	}
-return com_rslt;
-}
- /*!
- *	@brief This API write Slow/no-motion
- *	interrupt trigger delay duration from the register 0x5F bit 2 to 7
- *
- *  @param v_slow_no_motion_u8 :The value of slow no motion duration
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *	@note
- *	@note v_slow_no_motion_u8(5:4)=0b00 ->
- *	[v_slow_no_motion_u8(3:0) + 1] * 1.28s (1.28s-20.48s)
- *	@note v_slow_no_motion_u8(5:4)=1 ->
- *	[v_slow_no_motion_u8(3:0)+5] * 5.12s (25.6s-102.4s)
- *	@note v_slow_no_motion_u8(5)='1' ->
- *	[(v_slow_no_motion_u8:0)+11] * 10.24s (112.64s-430.08s);
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_slow_no_motion_durn(
-u8 v_slow_no_motion_u8)
-{
-/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-	/* write slow no motion duration*/
-	com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-	(p_bmi160->dev_addr,
-	BMI160_USER_INTR_MOTION_0_INTR_SLOW_NO_MOTION_DURN__REG,
-	&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	if (com_rslt == SUCCESS) {
-		v_data_u8 = BMI160_SET_BITSLICE
-		(v_data_u8,
-		BMI160_USER_INTR_MOTION_0_INTR_SLOW_NO_MOTION_DURN,
-		v_slow_no_motion_u8);
-		com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
-		(p_bmi160->dev_addr,
-		BMI160_USER_INTR_MOTION_0_INTR_SLOW_NO_MOTION_DURN__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	}
-}
-return com_rslt;
-}
-/*!
- *	@brief This API is used to read threshold
- *	definition for the any-motion interrupt
- *	from the register 0x60 bit 0 to 7
- *
- *
- *  @param  v_any_motion_thres_u8 : The value of any motion threshold
- *
- *	@note any motion threshold changes according to accel g range
- *	accel g range can be set by the function ""
- *   accel_range    | any motion threshold
- *  ----------------|---------------------
- *      2g          |  v_any_motion_thres_u8*3.91 mg
- *      4g          |  v_any_motion_thres_u8*7.81 mg
- *      8g          |  v_any_motion_thres_u8*15.63 mg
- *      16g         |  v_any_motion_thres_u8*31.25 mg
- *	@note when v_any_motion_thres_u8 = 0
- *   accel_range    | any motion threshold
- *  ----------------|---------------------
- *      2g          |  1.95 mg
- *      4g          |  3.91 mg
- *      8g          |  7.81 mg
- *      16g         |  15.63 mg
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_any_motion_thres(
-u8 *v_any_motion_thres_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read any motion threshold*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_INTR_MOTION_1_INTR_ANY_MOTION_THRES__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_any_motion_thres_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_MOTION_1_INTR_ANY_MOTION_THRES);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to write threshold
- *	definition for the any-motion interrupt
- *	from the register 0x60 bit 0 to 7
- *
- *
- *  @param  v_any_motion_thres_u8 : The value of any motion threshold
- *
- *	@note any motion threshold changes according to accel g range
- *	accel g range can be set by the function ""
- *   accel_range    | any motion threshold
- *  ----------------|---------------------
- *      2g          |  v_any_motion_thres_u8*3.91 mg
- *      4g          |  v_any_motion_thres_u8*7.81 mg
- *      8g          |  v_any_motion_thres_u8*15.63 mg
- *      16g         |  v_any_motion_thres_u8*31.25 mg
- *	@note when v_any_motion_thres_u8 = 0
- *   accel_range    | any motion threshold
- *  ----------------|---------------------
- *      2g          |  1.95 mg
- *      4g          |  3.91 mg
- *      8g          |  7.81 mg
- *      16g         |  15.63 mg
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_any_motion_thres(
-u8 v_any_motion_thres_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		/* write any motion threshold*/
-		com_rslt = p_bmi160->BMI160_BUS_WRITE_FUNC
-		(p_bmi160->dev_addr,
-		BMI160_USER_INTR_MOTION_1_INTR_ANY_MOTION_THRES__REG,
-		&v_any_motion_thres_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	}
-	return com_rslt;
-}
- /*!
- *	@brief This API is used to read threshold
- *	for the slow/no-motion interrupt
- *	from the register 0x61 bit 0 to 7
- *
- *
- *
- *
- *  @param v_slow_no_motion_thres_u8 : The value of slow no motion threshold
- *	@note slow no motion threshold changes according to accel g range
- *	accel g range can be set by the function ""
- *   accel_range    | slow no motion threshold
- *  ----------------|---------------------
- *      2g          |  v_slow_no_motion_thres_u8*3.91 mg
- *      4g          |  v_slow_no_motion_thres_u8*7.81 mg
- *      8g          |  v_slow_no_motion_thres_u8*15.63 mg
- *      16g         |  v_slow_no_motion_thres_u8*31.25 mg
- *	@note when v_slow_no_motion_thres_u8 = 0
- *   accel_range    | slow no motion threshold
- *  ----------------|---------------------
- *      2g          |  1.95 mg
- *      4g          |  3.91 mg
- *      8g          |  7.81 mg
- *      16g         |  15.63 mg
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_slow_no_motion_thres(
-u8 *v_slow_no_motion_thres_u8)
-{
-BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-		/* read slow no motion threshold*/
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-		(p_bmi160->dev_addr,
-		BMI160_USER_INTR_MOTION_2_INTR_SLOW_NO_MOTION_THRES__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		*v_slow_no_motion_thres_u8 =
-		BMI160_GET_BITSLICE(v_data_u8,
-		BMI160_USER_INTR_MOTION_2_INTR_SLOW_NO_MOTION_THRES);
-	}
-return com_rslt;
-}
- /*!
- *	@brief This API is used to write threshold
- *	for the slow/no-motion interrupt
- *	from the register 0x61 bit 0 to 7
- *
- *
- *
- *
- *  @param v_slow_no_motion_thres_u8 : The value of slow no motion threshold
- *	@note slow no motion threshold changes according to accel g range
- *	accel g range can be set by the function ""
- *   accel_range    | slow no motion threshold
- *  ----------------|---------------------
- *      2g          |  v_slow_no_motion_thres_u8*3.91 mg
- *      4g          |  v_slow_no_motion_thres_u8*7.81 mg
- *      8g          |  v_slow_no_motion_thres_u8*15.63 mg
- *      16g         |  v_slow_no_motion_thres_u8*31.25 mg
- *	@note when v_slow_no_motion_thres_u8 = 0
- *   accel_range    | slow no motion threshold
- *  ----------------|---------------------
- *      2g          |  1.95 mg
- *      4g          |  3.91 mg
- *      8g          |  7.81 mg
- *      16g         |  15.63 mg
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_slow_no_motion_thres(
-u8 v_slow_no_motion_thres_u8)
-{
-BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-		/* write slow no motion threshold*/
-		com_rslt = p_bmi160->BMI160_BUS_WRITE_FUNC(
-		p_bmi160->dev_addr,
-		BMI160_USER_INTR_MOTION_2_INTR_SLOW_NO_MOTION_THRES__REG,
-		&v_slow_no_motion_thres_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	}
-return com_rslt;
-}
- /*!
- *	@brief This API is used to read
- *	the slow/no-motion selection from the register 0x62 bit 0
- *
- *
- *
- *
- *  @param  v_intr_slow_no_motion_select_u8 :
- *	The value of slow/no-motion select
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     |  SLOW_MOTION
- *  0x01     |  NO_MOTION
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_slow_no_motion_select(
-u8 *v_intr_slow_no_motion_select_u8)
-{
-BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-		/* read slow no motion select*/
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-		p_bmi160->dev_addr,
-		BMI160_USER_INTR_MOTION_3_INTR_SLOW_NO_MOTION_SELECT__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		*v_intr_slow_no_motion_select_u8 =
-		BMI160_GET_BITSLICE(v_data_u8,
-		BMI160_USER_INTR_MOTION_3_INTR_SLOW_NO_MOTION_SELECT);
-	}
-return com_rslt;
-}
- /*!
- *	@brief This API is used to write
- *	the slow/no-motion selection from the register 0x62 bit 0
- *
- *
- *
- *
- *  @param  v_intr_slow_no_motion_select_u8 :
- *	The value of slow/no-motion select
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     |  SLOW_MOTION
- *  0x01     |  NO_MOTION
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_slow_no_motion_select(
-u8 v_intr_slow_no_motion_select_u8)
-{
-/* variable used for return the status of communication result*/
-BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-} else {
-if (v_intr_slow_no_motion_select_u8 <= BMI160_MAX_VALUE_NO_MOTION) {
-	/* write slow no motion select*/
-	com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-	(p_bmi160->dev_addr,
-	BMI160_USER_INTR_MOTION_3_INTR_SLOW_NO_MOTION_SELECT__REG,
-	&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	if (com_rslt == SUCCESS) {
-		v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-		BMI160_USER_INTR_MOTION_3_INTR_SLOW_NO_MOTION_SELECT,
-		v_intr_slow_no_motion_select_u8);
-		com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
-		(p_bmi160->dev_addr,
-		BMI160_USER_INTR_MOTION_3_INTR_SLOW_NO_MOTION_SELECT__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	}
-} else {
-com_rslt = E_BMI160_OUT_OF_RANGE;
-}
-}
-return com_rslt;
-}
- /*!
- *	@brief This API is used to select
- *	the significant or any motion interrupt from the register 0x62 bit 1
- *
- *
- *
- *
- *  @param  v_intr_significant_motion_select_u8 :
- *	the value of significant or any motion interrupt selection
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     |  ANY_MOTION
- *  0x01     |  SIGNIFICANT_MOTION
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_significant_motion_select(
-u8 *v_intr_significant_motion_select_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the significant or any motion interrupt*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_INTR_SIGNIFICATION_MOTION_SELECT__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_intr_significant_motion_select_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_SIGNIFICATION_MOTION_SELECT);
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API is used to write, select
- *	the significant or any motion interrupt from the register 0x62 bit 1
- *
- *
- *
- *
- *  @param  v_intr_significant_motion_select_u8 :
- *	the value of significant or any motion interrupt selection
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     |  ANY_MOTION
- *  0x01     |  SIGNIFICANT_MOTION
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_significant_motion_select(
-u8 v_intr_significant_motion_select_u8)
-{
-/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-	if (v_intr_significant_motion_select_u8 <=
-	BMI160_MAX_VALUE_SIGNIFICANT_MOTION) {
-		/* write the significant or any motion interrupt*/
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-		(p_bmi160->dev_addr,
-		BMI160_USER_INTR_SIGNIFICATION_MOTION_SELECT__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_SIGNIFICATION_MOTION_SELECT,
-			v_intr_significant_motion_select_u8);
-			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_INTR_SIGNIFICATION_MOTION_SELECT__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-	} else {
-	com_rslt = E_BMI160_OUT_OF_RANGE;
-	}
-}
-return com_rslt;
-}
- /*!
- *	@brief This API is used to read
- *	the significant skip time from the register 0x62 bit  2 and 3
- *
- *
- *
- *
- *  @param  v_int_sig_mot_skip_u8 : the value of significant skip time
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     |  skip time 1.5 seconds
- *  0x01     |  skip time 3 seconds
- *  0x02     |  skip time 6 seconds
- *  0x03     |  skip time 12 seconds
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_significant_motion_skip(
-u8 *v_int_sig_mot_skip_u8)
-{
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read significant skip time*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_INTR_SIGNIFICANT_MOTION_SKIP__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_int_sig_mot_skip_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_SIGNIFICANT_MOTION_SKIP);
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API is used to write
- *	the significant skip time from the register 0x62 bit  2 and 3
- *
- *
- *
- *
- *  @param  v_int_sig_mot_skip_u8 : the value of significant skip time
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     |  skip time 1.5 seconds
- *  0x01     |  skip time 3 seconds
- *  0x02     |  skip time 6 seconds
- *  0x03     |  skip time 12 seconds
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_significant_motion_skip(
-u8 v_int_sig_mot_skip_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_int_sig_mot_skip_u8 <= BMI160_MAX_UNDER_SIG_MOTION) {
-			/* write significant skip time*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_INTR_SIGNIFICANT_MOTION_SKIP__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR_SIGNIFICANT_MOTION_SKIP,
-				v_int_sig_mot_skip_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
-				(p_bmi160->dev_addr,
-				BMI160_USER_INTR_SIGNIFICANT_MOTION_SKIP__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
- /*!
- *	@brief This API is used to read
- *	the significant proof time from the register 0x62 bit  4 and 5
- *
- *
- *
- *
- *  @param  v_significant_motion_proof_u8 :
- *	the value of significant proof time
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     |  proof time 0.25 seconds
- *  0x01     |  proof time 0.5 seconds
- *  0x02     |  proof time 1 seconds
- *  0x03     |  proof time 2 seconds
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_significant_motion_proof(
-u8 *v_significant_motion_proof_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read significant proof time */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_INTR_SIGNIFICANT_MOTION_PROOF__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_significant_motion_proof_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_SIGNIFICANT_MOTION_PROOF);
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API is used to write
- *	the significant proof time from the register 0x62 bit  4 and 5
- *
- *
- *
- *
- *  @param  v_significant_motion_proof_u8 :
- *	the value of significant proof time
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     |  proof time 0.25 seconds
- *  0x01     |  proof time 0.5 seconds
- *  0x02     |  proof time 1 seconds
- *  0x03     |  proof time 2 seconds
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_significant_motion_proof(
-u8 v_significant_motion_proof_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_significant_motion_proof_u8
-		<= BMI160_MAX_UNDER_SIG_MOTION) {
-			/* write significant proof time */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_INTR_SIGNIFICANT_MOTION_PROOF__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR_SIGNIFICANT_MOTION_PROOF,
-				v_significant_motion_proof_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
-				(p_bmi160->dev_addr,
-				BMI160_USER_INTR_SIGNIFICANT_MOTION_PROOF__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to get the tap duration
- *	from the register 0x63 bit 0 to 2
- *
- *
- *
- *  @param v_tap_durn_u8 : The value of tap duration
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | BMI160_TAP_DURN_50MS
- *  0x01     | BMI160_TAP_DURN_100MS
- *  0x03     | BMI160_TAP_DURN_150MS
- *  0x04     | BMI160_TAP_DURN_200MS
- *  0x05     | BMI160_TAP_DURN_250MS
- *  0x06     | BMI160_TAP_DURN_375MS
- *  0x07     | BMI160_TAP_DURN_700MS
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_tap_durn(
-u8 *v_tap_durn_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read tap duration*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_INTR_TAP_0_INTR_TAP_DURN__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_tap_durn_u8 = BMI160_GET_BITSLICE(
-			v_data_u8,
-			BMI160_USER_INTR_TAP_0_INTR_TAP_DURN);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API is used to write the tap duration
- *	from the register 0x63 bit 0 to 2
- *
- *
- *
- *  @param v_tap_durn_u8 : The value of tap duration
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | BMI160_TAP_DURN_50MS
- *  0x01     | BMI160_TAP_DURN_100MS
- *  0x03     | BMI160_TAP_DURN_150MS
- *  0x04     | BMI160_TAP_DURN_200MS
- *  0x05     | BMI160_TAP_DURN_250MS
- *  0x06     | BMI160_TAP_DURN_375MS
- *  0x07     | BMI160_TAP_DURN_700MS
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_tap_durn(
-u8 v_tap_durn_u8)
-{
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_tap_durn_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_tap_durn_u8 <= BMI160_MAX_TAP_TURN) {
-			switch (v_tap_durn_u8) {
-			case BMI160_TAP_DURN_50MS:
-				v_data_tap_durn_u8 = BMI160_TAP_DURN_50MS;
-				break;
-			case BMI160_TAP_DURN_100MS:
-				v_data_tap_durn_u8 = BMI160_TAP_DURN_100MS;
-				break;
-			case BMI160_TAP_DURN_150MS:
-				v_data_tap_durn_u8 = BMI160_TAP_DURN_150MS;
-				break;
-			case BMI160_TAP_DURN_200MS:
-				v_data_tap_durn_u8 = BMI160_TAP_DURN_200MS;
-				break;
-			case BMI160_TAP_DURN_250MS:
-				v_data_tap_durn_u8 = BMI160_TAP_DURN_250MS;
-				break;
-			case BMI160_TAP_DURN_375MS:
-				v_data_tap_durn_u8 = BMI160_TAP_DURN_375MS;
-				break;
-			case BMI160_TAP_DURN_500MS:
-				v_data_tap_durn_u8 = BMI160_TAP_DURN_500MS;
-				break;
-			case BMI160_TAP_DURN_700MS:
-				v_data_tap_durn_u8 = BMI160_TAP_DURN_700MS;
-				break;
-			default:
-				break;
-			}
-			/* write tap duration*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_INTR_TAP_0_INTR_TAP_DURN__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR_TAP_0_INTR_TAP_DURN,
-				v_data_tap_durn_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
-				(p_bmi160->dev_addr,
-				BMI160_USER_INTR_TAP_0_INTR_TAP_DURN__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
- /*!
- *	@brief This API read the
- *	tap shock duration from the register 0x63 bit 2
- *
- *  @param v_tap_shock_u8 :The value of tap shock
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | BMI160_TAP_SHOCK_50MS
- *  0x01     | BMI160_TAP_SHOCK_75MS
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_tap_shock(
-u8 *v_tap_shock_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read tap shock duration*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_INTR_TAP_0_INTR_TAP_SHOCK__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_tap_shock_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_TAP_0_INTR_TAP_SHOCK);
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API write the
- *	tap shock duration from the register 0x63 bit 2
- *
- *  @param v_tap_shock_u8 :The value of tap shock
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | BMI160_TAP_SHOCK_50MS
- *  0x01     | BMI160_TAP_SHOCK_75MS
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_tap_shock(u8 v_tap_shock_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_tap_shock_u8 <= BMI160_MAX_VALUE_TAP_SHOCK) {
-			/* write tap shock duration*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_INTR_TAP_0_INTR_TAP_SHOCK__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR_TAP_0_INTR_TAP_SHOCK,
-				v_tap_shock_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
-				(p_bmi160->dev_addr,
-				BMI160_USER_INTR_TAP_0_INTR_TAP_SHOCK__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API read
- *	tap quiet duration from the register 0x63 bit 7
- *
- *
- *  @param v_tap_quiet_u8 : The value of tap quiet
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | BMI160_TAP_QUIET_30MS
- *  0x01     | BMI160_TAP_QUIET_20MS
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_tap_quiet(
-u8 *v_tap_quiet_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read tap quiet duration*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_INTR_TAP_0_INTR_TAP_QUIET__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_tap_quiet_u8 = BMI160_GET_BITSLICE(
-			v_data_u8,
-			BMI160_USER_INTR_TAP_0_INTR_TAP_QUIET);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API write
- *	tap quiet duration from the register 0x63 bit 7
- *
- *
- *  @param v_tap_quiet_u8 : The value of tap quiet
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | BMI160_TAP_QUIET_30MS
- *  0x01     | BMI160_TAP_QUIET_20MS
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_tap_quiet(u8 v_tap_quiet_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_tap_quiet_u8 <= BMI160_MAX_VALUE_TAP_QUIET) {
-			/* write tap quiet duration*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_INTR_TAP_0_INTR_TAP_QUIET__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR_TAP_0_INTR_TAP_QUIET,
-				v_tap_quiet_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
-				(p_bmi160->dev_addr,
-				BMI160_USER_INTR_TAP_0_INTR_TAP_QUIET__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
- /*!
- *	@brief This API read Threshold of the
- *	single/double tap interrupt from the register 0x64 bit 0 to 4
- *
- *
- *	@param v_tap_thres_u8 : The value of single/double tap threshold
- *
- *	@note single/double tap threshold changes according to accel g range
- *	accel g range can be set by the function ""
- *   accel_range    | single/double tap threshold
- *  ----------------|---------------------
- *      2g          |  ((v_tap_thres_u8 + 1) * 62.5)mg
- *      4g          |  ((v_tap_thres_u8 + 1) * 125)mg
- *      8g          |  ((v_tap_thres_u8 + 1) * 250)mg
- *      16g         |  ((v_tap_thres_u8 + 1) * 500)mg
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_tap_thres(
-u8 *v_tap_thres_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read tap threshold*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_INTR_TAP_1_INTR_TAP_THRES__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_tap_thres_u8 = BMI160_GET_BITSLICE
-			(v_data_u8,
-			BMI160_USER_INTR_TAP_1_INTR_TAP_THRES);
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API write Threshold of the
- *	single/double tap interrupt from the register 0x64 bit 0 to 4
- *
- *
- *	@param v_tap_thres_u8 : The value of single/double tap threshold
- *
- *	@note single/double tap threshold changes according to accel g range
- *	accel g range can be set by the function ""
- *   accel_range    | single/double tap threshold
- *  ----------------|---------------------
- *      2g          |  ((v_tap_thres_u8 + 1) * 62.5)mg
- *      4g          |  ((v_tap_thres_u8 + 1) * 125)mg
- *      8g          |  ((v_tap_thres_u8 + 1) * 250)mg
- *      16g         |  ((v_tap_thres_u8 + 1) * 500)mg
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_tap_thres(
-u8 v_tap_thres_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* write tap threshold*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_INTR_TAP_1_INTR_TAP_THRES__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR_TAP_1_INTR_TAP_THRES,
-				v_tap_thres_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
-				(p_bmi160->dev_addr,
-				BMI160_USER_INTR_TAP_1_INTR_TAP_THRES__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API read the threshold for orientation interrupt
- *	from the register 0x65 bit 0 and 1
- *
- *  @param v_orient_mode_u8 : The value of threshold for orientation
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | symmetrical
- *  0x01     | high-asymmetrical
- *  0x02     | low-asymmetrical
- *  0x03     | symmetrical
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_orient_mode(
-u8 *v_orient_mode_u8)
-{
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read orientation threshold*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_MODE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_orient_mode_u8 = BMI160_GET_BITSLICE
-			(v_data_u8,
-			BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_MODE);
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API write the threshold for orientation interrupt
- *	from the register 0x65 bit 0 and 1
- *
- *  @param v_orient_mode_u8 : The value of threshold for orientation
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | symmetrical
- *  0x01     | high-asymmetrical
- *  0x02     | low-asymmetrical
- *  0x03     | symmetrical
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_orient_mode(
-u8 v_orient_mode_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_orient_mode_u8 <= BMI160_MAX_ORIENT_MODE) {
-			/* write orientation threshold*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_MODE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_MODE,
-				v_orient_mode_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
-				(p_bmi160->dev_addr,
-				BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_MODE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API read the orient blocking mode
- *	that is used for the generation of the orientation interrupt.
- *	from the register 0x65 bit 2 and 3
- *
- *  @param v_orient_blocking_u8 : The value of orient blocking mode
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | No blocking
- *  0x01     | Theta blocking or acceleration in any axis > 1.5g
- *  0x02     | Theta blocking or acceleration slope in any axis >
- *   -       | 0.2g or acceleration in any axis > 1.5g
- *  0x03     | Theta blocking or acceleration slope in any axis >
- *   -       | 0.4g or acceleration in any axis >
- *   -       | 1.5g and value of orient is not stable
- *   -       | for at least 100 ms
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_orient_blocking(
-u8 *v_orient_blocking_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read orient blocking mode*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_BLOCKING__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_orient_blocking_u8 = BMI160_GET_BITSLICE
-			(v_data_u8,
-			BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_BLOCKING);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API write the orient blocking mode
- *	that is used for the generation of the orientation interrupt.
- *	from the register 0x65 bit 2 and 3
- *
- *  @param v_orient_blocking_u8 : The value of orient blocking mode
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | No blocking
- *  0x01     | Theta blocking or acceleration in any axis > 1.5g
- *  0x02     | Theta blocking or acceleration slope in any axis >
- *   -       | 0.2g or acceleration in any axis > 1.5g
- *  0x03     | Theta blocking or acceleration slope in any axis >
- *   -       | 0.4g or acceleration in any axis >
- *   -       | 1.5g and value of orient is not stable
- *   -       | for at least 100 ms
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_orient_blocking(
-u8 v_orient_blocking_u8)
-{
-/* variable used for return the status of communication result*/
-BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-	if (v_orient_blocking_u8 <= BMI160_MAX_ORIENT_BLOCKING) {
-		/* write orient blocking mode*/
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-		(p_bmi160->dev_addr,
-		BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_BLOCKING__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_BLOCKING,
-			v_orient_blocking_u8);
-			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_BLOCKING__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-	} else {
-	com_rslt = E_BMI160_OUT_OF_RANGE;
-	}
-}
-return com_rslt;
-}
-/*!
- *	@brief This API read Orient interrupt
- *	hysteresis, from the register 0x64 bit 4 to 7
- *
- *
- *
- *  @param v_orient_hyst_u8 : The value of orient hysteresis
- *
- *	@note 1 LSB corresponds to 62.5 mg,
- *	irrespective of the selected accel range
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_orient_hyst(
-u8 *v_orient_hyst_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read orient hysteresis*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_HYST__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_orient_hyst_u8 = BMI160_GET_BITSLICE
-			(v_data_u8,
-			BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_HYST);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API write Orient interrupt
- *	hysteresis, from the register 0x64 bit 4 to 7
- *
- *
- *
- *  @param v_orient_hyst_u8 : The value of orient hysteresis
- *
- *	@note 1 LSB corresponds to 62.5 mg,
- *	irrespective of the selected accel range
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_orient_hyst(
-u8 v_orient_hyst_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* write orient hysteresis*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_HYST__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_HYST,
-				v_orient_hyst_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
-				(p_bmi160->dev_addr,
-				BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_HYST__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API read Orient
- *	blocking angle (0 to 44.8) from the register 0x66 bit 0 to 5
- *
- *  @param v_orient_theta_u8 : The value of Orient blocking angle
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_orient_theta(
-u8 *v_orient_theta_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read Orient blocking angle*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_THETA__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_orient_theta_u8 = BMI160_GET_BITSLICE
-			(v_data_u8,
-			BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_THETA);
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API write Orient
- *	blocking angle (0 to 44.8) from the register 0x66 bit 0 to 5
- *
- *  @param v_orient_theta_u8 : The value of Orient blocking angle
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_orient_theta(
-u8 v_orient_theta_u8)
-{
-/* variable used for return the status of communication result*/
-BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-	if (v_orient_theta_u8 <= BMI160_MAX_ORIENT_THETA) {
-		/* write Orient blocking angle*/
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-		(p_bmi160->dev_addr,
-		BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_THETA__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_THETA,
-			v_orient_theta_u8);
-			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_THETA__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-	} else {
-	com_rslt = E_BMI160_OUT_OF_RANGE;
-	}
-}
-return com_rslt;
-}
-/*!
- *	@brief This API read orient change
- *	of up/down bit from the register 0x66 bit 6
- *
- *  @param v_orient_ud_u8 : The value of orient change of up/down
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | Is ignored
- *  0x01     | Generates orientation interrupt
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_orient_ud_enable(
-u8 *v_orient_ud_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read orient up/down enable*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_UD_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_orient_ud_u8 = BMI160_GET_BITSLICE
-			(v_data_u8,
-			BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_UD_ENABLE);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API write orient change
- *	of up/down bit from the register 0x66 bit 6
- *
- *  @param v_orient_ud_u8 : The value of orient change of up/down
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | Is ignored
- *  0x01     | Generates orientation interrupt
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_orient_ud_enable(
-u8 v_orient_ud_u8)
-{
-/* variable used for return the status of communication result*/
-BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-	if (v_orient_ud_u8 <= BMI160_MAX_VALUE_ORIENT_UD) {
-		/* write orient up/down enable */
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-		(p_bmi160->dev_addr,
-		BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_UD_ENABLE__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_UD_ENABLE,
-			v_orient_ud_u8);
-			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_UD_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-	} else {
-	com_rslt = E_BMI160_OUT_OF_RANGE;
-	}
-}
-return com_rslt;
-}
- /*!
- *	@brief This API read orientation axes changes
- *	from the register 0x66 bit 7
- *
- *  @param v_orient_axes_u8 : The value of orient axes assignment
- *	value    |       Behaviour    | Name
- * ----------|--------------------|------
- *  0x00     | x = x, y = y, z = z|orient_ax_noex
- *  0x01     | x = y, y = z, z = x|orient_ax_ex
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_orient_axes_enable(
-u8 *v_orient_axes_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read orientation axes changes  */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_AXES_EX__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_orient_axes_u8 = BMI160_GET_BITSLICE
-			(v_data_u8,
-			BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_AXES_EX);
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API write orientation axes changes
- *	from the register 0x66 bit 7
- *
- *  @param v_orient_axes_u8 : The value of orient axes assignment
- *	value    |       Behaviour    | Name
- * ----------|--------------------|------
- *  0x00     | x = x, y = y, z = z|orient_ax_noex
- *  0x01     | x = y, y = z, z = x|orient_ax_ex
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_orient_axes_enable(
-u8 v_orient_axes_u8)
-{
-/* variable used for return the status of communication result*/
-BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-	if (v_orient_axes_u8 <= BMI160_MAX_VALUE_ORIENT_AXES) {
-		/*write orientation axes changes  */
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-		(p_bmi160->dev_addr,
-		BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_AXES_EX__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_AXES_EX,
-			v_orient_axes_u8);
-			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_AXES_EX__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-	} else {
-	com_rslt = E_BMI160_OUT_OF_RANGE;
-	}
-}
-return com_rslt;
-}
- /*!
- *	@brief This API read Flat angle (0 to 44.8) for flat interrupt
- *	from the register 0x67 bit 0 to 5
- *
- *  @param v_flat_theta_u8 : The value of flat angle
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_flat_theta(
-u8 *v_flat_theta_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read Flat angle*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_INTR_FLAT_0_INTR_FLAT_THETA__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_flat_theta_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_FLAT_0_INTR_FLAT_THETA);
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API write Flat angle (0 to 44.8) for flat interrupt
- *	from the register 0x67 bit 0 to 5
- *
- *  @param v_flat_theta_u8 : The value of flat angle
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_flat_theta(
-u8 v_flat_theta_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_flat_theta_u8 <= BMI160_MAX_FLAT_THETA) {
-			/* write Flat angle */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_INTR_FLAT_0_INTR_FLAT_THETA__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR_FLAT_0_INTR_FLAT_THETA,
-				v_flat_theta_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
-				(p_bmi160->dev_addr,
-				BMI160_USER_INTR_FLAT_0_INTR_FLAT_THETA__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API read Flat interrupt hold time;
- *	from the register 0x68 bit 4 and 5
- *
- *  @param v_flat_hold_u8 : The value of flat hold time
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | 0ms
- *  0x01     | 512ms
- *  0x01     | 1024ms
- *  0x01     | 2048ms
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_flat_hold(
-u8 *v_flat_hold_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read flat hold time*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_INTR_FLAT_1_INTR_FLAT_HOLD__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_flat_hold_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_INTR_FLAT_1_INTR_FLAT_HOLD);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API write Flat interrupt hold time;
- *	from the register 0x68 bit 4 and 5
- *
- *  @param v_flat_hold_u8 : The value of flat hold time
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | 0ms
- *  0x01     | 512ms
- *  0x01     | 1024ms
- *  0x01     | 2048ms
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_flat_hold(
-u8 v_flat_hold_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_flat_hold_u8 <= BMI160_MAX_FLAT_HOLD) {
-			/* write flat hold time*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_INTR_FLAT_1_INTR_FLAT_HOLD__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR_FLAT_1_INTR_FLAT_HOLD,
-				v_flat_hold_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
-				(p_bmi160->dev_addr,
-				BMI160_USER_INTR_FLAT_1_INTR_FLAT_HOLD__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API read flat interrupt hysteresis
- *	from the register 0x68 bit 0 to 3
- *
- *  @param v_flat_hyst_u8 : The value of flat hysteresis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_flat_hyst(
-u8 *v_flat_hyst_u8)
-{
-	/* variable used to return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the flat hysteresis*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_INTR_FLAT_1_INTR_FLAT_HYST__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_flat_hyst_u8 = BMI160_GET_BITSLICE(
-			v_data_u8,
-			BMI160_USER_INTR_FLAT_1_INTR_FLAT_HYST);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API write flat interrupt hysteresis
- *	from the register 0x68 bit 0 to 3
- *
- *  @param v_flat_hyst_u8 : The value of flat hysteresis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_flat_hyst(
-u8 v_flat_hyst_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_flat_hyst_u8 <= BMI160_MAX_FLAT_HYST) {
-			/* read the flat hysteresis*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_INTR_FLAT_1_INTR_FLAT_HYST__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_INTR_FLAT_1_INTR_FLAT_HYST,
-				v_flat_hyst_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
-				(p_bmi160->dev_addr,
-				BMI160_USER_INTR_FLAT_1_INTR_FLAT_HYST__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
- /*!
- *	@brief This API read accel offset compensation
- *	target value for z-axis from the register 0x69 bit 0 and 1
- *
- *  @param v_foc_accel_z_u8 : the value of accel offset compensation z axis
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | disable
- *  0x01     | +1g
- *  0x01     | -1g
- *  0x01     | 0g
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_foc_accel_z(u8 *v_foc_accel_z_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the accel offset compensation for z axis*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_FOC_ACCEL_Z__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_foc_accel_z_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_FOC_ACCEL_Z);
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API write accel offset compensation
- *	target value for z-axis from the register 0x69 bit 0 and 1
- *
- *  @param v_foc_accel_z_u8 : the value of accel offset compensation z axis
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | disable
- *  0x01     | +1g
- *  0x01     | -1g
- *  0x01     | 0g
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_foc_accel_z(
-u8 v_foc_accel_z_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* write the accel offset compensation for z axis*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_FOC_ACCEL_Z__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_FOC_ACCEL_Z,
-				v_foc_accel_z_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
-				(p_bmi160->dev_addr,
-				BMI160_USER_FOC_ACCEL_Z__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API read accel offset compensation
- *	target value for y-axis
- *	from the register 0x69 bit 2 and 3
- *
- *  @param v_foc_accel_y_u8 : the value of accel offset compensation y axis
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | disable
- *  0x01     | +1g
- *  0x01     | -1g
- *  0x01     | 0g
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_foc_accel_y(u8 *v_foc_accel_y_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the accel offset compensation for y axis*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_FOC_ACCEL_Y__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_foc_accel_y_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_FOC_ACCEL_Y);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API write accel offset compensation
- *	target value for y-axis
- *	from the register 0x69 bit 2 and 3
- *
- *  @param v_foc_accel_y_u8 : the value of accel offset compensation y axis
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | disable
- *  0x01     | +1g
- *  0x02     | -1g
- *  0x03     | 0g
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_foc_accel_y(u8 v_foc_accel_y_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_foc_accel_y_u8 <= BMI160_MAX_ACCEL_FOC) {
-			/* write the accel offset compensation for y axis*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_FOC_ACCEL_Y__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_FOC_ACCEL_Y,
-				v_foc_accel_y_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
-				(p_bmi160->dev_addr,
-				BMI160_USER_FOC_ACCEL_Y__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API read accel offset compensation
- *	target value for x-axis is
- *	from the register 0x69 bit 4 and 5
- *
- *  @param v_foc_accel_x_u8 : the value of accel offset compensation x axis
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | disable
- *  0x01     | +1g
- *  0x02     | -1g
- *  0x03     | 0g
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_foc_accel_x(u8 *v_foc_accel_x_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		/* read the accel offset compensation for x axis*/
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-		p_bmi160->dev_addr,
-		BMI160_USER_FOC_ACCEL_X__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		*v_foc_accel_x_u8 = BMI160_GET_BITSLICE(v_data_u8,
-		BMI160_USER_FOC_ACCEL_X);
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API write accel offset compensation
- *	target value for x-axis is
- *	from the register 0x69 bit 4 and 5
- *
- *  @param v_foc_accel_x_u8 : the value of accel offset compensation x axis
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | disable
- *  0x01     | +1g
- *  0x01     | -1g
- *  0x01     | 0g
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_foc_accel_x(u8 v_foc_accel_x_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_foc_accel_x_u8 <= BMI160_MAX_ACCEL_FOC) {
-			/* write the accel offset compensation for x axis*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_FOC_ACCEL_X__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_FOC_ACCEL_X,
-				v_foc_accel_x_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_FOC_ACCEL_X__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API writes accel fast offset compensation
- *	from the register 0x69 bit 0 to 5
- *	@brief This API writes each axis individually
- *	FOC_X_AXIS - bit 4 and 5
- *	FOC_Y_AXIS - bit 2 and 3
- *	FOC_Z_AXIS - bit 0 and 1
- *
- *  @param  v_foc_accel_u8: The value of accel offset compensation
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | disable
- *  0x01     | +1g
- *  0x01     | -1g
- *  0x01     | 0g
- *
- *  @param  v_axis_u8: The value of accel offset axis selection
-  *	value    | axis
- * ----------|-------------------
- *  0        | FOC_X_AXIS
- *  1        | FOC_Y_AXIS
- *  2        | FOC_Z_AXIS
- *
- *	@param v_accel_offset_s8: The accel offset value
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_foc_trigger(u8 v_axis_u8,
-u8 v_foc_accel_u8, s8 *v_accel_offset_s8)
-{
-/* variable used for return the status of communication result*/
-BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-s8 v_status_s8 = SUCCESS;
-u8 v_timeout_u8 = BMI160_INIT_VALUE;
-s8 v_foc_accel_offset_x_s8  = BMI160_INIT_VALUE;
-s8 v_foc_accel_offset_y_s8 =  BMI160_INIT_VALUE;
-s8 v_foc_accel_offset_z_s8 =  BMI160_INIT_VALUE;
-u8 focstatus = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-} else {
-	v_status_s8 = bmi160_set_accel_offset_enable(
-	ACCEL_OFFSET_ENABLE);
-	if (v_status_s8 == SUCCESS) {
-		switch (v_axis_u8) {
-		case FOC_X_AXIS:
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_FOC_ACCEL_X__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 =
-				BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_FOC_ACCEL_X,
-				v_foc_accel_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_FOC_ACCEL_X__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-
-			/* trigger the
-			FOC need to write
-			0x03 in the register 0x7e*/
-			com_rslt +=
-			bmi160_set_command_register(
-			START_FOC_ACCEL_GYRO);
-
-			com_rslt +=
-			bmi160_get_foc_rdy(&focstatus);
-			if ((com_rslt != SUCCESS) ||
-			(focstatus != BMI160_FOC_STAT_HIGH)) {
-				while ((com_rslt != SUCCESS) ||
-				(focstatus != BMI160_FOC_STAT_HIGH
-				&& v_timeout_u8 <
-				BMI160_MAXIMUM_TIMEOUT)) {
-					p_bmi160->delay_msec(
-					BMI160_DELAY_SETTLING_TIME);
-					com_rslt = bmi160_get_foc_rdy(
-					&focstatus);
-					v_timeout_u8++;
-				}
-			}
-			if ((com_rslt == SUCCESS) &&
-				(focstatus == BMI160_FOC_STAT_HIGH)) {
-				com_rslt +=
-				bmi160_get_accel_offset_compensation_xaxis(
-				&v_foc_accel_offset_x_s8);
-				*v_accel_offset_s8 =
-				v_foc_accel_offset_x_s8;
-			}
-		break;
-		case FOC_Y_AXIS:
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_FOC_ACCEL_Y__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 =
-				BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_FOC_ACCEL_Y,
-				v_foc_accel_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_FOC_ACCEL_Y__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-
-			/* trigger the FOC
-			need to write 0x03
-			in the register 0x7e*/
-			com_rslt +=
-			bmi160_set_command_register(
-			START_FOC_ACCEL_GYRO);
-
-			com_rslt +=
-			bmi160_get_foc_rdy(&focstatus);
-			if ((com_rslt != SUCCESS) ||
-			(focstatus != BMI160_FOC_STAT_HIGH)) {
-				while ((com_rslt != SUCCESS) ||
-				(focstatus != BMI160_FOC_STAT_HIGH
-				&& v_timeout_u8 <
-				BMI160_MAXIMUM_TIMEOUT)) {
-					p_bmi160->delay_msec(
-					BMI160_DELAY_SETTLING_TIME);
-					com_rslt = bmi160_get_foc_rdy(
-					&focstatus);
-					v_timeout_u8++;
-				}
-			}
-			if ((com_rslt == SUCCESS) &&
-			(focstatus == BMI160_FOC_STAT_HIGH)) {
-				com_rslt +=
-				bmi160_get_accel_offset_compensation_yaxis(
-				&v_foc_accel_offset_y_s8);
-				*v_accel_offset_s8 =
-				v_foc_accel_offset_y_s8;
-			}
-		break;
-		case FOC_Z_AXIS:
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_FOC_ACCEL_Z__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 =
-				BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_FOC_ACCEL_Z,
-				v_foc_accel_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_FOC_ACCEL_Z__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-
-			/* trigger the FOC need to write
-			0x03 in the register 0x7e*/
-			com_rslt +=
-			bmi160_set_command_register(
-			START_FOC_ACCEL_GYRO);
-
-			com_rslt +=
-			bmi160_get_foc_rdy(&focstatus);
-			if ((com_rslt != SUCCESS) ||
-			(focstatus != BMI160_FOC_STAT_HIGH)) {
-				while ((com_rslt != SUCCESS) ||
-				(focstatus != BMI160_FOC_STAT_HIGH
-				&& v_timeout_u8 <
-				BMI160_MAXIMUM_TIMEOUT)) {
-					p_bmi160->delay_msec(
-					BMI160_DELAY_SETTLING_TIME);
-					com_rslt = bmi160_get_foc_rdy(
-					&focstatus);
-					v_timeout_u8++;
-				}
-			}
-			if ((com_rslt == SUCCESS) &&
-			(focstatus == BMI160_FOC_STAT_HIGH)) {
-				com_rslt +=
-				bmi160_get_accel_offset_compensation_zaxis(
-				&v_foc_accel_offset_z_s8);
-				*v_accel_offset_s8 =
-				v_foc_accel_offset_z_s8;
-			}
-		break;
-		default:
-		break;
-		}
-	} else {
-	com_rslt =  ERROR;
-	}
-}
-return com_rslt;
-}
-/*!
- *	@brief This API write fast accel offset compensation
- *	it writes all axis together.To the register 0x69 bit 0 to 5
- *	FOC_X_AXIS - bit 4 and 5
- *	FOC_Y_AXIS - bit 2 and 3
- *	FOC_Z_AXIS - bit 0 and 1
- *
- *  @param  v_foc_accel_x_u8: The value of accel offset x compensation
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | disable
- *  0x01     | +1g
- *  0x01     | -1g
- *  0x01     | 0g
- *
- *  @param  v_foc_accel_y_u8: The value of accel offset y compensation
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | disable
- *  0x01     | +1g
- *  0x01     | -1g
- *  0x01     | 0g
- *
- *  @param  v_foc_accel_z_u8: The value of accel offset z compensation
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | disable
- *  0x01     | +1g
- *  0x01     | -1g
- *  0x01     | 0g
- *
- *  @param  v_accel_off_x_s8: The value of accel offset x axis
- *  @param  v_accel_off_y_s8: The value of accel offset y axis
- *  @param  v_accel_off_z_s8: The value of accel offset z axis
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_accel_foc_trigger_xyz(u8 v_foc_accel_x_u8,
-u8 v_foc_accel_y_u8, u8 v_foc_accel_z_u8, s8 *v_accel_off_x_s8,
-s8 *v_accel_off_y_s8, s8 *v_accel_off_z_s8)
-{
-/* variable used for return the status of communication result*/
-BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 focx = BMI160_INIT_VALUE;
-u8 focy = BMI160_INIT_VALUE;
-u8 focz = BMI160_INIT_VALUE;
-s8 v_foc_accel_offset_x_s8 = BMI160_INIT_VALUE;
-s8 v_foc_accel_offset_y_s8 = BMI160_INIT_VALUE;
-s8 v_foc_accel_offset_z_s8 = BMI160_INIT_VALUE;
-u8 v_status_s8 = SUCCESS;
-u8 v_timeout_u8 = BMI160_INIT_VALUE;
-u8 focstatus = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-		v_status_s8 = bmi160_set_accel_offset_enable(
-		ACCEL_OFFSET_ENABLE);
-		if (v_status_s8 == SUCCESS) {
-			/* foc x axis*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_FOC_ACCEL_X__REG,
-			&focx, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				focx = BMI160_SET_BITSLICE(focx,
-				BMI160_USER_FOC_ACCEL_X,
-				v_foc_accel_x_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_FOC_ACCEL_X__REG,
-				&focx, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-
-			/* foc y axis*/
-			com_rslt +=
-			p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_FOC_ACCEL_Y__REG,
-			&focy, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				focy = BMI160_SET_BITSLICE(focy,
-				BMI160_USER_FOC_ACCEL_Y,
-				v_foc_accel_y_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_FOC_ACCEL_Y__REG,
-				&focy, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-
-			/* foc z axis*/
-			com_rslt +=
-			p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_FOC_ACCEL_Z__REG,
-			&focz, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				focz = BMI160_SET_BITSLICE(focz,
-				BMI160_USER_FOC_ACCEL_Z,
-				v_foc_accel_z_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_FOC_ACCEL_Z__REG,
-				&focz, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-
-			/* trigger the FOC need to
-			write 0x03 in the register 0x7e*/
-			com_rslt += bmi160_set_command_register(
-			START_FOC_ACCEL_GYRO);
-
-			com_rslt += bmi160_get_foc_rdy(
-			&focstatus);
-			if ((com_rslt != SUCCESS) ||
-			(focstatus != BMI160_FOC_STAT_HIGH)) {
-				while ((com_rslt != SUCCESS) ||
-				(focstatus != BMI160_FOC_STAT_HIGH
-				&& v_timeout_u8 <
-				BMI160_MAXIMUM_TIMEOUT)) {
-					p_bmi160->delay_msec(
-					BMI160_DELAY_SETTLING_TIME);
-					com_rslt = bmi160_get_foc_rdy(
-					&focstatus);
-					v_timeout_u8++;
-				}
-			}
-			if ((com_rslt == SUCCESS) &&
-			(focstatus == BMI160_GEN_READ_WRITE_DATA_LENGTH)) {
-				com_rslt +=
-				bmi160_get_accel_offset_compensation_xaxis(
-				&v_foc_accel_offset_x_s8);
-				*v_accel_off_x_s8 =
-				v_foc_accel_offset_x_s8;
-				com_rslt +=
-				bmi160_get_accel_offset_compensation_yaxis(
-				&v_foc_accel_offset_y_s8);
-				*v_accel_off_y_s8 =
-				v_foc_accel_offset_y_s8;
-				com_rslt +=
-				bmi160_get_accel_offset_compensation_zaxis(
-				&v_foc_accel_offset_z_s8);
-				*v_accel_off_z_s8 =
-				v_foc_accel_offset_z_s8;
-			}
-		} else {
-		com_rslt =  ERROR;
-		}
-	}
-return com_rslt;
-}
-/*!
- *	@brief This API read gyro fast offset enable
- *	from the register 0x69 bit 6
- *
- *  @param v_foc_gyro_u8 : The value of gyro fast offset enable
- *  value    |  Description
- * ----------|-------------
- *    0      | fast offset compensation disabled
- *    1      |  fast offset compensation enabled
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_foc_gyro_enable(
-u8 *v_foc_gyro_u8)
-{
-	/* used for return the status of bus communication */
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the gyro fast offset enable*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_FOC_GYRO_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_foc_gyro_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_FOC_GYRO_ENABLE);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API write gyro fast offset enable
- *	from the register 0x69 bit 6
- *
- *  @param v_foc_gyro_u8 : The value of gyro fast offset enable
- *  value    |  Description
- * ----------|-------------
- *    0      | fast offset compensation disabled
- *    1      |  fast offset compensation enabled
- *
- *	@param v_gyro_off_x_s16 : The value of gyro fast offset x axis data
- *	@param v_gyro_off_y_s16 : The value of gyro fast offset y axis data
- *	@param v_gyro_off_z_s16 : The value of gyro fast offset z axis data
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_foc_gyro_enable(
-u8 v_foc_gyro_u8, s16 *v_gyro_off_x_s16,
-s16 *v_gyro_off_y_s16, s16 *v_gyro_off_z_s16)
-{
-/* variable used for return the status of communication result*/
-BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-u8 v_status_s8 = SUCCESS;
-u8 v_timeout_u8 = BMI160_INIT_VALUE;
-s16 offsetx = BMI160_INIT_VALUE;
-s16 offsety = BMI160_INIT_VALUE;
-s16 offsetz = BMI160_INIT_VALUE;
-u8 focstatus = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-		v_status_s8 = bmi160_set_gyro_offset_enable(
-		GYRO_OFFSET_ENABLE);
-		if (v_status_s8 == SUCCESS) {
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_FOC_GYRO_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 =
-				BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_FOC_GYRO_ENABLE,
-				v_foc_gyro_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC
-				(p_bmi160->dev_addr,
-				BMI160_USER_FOC_GYRO_ENABLE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-
-			/* trigger the FOC need to write 0x03
-			in the register 0x7e*/
-			com_rslt += bmi160_set_command_register
-			(START_FOC_ACCEL_GYRO);
-
-			com_rslt += bmi160_get_foc_rdy(&focstatus);
-			if ((com_rslt != SUCCESS) ||
-			(focstatus != BMI160_FOC_STAT_HIGH)) {
-				while ((com_rslt != SUCCESS) ||
-				(focstatus != BMI160_FOC_STAT_HIGH
-				&& v_timeout_u8 <
-				BMI160_MAXIMUM_TIMEOUT)) {
-					p_bmi160->delay_msec(
-					BMI160_DELAY_SETTLING_TIME);
-					com_rslt = bmi160_get_foc_rdy(
-					&focstatus);
-					v_timeout_u8++;
-				}
-			}
-			if ((com_rslt == SUCCESS) &&
-			(focstatus == BMI160_FOC_STAT_HIGH)) {
-				com_rslt +=
-				bmi160_get_gyro_offset_compensation_xaxis
-				(&offsetx);
-				*v_gyro_off_x_s16 = offsetx;
-
-				com_rslt +=
-				bmi160_get_gyro_offset_compensation_yaxis
-				(&offsety);
-				*v_gyro_off_y_s16 = offsety;
-
-				com_rslt +=
-				bmi160_get_gyro_offset_compensation_zaxis(
-				&offsetz);
-				*v_gyro_off_z_s16 = offsetz;
-			}
-		} else {
-		com_rslt = ERROR;
-		}
-	}
-return com_rslt;
-}
- /*!
- *	@brief This API read NVM program enable
- *	from the register 0x6A bit 1
- *
- *  @param v_nvm_prog_u8 : The value of NVM program enable
- *  Value  |  Description
- * --------|-------------
- *   0     |  DISABLE
- *   1     |  ENABLE
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_nvm_prog_enable(
-u8 *v_nvm_prog_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read NVM program*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_CONFIG_NVM_PROG_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_nvm_prog_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_CONFIG_NVM_PROG_ENABLE);
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API write NVM program enable
- *	from the register 0x6A bit 1
- *
- *  @param v_nvm_prog_u8 : The value of NVM program enable
- *  Value  |  Description
- * --------|-------------
- *   0     |  DISABLE
- *   1     |  ENABLE
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_nvm_prog_enable(
-u8 v_nvm_prog_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_nvm_prog_u8 <= BMI160_MAX_VALUE_NVM_PROG) {
-			/* write the NVM program*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_CONFIG_NVM_PROG_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_CONFIG_NVM_PROG_ENABLE,
-				v_nvm_prog_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_CONFIG_NVM_PROG_ENABLE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- * @brief This API read to configure SPI
- * Interface Mode for primary and OIS interface
- * from the register 0x6B bit 0
- *
- *  @param v_spi3_u8 : The value of SPI mode selection
- *  Value  |  Description
- * --------|-------------
- *   0     |  SPI 4-wire mode
- *   1     |  SPI 3-wire mode
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_spi3(
-u8 *v_spi3_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read SPI mode*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_IF_CONFIG_SPI3__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_spi3_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_IF_CONFIG_SPI3);
-		}
-	return com_rslt;
-}
-/*!
- * @brief This API write to configure SPI
- * Interface Mode for primary and OIS interface
- * from the register 0x6B bit 0
- *
- *  @param v_spi3_u8 : The value of SPI mode selection
- *  Value  |  Description
- * --------|-------------
- *   0     |  SPI 4-wire mode
- *   1     |  SPI 3-wire mode
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_spi3(
-u8 v_spi3_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_spi3_u8 <= BMI160_MAX_VALUE_SPI3) {
-			/* write SPI mode*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_IF_CONFIG_SPI3__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_IF_CONFIG_SPI3,
-				v_spi3_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_IF_CONFIG_SPI3__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API read I2C Watchdog timer
- *	from the register 0x70 bit 1
- *
- *  @param v_i2c_wdt_u8 : The value of I2C watch dog timer
- *  Value  |  Description
- * --------|-------------
- *   0     |  I2C watchdog v_timeout_u8 after 1 ms
- *   1     |  I2C watchdog v_timeout_u8 after 50 ms
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_i2c_wdt_select(
-u8 *v_i2c_wdt_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read I2C watch dog timer */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_IF_CONFIG_I2C_WDT_SELECT__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_i2c_wdt_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_IF_CONFIG_I2C_WDT_SELECT);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API write I2C Watchdog timer
- *	from the register 0x70 bit 1
- *
- *  @param v_i2c_wdt_u8 : The value of I2C watch dog timer
- *  Value  |  Description
- * --------|-------------
- *   0     |  I2C watchdog v_timeout_u8 after 1 ms
- *   1     |  I2C watchdog v_timeout_u8 after 50 ms
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_i2c_wdt_select(
-u8 v_i2c_wdt_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_i2c_wdt_u8 <= BMI160_MAX_VALUE_I2C_WDT) {
-			/* write I2C watch dog timer */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_IF_CONFIG_I2C_WDT_SELECT__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_IF_CONFIG_I2C_WDT_SELECT,
-				v_i2c_wdt_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_IF_CONFIG_I2C_WDT_SELECT__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API read I2C watchdog enable
- *	from the register 0x70 bit 2
- *
- *  @param v_i2c_wdt_u8 : The value of I2C watchdog enable
- *  Value  |  Description
- * --------|-------------
- *   0     |  DISABLE
- *   1     |  ENABLE
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_i2c_wdt_enable(
-u8 *v_i2c_wdt_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read i2c watch dog eneble */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_IF_CONFIG_I2C_WDT_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_i2c_wdt_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_IF_CONFIG_I2C_WDT_ENABLE);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API write I2C watchdog enable
- *	from the register 0x70 bit 2
- *
- *  @param v_i2c_wdt_u8 : The value of I2C watchdog enable
- *  Value  |  Description
- * --------|-------------
- *   0     |  DISABLE
- *   1     |  ENABLE
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_i2c_wdt_enable(
-u8 v_i2c_wdt_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_i2c_wdt_u8 <= BMI160_MAX_VALUE_I2C_WDT) {
-			/* write i2c watch dog eneble */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_IF_CONFIG_I2C_WDT_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_IF_CONFIG_I2C_WDT_ENABLE,
-				v_i2c_wdt_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_IF_CONFIG_I2C_WDT_ENABLE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- * @brief This API read I2C interface configuration(if) moe
- * from the register 0x6B bit 4 and 5
- *
- *  @param  v_if_mode_u8 : The value of interface configuration mode
- *  Value  |  Description
- * --------|-------------
- *   0x00  |  Primary interface:autoconfig / secondary interface:off
- *   0x01  |  Primary interface:I2C / secondary interface:OIS
- *   0x02  |  Primary interface:autoconfig/secondary interface:Magnetometer
- *   0x03  |   Reserved
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_if_mode(
-u8 *v_if_mode_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read if mode*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_IF_CONFIG_IF_MODE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_if_mode_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_IF_CONFIG_IF_MODE);
-		}
-	return com_rslt;
-}
-/*!
- * @brief This API write I2C interface configuration(if) moe
- * from the register 0x6B bit 4 and 5
- *
- *  @param  v_if_mode_u8 : The value of interface configuration mode
- *  Value  |  Description
- * --------|-------------
- *   0x00  |  Primary interface:autoconfig / secondary interface:off
- *   0x01  |  Primary interface:I2C / secondary interface:OIS
- *   0x02  |  Primary interface:autoconfig/secondary interface:Magnetometer
- *   0x03  |   Reserved
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_if_mode(
-u8 v_if_mode_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_if_mode_u8 <= BMI160_MAX_IF_MODE) {
-			/* write if mode*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_IF_CONFIG_IF_MODE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_IF_CONFIG_IF_MODE,
-				v_if_mode_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_IF_CONFIG_IF_MODE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API read gyro sleep trigger
- *	from the register 0x6C bit 0 to 2
- *
- *  @param v_gyro_sleep_trigger_u8 : The value of gyro sleep trigger
- *  Value  |  Description
- * --------|-------------
- *   0x00  | nomotion: no / Not INT1 pin: no / INT2 pin: no
- *   0x01  | nomotion: no / Not INT1 pin: no / INT2 pin: yes
- *   0x02  | nomotion: no / Not INT1 pin: yes / INT2 pin: no
- *   0x03  | nomotion: no / Not INT1 pin: yes / INT2 pin: yes
- *   0x04  | nomotion: yes / Not INT1 pin: no / INT2 pin: no
- *   0x05  | anymotion: yes / Not INT1 pin: no / INT2 pin: yes
- *   0x06  | anymotion: yes / Not INT1 pin: yes / INT2 pin: no
- *   0x07  | anymotion: yes / Not INT1 pin: yes / INT2 pin: yes
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_sleep_trigger(
-u8 *v_gyro_sleep_trigger_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read gyro sleep trigger */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_GYRO_SLEEP_TRIGGER__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_gyro_sleep_trigger_u8 =
-			BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_GYRO_SLEEP_TRIGGER);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API write gyro sleep trigger
- *	from the register 0x6C bit 0 to 2
- *
- *  @param v_gyro_sleep_trigger_u8 : The value of gyro sleep trigger
- *  Value  |  Description
- * --------|-------------
- *   0x00  | nomotion: no / Not INT1 pin: no / INT2 pin: no
- *   0x01  | nomotion: no / Not INT1 pin: no / INT2 pin: yes
- *   0x02  | nomotion: no / Not INT1 pin: yes / INT2 pin: no
- *   0x03  | nomotion: no / Not INT1 pin: yes / INT2 pin: yes
- *   0x04  | nomotion: yes / Not INT1 pin: no / INT2 pin: no
- *   0x05  | anymotion: yes / Not INT1 pin: no / INT2 pin: yes
- *   0x06  | anymotion: yes / Not INT1 pin: yes / INT2 pin: no
- *   0x07  | anymotion: yes / Not INT1 pin: yes / INT2 pin: yes
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_sleep_trigger(
-u8 v_gyro_sleep_trigger_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_gyro_sleep_trigger_u8 <= BMI160_MAX_GYRO_SLEEP_TIGGER) {
-			/* write gyro sleep trigger */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_GYRO_SLEEP_TRIGGER__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_GYRO_SLEEP_TRIGGER,
-				v_gyro_sleep_trigger_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_GYRO_SLEEP_TRIGGER__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API read gyro wakeup trigger
- *	from the register 0x6C bit 3 and 4
- *
- *  @param v_gyro_wakeup_trigger_u8 : The value of gyro wakeup trigger
- *  Value  |  Description
- * --------|-------------
- *   0x00  | anymotion: no / INT1 pin: no
- *   0x01  | anymotion: no / INT1 pin: yes
- *   0x02  | anymotion: yes / INT1 pin: no
- *   0x03  | anymotion: yes / INT1 pin: yes
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_wakeup_trigger(
-u8 *v_gyro_wakeup_trigger_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read gyro wakeup trigger */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_GYRO_WAKEUP_TRIGGER__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_gyro_wakeup_trigger_u8 = BMI160_GET_BITSLICE(
-			v_data_u8,
-			BMI160_USER_GYRO_WAKEUP_TRIGGER);
-	  }
-	return com_rslt;
-}
-/*!
- *	@brief This API write gyro wakeup trigger
- *	from the register 0x6C bit 3 and 4
- *
- *  @param v_gyro_wakeup_trigger_u8 : The value of gyro wakeup trigger
- *  Value  |  Description
- * --------|-------------
- *   0x00  | anymotion: no / INT1 pin: no
- *   0x01  | anymotion: no / INT1 pin: yes
- *   0x02  | anymotion: yes / INT1 pin: no
- *   0x03  | anymotion: yes / INT1 pin: yes
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_wakeup_trigger(
-u8 v_gyro_wakeup_trigger_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_gyro_wakeup_trigger_u8
-		<= BMI160_MAX_GYRO_WAKEUP_TRIGGER) {
-			/* write gyro wakeup trigger */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_GYRO_WAKEUP_TRIGGER__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_GYRO_WAKEUP_TRIGGER,
-				v_gyro_wakeup_trigger_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_GYRO_WAKEUP_TRIGGER__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API read Target state for gyro sleep mode
- *	from the register 0x6C bit 5
- *
- *  @param v_gyro_sleep_state_u8 : The value of gyro sleep mode
- *  Value  |  Description
- * --------|-------------
- *   0x00  | Sleep transition to fast wake up state
- *   0x01  | Sleep transition to suspend state
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_sleep_state(
-u8 *v_gyro_sleep_state_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read gyro sleep state*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_GYRO_SLEEP_STATE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_gyro_sleep_state_u8 = BMI160_GET_BITSLICE(
-			v_data_u8,
-			BMI160_USER_GYRO_SLEEP_STATE);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API write Target state for gyro sleep mode
- *	from the register 0x6C bit 5
- *
- *  @param v_gyro_sleep_state_u8 : The value of gyro sleep mode
- *  Value  |  Description
- * --------|-------------
- *   0x00  | Sleep transition to fast wake up state
- *   0x01  | Sleep transition to suspend state
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_sleep_state(
-u8 v_gyro_sleep_state_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_gyro_sleep_state_u8 <= BMI160_MAX_VALUE_SLEEP_STATE) {
-			/* write gyro sleep state*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_GYRO_SLEEP_STATE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_GYRO_SLEEP_STATE,
-				v_gyro_sleep_state_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_GYRO_SLEEP_STATE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API read gyro wakeup interrupt
- *	from the register 0x6C bit 6
- *
- *  @param v_gyro_wakeup_intr_u8 : The valeu of gyro wakeup interrupt
- *  Value  |  Description
- * --------|-------------
- *   0x00  | DISABLE
- *   0x01  | ENABLE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_wakeup_intr(
-u8 *v_gyro_wakeup_intr_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read gyro wakeup interrupt */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_GYRO_WAKEUP_INTR__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_gyro_wakeup_intr_u8 = BMI160_GET_BITSLICE(
-			v_data_u8,
-			BMI160_USER_GYRO_WAKEUP_INTR);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API write gyro wakeup interrupt
- *	from the register 0x6C bit 6
- *
- *  @param v_gyro_wakeup_intr_u8 : The valeu of gyro wakeup interrupt
- *  Value  |  Description
- * --------|-------------
- *   0x00  | DISABLE
- *   0x01  | ENABLE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_wakeup_intr(
-u8 v_gyro_wakeup_intr_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_gyro_wakeup_intr_u8 <= BMI160_MAX_VALUE_WAKEUP_INTR) {
-			/* write gyro wakeup interrupt */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_GYRO_WAKEUP_INTR__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_GYRO_WAKEUP_INTR,
-				v_gyro_wakeup_intr_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_GYRO_WAKEUP_INTR__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- * @brief This API read accel select axis to be self-test
- *
- *  @param v_accel_selftest_axis_u8 :
- *	The value of accel self test axis selection
- *  Value  |  Description
- * --------|-------------
- *   0x00  | disabled
- *   0x01  | x-axis
- *   0x02  | y-axis
- *   0x03  | z-axis
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_selftest_axis(
-u8 *v_accel_selftest_axis_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read accel self test axis*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_ACCEL_SELFTEST_AXIS__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_accel_selftest_axis_u8 = BMI160_GET_BITSLICE(
-			v_data_u8,
-			BMI160_USER_ACCEL_SELFTEST_AXIS);
-		}
-	return com_rslt;
-}
-/*!
- * @brief This API write accel select axis to be self-test
- *
- *  @param v_accel_selftest_axis_u8 :
- *	The value of accel self test axis selection
- *  Value  |  Description
- * --------|-------------
- *   0x00  | disabled
- *   0x01  | x-axis
- *   0x02  | y-axis
- *   0x03  | z-axis
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_selftest_axis(
-u8 v_accel_selftest_axis_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_accel_selftest_axis_u8
-		<= BMI160_MAX_ACCEL_SELFTEST_AXIS) {
-			/* write accel self test axis*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_ACCEL_SELFTEST_AXIS__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_ACCEL_SELFTEST_AXIS,
-				v_accel_selftest_axis_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_ACCEL_SELFTEST_AXIS__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API read accel self test axis sign
- *	from the register 0x6D bit 2
- *
- *  @param v_accel_selftest_sign_u8: The value of accel self test axis sign
- *  Value  |  Description
- * --------|-------------
- *   0x00  | negative
- *   0x01  | positive
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_selftest_sign(
-u8 *v_accel_selftest_sign_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read accel self test axis sign*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_ACCEL_SELFTEST_SIGN__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_accel_selftest_sign_u8 = BMI160_GET_BITSLICE(
-			v_data_u8,
-			BMI160_USER_ACCEL_SELFTEST_SIGN);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API write accel self test axis sign
- *	from the register 0x6D bit 2
- *
- *  @param v_accel_selftest_sign_u8: The value of accel self test axis sign
- *  Value  |  Description
- * --------|-------------
- *   0x00  | negative
- *   0x01  | positive
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_selftest_sign(
-u8 v_accel_selftest_sign_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_accel_selftest_sign_u8 <=
-		BMI160_MAX_VALUE_SELFTEST_SIGN) {
-			/* write accel self test axis sign*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_ACCEL_SELFTEST_SIGN__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_ACCEL_SELFTEST_SIGN,
-				v_accel_selftest_sign_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_ACCEL_SELFTEST_SIGN__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-			com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API read accel self test amplitude
- *	from the register 0x6D bit 3
- *        select amplitude of the selftest deflection:
- *
- *  @param v_accel_selftest_amp_u8 : The value of accel self test amplitude
- *  Value  |  Description
- * --------|-------------
- *   0x00  | LOW
- *   0x01  | HIGH
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_selftest_amp(
-u8 *v_accel_selftest_amp_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read  self test amplitude*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_SELFTEST_AMP__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_accel_selftest_amp_u8 = BMI160_GET_BITSLICE(
-			v_data_u8,
-			BMI160_USER_SELFTEST_AMP);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API write accel self test amplitude
- *	from the register 0x6D bit 3
- *        select amplitude of the selftest deflection:
- *
- *  @param v_accel_selftest_amp_u8 : The value of accel self test amplitude
- *  Value  |  Description
- * --------|-------------
- *   0x00  | LOW
- *   0x01  | HIGH
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_selftest_amp(
-u8 v_accel_selftest_amp_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_accel_selftest_amp_u8 <=
-		BMI160_MAX_VALUE_SELFTEST_AMP) {
-			/* write  self test amplitude*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_SELFTEST_AMP__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_SELFTEST_AMP,
-				v_accel_selftest_amp_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_SELFTEST_AMP__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API read gyro self test trigger
- *
- *	@param v_gyro_selftest_start_u8: The value of gyro self test start
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_selftest_start(
-u8 *v_gyro_selftest_start_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read gyro self test start */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_GYRO_SELFTEST_START__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_gyro_selftest_start_u8 = BMI160_GET_BITSLICE(
-			v_data_u8,
-			BMI160_USER_GYRO_SELFTEST_START);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API write gyro self test trigger
- *
- *	@param v_gyro_selftest_start_u8: The value of gyro self test start
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_selftest_start(
-u8 v_gyro_selftest_start_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_gyro_selftest_start_u8 <=
-		BMI160_MAX_VALUE_SELFTEST_START) {
-			/* write gyro self test start */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_GYRO_SELFTEST_START__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_GYRO_SELFTEST_START,
-				v_gyro_selftest_start_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_GYRO_SELFTEST_START__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
- /*!
- * @brief This API read primary interface selection I2C or SPI
- *	from the register 0x70 bit 0
- *
- *  @param v_spi_enable_u8: The value of Interface selection
- *  Value  |  Description
- * --------|-------------
- *   0x00  | I2C Enable
- *   0x01  | I2C DISBALE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_spi_enable(u8 *v_spi_enable_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read interface section*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_NV_CONFIG_SPI_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_spi_enable_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_NV_CONFIG_SPI_ENABLE);
-		}
-	return com_rslt;
-}
- /*!
- * @brief This API write primary interface selection I2C or SPI
- *	from the register 0x70 bit 0
- *
- *  @param v_spi_enable_u8: The value of Interface selection
- *  Value  |  Description
- * --------|-------------
- *   0x00  | I2C Enable
- *   0x01  | I2C DISBALE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_spi_enable(u8 v_spi_enable_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* write interface section*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_NV_CONFIG_SPI_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_NV_CONFIG_SPI_ENABLE,
-				v_spi_enable_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
-				(p_bmi160->dev_addr,
-				BMI160_USER_NV_CONFIG_SPI_ENABLE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API read the spare zero
- *	form register 0x70 bit 3
- *
- *
- *  @param v_spare0_trim_u8: The value of spare zero
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_spare0_trim(u8 *v_spare0_trim_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read spare zero*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_NV_CONFIG_SPARE0__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_spare0_trim_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_NV_CONFIG_SPARE0);
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API write the spare zero
- *	form register 0x70 bit 3
- *
- *
- *  @param v_spare0_trim_u8: The value of spare zero
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_spare0_trim(u8 v_spare0_trim_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* write  spare zero*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_NV_CONFIG_SPARE0__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_NV_CONFIG_SPARE0,
-				v_spare0_trim_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_NV_CONFIG_SPARE0__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API read the NVM counter
- *	form register 0x70 bit 4 to 7
- *
- *
- *  @param v_nvm_counter_u8: The value of NVM counter
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_nvm_counter(u8 *v_nvm_counter_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read NVM counter*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_NV_CONFIG_NVM_COUNTER__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_nvm_counter_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_NV_CONFIG_NVM_COUNTER);
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API write the NVM counter
- *	form register 0x70 bit 4 to 7
- *
- *
- *  @param v_nvm_counter_u8: The value of NVM counter
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_nvm_counter(
-u8 v_nvm_counter_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* write NVM counter*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_NV_CONFIG_NVM_COUNTER__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_NV_CONFIG_NVM_COUNTER,
-				v_nvm_counter_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_NV_CONFIG_NVM_COUNTER__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API read accel manual offset compensation of x axis
- *	from the register 0x71 bit 0 to 7
- *
- *
- *
- *  @param v_accel_off_x_s8:
- *	The value of accel manual offset compensation of x axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_offset_compensation_xaxis(
-s8 *v_accel_off_x_s8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read accel manual offset compensation of x axis*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_OFFSET_0_ACCEL_OFF_X__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_accel_off_x_s8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_OFFSET_0_ACCEL_OFF_X);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API write accel manual offset compensation of x axis
- *	from the register 0x71 bit 0 to 7
- *
- *
- *
- *  @param v_accel_off_x_s8:
- *	The value of accel manual offset compensation of x axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_offset_compensation_xaxis(
-s8 v_accel_off_x_s8)
-{
-/* variable used for return the status of communication result*/
-BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-u8 v_status_s8 = SUCCESS;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-		/* enable accel offset */
-		v_status_s8 = bmi160_set_accel_offset_enable(
-		ACCEL_OFFSET_ENABLE);
-		if (v_status_s8 == SUCCESS) {
-			/* write accel manual offset compensation of x axis*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_OFFSET_0_ACCEL_OFF_X__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 =
-				BMI160_SET_BITSLICE(
-				v_data_u8,
-				BMI160_USER_OFFSET_0_ACCEL_OFF_X,
-				v_accel_off_x_s8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_OFFSET_0_ACCEL_OFF_X__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt =  ERROR;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API read accel manual offset compensation of y axis
- *	from the register 0x72 bit 0 to 7
- *
- *
- *
- *  @param v_accel_off_y_s8:
- *	The value of accel manual offset compensation of y axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_offset_compensation_yaxis(
-s8 *v_accel_off_y_s8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read accel manual offset compensation of y axis*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_OFFSET_1_ACCEL_OFF_Y__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_accel_off_y_s8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_OFFSET_1_ACCEL_OFF_Y);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API write accel manual offset compensation of y axis
- *	from the register 0x72 bit 0 to 7
- *
- *
- *
- *  @param v_accel_off_y_s8:
- *	The value of accel manual offset compensation of y axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_offset_compensation_yaxis(
-s8 v_accel_off_y_s8)
-{
-/* variable used for return the status of communication result*/
-BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-u8 v_status_s8 = SUCCESS;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-		/* enable accel offset */
-		v_status_s8 = bmi160_set_accel_offset_enable(
-		ACCEL_OFFSET_ENABLE);
-		if (v_status_s8 == SUCCESS) {
-			/* write accel manual offset compensation of y axis*/
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_OFFSET_1_ACCEL_OFF_Y__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 =
-				BMI160_SET_BITSLICE(
-				v_data_u8,
-				BMI160_USER_OFFSET_1_ACCEL_OFF_Y,
-				v_accel_off_y_s8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_OFFSET_1_ACCEL_OFF_Y__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = ERROR;
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API read accel manual offset compensation of z axis
- *	from the register 0x73 bit 0 to 7
- *
- *
- *
- *  @param v_accel_off_z_s8:
- *	The value of accel manual offset compensation of z axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_offset_compensation_zaxis(
-s8 *v_accel_off_z_s8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read accel manual offset compensation of z axis*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_OFFSET_2_ACCEL_OFF_Z__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_accel_off_z_s8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_OFFSET_2_ACCEL_OFF_Z);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API write accel manual offset compensation of z axis
- *	from the register 0x73 bit 0 to 7
- *
- *
- *
- *  @param v_accel_off_z_s8:
- *	The value of accel manual offset compensation of z axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_offset_compensation_zaxis(
-s8 v_accel_off_z_s8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	u8 v_status_s8 = SUCCESS;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* enable accel offset */
-			v_status_s8 = bmi160_set_accel_offset_enable(
-			ACCEL_OFFSET_ENABLE);
-			if (v_status_s8 == SUCCESS) {
-				/* write accel manual offset
-				compensation of z axis*/
-				com_rslt =
-				p_bmi160->BMI160_BUS_READ_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_OFFSET_2_ACCEL_OFF_Z__REG,
-				&v_data_u8,
-				BMI160_GEN_READ_WRITE_DATA_LENGTH);
-				if (com_rslt == SUCCESS) {
-					v_data_u8 =
-					BMI160_SET_BITSLICE(v_data_u8,
-					BMI160_USER_OFFSET_2_ACCEL_OFF_Z,
-					v_accel_off_z_s8);
-					com_rslt +=
-					p_bmi160->BMI160_BUS_WRITE_FUNC(
-					p_bmi160->dev_addr,
-					BMI160_USER_OFFSET_2_ACCEL_OFF_Z__REG,
-					&v_data_u8,
-					BMI160_GEN_READ_WRITE_DATA_LENGTH);
-				}
-			} else {
-			com_rslt = ERROR;
-			}
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API read gyro manual offset compensation of x axis
- *	from the register 0x74 bit 0 to 7 and 0x77 bit 0 and 1
- *
- *
- *
- *  @param v_gyro_off_x_s16:
- *	The value of gyro manual offset compensation of x axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_offset_compensation_xaxis(
-s16 *v_gyro_off_x_s16)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data1_u8r = BMI160_INIT_VALUE;
-	u8 v_data2_u8r = BMI160_INIT_VALUE;
-	s16 v_data3_u8r, v_data4_u8r = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read gyro offset x*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_OFFSET_3_GYRO_OFF_X__REG,
-			&v_data1_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			v_data1_u8r = BMI160_GET_BITSLICE(v_data1_u8r,
-			BMI160_USER_OFFSET_3_GYRO_OFF_X);
-			com_rslt += p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_OFFSET_6_GYRO_OFF_X__REG,
-			&v_data2_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			v_data2_u8r = BMI160_GET_BITSLICE(v_data2_u8r,
-			BMI160_USER_OFFSET_6_GYRO_OFF_X);
-			v_data3_u8r = v_data2_u8r
-			<< BMI160_SHIFT_BIT_POSITION_BY_14_BITS;
-			v_data4_u8r =  v_data1_u8r
-			<< BMI160_SHIFT_BIT_POSITION_BY_06_BITS;
-			v_data3_u8r = v_data3_u8r | v_data4_u8r;
-			*v_gyro_off_x_s16 = v_data3_u8r
-			>> BMI160_SHIFT_BIT_POSITION_BY_06_BITS;
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API write gyro manual offset compensation of x axis
- *	from the register 0x74 bit 0 to 7 and 0x77 bit 0 and 1
- *
- *
- *
- *  @param v_gyro_off_x_s16:
- *	The value of gyro manual offset compensation of x axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_offset_compensation_xaxis(
-s16 v_gyro_off_x_s16)
-{
-/* variable used for return the status of communication result*/
-BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data1_u8r, v_data2_u8r = BMI160_INIT_VALUE;
-u16 v_data3_u8r = BMI160_INIT_VALUE;
-u8 v_status_s8 = SUCCESS;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-		/* write gyro offset x*/
-		v_status_s8 = bmi160_set_gyro_offset_enable(
-		GYRO_OFFSET_ENABLE);
-		if (v_status_s8 == SUCCESS) {
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_OFFSET_3_GYRO_OFF_X__REG,
-			&v_data2_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data1_u8r =
-				((s8) (v_gyro_off_x_s16 &
-				BMI160_GYRO_MANUAL_OFFSET_0_7));
-				v_data2_u8r = BMI160_SET_BITSLICE(
-				v_data2_u8r,
-				BMI160_USER_OFFSET_3_GYRO_OFF_X,
-				v_data1_u8r);
-				/* write 0x74 bit 0 to 7*/
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_OFFSET_3_GYRO_OFF_X__REG,
-				&v_data2_u8r,
-				BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-
-			com_rslt += p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_OFFSET_6_GYRO_OFF_X__REG,
-			&v_data2_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data3_u8r =
-				(u16) (v_gyro_off_x_s16 &
-				BMI160_GYRO_MANUAL_OFFSET_8_9);
-				v_data1_u8r = (u8)(v_data3_u8r
-				>> BMI160_SHIFT_BIT_POSITION_BY_08_BITS);
-				v_data2_u8r = BMI160_SET_BITSLICE(
-				v_data2_u8r,
-				BMI160_USER_OFFSET_6_GYRO_OFF_X,
-				v_data1_u8r);
-				/* write 0x77 bit 0 and 1*/
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_OFFSET_6_GYRO_OFF_X__REG,
-				&v_data2_u8r,
-				BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		return ERROR;
-		}
-	}
-return com_rslt;
-}
-/*!
- *	@brief This API read gyro manual offset compensation of y axis
- *	from the register 0x75 bit 0 to 7 and 0x77 bit 2 and 3
- *
- *
- *
- *  @param v_gyro_off_y_s16:
- *	The value of gyro manual offset compensation of y axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_offset_compensation_yaxis(
-s16 *v_gyro_off_y_s16)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data1_u8r = BMI160_INIT_VALUE;
-	u8 v_data2_u8r = BMI160_INIT_VALUE;
-	s16 v_data3_u8r, v_data4_u8r = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read gyro offset y*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_OFFSET_4_GYRO_OFF_Y__REG,
-			&v_data1_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			v_data1_u8r = BMI160_GET_BITSLICE(v_data1_u8r,
-			BMI160_USER_OFFSET_4_GYRO_OFF_Y);
-			com_rslt += p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_OFFSET_6_GYRO_OFF_Y__REG,
-			&v_data2_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			v_data2_u8r = BMI160_GET_BITSLICE(v_data2_u8r,
-			BMI160_USER_OFFSET_6_GYRO_OFF_Y);
-			v_data3_u8r = v_data2_u8r
-			<< BMI160_SHIFT_BIT_POSITION_BY_14_BITS;
-			v_data4_u8r =  v_data1_u8r
-			<< BMI160_SHIFT_BIT_POSITION_BY_06_BITS;
-			v_data3_u8r = v_data3_u8r | v_data4_u8r;
-			*v_gyro_off_y_s16 = v_data3_u8r
-			>> BMI160_SHIFT_BIT_POSITION_BY_06_BITS;
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API write gyro manual offset compensation of y axis
- *	from the register 0x75 bit 0 to 7 and 0x77 bit 2 and 3
- *
- *
- *
- *  @param v_gyro_off_y_s16:
- *	The value of gyro manual offset compensation of y axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_offset_compensation_yaxis(
-s16 v_gyro_off_y_s16)
-{
-/* variable used for return the status of communication result*/
-BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data1_u8r, v_data2_u8r = BMI160_INIT_VALUE;
-u16 v_data3_u8r = BMI160_INIT_VALUE;
-u8 v_status_s8 = SUCCESS;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-		/* enable gyro offset bit */
-		v_status_s8 = bmi160_set_gyro_offset_enable(
-		GYRO_OFFSET_ENABLE);
-		/* write gyro offset y*/
-		if (v_status_s8 == SUCCESS) {
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_OFFSET_4_GYRO_OFF_Y__REG,
-			&v_data2_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data1_u8r =
-				((s8) (v_gyro_off_y_s16 &
-				BMI160_GYRO_MANUAL_OFFSET_0_7));
-				v_data2_u8r = BMI160_SET_BITSLICE(
-				v_data2_u8r,
-				BMI160_USER_OFFSET_4_GYRO_OFF_Y,
-				v_data1_u8r);
-				/* write 0x75 bit 0 to 7*/
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC
-				(p_bmi160->dev_addr,
-				BMI160_USER_OFFSET_4_GYRO_OFF_Y__REG,
-				&v_data2_u8r,
-				BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-
-			com_rslt += p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_OFFSET_6_GYRO_OFF_Y__REG,
-			&v_data2_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data3_u8r =
-				(u16) (v_gyro_off_y_s16 &
-				BMI160_GYRO_MANUAL_OFFSET_8_9);
-				v_data1_u8r = (u8)(v_data3_u8r
-				>> BMI160_SHIFT_BIT_POSITION_BY_08_BITS);
-				v_data2_u8r = BMI160_SET_BITSLICE(
-				v_data2_u8r,
-				BMI160_USER_OFFSET_6_GYRO_OFF_Y,
-				v_data1_u8r);
-				/* write 0x77 bit 2 and 3*/
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC
-				(p_bmi160->dev_addr,
-				BMI160_USER_OFFSET_6_GYRO_OFF_Y__REG,
-				&v_data2_u8r,
-				BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		return ERROR;
-		}
-	}
-return com_rslt;
-}
-/*!
- *	@brief This API read gyro manual offset compensation of z axis
- *	from the register 0x76 bit 0 to 7 and 0x77 bit 4 and 5
- *
- *
- *
- *  @param v_gyro_off_z_s16:
- *	The value of gyro manual offset compensation of z axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_offset_compensation_zaxis(
-s16 *v_gyro_off_z_s16)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data1_u8r = BMI160_INIT_VALUE;
-	u8 v_data2_u8r = BMI160_INIT_VALUE;
-	s16 v_data3_u8r, v_data4_u8r = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read gyro manual offset z axis*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_OFFSET_5_GYRO_OFF_Z__REG,
-			&v_data1_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			v_data1_u8r = BMI160_GET_BITSLICE
-			(v_data1_u8r,
-			BMI160_USER_OFFSET_5_GYRO_OFF_Z);
-			com_rslt +=
-			p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_OFFSET_6_GYRO_OFF_Z__REG,
-			&v_data2_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			v_data2_u8r = BMI160_GET_BITSLICE(
-			v_data2_u8r,
-			BMI160_USER_OFFSET_6_GYRO_OFF_Z);
-			v_data3_u8r = v_data2_u8r
-			<< BMI160_SHIFT_BIT_POSITION_BY_14_BITS;
-			v_data4_u8r =  v_data1_u8r
-			<< BMI160_SHIFT_BIT_POSITION_BY_06_BITS;
-			v_data3_u8r = v_data3_u8r | v_data4_u8r;
-			*v_gyro_off_z_s16 = v_data3_u8r
-			>> BMI160_SHIFT_BIT_POSITION_BY_06_BITS;
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API write gyro manual offset compensation of z axis
- *	from the register 0x76 bit 0 to 7 and 0x77 bit 4 and 5
- *
- *
- *
- *  @param v_gyro_off_z_s16:
- *	The value of gyro manual offset compensation of z axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_offset_compensation_zaxis(
-s16 v_gyro_off_z_s16)
-{
-/* variable used for return the status of communication result*/
-BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data1_u8r, v_data2_u8r = BMI160_INIT_VALUE;
-u16 v_data3_u8r = BMI160_INIT_VALUE;
-u8 v_status_s8 = SUCCESS;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-	} else {
-		/* enable gyro offset*/
-		v_status_s8 = bmi160_set_gyro_offset_enable(
-		GYRO_OFFSET_ENABLE);
-		/* write gyro manual offset z axis*/
-		if (v_status_s8 == SUCCESS) {
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_OFFSET_5_GYRO_OFF_Z__REG,
-			&v_data2_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data1_u8r =
-				((u8) (v_gyro_off_z_s16 &
-				BMI160_GYRO_MANUAL_OFFSET_0_7));
-				v_data2_u8r = BMI160_SET_BITSLICE(
-				v_data2_u8r,
-				BMI160_USER_OFFSET_5_GYRO_OFF_Z,
-				v_data1_u8r);
-				/* write 0x76 bit 0 to 7*/
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC
-				(p_bmi160->dev_addr,
-				BMI160_USER_OFFSET_5_GYRO_OFF_Z__REG,
-				&v_data2_u8r,
-				BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-
-			com_rslt += p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_OFFSET_6_GYRO_OFF_Z__REG,
-			&v_data2_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data3_u8r =
-				(u16) (v_gyro_off_z_s16 &
-				BMI160_GYRO_MANUAL_OFFSET_8_9);
-				v_data1_u8r = (u8)(v_data3_u8r
-				>> BMI160_SHIFT_BIT_POSITION_BY_08_BITS);
-				v_data2_u8r = BMI160_SET_BITSLICE(
-				v_data2_u8r,
-				BMI160_USER_OFFSET_6_GYRO_OFF_Z,
-				v_data1_u8r);
-				/* write 0x77 bit 4 and 5*/
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC
-				(p_bmi160->dev_addr,
-				BMI160_USER_OFFSET_6_GYRO_OFF_Z__REG,
-				&v_data2_u8r,
-				BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		return ERROR;
-		}
-	}
-return com_rslt;
-}
-/*!
- *	@brief This API read the accel offset enable bit
- *	from the register 0x77 bit 6
- *
- *
- *
- *  @param v_accel_off_enable_u8: The value of accel offset enable
- *  value    |  Description
- * ----------|--------------
- *   0x01    | ENABLE
- *   0x00    | DISABLE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_offset_enable(
-u8 *v_accel_off_enable_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read accel offset enable */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_OFFSET_6_ACCEL_OFF_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_accel_off_enable_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_OFFSET_6_ACCEL_OFF_ENABLE);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API write the accel offset enable bit
- *	from the register 0x77 bit 6
- *
- *
- *
- *  @param v_accel_off_enable_u8: The value of accel offset enable
- *  value    |  Description
- * ----------|--------------
- *   0x01    | ENABLE
- *   0x00    | DISABLE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_offset_enable(
-u8 v_accel_off_enable_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-			} else {
-			/* write accel offset enable */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_OFFSET_6_ACCEL_OFF_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_OFFSET_6_ACCEL_OFF_ENABLE,
-				v_accel_off_enable_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_OFFSET_6_ACCEL_OFF_ENABLE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API read the accel offset enable bit
- *	from the register 0x77 bit 7
- *
- *
- *
- *  @param v_gyro_off_enable_u8: The value of gyro offset enable
- *  value    |  Description
- * ----------|--------------
- *   0x01    | ENABLE
- *   0x00    | DISABLE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_offset_enable(
-u8 *v_gyro_off_enable_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read gyro offset*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_OFFSET_6_GYRO_OFF_EN__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_gyro_off_enable_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_OFFSET_6_GYRO_OFF_EN);
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API write the accel offset enable bit
- *	from the register 0x77 bit 7
- *
- *
- *
- *  @param v_gyro_off_enable_u8: The value of gyro offset enable
- *  value    |  Description
- * ----------|--------------
- *   0x01    | ENABLE
- *   0x00    | DISABLE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_offset_enable(
-u8 v_gyro_off_enable_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* write gyro offset*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_OFFSET_6_GYRO_OFF_EN__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_USER_OFFSET_6_GYRO_OFF_EN,
-				v_gyro_off_enable_u8);
-				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
-				p_bmi160->dev_addr,
-				BMI160_USER_OFFSET_6_GYRO_OFF_EN__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This API reads step counter value
- *	form the register 0x78 and 0x79
- *
- *
- *
- *
- *  @param v_step_cnt_s16 : The value of step counter
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_step_count(s16 *v_step_cnt_s16)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* array having the step counter LSB and MSB data
-	v_data_u8[0] - LSB
-	v_data_u8[1] - MSB*/
-	u8 a_data_u8r[BMI160_STEP_COUNT_DATA_SIZE] = {BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE};
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read step counter */
-			com_rslt =
-			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-			BMI160_USER_STEP_COUNT_LSB__REG,
-			a_data_u8r, BMI160_STEP_COUNTER_LENGTH);
-
-			*v_step_cnt_s16 = (s16)
-			((((s32)((s8)a_data_u8r[BMI160_STEP_COUNT_MSB_BYTE]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			| (a_data_u8r[BMI160_STEP_COUNT_LSB_BYTE]));
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API Reads
- *	step counter configuration
- *	from the register 0x7A bit 0 to 7
- *	and from the register 0x7B bit 0 to 2 and 4 to 7
- *
- *
- *  @param v_step_config_u16 : The value of step configuration
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_step_config(
-u16 *v_step_config_u16)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data1_u8r = BMI160_INIT_VALUE;
-	u8 v_data2_u8r = BMI160_INIT_VALUE;
-	u16 v_data3_u8r = BMI160_INIT_VALUE;
-	/* Read the 0 to 7 bit*/
-	com_rslt =
-	p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-	BMI160_USER_STEP_CONFIG_ZERO__REG,
-	&v_data1_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	/* Read the 8 to 10 bit*/
-	com_rslt +=
-	p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-	BMI160_USER_STEP_CONFIG_ONE_CNF1__REG,
-	&v_data2_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	v_data2_u8r = BMI160_GET_BITSLICE(v_data2_u8r,
-	BMI160_USER_STEP_CONFIG_ONE_CNF1);
-	v_data3_u8r = ((u16)((((u32)
-	((u8)v_data2_u8r))
-	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS) | (v_data1_u8r)));
-	/* Read the 11 to 14 bit*/
-	com_rslt +=
-	p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-	BMI160_USER_STEP_CONFIG_ONE_CNF2__REG,
-	&v_data1_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	v_data1_u8r = BMI160_GET_BITSLICE(v_data1_u8r,
-	BMI160_USER_STEP_CONFIG_ONE_CNF2);
-	*v_step_config_u16 = ((u16)((((u32)
-	((u8)v_data1_u8r))
-	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS) | (v_data3_u8r)));
-
-	return com_rslt;
-}
- /*!
- *	@brief This API write
- *	step counter configuration
- *	from the register 0x7A bit 0 to 7
- *	and from the register 0x7B bit 0 to 2 and 4 to 7
- *
- *
- *  @param v_step_config_u16   :
- *	the value of  Enable step configuration
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_step_config(
-u16 v_step_config_u16)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data1_u8r = BMI160_INIT_VALUE;
-	u8 v_data2_u8r = BMI160_INIT_VALUE;
-	u16 v_data3_u16 = BMI160_INIT_VALUE;
-
-	/* write the 0 to 7 bit*/
-	v_data1_u8r = (u8)(v_step_config_u16 &
-	BMI160_STEP_CONFIG_0_7);
-	p_bmi160->BMI160_BUS_WRITE_FUNC
-	(p_bmi160->dev_addr,
-	BMI160_USER_STEP_CONFIG_ZERO__REG,
-	&v_data1_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	/* write the 8 to 10 bit*/
-	com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-	(p_bmi160->dev_addr,
-	BMI160_USER_STEP_CONFIG_ONE_CNF1__REG,
-	&v_data2_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	if (com_rslt == SUCCESS) {
-		v_data3_u16 = (u16) (v_step_config_u16 &
-		BMI160_STEP_CONFIG_8_10);
-		v_data1_u8r = (u8)(v_data3_u16
-		>> BMI160_SHIFT_BIT_POSITION_BY_08_BITS);
-		v_data2_u8r = BMI160_SET_BITSLICE(v_data2_u8r,
-		BMI160_USER_STEP_CONFIG_ONE_CNF1, v_data1_u8r);
-		p_bmi160->BMI160_BUS_WRITE_FUNC
-		(p_bmi160->dev_addr,
-		BMI160_USER_STEP_CONFIG_ONE_CNF1__REG,
-		&v_data2_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	}
-	/* write the 11 to 14 bit*/
-	com_rslt += p_bmi160->BMI160_BUS_READ_FUNC
-	(p_bmi160->dev_addr,
-	BMI160_USER_STEP_CONFIG_ONE_CNF2__REG,
-	&v_data2_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	if (com_rslt == SUCCESS) {
-		v_data3_u16 = (u16) (v_step_config_u16 &
-		BMI160_STEP_CONFIG_11_14);
-		v_data1_u8r = (u8)(v_data3_u16
-		>> BMI160_SHIFT_BIT_POSITION_BY_12_BITS);
-		v_data2_u8r = BMI160_SET_BITSLICE(v_data2_u8r,
-		BMI160_USER_STEP_CONFIG_ONE_CNF2, v_data1_u8r);
-		p_bmi160->BMI160_BUS_WRITE_FUNC
-		(p_bmi160->dev_addr,
-		BMI160_USER_STEP_CONFIG_ONE_CNF2__REG,
-		&v_data2_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	}
-
-	return com_rslt;
-}
- /*!
- *	@brief This API read enable step counter
- *	from the register 0x7B bit 3
- *
- *
- *  @param v_step_counter_u8 : The value of step counter enable
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_step_counter_enable(
-u8 *v_step_counter_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the step counter */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_USER_STEP_CONFIG_1_STEP_COUNT_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_step_counter_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_USER_STEP_CONFIG_1_STEP_COUNT_ENABLE);
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API write enable step counter
- *	from the register 0x7B bit 3
- *
- *
- *  @param v_step_counter_u8 : The value of step counter enable
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_step_counter_enable(u8 v_step_counter_u8)
-{
-/* variable used for return the status of communication result*/
-BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-/* check the p_bmi160 structure as NULL*/
-if (p_bmi160 == BMI160_NULL) {
-	return E_BMI160_NULL_PTR;
-} else {
-	if (v_step_counter_u8 <= BMI160_MAX_GYRO_STEP_COUNTER) {
-		/* write the step counter */
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-		(p_bmi160->dev_addr,
-		BMI160_USER_STEP_CONFIG_1_STEP_COUNT_ENABLE__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		if (com_rslt == SUCCESS) {
-			v_data_u8 =
-			BMI160_SET_BITSLICE(v_data_u8,
-			BMI160_USER_STEP_CONFIG_1_STEP_COUNT_ENABLE,
-			v_step_counter_u8);
-			com_rslt +=
-			p_bmi160->BMI160_BUS_WRITE_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_USER_STEP_CONFIG_1_STEP_COUNT_ENABLE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-	} else {
-	com_rslt = E_BMI160_OUT_OF_RANGE;
-	}
-}
-	return com_rslt;
-}
- /*!
- *	@brief This API set Step counter modes
- *
- *
- *  @param  v_step_mode_u8 : The value of step counter mode
- *  value    |   mode
- * ----------|-----------
- *   0       | BMI160_STEP_NORMAL_MODE
- *   1       | BMI160_STEP_SENSITIVE_MODE
- *   2       | BMI160_STEP_ROBUST_MODE
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_step_mode(u8 v_step_mode_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-
-	switch (v_step_mode_u8) {
-	case BMI160_STEP_NORMAL_MODE:
-		com_rslt = bmi160_set_step_config(
-		STEP_CONFIG_NORMAL);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	break;
-	case BMI160_STEP_SENSITIVE_MODE:
-		com_rslt = bmi160_set_step_config(
-		STEP_CONFIG_SENSITIVE);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	break;
-	case BMI160_STEP_ROBUST_MODE:
-		com_rslt = bmi160_set_step_config(
-		STEP_CONFIG_ROBUST);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	break;
-	default:
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-	break;
-	}
-
-	return com_rslt;
-}
-/*!
- *	@brief This API used to trigger the  signification motion
- *	interrupt
- *
- *
- *  @param  v_significant_u8 : The value of interrupt selection
- *  value    |  interrupt
- * ----------|-----------
- *   0       |  BMI160_MAP_INTR1
- *   1       |  BMI160_MAP_INTR2
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_map_significant_motion_intr(
-u8 v_significant_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_sig_motion_u8 = BMI160_INIT_VALUE;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	u8 v_any_motion_intr1_stat_u8 = BMI160_ENABLE_ANY_MOTION_INTR1;
-	u8 v_any_motion_intr2_stat_u8 = BMI160_ENABLE_ANY_MOTION_INTR2;
-	u8 v_any_motion_axis_stat_u8 = BMI160_ENABLE_ANY_MOTION_AXIS;
-	/* enable the significant motion interrupt */
-	com_rslt = bmi160_get_intr_significant_motion_select(&v_sig_motion_u8);
-	if (v_sig_motion_u8 != BMI160_SIG_MOTION_STAT_HIGH)
-		com_rslt += bmi160_set_intr_significant_motion_select(
-		BMI160_SIG_MOTION_INTR_ENABLE);
-	switch (v_significant_u8) {
-	case BMI160_MAP_INTR1:
-		/* interrupt */
-		com_rslt += bmi160_read_reg(
-		BMI160_USER_INTR_MAP_0_INTR1_ANY_MOTION__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		v_data_u8 |= v_any_motion_intr1_stat_u8;
-		/* map the signification interrupt to any-motion interrupt1*/
-		com_rslt += bmi160_write_reg(
-		BMI160_USER_INTR_MAP_0_INTR1_ANY_MOTION__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		/* axis*/
-		com_rslt = bmi160_read_reg(BMI160_USER_INTR_ENABLE_0_ADDR,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		v_data_u8 |= v_any_motion_axis_stat_u8;
-		com_rslt += bmi160_write_reg(
-		BMI160_USER_INTR_ENABLE_0_ADDR,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	break;
-
-	case BMI160_MAP_INTR2:
-		/* map the signification interrupt to any-motion interrupt2*/
-		com_rslt += bmi160_read_reg(
-		BMI160_USER_INTR_MAP_2_INTR2_ANY_MOTION__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		v_data_u8 |= v_any_motion_intr2_stat_u8;
-		com_rslt += bmi160_write_reg(
-		BMI160_USER_INTR_MAP_2_INTR2_ANY_MOTION__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		/* axis*/
-		com_rslt = bmi160_read_reg(BMI160_USER_INTR_ENABLE_0_ADDR,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		v_data_u8 |= v_any_motion_axis_stat_u8;
-		com_rslt += bmi160_write_reg(
-		BMI160_USER_INTR_ENABLE_0_ADDR,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	break;
-
-	default:
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-	break;
-
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API used to trigger the step detector
- *	interrupt
- *
- *
- *  @param  v_step_detector_u8 : The value of interrupt selection
- *  value    |  interrupt
- * ----------|-----------
- *   0       |  BMI160_MAP_INTR1
- *   1       |  BMI160_MAP_INTR2
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_map_step_detector_intr(
-u8 v_step_detector_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_step_det_u8 = BMI160_INIT_VALUE;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	u8 v_low_g_intr_u81_stat_u8 = BMI160_LOW_G_INTR_STAT;
-	u8 v_low_g_intr_u82_stat_u8 = BMI160_LOW_G_INTR_STAT;
-	u8 v_low_g_enable_u8 = BMI160_ENABLE_LOW_G;
-	/* read the v_status_s8 of step detector interrupt*/
-	com_rslt = bmi160_get_step_detector_enable(&v_step_det_u8);
-	if (v_step_det_u8 != BMI160_STEP_DET_STAT_HIGH)
-		com_rslt += bmi160_set_step_detector_enable(
-		BMI160_STEP_DETECT_INTR_ENABLE);
-	switch (v_step_detector_u8) {
-	case BMI160_MAP_INTR1:
-		com_rslt += bmi160_read_reg(
-		BMI160_USER_INTR_MAP_0_INTR1_LOW_G__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		v_data_u8 |= v_low_g_intr_u81_stat_u8;
-		/* map the step detector interrupt
-		to Low-g interrupt 1*/
-		com_rslt += bmi160_write_reg(
-		BMI160_USER_INTR_MAP_0_INTR1_LOW_G__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		/* Enable the Low-g interrupt*/
-		com_rslt = bmi160_read_reg(
-		BMI160_USER_INTR_ENABLE_1_LOW_G_ENABLE__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		v_data_u8 |= v_low_g_enable_u8;
-		com_rslt += bmi160_write_reg(
-		BMI160_USER_INTR_ENABLE_1_LOW_G_ENABLE__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	break;
-	case BMI160_MAP_INTR2:
-		/* map the step detector interrupt
-		to Low-g interrupt 1*/
-		com_rslt += bmi160_read_reg(
-		BMI160_USER_INTR_MAP_2_INTR2_LOW_G__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		v_data_u8 |= v_low_g_intr_u82_stat_u8;
-
-		com_rslt += bmi160_write_reg(
-		BMI160_USER_INTR_MAP_2_INTR2_LOW_G__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		/* Enable the Low-g interrupt*/
-		com_rslt = bmi160_read_reg(
-		BMI160_USER_INTR_ENABLE_1_LOW_G_ENABLE__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		v_data_u8 |= v_low_g_enable_u8;
-		com_rslt += bmi160_write_reg(
-		BMI160_USER_INTR_ENABLE_1_LOW_G_ENABLE__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	break;
-	default:
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-	break;
-	}
-	return com_rslt;
-}
- /*!
- *	@brief This API used to clear the step counter interrupt
- *	interrupt
- *
- *
- *  @param  : None
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_clear_step_counter(void)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* clear the step counter*/
-	com_rslt = bmi160_set_command_register(RESET_STEP_COUNTER);
-	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-
-	return com_rslt;
-
-}
- /*!
- *	@brief This API writes value to the register 0x7E bit 0 to 7
- *
- *
- *  @param  v_command_reg_u8 : The value to write command register
- *  value   |  Description
- * ---------|--------------------------------------------------------
- *	0x00	|	Reserved
- *  0x03	|	Starts fast offset calibration for the accel and gyro
- *	0x10	|	Sets the PMU mode for the Accelerometer to suspend
- *	0x11	|	Sets the PMU mode for the Accelerometer to normal
- *	0x12	|	Sets the PMU mode for the Accelerometer Lowpower
- *  0x14	|	Sets the PMU mode for the Gyroscope to suspend
- *	0x15	|	Sets the PMU mode for the Gyroscope to normal
- *	0x16	|	Reserved
- *	0x17	|	Sets the PMU mode for the Gyroscope to fast start-up
- *  0x18	|	Sets the PMU mode for the Magnetometer to suspend
- *	0x19	|	Sets the PMU mode for the Magnetometer to normal
- *	0x1A	|	Sets the PMU mode for the Magnetometer to Lowpower
- *	0xB0	|	Clears all data in the FIFO
- *  0xB1	|	Resets the interrupt engine
- *	0xB2	|	step_cnt_clr Clears the step counter
- *	0xB6	|	Triggers a reset
- *	0x37	|	See extmode_en_last
- *	0x9A	|	See extmode_en_last
- *	0xC0	|	Enable the extended mode
- *  0xC4	|	Erase NVM cell
- *	0xC8	|	Load NVM cell
- *	0xF0	|	Reset acceleration data path
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_command_register(u8 v_command_reg_u8)
-{
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* write command register */
-			com_rslt = p_bmi160->BMI160_BUS_WRITE_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_CMD_COMMANDS__REG,
-			&v_command_reg_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API read target page from the register 0x7F bit 4 and 5
- *
- *  @param v_target_page_u8: The value of target page
- *  value   |  page
- * ---------|-----------
- *   0      |  User data/configure page
- *   1      |  Chip level trim/test page
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_target_page(u8 *v_target_page_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* read the page*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-			p_bmi160->dev_addr,
-			BMI160_CMD_TARGET_PAGE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			*v_target_page_u8 = BMI160_GET_BITSLICE(v_data_u8,
-			BMI160_CMD_TARGET_PAGE);
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API write target page from the register 0x7F bit 4 and 5
- *
- *  @param v_target_page_u8: The value of target page
- *  value   |  page
- * ---------|-----------
- *   0      |  User data/configure page
- *   1      |  Chip level trim/test page
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_target_page(u8 v_target_page_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_target_page_u8 <= BMI160_MAX_TARGET_PAGE) {
-			/* write the page*/
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_CMD_TARGET_PAGE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 =
-				BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_CMD_TARGET_PAGE,
-				v_target_page_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC
-				(p_bmi160->dev_addr,
-				BMI160_CMD_TARGET_PAGE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
- /*!
- *	@brief This API read page enable from the register 0x7F bit 7
- *
- *
- *
- *  @param v_page_enable_u8: The value of page enable
- *  value   |  page
- * ---------|-----------
- *   0      |  DISABLE
- *   1      |  ENABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_paging_enable(u8 *v_page_enable_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		/* read the page enable */
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-		p_bmi160->dev_addr,
-		BMI160_CMD_PAGING_EN__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		*v_page_enable_u8 = BMI160_GET_BITSLICE(v_data_u8,
-		BMI160_CMD_PAGING_EN);
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This API write page enable from the register 0x7F bit 7
- *
- *
- *
- *  @param v_page_enable_u8: The value of page enable
- *  value   |  page
- * ---------|-----------
- *   0      |  DISABLE
- *   1      |  ENABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_paging_enable(
-u8 v_page_enable_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		if (v_page_enable_u8 <= BMI160_MAX_VALUE_PAGE) {
-			/* write the page enable */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_CMD_PAGING_EN__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 =
-				BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_CMD_PAGING_EN,
-				v_page_enable_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC
-				(p_bmi160->dev_addr,
-				BMI160_CMD_PAGING_EN__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		} else {
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-		}
-	}
-	return com_rslt;
-}
- /*!
- *	@brief This API read
- *	pull up configuration from the register 0X85 bit 4 an 5
- *
- *
- *
- *  @param v_control_pullup_u8: The value of pull up register
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_pullup_configuration(
-u8 *v_control_pullup_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		/* read pull up value */
-		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
-		p_bmi160->dev_addr,
-		BMI160_COM_C_TRIM_FIVE__REG,
-		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		*v_control_pullup_u8 = BMI160_GET_BITSLICE(v_data_u8,
-		BMI160_COM_C_TRIM_FIVE);
-		}
-	return com_rslt;
-
-}
- /*!
- *	@brief This API write
- *	pull up configuration from the register 0X85 bit 4 an 5
- *
- *
- *
- *  @param v_control_pullup_u8: The value of pull up register
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_pullup_configuration(
-u8 v_control_pullup_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-			/* write  pull up value */
-			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
-			(p_bmi160->dev_addr,
-			BMI160_COM_C_TRIM_FIVE__REG,
-			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			if (com_rslt == SUCCESS) {
-				v_data_u8 =
-				BMI160_SET_BITSLICE(v_data_u8,
-				BMI160_COM_C_TRIM_FIVE,
-				v_control_pullup_u8);
-				com_rslt +=
-				p_bmi160->BMI160_BUS_WRITE_FUNC
-				(p_bmi160->dev_addr,
-				BMI160_COM_C_TRIM_FIVE__REG,
-				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-			}
-		}
-	return com_rslt;
-}
-/*!
- *	@brief This function used for reading the compensated data of
- *	mag secondary interface xyz data
- *	@param v_mag_x_s16: The value of mag x data
- *	@param v_mag_y_s16: The value of mag y data
- *	@param v_mag_z_s16: The value of mag z data
- *	@param v_mag_r_s16: The value of mag r data
- *	@param v_mag_second_if_u8: The value of mag selection
- *
- *  value   |   v_mag_second_if_u8
- * ---------|----------------------
- *    0     |    BMM150
- *    1     |    AKM09911
- *    2     |    AKM09912
- *    3     |    YAS532
- *    4     |    YAS537
- *	@param mag_fifo_data: The value of compensated mag xyz data
- *
- *
- *  @return
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_second_if_mag_compensate_xyz(
-struct bmi160_mag_fifo_data_t mag_fifo_data,
-u8 v_mag_second_if_u8)
-{
-s8 com_rslt = BMI160_INIT_VALUE;
-s16 v_mag_x_s16 = BMI160_INIT_VALUE;
-s16 v_mag_y_s16 = BMI160_INIT_VALUE;
-s16 v_mag_z_s16 = BMI160_INIT_VALUE;
-u16 v_mag_r_u16 = BMI160_INIT_VALUE;
-u8 i = BMI160_INIT_VALUE;
-u8 v_ouflow_u8 = BMI160_INIT_VALUE;
-u8 v_busy_u8 = BMI160_INIT_VALUE;
-u8 v_coil_stat_u8 = BMI160_INIT_VALUE;
-u16 v_temperature_u16 = BMI160_INIT_VALUE;
-s32 a_h_s32[BMI160_YAS_H_DATA_SIZE] = {
-BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE};
-s32 a_s_s32[BMI160_YAS_S_DATA_SIZE] = {
-BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE};
-u16 xy1y2[3] = {
-BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE};
-u16 v_xy1y2_u16[3] = {
-BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE};
-u8 v_busy_yas532_u8 = BMI160_INIT_VALUE;
-u16 v_temp_yas532_u16 = BMI160_INIT_VALUE;
-u8 v_overflow_yas532_u8 = BMI160_INIT_VALUE;
-
-switch (v_mag_second_if_u8) {
-case BMI160_SEC_IF_BMM150:
-	/* x data*/
-	v_mag_x_s16 = (s16)((mag_fifo_data.mag_x_msb
-	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-	| (mag_fifo_data.mag_x_lsb));
-	v_mag_x_s16 = (s16)
-	(v_mag_x_s16 >> BMI160_SHIFT_BIT_POSITION_BY_03_BITS);
-	/* y data*/
-	v_mag_y_s16 = (s16)((mag_fifo_data.mag_y_msb
-	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-	| (mag_fifo_data.mag_y_lsb));
-	v_mag_y_s16 = (s16)
-	(v_mag_y_s16 >> BMI160_SHIFT_BIT_POSITION_BY_03_BITS);
-	/* z data*/
-	v_mag_z_s16 = (s16)((mag_fifo_data.mag_z_msb
-	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-	| (mag_fifo_data.mag_z_lsb));
-	v_mag_z_s16 = (s16)
-	(v_mag_z_s16 >> BMI160_SHIFT_BIT_POSITION_BY_01_BIT);
-	/* r data*/
-	v_mag_r_u16 = (u16)((mag_fifo_data.mag_r_y2_msb
-	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-	| (mag_fifo_data.mag_r_y2_lsb));
-	v_mag_r_u16 = (u16)
-	(v_mag_r_u16 >> BMI160_SHIFT_BIT_POSITION_BY_02_BITS);
-	/* Compensated mag x data */
-	processed_data.x =
-	bmi160_bmm150_mag_compensate_X(v_mag_x_s16,
-	v_mag_r_u16);
-	/* Compensated mag y data */
-	processed_data.y =
-	bmi160_bmm150_mag_compensate_Y(v_mag_y_s16,
-	v_mag_r_u16);
-	/* Compensated mag z data */
-	processed_data.z =
-	bmi160_bmm150_mag_compensate_Z(v_mag_z_s16,
-	v_mag_r_u16);
-break;
-case BMI160_SEC_IF_AKM09911:
-	/* x data*/
-	v_mag_x_s16 = (s16)((mag_fifo_data.mag_x_msb
-	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-	| (mag_fifo_data.mag_x_lsb));
-	/* y data*/
-	v_mag_y_s16 = (s16)((mag_fifo_data.mag_y_msb
-	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-	| (mag_fifo_data.mag_y_lsb));
-	/* z data*/
-	v_mag_z_s16 = (s16)((mag_fifo_data.mag_z_msb
-	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-	| (mag_fifo_data.mag_z_lsb));
-	/* Compensated for X data */
-	processed_data.x =
-	bmi160_bst_akm09911_compensate_X(v_mag_x_s16);
-	/* Compensated for Y data */
-	processed_data.y =
-	bmi160_bst_akm09911_compensate_Y(v_mag_y_s16);
-	/* Compensated for Z data */
-	processed_data.z =
-	bmi160_bst_akm09911_compensate_Z(v_mag_z_s16);
-break;
-case BMI160_SEC_IF_AKM09912:
-	/* x data*/
-	v_mag_x_s16 = (s16)((mag_fifo_data.mag_x_msb
-	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-	| (mag_fifo_data.mag_x_lsb));
-	/* y data*/
-	v_mag_y_s16 = (s16)((mag_fifo_data.mag_y_msb
-	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-	| (mag_fifo_data.mag_y_lsb));
-	/* z data*/
-	v_mag_z_s16 = (s16)((mag_fifo_data.mag_z_msb
-	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-	| (mag_fifo_data.mag_z_lsb));
-	/* Compensated for X data */
-	processed_data.x =
-	bmi160_bst_akm09912_compensate_X(v_mag_x_s16);
-	/* Compensated for Y data */
-	processed_data.y =
-	bmi160_bst_akm09912_compensate_Y(v_mag_y_s16);
-	/* Compensated for Z data */
-	processed_data.z =
-	bmi160_bst_akm09912_compensate_Z(v_mag_z_s16);
-break;
-case BMI160_SEC_IF_YAS532:
-	/* read the xyy1 data*/
-	v_busy_yas532_u8 =
-	((mag_fifo_data.mag_x_lsb
-	>> BMI160_SHIFT_BIT_POSITION_BY_07_BITS) & 0x01);
-	v_temp_yas532_u16 =
-	(u16)((((s32)mag_fifo_data.mag_x_lsb
-	<< BMI160_SHIFT_BIT_POSITION_BY_03_BITS)
-	& 0x3F8) | ((mag_fifo_data.mag_x_msb
-	>> BMI160_SHIFT_BIT_POSITION_BY_05_BITS) & 0x07));
-
-	v_xy1y2_u16[0] =
-	(u16)((((s32)mag_fifo_data.mag_y_lsb
-	<< BMI160_SHIFT_BIT_POSITION_BY_06_BITS) & 0x1FC0)
-	| ((mag_fifo_data.mag_y_msb >>
-	BMI160_SHIFT_BIT_POSITION_BY_02_BITS) & 0x3F));
-	v_xy1y2_u16[1] =
-	(u16)((((s32)mag_fifo_data.mag_z_lsb
-	<< BMI160_SHIFT_BIT_POSITION_BY_06_BITS)
-	& 0x1FC0)
-	| ((mag_fifo_data.mag_z_msb
-	>> BMI160_SHIFT_BIT_POSITION_BY_02_BITS) & 0x3F));
-	v_xy1y2_u16[2] =
-	(u16)((((s32)mag_fifo_data.mag_r_y2_lsb
-	<< BMI160_SHIFT_BIT_POSITION_BY_06_BITS)
-	& 0x1FC0)
-	| ((mag_fifo_data.mag_r_y2_msb
-	>> BMI160_SHIFT_BIT_POSITION_BY_02_BITS) & 0x3F));
-	v_overflow_yas532_u8 = 0;
-	for (i = 0; i < 3; i++) {
-		if (v_xy1y2_u16[i] == YAS532_DATA_OVERFLOW)
-			v_overflow_yas532_u8 |= (1 << (i * 2));
-		if (v_xy1y2_u16[i] == YAS532_DATA_UNDERFLOW)
-			v_overflow_yas532_u8 |= (1 << (i * 2 + 1));
-	}
-	/* assign the data*/
-	com_rslt = bmi160_bst_yas532_fifo_xyz_data(
-	v_xy1y2_u16, 1, v_overflow_yas532_u8,
-	v_temp_yas532_u16, v_busy_yas532_u8);
-	processed_data.x =
-	fifo_xyz_data.yas532_vector_xyz[0];
-	processed_data.y =
-	fifo_xyz_data.yas532_vector_xyz[1];
-	processed_data.z =
-	fifo_xyz_data.yas532_vector_xyz[2];
-break;
-case BMI160_SEC_IF_YAS537:
-	/* read the busy flag*/
-	v_busy_u8 = mag_fifo_data.mag_y_lsb
-	>> BMI160_SHIFT_BIT_POSITION_BY_07_BITS;
-	/* read the coil status*/
-	v_coil_stat_u8 =
-	((mag_fifo_data.mag_y_lsb >>
-	BMI160_SHIFT_BIT_POSITION_BY_06_BITS) & 0X01);
-	/* read temperature data*/
-	v_temperature_u16 = (u16)((mag_fifo_data.mag_x_lsb
-	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-	| mag_fifo_data.mag_x_msb);
-	/* read x data*/
-	xy1y2[0] = (u16)(((mag_fifo_data.mag_y_lsb &
-	0x3F)
-	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-	| (mag_fifo_data.mag_y_msb));
-	/* read y1 data*/
-	xy1y2[1] = (u16)((mag_fifo_data.mag_z_lsb
-	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-	| mag_fifo_data.mag_z_msb);
-	/* read y2 data*/
-	xy1y2[2] = (u16)((mag_fifo_data.mag_r_y2_lsb
-	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-	| mag_fifo_data.mag_r_y2_msb);
-	for (i = 0; i < 3; i++)
-		yas537_data.last_raw[i] = xy1y2[i];
-		yas537_data.last_raw[i] = v_temperature_u16;
-		if (yas537_data.calib_yas537.ver == 1) {
-			for (i = 0; i < 3; i++)
-				a_s_s32[i] = xy1y2[i] - 8192;
-		/* read hx*/
-		a_h_s32[0] = ((yas537_data.calib_yas537.k * (
-		(128 * a_s_s32[0]) +
-		(yas537_data.calib_yas537.a2 * a_s_s32[1]) +
-		(yas537_data.calib_yas537.a3 * a_s_s32[2])))
-		/ (8192));
-		/* read hy1*/
-		a_h_s32[1] = ((yas537_data.calib_yas537.k * (
-		(yas537_data.calib_yas537.a4 * a_s_s32[0]) +
-		(yas537_data.calib_yas537.a5 * a_s_s32[1]) +
-		(yas537_data.calib_yas537.a6 * a_s_s32[2])))
-		/ (8192));
-		/* read hy2*/
-		a_h_s32[2] = ((yas537_data.calib_yas537.k * (
-		(yas537_data.calib_yas537.a7 * a_s_s32[0]) +
-		(yas537_data.calib_yas537.a8 * a_s_s32[1]) +
-		(yas537_data.calib_yas537.a9 * a_s_s32[2])))
-		/ (8192));
-
-	for (i = 0; i < 3; i++) {
-		if (a_h_s32[i] < -8192)
-			a_h_s32[i] = -8192;
-
-		if (8192 < a_h_s32[i])
-			a_h_s32[i] = 8192;
-
-		xy1y2[i] = a_h_s32[i] + 8192;
-
-	}
-	}
-	v_ouflow_u8 = 0;
-	for (i = 0; i < 3; i++) {
-		if (YAS537_DATA_OVERFLOW
-		<= xy1y2[i])
-			v_ouflow_u8 |=
-			(1 << (i * 2));
-		if (xy1y2[i] ==
-		YAS537_DATA_UNDERFLOW)
-			v_ouflow_u8
-			|= (1 << (i * 2 + 1));
-	}
-	com_rslt = bmi160_bst_yamaha_yas537_fifo_xyz_data(
-	xy1y2, v_ouflow_u8, v_coil_stat_u8, v_busy_u8);
-	processed_data.x =
-	fifo_vector_xyz.yas537_vector_xyz[0];
-	processed_data.y =
-	fifo_vector_xyz.yas537_vector_xyz[1];
-	processed_data.z =
-	fifo_vector_xyz.yas537_vector_xyz[2];
-break;
-default:
-	com_rslt = E_BMI160_OUT_OF_RANGE;
-break;
-}
-	return com_rslt;
-}
-/*!
- *	@brief This function used for reading the
- *	fifo data of  header mode
- *
- *
- *	@note Configure the below functions for FIFO header mode
- *	@note 1. bmi160_set_fifo_down_gyro()
- *	@note 2. bmi160_set_gyro_fifo_filter_data()
- *	@note 3. bmi160_set_fifo_down_accel()
- *	@note 4. bmi160_set_accel_fifo_filter_dat()
- *	@note 5. bmi160_set_fifo_mag_enable()
- *	@note 6. bmi160_set_fifo_accel_enable()
- *	@note 7. bmi160_set_fifo_gyro_enable()
- *	@note 8. bmi160_set_fifo_header_enable()
- *	@note For interrupt configuration
- *	@note 1. bmi160_set_intr_fifo_full()
- *	@note 2. bmi160_set_intr_fifo_wm()
- *	@note 3. bmi160_set_fifo_tag_intr2_enable()
- *	@note 4. bmi160_set_fifo_tag_intr1_enable()
- *
- *	@note The fifo reads the whole 1024 bytes
- *	and processing the data
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_fifo_header_data(u8 v_mag_if_u8)
-{
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	struct bmi160_fifo_data_header_t header_data;
-	/* read the whole fifo data*/
-	com_rslt =
-	bmi160_read_fifo_header_data_user_defined_length(
-	FIFO_FRAME, v_mag_if_u8, &header_data);
-	return com_rslt;
-}
-/*!
- *	@brief This function used for reading the
- *	fifo data of  header mode for using user defined length
- *
- *
- *	@note Configure the below functions for FIFO header mode
- *	@note 1. bmi160_set_fifo_down_gyro()
- *	@note 2. bmi160_set_gyro_fifo_filter_data()
- *	@note 3. bmi160_set_fifo_down_accel()
- *	@note 4. bmi160_set_accel_fifo_filter_dat()
- *	@note 5. bmi160_set_fifo_mag_enable()
- *	@note 6. bmi160_set_fifo_accel_enable()
- *	@note 7. bmi160_set_fifo_gyro_enable()
- *	@note 8. bmi160_set_fifo_header_enable()
- *	@note For interrupt configuration
- *	@note 1. bmi160_set_intr_fifo_full()
- *	@note 2. bmi160_set_intr_fifo_wm()
- *	@note 3. bmi160_set_fifo_tag_intr2_enable()
- *	@note 4. bmi160_set_fifo_tag_intr1_enable()
- *
- *	@note The fifo reads the whole 1024 bytes
- *	and processing the data
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_fifo_header_data_user_defined_length(
-u16 v_fifo_user_length_u16, u8 v_mag_if_mag_u8,
-struct bmi160_fifo_data_header_t *fifo_header_data)
-{
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_accel_index_u8 = BMI160_INIT_VALUE;
-	u8 v_gyro_index_u8 = BMI160_INIT_VALUE;
-	u8 v_mag_index_u8 = BMI160_INIT_VALUE;
-	s8 v_last_return_stat_s8 = BMI160_INIT_VALUE;
-	u16 v_fifo_index_u16 = BMI160_INIT_VALUE;
-	u8 v_frame_head_u8 = BMI160_INIT_VALUE;
-	u8 v_frame_index_u8 = BMI160_INIT_VALUE;
-
-	u16 v_fifo_length_u16 = BMI160_INIT_VALUE;
-
-	fifo_header_data->accel_frame_count = BMI160_INIT_VALUE;
-	fifo_header_data->mag_frame_count = BMI160_INIT_VALUE;
-	fifo_header_data->gyro_frame_count = BMI160_INIT_VALUE;
-	/* read fifo v_data_u8*/
-	com_rslt = bmi160_fifo_data(&v_fifo_data_u8[BMI160_INIT_VALUE],
-	v_fifo_user_length_u16);
-	v_fifo_length_u16 = v_fifo_user_length_u16;
-	for (v_fifo_index_u16 = BMI160_INIT_VALUE;
-	v_fifo_index_u16 < v_fifo_length_u16;) {
-		fifo_header_data->fifo_header[v_frame_index_u8]
-		= v_fifo_data_u8[v_fifo_index_u16];
-		v_frame_head_u8 =
-		fifo_header_data->fifo_header[v_frame_index_u8]
-		 & BMI160_FIFO_TAG_INTR_MASK;
-		v_frame_index_u8++;
-		switch (v_frame_head_u8) {
-		/* Header frame of accel */
-		case FIFO_HEAD_A:
-		{	/*fifo v_data_u8 frame index + 1*/
-			v_fifo_index_u16 = v_fifo_index_u16 +
-			BMI160_FIFO_INDEX_LENGTH;
-
-			if ((v_fifo_index_u16 + BMI160_FIFO_A_LENGTH)
-			> v_fifo_length_u16) {
-				v_last_return_stat_s8 = FIFO_A_OVER_LEN;
-			break;
-			}
-			/* Accel raw x v_data_u8 */
-			fifo_header_data->accel_fifo[v_accel_index_u8].x =
-			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_X_MSB_DATA])
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			| (v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_X_LSB_DATA]));
-			/* Accel raw y v_data_u8 */
-			fifo_header_data->accel_fifo[v_accel_index_u8].y =
-			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_Y_MSB_DATA])
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			| (v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_Y_LSB_DATA]));
-			/* Accel raw z v_data_u8 */
-			fifo_header_data->accel_fifo[v_accel_index_u8].z =
-			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_Z_MSB_DATA])
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			| (v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_Z_LSB_DATA]));
-			/* check for accel frame count*/
-			fifo_header_data->accel_frame_count =
-			fifo_header_data->accel_frame_count
-			+ BMI160_FRAME_COUNT;
-			/* index adde to 6 accel alone*/
-			v_fifo_index_u16 = v_fifo_index_u16 +
-			BMI160_FIFO_A_LENGTH;
-			v_accel_index_u8++;
-
-		break;
-		}
-		/* Header frame of gyro */
-		case FIFO_HEAD_G:
-		{	/*fifo v_data_u8 frame index + 1*/
-			v_fifo_index_u16 = v_fifo_index_u16
-			+ BMI160_FIFO_INDEX_LENGTH;
-
-			if ((v_fifo_index_u16 + BMI160_FIFO_G_LENGTH) >
-			v_fifo_length_u16) {
-				v_last_return_stat_s8 = FIFO_G_OVER_LEN;
-			break;
-			}
-			/* Gyro raw x v_data_u8 */
-			fifo_header_data->gyro_fifo[v_gyro_index_u8].x  =
-			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_X_MSB_DATA])
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			| (v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_X_LSB_DATA]));
-			/* Gyro raw y v_data_u8 */
-			fifo_header_data->gyro_fifo[v_gyro_index_u8].y =
-			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_Y_MSB_DATA])
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			| (v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_Y_LSB_DATA]));
-			/* Gyro raw z v_data_u8 */
-			fifo_header_data->gyro_fifo[v_gyro_index_u8].z  =
-			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_Z_MSB_DATA])
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			| (v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_Z_LSB_DATA]));
-			/* check for gyro frame count*/
-			fifo_header_data->gyro_frame_count =
-			fifo_header_data->gyro_frame_count + BMI160_FRAME_COUNT;
-			/*fifo G v_data_u8 frame index + 6*/
-			v_fifo_index_u16 = v_fifo_index_u16 +
-			BMI160_FIFO_G_LENGTH;
-			v_gyro_index_u8++;
-
-		break;
-		}
-		/* Header frame of mag */
-		case FIFO_HEAD_M:
-		{	/*fifo v_data_u8 frame index + 1*/
-			v_fifo_index_u16 = v_fifo_index_u16
-			+ BMI160_FIFO_INDEX_LENGTH;
-
-			if ((v_fifo_index_u16 + BMI160_FIFO_M_LENGTH) >
-			(v_fifo_length_u16)) {
-				v_last_return_stat_s8 = FIFO_M_OVER_LEN;
-			break;
-			}
-			/* Mag x data*/
-			mag_data.mag_x_lsb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_X_LSB_DATA]);
-			mag_data.mag_x_msb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_X_MSB_DATA]);
-			/* Mag y data*/
-			mag_data.mag_y_lsb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_Y_LSB_DATA]);
-			mag_data.mag_y_msb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_Y_MSB_DATA]);
-			mag_data.mag_z_lsb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_Z_LSB_DATA]);
-			mag_data.mag_z_msb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_Z_MSB_DATA]);
-			/* Mag r data*/
-			mag_data.mag_r_y2_lsb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_R_LSB_DATA]);
-			mag_data.mag_r_y2_msb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_R_MSB_DATA]);
-
-			com_rslt = bmi160_second_if_mag_compensate_xyz(mag_data,
-			v_mag_if_mag_u8);
-			 /* compensated mag x */
-			fifo_header_data->mag_fifo[v_gyro_index_u8].x
-			= processed_data.x;
-			/* compensated mag y */
-			fifo_header_data->mag_fifo[v_gyro_index_u8].y
-			= processed_data.y;
-			/* compensated mag z */
-			fifo_header_data->mag_fifo[v_gyro_index_u8].z
-			= processed_data.z;
-
-			/* check for mag frame count*/
-			fifo_header_data->mag_frame_count =
-			fifo_header_data->mag_frame_count
-			+ BMI160_FRAME_COUNT;
-
-			v_mag_index_u8++;
-			/*fifo M v_data_u8 frame index + 8*/
-			v_fifo_index_u16 = v_fifo_index_u16 +
-			BMI160_FIFO_M_LENGTH;
-		break;
-		}
-		/* Header frame of gyro and accel */
-		case FIFO_HEAD_G_A:
-			v_fifo_index_u16 = v_fifo_index_u16 +
-			BMI160_FIFO_INDEX_LENGTH;
-			if ((v_fifo_index_u16 + BMI160_FIFO_AG_LENGTH)
-			> v_fifo_length_u16) {
-				v_last_return_stat_s8 = FIFO_G_A_OVER_LEN;
-			break;
-			}
-			/* Raw gyro x */
-			fifo_header_data->gyro_fifo[v_gyro_index_u8].x   =
-			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_GA_FIFO_G_X_MSB])
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			|(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_GA_FIFO_G_X_LSB]));
-			/* Raw gyro y */
-			fifo_header_data->gyro_fifo[v_gyro_index_u8].y  =
-			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_GA_FIFO_G_Y_MSB])
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			|(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_GA_FIFO_G_Y_LSB]));
-			/* Raw gyro z */
-			fifo_header_data->gyro_fifo[v_gyro_index_u8].z  =
-			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_GA_FIFO_G_Z_MSB])
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			|(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_GA_FIFO_G_Z_LSB]));
-			/* check for gyro frame count*/
-			fifo_header_data->gyro_frame_count =
-			fifo_header_data->gyro_frame_count + BMI160_FRAME_COUNT;
-			/* Raw accel x */
-			fifo_header_data->accel_fifo[v_accel_index_u8].x =
-			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_GA_FIFO_A_X_MSB])
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			|(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_GA_FIFO_A_X_LSB]));
-			/* Raw accel y */
-			fifo_header_data->accel_fifo[v_accel_index_u8].y =
-			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_GA_FIFO_A_Y_MSB])
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			|(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_GA_FIFO_A_Y_LSB]));
-			/* Raw accel z */
-			fifo_header_data->accel_fifo[v_accel_index_u8].z =
-			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_GA_FIFO_A_Z_MSB])
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			|(v_fifo_data_u8[v_fifo_index_u16
-			+ BMI160_GA_FIFO_A_Z_LSB]));
-			/* check for accel frame count*/
-			fifo_header_data->accel_frame_count =
-			fifo_header_data->accel_frame_count
-			+ BMI160_FRAME_COUNT;
-			/* Index added to 12 for gyro and accel*/
-			v_fifo_index_u16 = v_fifo_index_u16 +
-			BMI160_FIFO_AG_LENGTH;
-			v_gyro_index_u8++;
-			v_accel_index_u8++;
-		break;
-		/* Header frame of mag, gyro and accel */
-		case FIFO_HEAD_M_G_A:
-			{	/*fifo v_data_u8 frame index + 1*/
-			v_fifo_index_u16 = v_fifo_index_u16
-			+ BMI160_FIFO_INDEX_LENGTH;
-
-			if ((v_fifo_index_u16 + BMI160_FIFO_AMG_LENGTH)
-			> (v_fifo_length_u16)) {
-				v_last_return_stat_s8 = FIFO_M_G_A_OVER_LEN;
-				break;
-			}
-					/* Mag x data*/
-			mag_data.mag_x_lsb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_X_LSB_DATA]);
-			mag_data.mag_x_msb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_X_MSB_DATA]);
-			/* Mag y data*/
-			mag_data.mag_y_lsb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_Y_LSB_DATA]);
-			mag_data.mag_y_msb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_Y_MSB_DATA]);
-			mag_data.mag_z_lsb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_Z_LSB_DATA]);
-			mag_data.mag_z_msb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_Z_MSB_DATA]);
-			/* Mag r data*/
-			mag_data.mag_r_y2_lsb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_R_LSB_DATA]);
-			mag_data.mag_r_y2_msb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_R_MSB_DATA]);
-			/* Processing the compensation data*/
-			com_rslt = bmi160_second_if_mag_compensate_xyz(mag_data,
-			v_mag_if_mag_u8);
-			 /* compensated mag x */
-			fifo_header_data->mag_fifo[v_mag_index_u8].x =
-			processed_data.x;
-			/* compensated mag y */
-			fifo_header_data->mag_fifo[v_mag_index_u8].y =
-			processed_data.y;
-			/* compensated mag z */
-			fifo_header_data->mag_fifo[v_mag_index_u8].z =
-			processed_data.z;
-			/* check for mag frame count*/
-			fifo_header_data->mag_frame_count =
-			fifo_header_data->mag_frame_count + BMI160_FRAME_COUNT;
-			/* Gyro raw x v_data_u8 */
-			fifo_header_data->gyro_fifo[v_gyro_index_u8].x =
-				(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-				BMI160_MGA_FIFO_G_X_MSB])
-				<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-				|(v_fifo_data_u8[v_fifo_index_u16 +
-				BMI160_MGA_FIFO_G_X_LSB]));
-			/* Gyro raw y v_data_u8 */
-			fifo_header_data->gyro_fifo[v_gyro_index_u8].y =
-				(s16)(((v_fifo_data_u8[
-				v_fifo_index_u16 + BMI160_MGA_FIFO_G_Y_MSB])
-				<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-				|(v_fifo_data_u8[v_fifo_index_u16 +
-				BMI160_MGA_FIFO_G_Y_LSB]));
-			/* Gyro raw z v_data_u8 */
-			fifo_header_data->gyro_fifo[v_gyro_index_u8].z =
-				(s16)(((v_fifo_data_u8[
-				v_fifo_index_u16 + BMI160_MGA_FIFO_G_Z_MSB])
-				<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-				|(v_fifo_data_u8[
-				v_fifo_index_u16 + BMI160_MGA_FIFO_G_Z_LSB]));
-			/* check for gyro frame count*/
-			fifo_header_data->gyro_frame_count =
-			fifo_header_data->gyro_frame_count + BMI160_FRAME_COUNT;
-			/* Accel raw x v_data_u8 */
-			fifo_header_data->accel_fifo[v_accel_index_u8].x =
-				(s16)(((v_fifo_data_u8[
-				v_fifo_index_u16 + BMI160_MGA_FIFO_A_X_MSB])
-				<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-				|(v_fifo_data_u8[v_fifo_index_u16 +
-				BMI160_MGA_FIFO_A_X_LSB]));
-			/* Accel raw y v_data_u8 */
-			fifo_header_data->accel_fifo[v_accel_index_u8].y =
-				(s16)(((v_fifo_data_u8[
-				v_fifo_index_u16 + BMI160_MGA_FIFO_A_Y_MSB])
-				<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-				|(v_fifo_data_u8[v_fifo_index_u16 +
-				BMI160_MGA_FIFO_A_Y_LSB]));
-			/* Accel raw z v_data_u8 */
-			fifo_header_data->accel_fifo[v_accel_index_u8].z =
-				(s16)(((v_fifo_data_u8[
-				v_fifo_index_u16 + BMI160_MGA_FIFO_A_Z_MSB])
-				<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-				|(v_fifo_data_u8[v_fifo_index_u16 +
-				BMI160_MGA_FIFO_A_Z_LSB]));
-			/* check for accel frame count*/
-			fifo_header_data->accel_frame_count =
-			fifo_header_data->accel_frame_count
-			+ BMI160_FRAME_COUNT;
-			/* Index added to 20 for mag, gyro and accel*/
-			v_fifo_index_u16 = v_fifo_index_u16 +
-			BMI160_FIFO_AMG_LENGTH;
-			v_accel_index_u8++;
-			v_mag_index_u8++;
-			v_gyro_index_u8++;
-		break;
-			}
-		/* Header frame of mag and accel */
-		case FIFO_HEAD_M_A:
-			{	/*fifo v_data_u8 frame index + 1*/
-			v_fifo_index_u16 = v_fifo_index_u16
-			+ BMI160_GEN_READ_WRITE_DATA_LENGTH;
-
-			if ((v_fifo_index_u16 + BMI160_FIFO_MA_OR_MG_LENGTH)
-			> (v_fifo_length_u16)) {
-				v_last_return_stat_s8 = FIFO_M_A_OVER_LEN;
-				break;
-			}
-			/* Mag x data*/
-			mag_data.mag_x_lsb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_X_LSB_DATA]);
-			mag_data.mag_x_msb = (v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_X_MSB_DATA]);
-			/* Mag y data*/
-			mag_data.mag_y_lsb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_Y_LSB_DATA]);
-			mag_data.mag_y_msb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_Y_MSB_DATA]);
-			mag_data.mag_z_lsb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_Z_LSB_DATA]);
-			mag_data.mag_z_msb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_Z_MSB_DATA]);
-			/* Mag r data*/
-			mag_data.mag_r_y2_lsb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_R_LSB_DATA]);
-			mag_data.mag_r_y2_msb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_R_MSB_DATA]);
-			com_rslt =
-			bmi160_second_if_mag_compensate_xyz(mag_data,
-			 v_mag_if_mag_u8);
-			 /* compensated mag x */
-			fifo_header_data->mag_fifo[v_mag_index_u8].x =
-			processed_data.x;
-			/* compensated mag y */
-			fifo_header_data->mag_fifo[v_mag_index_u8].y =
-			processed_data.y;
-			/* compensated mag z */
-			fifo_header_data->mag_fifo[v_mag_index_u8].z =
-			processed_data.z;
-			/* check for mag frame count*/
-			fifo_header_data->mag_frame_count =
-			fifo_header_data->mag_frame_count
-			+ BMI160_FRAME_COUNT;
-			/* Accel raw x v_data_u8 */
-			fifo_header_data->accel_fifo[v_accel_index_u8].x =
-			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_MA_FIFO_A_X_MSB])
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			|(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_MA_FIFO_A_X_LSB]));
-			/* Accel raw y v_data_u8 */
-			fifo_header_data->accel_fifo[v_accel_index_u8].y =
-			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_MA_FIFO_A_Y_MSB])
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			|(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_MA_FIFO_A_Y_LSB]));
-			/* Accel raw z v_data_u8 */
-			fifo_header_data->accel_fifo[v_accel_index_u8].z =
-			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_MA_FIFO_A_Z_MSB])
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			|(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_MA_FIFO_A_Z_LSB]));
-			/* check for accel frame count*/
-			fifo_header_data->accel_frame_count =
-			fifo_header_data->accel_frame_count
-			+ BMI160_FRAME_COUNT;
-			/*fifo AM v_data_u8 frame index + 14(8+6)*/
-			v_fifo_index_u16 = v_fifo_index_u16 +
-			BMI160_FIFO_MA_OR_MG_LENGTH;
-			v_accel_index_u8++;
-			v_mag_index_u8++;
-		break;
-			}
-			/* Header frame of mag and gyro */
-		case FIFO_HEAD_M_G:
-			{
-			/*fifo v_data_u8 frame index + 1*/
-			v_fifo_index_u16 = v_fifo_index_u16
-			+ BMI160_GEN_READ_WRITE_DATA_LENGTH;
-
-			if ((v_fifo_index_u16 + BMI160_FIFO_MA_OR_MG_LENGTH)
-			> v_fifo_length_u16) {
-				v_last_return_stat_s8 = FIFO_M_G_OVER_LEN;
-				break;
-			}
-			/* Mag x data*/
-			mag_data.mag_x_lsb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_X_LSB_DATA]);
-			mag_data.mag_x_msb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_X_MSB_DATA]);
-			/* Mag y data*/
-			mag_data.mag_y_lsb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_Y_LSB_DATA]);
-			mag_data.mag_y_msb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_Y_MSB_DATA]);
-			mag_data.mag_z_lsb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_Z_LSB_DATA]);
-			mag_data.mag_z_msb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_Z_MSB_DATA]);
-			/* Mag r data*/
-			mag_data.mag_r_y2_lsb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_R_LSB_DATA]);
-			mag_data.mag_r_y2_msb =
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_R_MSB_DATA]);
-			com_rslt =
-			bmi160_second_if_mag_compensate_xyz(mag_data,
-			v_mag_if_mag_u8);
-			 /* compensated mag x */
-			fifo_header_data->mag_fifo[v_mag_index_u8].x =
-			processed_data.x;
-			/* compensated mag y */
-			fifo_header_data->mag_fifo[v_mag_index_u8].y =
-			processed_data.y;
-			/* compensated mag z */
-			fifo_header_data->mag_fifo[v_mag_index_u8].z =
-			processed_data.z;
-			/* check for mag frame count*/
-			fifo_header_data->mag_frame_count =
-			fifo_header_data->mag_frame_count + BMI160_FRAME_COUNT;
-			/* Gyro raw x v_data_u8 */
-			fifo_header_data->gyro_fifo[v_gyro_index_u8].x =
-			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_MG_FIFO_G_X_MSB])
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			|(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_MG_FIFO_G_X_LSB]));
-			/* Gyro raw y v_data_u8 */
-			fifo_header_data->gyro_fifo[v_gyro_index_u8].y =
-			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_MG_FIFO_G_Y_MSB])
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			|(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_MG_FIFO_G_Y_LSB]));
-			/* Gyro raw z v_data_u8 */
-			fifo_header_data->gyro_fifo[v_gyro_index_u8].z =
-			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_MG_FIFO_G_Z_MSB])
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-			|(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_MG_FIFO_G_Z_LSB]));
-			/* check for gyro frame count*/
-			fifo_header_data->gyro_frame_count =
-			fifo_header_data->gyro_frame_count
-			+ BMI160_FRAME_COUNT;
-			/*fifo GM v_data_u8 frame index + 14(8+6)*/
-			v_fifo_index_u16 = v_fifo_index_u16 +
-			BMI160_FIFO_MA_OR_MG_LENGTH;
-			v_mag_index_u8++;
-			v_gyro_index_u8++;
-		break;
-			}
-		/* Header frame of sensor time */
-		case FIFO_HEAD_SENSOR_TIME:
-			{
-			v_fifo_index_u16 = v_fifo_index_u16 +
-			BMI160_GEN_READ_WRITE_DATA_LENGTH;
-
-			if ((v_fifo_index_u16
-			+ BMI160_FIFO_SENSOR_TIME_LENGTH) >
-			(v_fifo_length_u16)) {
-				v_last_return_stat_s8
-				= FIFO_SENSORTIME_RETURN;
-			break;
-			}
-			/* Sensor time */
-			fifo_header_data->fifo_time = (u32)
-			((v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_SENSOR_TIME_MSB]
-			<< BMI160_SHIFT_BIT_POSITION_BY_16_BITS) |
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_SENSOR_TIME_XLSB]
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS) |
-			(v_fifo_data_u8[v_fifo_index_u16 +
-			BMI160_FIFO_SENSOR_TIME_LSB]));
-
-			v_fifo_index_u16 = v_fifo_index_u16 +
-			BMI160_FIFO_SENSOR_TIME_LENGTH;
-		break;
-			}
-		/* Header frame of skip frame */
-		case FIFO_HEAD_SKIP_FRAME:
-			{
-			/*fifo v_data_u8 frame index + 1*/
-				v_fifo_index_u16 = v_fifo_index_u16 +
-				BMI160_FIFO_INDEX_LENGTH;
-				if (v_fifo_index_u16
-				+ BMI160_FIFO_INDEX_LENGTH
-				> v_fifo_length_u16) {
-					v_last_return_stat_s8 =
-					FIFO_SKIP_OVER_LEN;
-				break;
-				}
-				fifo_header_data->skip_frame =
-				v_fifo_data_u8[v_fifo_index_u16];
-				v_fifo_index_u16 = v_fifo_index_u16 +
-				BMI160_FIFO_INDEX_LENGTH;
-		break;
-			}
-		case FIFO_HEAD_INPUT_CONFIG:
-			{
-			/*fifo v_data_u8 frame index + 1*/
-				v_fifo_index_u16 = v_fifo_index_u16 +
-				BMI160_FIFO_INDEX_LENGTH;
-				if (v_fifo_index_u16
-				+ BMI160_FIFO_INDEX_LENGTH
-				> v_fifo_length_u16) {
-					v_last_return_stat_s8 =
-					FIFO_INPUT_CONFIG_OVER_LEN;
-				break;
-				}
-				fifo_header_data->fifo_input_config_info
-				= v_fifo_data_u8[v_fifo_index_u16];
-				v_fifo_index_u16 = v_fifo_index_u16 +
-				BMI160_FIFO_INDEX_LENGTH;
-		break;
-			}
-		/* Header frame of over read fifo v_data_u8 */
-		case FIFO_HEAD_OVER_READ_LSB:
-			{
-		/*fifo v_data_u8 frame index + 1*/
-			v_fifo_index_u16 = v_fifo_index_u16 +
-			BMI160_FIFO_INDEX_LENGTH;
-
-			if ((v_fifo_index_u16 + BMI160_FIFO_INDEX_LENGTH)
-			> (v_fifo_length_u16)) {
-				v_last_return_stat_s8 = FIFO_OVER_READ_RETURN;
-			break;
-			}
-			if (v_fifo_data_u8[v_fifo_index_u16] ==
-			FIFO_HEAD_OVER_READ_MSB) {
-				/*fifo over read frame index + 1*/
-				v_fifo_index_u16 = v_fifo_index_u16 +
-				BMI160_FIFO_INDEX_LENGTH;
-			break;
-			} else {
-				v_last_return_stat_s8 = FIFO_OVER_READ_RETURN;
-			break;
-			}
-			}
-
-		default:
-			v_last_return_stat_s8 = BMI160_FIFO_INDEX_LENGTH;
-		break;
-		}
-	if (v_last_return_stat_s8)
-		break;
-	}
-return com_rslt;
-}
-/*!
- *	@brief This function used for reading the
- *	fifo data of  header less mode
- *
- *
- *
- *	@note Configure the below functions for FIFO header less mode
- *	@note 1. bmi160_set_fifo_down_gyro
- *	@note 2. bmi160_set_gyro_fifo_filter_data
- *	@note 3. bmi160_set_fifo_down_accel
- *	@note 4. bmi160_set_accel_fifo_filter_dat
- *	@note 5. bmi160_set_fifo_mag_enable
- *	@note 6. bmi160_set_fifo_accel_enable
- *	@note 7. bmi160_set_fifo_gyro_enable
- *	@note For interrupt configuration
- *	@note 1. bmi160_set_intr_fifo_full
- *	@note 2. bmi160_set_intr_fifo_wm
- *	@note 3. bmi160_set_fifo_tag_intr2_enable
- *	@note 4. bmi160_set_fifo_tag_intr1_enable
- *
- *	@note The fifo reads the whole 1024 bytes
- *	and processing the data
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_fifo_headerless_mode(
-u8 v_mag_if_u8) {
-
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	struct bmi160_fifo_data_header_less_t headerless_data;
-	/* read the whole FIFO data*/
-	com_rslt =
-	bmi160_read_fifo_headerless_mode_user_defined_length(
-	FIFO_FRAME, &headerless_data, v_mag_if_u8);
-	return com_rslt;
-}
-/*!
- *	@brief This function used for reading the
- *	fifo data of  header less mode for using user defined length
- *
- *
- *	@param v_fifo_user_length_u16: The value of length of fifo read data
- *
- *	@note Configure the below functions for FIFO header less mode
- *	@note 1. bmi160_set_fifo_down_gyro
- *	@note 2. bmi160_set_gyro_fifo_filter_data
- *	@note 3. bmi160_set_fifo_down_accel
- *	@note 4. bmi160_set_accel_fifo_filter_dat
- *	@note 5. bmi160_set_fifo_mag_enable
- *	@note 6. bmi160_set_fifo_accel_enable
- *	@note 7. bmi160_set_fifo_gyro_enable
- *	@note For interrupt configuration
- *	@note 1. bmi160_set_intr_fifo_full
- *	@note 2. bmi160_set_intr_fifo_wm
- *	@note 3. bmi160_set_fifo_tag_intr2_enable
- *	@note 4. bmi160_set_fifo_tag_intr1_enable
- *
- *	@note The fifo reads the whole 1024 bytes
- *	and processing the data
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE
-bmi160_read_fifo_headerless_mode_user_defined_length(
-u16 v_fifo_user_length_u16,
-struct bmi160_fifo_data_header_less_t *fifo_data,
-u8 v_mag_if_mag_u8)
-{
-u8 v_data_u8 = BMI160_INIT_VALUE;
-u32 v_fifo_index_u16 = BMI160_INIT_VALUE;
-u32 v_fifo_length_u16 = BMI160_INIT_VALUE;
-u8 v_accel_index_u8 = BMI160_INIT_VALUE;
-u8 v_gyro_index_u8 = BMI160_INIT_VALUE;
-u8 v_mag_index_u8 = BMI160_INIT_VALUE;
-BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-fifo_data->accel_frame_count = BMI160_INIT_VALUE;
-fifo_data->mag_frame_count = BMI160_INIT_VALUE;
-fifo_data->gyro_frame_count = BMI160_INIT_VALUE;
-/* disable the header data */
-com_rslt = bmi160_set_fifo_header_enable(BMI160_INIT_VALUE);
-/* read mag, accel and gyro enable status*/
-com_rslt += bmi160_read_reg(BMI160_USER_FIFO_CONFIG_1_ADDR,
-&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-v_data_u8 = v_data_u8 & BMI160_FIFO_M_G_A_ENABLE;
-/* read the fifo data of 1024 bytes*/
-com_rslt += bmi160_fifo_data(&v_fifo_data_u8[BMI160_INIT_VALUE],
-v_fifo_user_length_u16);
-v_fifo_length_u16 = v_fifo_user_length_u16;
-/* loop for executing the different conditions */
-for (v_fifo_index_u16 = BMI160_INIT_VALUE;
-v_fifo_index_u16 < v_fifo_length_u16;) {
-	/* condition for mag, gyro and accel enable*/
-	if (v_data_u8 == BMI160_FIFO_M_G_A_ENABLE) {
-		/* Raw mag x*/
-		mag_data.mag_x_lsb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_X_LSB_DATA]);
-		mag_data.mag_x_msb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_X_MSB_DATA]);
-		/* Mag y data*/
-		mag_data.mag_y_lsb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_Y_LSB_DATA]);
-		mag_data.mag_y_msb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_Y_MSB_DATA]);
-		/* Mag z data*/
-		mag_data.mag_z_lsb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_Z_LSB_DATA]);
-		mag_data.mag_z_msb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_Z_MSB_DATA]);
-		/* Mag r data*/
-		mag_data.mag_r_y2_lsb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_R_LSB_DATA]);
-		mag_data.mag_r_y2_msb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_R_MSB_DATA]);
-		com_rslt =
-		bmi160_second_if_mag_compensate_xyz(mag_data,
-		v_mag_if_mag_u8);
-		/* compensated mag x */
-		fifo_data->mag_fifo[v_mag_index_u8].x =
-		processed_data.x;
-		/* compensated mag y */
-		fifo_data->mag_fifo[v_mag_index_u8].y =
-		processed_data.y;
-		/* compensated mag z */
-		fifo_data->mag_fifo[v_mag_index_u8].z =
-		processed_data.z;
-		/* check for mag frame count*/
-		fifo_data->mag_frame_count =
-		fifo_data->mag_frame_count + BMI160_FRAME_COUNT;
-		/* Gyro raw x v_data_u8 */
-		fifo_data->gyro_fifo[v_gyro_index_u8].x  =
-		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_MGA_FIFO_G_X_MSB])
-		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-		|(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_MGA_FIFO_G_X_LSB]));
-		/* Gyro raw y v_data_u8 */
-		fifo_data->gyro_fifo[v_gyro_index_u8].y =
-		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_MGA_FIFO_G_Y_MSB])
-		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-		|(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_MGA_FIFO_G_Y_LSB]));
-		/* Gyro raw z v_data_u8 */
-		fifo_data->gyro_fifo[v_gyro_index_u8].z  =
-		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_MGA_FIFO_G_Z_MSB])
-		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-		|(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_MGA_FIFO_G_Z_LSB]));
-		/* check for gyro frame count*/
-		fifo_data->gyro_frame_count =
-		fifo_data->gyro_frame_count + BMI160_FRAME_COUNT;
-		/* Accel raw x v_data_u8 */
-		fifo_data->accel_fifo[v_accel_index_u8].x =
-		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_MGA_FIFO_A_X_MSB])
-		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-		|(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_MGA_FIFO_A_X_LSB]));
-		/* Accel raw y v_data_u8 */
-		fifo_data->accel_fifo[v_accel_index_u8].y =
-		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_MGA_FIFO_A_Y_MSB])
-		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-		|(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_MGA_FIFO_A_Y_LSB]));
-		/* Accel raw z v_data_u8 */
-		fifo_data->accel_fifo[v_accel_index_u8].z =
-		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_MGA_FIFO_A_Z_MSB])
-		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-		|(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_MGA_FIFO_A_Z_LSB]));
-		/* check for accel frame count*/
-		fifo_data->accel_frame_count =
-		fifo_data->accel_frame_count + BMI160_FRAME_COUNT;
-		v_accel_index_u8++;
-		v_mag_index_u8++;
-		v_gyro_index_u8++;
-	   v_fifo_index_u16 = v_fifo_index_u16 +
-	   BMI160_FIFO_AMG_LENGTH;
-	}
-	/* condition for mag and gyro enable*/
-	else if (v_data_u8 == BMI160_FIFO_M_G_ENABLE) {
-		/* Raw mag x*/
-		mag_data.mag_x_lsb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_X_LSB_DATA]);
-		mag_data.mag_x_msb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_X_MSB_DATA]);
-		/* Mag y data*/
-		mag_data.mag_y_lsb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_Y_LSB_DATA]);
-		mag_data.mag_y_msb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_Y_MSB_DATA]);
-		/* Mag z data*/
-		mag_data.mag_z_lsb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_Z_LSB_DATA]);
-		mag_data.mag_z_msb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_Z_MSB_DATA]);
-		/* Mag r data*/
-		mag_data.mag_r_y2_lsb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_R_LSB_DATA]);
-		mag_data.mag_r_y2_msb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_R_MSB_DATA]);
-		 com_rslt = bmi160_second_if_mag_compensate_xyz(mag_data,
-		 v_mag_if_mag_u8);
-		 /* compensated mag x */
-		fifo_data->mag_fifo[v_mag_index_u8].x =
-		processed_data.x;
-		/* compensated mag y */
-		fifo_data->mag_fifo[v_mag_index_u8].y =
-		processed_data.y;
-		/* compensated mag z */
-		fifo_data->mag_fifo[v_mag_index_u8].z =
-		processed_data.z;
-		/* check for mag frame count*/
-		fifo_data->mag_frame_count =
-		fifo_data->mag_frame_count + BMI160_FRAME_COUNT;
-		/* Gyro raw x v_data_u8 */
-		fifo_data->gyro_fifo[v_gyro_index_u8].x  =
-		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_MG_FIFO_G_X_MSB])
-		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-		|(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_MG_FIFO_G_X_LSB]));
-		/* Gyro raw y v_data_u8 */
-		fifo_data->gyro_fifo[v_gyro_index_u8].y =
-		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_MG_FIFO_G_Y_MSB])
-		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-		|(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_MG_FIFO_G_Y_LSB]));
-		/* Gyro raw z v_data_u8 */
-		fifo_data->gyro_fifo[v_gyro_index_u8].z  =
-		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_MG_FIFO_G_Z_MSB])
-		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-		|(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_MG_FIFO_G_Z_LSB]));
-		/* check for gyro frame count*/
-		fifo_data->gyro_frame_count =
-		fifo_data->gyro_frame_count + BMI160_FRAME_COUNT;
-		v_gyro_index_u8++;
-		v_mag_index_u8++;
-		v_fifo_index_u16 = v_fifo_index_u16 +
-		BMI160_FIFO_MA_OR_MG_LENGTH;
-	}
-	/* condition for mag and accel enable*/
-	else if (v_data_u8 == BMI160_FIFO_M_A_ENABLE) {
-		/* Raw mag x*/
-		mag_data.mag_x_lsb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_X_LSB_DATA]);
-		mag_data.mag_x_msb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_X_MSB_DATA]);
-		/* Mag y data*/
-		mag_data.mag_y_lsb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_Y_LSB_DATA]);
-		mag_data.mag_y_msb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_Y_MSB_DATA]);
-		/* Mag z data*/
-		mag_data.mag_z_lsb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_Z_LSB_DATA]);
-		mag_data.mag_z_msb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_Z_MSB_DATA]);
-			/* Mag r data*/
-		mag_data.mag_r_y2_lsb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_R_LSB_DATA]);
-		mag_data.mag_r_y2_msb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_R_MSB_DATA]);
-		 com_rslt = bmi160_second_if_mag_compensate_xyz(mag_data,
-		 v_mag_if_mag_u8);
-		 /* compensated mag x */
-		fifo_data->mag_fifo[v_mag_index_u8].x =
-		processed_data.x;
-		/* compensated mag y */
-		fifo_data->mag_fifo[v_mag_index_u8].y =
-		processed_data.y;
-		/* compensated mag z */
-		fifo_data->mag_fifo[v_mag_index_u8].z =
-		processed_data.z;
-		/* check for mag frame count*/
-		fifo_data->mag_frame_count =
-		fifo_data->mag_frame_count + BMI160_FRAME_COUNT;
-		/* Accel raw x v_data_u8 */
-		fifo_data->accel_fifo[v_accel_index_u8].x =
-		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_MA_FIFO_A_X_MSB])
-		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-		|(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_MA_FIFO_A_X_LSB]));
-		/* Accel raw y v_data_u8 */
-		fifo_data->accel_fifo[v_accel_index_u8].y =
-		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_MA_FIFO_A_Y_MSB])
-		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-		|(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_MA_FIFO_A_Y_LSB]));
-		/* Accel raw z v_data_u8 */
-		fifo_data->accel_fifo[v_accel_index_u8].z =
-		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_MA_FIFO_A_Z_MSB])
-		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-		|(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_MA_FIFO_A_Z_LSB]));
-		/* check for accel frame count*/
-		fifo_data->accel_frame_count =
-		fifo_data->accel_frame_count + BMI160_FRAME_COUNT;
-		v_accel_index_u8++;
-		v_mag_index_u8++;
-		v_fifo_index_u16 = v_fifo_index_u16 +
-		BMI160_FIFO_MA_OR_MG_LENGTH;
-	}
-	/* condition for gyro and accel enable*/
-	else if (v_data_u8 == BMI160_FIFO_G_A_ENABLE) {
-		/* Gyro raw x v_data_u8 */
-		fifo_data->gyro_fifo[v_gyro_index_u8].x  =
-		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_GA_FIFO_G_X_MSB])
-		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-		|(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_GA_FIFO_G_X_LSB]));
-		/* Gyro raw y v_data_u8 */
-		fifo_data->gyro_fifo[v_gyro_index_u8].y =
-		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_GA_FIFO_G_Y_MSB])
-		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-		|(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_GA_FIFO_G_Y_LSB]));
-		/* Gyro raw z v_data_u8 */
-		fifo_data->gyro_fifo[v_gyro_index_u8].z  =
-		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_GA_FIFO_G_Z_MSB])
-		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-		|(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_GA_FIFO_G_Z_LSB]));
-		/* check for gyro frame count*/
-		fifo_data->gyro_frame_count =
-		fifo_data->gyro_frame_count + BMI160_FRAME_COUNT;
-		/* Accel raw x v_data_u8 */
-		fifo_data->accel_fifo[v_accel_index_u8].x =
-		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_GA_FIFO_A_X_MSB])
-		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-		|(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_GA_FIFO_A_X_LSB]));
-		/* Accel raw y v_data_u8 */
-		fifo_data->accel_fifo[v_accel_index_u8].y =
-		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_GA_FIFO_A_Y_MSB])
-		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-		|(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_GA_FIFO_A_Y_LSB]));
-		/* Accel raw z v_data_u8 */
-		fifo_data->accel_fifo[v_accel_index_u8].z =
-		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_GA_FIFO_A_Z_MSB])
-		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-		|(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_GA_FIFO_A_Z_LSB]));
-		/* check for accel frame count*/
-		fifo_data->accel_frame_count =
-		fifo_data->accel_frame_count + BMI160_FRAME_COUNT;
-		v_accel_index_u8++;
-		v_gyro_index_u8++;
-		v_fifo_index_u16 = v_fifo_index_u16 +
-		BMI160_FIFO_AG_LENGTH;
-	}
-	/* condition  for gyro enable*/
-	else if (v_data_u8 == BMI160_FIFO_GYRO_ENABLE) {
-		/* Gyro raw x v_data_u8 */
-		fifo_data->gyro_fifo[v_gyro_index_u8].x  =
-		(s16)(((v_fifo_data_u8[v_fifo_index_u16
-		+ BMI160_FIFO_X_MSB_DATA])
-		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-		|(v_fifo_data_u8[v_fifo_index_u16
-		+ BMI160_FIFO_X_LSB_DATA]));
-		/* Gyro raw y v_data_u8 */
-		fifo_data->gyro_fifo[v_gyro_index_u8].y =
-		(s16)(((v_fifo_data_u8[v_fifo_index_u16
-		+ BMI160_FIFO_Y_MSB_DATA])
-		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-		|(v_fifo_data_u8[v_fifo_index_u16
-		+ BMI160_FIFO_Y_LSB_DATA]));
-		/* Gyro raw z v_data_u8 */
-		fifo_data->gyro_fifo[v_gyro_index_u8].z  =
-		(s16)(((v_fifo_data_u8[v_fifo_index_u16
-		+ BMI160_FIFO_Z_MSB_DATA])
-		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-		|(v_fifo_data_u8[v_fifo_index_u16
-		+ BMI160_FIFO_Z_LSB_DATA]));
-		/* check for gyro frame count*/
-		fifo_data->gyro_frame_count =
-		fifo_data->gyro_frame_count + BMI160_FRAME_COUNT;
-		v_fifo_index_u16 = v_fifo_index_u16 + BMI160_FIFO_G_LENGTH;
-		v_gyro_index_u8++;
-	}
-	/* condition  for accel enable*/
-	else if (v_data_u8 == BMI160_FIFO_A_ENABLE) {
-		/* Accel raw x v_data_u8 */
-		fifo_data->accel_fifo[v_accel_index_u8].x =
-		(s16)(((v_fifo_data_u8[v_fifo_index_u16
-		+ BMI160_FIFO_X_MSB_DATA])
-		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-		|(v_fifo_data_u8[v_fifo_index_u16 + BMI160_FIFO_X_LSB_DATA]));
-		/* Accel raw y v_data_u8 */
-		fifo_data->accel_fifo[v_accel_index_u8].y =
-		(s16)(((v_fifo_data_u8[v_fifo_index_u16
-		+ BMI160_FIFO_Y_MSB_DATA])
-		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-		|(v_fifo_data_u8[v_fifo_index_u16 + BMI160_FIFO_Y_LSB_DATA]));
-		/* Accel raw z v_data_u8 */
-		fifo_data->accel_fifo[v_accel_index_u8].z =
-		(s16)(((v_fifo_data_u8[v_fifo_index_u16
-		+ BMI160_FIFO_Z_MSB_DATA])
-		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-		|(v_fifo_data_u8[v_fifo_index_u16 + BMI160_FIFO_Z_LSB_DATA]));
-		/* check for accel frame count*/
-		fifo_data->accel_frame_count =
-		fifo_data->accel_frame_count + BMI160_FRAME_COUNT;
-		v_fifo_index_u16 = v_fifo_index_u16 + BMI160_FIFO_A_LENGTH;
-		v_accel_index_u8++;
-	}
-	/* condition  for mag enable*/
-	else if (v_data_u8 == BMI160_FIFO_M_ENABLE) {
-		/* Raw mag x*/
-		mag_data.mag_x_lsb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_X_LSB_DATA]);
-		mag_data.mag_x_msb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_X_MSB_DATA]);
-		/* Mag y data*/
-		mag_data.mag_y_lsb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_Y_LSB_DATA]);
-		mag_data.mag_y_msb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_Y_MSB_DATA]);
-		/* Mag z data*/
-		mag_data.mag_z_lsb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_Z_LSB_DATA]);
-		mag_data.mag_z_msb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_Z_MSB_DATA]);
-		/* Mag r data*/
-		mag_data.mag_r_y2_lsb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_R_LSB_DATA]);
-		mag_data.mag_r_y2_msb =
-		(v_fifo_data_u8[v_fifo_index_u16 +
-		BMI160_FIFO_R_MSB_DATA]);
-		com_rslt = bmi160_second_if_mag_compensate_xyz(mag_data,
-		v_mag_if_mag_u8);
-		 /* compensated mag x */
-		fifo_data->mag_fifo[v_mag_index_u8].x =
-		processed_data.x;
-		/* compensated mag y */
-		fifo_data->mag_fifo[v_mag_index_u8].y =
-		processed_data.y;
-		/* compensated mag z */
-		fifo_data->mag_fifo[v_mag_index_u8].z =
-		processed_data.z;
-		/* check for mag frame count*/
-		fifo_data->mag_frame_count =
-		fifo_data->mag_frame_count + BMI160_FRAME_COUNT;
-		v_fifo_index_u16 = v_fifo_index_u16
-		+ BMI160_FIFO_M_LENGTH;
-		v_mag_index_u8++;
-	}
-	/* condition  for fifo over read enable*/
-	if (v_fifo_data_u8[v_fifo_index_u16] == FIFO_CONFIG_CHECK1 &&
-	v_fifo_data_u8[v_fifo_index_u16 + BMI160_FIFO_INDEX_LENGTH] ==
-	FIFO_CONFIG_CHECK2) {
-		break;
-		}
-	}
-	return com_rslt;
-}
- /*!
- *	@brief This function used for read the compensated value of mag
- *	Before start reading the mag compensated data's
- *	make sure the following two points are addressed
- *	@note
- *	1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note
- *	2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_bmm150_mag_compensate_xyz(
-struct bmi160_mag_xyz_s32_t *mag_comp_xyz)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	struct bmi160_mag_xyzr_t mag_xyzr;
-
-	com_rslt = bmi160_read_mag_xyzr(&mag_xyzr);
-	if (com_rslt)
-		return com_rslt;
-	/* Compensation for X axis */
-	mag_comp_xyz->x = bmi160_bmm150_mag_compensate_X(
-	mag_xyzr.x, mag_xyzr.r);
-
-	/* Compensation for Y axis */
-	mag_comp_xyz->y = bmi160_bmm150_mag_compensate_Y(
-	mag_xyzr.y, mag_xyzr.r);
-
-	/* Compensation for Z axis */
-	mag_comp_xyz->z = bmi160_bmm150_mag_compensate_Z(
-	mag_xyzr.z, mag_xyzr.r);
-
-	return com_rslt;
-}
-/*!
- *	@brief This API used to get the compensated BMM150-X data
- *	the out put of X as s32
- *	Before start reading the mag compensated X data
- *	make sure the following two points are addressed
- *	@note
- *	1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note
- *	2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
- *
- *
- *
- *  @param  v_mag_data_x_s16 : The value of mag raw X data
- *  @param  v_data_r_u16 : The value of mag R data
- *
- *	@return results of compensated X data value output as s32
- *
- */
-s32 bmi160_bmm150_mag_compensate_X(s16 v_mag_data_x_s16, u16 v_data_r_u16)
-{
-s32 inter_retval = BMI160_INIT_VALUE;
-/* no overflow */
-if (v_mag_data_x_s16 != BMI160_MAG_FLIP_OVERFLOW_ADCVAL) {
-	if ((v_data_r_u16 != 0)
-	|| (mag_trim.dig_xyz1 != 0)) {
-		inter_retval = ((s32)(((u16)
-		((((s32)mag_trim.dig_xyz1)
-		<< BMI160_SHIFT_BIT_POSITION_BY_14_BITS)/
-		 (v_data_r_u16 != 0 ?
-		 v_data_r_u16 : mag_trim.dig_xyz1))) -
-		((u16)0x4000)));
-	} else {
-		inter_retval = BMI160_MAG_OVERFLOW_OUTPUT;
-		return inter_retval;
-	}
-	inter_retval = ((s32)((((s32)v_mag_data_x_s16) *
-			((((((((s32)mag_trim.dig_xy2) *
-			((((s32)inter_retval) *
-			((s32)inter_retval))
-			>> BMI160_SHIFT_BIT_POSITION_BY_07_BITS)) +
-			 (((s32)inter_retval) *
-			  ((s32)(((s16)mag_trim.dig_xy1)
-			  << BMI160_SHIFT_BIT_POSITION_BY_07_BITS))))
-			  >> BMI160_SHIFT_BIT_POSITION_BY_09_BITS) +
-		   ((s32)0x100000)) *
-		  ((s32)(((s16)mag_trim.dig_x2) +
-		  ((s16)0xA0))))
-		  >> BMI160_SHIFT_BIT_POSITION_BY_12_BITS))
-		  >> BMI160_SHIFT_BIT_POSITION_BY_13_BITS)) +
-		(((s16)mag_trim.dig_x1)
-		<< BMI160_SHIFT_BIT_POSITION_BY_03_BITS);
-	/* check the overflow output */
-	if (inter_retval == (s32)BMI160_MAG_OVERFLOW_OUTPUT)
-		inter_retval = BMI160_MAG_OVERFLOW_OUTPUT_S32;
-} else {
-	/* overflow */
-	inter_retval = BMI160_MAG_OVERFLOW_OUTPUT;
-}
-return inter_retval;
-}
-/*!
- *	@brief This API used to get the compensated BMM150-Y data
- *	the out put of Y as s32
- *	Before start reading the mag compensated Y data
- *	make sure the following two points are addressed
- *	@note
- *	1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note
- *	2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
- *
- *
- *
- *  @param  v_mag_data_y_s16 : The value of mag raw Y data
- *  @param  v_data_r_u16 : The value of mag R data
- *
- *	@return results of compensated Y data value output as s32
- */
-s32 bmi160_bmm150_mag_compensate_Y(s16 v_mag_data_y_s16, u16 v_data_r_u16)
-{
-s32 inter_retval = BMI160_INIT_VALUE;
-/* no overflow */
-if (v_mag_data_y_s16 != BMI160_MAG_FLIP_OVERFLOW_ADCVAL) {
-	if ((v_data_r_u16 != 0)
-	|| (mag_trim.dig_xyz1 != 0)) {
-		inter_retval = ((s32)(((u16)(((
-		(s32)mag_trim.dig_xyz1)
-		<< BMI160_SHIFT_BIT_POSITION_BY_14_BITS) /
-		(v_data_r_u16 != 0 ?
-		 v_data_r_u16 : mag_trim.dig_xyz1))) -
-		((u16)0x4000)));
-		} else {
-			inter_retval = BMI160_MAG_OVERFLOW_OUTPUT;
-			return inter_retval;
-		}
-	inter_retval = ((s32)((((s32)v_mag_data_y_s16) * ((((((((s32)
-		mag_trim.dig_xy2) * ((((s32) inter_retval) *
-		((s32)inter_retval)) >> BMI160_SHIFT_BIT_POSITION_BY_07_BITS))
-		+ (((s32)inter_retval) *
-		((s32)(((s16)mag_trim.dig_xy1)
-		<< BMI160_SHIFT_BIT_POSITION_BY_07_BITS))))
-		>> BMI160_SHIFT_BIT_POSITION_BY_09_BITS) +
-		((s32)0x100000))
-		* ((s32)(((s16)mag_trim.dig_y2)
-		+ ((s16)0xA0))))
-		>> BMI160_SHIFT_BIT_POSITION_BY_12_BITS))
-		>> BMI160_SHIFT_BIT_POSITION_BY_13_BITS)) +
-		(((s16)mag_trim.dig_y1)
-		<< BMI160_SHIFT_BIT_POSITION_BY_03_BITS);
-	/* check the overflow output */
-	if (inter_retval == (s32)BMI160_MAG_OVERFLOW_OUTPUT)
-		inter_retval = BMI160_MAG_OVERFLOW_OUTPUT_S32;
-} else {
-	/* overflow */
-	inter_retval = BMI160_MAG_OVERFLOW_OUTPUT;
-}
-return inter_retval;
-}
-/*!
- *	@brief This API used to get the compensated BMM150-Z data
- *	the out put of Z as s32
- *	Before start reading the mag compensated Z data
- *	make sure the following two points are addressed
- *	@note
- *	1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note
- *	2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
- *
- *
- *
- *  @param  v_mag_data_z_s16 : The value of mag raw Z data
- *  @param  v_data_r_u16 : The value of mag R data
- *
- *	@return results of compensated Z data value output as s32
- */
-s32 bmi160_bmm150_mag_compensate_Z(s16 v_mag_data_z_s16, u16 v_data_r_u16)
-{
-	s32 retval = BMI160_INIT_VALUE;
-
-	if (v_mag_data_z_s16 != BMI160_MAG_HALL_OVERFLOW_ADCVAL) {
-		if ((v_data_r_u16 != 0)
-		   && (mag_trim.dig_z2 != 0)
-		   && (mag_trim.dig_z1 != 0)) {
-			retval = (((((s32)(v_mag_data_z_s16 - mag_trim.dig_z4))
-			<< BMI160_SHIFT_BIT_POSITION_BY_15_BITS) -
-			((((s32)mag_trim.dig_z3) *
-			((s32)(((s16)v_data_r_u16) -
-			((s16)mag_trim.dig_xyz1))))
-			>> BMI160_SHIFT_BIT_POSITION_BY_02_BITS))/
-			(mag_trim.dig_z2 +
-			((s16)(((((s32)mag_trim.dig_z1) *
-			((((s16)v_data_r_u16)
-			<< BMI160_SHIFT_BIT_POSITION_BY_01_BIT))) +
-			(1 << BMI160_SHIFT_BIT_POSITION_BY_15_BITS))
-			>> BMI160_SHIFT_BIT_POSITION_BY_16_BITS))));
-		}
-	} else {
-		retval = BMI160_MAG_OVERFLOW_OUTPUT;
-	}
-		return retval;
-}
- /*!
- *	@brief This function used for initialize the bmm150 sensor
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_bmm150_mag_interface_init(u8 *v_chip_id_u8)
-{
-	/* This variable used for provide the communication
-	results*/
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = BMI160_INIT_VALUE;
-	u8 v_pull_value_u8 = BMI160_INIT_VALUE;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	/* accel operation mode to normal*/
-	com_rslt = bmi160_set_command_register(ACCEL_MODE_NORMAL);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* write the mag power mode as NORMAL*/
-	com_rslt += bmi160_set_mag_interface_normal();
-	/* register 0x7E write the 0x37, 0x9A and 0x30*/
-	com_rslt += bmi160_set_command_register(BMI160_COMMAND_REG_ONE);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	com_rslt += bmi160_set_command_register(BMI160_COMMAND_REG_TWO);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	com_rslt += bmi160_set_command_register(BMI160_COMMAND_REG_THREE);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/*switch the page1*/
-	com_rslt += bmi160_set_target_page(BMI160_WRITE_TARGET_PAGE1);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	bmi160_get_target_page(&v_data_u8);
-	com_rslt += bmi160_set_paging_enable(BMI160_WRITE_ENABLE_PAGE1);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	bmi160_get_paging_enable(&v_data_u8);
-	/* enable the pullup configuration from
-	the register 0x05 bit 4 and 5 as 10*/
-	bmi160_get_pullup_configuration(&v_pull_value_u8);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	v_pull_value_u8 = v_pull_value_u8 | BMI160_PULL_UP_DATA;
-	com_rslt += bmi160_set_pullup_configuration(v_pull_value_u8);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/*switch the page0*/
-	com_rslt += bmi160_set_target_page(BMI160_WRITE_TARGET_PAGE0);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	bmi160_get_target_page(&v_data_u8);
-	/* Write the BMM150 i2c address*/
-	com_rslt += bmi160_set_i2c_device_addr(BMI160_AUX_BMM150_I2C_ADDRESS);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* enable the mag interface to manual mode*/
-	com_rslt += bmi160_set_mag_manual_enable(BMI160_MANUAL_ENABLE);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	bmi160_get_mag_manual_enable(&v_data_u8);
-	/*Enable the MAG interface */
-	com_rslt += bmi160_set_if_mode(BMI160_ENABLE_MAG_IF_MODE);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	bmi160_get_if_mode(&v_data_u8);
-	/* Mag normal mode*/
-	com_rslt += bmi160_bmm150_mag_wakeup();
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* Read the BMM150 device id is 0x32*/
-	com_rslt += bmi160_set_mag_read_addr(BMI160_BMM150_CHIP_ID);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	*v_chip_id_u8 = v_data_u8;
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* write the power mode register*/
-	com_rslt += bmi160_set_mag_write_data(BMI160_BMM_POWER_MODE_REG);
-	/*write 0x4C register to write set power mode to normal*/
-	com_rslt += bmi160_set_mag_write_addr(
-	BMI160_BMM150_POWE_MODE_REG);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* read the mag trim values*/
-	com_rslt += bmi160_read_bmm150_mag_trim();
-	/* To avoid the auto mode enable when manual mode operation running*/
-	V_bmm150_maual_auto_condition_u8 = BMI160_MANUAL_ENABLE;
-	/* write the XY and Z repetitions*/
-	com_rslt += bmi160_set_bmm150_mag_presetmode(
-	BMI160_MAG_PRESETMODE_REGULAR);
-	/* To avoid the auto mode enable when manual mode operation running*/
-	V_bmm150_maual_auto_condition_u8 = BMI160_MANUAL_DISABLE;
-	/* Set the power mode of mag as force mode*/
-	/* The data have to write for the register
-	It write the value in the register 0x4F */
-	com_rslt += bmi160_set_mag_write_data(BMI160_BMM150_FORCE_MODE);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* write into power mode register*/
-	com_rslt += bmi160_set_mag_write_addr(
-	BMI160_BMM150_POWE_MODE_REG);
-	/* write the mag v_data_bw_u8 as 25Hz*/
-	com_rslt += bmi160_set_mag_output_data_rate(
-	BMI160_MAG_OUTPUT_DATA_RATE_25HZ);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-
-	/* When mag interface is auto mode - The mag read address
-	starts the register 0x42*/
-	com_rslt += bmi160_set_mag_read_addr(
-	BMI160_BMM150_DATA_REG);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* enable mag interface to auto mode*/
-	com_rslt += bmi160_set_mag_manual_enable(BMI160_MANUAL_DISABLE);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	bmi160_get_mag_manual_enable(&v_data_u8);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-
-	return com_rslt;
-}
- /*!
- *	@brief This function used for set the mag power control
- *	bit enable
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_bmm150_mag_wakeup(void)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = BMI160_INIT_VALUE;
-	u8 v_try_times_u8 = BMI160_BMM150_MAX_RETRY_WAKEUP;
-	u8 v_power_control_bit_u8 = BMI160_INIT_VALUE;
-	u8 i = BMI160_INIT_VALUE;
-
-	for (i = BMI160_INIT_VALUE; i < v_try_times_u8; i++) {
-		com_rslt = bmi160_set_mag_write_data(BMI160_BMM150_POWER_ON);
-		p_bmi160->delay_msec(BMI160_BMM150_WAKEUP_DELAY1);
-		/*write 0x4B register to enable power control bit*/
-		com_rslt += bmi160_set_mag_write_addr(
-		BMI160_BMM150_POWE_CONTROL_REG);
-		p_bmi160->delay_msec(BMI160_BMM150_WAKEUP_DELAY2);
-		com_rslt += bmi160_set_mag_read_addr(
-		BMI160_BMM150_POWE_CONTROL_REG);
-		/* 0x04 is secondary read mag x lsb register */
-		p_bmi160->delay_msec(BMI160_BMM150_WAKEUP_DELAY3);
-		com_rslt += bmi160_read_reg(BMI160_USER_DATA_0_ADDR,
-		&v_power_control_bit_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-		v_power_control_bit_u8 = BMI160_BMM150_SET_POWER_CONTROL
-		& v_power_control_bit_u8;
-		if (v_power_control_bit_u8 == BMI160_BMM150_POWER_ON)
-			break;
-	}
-	com_rslt = (i >= v_try_times_u8) ?
-	BMI160_BMM150_POWER_ON_FAIL : BMI160_BMM150_POWER_ON_SUCCESS;
-	return com_rslt;
-}
- /*!
- *	@brief This function used for set the magnetometer
- *	power mode.
- *	@note
- *	Before set the mag power mode
- *	make sure the following two point is addressed
- *		Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *
- *	@param v_mag_sec_if_pow_mode_u8 : The value of mag power mode
- *  value    |  mode
- * ----------|------------
- *   0       | BMI160_MAG_FORCE_MODE
- *   1       | BMI160_MAG_SUSPEND_MODE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_bmm150_mag_and_secondary_if_power_mode(
-u8 v_mag_sec_if_pow_mode_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = BMI160_INIT_VALUE;
-	/* set the accel power mode to NORMAL*/
-	com_rslt = bmi160_set_command_register(ACCEL_MODE_NORMAL);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* set mag interface manual mode*/
-	if (p_bmi160->mag_manual_enable != BMI160_MANUAL_ENABLE)	{
-		com_rslt += bmi160_set_mag_manual_enable(
-		BMI160_MANUAL_ENABLE);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	}
-	switch (v_mag_sec_if_pow_mode_u8) {
-	case BMI160_MAG_FORCE_MODE:
-		/* set the secondary mag power mode as NORMAL*/
-		com_rslt += bmi160_set_mag_interface_normal();
-		/* set the mag power mode as FORCE mode*/
-		com_rslt += bmi160_bmm150_mag_set_power_mode(FORCE_MODE);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	break;
-	case BMI160_MAG_SUSPEND_MODE:
-		/* set the mag power mode as SUSPEND mode*/
-		com_rslt += bmi160_bmm150_mag_set_power_mode(SUSPEND_MODE);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		/* set the secondary mag power mode as SUSPEND*/
-		com_rslt += bmi160_set_command_register(MAG_MODE_SUSPEND);
-		p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-	break;
-	default:
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-	break;
-	}
-	if (p_bmi160->mag_manual_enable == BMI160_MANUAL_ENABLE) {
-		/* set mag interface auto mode*/
-		com_rslt += bmi160_set_mag_manual_enable(
-		BMI160_MANUAL_DISABLE);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This function used for set the magnetometer
- *	power mode.
- *	@note
- *	Before set the mag power mode
- *	make sure the following two points are addressed
- *	@note
- *	1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note
- *	2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
- *
- *	@param v_mag_pow_mode_u8 : The value of mag power mode
- *  value    |  mode
- * ----------|------------
- *   0       | FORCE_MODE
- *   1       | SUSPEND_MODE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_bmm150_mag_set_power_mode(
-u8 v_mag_pow_mode_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* set mag interface manual mode*/
-	if (p_bmi160->mag_manual_enable != BMI160_MANUAL_ENABLE) {
-		com_rslt = bmi160_set_mag_manual_enable(
-		BMI160_MANUAL_ENABLE);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		if (com_rslt != SUCCESS)
-			return com_rslt;
-
-	}
-	switch (v_mag_pow_mode_u8) {
-	case FORCE_MODE:
-		/* Set the power control bit enabled */
-		com_rslt = bmi160_bmm150_mag_wakeup();
-		/* write the mag power mode as FORCE mode*/
-		com_rslt += bmi160_set_mag_write_data(
-		BMI160_BMM150_FORCE_MODE);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		com_rslt += bmi160_set_mag_write_addr(
-		BMI160_BMM150_POWE_MODE_REG);
-		p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-		/* To avoid the auto mode enable when manual
-		mode operation running*/
-		V_bmm150_maual_auto_condition_u8 = BMI160_MANUAL_ENABLE;
-		/* set the preset mode */
-		com_rslt += bmi160_set_bmm150_mag_presetmode(
-		BMI160_MAG_PRESETMODE_REGULAR);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		/* To avoid the auto mode enable when manual
-		mode operation running*/
-		V_bmm150_maual_auto_condition_u8 = BMI160_MANUAL_DISABLE;
-		/* set the mag read address to data registers*/
-		com_rslt += bmi160_set_mag_read_addr(
-		BMI160_BMM150_DATA_REG);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	break;
-	case SUSPEND_MODE:
-		/* Set the power mode of mag as suspend mode*/
-		com_rslt = bmi160_set_mag_write_data(
-		BMI160_BMM150_POWER_OFF);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		com_rslt += bmi160_set_mag_write_addr(
-		BMI160_BMM150_POWE_CONTROL_REG);
-		p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-	break;
-	default:
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-	break;
-	}
-	/* set mag interface auto mode*/
-	if (p_bmi160->mag_manual_enable == BMI160_MANUAL_ENABLE) {
-		com_rslt += bmi160_set_mag_manual_enable(
-		BMI160_MANUAL_DISABLE);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This API used to set the pre-set modes of bmm150
- *	The pre-set mode setting is depend on data rate and xy and z repetitions
- *
- *	@note
- *	Before set the mag preset mode
- *	make sure the following two points are addressed
- *	@note
- *	1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note
- *	2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
- *
- *
- *  @param  v_mode_u8: The value of pre-set mode selection value
- *  value    |  pre_set mode
- * ----------|------------
- *   1       | BMI160_MAG_PRESETMODE_LOWPOWER
- *   2       | BMI160_MAG_PRESETMODE_REGULAR
- *   3       | BMI160_MAG_PRESETMODE_HIGHACCURACY
- *   4       | BMI160_MAG_PRESETMODE_ENHANCED
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_bmm150_mag_presetmode(u8 v_mode_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* set mag interface manual mode*/
-	if (p_bmi160->mag_manual_enable != BMI160_MANUAL_ENABLE)
-			com_rslt = bmi160_set_mag_manual_enable(
-			BMI160_MANUAL_ENABLE);
-	switch (v_mode_u8) {
-	case BMI160_MAG_PRESETMODE_LOWPOWER:
-		/* write the XY and Z repetitions*/
-		/* The v_data_u8 have to write for the register
-		It write the value in the register 0x4F*/
-		com_rslt = bmi160_set_mag_write_data(
-		BMI160_MAG_LOWPOWER_REPXY);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		com_rslt += bmi160_set_mag_write_addr(
-		BMI160_BMM150_XY_REP);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		/* write the Z repetitions*/
-		/* The v_data_u8 have to write for the register
-		It write the value in the register 0x4F*/
-		com_rslt += bmi160_set_mag_write_data(
-		BMI160_MAG_LOWPOWER_REPZ);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		com_rslt += bmi160_set_mag_write_addr(
-		BMI160_BMM150_Z_REP);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		/* set the mag v_data_u8 rate as 10 to the register 0x4C*/
-		com_rslt += bmi160_set_mag_write_data(
-		BMI160_MAG_LOWPOWER_DR);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		com_rslt += bmi160_set_mag_write_addr(
-		BMI160_BMM150_POWE_MODE_REG);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	break;
-	case BMI160_MAG_PRESETMODE_REGULAR:
-		/* write the XY and Z repetitions*/
-		/* The v_data_u8 have to write for the register
-		It write the value in the register 0x4F*/
-		com_rslt = bmi160_set_mag_write_data(
-		BMI160_MAG_REGULAR_REPXY);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		com_rslt += bmi160_set_mag_write_addr(
-		BMI160_BMM150_XY_REP);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		/* write the Z repetitions*/
-		/* The v_data_u8 have to write for the register
-		It write the value in the register 0x4F*/
-		com_rslt += bmi160_set_mag_write_data(
-		BMI160_MAG_REGULAR_REPZ);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		com_rslt += bmi160_set_mag_write_addr(
-		BMI160_BMM150_Z_REP);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		/* set the mag v_data_u8 rate as 10 to the register 0x4C*/
-		com_rslt += bmi160_set_mag_write_data(
-		BMI160_MAG_REGULAR_DR);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		com_rslt += bmi160_set_mag_write_addr(
-		BMI160_BMM150_POWE_MODE_REG);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	break;
-	case BMI160_MAG_PRESETMODE_HIGHACCURACY:
-		/* write the XY and Z repetitions*/
-		/* The v_data_u8 have to write for the register
-		It write the value in the register 0x4F*/
-		com_rslt = bmi160_set_mag_write_data(
-		BMI160_MAG_HIGHACCURACY_REPXY);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		com_rslt += bmi160_set_mag_write_addr(
-		BMI160_BMM150_XY_REP);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		/* write the Z repetitions*/
-		/* The v_data_u8 have to write for the register
-		It write the value in the register 0x4F*/
-		com_rslt += bmi160_set_mag_write_data(
-		BMI160_MAG_HIGHACCURACY_REPZ);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		com_rslt += bmi160_set_mag_write_addr(
-		BMI160_BMM150_Z_REP);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		/* set the mag v_data_u8 rate as 20 to the register 0x4C*/
-		com_rslt += bmi160_set_mag_write_data(
-		BMI160_MAG_HIGHACCURACY_DR);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		com_rslt += bmi160_set_mag_write_addr(
-		BMI160_BMM150_POWE_MODE_REG);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	break;
-	case BMI160_MAG_PRESETMODE_ENHANCED:
-		/* write the XY and Z repetitions*/
-		/* The v_data_u8 have to write for the register
-		It write the value in the register 0x4F*/
-		com_rslt = bmi160_set_mag_write_data(
-		BMI160_MAG_ENHANCED_REPXY);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		com_rslt += bmi160_set_mag_write_addr(
-		BMI160_BMM150_XY_REP);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		/* write the Z repetitions*/
-		/* The v_data_u8 have to write for the register
-		It write the value in the register 0x4F*/
-		com_rslt += bmi160_set_mag_write_data(
-		BMI160_MAG_ENHANCED_REPZ);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		com_rslt += bmi160_set_mag_write_addr(
-		BMI160_BMM150_Z_REP);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		/* set the mag v_data_u8 rate as 10 to the register 0x4C*/
-		com_rslt += bmi160_set_mag_write_data(
-		BMI160_MAG_ENHANCED_DR);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		com_rslt += bmi160_set_mag_write_addr(
-		BMI160_BMM150_POWE_MODE_REG);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	break;
-	default:
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-	break;
-	}
-	if (V_bmm150_maual_auto_condition_u8 == BMI160_MANUAL_DISABLE) {
-			com_rslt += bmi160_set_mag_write_data(
-			BMI160_BMM150_FORCE_MODE);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		com_rslt += bmi160_set_mag_write_addr(
-		BMI160_BMM150_POWE_MODE_REG);
-		p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-		com_rslt += bmi160_set_mag_read_addr(BMI160_BMM150_DATA_REG);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		/* set mag interface auto mode*/
-		if (p_bmi160->mag_manual_enable == BMI160_MANUAL_ENABLE)
-			com_rslt = bmi160_set_mag_manual_enable(
-			BMI160_MANUAL_DISABLE);
-		}
-	return com_rslt;
-}
- /*!
- *	@brief This function used for read the trim values of magnetometer
- *
- *	@note
- *	Before reading the mag trimming values
- *	make sure the following two points are addressed
- *	@note
- *	1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note
- *	2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_bmm150_mag_trim(void)
-{
-	/* This variable used for provide the communication
-	results*/
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* Array holding the bmm150 trim data
-	*/
-	u8 v_data_u8[BMI160_MAG_TRIM_DATA_SIZE] = {
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE};
-	/* read dig_x1 value */
-	com_rslt = bmi160_set_mag_read_addr(
-	BMI160_MAG_DIG_X1);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* 0x04 is secondary read mag x lsb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[BMI160_BMM150_DIG_X1],
-	BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	mag_trim.dig_x1 = v_data_u8[BMI160_BMM150_DIG_X1];
-	/* read dig_y1 value */
-	com_rslt += bmi160_set_mag_read_addr(
-	BMI160_MAG_DIG_Y1);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* 0x04 is secondary read mag x lsb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[BMI160_BMM150_DIG_Y1],
-	BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	mag_trim.dig_y1 = v_data_u8[BMI160_BMM150_DIG_Y1];
-
-	/* read dig_x2 value */
-	com_rslt += bmi160_set_mag_read_addr(
-	BMI160_MAG_DIG_X2);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* 0x04 is secondary read mag x lsb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[BMI160_BMM150_DIG_X2],
-	BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	mag_trim.dig_x2 = v_data_u8[BMI160_BMM150_DIG_X2];
-	/* read dig_y2 value */
-	com_rslt += bmi160_set_mag_read_addr(
-	BMI160_MAG_DIG_Y2);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* 0x04 is secondary read mag x lsb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[BMI160_BMM150_DIG_Y3],
-	BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	mag_trim.dig_y2 = v_data_u8[BMI160_BMM150_DIG_Y3];
-
-	/* read dig_xy1 value */
-	com_rslt += bmi160_set_mag_read_addr(
-	BMI160_MAG_DIG_XY1);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* 0x04 is secondary read mag x lsb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[BMI160_BMM150_DIG_XY1],
-	BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	mag_trim.dig_xy1 = v_data_u8[BMI160_BMM150_DIG_XY1];
-	/* read dig_xy2 value */
-	com_rslt += bmi160_set_mag_read_addr(
-	BMI160_MAG_DIG_XY2);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* 0x04 is v_mag_x_s16 ls register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[BMI160_BMM150_DIG_XY2],
-	BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	mag_trim.dig_xy2 = v_data_u8[BMI160_BMM150_DIG_XY2];
-
-	/* read dig_z1 lsb value */
-	com_rslt += bmi160_set_mag_read_addr(
-	BMI160_MAG_DIG_Z1_LSB);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* 0x04 is secondary read mag x lsb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[BMI160_BMM150_DIG_Z1_LSB],
-	BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* read dig_z1 msb value */
-	com_rslt += bmi160_set_mag_read_addr(BMI160_MAG_DIG_Z1_MSB);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* 0x04 is v_mag_x_s16 msb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[BMI160_BMM150_DIG_Z1_MSB],
-	BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	mag_trim.dig_z1 =
-	(u16)((((u32)((u8)v_data_u8[BMI160_BMM150_DIG_Z1_MSB]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS) |
-			(v_data_u8[BMI160_BMM150_DIG_Z1_LSB]));
-
-	/* read dig_z2 lsb value */
-	com_rslt += bmi160_set_mag_read_addr(BMI160_MAG_DIG_Z2_LSB);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* 0x04 is secondary read mag x lsb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[BMI160_BMM150_DIG_Z2_LSB],
-	BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* read dig_z2 msb value */
-	com_rslt += bmi160_set_mag_read_addr(BMI160_MAG_DIG_Z2_MSB);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* 0x04 is v_mag_x_s16 msb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[BMI160_BMM150_DIG_Z2_MSB],
-	BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	mag_trim.dig_z2 =
-	(s16)((((s32)((s8)v_data_u8[BMI160_BMM150_DIG_Z2_MSB]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS) |
-			(v_data_u8[BMI160_BMM150_DIG_Z2_LSB]));
-
-	/* read dig_z3 lsb value */
-	com_rslt += bmi160_set_mag_read_addr(BMI160_MAG_DIG_Z3_LSB);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* 0x04 is secondary read mag x lsb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[BMI160_BMM150_DIG_DIG_Z3_LSB],
-	BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* read dig_z3 msb value */
-	com_rslt += bmi160_set_mag_read_addr(BMI160_MAG_DIG_Z3_MSB);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* 0x04 is v_mag_x_s16 msb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[BMI160_BMM150_DIG_DIG_Z3_MSB],
-	BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	mag_trim.dig_z3 =
-	(s16)((((s32)((s8)v_data_u8[BMI160_BMM150_DIG_DIG_Z3_MSB]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS) |
-			(v_data_u8[BMI160_BMM150_DIG_DIG_Z3_LSB]));
-	/* read dig_z4 lsb value */
-	com_rslt += bmi160_set_mag_read_addr(BMI160_MAG_DIG_Z4_LSB);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* 0x04 is secondary read mag x lsb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[BMI160_BMM150_DIG_DIG_Z4_LSB],
-	BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* read dig_z4 msb value */
-	com_rslt += bmi160_set_mag_read_addr(BMI160_MAG_DIG_Z4_MSB);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* 0x04 is v_mag_x_s16 msb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[BMI160_BMM150_DIG_DIG_Z4_MSB],
-	BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	mag_trim.dig_z4 =
-	(s16)((((s32)((s8)v_data_u8[BMI160_BMM150_DIG_DIG_Z4_MSB]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS) |
-			(v_data_u8[BMI160_BMM150_DIG_DIG_Z4_LSB]));
-
-	/* read dig_xyz1 lsb value */
-	com_rslt += bmi160_set_mag_read_addr(BMI160_MAG_DIG_XYZ1_LSB);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* 0x04 is secondary read mag x lsb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[BMI160_BMM150_DIG_DIG_XYZ1_LSB],
-	BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* read dig_xyz1 msb value */
-	com_rslt += bmi160_set_mag_read_addr(BMI160_MAG_DIG_XYZ1_MSB);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* 0x04 is v_mag_x_s16 msb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[BMI160_BMM150_DIG_DIG_XYZ1_MSB],
-	BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	mag_trim.dig_xyz1 =
-	(u16)((((u32)((u8)v_data_u8[BMI160_BMM150_DIG_DIG_XYZ1_MSB]))
-			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS) |
-			(v_data_u8[BMI160_BMM150_DIG_DIG_XYZ1_LSB]));
-
-	return com_rslt;
-}
- /*!
- *	@brief This function used for initialize
- *	the AKM09911 and AKM09912 sensor
- *
- *
- *	@param v_akm_i2c_address_u8: The value of device address
- *	AKM sensor   |  Slave address
- * --------------|---------------------
- *  AKM09911     |  AKM09911_I2C_ADDR_1
- *     -         |  and AKM09911_I2C_ADDR_2
- *  AKM09912     |  AKM09912_I2C_ADDR_1
- *     -         |  AKM09912_I2C_ADDR_2
- *     -         |  AKM09912_I2C_ADDR_3
- *     -         |  AKM09912_I2C_ADDR_4
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_akm_mag_interface_init(
-u8 v_akm_i2c_address_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_pull_value_u8 = BMI160_INIT_VALUE;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	u8 v_akm_chip_id_u8 = BMI160_INIT_VALUE;
-	/* accel operation mode to normal*/
-	com_rslt = bmi160_set_command_register(ACCEL_MODE_NORMAL);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	com_rslt += bmi160_set_command_register(MAG_MODE_NORMAL);
-	p_bmi160->delay_msec(BMI160_AKM_INIT_DELAY);
-	bmi160_get_mag_power_mode_stat(&v_data_u8);
-	/* register 0x7E write the 0x37, 0x9A and 0x30*/
-	com_rslt += bmi160_set_command_register(BMI160_COMMAND_REG_ONE);
-	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-	com_rslt += bmi160_set_command_register(BMI160_COMMAND_REG_TWO);
-	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-	com_rslt += bmi160_set_command_register(BMI160_COMMAND_REG_THREE);
-	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-	/*switch the page1*/
-	com_rslt += bmi160_set_target_page(BMI160_WRITE_TARGET_PAGE1);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	bmi160_get_target_page(&v_data_u8);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	com_rslt += bmi160_set_paging_enable(BMI160_WRITE_ENABLE_PAGE1);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	bmi160_get_paging_enable(&v_data_u8);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* enable the pullup configuration from
-	the register 0x05 bit 4 and 5  to 10*/
-	bmi160_get_pullup_configuration(&v_pull_value_u8);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	v_pull_value_u8 = v_pull_value_u8 | BMI160_PULL_UP_DATA;
-	com_rslt += bmi160_set_pullup_configuration(v_pull_value_u8);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-
-	/*switch the page0*/
-	com_rslt += bmi160_set_target_page(BMI160_WRITE_TARGET_PAGE0);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	bmi160_get_target_page(&v_data_u8);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* Write the AKM09911 0r AKM09912 i2c address*/
-	com_rslt += bmi160_set_i2c_device_addr(v_akm_i2c_address_u8);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* enable the mag interface to manual mode*/
-	com_rslt += bmi160_set_mag_manual_enable(BMI160_MANUAL_ENABLE);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	bmi160_get_mag_manual_enable(&v_data_u8);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/*Enable the MAG interface */
-	com_rslt += bmi160_set_if_mode(BMI160_ENABLE_MAG_IF_MODE);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	bmi160_get_if_mode(&v_data_u8);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-
-	/* Set the AKM Fuse ROM mode */
-	/* Set value for fuse ROM mode*/
-	com_rslt += bmi160_set_mag_write_data(AKM_FUSE_ROM_MODE);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* AKM mode address is 0x31*/
-	com_rslt += bmi160_set_mag_write_addr(AKM_POWER_MODE_REG);
-	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-	/* Read the Fuse ROM v_data_u8 from registers
-	0x60,0x61 and 0x62*/
-	/* ASAX v_data_u8 */
-	com_rslt += bmi160_read_bst_akm_sensitivity_data();
-	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-	/* read the device id of the AKM sensor
-	if device id is 0x05 - AKM09911
-	if device id is 0x04 - AKM09912*/
-	com_rslt += bmi160_set_mag_read_addr(AKM_CHIP_ID_REG);
-	/* 0x04 is mag_x lsb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_akm_chip_id_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	/* Set value power down mode mode*/
-	com_rslt += bmi160_set_mag_write_data(AKM_POWER_DOWN_MODE_DATA);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* AKM mode address is 0x31*/
-	com_rslt += bmi160_set_mag_write_addr(AKM_POWER_MODE_REG);
-	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-	/* Set AKM Force mode*/
-	com_rslt += bmi160_set_mag_write_data(
-	AKM_SINGLE_MEASUREMENT_MODE);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* AKM mode address is 0x31*/
-	com_rslt += bmi160_set_mag_write_addr(AKM_POWER_MODE_REG);
-	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-	/* Set the AKM read xyz v_data_u8 address*/
-	com_rslt += bmi160_set_mag_read_addr(AKM_DATA_REGISTER);
-	/* write the mag v_data_bw_u8 as 25Hz*/
-	com_rslt += bmi160_set_mag_output_data_rate(
-	BMI160_MAG_OUTPUT_DATA_RATE_25HZ);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* Enable mag interface to auto mode*/
-	com_rslt += bmi160_set_mag_manual_enable(BMI160_MANUAL_DISABLE);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	bmi160_get_mag_manual_enable(&v_data_u8);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-
-	return com_rslt;
-}
- /*!
- *	@brief This function used for read the sensitivity data of
- *	AKM09911 and AKM09912
- *
- *	@note Before reading the mag sensitivity values
- *	make sure the following two points are addressed
- *	@note	1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note	2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_bst_akm_sensitivity_data(void)
-{
-	/* This variable used for provide the communication
-	results*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* Array holding the sensitivity ax,ay and az data*/
-	u8 v_data_u8[BMI160_AKM_SENSITIVITY_DATA_SIZE] = {
-	BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE};
-	/* read asax value */
-	com_rslt = bmi160_set_mag_read_addr(BMI160_BST_AKM_ASAX);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* 0x04 is secondary read mag x lsb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[AKM_ASAX],
-	BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	akm_asa_data.asax = v_data_u8[AKM_ASAX];
-	/* read asay value */
-	com_rslt += bmi160_set_mag_read_addr(BMI160_BST_AKM_ASAY);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* 0x04 is secondary read mag x lsb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[AKM_ASAY],
-	BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	akm_asa_data.asay = v_data_u8[AKM_ASAY];
-	/* read asaz value */
-	com_rslt += bmi160_set_mag_read_addr(BMI160_BST_AKM_ASAZ);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* 0x04 is secondary read mag x lsb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[AKM_ASAZ],
-	BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	akm_asa_data.asaz = v_data_u8[AKM_ASAZ];
-
-	return com_rslt;
-}
-/*!
- *	@brief This API used to get the compensated X data
- *	of AKM09911 the out put of X as s32
- *	@note	Before start reading the mag compensated X data
- *			make sure the following two points are addressed
- *	@note 1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note 2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
- *
- *
- *  @param v_bst_akm_x_s16 : The value of X data
- *
- *	@return results of compensated X data value output as s32
- *
- */
-s32 bmi160_bst_akm09911_compensate_X(s16 v_bst_akm_x_s16)
-{
-	/*Return value of AKM x compensated v_data_u8*/
-	s32 retval = BMI160_INIT_VALUE;
-	/* Convert raw v_data_u8 into compensated v_data_u8*/
-	retval = (v_bst_akm_x_s16 *
-	((akm_asa_data.asax/AKM09911_SENSITIVITY_DIV) +
-	BMI160_GEN_READ_WRITE_DATA_LENGTH));
-	return retval;
-}
-/*!
- *	@brief This API used to get the compensated Y data
- *	of AKM09911 the out put of Y as s32
- *	@note	Before start reading the mag compensated Y data
- *			make sure the following two points are addressed
- *	@note 1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note 2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
- *
- *
- *  @param v_bst_akm_y_s16 : The value of Y data
- *
- *	@return results of compensated Y data value output as s32
- *
- */
-s32 bmi160_bst_akm09911_compensate_Y(s16 v_bst_akm_y_s16)
-{
-	/*Return value of AKM y compensated v_data_u8*/
-	s32 retval = BMI160_INIT_VALUE;
-	/* Convert raw v_data_u8 into compensated v_data_u8*/
-	retval = (v_bst_akm_y_s16 *
-	((akm_asa_data.asay/AKM09911_SENSITIVITY_DIV) +
-	BMI160_GEN_READ_WRITE_DATA_LENGTH));
-	return retval;
-}
-/*!
- *	@brief This API used to get the compensated Z data
- *	of AKM09911 the out put of Z as s32
- *	@note	Before start reading the mag compensated Z data
- *			make sure the following two points are addressed
- *	@note 1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note 2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
- *
- *
- *  @param v_bst_akm_z_s16 : The value of Z data
- *
- *	@return results of compensated Z data value output as s32
- *
- */
-s32 bmi160_bst_akm09911_compensate_Z(s16 v_bst_akm_z_s16)
-{
-	/*Return value of AKM z compensated v_data_u8*/
-	s32 retval = BMI160_INIT_VALUE;
-	/* Convert raw v_data_u8 into compensated v_data_u8*/
-	retval = (v_bst_akm_z_s16 *
-	((akm_asa_data.asaz/AKM09911_SENSITIVITY_DIV) +
-	BMI160_GEN_READ_WRITE_DATA_LENGTH));
-	return retval;
-}
-/*!
- *	@brief This API used to get the compensated X data
- *	of AKM09912 the out put of X as s32
- *	@note	Before start reading the mag compensated X data
- *			make sure the following two points are addressed
- *	@note 1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note 2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
- *
- *
- *  @param v_bst_akm_x_s16 : The value of X data
- *
- *	@return results of compensated X data value output as s32
- *
- */
-s32 bmi160_bst_akm09912_compensate_X(s16 v_bst_akm_x_s16)
-{
-	/*Return value of AKM x compensated data*/
-	s32 retval = BMI160_INIT_VALUE;
-	/* Convert raw data into compensated data*/
-	retval = v_bst_akm_x_s16 *
-	(akm_asa_data.asax + AKM09912_SENSITIVITY)
-	/ AKM09912_SENSITIVITY_DIV;
-	return retval;
-}
-/*!
- *	@brief This API used to get the compensated Y data
- *	of AKM09912 the out put of Y as s32
- *	@note	Before start reading the mag compensated Y data
- *			make sure the following two points are addressed
- *	@note 1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note 2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
- *
- *
- *  @param v_bst_akm_y_s16 : The value of Y data
- *
- *	@return results of compensated Y data value output as s32
- *
- */
-s32 bmi160_bst_akm09912_compensate_Y(s16 v_bst_akm_y_s16)
-{
-	/*Return value of AKM y compensated data*/
-	s32 retval = BMI160_INIT_VALUE;
-	/* Convert raw data into compensated data*/
-	retval = v_bst_akm_y_s16 *
-	(akm_asa_data.asax + AKM09912_SENSITIVITY)
-	/ AKM09912_SENSITIVITY_DIV;
-	return retval;
-}
-/*!
- *	@brief This API used to get the compensated Z data
- *	of AKM09912 the out put of Z as s32
- *	@note	Before start reading the mag compensated Z data
- *			make sure the following two points are addressed
- *	@note 1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note 2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
- *
- *
- *  @param v_bst_akm_z_s16 : The value of Z data
- *
- *	@return results of compensated Z data value output as s32
- *
- */
-s32 bmi160_bst_akm09912_compensate_Z(s16 v_bst_akm_z_s16)
-{
-	/*Return value of AKM z compensated data*/
-	s32 retval = BMI160_INIT_VALUE;
-	/* Convert raw data into compensated data*/
-	retval = v_bst_akm_z_s16 *
-	(akm_asa_data.asax + AKM09912_SENSITIVITY)
-	/ AKM09912_SENSITIVITY_DIV;
-	return retval;
-}
- /*!
- *	@brief This function used for read the compensated value of
- *	AKM09911
- *	@note Before start reading the mag compensated data's
- *	make sure the following two points are addressed
- *	@note	1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note	2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
-
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_akm09911_compensate_xyz(
-struct bmi160_bst_akm_xyz_t *bst_akm_xyz)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	struct bmi160_mag_t mag_xyz;
-
-	com_rslt = bmi160_read_mag_xyz(&mag_xyz, BST_AKM);
-	/* Compensation for X axis */
-	bst_akm_xyz->x = bmi160_bst_akm09911_compensate_X(mag_xyz.x);
-
-	/* Compensation for Y axis */
-	bst_akm_xyz->y = bmi160_bst_akm09911_compensate_Y(mag_xyz.y);
-
-	/* Compensation for Z axis */
-	bst_akm_xyz->z = bmi160_bst_akm09911_compensate_Z(mag_xyz.z);
-
-	return com_rslt;
-}
- /*!
- *	@brief This function used for read the compensated value of
- *	AKM09912
- *	@note Before start reading the mag compensated data's
- *	make sure the following two points are addressed
- *	@note	1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note	2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
-
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_akm09912_compensate_xyz(
-struct bmi160_bst_akm_xyz_t *bst_akm_xyz)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	struct bmi160_mag_t mag_xyz;
-
-	com_rslt = bmi160_read_mag_xyz(&mag_xyz, BST_AKM);
-	/* Compensation for X axis */
-	bst_akm_xyz->x = bmi160_bst_akm09912_compensate_X(mag_xyz.x);
-
-	/* Compensation for Y axis */
-	bst_akm_xyz->y = bmi160_bst_akm09912_compensate_Y(mag_xyz.y);
-
-	/* Compensation for Z axis */
-	bst_akm_xyz->z = bmi160_bst_akm09912_compensate_Z(mag_xyz.z);
-
-	return com_rslt;
-}
-/*!
- *	@brief This function used for set the AKM09911 and AKM09912
- *	power mode.
- *	@note Before set the AKM power mode
- *	make sure the following two points are addressed
- *	@note	1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note	2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
- *
- *	@param v_akm_pow_mode_u8 : The value of akm power mode
- *  value   |    Description
- * ---------|--------------------
- *    0     |  AKM_POWER_DOWN_MODE
- *    1     |  AKM_SINGLE_MEAS_MODE
- *    2     |  FUSE_ROM_MODE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_akm_set_powermode(
-u8 v_akm_pow_mode_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* set mag interface manual mode*/
-	if (p_bmi160->mag_manual_enable != BMI160_MANUAL_ENABLE) {
-		com_rslt = bmi160_set_mag_manual_enable(
-		BMI160_MANUAL_ENABLE);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	}
-	switch (v_akm_pow_mode_u8) {
-	case AKM_POWER_DOWN_MODE:
-		/* Set the power mode of AKM as power down mode*/
-		com_rslt += bmi160_set_mag_write_data(AKM_POWER_DOWN_MODE_DATA);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		com_rslt += bmi160_set_mag_write_addr(AKM_POWER_MODE_REG);
-		p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-	break;
-	case AKM_SINGLE_MEAS_MODE:
-		/* Set the power mode of AKM as
-		single measurement mode*/
-		com_rslt += bmi160_set_mag_write_data
-		(AKM_SINGLE_MEASUREMENT_MODE);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		com_rslt += bmi160_set_mag_write_addr(AKM_POWER_MODE_REG);
-		p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-		com_rslt += bmi160_set_mag_read_addr(AKM_DATA_REGISTER);
-	break;
-	case FUSE_ROM_MODE:
-		/* Set the power mode of AKM as
-		Fuse ROM mode*/
-		com_rslt += bmi160_set_mag_write_data(AKM_FUSE_ROM_MODE);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		com_rslt += bmi160_set_mag_write_addr(AKM_POWER_MODE_REG);
-		p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-		/* Sensitivity v_data_u8 */
-		com_rslt += bmi160_read_bst_akm_sensitivity_data();
-		p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-		/* power down mode*/
-		com_rslt += bmi160_set_mag_write_data(AKM_POWER_DOWN_MODE);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		com_rslt += bmi160_set_mag_write_addr(AKM_POWER_MODE_REG);
-		p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-	break;
-	default:
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-	break;
-	}
-	/* set mag interface auto mode*/
-	if (p_bmi160->mag_manual_enable == BMI160_MANUAL_ENABLE) {
-		com_rslt += bmi160_set_mag_manual_enable(
-		BMI160_MANUAL_DISABLE);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	}
-	return com_rslt;
-}
- /*!
- *	@brief This function used for set the magnetometer
- *	power mode of AKM09911 and AKM09912
- *	@note Before set the mag power mode
- *	make sure the following two point is addressed
- *		Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *
- *	@param v_mag_sec_if_pow_mode_u8 : The value of secondary if power mode
- *  value   |    Description
- * ---------|--------------------
- *    0     |  BMI160_MAG_FORCE_MODE
- *    1     |  BMI160_MAG_SUSPEND_MODE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_bst_akm_and_secondary_if_powermode(
-u8 v_mag_sec_if_pow_mode_u8)
-{
-	/* variable used for return the status of communication result*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* accel operation mode to normal*/
-	com_rslt = bmi160_set_command_register(ACCEL_MODE_NORMAL);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* set mag interface manual mode*/
-	if (p_bmi160->mag_manual_enable != BMI160_MANUAL_ENABLE) {
-		com_rslt = bmi160_set_mag_manual_enable(
-		BMI160_MANUAL_ENABLE);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	}
-	switch (v_mag_sec_if_pow_mode_u8) {
-	case BMI160_MAG_FORCE_MODE:
-		/* set the secondary mag power mode as NORMAL*/
-		com_rslt += bmi160_set_mag_interface_normal();
-		/* set the akm power mode as single measurement mode*/
-		com_rslt += bmi160_bst_akm_set_powermode(AKM_SINGLE_MEAS_MODE);
-		p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-		com_rslt += bmi160_set_mag_read_addr(AKM_DATA_REGISTER);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	break;
-	case BMI160_MAG_SUSPEND_MODE:
-		/* set the akm power mode as power down mode*/
-		com_rslt += bmi160_bst_akm_set_powermode(AKM_POWER_DOWN_MODE);
-		p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-		/* set the secondary mag power mode as SUSPEND*/
-		com_rslt += bmi160_set_command_register(MAG_MODE_SUSPEND);
-		p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-	break;
-	default:
-		com_rslt = E_BMI160_OUT_OF_RANGE;
-	break;
-	}
-	/* set mag interface auto mode*/
-	if (p_bmi160->mag_manual_enable == BMI160_MANUAL_ENABLE)
-		com_rslt += bmi160_set_mag_manual_enable(
-		BMI160_MANUAL_DISABLE);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	return com_rslt;
-}
-/*!
- *	@brief This function used for read the YAMAH-YAS532 init
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yamaha_yas532_mag_interface_init(
-void)
-{
-	/* This variable used for provide the communication
-	results*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	u8 v_pull_value_u8 = BMI160_INIT_VALUE;
-	u8 v_data_u8 = BMI160_INIT_VALUE;
-	u8 i = BMI160_INIT_VALUE;
-	/* accel operation mode to normal*/
-	com_rslt = bmi160_set_command_register(ACCEL_MODE_NORMAL);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* write mag power mode as NORMAL*/
-	com_rslt += bmi160_set_mag_interface_normal();
-	/* register 0x7E write the 0x37, 0x9A and 0x30*/
-	com_rslt += bmi160_set_command_register(BMI160_COMMAND_REG_ONE);
-	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-	com_rslt += bmi160_set_command_register(BMI160_COMMAND_REG_TWO);
-	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-	com_rslt += bmi160_set_command_register(BMI160_COMMAND_REG_THREE);
-	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-	/*switch the page1*/
-	com_rslt += bmi160_set_target_page(BMI160_WRITE_TARGET_PAGE1);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	bmi160_get_target_page(&v_data_u8);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	com_rslt += bmi160_set_paging_enable(BMI160_WRITE_ENABLE_PAGE1);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	bmi160_get_paging_enable(&v_data_u8);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* enable the pullup configuration from
-	the register 0x05 bit 4 and 5 as 10*/
-	bmi160_get_pullup_configuration(&v_pull_value_u8);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	v_pull_value_u8 = v_pull_value_u8 | BMI160_PULL_UP_DATA;
-	com_rslt += bmi160_set_pullup_configuration(v_pull_value_u8);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/*switch the page0*/
-	com_rslt += bmi160_set_target_page(BMI160_WRITE_TARGET_PAGE0);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	bmi160_get_target_page(&v_data_u8);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* Write the YAS532 i2c address*/
-	com_rslt += bmi160_set_i2c_device_addr(BMI160_AUX_YAS532_I2C_ADDRESS);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* enable the mag interface to manual mode*/
-	com_rslt += bmi160_set_mag_manual_enable(BMI160_MANUAL_ENABLE);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	bmi160_get_mag_manual_enable(&v_data_u8);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/*Enable the MAG interface */
-	com_rslt += bmi160_set_if_mode(BMI160_ENABLE_MAG_IF_MODE);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	bmi160_get_if_mode(&v_data_u8);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	v_data_u8 = BMI160_MANUAL_DISABLE;
-	/* Read the YAS532 device id is 0x02*/
-	com_rslt += bmi160_set_mag_read_addr(BMI160_YAS_DEVICE_ID_REG);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* Read the YAS532 calibration data*/
-	com_rslt += bmi160_bst_yamaha_yas532_calib_values();
-	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-	/* Assign the data acquisition mode*/
-	yas532_data.measure_state = YAS532_MAG_STATE_INIT_COIL;
-	/* Set the default offset as invalid offset*/
-	set_vector(yas532_data.v_hard_offset_s8, INVALID_OFFSET);
-	/* set the transform to zero */
-
-	yas532_data.transform = BMI160_NULL;
-	/* Assign overflow as zero*/
-	yas532_data.overflow = 0;
-	#if 1 < YAS532_MAG_TEMPERATURE_LOG
-		yas532_data.temp_data.num =
-		yas532_data.temp_data.idx = 0;
-	#endif
-	/* Assign the coef value*/
-	for (i = 0; i < 3; i++) {
-		yas532_data.coef[i] = yas532_version_ac_coef[i];
-		yas532_data.last_raw[i] = 0;
-	}
-	yas532_data.last_raw[3] = 0;
-	/* Set the initial values of yas532*/
-	com_rslt += bmi160_bst_yas532_set_initial_values();
-	/* write the mag v_data_bw_u8 as 25Hz*/
-	com_rslt += bmi160_set_mag_output_data_rate(
-	BMI160_MAG_OUTPUT_DATA_RATE_25HZ);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* Enable mag interface to auto mode*/
-	com_rslt += bmi160_set_mag_manual_enable(
-	BMI160_MANUAL_DISABLE);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	bmi160_get_mag_manual_enable(&v_data_u8);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-
-	return com_rslt;
-}
-/*!
- *	@brief This function used to set the YAS532 initial values
- *
- *
-  *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_set_initial_values(void)
-{
-/* This variable used for provide the communication
-	results*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* write testr1 as 0x00*/
-	com_rslt = bmi160_set_mag_write_data(
-	BMI160_YAS532_WRITE_TESTR1);
-	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-	com_rslt += bmi160_set_mag_write_addr(BMI160_YAS532_TESTR1);
-	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-	/* write testr2 as 0x00*/
-	com_rslt += bmi160_set_mag_write_data(
-	BMI160_YAS532_WRITE_TESTR2);
-	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-	com_rslt += bmi160_set_mag_write_addr(BMI160_YAS532_TESTR2);
-	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-	/* write Rcoil as 0x00*/
-	com_rslt += bmi160_set_mag_write_data(
-	BMI160_YAS532_WRITE_RCOIL);
-	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-	com_rslt += bmi160_set_mag_write_addr(BMI160_YAS532_RCOIL);
-	p_bmi160->delay_msec(BMI160_YAS532_SET_INITIAL_VALUE_DELAY);
-	/* check the valid offset*/
-	if (is_valid_offset(yas532_data.v_hard_offset_s8)) {
-		com_rslt += bmi160_bst_yas532_set_offset(
-		yas532_data.v_hard_offset_s8);
-		yas532_data.measure_state = YAS532_MAG_STATE_NORMAL;
-	} else {
-		/* set the default offset as invalid offset*/
-		set_vector(yas532_data.v_hard_offset_s8, INVALID_OFFSET);
-		/*Set the default measure state for offset correction*/
-		yas532_data.measure_state = YAS532_MAG_STATE_MEASURE_OFFSET;
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This function used for YAS532 offset correction
- *
- *
-  *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_magnetic_measure_set_offset(
-void)
-{
-	/* This variable used for provide the communication
-	results*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* used for offset value set to the offset register*/
-	s8 v_hard_offset_s8[BMI160_HARD_OFFSET_DATA_SIZE] = {
-	BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE};
-	/* offset correction factors*/
-	static const u8 v_correct_u8[BMI160_YAS_CORRECT_DATA_SIZE] = {
-	16, 8, 4, 2, 1};
-	/* used for the temperature */
-	u16 v_temp_u16 = BMI160_INIT_VALUE;
-	/* used for the xy1y2 read*/
-	u16 v_xy1y2_u16[BMI160_YAS_XY1Y2_DATA_SIZE] = {BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE};
-	/* local flag for assign the values*/
-	s32 v_flag_s32[BMI160_YAS_FLAG_DATA_SIZE] = {BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE};
-	u8 i, j, v_busy_u8, v_overflow_u8 = BMI160_INIT_VALUE;
-
-	for (i = 0; i < 5; i++) {
-		/* set the offset values*/
-		com_rslt = bmi160_bst_yas532_set_offset(v_hard_offset_s8);
-		/* read the sensor data*/
-		com_rslt += bmi160_bst_yas532_normal_measurement_data(
-		BMI160_YAS532_ACQ_START, &v_busy_u8, &v_temp_u16,
-		v_xy1y2_u16, &v_overflow_u8);
-		/* check the sensor busy status*/
-		if (v_busy_u8)
-			return E_BMI160_BUSY;
-		/* calculate the magnetic correction with
-		offset and assign the values
-		to the offset register */
-		for (j = 0; j < 3; j++) {
-			if (YAS532_DATA_CENTER == v_xy1y2_u16[j])
-				v_flag_s32[j] = 0;
-			if (YAS532_DATA_CENTER < v_xy1y2_u16[j])
-				v_flag_s32[j] = 1;
-			if (v_xy1y2_u16[j] < YAS532_DATA_CENTER)
-				v_flag_s32[j] = -1;
-		}
-		for (j = 0; j < 3; j++) {
-			if (v_flag_s32[j])
-				v_hard_offset_s8[j] = (s8)(v_hard_offset_s8[j]
-				+ v_flag_s32[j] * v_correct_u8[i]);
-		}
-	}
-	/* set the offset */
-	com_rslt += bmi160_bst_yas532_set_offset(v_hard_offset_s8);
-	return com_rslt;
-}
-/*!
- *	@brief This function used for read the
- *	YAMAHA YAS532 calibration data
- *
- *
-  *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yamaha_yas532_calib_values(void)
-{
-	/* This variable used for provide the communication
-	results*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* Array holding the YAS532 calibration values */
-	u8 v_data_u8[BMI160_YAS532_CALIB_DATA_SIZE] = {
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE};
-	/* Read the DX value */
-	com_rslt = bmi160_set_mag_read_addr(BMI160_YAS532_CALIB_CX);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	/* 0x04 is secondary read mag x lsb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[0], BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	yas532_data.calib_yas532.cx = (s32)((v_data_u8[0]
-	* 10) - 1280);
-	/* Read the DY1 value */
-	com_rslt += bmi160_set_mag_read_addr(BMI160_YAS532_CALIB_CY1);
-	/* 0x04 is secondary read mag x lsb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[1], BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	yas532_data.calib_yas532.cy1 =
-	(s32)((v_data_u8[1] * 10) - 1280);
-	/* Read the DY2 value */
-	com_rslt += bmi160_set_mag_read_addr(BMI160_YAS532_CALIB_CY2);
-	/* 0x04 is secondary read mag x lsb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[2], BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	yas532_data.calib_yas532.cy2 =
-	(s32)((v_data_u8[2] * 10) - 1280);
-	/* Read the D2 and D3 value */
-	com_rslt += bmi160_set_mag_read_addr(BMI160_YAS532_CALIB1);
-	/* 0x04 is secondary read mag x lsb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[3], BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	yas532_data.calib_yas532.a2 =
-	(s32)(((v_data_u8[3] >>
-	BMI160_SHIFT_BIT_POSITION_BY_02_BITS)
-	& 0x03F) - 32);
-	/* Read the D3 and D4 value */
-	com_rslt += bmi160_set_mag_read_addr(BMI160_YAS532_CALIB2);
-	/* 0x04 is secondary read mag x lsb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[4], BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	/* calculate a3*/
-	yas532_data.calib_yas532.a3 = (s32)((((v_data_u8[3] <<
-	BMI160_SHIFT_BIT_POSITION_BY_02_BITS) & 0x0C) |
-	((v_data_u8[4]
-	>> BMI160_SHIFT_BIT_POSITION_BY_06_BITS)
-	& 0x03)) - 8);
-	/* calculate a4*/
-	yas532_data.calib_yas532.a4 = (s32)((v_data_u8[4]
-	& 0x3F) - 32);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-    /* Read the D5 and D6 value */
-	com_rslt += bmi160_set_mag_read_addr(BMI160_YAS532_CALIB3);
-	/* 0x04 is secondary read mag x lsb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[5], BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	/* calculate a5*/
-	yas532_data.calib_yas532.a5 =
-	(s32)(((v_data_u8[5]
-	>> BMI160_SHIFT_BIT_POSITION_BY_02_BITS)
-	& 0x3F) + 38);
-	/* Read the D6 and D7 value */
-	com_rslt += bmi160_set_mag_read_addr(BMI160_YAS532_CALIB4);
-	/* 0x04 is secondary read mag x lsb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[6], BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	/* calculate a6*/
-	yas532_data.calib_yas532.a6 =
-	(s32)((((v_data_u8[5]
-	<< BMI160_SHIFT_BIT_POSITION_BY_04_BITS)
-	& 0x30) | ((v_data_u8[6] >>
-	 BMI160_SHIFT_BIT_POSITION_BY_04_BITS)
-	 & 0x0F)) - 32);
-	 /* Read the D7 and D8 value */
-	com_rslt += bmi160_set_mag_read_addr(BMI160_YAS532_CALIB5);
-	/* 0x04 is secondary read mag x lsb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[7], BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	/* calculate a7*/
-	yas532_data.calib_yas532.a7 = (s32)((((v_data_u8[6]
-	<< BMI160_SHIFT_BIT_POSITION_BY_03_BITS)
-	& 0x78) |
-	((v_data_u8[7]
-	>> BMI160_SHIFT_BIT_POSITION_BY_05_BITS) &
-	0x07)) - 64);
-	/* Read the D8 and D9 value */
-	com_rslt += bmi160_set_mag_read_addr(BMI160_YAS532_CLAIB6);
-	/* 0x04 is secondary read mag x lsb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[8], BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	/* calculate a8*/
-	yas532_data.calib_yas532.a8 = (s32)((((v_data_u8[7] <<
-	BMI160_GEN_READ_WRITE_DATA_LENGTH) & 0x3E) |
-	((v_data_u8[8] >>
-	BMI160_SHIFT_BIT_POSITION_BY_07_BITS) & 0x01)) -
-	32);
-
-	/* Read the D8 and D9 value */
-	com_rslt += bmi160_set_mag_read_addr(BMI160_YAS532_CALIB7);
-	/* 0x04 is secondary read mag x lsb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[9], BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	/* calculate a9*/
-	yas532_data.calib_yas532.a9 = (s32)(((v_data_u8[8] <<
-	BMI160_GEN_READ_WRITE_DATA_LENGTH) & 0xFE) |
-	 ((v_data_u8[9] >>
-	 BMI160_SHIFT_BIT_POSITION_BY_07_BITS) & 0x01));
-	/* calculate k*/
-	yas532_data.calib_yas532.k = (s32)((v_data_u8[9] >>
-	BMI160_SHIFT_BIT_POSITION_BY_02_BITS) & 0x1F);
-	/* Read the  value from register 0x9A*/
-	com_rslt += bmi160_set_mag_read_addr(BMI160_YAS532_CALIB8);
-	/* 0x04 is secondary read mag x lsb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[10],
-	BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	/* Read the  value from register 0x9B*/
-	com_rslt += bmi160_set_mag_read_addr(BMI160_YAS532_CALIIB9);
-	/* 0x04 is secondary read mag x lsb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[11],
-	BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	/* Read the  value from register 0x9C*/
-	com_rslt += bmi160_set_mag_read_addr(BMI160_YAS532_CALIB10);
-	/* 0x04 is secondary read mag x lsb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[12],
-	BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	/* Read the  value from register 0x9D*/
-	com_rslt += bmi160_set_mag_read_addr(BMI160_YAS532_CALIB11);
-	/* 0x04 is secondary read mag x lsb register */
-	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-	&v_data_u8[13],
-	BMI160_GEN_READ_WRITE_DATA_LENGTH);
-	/* Calculate the fxy1y2 and rxy1y1*/
-	yas532_data.calib_yas532.fxy1y2[0] =
-	(u8)(((v_data_u8[10]
-	& 0x01)
-	<< BMI160_SHIFT_BIT_POSITION_BY_01_BIT)
-	| ((v_data_u8[11] >>
-	BMI160_SHIFT_BIT_POSITION_BY_07_BITS) & 0x01));
-	yas532_data.calib_yas532.rxy1y2[0] =
-	((s8)(((v_data_u8[10]
-	>> BMI160_SHIFT_BIT_POSITION_BY_01_BIT) & 0x3F)
-	<< BMI160_SHIFT_BIT_POSITION_BY_02_BITS))
-	>> BMI160_SHIFT_BIT_POSITION_BY_02_BITS;
-	yas532_data.calib_yas532.fxy1y2[1] =
-	(u8)(((v_data_u8[11] & 0x01)
-	<< BMI160_SHIFT_BIT_POSITION_BY_01_BIT)
-	 | ((v_data_u8[12] >>
-	 BMI160_SHIFT_BIT_POSITION_BY_07_BITS) & 0x01));
-	yas532_data.calib_yas532.rxy1y2[1] =
-	((s8)(((v_data_u8[11]
-	>> BMI160_SHIFT_BIT_POSITION_BY_01_BIT) & 0x3F)
-	<< BMI160_SHIFT_BIT_POSITION_BY_02_BITS))
-	>> BMI160_SHIFT_BIT_POSITION_BY_02_BITS;
-	yas532_data.calib_yas532.fxy1y2[2] =
-	(u8)(((v_data_u8[12] & 0x01)
-	<< BMI160_SHIFT_BIT_POSITION_BY_01_BIT)
-	| ((v_data_u8[13]
-	>> BMI160_SHIFT_BIT_POSITION_BY_07_BITS) & 0x01));
-	yas532_data.calib_yas532.rxy1y2[2] =
-	((s8)(((v_data_u8[12]
-	>> BMI160_SHIFT_BIT_POSITION_BY_01_BIT) & 0x3F)
-	 << BMI160_SHIFT_BIT_POSITION_BY_02_BITS))
-	 >> BMI160_SHIFT_BIT_POSITION_BY_02_BITS;
-
-	return com_rslt;
-}
-/*!
- *	@brief This function used for calculate the
- *	YAS532 read the linear data
- *
- *
-  *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_xy1y2_to_linear(
-u16 *v_xy1y2_u16, s32 *xy1y2_linear)
-{
-	/* This variable used for provide the communication
-	results*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = SUCCESS;
-	static const u16 v_calib_data[] = {
-	3721, 3971, 4221, 4471};
-	u8 i = BMI160_INIT_VALUE;
-
-	for (i = 0; i < 3; i++)
-		xy1y2_linear[i] = v_xy1y2_u16[i] -
-		 v_calib_data[yas532_data.calib_yas532.fxy1y2[i]]
-			+ (yas532_data.v_hard_offset_s8[i] -
-			yas532_data.calib_yas532.rxy1y2[i])
-			* yas532_data.coef[i];
-	return com_rslt;
-}
-/*!
- *	@brief This function used for read the YAS532 sensor data
- *	@param	v_acquisition_command_u8: used to set the data acquisition
- *	acquisition_command  |   operation
- *  ---------------------|-------------------------
- *         0x17          | turn on the acquisition coil
- *         -             | set direction of the coil
- *         _             | (x and y as minus(-))
- *         _             | Deferred acquisition mode
- *        0x07           | turn on the acquisition coil
- *         _             | set direction of the coil
- *         _             | (x and y as minus(-))
- *         _             | Normal acquisition mode
- *        0x11           | turn OFF the acquisition coil
- *         _             | set direction of the coil
- *         _             | (x and y as plus(+))
- *         _             | Deferred acquisition mode
- *       0x01            | turn OFF the acquisition coil
- *        _              | set direction of the coil
- *        _              | (x and y as plus(+))
- *        _              | Normal acquisition mode
- *
- *	@param	v_busy_u8 : used to get the busy flay for sensor data read
- *	@param	v_temp_u16 : used to get the temperature data
- *	@param	v_xy1y2_u16 : used to get the sensor xy1y2 data
- *	@param	v_overflow_u8 : used to get the overflow data
- *
- *
- *
-  *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_normal_measurement_data(
-u8 v_acquisition_command_u8, u8 *v_busy_u8,
-u16 *v_temp_u16, u16 *v_xy1y2_u16, u8 *v_overflow_u8)
-{
-	/* This variable used for provide the communication
-	results*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* Array holding the YAS532 xyy1 data*/
-	u8 v_data_u8[BMI160_YAS_XY1Y2T_DATA_SIZE] = {
-	BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE};
-	u8 i = BMI160_INIT_VALUE;
-	/* check the p_bmi160 structure as NULL*/
-	if (p_bmi160 == BMI160_NULL) {
-		return E_BMI160_NULL_PTR;
-		} else {
-		/* read the sensor data */
-		com_rslt = bmi160_bst_yas532_acquisition_command_register(
-		v_acquisition_command_u8);
-		com_rslt +=
-		p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-		BMI160_USER_DATA_MAG_X_LSB__REG,
-		v_data_u8, BMI160_MAG_YAS_DATA_LENGTH);
-		 v_data_u8[0] = 0x31;
-		 v_data_u8[1] = 0xF8;
-		 v_data_u8[2] = 0x49;
-		 v_data_u8[3] = 0x3B;
-		 v_data_u8[4] = 0x45;
-		 v_data_u8[5] = 0x8F;
-		 v_data_u8[6] = 0x31;
-		 v_data_u8[7] = 0x90;
-		/* read the xyy1 data*/
-		*v_busy_u8 =
-		((v_data_u8[0]
-		>> BMI160_SHIFT_BIT_POSITION_BY_07_BITS) & 0x01);
-		*v_temp_u16 =
-		(u16)((((s32)v_data_u8[0]
-		<< BMI160_SHIFT_BIT_POSITION_BY_03_BITS)
-		& 0x3F8) | ((v_data_u8[1]
-		>> BMI160_SHIFT_BIT_POSITION_BY_05_BITS) & 0x07));
-		v_xy1y2_u16[0] =
-		(u16)((((s32)v_data_u8[2]
-		<< BMI160_SHIFT_BIT_POSITION_BY_06_BITS) & 0x1FC0)
-		| ((v_data_u8[3] >>
-		BMI160_SHIFT_BIT_POSITION_BY_02_BITS) & 0x3F));
-		v_xy1y2_u16[1] =
-		(u16)((((s32)v_data_u8[4]
-		<< BMI160_SHIFT_BIT_POSITION_BY_06_BITS)
-		& 0x1FC0)
-		| ((v_data_u8[5]
-		>> BMI160_SHIFT_BIT_POSITION_BY_02_BITS) & 0x3F));
-		v_xy1y2_u16[2] =
-		(u16)((((s32)v_data_u8[6]
-		<< BMI160_SHIFT_BIT_POSITION_BY_06_BITS)
-		& 0x1FC0)
-		| ((v_data_u8[7]
-		>> BMI160_SHIFT_BIT_POSITION_BY_02_BITS) & 0x3F));
-		*v_overflow_u8 = 0;
-		for (i = 0; i < 3; i++) {
-			if (v_xy1y2_u16[i] == YAS532_DATA_OVERFLOW)
-				*v_overflow_u8 |= (1 << (i * 2));
-			if (v_xy1y2_u16[i] == YAS532_DATA_UNDERFLOW)
-				*v_overflow_u8 |= (1 << (i * 2 + 1));
-		}
-	}
-	return com_rslt;
-}
-/*!
- *	@brief This function used for YAS532 sensor data
- *	@param	v_acquisition_command_u8	:	the value of CMDR
- *	acquisition_command  |   operation
- *  ---------------------|-------------------------
- *         0x17          | turn on the acquisition coil
- *         -             | set direction of the coil
- *         _             | (x and y as minus(-))
- *         _             | Deferred acquisition mode
- *        0x07           | turn on the acquisition coil
- *         _             | set direction of the coil
- *         _             | (x and y as minus(-))
- *         _             | Normal acquisition mode
- *        0x11           | turn OFF the acquisition coil
- *         _             | set direction of the coil
- *         _             | (x and y as plus(+))
- *         _             | Deferred acquisition mode
- *       0x01            | turn OFF the acquisition coil
- *        _              | set direction of the coil
- *        _              | (x and y as plus(+))
- *        _              | Normal acquisition mode
- *
- * @param xyz_data : the vector xyz output
- * @param v_overflow_s8 : the value of overflow
- * @param v_temp_correction_u8 : the value of temperate correction enable
- *
- *
-  *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_measurement_xyz_data(
-struct yas532_vector *xyz_data, u8 *v_overflow_s8, u8 v_temp_correction_u8,
-u8 v_acquisition_command_u8)
-{
-	/* This variable used for provide the communication
-	results*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* Array holding the linear calculation output*/
-	s32 v_xy1y2_linear_s32[BMI160_YAS_XY1Y2_DATA_SIZE] = {
-	BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE};
-	/* Array holding the temperature data */
-	s32 v_xyz_tmp_s32[BMI160_YAS_TEMP_DATA_SIZE] = {BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE};
-	s32 tmp = BMI160_INIT_VALUE;
-	s32 sx, sy1, sy2, sy, sz = BMI160_INIT_VALUE;
-	u8 i, v_busy_u8 = BMI160_INIT_VALUE;
-	u16 v_temp_u16 = BMI160_INIT_VALUE;
-	/* Array holding the xyy1 sensor raw data*/
-	u16 v_xy1y2_u16[BMI160_YAS_XY1Y2_DATA_SIZE] = {BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE};
-	#if 1 < YAS532_MAG_TEMPERATURE_LOG
-	s32 sum = BMI160_INIT_VALUE;
-	#endif
-	*v_overflow_s8 = BMI160_INIT_VALUE;
-	switch (yas532_data.measure_state) {
-	case YAS532_MAG_STATE_INIT_COIL:
-		if (p_bmi160->mag_manual_enable != BMI160_MANUAL_ENABLE)
-			com_rslt = bmi160_set_mag_manual_enable(
-			BMI160_MANUAL_ENABLE);
-		/* write Rcoil*/
-		com_rslt += bmi160_set_mag_write_data(
-		BMI160_YAS_DISABLE_RCOIL);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		com_rslt += bmi160_set_mag_write_addr(BMI160_YAS532_RCOIL);
-		p_bmi160->delay_msec(BMI160_YAS532_MEASUREMENT_DELAY);
-		if (!yas532_data.overflow && is_valid_offset(
-		yas532_data.v_hard_offset_s8))
-			yas532_data.measure_state = 0;
-	break;
-	case YAS532_MAG_STATE_MEASURE_OFFSET:
-		com_rslt = bmi160_bst_yas532_magnetic_measure_set_offset();
-		yas532_data.measure_state = 0;
-	break;
-	default:
-	break;
-	}
-	/* Read sensor data*/
-	com_rslt += bmi160_bst_yas532_normal_measurement_data(
-	v_acquisition_command_u8, &v_busy_u8, &v_temp_u16,
-	v_xy1y2_u16, v_overflow_s8);
-	/* Calculate the linear data*/
-	com_rslt += bmi160_bst_yas532_xy1y2_to_linear(v_xy1y2_u16,
-	v_xy1y2_linear_s32);
-	/* Calculate temperature correction */
-	#if 1 < YAS532_MAG_TEMPERATURE_LOG
-		yas532_data.temp_data.log[yas532_data.temp_data.idx++] =
-		v_temp_u16;
-	if (YAS532_MAG_TEMPERATURE_LOG <= yas532_data.temp_data.idx)
-		yas532_data.temp_data.idx = 0;
-		yas532_data.temp_data.num++;
-	if (YAS532_MAG_TEMPERATURE_LOG <= yas532_data.temp_data.num)
-		yas532_data.temp_data.num = YAS532_MAG_TEMPERATURE_LOG;
-	for (i = 0; i < yas532_data.temp_data.num; i++)
-		sum += yas532_data.temp_data.log[i];
-		tmp = sum * 10 / yas532_data.temp_data.num
-		- YAS532_TEMP20DEGREE_TYPICAL * 10;
-	#else
-		tmp = (v_temp_u16 - YAS532_TEMP20DEGREE_TYPICAL)
-		* 10;
-	#endif
-	sx  = v_xy1y2_linear_s32[0];
-	sy1 = v_xy1y2_linear_s32[1];
-	sy2 = v_xy1y2_linear_s32[2];
-	/* Temperature correction */
-	if (v_temp_correction_u8) {
-		sx  -= (yas532_data.calib_yas532.cx  * tmp)
-		/ 1000;
-		sy1 -= (yas532_data.calib_yas532.cy1 * tmp)
-		/ 1000;
-		sy2 -= (yas532_data.calib_yas532.cy2 * tmp)
-		/ 1000;
-	}
-	sy = sy1 - sy2;
-	sz = -sy1 - sy2;
-	#if 1
-	xyz_data->yas532_vector_xyz[0] = yas532_data.calib_yas532.k *
-	((100 * sx + yas532_data.calib_yas532.a2 * sy +
-	yas532_data.calib_yas532.a3 * sz) / 10);
-	xyz_data->yas532_vector_xyz[1] = yas532_data.calib_yas532.k *
-	((yas532_data.calib_yas532.a4 * sx + yas532_data.calib_yas532.a5 * sy +
-	yas532_data.calib_yas532.a6 * sz) / 10);
-	xyz_data->yas532_vector_xyz[2] = yas532_data.calib_yas532.k *
-	((yas532_data.calib_yas532.a7 * sx + yas532_data.calib_yas532.a8 * sy +
-	yas532_data.calib_yas532.a9 * sz) / 10);
-	if (yas532_data.transform != BMI160_NULL) {
-		for (i = 0; i < 3; i++) {
-				v_xyz_tmp_s32[i] = yas532_data.transform[i
-				* 3] *
-				xyz_data->yas532_vector_xyz[0]
-				+ yas532_data.transform[i * 3 + 1] *
-				xyz_data->yas532_vector_xyz[1]
-				+ yas532_data.transform[i * 3 + 2] *
-				xyz_data->yas532_vector_xyz[2];
-		}
-		set_vector(xyz_data->yas532_vector_xyz, v_xyz_tmp_s32);
-	}
-	for (i = 0; i < 3; i++) {
-		xyz_data->yas532_vector_xyz[i] -=
-		xyz_data->yas532_vector_xyz[i] % 10;
-		if (*v_overflow_s8 & (1
-		<< (i * 2)))
-			xyz_data->yas532_vector_xyz[i] +=
-			1; /* set overflow */
-		if (*v_overflow_s8 & (1 <<
-		(i * 2 + 1)))
-			xyz_data->yas532_vector_xyz[i] += 2; /* set underflow */
-	}
-#else
-	xyz_data->yas532_vector_xyz[0] = sx;
-	xyz_data->yas532_vector_xyz[1] = sy;
-	xyz_data->yas532_vector_xyz[2] = sz;
-#endif
-if (v_busy_u8)
-		return com_rslt;
-	if (0 < *v_overflow_s8) {
-		if (!yas532_data.overflow)
-			yas532_data.overflow = 1;
-		yas532_data.measure_state = YAS532_MAG_STATE_INIT_COIL;
-	} else
-		yas532_data.overflow = 0;
-	for (i = 0; i < 3; i++)
-		yas532_data.last_raw[i] = v_xy1y2_u16[i];
-	  yas532_data.last_raw[i] = v_temp_u16;
-	return com_rslt;
-}
-/*!
- *	@brief This function used for YAS532 sensor data
- *	@param	v_acquisition_command_u8	:	the value of CMDR
- *
- * @param v_xy1y2_u16 : the vector xyz output
- * @param v_overflow_s8 : the value of overflow
- * @param v_temp_correction_u8 : the value of temperate correction enable
- *
- *
-  *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_fifo_xyz_data(
-u16 *v_xy1y2_u16, u8 v_temp_correction_u8,
-s8 v_overflow_s8, u16 v_temp_u16, u8 v_busy_u8)
-{
-	/* This variable used for provide the communication
-	results*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* Array holding the linear calculation output*/
-	s32 v_xy1y2_linear_s32[BMI160_YAS_XY1Y2_DATA_SIZE] = {
-	BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE};
-	/* Array holding the temperature data */
-	s32 v_xyz_tmp_s32[BMI160_YAS_TEMP_DATA_SIZE] = {BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE};
-	s32 tmp = BMI160_INIT_VALUE;
-	s32 sx, sy1, sy2, sy, sz = BMI160_INIT_VALUE;
-	u8 i = BMI160_INIT_VALUE;
-	#if 1 < YAS532_MAG_TEMPERATURE_LOG
-	s32 sum = BMI160_INIT_VALUE;
-	#endif
-	v_overflow_s8 = BMI160_INIT_VALUE;
-	/* Calculate the linear data*/
-	com_rslt = bmi160_bst_yas532_xy1y2_to_linear(v_xy1y2_u16,
-	v_xy1y2_linear_s32);
-	/* Calculate temperature correction */
-	#if 1 < YAS532_MAG_TEMPERATURE_LOG
-		yas532_data.temp_data.log[yas532_data.temp_data.idx++] =
-		v_temp_u16;
-	if (YAS532_MAG_TEMPERATURE_LOG <= yas532_data.temp_data.idx)
-		yas532_data.temp_data.idx = 0;
-		yas532_data.temp_data.num++;
-	if (YAS532_MAG_TEMPERATURE_LOG <= yas532_data.temp_data.num)
-		yas532_data.temp_data.num = YAS532_MAG_TEMPERATURE_LOG;
-	for (i = 0; i < yas532_data.temp_data.num; i++)
-		sum += yas532_data.temp_data.log[i];
-		tmp = sum * 10 / yas532_data.temp_data.num
-		- YAS532_TEMP20DEGREE_TYPICAL * 10;
-	#else
-		tmp = (v_temp_u16 - YAS532_TEMP20DEGREE_TYPICAL)
-		* 10;
-	#endif
-	sx  = v_xy1y2_linear_s32[0];
-	sy1 = v_xy1y2_linear_s32[1];
-	sy2 = v_xy1y2_linear_s32[2];
-	/* Temperature correction */
-	if (v_temp_correction_u8) {
-		sx  -= (yas532_data.calib_yas532.cx  * tmp)
-		/ 1000;
-		sy1 -= (yas532_data.calib_yas532.cy1 * tmp)
-		/ 1000;
-		sy2 -= (yas532_data.calib_yas532.cy2 * tmp)
-		/ 1000;
-	}
-	sy = sy1 - sy2;
-	sz = -sy1 - sy2;
-	#if 1
-	fifo_xyz_data.yas532_vector_xyz[0] = yas532_data.calib_yas532.k *
-	((100 * sx + yas532_data.calib_yas532.a2 * sy +
-	yas532_data.calib_yas532.a3 * sz) / 10);
-	fifo_xyz_data.yas532_vector_xyz[1] = yas532_data.calib_yas532.k *
-	((yas532_data.calib_yas532.a4 * sx + yas532_data.calib_yas532.a5 * sy +
-	yas532_data.calib_yas532.a6 * sz) / 10);
-	fifo_xyz_data.yas532_vector_xyz[2] = yas532_data.calib_yas532.k *
-	((yas532_data.calib_yas532.a7 * sx + yas532_data.calib_yas532.a8 * sy +
-	yas532_data.calib_yas532.a9 * sz) / 10);
-	if (yas532_data.transform != BMI160_NULL) {
-		for (i = 0; i < 3; i++) {
-				v_xyz_tmp_s32[i] = yas532_data.transform[i
-				* 3] *
-				fifo_xyz_data.yas532_vector_xyz[0]
-				+ yas532_data.transform[i * 3 + 1] *
-				fifo_xyz_data.yas532_vector_xyz[1]
-				+ yas532_data.transform[i * 3 + 2] *
-				fifo_xyz_data.yas532_vector_xyz[2];
-		}
-		set_vector(fifo_xyz_data.yas532_vector_xyz, v_xyz_tmp_s32);
-	}
-	for (i = 0; i < 3; i++) {
-		fifo_xyz_data.yas532_vector_xyz[i] -=
-		fifo_xyz_data.yas532_vector_xyz[i] % 10;
-		if (v_overflow_s8 & (1
-		<< (i * 2)))
-			fifo_xyz_data.yas532_vector_xyz[i] +=
-			1; /* set overflow */
-		if (v_overflow_s8 & (1 <<
-		(i * 2 + 1)))
-			fifo_xyz_data.yas532_vector_xyz[i] += 2;
-	}
-#else
-	fifo_xyz_data.yas532_vector_xyz[0] = sx;
-	fifo_xyz_data.yas532_vector_xyz[1] = sy;
-	fifo_xyz_data.yas532_vector_xyz[2] = sz;
-#endif
-if (v_busy_u8)
-		return com_rslt;
-	if (0 < v_overflow_s8) {
-		if (!yas532_data.overflow)
-			yas532_data.overflow = 1;
-		yas532_data.measure_state = YAS532_MAG_STATE_INIT_COIL;
-	} else
-		yas532_data.overflow = 0;
-	for (i = 0; i < 3; i++)
-		yas532_data.last_raw[i] = v_xy1y2_u16[i];
-	  yas532_data.last_raw[i] = v_temp_u16;
-	return com_rslt;
-}
-/*!
- *	@brief This function used for YAS532 write data acquisition
- *	@param
- */
-/*!
- *	@brief This function used for YAS532 write data acquisition
- *	command register write
- *	@param	v_command_reg_data_u8	:	the value of data acquisition
- *	acquisition_command  |   operation
- *  ---------------------|-------------------------
- *         0x17          | turn on the acquisition coil
- *         -             | set direction of the coil
- *         _             | (x and y as minus(-))
- *         _             | Deferred acquisition mode
- *        0x07           | turn on the acquisition coil
- *         _             | set direction of the coil
- *         _             | (x and y as minus(-))
- *         _             | Normal acquisition mode
- *        0x11           | turn OFF the acquisition coil
- *         _             | set direction of the coil
- *         _             | (x and y as plus(+))
- *         _             | Deferred acquisition mode
- *       0x01            | turn OFF the acquisition coil
- *        _              | set direction of the coil
- *        _              | (x and y as plus(+))
- *        _              | Normal acquisition mode
- *
- *
- *
-  *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_acquisition_command_register(
-u8 v_command_reg_data_u8)
-{
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-
-	if (p_bmi160->mag_manual_enable != BMI160_MANUAL_ENABLE)
-			com_rslt = bmi160_set_mag_manual_enable(
-			BMI160_MANUAL_ENABLE);
-
-		com_rslt = bmi160_set_mag_write_data(v_command_reg_data_u8);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		/* YAMAHA YAS532-0x82*/
-		com_rslt += bmi160_set_mag_write_addr(
-		BMI160_YAS532_COMMAND_REGISTER);
-		p_bmi160->delay_msec(BMI160_YAS_ACQ_COMMAND_DELAY);
-		com_rslt += bmi160_set_mag_read_addr(
-		BMI160_YAS532_DATA_REGISTER);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-
-	if (p_bmi160->mag_manual_enable == BMI160_MANUAL_ENABLE)
-		com_rslt += bmi160_set_mag_manual_enable(BMI160_MANUAL_DISABLE);
-
-	return com_rslt;
-
-}
-/*!
- *	@brief This function used write offset of YAS532
- *
- *	@param	p_offset_s8	: The value of offset to write
- *
- *
-  *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_set_offset(
-const s8 *p_offset_s8)
-{
-	/* This variable used for provide the communication
-	results*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-
-	if (p_bmi160->mag_manual_enable != BMI160_MANUAL_ENABLE)
-		com_rslt = bmi160_set_mag_manual_enable(BMI160_MANUAL_ENABLE);
-		p_bmi160->delay_msec(BMI160_YAS532_OFFSET_DELAY);
-
-	    /* Write offset X data*/
-		com_rslt = bmi160_set_mag_write_data(p_offset_s8[0]);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		/* YAS532 offset x write*/
-		com_rslt += bmi160_set_mag_write_addr(BMI160_YAS532_OFFSET_X);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-
-		/* Write offset Y data*/
-		com_rslt = bmi160_set_mag_write_data(p_offset_s8[1]);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		/* YAS532 offset y write*/
-		com_rslt += bmi160_set_mag_write_addr(BMI160_YAS532_OFFSET_Y);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-
-		/* Write offset Z data*/
-		com_rslt = bmi160_set_mag_write_data(p_offset_s8[2]);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		/* YAS532 offset z write*/
-		com_rslt += bmi160_set_mag_write_addr(BMI160_YAS532_OFFSET_Z);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		set_vector(yas532_data.v_hard_offset_s8, p_offset_s8);
-
-	if (p_bmi160->mag_manual_enable == BMI160_MANUAL_ENABLE)
-		com_rslt = bmi160_set_mag_manual_enable(BMI160_MANUAL_DISABLE);
-	return com_rslt;
-}
-/*!
- *	@brief This function used to init the YAMAH-YAS537
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yamaha_yas537_mag_interface_init(
-void)
-{
-/* This variable used for provide the communication
-results*/
-BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-u8 v_pull_value_u8 = BMI160_INIT_VALUE;
-u8 v_data_u8 = BMI160_INIT_VALUE;
-u8 i = BMI160_INIT_VALUE;
-/* accel operation mode to normal*/
-com_rslt = bmi160_set_command_register(ACCEL_MODE_NORMAL);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-/* write mag power mode as NORMAL*/
-com_rslt += bmi160_set_mag_interface_normal();
-/* register 0x7E write the 0x37, 0x9A and 0x30*/
-com_rslt += bmi160_set_command_register(BMI160_COMMAND_REG_ONE);
-p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-com_rslt += bmi160_set_command_register(BMI160_COMMAND_REG_TWO);
-p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-com_rslt += bmi160_set_command_register(BMI160_COMMAND_REG_THREE);
-p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-/*switch the page1*/
-com_rslt += bmi160_set_target_page(BMI160_WRITE_TARGET_PAGE1);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-bmi160_get_target_page(&v_data_u8);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-com_rslt += bmi160_set_paging_enable(BMI160_WRITE_ENABLE_PAGE1);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-bmi160_get_paging_enable(&v_data_u8);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-/* enable the pullup configuration from
-the register 0x05 bit 4 and 5 as 10*/
-bmi160_get_pullup_configuration(&v_pull_value_u8);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-v_pull_value_u8 = v_pull_value_u8 | BMI160_PULL_UP_DATA;
-com_rslt += bmi160_set_pullup_configuration(v_pull_value_u8);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-/*switch the page0*/
-com_rslt += bmi160_set_target_page(BMI160_WRITE_TARGET_PAGE0);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-bmi160_get_target_page(&v_data_u8);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-/* Write the YAS532 i2c address*/
-com_rslt += bmi160_set_i2c_device_addr(BMI160_YAS537_I2C_ADDRESS);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-/* enable the mag interface to manual mode*/
-com_rslt += bmi160_set_mag_manual_enable(BMI160_MANUAL_ENABLE);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-bmi160_get_mag_manual_enable(&v_data_u8);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-/*Enable the MAG interface */
-com_rslt += bmi160_set_if_mode(BMI160_ENABLE_MAG_IF_MODE);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-bmi160_get_if_mode(&v_data_u8);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-v_data_u8 = BMI160_MANUAL_DISABLE;
-/* Read the YAS537 device id 0x07*/
-com_rslt += bmi160_set_mag_read_addr(BMI160_YAS_DEVICE_ID_REG);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
-yas537_data.dev_id = v_data_u8;
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-/* Read the YAS532 calibration data*/
-
-com_rslt +=
-bmi160_bst_yamaha_yas537_calib_values(
-BMI160_GEN_READ_WRITE_DATA_LENGTH);
-p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-/* set the mode to NORMAL*/
-yas537_data.measure_state = YAS537_MAG_STATE_NORMAL;
-/* set the transform to zero */
-yas537_data.transform = BMI160_NULL;
-yas537_data.average = 32;
-for (i = 0; i < 3; i++) {
-	yas537_data.hard_offset[i] = -128;
-	yas537_data.last_after_rcoil[i] = 0;
-}
-for (i = 0; i < 4; i++)
-	yas537_data.last_raw[i] = 0;
-/* write the mag bandwidth as 25Hz*/
-com_rslt += bmi160_set_mag_output_data_rate(
-BMI160_MAG_OUTPUT_DATA_RATE_25HZ);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-/* Enable mag interface to auto mode*/
-com_rslt += bmi160_set_mag_manual_enable(
-BMI160_MANUAL_DISABLE);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-bmi160_get_mag_manual_enable(&v_data_u8);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-return com_rslt;
-}
-/*!
-*	@brief This function used for read the
-*	YAMAHA YAS537 calibration data
-*
-*
-*	@param v_rcoil_u8 : The value of r coil
-*
-*
-*	@return results of bus communication function
-*	@retval 0 -> Success
-*	@retval -1 -> Error
-*
-*
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yamaha_yas537_calib_values(
-u8 v_rcoil_u8)
-{
-/* This variable used for provide the communication
-results*/
-BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-/* Array holding the YAS532 calibration values */
-u8 a_data_u8[BMI160_YAS537_CALIB_DATA_SIZE] = {
-BMI160_INIT_VALUE, BMI160_INIT_VALUE,
-BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE,
-BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE,
-BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE,
-BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE,
-BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE,
-};
-static const u8 v_avrr_u8[] = {0x50, 0x60, 0x70};
-u8 v_cal_valid_u8 = BMI160_INIT_VALUE, i;
-/* write soft reset as 0x02*/
-com_rslt = bmi160_set_mag_write_data(
-YAS537_SRSTR_DATA);
-p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-com_rslt += bmi160_set_mag_write_addr(YAS537_REG_SRSTR);
-p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-/* Read the DX value */
-com_rslt = bmi160_set_mag_read_addr(YAS537_REG_CALR_C0);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-/* 0x04 is secondary read mag x lsb register */
-com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-&a_data_u8[0], BMI160_GEN_READ_WRITE_DATA_LENGTH);
-/* Read the DY1 value */
-com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_C1);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-/* 0x04 is secondary read mag x lsb register */
-com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-&a_data_u8[1], BMI160_GEN_READ_WRITE_DATA_LENGTH);
-/* Read the DY2 value */
-com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_C2);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-/* 0x04 is secondary read mag x lsb register */
-com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-&a_data_u8[2], BMI160_GEN_READ_WRITE_DATA_LENGTH);
-/* Read the D2 value */
-com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_C3);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-/* 0x04 is secondary read mag x lsb register */
-com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-&a_data_u8[3], BMI160_GEN_READ_WRITE_DATA_LENGTH);
-/* Read the D3 value */
-com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_C4);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-/* 0x04 is secondary read mag x lsb register */
-com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-&a_data_u8[4], BMI160_GEN_READ_WRITE_DATA_LENGTH);
-/* Read the D4 value */
-com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_C5);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-/* 0x04 is secondary read mag x lsb register */
-com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-&a_data_u8[5], BMI160_GEN_READ_WRITE_DATA_LENGTH);
-/* Read the D5 value */
-com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_C6);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-/* 0x04 is secondary read mag x lsb register */
-com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-&a_data_u8[6], BMI160_GEN_READ_WRITE_DATA_LENGTH);
-/* Read the D6 value */
-com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_C7);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-/* 0x04 is secondary read mag x lsb register */
-com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-&a_data_u8[7], BMI160_GEN_READ_WRITE_DATA_LENGTH);
-/* Read the D7 value */
-com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_C8);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-/* 0x04 is secondary read mag x lsb register */
-com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-&a_data_u8[8], BMI160_GEN_READ_WRITE_DATA_LENGTH);
-/* Read the D8 value */
-com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_C9);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-/* 0x04 is secondary read mag x lsb register */
-com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-&a_data_u8[9], BMI160_GEN_READ_WRITE_DATA_LENGTH);
-/* Read the D9 value */
-com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_CA);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-/* 0x04 is secondary read mag x lsb register */
-com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-&a_data_u8[10], BMI160_GEN_READ_WRITE_DATA_LENGTH);
-/* Read the RX value */
-com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_CB);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-/* 0x04 is secondary read mag x lsb register */
-com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-&a_data_u8[11], BMI160_GEN_READ_WRITE_DATA_LENGTH);
-/* Read the RY1 value */
-com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_CC);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-/* 0x04 is secondary read mag x lsb register */
-com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-&a_data_u8[12], BMI160_GEN_READ_WRITE_DATA_LENGTH);
-/* Read the RY2 value */
-com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_CD);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-/* 0x04 is secondary read mag x lsb register */
-com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-&a_data_u8[13], BMI160_GEN_READ_WRITE_DATA_LENGTH);
-/* Read the RY2 value */
-com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_CE);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-/* 0x04 is secondary read mag x lsb register */
-com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-&a_data_u8[14], BMI160_GEN_READ_WRITE_DATA_LENGTH);
-/* Read the CHF value */
-com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_CF);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-/* 0x04 is secondary read mag x lsb register */
-com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-&a_data_u8[15], BMI160_GEN_READ_WRITE_DATA_LENGTH);
-/* Read the VER value */
-com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_DO);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-/* 0x04 is secondary read mag x lsb register */
-com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
-&a_data_u8[16], BMI160_GEN_READ_WRITE_DATA_LENGTH);
-/* get the calib ver*/
-yas537_data.calib_yas537.ver =
-(a_data_u8[16] >> BMI160_SHIFT_BIT_POSITION_BY_06_BITS);
-for (i = 0; i < 17; i++) {
-	if (((i < 16 && a_data_u8[i]) != 0))
-		v_cal_valid_u8 = 1;
-	if ((i < 16 &&
-	(a_data_u8[i] & 0x3F)) != 0)
-		v_cal_valid_u8 = 1;
-}
-if (!v_cal_valid_u8)
-	return ERROR;
-if (yas537_data.calib_yas537.ver == 0) {
-	for (i = 0; i < 17; i++) {
-		if (i < 12) {
-			/* write offset*/
-			com_rslt += bmi160_set_mag_write_data(
-			a_data_u8[i]);
-			p_bmi160->delay_msec(
-			BMI160_GEN_READ_WRITE_DELAY);
-			com_rslt += bmi160_set_mag_write_addr(
-			YAS537_REG_MTCR + i);
-			p_bmi160->delay_msec(
-			BMI160_GEN_READ_WRITE_DELAY);
-		} else if (i < 15) {
-			/* write offset correction*/
-			com_rslt += bmi160_set_mag_write_data(
-			a_data_u8[i]);
-			p_bmi160->delay_msec(
-			BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-			com_rslt += bmi160_set_mag_write_addr((
-			(YAS537_REG_OXR + i) - 12));
-			p_bmi160->delay_msec(
-			BMI160_GEN_READ_WRITE_DELAY);
-			yas537_data.hard_offset[i - 12]
-			= a_data_u8[i];
-		} else {
-			/* write offset correction*/
-			com_rslt += bmi160_set_mag_write_data(
-			a_data_u8[i]);
-			p_bmi160->delay_msec(
-			BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-			com_rslt += bmi160_set_mag_write_addr((
-			(YAS537_REG_OXR + i) - 11));
-			p_bmi160->delay_msec(
-			BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-		}
-
-}
-} else if (yas537_data.calib_yas537.ver == 1) {
-	for (i = 0; i < 3; i++) {
-		/* write offset*/
-		com_rslt += bmi160_set_mag_write_data(
-		a_data_u8[i]);
-		p_bmi160->delay_msec(
-		BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-		com_rslt += bmi160_set_mag_write_addr(
-		YAS537_REG_MTCR + i);
-		p_bmi160->delay_msec(
-		BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-		if (com_rslt == SUCCESS) {
-			/* write offset*/
-			com_rslt += bmi160_set_mag_write_data(
-			a_data_u8[i + 12]);
-			p_bmi160->delay_msec(
-			BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-			com_rslt += bmi160_set_mag_write_addr(
-			YAS537_REG_OXR + i);
-			p_bmi160->delay_msec(
-			BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-			yas537_data.hard_offset[i] =
-			a_data_u8[i + 12];
-		} else {
-			com_rslt = ERROR;
-		}
-	}
-	/* write offset*/
-	com_rslt += bmi160_set_mag_write_data(
-	((a_data_u8[i] & 0xE0) | 0x10));
-	p_bmi160->delay_msec(
-	BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-	com_rslt += bmi160_set_mag_write_addr(
-	YAS537_REG_MTCR + i);
-	p_bmi160->delay_msec(
-	BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-	/* write offset*/
-	com_rslt += bmi160_set_mag_write_data(
-	((a_data_u8[15]
-	>> BMI160_SHIFT_BIT_POSITION_BY_03_BITS)
-	& 0x1E));
-	p_bmi160->delay_msec(
-	BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-	com_rslt += bmi160_set_mag_write_addr(YAS537_REG_HCKR);
-	p_bmi160->delay_msec(
-	BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-	/* write offset*/
-	com_rslt += bmi160_set_mag_write_data(
-	((a_data_u8[15] << 1) & 0x1E));
-	p_bmi160->delay_msec(
-	BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-	com_rslt += bmi160_set_mag_write_addr(YAS537_REG_LCKR);
-	p_bmi160->delay_msec(
-	BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-	/* write offset*/
-	com_rslt += bmi160_set_mag_write_data(
-	(a_data_u8[16] & 0x3F));
-	p_bmi160->delay_msec(
-	BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-	com_rslt += bmi160_set_mag_write_addr(YAS537_REG_OCR);
-	p_bmi160->delay_msec(
-	BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-
-	/* Assign the calibration values*/
-	/* a2 */
-	yas537_data.calib_yas537.a2 =
-	((((a_data_u8[3]
-	<< BMI160_SHIFT_BIT_POSITION_BY_02_BITS)
-	& 0x7C)
-	| (a_data_u8[4]
-	>> BMI160_SHIFT_BIT_POSITION_BY_06_BITS)) - 64);
-	/* a3 */
-	yas537_data.calib_yas537.a3 =
-	((((a_data_u8[4] << BMI160_SHIFT_BIT_POSITION_BY_01_BIT)
-	& 0x7E)
-	| (a_data_u8[5]
-	>> BMI160_SHIFT_BIT_POSITION_BY_07_BITS)) - 64);
-	/* a4 */
-	yas537_data.calib_yas537.a4 =
-	((((a_data_u8[5]
-	<< BMI160_SHIFT_BIT_POSITION_BY_01_BIT)
-	& 0xFE)
-	| (a_data_u8[6]
-	>> BMI160_SHIFT_BIT_POSITION_BY_07_BITS))
-	- 128);
-	/* a5 */
-	yas537_data.calib_yas537.a5 =
-	((((a_data_u8[6]
-	<< BMI160_SHIFT_BIT_POSITION_BY_02_BITS)
-	& 0x1FC)
-	| (a_data_u8[7]
-	>> BMI160_SHIFT_BIT_POSITION_BY_06_BITS))
-	- 112);
-	/* a6 */
-	yas537_data.calib_yas537.a6 =
-	((((a_data_u8[7]
-	<< BMI160_SHIFT_BIT_POSITION_BY_01_BIT)
-	& 0x7E)
-	| (a_data_u8[8]
-	>> BMI160_SHIFT_BIT_POSITION_BY_07_BITS)) - 64);
-	/* a7 */
-	yas537_data.calib_yas537.a7 =
-	((((a_data_u8[8]
-	<< BMI160_SHIFT_BIT_POSITION_BY_01_BIT)
-	& 0xFE)
-	| (a_data_u8[9]
-	>> BMI160_SHIFT_BIT_POSITION_BY_07_BITS))
-	- 128);
-	/* a8 */
-	yas537_data.calib_yas537.a8 = ((a_data_u8[9] &
-	0x7F) - 64);
-	/* a9 */
-	yas537_data.calib_yas537.a9 = ((((a_data_u8[10]
-	<< BMI160_SHIFT_BIT_POSITION_BY_01_BIT) & 0x1FE)
-	| (a_data_u8[11]
-	>> BMI160_SHIFT_BIT_POSITION_BY_07_BITS))
-	- 112);
-	/* k */
-	yas537_data.calib_yas537.k = (
-	a_data_u8[11] & 0x7F);
-	} else {
-		return ERROR;
-	}
-/* write A/D converter*/
-com_rslt += bmi160_set_mag_write_data(
-YAS537_WRITE_A_D_CONVERTER);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-com_rslt += bmi160_set_mag_write_addr(YAS537_REG_ADCCALR);
-p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-/* write A/D converter second register*/
-com_rslt += bmi160_set_mag_write_data(
-YAS537_WRITE_A_D_CONVERTER2);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-com_rslt += bmi160_set_mag_write_addr(YAS537_REG_ADCCALR_ONE);
-p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-/* write temperature calibration register*/
-com_rslt += bmi160_set_mag_write_data(YAS537_WRITE_TEMP_CALIB);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-com_rslt += bmi160_set_mag_write_addr(YAS537_REG_TRMR);
-p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-/* write average filter register*/
-com_rslt += bmi160_set_mag_write_data(
-v_avrr_u8[yas537_data.average]);
-p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-com_rslt += bmi160_set_mag_write_addr(YAS537_REG_AVRR);
-p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-if (v_rcoil_u8) {
-	/* write average; filter register*/
-	com_rslt += bmi160_set_mag_write_data(
-	YAS537_WRITE_FILTER);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	com_rslt += bmi160_set_mag_write_addr(YAS537_REG_CONFR);
-	p_bmi160->delay_msec(
-	BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-}
-
-return com_rslt;
-
-}
-/*!
- *	@brief This function used for YAS537 write data acquisition
- *	command register write
- *	@param	v_command_reg_data_u8	:	the value of data acquisition
- *	acquisition_command  |   operation
- *  ---------------------|-------------------------
- *         0x17          | turn on the acquisition coil
- *         -             | set direction of the coil
- *         _             | (x and y as minus(-))
- *         _             | Deferred acquisition mode
- *        0x07           | turn on the acquisition coil
- *         _             | set direction of the coil
- *         _             | (x and y as minus(-))
- *         _             | Normal acquisition mode
- *        0x11           | turn OFF the acquisition coil
- *         _             | set direction of the coil
- *         _             | (x and y as plus(+))
- *         _             | Deferred acquisition mode
- *       0x01            | turn OFF the acquisition coil
- *        _              | set direction of the coil
- *        _              | (x and y as plus(+))
- *        _              | Normal acquisition mode
- *
- *
- *
-  *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas537_acquisition_command_register(
-u8 v_command_reg_data_u8)
-{
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-
-	if (p_bmi160->mag_manual_enable != BMI160_MANUAL_ENABLE)
-			com_rslt = bmi160_set_mag_manual_enable(
-			BMI160_MANUAL_ENABLE);
-			p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-
-		com_rslt = bmi160_set_mag_write_data(v_command_reg_data_u8);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		/* YAMAHA YAS532-0x82*/
-		com_rslt += bmi160_set_mag_write_addr(
-		BMI160_REG_YAS537_CMDR);
-		/* set the mode to RECORD*/
-		yas537_data.measure_state = YAS537_MAG_STATE_RECORD_DATA;
-		p_bmi160->delay_msec(BMI160_YAS_ACQ_COMMAND_DELAY);
-		com_rslt += bmi160_set_mag_read_addr(
-		YAS537_REG_TEMPERATURE_0);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-
-	if (p_bmi160->mag_manual_enable == BMI160_MANUAL_ENABLE)
-		com_rslt += bmi160_set_mag_manual_enable(
-		BMI160_MANUAL_DISABLE);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-
-	return com_rslt;
-
-}
-/*!
- *	@brief This function used for read the
- *	YAMAHA YAS537 xy1y2 data
- *
- *	@param xy1y2: The value of raw xy1y2 data
- *	@param xyz: The value of  xyz data
- *
- *
- *	@return None
- *
- *
- */
-static void xy1y2_to_xyz(u16 *xy1y2, s32 *xyz)
-{
-	xyz[0] = ((xy1y2[0] - 8192)
-	* 300);
-	xyz[1] = (((xy1y2[1] - xy1y2[2])
-	* 1732) / 10);
-	xyz[2] = (((-xy1y2[2] - xy1y2[2])
-	+ 16384) * 300);
-}
-/*!
- *	@brief This function used for read the
- *	YAMAHA YAS537 xy1y2 data
- *
- *	@param v_coil_stat_u8: The value of R coil status
- *	@param v_busy_u8: The value of busy status
- *	@param v_temperature_u16: The value of temperature
- *	@param xy1y2: The value of raw xy1y2 data
- *	@param v_ouflow_u8: The value of overflow
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yamaha_yas537_read_xy1y2_data(
-u8 *v_coil_stat_u8, u8 *v_busy_u8,
-u16 *v_temperature_u16, u16 *xy1y2, u8 *v_ouflow_u8)
-{
-	/* This variable used for provide the communication
-	results*/
-	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
-	/* Array holding the YAS532 calibration values */
-	u8 a_data_u8[BMI160_YAS_XY1Y2T_DATA_SIZE] = {
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE,
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE,
-	};
-	u8 i = BMI160_INIT_VALUE;
-	s32 a_h_s32[BMI160_YAS_H_DATA_SIZE] = {
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE};
-	s32 a_s_s32[BMI160_YAS_S_DATA_SIZE] = {
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE};
-	/* set command register*/
-	com_rslt = bmi160_bst_yas537_acquisition_command_register(
-	YAS537_SET_COMMAND_REGISTER);
-	/* read the yas537 sensor data of xy1y2*/
-	com_rslt +=
-	p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
-	BMI160_USER_DATA_MAG_X_LSB__REG,
-	a_data_u8, BMI160_MAG_YAS_DATA_LENGTH);
-	/* read the busy flag*/
-	*v_busy_u8 = a_data_u8[2]
-	>> BMI160_SHIFT_BIT_POSITION_BY_07_BITS;
-	/* read the coil status*/
-	*v_coil_stat_u8 =
-	((a_data_u8[2] >>
-	BMI160_SHIFT_BIT_POSITION_BY_06_BITS) & 0X01);
-	/* read temperature data*/
-	*v_temperature_u16 = (u16)((a_data_u8[0]
-	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS) | a_data_u8[1]);
-	/* read x data*/
-	xy1y2[0] = (u16)(((a_data_u8[2] &
-	0x3F)
-	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-	| (a_data_u8[3]));
-	/* read y1 data*/
-	xy1y2[1] = (u16)((a_data_u8[4]
-	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-	| a_data_u8[5]);
-	/* read y2 data*/
-	xy1y2[2] = (u16)((a_data_u8[6]
-	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
-	| a_data_u8[7]);
-	for (i = 0; i < 3; i++)
-		yas537_data.last_raw[i] = xy1y2[i];
-	yas537_data.last_raw[i] = *v_temperature_u16;
-	if (yas537_data.calib_yas537.ver == 1) {
-		for (i = 0; i < 3; i++)
-			a_s_s32[i] = xy1y2[i] - 8192;
-		/* read hx*/
-		a_h_s32[0] = ((yas537_data.calib_yas537.k * (
-		(128 * a_s_s32[0]) +
-		(yas537_data.calib_yas537.a2 * a_s_s32[1]) +
-		(yas537_data.calib_yas537.a3 * a_s_s32[2])))
-		/ (8192));
-		/* read hy1*/
-		a_h_s32[1] = ((yas537_data.calib_yas537.k * (
-		(yas537_data.calib_yas537.a4 * a_s_s32[0]) +
-		(yas537_data.calib_yas537.a5 * a_s_s32[1]) +
-		(yas537_data.calib_yas537.a6 * a_s_s32[2])))
-		/ (8192));
-		/* read hy2*/
-		a_h_s32[2] = ((yas537_data.calib_yas537.k * (
-		(yas537_data.calib_yas537.a7 * a_s_s32[0]) +
-		(yas537_data.calib_yas537.a8 * a_s_s32[1]) +
-		(yas537_data.calib_yas537.a9 * a_s_s32[2])))
-		/ (8192));
-
-		for (i = 0; i < 3; i++) {
-			if (a_h_s32[i] < -8192)
-				a_h_s32[i] = -8192;
-
-			if (8192 < a_h_s32[i])
-				a_h_s32[i] = 8192;
-
-			xy1y2[i] = a_h_s32[i] + 8192;
-
-		}
-	}
-	*v_ouflow_u8 = 0;
-	for (i = 0; i < 3; i++) {
-		if (YAS537_DATA_OVERFLOW <= xy1y2[i])
-			*v_ouflow_u8 |= (1 << (i * 2));
-		if (xy1y2[i] == YAS537_DATA_UNDERFLOW)
-			*v_ouflow_u8 |= (1 << (i * 2 + 1));
-	}
-
-	return com_rslt;
-
-}
-/*!
- *	@brief This function used for read the
- *	YAMAHA YAS537 xy1y2 data
- *
- *	@param v_ouflow_u8: The value of overflow
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-static BMI160_RETURN_FUNCTION_TYPE invalid_magnetic_field(
-u16 *v_cur_u16, u16 *v_last_u16)
-{
-	s16 invalid_thresh[] = {1500, 1500, 1500};
-	u8 i = BMI160_INIT_VALUE;
-
-	for (i = 0; i < 3; i++)
-		if (invalid_thresh[i] < ABS(v_cur_u16[i] - v_last_u16[i]))
-			return 1;
-	return 0;
-}
-/*!
- *	@brief This function used for read the
- *	YAMAHA YAS537 xy1y2 data
- *
- *	@param v_ouflow_u8: The value of overflow
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yamaha_yas537_measure_xyz_data(
-u8 *v_ouflow_u8, struct yas_vector *vector_xyz)
-{
-	s32 a_xyz_tmp_s32[BMI160_YAS_TEMP_DATA_SIZE] = {
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE};
-	u8 i = BMI160_INIT_VALUE;
-	s8 com_rslt = BMI160_INIT_VALUE;
-	u8 v_busy_u8 = BMI160_INIT_VALUE;
-	u8 v_rcoil_u8 = BMI160_INIT_VALUE;
-	u16 v_temperature_u16 = BMI160_INIT_VALUE;
-	u16 a_xy1y2_u16[BMI160_YAS_XY1Y2_DATA_SIZE] = {
-	BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE};
-	*v_ouflow_u8 = 0;
-	/* read the yas537 xy1y2 data*/
-	com_rslt = bmi160_bst_yamaha_yas537_read_xy1y2_data(
-	&v_rcoil_u8, &v_busy_u8,
-	&v_temperature_u16, a_xy1y2_u16, v_ouflow_u8);
-	/* linear calculation*/
-	xy1y2_to_xyz(a_xy1y2_u16, vector_xyz->yas537_vector_xyz);
-	if (yas537_data.transform != BMI160_NULL) {
-		for (i = 0; i < 3; i++) {
-			a_xyz_tmp_s32[i] = ((
-			yas537_data.transform[i + 3]
-			* vector_xyz->yas537_vector_xyz[0])
-			+ (yas537_data.transform[
-			i * 3 + 1]
-			* vector_xyz->yas537_vector_xyz[1])
-			+ (yas537_data.transform[
-			i * 3 + 2]
-			* vector_xyz->yas537_vector_xyz[2]));
-		}
-		yas537_set_vector(
-		vector_xyz->yas537_vector_xyz, a_xyz_tmp_s32);
-	}
-	for (i = 0; i < 3; i++) {
-		vector_xyz->yas537_vector_xyz[i] -=
-		vector_xyz->yas537_vector_xyz[i] % 10;
-		if (*v_ouflow_u8 & (1 <<
-		(i * 2)))
-			vector_xyz->yas537_vector_xyz[i] +=
-			1; /* set overflow */
-		if (*v_ouflow_u8 & (1 << (i * 2 + 1)))
-			/* set underflow */
-			vector_xyz->yas537_vector_xyz[i] += 2;
-	}
-	if (v_busy_u8)
-		return ERROR;
-	switch (yas537_data.measure_state) {
-	case YAS537_MAG_STATE_INIT_COIL:
-		if (p_bmi160->mag_manual_enable != BMI160_MANUAL_ENABLE)
-			com_rslt = bmi160_set_mag_manual_enable(
-			BMI160_MANUAL_ENABLE);
-		com_rslt += bmi160_set_mag_write_data(YAS537_WRITE_CONFR);
-		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-		com_rslt += bmi160_set_mag_write_addr(YAS537_REG_CONFR);
-		p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-		yas537_data.measure_state = YAS537_MAG_STATE_RECORD_DATA;
-		if (p_bmi160->mag_manual_enable == BMI160_MANUAL_ENABLE)
-			com_rslt = bmi160_set_mag_manual_enable(
-			BMI160_MANUAL_DISABLE);
-	break;
-	case YAS537_MAG_STATE_RECORD_DATA:
-		if (v_rcoil_u8)
-			break;
-		yas537_set_vector(yas537_data.last_after_rcoil, a_xy1y2_u16);
-		yas537_data.measure_state = YAS537_MAG_STATE_NORMAL;
-	break;
-	case YAS537_MAG_STATE_NORMAL:
-		if (BMI160_INIT_VALUE < v_ouflow_u8
-		|| invalid_magnetic_field(a_xy1y2_u16,
-		yas537_data.last_after_rcoil)) {
-			yas537_data.measure_state = YAS537_MAG_STATE_INIT_COIL;
-			for (i = 0; i < 3; i++) {
-				if (!*v_ouflow_u8)
-					vector_xyz->yas537_vector_xyz[i] += 3;
-			}
-		}
-	break;
-	}
-
-	return com_rslt;
-}
-/*!
- *	@brief This function used for read the
- *	YAMAHA YAS537 xy1y2 data of fifo
- *
- *	@param a_xy1y2_u16: The value of xyy1 data
- *	@param v_over_flow_u8: The value of overflow
- *	@param v_rcoil_u8: The value of rcoil
- *	@param v_busy_u8: The value of busy flag
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yamaha_yas537_fifo_xyz_data(
-u16 *a_xy1y2_u16, u8 v_over_flow_u8, u8 v_rcoil_u8, u8 v_busy_u8)
-{
-
-s32 a_xyz_tmp_s32[BMI160_YAS_TEMP_DATA_SIZE] = {
-BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE};
-u8 i = BMI160_INIT_VALUE;
-s8 com_rslt = BMI160_INIT_VALUE;
-/* linear calculation*/
-xy1y2_to_xyz(a_xy1y2_u16, fifo_vector_xyz.yas537_vector_xyz);
-if (yas537_data.transform != BMI160_NULL) {
-	for (i = 0; i < 3; i++) {
-		a_xyz_tmp_s32[i] = ((
-		yas537_data.transform[i + 3]
-		* fifo_vector_xyz.yas537_vector_xyz[0])
-		+ (yas537_data.transform[
-		i * 3 + 1]
-		* fifo_vector_xyz.yas537_vector_xyz[1])
-		+ (yas537_data.transform[
-		i * 3 + 2]
-		* fifo_vector_xyz.yas537_vector_xyz[2]));
-	}
-	yas537_set_vector(
-	fifo_vector_xyz.yas537_vector_xyz, a_xyz_tmp_s32);
-}
-for (i = 0; i < 3; i++) {
-	fifo_vector_xyz.yas537_vector_xyz[i] -=
-	fifo_vector_xyz.yas537_vector_xyz[i] % 10;
-	if (v_over_flow_u8 & (1 <<
-	(i * 2)))
-		fifo_vector_xyz.yas537_vector_xyz[i] +=
-		1; /* set overflow */
-	if (v_over_flow_u8 & (1 << (i * 2 + 1)))
-		/* set underflow */
-		fifo_vector_xyz.yas537_vector_xyz[i] += 2;
-}
-if (v_busy_u8)
-	return ERROR;
-switch (yas537_data.measure_state) {
-case YAS537_MAG_STATE_INIT_COIL:
-	if (p_bmi160->mag_manual_enable != BMI160_MANUAL_ENABLE)
-		com_rslt = bmi160_set_mag_manual_enable(
-		BMI160_MANUAL_ENABLE);
-	com_rslt += bmi160_set_mag_write_data(YAS537_WRITE_CONFR);
-	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
-	com_rslt += bmi160_set_mag_write_addr(YAS537_REG_CONFR);
-	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
-	yas537_data.measure_state = YAS537_MAG_STATE_RECORD_DATA;
-	if (p_bmi160->mag_manual_enable == BMI160_MANUAL_ENABLE)
-		com_rslt = bmi160_set_mag_manual_enable(
-		BMI160_MANUAL_DISABLE);
-break;
-case YAS537_MAG_STATE_RECORD_DATA:
-	if (v_rcoil_u8)
-		break;
-	yas537_set_vector(yas537_data.last_after_rcoil, a_xy1y2_u16);
-	yas537_data.measure_state = YAS537_MAG_STATE_NORMAL;
-break;
-case YAS537_MAG_STATE_NORMAL:
-	if (BMI160_INIT_VALUE < v_over_flow_u8
-	|| invalid_magnetic_field(a_xy1y2_u16,
-	yas537_data.last_after_rcoil)) {
-		yas537_data.measure_state = YAS537_MAG_STATE_INIT_COIL;
-		for (i = 0; i < 3; i++) {
-			if (!v_over_flow_u8)
-				fifo_vector_xyz.yas537_vector_xyz[i]
-				+= 3;
-		}
-	}
-break;
-}
-
-return com_rslt;
-
-}
-/*!
- *	@brief This function used for reading
- *	bmi160_t structure
- *
- *  @return the reference and values of bmi160_t
- *
- *
-*/
-struct bmi160_t *bmi160_get_ptr(void)
-{
-	return  p_bmi160;
-}
diff --git a/src/bmi160/bosch_bmi160.h b/src/bmi160/bosch_bmi160.h
deleted file mode 100644
index 87ca224..0000000
--- a/src/bmi160/bosch_bmi160.h
+++ /dev/null
@@ -1,12048 +0,0 @@
-/** \mainpage
-*
-****************************************************************************
-* Copyright (C) 2014 Bosch Sensortec GmbH
-*
-* File : bosch_bmi160.h
-*
-* Date : 2014/10/27
-*
-* Revision : 2.0.6 $
-*
-* Usage: Sensor Driver for BMI160 sensor
-*
-****************************************************************************
-*
-* \section License
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*
-*   Redistributions of source code must retain the above copyright
-*   notice, this list of conditions and the following disclaimer.
-*
-*   Redistributions in binary form must reproduce the above copyright
-*   notice, this list of conditions and the following disclaimer in the
-*   documentation and/or other materials provided with the distribution.
-*
-*   Neither the name of the copyright holder nor the names of the
-*   contributors may be used to endorse or promote products derived from
-*   this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
-* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
-* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDER
-* OR CONTRIBUTORS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
-* OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT NOT LIMITED TO,
-* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-* ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
-*
-* The information provided is believed to be accurate and reliable.
-* The copyright holder assumes no responsibility
-* for the consequences of use
-* of such information nor for any infringement of patents or
-* other rights of third parties which may result from its use.
-* No license is granted by implication or otherwise under any patent or
-* patent rights of the copyright holder.
-**************************************************************************/
-
-/*! \file bmi160.hpp
-    \brief BMI160 Sensor Driver Support Header File */
-/* user defined code to be added here ... */
-#ifndef __BMI160_H__
-#define __BMI160_H__
-
-/*!
-* @brief The following definition uses for define the data types
-*
-* @note While porting the API please consider the following
-* @note Please check the version of C standard
-* @note Are you using Linux platform
-*/
-
-/*!
-* @brief For the Linux platform support
-* Please use the types.h for your data types definitions
-*/
-#ifdef	__KERNEL__
-
-#include <linux/types.h>
-/* singed integer type*/
-typedef	int8_t s8;/**< used for signed 8bit */
-typedef	int16_t s16;/**< used for signed 16bit */
-typedef	int32_t s32;/**< used for signed 32bit */
-typedef	int64_t s64;/**< used for signed 64bit */
-
-typedef	u_int8_t u8;/**< used for unsigned 8bit */
-typedef	u_int16_t u16;/**< used for unsigned 16bit */
-typedef	u_int32_t u32;/**< used for unsigned 32bit */
-typedef	u_int64_t u64;/**< used for unsigned 64bit */
-
-
-
-#else /* ! __KERNEL__ */
-/**********************************************************
-* These definition uses for define the C
-* standard version data types
-***********************************************************/
-# if !defined(__STDC_VERSION__)
-
-/************************************************
- * compiler is C11 C standard
-************************************************/
-#if (__STDC_VERSION__ == 201112L)
-
-/************************************************/
-#include <stdint.h>
-/************************************************/
-
-/*unsigned integer types*/
-typedef	uint8_t u8;/**< used for unsigned 8bit */
-typedef	uint16_t u16;/**< used for unsigned 16bit */
-typedef	uint32_t u32;/**< used for unsigned 32bit */
-typedef	uint64_t u64;/**< used for unsigned 64bit */
-
-/*signed integer types*/
-typedef	int8_t s8;/**< used for signed 8bit */
-typedef	int16_t s16;/**< used for signed 16bit */
-typedef	int32_t s32;/**< used for signed 32bit */
-typedef	int64_t s64;/**< used for signed 64bit */
-/************************************************
- * compiler is C99 C standard
-************************************************/
-
-#elif (__STDC_VERSION__ == 199901L)
-
-/* stdint.h is a C99 supported c library.
-which is used to fixed the integer size*/
-/************************************************/
-#include <stdint.h>
-/************************************************/
-
-/*unsigned integer types*/
-typedef	uint8_t u8;/**< used for unsigned 8bit */
-typedef	uint16_t u16;/**< used for unsigned 16bit */
-typedef	uint32_t u32;/**< used for unsigned 32bit */
-typedef	uint64_t u64;/**< used for unsigned 64bit */
-
-/*signed integer types*/
-typedef int8_t s8;/**< used for signed 8bit */
-typedef	int16_t s16;/**< used for signed 16bit */
-typedef	int32_t s32;/**< used for signed 32bit */
-typedef	int64_t s64;/**< used for signed 64bit */
-/************************************************
- * compiler is C89 or other C standard
-************************************************/
-
-#else /*  !defined(__STDC_VERSION__) */
-/*!
-* @brief By default it is defined as 32 bit machine configuration
-*	define your data types based on your
-*	machine/compiler/controller configuration
-*/
-#define  MACHINE_32_BIT
-
-/*! @brief
- *	If your machine support 16 bit
- *	define the MACHINE_16_BIT
- */
-#ifdef MACHINE_16_BIT
-#include <limits.h>
-/*signed integer types*/
-typedef	signed char  s8;/**< used for signed 8bit */
-typedef	signed short int s16;/**< used for signed 16bit */
-typedef	signed long int s32;/**< used for signed 32bit */
-
-#if defined(LONG_MAX) && LONG_MAX == 0x7fffffffffffffffL
-typedef long int s64;/**< used for signed 64bit */
-typedef unsigned long int u64;/**< used for unsigned 64bit */
-#elif defined(LLONG_MAX) && (LLONG_MAX == 0x7fffffffffffffffLL)
-typedef long long int s64;/**< used for signed 64bit */
-typedef unsigned long long int u64;/**< used for unsigned 64bit */
-#else
-#warning Either the correct data type for signed 64 bit integer \
-could not be found, or 64 bit integers are not supported in your environment.
-#warning If 64 bit integers are supported on your platform, \
-please set s64 manually.
-#endif
-
-/*unsigned integer types*/
-typedef	unsigned char u8;/**< used for unsigned 8bit */
-typedef	unsigned short int u16;/**< used for unsigned 16bit */
-typedef	unsigned long int u32;/**< used for unsigned 32bit */
-
-/* If your machine support 32 bit
-define the MACHINE_32_BIT*/
-#elif defined MACHINE_32_BIT
-/*signed integer types*/
-typedef	signed char  s8;/**< used for signed 8bit */
-typedef	signed short int s16;/**< used for signed 16bit */
-typedef	signed int s32;/**< used for signed 32bit */
-typedef	signed long long int s64;/**< used for signed 64bit */
-
-/*unsigned integer types*/
-typedef	unsigned char u8;/**< used for unsigned 8bit */
-typedef	unsigned short int u16;/**< used for unsigned 16bit */
-typedef	unsigned int u32;/**< used for unsigned 32bit */
-typedef	unsigned long long int u64;/**< used for unsigned 64bit */
-
-/* If your machine support 64 bit
-define the MACHINE_64_BIT*/
-#elif defined MACHINE_64_BIT
-/*signed integer types*/
-typedef	signed char  s8;/**< used for signed 8bit */
-typedef	signed short int s16;/**< used for signed 16bit */
-typedef	signed int s32;/**< used for signed 32bit */
-typedef	signed long int s64;/**< used for signed 64bit */
-
-/*unsigned integer types*/
-typedef	unsigned char u8;/**< used for unsigned 8bit */
-typedef	unsigned short int u16;/**< used for unsigned 16bit */
-typedef	unsigned int u32;/**< used for unsigned 32bit */
-typedef	unsigned long int u64;/**< used for unsigned 64bit */
-
-#else
-#warning The data types defined above which not supported \
-define the data types manually
-#endif
-#endif
-
-/*** This else will execute for the compilers
- *	which are not supported the C standards
- *	Like C89/C99/C11***/
-#else
-/*!
-* @brief By default it is defined as 32 bit machine configuration
-*	define your data types based on your
-*	machine/compiler/controller configuration
-*/
-#define  MACHINE_32_BIT
-
-/* If your machine support 16 bit
-define the MACHINE_16_BIT*/
-#ifdef MACHINE_16_BIT
-#include <limits.h>
-/*signed integer types*/
-typedef	signed char  s8;/**< used for signed 8bit */
-typedef	signed short int s16;/**< used for signed 16bit */
-typedef	signed long int s32;/**< used for signed 32bit */
-
-#if defined(LONG_MAX) && LONG_MAX == 0x7fffffffffffffffL
-typedef long int s64;/**< used for signed 64bit */
-typedef unsigned long int u64;/**< used for unsigned 64bit */
-#elif defined(LLONG_MAX) && (LLONG_MAX == 0x7fffffffffffffffLL)
-typedef long long int s64;/**< used for signed 64bit */
-typedef unsigned long long int u64;/**< used for unsigned 64bit */
-#else
-#warning Either the correct data type for signed 64 bit integer \
-could not be found, or 64 bit integers are not supported in your environment.
-#warning If 64 bit integers are supported on your platform, \
-please set s64 manually.
-#endif
-
-/*unsigned integer types*/
-typedef	unsigned char u8;/**< used for unsigned 8bit */
-typedef	unsigned short int u16;/**< used for unsigned 16bit */
-typedef	unsigned long int u32;/**< used for unsigned 32bit */
-
-/*! @brief If your machine support 32 bit
-define the MACHINE_32_BIT*/
-#elif defined MACHINE_32_BIT
-/*signed integer types*/
-typedef	signed char  s8;/**< used for signed 8bit */
-typedef	signed short int s16;/**< used for signed 16bit */
-typedef	signed int s32;/**< used for signed 32bit */
-typedef	signed long long int s64;/**< used for signed 64bit */
-
-/*unsigned integer types*/
-typedef	unsigned char u8;/**< used for unsigned 8bit */
-typedef	unsigned short int u16;/**< used for unsigned 16bit */
-typedef	unsigned int u32;/**< used for unsigned 32bit */
-typedef	unsigned long long int u64;/**< used for unsigned 64bit */
-
-/* If your machine support 64 bit
-define the MACHINE_64_BIT*/
-#elif defined MACHINE_64_BIT
-/*signed integer types*/
-typedef	signed char  s8;/**< used for signed 8bit */
-typedef	signed short int s16;/**< used for signed 16bit */
-typedef	signed int s32;/**< used for signed 32bit */
-typedef	signed long int s64;/**< used for signed 64bit */
-
-/*unsigned integer types*/
-typedef	unsigned char u8;/**< used for unsigned 8bit */
-typedef	unsigned short int u16;/**< used for unsigned 16bit */
-typedef	unsigned int u32;/**< used for unsigned 32bit */
-typedef	unsigned long int u64;/**< used for unsigned 64bit */
-
-#else
-#warning The data types defined above which not supported \
-define the data types manually
-#endif
-#endif
-#endif
-/***************************************************************/
-/**\name	BUS READ AND WRITE FUNCTION POINTERS        */
-/***************************************************************/
-/*!
-	@brief Define the calling convention of YOUR bus communication routine.
-	@note This includes types of parameters. This example shows the
-	configuration for an SPI bus link.
-
-    If your communication function looks like this:
-
-    write_my_bus_xy(u8 device_addr, u8 register_addr,
-    u8 * data, u8 length);
-
-    The BMI160_WR_FUNC_PTR would equal:
-
-    BMI160_WR_FUNC_PTR s8 (* bus_write)(u8,
-    u8, u8 *, u8)
-
-    Parameters can be mixed as needed refer to the
-    @ref BMI160_BUS_WRITE_FUNC  macro.
-
-
-*/
-#define BMI160_WR_FUNC_PTR s8 (*bus_write)(u8, u8,\
-u8 *, u8)
-/**< link macro between API function calls and bus write function
-	@note The bus write function can change since this is a
-	system dependant issue.
-
-    If the bus_write parameter calling order is like: reg_addr,
-    reg_data, wr_len it would be as it is here.
-
-    If the parameters are differently ordered or your communication
-    function like I2C need to know the device address,
-    you can change this macro accordingly.
-
-
-    BMI160_BUS_WRITE_FUNC(dev_addr, reg_addr, reg_data, wr_len)\
-    bus_write(dev_addr, reg_addr, reg_data, wr_len)
-
-    This macro lets all API functions call YOUR communication routine in a
-    way that equals your definition in the
-    @ref BMI160_WR_FUNC_PTR definition.
-
-*/
-#define BMI160_BUS_WRITE_FUNC(dev_addr, reg_addr, reg_data, wr_len)\
-				bus_write(dev_addr, reg_addr, reg_data, wr_len)
-
-/**< Define the calling convention of YOUR bus communication routine.
-	@note This includes types of parameters. This example shows the
-	configuration for an SPI bus link.
-
-    If your communication function looks like this:
-
-    read_my_bus_xy(u8 device_addr, u8 register_addr,
-    u8 * data, u8 length);
-
-    The BMI160_RD_FUNC_PTR would equal:
-
-    BMI160_RD_FUNC_PTR s8 (* bus_read)(u8,
-    u8, u8 *, u8)
-
-    Parameters can be mixed as needed refer to the
-    refer BMI160_BUS_READ_FUNC  macro.
-
-*/
-#define BMI160_SPI_RD_MASK (0x80)   /* for spi read transactions on SPI the
-			MSB has to be set */
-#define BMI160_RD_FUNC_PTR s8 (*bus_read)(u8,\
-			u8, u8 *, u8)
-
-#define BMI160_BRD_FUNC_PTR s8 \
-(*burst_read)(u8, u8, u8 *, u32)
-
-/**< link macro between API function calls and bus read function
-	@note The bus write function can change since this is a
-	system dependant issue.
-
-    If the bus_read parameter calling order is like: reg_addr,
-    reg_data, wr_len it would be as it is here.
-
-    If the parameters are differently ordered or your communication
-    function like I2C need to know the device address,
-    you can change this macro accordingly.
-
-
-    BMI160_BUS_READ_FUNC(dev_addr, reg_addr, reg_data, wr_len)\
-    bus_read(dev_addr, reg_addr, reg_data, wr_len)
-
-    This macro lets all API functions call YOUR communication routine in a
-    way that equals your definition in the
-    refer BMI160_WR_FUNC_PTR definition.
-
-    @note: this macro also includes the "MSB='1'
-    for reading BMI160 addresses.
-
-*/
-#define BMI160_BUS_READ_FUNC(dev_addr, reg_addr, reg_data, r_len)\
-				bus_read(dev_addr, reg_addr, reg_data, r_len)
-
-#define BMI160_BURST_READ_FUNC(device_addr, \
-register_addr, register_data, rd_len)\
-burst_read(device_addr, register_addr, register_data, rd_len)
-
-
-#define BMI160_MDELAY_DATA_TYPE                 u32
-
-/***************************************************************/
-/**\name	BUS READ AND WRITE FUNCTION POINTERS        */
-/***************************************************************/
-#define BMI160_I2C_ADDR1                   (0x68)
-/**< I2C Address needs to be changed */
-#define BMI160_I2C_ADDR2                    (0x69)
- /**< I2C Address needs to be changed */
-#define BMI160_AUX_BMM150_I2C_ADDRESS       (0x10)
-/**< I2C address of BMM150*/
-#define BMI160_AUX_YAS532_I2C_ADDRESS       (0x2E)
-/**< I2C address of YAS532*/
-#define	BMI160_AUX_AKM09911_I2C_ADDR_1		(0x0C)
-/**< I2C address of AKM09911*/
-#define	BMI160_AUX_AKM09911_I2C_ADDR_2		(0x0D)
-/**< I2C address of AKM09911*/
-#define	BMI160_AUX_AKM09912_I2C_ADDR_1		(0x0C)
-/**< I2C address of AKM09912*/
-#define	BMI160_AUX_AKM09912_I2C_ADDR_2		(0x0D)
-/**< I2C address of AKM09912*/
-#define	BMI160_AUX_AKM09912_I2C_ADDR_3		(0x0E)
-/**< I2C address of AKM09912*/
-#define	BMI160_AUX_AKM09912_I2C_ADDR_4		(0x0F)
-/**< I2C address of AKM09912*/
-/*******************************************/
-/**\name	CONSTANTS        */
-/******************************************/
-#define  BMI160_INIT_VALUE					(0)
-#define  BMI160_ASSIGN_DATA                 (1)
-#define  BMI160_GEN_READ_WRITE_DATA_LENGTH	(1)
-#define  BMI160_MAXIMUM_TIMEOUT             (10)
-
-/* output data rate condition check*/
-#define  BMI160_OUTPUT_DATA_RATE0	(0)
-#define  BMI160_OUTPUT_DATA_RATE1	(1)
-#define  BMI160_OUTPUT_DATA_RATE2	(2)
-#define  BMI160_OUTPUT_DATA_RATE3	(3)
-#define  BMI160_OUTPUT_DATA_RATE4	(4)
-#define  BMI160_OUTPUT_DATA_RATE5	(5)
-#define  BMI160_OUTPUT_DATA_RATE6	(14)
-#define  BMI160_OUTPUT_DATA_RATE7	(15)
-
-/* accel range check*/
-#define BMI160_ACCEL_RANGE0  (3)
-#define BMI160_ACCEL_RANGE1  (5)
-#define BMI160_ACCEL_RANGE3  (8)
-#define BMI160_ACCEL_RANGE4  (12)
-
-/* check the status of registers*/
-#define  BMI160_FOC_STAT_HIGH			(1)
-#define  BMI160_SIG_MOTION_STAT_HIGH	(1)
-#define  BMI160_STEP_DET_STAT_HIGH		(1)
-
-/*condition check for reading and writing data*/
-#define	BMI160_MAX_VALUE_SIGNIFICANT_MOTION      (1)
-#define	BMI160_MAX_VALUE_FIFO_FILTER    (1)
-#define	BMI160_MAX_VALUE_FIFO_TIME      (1)
-#define	BMI160_MAX_VALUE_FIFO_INTR      (1)
-#define	BMI160_MAX_VALUE_FIFO_HEADER    (1)
-#define	BMI160_MAX_VALUE_FIFO_MAG       (1)
-#define	BMI160_MAX_VALUE_FIFO_ACCEL     (1)
-#define	BMI160_MAX_VALUE_FIFO_GYRO      (1)
-#define	BMI160_MAX_VALUE_SOURCE_INTR    (1)
-#define	BMI160_MAX_VALUE_LOW_G_MODE     (1)
-#define	BMI160_MAX_VALUE_NO_MOTION      (1)
-#define	BMI160_MAX_VALUE_TAP_SHOCK      (1)
-#define	BMI160_MAX_VALUE_TAP_QUIET      (1)
-#define	BMI160_MAX_VALUE_ORIENT_UD      (1)
-#define	BMI160_MAX_VALUE_ORIENT_AXES    (1)
-#define	BMI160_MAX_VALUE_NVM_PROG       (1)
-#define	BMI160_MAX_VALUE_SPI3           (1)
-#define	BMI160_MAX_VALUE_PAGE           (1)
-#define	BMI160_MAX_VALUE_I2C_WDT        (1)
-#define	BMI160_MAX_VALUE_SLEEP_STATE    (1)
-#define	BMI160_MAX_VALUE_WAKEUP_INTR    (1)
-#define	BMI160_MAX_VALUE_SELFTEST_SIGN  (1)
-#define	BMI160_MAX_VALUE_SELFTEST_AMP   (1)
-#define	BMI160_MAX_VALUE_SELFTEST_START (1)
-
-#define BMI160_MAX_GYRO_WAKEUP_TRIGGER		(3)
-#define BMI160_MAX_ACCEL_SELFTEST_AXIS	    (3)
-#define BMI160_MAX_GYRO_STEP_COUNTER        (1)
-#define BMI160_MAX_GYRO_BW                  (3)
-#define BMI160_MAX_ACCEL_BW                 (7)
-#define BMI160_MAX_ORIENT_MODE              (3)
-#define BMI160_MAX_ORIENT_BLOCKING          (3)
-#define BMI160_MAX_FLAT_HOLD                (3)
-#define BMI160_MAX_ACCEL_FOC                (3)
-#define BMI160_MAX_IF_MODE                  (3)
-#define BMI160_MAX_TARGET_PAGE              (3)
-#define BMI160_MAX_GYRO_RANGE               (4)
-#define BMI160_MAX_GYRO_SLEEP_TIGGER        (7)
-#define BMI160_MAX_TAP_TURN                 (7)
-#define BMI160_MAX_UNDER_SAMPLING           (1)
-#define BMI160_MAX_UNDER_SIG_MOTION         (3)
-#define BMI160_MAX_ACCEL_OUTPUT_DATA_RATE   (12)
-#define BMI160_MAX_LATCH_INTR               (15)
-#define BMI160_MAX_FLAT_HYST                (15)
-#define BMI160_MAX_ORIENT_THETA             (63)
-#define BMI160_MAX_FLAT_THETA               (63)
-
-/* FIFO index definitions*/
-#define BMI160_FIFO_X_LSB_DATA			(0)
-#define BMI160_FIFO_X_MSB_DATA			(1)
-#define BMI160_FIFO_Y_LSB_DATA			(2)
-#define BMI160_FIFO_Y_MSB_DATA			(3)
-#define BMI160_FIFO_Z_LSB_DATA			(4)
-#define BMI160_FIFO_Z_MSB_DATA			(5)
-#define BMI160_FIFO_R_LSB_DATA			(6)
-#define BMI160_FIFO_R_MSB_DATA			(7)
-/* FIFO gyro definition*/
-#define BMI160_GA_FIFO_G_X_LSB		(0)
-#define BMI160_GA_FIFO_G_X_MSB		(1)
-#define BMI160_GA_FIFO_G_Y_LSB		(2)
-#define BMI160_GA_FIFO_G_Y_MSB		(3)
-#define BMI160_GA_FIFO_G_Z_LSB		(4)
-#define BMI160_GA_FIFO_G_Z_MSB		(5)
-#define BMI160_GA_FIFO_A_X_LSB		(6)
-#define BMI160_GA_FIFO_A_X_MSB		(7)
-#define BMI160_GA_FIFO_A_Y_LSB		(8)
-#define BMI160_GA_FIFO_A_Y_MSB		(9)
-#define BMI160_GA_FIFO_A_Z_LSB		(10)
-#define BMI160_GA_FIFO_A_Z_MSB		(11)
-/* FIFO mag/gyro/accel definition*/
-#define BMI160_MGA_FIFO_M_X_LSB		(0)
-#define BMI160_MGA_FIFO_M_X_MSB		(1)
-#define BMI160_MGA_FIFO_M_Y_LSB		(2)
-#define BMI160_MGA_FIFO_M_Y_MSB		(3)
-#define BMI160_MGA_FIFO_M_Z_LSB		(4)
-#define BMI160_MGA_FIFO_M_Z_MSB		(5)
-#define BMI160_MGA_FIFO_M_R_LSB		(6)
-#define BMI160_MGA_FIFO_M_R_MSB		(7)
-#define BMI160_MGA_FIFO_G_X_LSB		(8)
-#define BMI160_MGA_FIFO_G_X_MSB		(9)
-#define BMI160_MGA_FIFO_G_Y_LSB		(10)
-#define BMI160_MGA_FIFO_G_Y_MSB		(11)
-#define BMI160_MGA_FIFO_G_Z_LSB		(12)
-#define BMI160_MGA_FIFO_G_Z_MSB		(13)
-#define BMI160_MGA_FIFO_A_X_LSB		(14)
-#define BMI160_MGA_FIFO_A_X_MSB		(15)
-#define BMI160_MGA_FIFO_A_Y_LSB		(16)
-#define BMI160_MGA_FIFO_A_Y_MSB		(17)
-#define BMI160_MGA_FIFO_A_Z_LSB		(18)
-#define BMI160_MGA_FIFO_A_Z_MSB		(19)
-/* FIFO mag definition*/
-#define BMI160_MA_FIFO_M_X_LSB		(0)
-#define BMI160_MA_FIFO_M_X_MSB		(1)
-#define BMI160_MA_FIFO_M_Y_LSB		(2)
-#define BMI160_MA_FIFO_M_Y_MSB		(3)
-#define BMI160_MA_FIFO_M_Z_LSB		(4)
-#define BMI160_MA_FIFO_M_Z_MSB		(5)
-#define BMI160_MA_FIFO_M_R_LSB		(6)
-#define BMI160_MA_FIFO_M_R_MSB		(7)
-#define BMI160_MA_FIFO_A_X_LSB		(8)
-#define BMI160_MA_FIFO_A_X_MSB		(9)
-#define BMI160_MA_FIFO_A_Y_LSB		(10)
-#define BMI160_MA_FIFO_A_Y_MSB		(11)
-#define BMI160_MA_FIFO_A_Z_LSB		(12)
-#define BMI160_MA_FIFO_A_Z_MSB		(13)
-/* FIFO mag/gyro definition*/
-#define BMI160_MG_FIFO_M_X_LSB		(0)
-#define BMI160_MG_FIFO_M_X_MSB		(1)
-#define BMI160_MG_FIFO_M_Y_LSB		(2)
-#define BMI160_MG_FIFO_M_Y_MSB		(3)
-#define BMI160_MG_FIFO_M_Z_LSB		(4)
-#define BMI160_MG_FIFO_M_Z_MSB		(5)
-#define BMI160_MG_FIFO_M_R_LSB		(6)
-#define BMI160_MG_FIFO_M_R_MSB		(7)
-#define BMI160_MG_FIFO_G_X_LSB		(8)
-#define BMI160_MG_FIFO_G_X_MSB		(9)
-#define BMI160_MG_FIFO_G_Y_LSB		(10)
-#define BMI160_MG_FIFO_G_Y_MSB		(11)
-#define BMI160_MG_FIFO_G_Z_LSB		(12)
-#define BMI160_MG_FIFO_G_Z_MSB		(13)
-/* FIFO length definitions*/
-#define BMI160_FIFO_SENSOR_TIME_LSB     (0)
-#define BMI160_FIFO_SENSOR_TIME_XLSB    (1)
-#define BMI160_FIFO_SENSOR_TIME_MSB     (2)
-#define BMI160_FIFO_SENSOR_TIME_LENGTH  (3)
-#define BMI160_FIFO_A_LENGTH            (6)
-#define BMI160_FIFO_G_LENGTH            (6)
-#define BMI160_FIFO_M_LENGTH            (8)
-#define BMI160_FIFO_AG_LENGTH           (12)
-#define BMI160_FIFO_AMG_LENGTH          (20)
-#define BMI160_FIFO_MA_OR_MG_LENGTH     (14)
-
-/* bus read and write length for mag, accel and gyro*/
-#define BMI160_MAG_X_DATA_LENGTH     (2)
-#define BMI160_MAG_Y_DATA_LENGTH     (2)
-#define BMI160_MAG_Z_DATA_LENGTH     (2)
-#define BMI160_MAG_R_DATA_LENGTH     (2)
-#define BMI160_MAG_XYZ_DATA_LENGTH	 (6)
-#define BMI160_MAG_XYZR_DATA_LENGTH	 (8)
-#define BMI160_MAG_YAS_DATA_LENGTH	 (8)
-#define BMI160_GYRO_DATA_LENGTH		 (2)
-#define BMI160_GYRO_XYZ_DATA_LENGTH	 (6)
-#define BMI160_ACCEL_DATA_LENGTH	 (2)
-#define BMI160_ACCEL_XYZ_DATA_LENGTH (6)
-#define BMI160_TEMP_DATA_LENGTH		 (2)
-#define BMI160_FIFO_DATA_LENGTH		 (2)
-#define BMI160_STEP_COUNTER_LENGTH	 (2)
-#define BMI160_SENSOR_TIME_LENGTH	 (3)
-
-/* Delay definitions*/
-#define BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY    (5)
-#define BMI160_BMM150_WAKEUP_DELAY1                  (2)
-#define BMI160_BMM150_WAKEUP_DELAY2                  (3)
-#define BMI160_BMM150_WAKEUP_DELAY3                  (1)
-#define BMI160_YAS532_OFFSET_DELAY                   (2)
-#define BMI160_GEN_READ_WRITE_DELAY                  (1)
-#define BMI160_YAS532_MEASUREMENT_DELAY              (25)
-#define BMI160_YAS_ACQ_COMMAND_DELAY                 (50)
-#define BMI160_YAS532_SET_INITIAL_VALUE_DELAY        (200)
-#define BMI160_AKM_INIT_DELAY                        (60)
-/****************************************************/
-/**\name	ARRAY SIZE DEFINITIONS      */
-/***************************************************/
-#define	BMI160_ACCEL_X_DATA_SIZE   (2)
-#define	BMI160_ACCEL_Y_DATA_SIZE   (2)
-#define	BMI160_ACCEL_Z_DATA_SIZE   (2)
-#define	BMI160_ACCEL_XYZ_DATA_SIZE (6)
-
-#define	BMI160_GYRO_X_DATA_SIZE    (2)
-#define	BMI160_GYRO_Y_DATA_SIZE    (2)
-#define	BMI160_GYRO_Z_DATA_SIZE    (2)
-#define	BMI160_GYRO_XYZ_DATA_SIZE  (6)
-
-#define	BMI160_MAG_X_DATA_SIZE      (2)
-#define	BMI160_MAG_Y_DATA_SIZE      (2)
-#define	BMI160_MAG_Z_DATA_SIZE      (2)
-#define	BMI160_MAG_R_DATA_SIZE      (2)
-#define	BMI160_MAG_XYZ_DATA_SIZE    (6)
-#define	BMI160_MAG_XYZR_DATA_SIZE   (8)
-#define	BMI160_MAG_TRIM_DATA_SIZE   (16)
-
-
-#define	BMI160_TEMP_DATA_SIZE       (2)
-#define	BMI160_FIFO_DATA_SIZE       (2)
-#define	BMI160_STEP_COUNT_DATA_SIZE (2)
-
-#define	BMI160_SENSOR_TIME_DATA_SIZE      (3)
-#define	BMI160_AKM_SENSITIVITY_DATA_SIZE  (3)
-#define	BMI160_HARD_OFFSET_DATA_SIZE      (3)
-#define	BMI160_YAS_XY1Y2_DATA_SIZE        (3)
-#define	BMI160_YAS_FLAG_DATA_SIZE         (3)
-#define	BMI160_YAS_TEMP_DATA_SIZE         (3)
-#define	BMI160_YAS_H_DATA_SIZE            (3)
-#define	BMI160_YAS_S_DATA_SIZE            (3)
-#define BMI160_YAS_CORRECT_DATA_SIZE      (5)
-#define BMI160_YAS_XY1Y2T_DATA_SIZE       (8)
-#define BMI160_YAS537_CALIB_DATA_SIZE     (17)
-#define BMI160_YAS532_CALIB_DATA_SIZE     (14)
-
-/****************************************************/
-/**\name	ARRAY PARAMETER DEFINITIONS      */
-/***************************************************/
-#define BMI160_SENSOR_TIME_MSB_BYTE   (2)
-#define BMI160_SENSOR_TIME_XLSB_BYTE  (1)
-#define BMI160_SENSOR_TIME_LSB_BYTE   (0)
-
-#define BMI160_MAG_X_LSB_BYTE	          (0)
-#define BMI160_MAG_X_MSB_BYTE              (1)
-#define BMI160_MAG_Y_LSB_BYTE	           (0)
-#define BMI160_MAG_Y_MSB_BYTE              (1)
-#define BMI160_MAG_Z_LSB_BYTE	           (0)
-#define BMI160_MAG_Z_MSB_BYTE              (1)
-#define BMI160_MAG_R_LSB_BYTE	           (0)
-#define BMI160_MAG_R_MSB_BYTE              (1)
-#define BMI160_DATA_FRAME_MAG_X_LSB_BYTE   (0)
-#define BMI160_DATA_FRAME_MAG_X_MSB_BYTE   (1)
-#define BMI160_DATA_FRAME_MAG_Y_LSB_BYTE   (2)
-#define BMI160_DATA_FRAME_MAG_Y_MSB_BYTE   (3)
-#define BMI160_DATA_FRAME_MAG_Z_LSB_BYTE   (4)
-#define BMI160_DATA_FRAME_MAG_Z_MSB_BYTE   (5)
-#define BMI160_DATA_FRAME_MAG_R_LSB_BYTE   (6)
-#define BMI160_DATA_FRAME_MAG_R_MSB_BYTE   (7)
-
-#define BMI160_GYRO_X_LSB_BYTE              (0)
-#define BMI160_GYRO_X_MSB_BYTE              (1)
-#define BMI160_GYRO_Y_LSB_BYTE              (0)
-#define BMI160_GYRO_Y_MSB_BYTE              (1)
-#define BMI160_GYRO_Z_LSB_BYTE              (0)
-#define BMI160_GYRO_Z_MSB_BYTE              (1)
-#define BMI160_DATA_FRAME_GYRO_X_LSB_BYTE   (0)
-#define BMI160_DATA_FRAME_GYRO_X_MSB_BYTE   (1)
-#define BMI160_DATA_FRAME_GYRO_Y_LSB_BYTE   (2)
-#define BMI160_DATA_FRAME_GYRO_Y_MSB_BYTE   (3)
-#define BMI160_DATA_FRAME_GYRO_Z_LSB_BYTE   (4)
-#define BMI160_DATA_FRAME_GYRO_Z_MSB_BYTE   (5)
-
-#define BMI160_ACCEL_X_LSB_BYTE              (0)
-#define BMI160_ACCEL_X_MSB_BYTE              (1)
-#define BMI160_ACCEL_Y_LSB_BYTE              (0)
-#define BMI160_ACCEL_Y_MSB_BYTE              (1)
-#define BMI160_ACCEL_Z_LSB_BYTE              (0)
-#define BMI160_ACCEL_Z_MSB_BYTE              (1)
-#define BMI160_DATA_FRAME_ACCEL_X_LSB_BYTE   (0)
-#define BMI160_DATA_FRAME_ACCEL_X_MSB_BYTE   (1)
-#define BMI160_DATA_FRAME_ACCEL_Y_LSB_BYTE   (2)
-#define BMI160_DATA_FRAME_ACCEL_Y_MSB_BYTE   (3)
-#define BMI160_DATA_FRAME_ACCEL_Z_LSB_BYTE   (4)
-#define BMI160_DATA_FRAME_ACCEL_Z_MSB_BYTE   (5)
-
-#define	BMI160_TEMP_LSB_BYTE    (0)
-#define	BMI160_TEMP_MSB_BYTE    (1)
-
-#define	BMI160_FIFO_LENGTH_LSB_BYTE    (0)
-#define	BMI160_FIFO_LENGTH_MSB_BYTE    (1)
-
-#define	BMI160_STEP_COUNT_LSB_BYTE    (0)
-#define	BMI160_STEP_COUNT_MSB_BYTE    (1)
-/****************************************************/
-/**\name	ERROR CODES       */
-/***************************************************/
-
-#define E_BMI160_NULL_PTR			((s8)-127)
-#define E_BMI160_COMM_RES			((s8)-1)
-#define E_BMI160_OUT_OF_RANGE		((s8)-2)
-#define E_BMI160_BUSY				((s8)-3)
-#define	SUCCESS						((u8)0)
-#define	ERROR						((s8)-1)
-
-/* Constants */
-#define BMI160_NULL						(0)
-#define BMI160_DELAY_SETTLING_TIME		(5)
-/*This refers BMI160 return type as s8 */
-#define BMI160_RETURN_FUNCTION_TYPE		s8
-/****************************************************/
-/**\name	REGISTER DEFINITIONS       */
-/***************************************************/
-/*******************/
-/**\name CHIP ID */
-/*******************/
-#define BMI160_USER_CHIP_ID_ADDR				(0x00)
-/*******************/
-/**\name ERROR STATUS */
-/*******************/
-#define BMI160_USER_ERROR_ADDR					(0X02)
-/*******************/
-/**\name POWER MODE STATUS */
-/*******************/
-#define BMI160_USER_PMU_STAT_ADDR				(0X03)
-/*******************/
-/**\name MAG DATA REGISTERS */
-/*******************/
-#define BMI160_USER_DATA_0_ADDR					(0X04)
-#define BMI160_USER_DATA_1_ADDR					(0X05)
-#define BMI160_USER_DATA_2_ADDR					(0X06)
-#define BMI160_USER_DATA_3_ADDR					(0X07)
-#define BMI160_USER_DATA_4_ADDR					(0X08)
-#define BMI160_USER_DATA_5_ADDR					(0X09)
-#define BMI160_USER_DATA_6_ADDR					(0X0A)
-#define BMI160_USER_DATA_7_ADDR					(0X0B)
-/*******************/
-/**\name GYRO DATA REGISTERS */
-/*******************/
-#define BMI160_USER_DATA_8_ADDR					(0X0C)
-#define BMI160_USER_DATA_9_ADDR					(0X0D)
-#define BMI160_USER_DATA_10_ADDR				(0X0E)
-#define BMI160_USER_DATA_11_ADDR				(0X0F)
-#define BMI160_USER_DATA_12_ADDR				(0X10)
-#define BMI160_USER_DATA_13_ADDR				(0X11)
-#define BMI160_USER_DATA_14_ADDR				(0X12)
-#define BMI160_USER_DATA_15_ADDR				(0X13)
-/*******************/
-/**\name ACCEL DATA REGISTERS */
-/*******************/
-#define BMI160_USER_DATA_16_ADDR				(0X14)
-#define BMI160_USER_DATA_17_ADDR				(0X15)
-#define BMI160_USER_DATA_18_ADDR				(0X16)
-#define BMI160_USER_DATA_19_ADDR				(0X17)
-/*******************/
-/**\name SENSOR TIME REGISTERS */
-/*******************/
-#define BMI160_USER_SENSORTIME_0_ADDR			(0X18)
-#define BMI160_USER_SENSORTIME_1_ADDR			(0X19)
-#define BMI160_USER_SENSORTIME_2_ADDR			(0X1A)
-/*******************/
-/**\name STATUS REGISTER FOR SENSOR STATUS FLAG */
-/*******************/
-#define BMI160_USER_STAT_ADDR					(0X1B)
-/*******************/
-/**\name INTERRUPY STATUS REGISTERS */
-/*******************/
-#define BMI160_USER_INTR_STAT_0_ADDR			(0X1C)
-#define BMI160_USER_INTR_STAT_1_ADDR			(0X1D)
-#define BMI160_USER_INTR_STAT_2_ADDR			(0X1E)
-#define BMI160_USER_INTR_STAT_3_ADDR			(0X1F)
-/*******************/
-/**\name TEMPERATURE REGISTERS */
-/*******************/
-#define BMI160_USER_TEMPERATURE_0_ADDR			(0X20)
-#define BMI160_USER_TEMPERATURE_1_ADDR			(0X21)
-/*******************/
-/**\name FIFO REGISTERS */
-/*******************/
-#define BMI160_USER_FIFO_LENGTH_0_ADDR			(0X22)
-#define BMI160_USER_FIFO_LENGTH_1_ADDR			(0X23)
-#define BMI160_USER_FIFO_DATA_ADDR				(0X24)
-/***************************************************/
-/**\name ACCEL CONFIG REGISTERS  FOR ODR, BANDWIDTH AND UNDERSAMPLING*/
-/******************************************************/
-#define BMI160_USER_ACCEL_CONFIG_ADDR			(0X40)
-/*******************/
-/**\name ACCEL RANGE */
-/*******************/
-#define BMI160_USER_ACCEL_RANGE_ADDR            (0X41)
-/***************************************************/
-/**\name GYRO CONFIG REGISTERS  FOR ODR AND BANDWIDTH */
-/******************************************************/
-#define BMI160_USER_GYRO_CONFIG_ADDR            (0X42)
-/*******************/
-/**\name GYRO RANGE */
-/*******************/
-#define BMI160_USER_GYRO_RANGE_ADDR             (0X43)
-/***************************************************/
-/**\name MAG CONFIG REGISTERS  FOR ODR*/
-/******************************************************/
-#define BMI160_USER_MAG_CONFIG_ADDR				(0X44)
-/***************************************************/
-/**\name REGISTER FOR GYRO AND ACCEL DOWNSAMPLING RATES FOR FIFO*/
-/******************************************************/
-#define BMI160_USER_FIFO_DOWN_ADDR              (0X45)
-/***************************************************/
-/**\name FIFO CONFIG REGISTERS*/
-/******************************************************/
-#define BMI160_USER_FIFO_CONFIG_0_ADDR          (0X46)
-#define BMI160_USER_FIFO_CONFIG_1_ADDR          (0X47)
-/***************************************************/
-/**\name MAG INTERFACE REGISTERS*/
-/******************************************************/
-#define BMI160_USER_MAG_IF_0_ADDR				(0X4B)
-#define BMI160_USER_MAG_IF_1_ADDR				(0X4C)
-#define BMI160_USER_MAG_IF_2_ADDR				(0X4D)
-#define BMI160_USER_MAG_IF_3_ADDR				(0X4E)
-#define BMI160_USER_MAG_IF_4_ADDR				(0X4F)
-/***************************************************/
-/**\name INTERRUPT ENABLE REGISTERS*/
-/******************************************************/
-#define BMI160_USER_INTR_ENABLE_0_ADDR			(0X50)
-#define BMI160_USER_INTR_ENABLE_1_ADDR			(0X51)
-#define BMI160_USER_INTR_ENABLE_2_ADDR			(0X52)
-#define BMI160_USER_INTR_OUT_CTRL_ADDR			(0X53)
-/***************************************************/
-/**\name LATCH DURATION REGISTERS*/
-/******************************************************/
-#define BMI160_USER_INTR_LATCH_ADDR				(0X54)
-/***************************************************/
-/**\name MAP INTERRUPT 1 and 2 REGISTERS*/
-/******************************************************/
-#define BMI160_USER_INTR_MAP_0_ADDR				(0X55)
-#define BMI160_USER_INTR_MAP_1_ADDR				(0X56)
-#define BMI160_USER_INTR_MAP_2_ADDR				(0X57)
-/***************************************************/
-/**\name DATA SOURCE REGISTERS*/
-/******************************************************/
-#define BMI160_USER_INTR_DATA_0_ADDR			(0X58)
-#define BMI160_USER_INTR_DATA_1_ADDR			(0X59)
-/***************************************************/
-/**\name
-INTERRUPT THRESHOLD, HYSTERESIS, DURATION, MODE CONFIGURATION REGISTERS*/
-/******************************************************/
-#define BMI160_USER_INTR_LOWHIGH_0_ADDR			(0X5A)
-#define BMI160_USER_INTR_LOWHIGH_1_ADDR			(0X5B)
-#define BMI160_USER_INTR_LOWHIGH_2_ADDR			(0X5C)
-#define BMI160_USER_INTR_LOWHIGH_3_ADDR			(0X5D)
-#define BMI160_USER_INTR_LOWHIGH_4_ADDR			(0X5E)
-#define BMI160_USER_INTR_MOTION_0_ADDR			(0X5F)
-#define BMI160_USER_INTR_MOTION_1_ADDR			(0X60)
-#define BMI160_USER_INTR_MOTION_2_ADDR			(0X61)
-#define BMI160_USER_INTR_MOTION_3_ADDR			(0X62)
-#define BMI160_USER_INTR_TAP_0_ADDR				(0X63)
-#define BMI160_USER_INTR_TAP_1_ADDR				(0X64)
-#define BMI160_USER_INTR_ORIENT_0_ADDR			(0X65)
-#define BMI160_USER_INTR_ORIENT_1_ADDR			(0X66)
-#define BMI160_USER_INTR_FLAT_0_ADDR			(0X67)
-#define BMI160_USER_INTR_FLAT_1_ADDR			(0X68)
-/***************************************************/
-/**\name FAST OFFSET CONFIGURATION REGISTER*/
-/******************************************************/
-#define BMI160_USER_FOC_CONFIG_ADDR				(0X69)
-/***************************************************/
-/**\name MISCELLANEOUS CONFIGURATION REGISTER*/
-/******************************************************/
-#define BMI160_USER_CONFIG_ADDR					(0X6A)
-/***************************************************/
-/**\name SERIAL INTERFACE SETTINGS REGISTER*/
-/******************************************************/
-#define BMI160_USER_IF_CONFIG_ADDR				(0X6B)
-/***************************************************/
-/**\name GYRO POWER MODE TRIGGER REGISTER */
-/******************************************************/
-#define BMI160_USER_PMU_TRIGGER_ADDR			(0X6C)
-/***************************************************/
-/**\name SELF_TEST REGISTER*/
-/******************************************************/
-#define BMI160_USER_SELF_TEST_ADDR				(0X6D)
-/***************************************************/
-/**\name SPI,I2C SELECTION REGISTER*/
-/******************************************************/
-#define BMI160_USER_NV_CONFIG_ADDR				(0x70)
-/***************************************************/
-/**\name ACCEL AND GYRO OFFSET REGISTERS*/
-/******************************************************/
-#define BMI160_USER_OFFSET_0_ADDR				(0X71)
-#define BMI160_USER_OFFSET_1_ADDR				(0X72)
-#define BMI160_USER_OFFSET_2_ADDR				(0X73)
-#define BMI160_USER_OFFSET_3_ADDR				(0X74)
-#define BMI160_USER_OFFSET_4_ADDR				(0X75)
-#define BMI160_USER_OFFSET_5_ADDR				(0X76)
-#define BMI160_USER_OFFSET_6_ADDR				(0X77)
-/***************************************************/
-/**\name STEP COUNTER INTERRUPT REGISTERS*/
-/******************************************************/
-#define BMI160_USER_STEP_COUNT_0_ADDR			(0X78)
-#define BMI160_USER_STEP_COUNT_1_ADDR			(0X79)
-/***************************************************/
-/**\name STEP COUNTER CONFIGURATION REGISTERS*/
-/******************************************************/
-#define BMI160_USER_STEP_CONFIG_0_ADDR			(0X7A)
-#define BMI160_USER_STEP_CONFIG_1_ADDR			(0X7B)
-/***************************************************/
-/**\name COMMAND REGISTER*/
-/******************************************************/
-#define BMI160_CMD_COMMANDS_ADDR				(0X7E)
-/***************************************************/
-/**\name PAGE REGISTERS*/
-/******************************************************/
-#define BMI160_CMD_EXT_MODE_ADDR				(0X7F)
-#define BMI160_COM_C_TRIM_FIVE_ADDR				(0X05)
-
-/****************************************************/
-/**\name	SHIFT VALUE DEFINITION       */
-/***************************************************/
-#define BMI160_SHIFT_BIT_POSITION_BY_01_BIT      (1)
-#define BMI160_SHIFT_BIT_POSITION_BY_02_BITS     (2)
-#define BMI160_SHIFT_BIT_POSITION_BY_03_BITS     (3)
-#define BMI160_SHIFT_BIT_POSITION_BY_04_BITS     (4)
-#define BMI160_SHIFT_BIT_POSITION_BY_05_BITS     (5)
-#define BMI160_SHIFT_BIT_POSITION_BY_06_BITS     (6)
-#define BMI160_SHIFT_BIT_POSITION_BY_07_BITS     (7)
-#define BMI160_SHIFT_BIT_POSITION_BY_08_BITS     (8)
-#define BMI160_SHIFT_BIT_POSITION_BY_09_BITS     (9)
-#define BMI160_SHIFT_BIT_POSITION_BY_12_BITS     (12)
-#define BMI160_SHIFT_BIT_POSITION_BY_13_BITS     (13)
-#define BMI160_SHIFT_BIT_POSITION_BY_14_BITS     (14)
-#define BMI160_SHIFT_BIT_POSITION_BY_15_BITS     (15)
-#define BMI160_SHIFT_BIT_POSITION_BY_16_BITS     (16)
-
-/****************************************************/
-/**\name	 DEFINITIONS USED FOR YAMAHA-YAS532 */
-/***************************************************/
-#define YAS532_MAG_STATE_NORMAL				(0)
-#define YAS532_MAG_STATE_INIT_COIL			(1)
-#define YAS532_MAG_STATE_MEASURE_OFFSET		(2)
-#define YAS532_MAG_INITCOIL_TIMEOUT			(1000)
-#define YAS532_MAG_NOTRANS_POSITION			(3)
-#define YAS532_DEFAULT_SENSOR_DELAY			(50)
-#define YAS532_DATA_OVERFLOW				(8190)
-#define YAS532_DATA_UNDERFLOW				(0)
-#define YAS532_MAG_TEMPERATURE_LOG			(10)
-#define YAS532_TEMP20DEGREE_TYPICAL			(390)
-#define YAS532_VERSION_AC_COEF_X			(850)
-#define YAS532_VERSION_AC_COEF_Y1			(750)
-#define YAS532_VERSION_AC_COEF_Y2			(750)
-#define YAS532_DATA_CENTER					(4096)
-/****************************************************/
-/**\name	YAMAHA-YAS532 OFFSET DEFINITION */
-/***************************************************/
-static const s8 INVALID_OFFSET[] = {0x7f, 0x7f, 0x7f};
-#define set_vector(to, from) \
-	{int _l; for (_l = 0; _l < 3; _l++) (to)[_l] = (from)[_l]; }
-#define is_valid_offset(a) \
-	(((a)[0] <= 31) && ((a)[1] <= 31) && ((a)[2] <= 31) \
-		&& (-31 <= (a)[0]) && (-31 <= (a)[1]) && (-31 <= (a)[2]))
-
-/**************************************************/
-/**\name	YAS532 CALIB DATA DEFINITIONS  */
-/*************************************************/
-
-
-/* register address of YAS532*/
-#define BMI160_YAS532_TESTR1			(0x88)
-#define BMI160_YAS532_TESTR2			(0x89)
-#define BMI160_YAS532_RCOIL				(0x81)
-#define BMI160_YAS532_COMMAND_REGISTER	(0x82)
-#define BMI160_YAS532_DATA_REGISTER		(0xB0)
-/* calib data register definition*/
-#define BMI160_YAS532_CALIB_CX	        (0x90)
-#define BMI160_YAS532_CALIB_CY1	        (0x91)
-#define BMI160_YAS532_CALIB_CY2	        (0x92)
-#define BMI160_YAS532_CALIB1	        (0x93)
-#define BMI160_YAS532_CALIB2	        (0x94)
-#define BMI160_YAS532_CALIB3	        (0x95)
-#define BMI160_YAS532_CALIB4	        (0x96)
-#define BMI160_YAS532_CALIB5	        (0x97)
-#define BMI160_YAS532_CLAIB6	        (0x98)
-#define BMI160_YAS532_CALIB7	        (0x99)
-#define BMI160_YAS532_CALIB8	        (0x9A)
-#define BMI160_YAS532_CALIIB9	        (0x9B)
-#define BMI160_YAS532_CALIB10	        (0x9C)
-#define BMI160_YAS532_CALIB11	        (0x9D)
-/* offset definition */
-#define BMI160_YAS532_OFFSET_X	        (0x85)
-#define BMI160_YAS532_OFFSET_Y	        (0x86)
-#define BMI160_YAS532_OFFSET_Z	        (0x87)
-/* data to write register for yas532*/
-#define BMI160_YAS532_WRITE_TESTR1	    (0x00)
-#define BMI160_YAS532_WRITE_TESTR2	    (0x00)
-#define BMI160_YAS532_WRITE_RCOIL       (0x00)
-/**************************************************/
-/**\name	YAS537 DEFINITION  */
-/*************************************************/
-
-#define	YAS537_SRSTR_DATA		        (0x02)
-#define	YAS537_WRITE_A_D_CONVERTER		(0x03)
-#define	YAS537_WRITE_A_D_CONVERTER2		(0xF8)
-#define	YAS537_WRITE_FILTER             (0x08)
-#define	YAS537_WRITE_CONFR              (0x08)
-#define	YAS537_WRITE_TEMP_CALIB         (0xFF)
-#define	YAS537_SET_COMMAND_REGISTER     (0x01)
-
-/**************************************************/
-/**\name	YAS537 REGISTER DEFINITION  */
-/*************************************************/
-#define	YAS537_REG_SRSTR				(0x90)
-#define	YAS537_REG_CALR_C0				(0xC0)
-#define	YAS537_REG_CALR_C1				(0xC1)
-#define	YAS537_REG_CALR_C2				(0xC2)
-#define	YAS537_REG_CALR_C3				(0xC3)
-#define	YAS537_REG_CALR_C4				(0xC4)
-#define	YAS537_REG_CALR_C5				(0xC5)
-#define	YAS537_REG_CALR_C6				(0xC6)
-#define	YAS537_REG_CALR_C7				(0xC7)
-#define	YAS537_REG_CALR_C8				(0xC8)
-#define	YAS537_REG_CALR_C9				(0xC9)
-#define	YAS537_REG_CALR_CA				(0xCA)
-#define	YAS537_REG_CALR_CB				(0xCB)
-#define	YAS537_REG_CALR_CC				(0xCC)
-#define	YAS537_REG_CALR_CD				(0xCD)
-#define	YAS537_REG_CALR_CE				(0xCE)
-#define	YAS537_REG_CALR_CF				(0xCF)
-#define	YAS537_REG_CALR_DO				(0xD0)
-#define	YAS537_REG_MTCR					(0x93)
-#define	YAS537_REG_CONFR				(0x82)
-#define	BMI160_REG_YAS537_CMDR			(0x81)
-#define	YAS537_REG_OXR					(0x84)
-#define	YAS537_REG_AVRR					(0x87)
-#define	YAS537_REG_HCKR					(0x88)
-#define	YAS537_REG_LCKR					(0x89)
-#define	YAS537_REG_ADCCALR				(0x91)
-#define	YAS537_REG_ADCCALR_ONE			(0x92)
-#define	YAS537_REG_OCR					(0x9E)
-#define	YAS537_REG_TRMR			        (0x9F)
-#define	YAS537_REG_TEMPERATURE_0		(0xB0)
-#define	YAS537_REG_TEMPERATURE_1		(0xB1)
-#define	YAS537_REG_DATA_X_0				(0xB2)
-#define	YAS537_REG_DATA_X_1				(0xB3)
-#define	YAS537_REG_DATA_Y1_0			(0xB4)
-#define	YAS537_REG_DATA_Y1_1			(0xB5)
-#define	YAS537_REG_DATA_Y2_0			(0xB6)
-#define	YAS537_REG_DATA_Y2_1			(0xB7)
-#define YAS537_MAG_STATE_NORMAL			(0)
-#define YAS537_MAG_STATE_INIT_COIL		(1)
-#define YAS537_MAG_STATE_RECORD_DATA	(2)
-#define YAS537_DATA_UNDERFLOW			(0)
-#define YAS537_DATA_OVERFLOW			(16383)
-/****************************************************/
-/**\name	YAS537_set vector */
-/***************************************************/
-#define yas537_set_vector(to, from) \
-	{int _l; for (_l = 0; _l < 3; _l++) (to)[_l] = (from)[_l]; }
-
-#ifndef ABS
-#define ABS(a)		((a) > 0 ? (a) : -(a)) /*!< Absolute value */
-#endif
-/****************************************************/
-/**\name	AKM09911 AND AKM09912 DEFINITION */
-/***************************************************/
-#define AKM09912_SENSITIVITY_DIV	(256)
-#define AKM09912_SENSITIVITY		(128)
-#define AKM09911_SENSITIVITY_DIV	(128)
-#define AKM_ASAX	(0)
-#define AKM_ASAY	(1)
-#define AKM_ASAZ	(2)
-#define AKM_POWER_DOWN_MODE_DATA		(0x00)
-#define AKM_FUSE_ROM_MODE				(0x1F)
-#define AKM_POWER_MODE_REG				(0x31)
-#define	AKM_SINGLE_MEASUREMENT_MODE		(0x01)
-#define AKM_DATA_REGISTER				(0x11)
-/*! AKM09912 Register definition */
-#define AKM_CHIP_ID_REG			(0x01)
-/****************************************************/
-/**\name	BMM150 DEFINITION */
-/***************************************************/
-#define BMI160_BMM150_SET_POWER_CONTROL	(0x01)
-#define BMI160_BMM150_MAX_RETRY_WAKEUP	(5)
-#define BMI160_BMM150_POWER_ON			(0x01)
-#define BMI160_BMM150_POWER_OFF			(0x00)
-#define BMI160_BMM150_FORCE_MODE		(0x02)
-#define BMI160_BMM150_POWER_ON_SUCCESS	(0)
-#define BMI160_BMM150_POWER_ON_FAIL		((s8)-1)
-
-#define	BMI160_BMM150_DIG_X1			(0)
-#define	BMI160_BMM150_DIG_Y1			(1)
-#define	BMI160_BMM150_DIG_X2			(2)
-#define	BMI160_BMM150_DIG_Y3			(3)
-#define	BMI160_BMM150_DIG_XY1			(4)
-#define	BMI160_BMM150_DIG_XY2			(5)
-#define	BMI160_BMM150_DIG_Z1_LSB		(6)
-#define	BMI160_BMM150_DIG_Z1_MSB		(7)
-#define	BMI160_BMM150_DIG_Z2_LSB		(8)
-#define	BMI160_BMM150_DIG_Z2_MSB		(9)
-#define	BMI160_BMM150_DIG_DIG_Z3_LSB	(10)
-#define	BMI160_BMM150_DIG_DIG_Z3_MSB	(11)
-#define	BMI160_BMM150_DIG_DIG_Z4_LSB	(12)
-#define	BMI160_BMM150_DIG_DIG_Z4_MSB	(13)
-#define	BMI160_BMM150_DIG_DIG_XYZ1_LSB	(14)
-#define	BMI160_BMM150_DIG_DIG_XYZ1_MSB	(15)
-#define BMI160_FIFO_FRAME_CNT			(146)
-#define	BMI160_FRAME_COUNT				(1)
-
-/**************************************************************/
-/**\name	STRUCTURE DEFINITIONS                         */
-/**************************************************************/
-/*!
-*	@brief bmi160 structure
-*	This structure holds all relevant information about bmi160
-*/
-struct bmi160_t {
-u8 chip_id;/**< chip id of BMI160 */
-u8 dev_addr;/**< device address of BMI160 */
-s8 mag_manual_enable;/**< used for check the mag manual/auto mode status */
-BMI160_WR_FUNC_PTR;/**< bus write function pointer */
-BMI160_RD_FUNC_PTR;/**< bus read function pointer */
-BMI160_BRD_FUNC_PTR;/**< burst write function pointer */
-void (*delay_msec)(BMI160_MDELAY_DATA_TYPE);/**< delay function pointer */
-};
-/*!
- * @brief Structure containing bmm150 and akm09911
- *	magnetometer values for x,y and
- *	z-axis in s16
- */
-struct bmi160_mag_t {
-s32 x;/**< BMM150 and AKM09911 and AKM09912 X raw data*/
-s32 y;/**< BMM150 and AKM09911 and AKM09912 Y raw data*/
-s32 z;/**< BMM150 and AKM09911 and AKM09912 Z raw data*/
-};
-/*!
- * @brief Structure containing bmm150 xyz data and temperature
- */
-struct bmi160_mag_xyzr_t {
-s16 x;/**< BMM150 X raw data*/
-s16 y;/**< BMM150 Y raw data*/
-s16 z;/**<BMM150 Z raw data*/
-u16 r;/**<BMM150 R raw data*/
-};
-/*!
- * @brief Structure containing gyro xyz data
- */
-struct bmi160_gyro_t {
-s16 x;/**<gyro X  data*/
-s16 y;/**<gyro Y  data*/
-s16 z;/**<gyro Z  data*/
-};
-/*!
- * @brief Structure containing accel xyz data
- */
-struct bmi160_accel_t {
-s16 x;/**<accel X  data*/
-s16 y;/**<accel Y  data*/
-s16 z;/**<accel Z  data*/
-};
-/*!
- * @brief Structure bmm150 mag compensated data with s32 output
- */
-struct bmi160_mag_xyz_s32_t {
-s32 x;/**<BMM150 X compensated data*/
-s32 y;/**<BMM150 Y compensated data*/
-s32 z;/**<BMM150 Z compensated data*/
-};
-/*!
- * @brief Structure bmm150 mag trim data
- */
-struct trim_data_t {
-s8 dig_x1;/**<BMM150 trim x1 data*/
-s8 dig_y1;/**<BMM150 trim y1 data*/
-
-s8 dig_x2;/**<BMM150 trim x2 data*/
-s8 dig_y2;/**<BMM150 trim y2 data*/
-
-u16 dig_z1;/**<BMM150 trim z1 data*/
-s16 dig_z2;/**<BMM150 trim z2 data*/
-s16 dig_z3;/**<BMM150 trim z3 data*/
-s16 dig_z4;/**<BMM150 trim z4 data*/
-
-u8 dig_xy1;/**<BMM150 trim xy1 data*/
-s8 dig_xy2;/**<BMM150 trim xy2 data*/
-
-u16 dig_xyz1;/**<BMM150 trim xyz1 data*/
-};
-/*!
- *	@brief Used to read the akm compensated values
-*/
-struct bmi160_bst_akm_xyz_t {
-s32 x;/**<AKM09911 and AKM09912 X compensated data*/
-s32 y;/**<AKM09911 and AKM09912 Y compensated data*/
-s32 z;/**<AKM09911 and AKM09912 Z compensated data*/
-};
-/*!
-*	@brief Structure for reading AKM compensating data
-*/
-struct bst_akm_sensitivity_data_t {
-u8 asax;/**<AKM09911 and AKM09912 X sensitivity data*/
-u8 asay;/**<AKM09911 and AKM09912 Y sensitivity data*/
-u8 asaz;/**<AKM09911 and AKM09912 Z sensitivity data*/
-};
-/*!
-* @brief YAMAHA-YAS532 struct
-* Calibration YAS532 data struct
-*/
-struct bst_yas532_calib_data_t {
-s32 cx;/**<YAS532 calib cx data */
-s32 cy1;/**<YAS532 calib cy1 data */
-s32 cy2;/**<YAS532 calib cy2 data */
-s32 a2;/**<YAS532 calib a2 data */
-s32 a3;/**<YAS532 calib a3 data */
-s32 a4;/**<YAS532 calib a4 data */
-s32 a5;/**<YAS532 calib a5 data */
-s32 a6;/**<YAS532 calib a6 data */
-s32 a7;/**<YAS532 calib a7 data */
-s32 a8;/**<YAS532 calib a8 data */
-s32 a9;/**<YAS532 calib a9 data */
-s32 k;/**<YAS532 calib k data */
-s8 rxy1y2[3];/**<YAS532 calib rxy1y2 data */
-u8 fxy1y2[3];/**<YAS532 calib fxy1y2 data */
-};
-/*!
-* @brief YAS532 Temperature structure
-*/
-#if 1 < YAS532_MAG_TEMPERATURE_LOG
-struct yas_temp_filter_t {
-u16 log[YAS532_MAG_TEMPERATURE_LOG];/**<YAS532 temp log array */
-u8 num;/**< used for increment the index */
-u8 idx;/**< used for increment the index */
-};
-#endif
-/*!
-* @brief YAS532 sensor initialization
-*/
-struct yas532_t {
-struct bst_yas532_calib_data_t calib_yas532;/**< calib data */
-s8 measure_state;/**< update measure state */
-s8 v_hard_offset_s8[3];/**< offset write array*/
-s32 coef[3];/**< co efficient data */
-s8 overflow;/**< over flow condition check */
-u8 dev_id;/**< device id information */
-const s8 *transform;/**< transform condition check  */
-#if 1 < YAS532_MAG_TEMPERATURE_LOG
-struct yas_temp_filter_t temp_data;/**< temp data */
-#endif
-u16 last_raw[4];/**< raw data */
-};
-/*!
-* @brief Used for reading the YAS532 XYZ data
-*/
-struct yas532_vector {
-s32 yas532_vector_xyz[3];/**< YAS532 compensated xyz data*/
-};
-/*!
-* @brief Used for reading the YAS532 XYZ data
-*/
-struct yas532_data {
-s32 x;
-s32 y;
-s32 z;
-};
-/**
- * @struct yas_vector
- * @brief Stores the sensor data
- */
-struct yas_vector {
-	s32 yas537_vector_xyz[3]; /*!< vector data */
-};
-/*!
-* @brief YAMAHA-YAS532 struct
-* Calibration YAS532 data struct
-*/
-struct bst_yas537_calib_data_t {
-s8 a2;/**<YAS532 calib a2 data */
-s8 a3;/**<YAS532 calib a3 data */
-s8 a4;/**<YAS532 calib a4 data */
-s16 a5;/**<YAS532 calib a5 data */
-s8 a6;/**<YAS532 calib a6 data */
-s8 a7;/**<YAS532 calib a7 data */
-s8 a8;/**<YAS532 calib a8 data */
-s16 a9;/**<YAS532 calib a9 data */
-u8 k;/**<YAS532 calib k data */
-u8 ver;/**<YAS532 calib ver data*/
-};
-/*!
-* @brief YAS537 sensor initialization
-*/
-struct yas537_t {
-struct bst_yas537_calib_data_t calib_yas537;/**< calib data */
-s8 measure_state;/**< update measure state */
-s8 hard_offset[3];/**< offset write array*/
-u16 last_after_rcoil[3];/**< rcoil write array*/
-s32 coef[3];/**< co efficient data */
-s8 overflow;/**< over flow condition check */
-u8 dev_id;/**< device id information */
-u8 average;/**<average selection for offset configuration*/
-const s8 *transform;/**< transform condition check  */
-u16 last_raw[4];/**< raw data */
-struct yas_vector xyz; /*!< X, Y, Z measurement data of the sensor */
-};
-/*!
-* @brief FIFO used to store the FIFO header less data
-*/
-struct bmi160_fifo_data_header_less_t {
-
-struct bmi160_accel_t accel_fifo[BMI160_FIFO_FRAME_CNT];/**<
-Accel data of XYZ */
-struct bmi160_mag_t mag_fifo[BMI160_FIFO_FRAME_CNT];/**<
-Mag data of XYZ */
-struct bmi160_gyro_t gyro_fifo[BMI160_FIFO_FRAME_CNT];/**<
-Gyro data of XYZ */
-u8 accel_frame_count;/**< The total number of accel frame stored
-in the FIFO*/
-u8 gyro_frame_count;/**< The total number of gyro frame stored
-in the FIFO*/
-u8 mag_frame_count;/**< The total number of mag frame stored
-in the FIFO*/
-};
-/*!
-* @brief Struct used to store the FIFO header data
-*/
-struct bmi160_fifo_data_header_t {
-struct bmi160_accel_t accel_fifo[BMI160_FIFO_FRAME_CNT];/**<
-Accel data of XYZ */
-struct bmi160_mag_t mag_fifo[BMI160_FIFO_FRAME_CNT];/**<
-Mag data of XYZ */
-struct bmi160_gyro_t gyro_fifo[BMI160_FIFO_FRAME_CNT];/**<
-Gyro data of XYZ */
-u32 fifo_time;/**< Value of fifo time*/
-u8 skip_frame;/**< The value of skip frame information */
-u8 fifo_input_config_info; /**< FIFO input config info*/
-u8 accel_frame_count; /**< The total number of accel frame stored
-in the FIFO*/
-u8 gyro_frame_count; /**< The total number of gyro frame stored
-in the FIFO*/
-u8 mag_frame_count; /**< The total number of mag frame stored
-in the FIFO*/
-u8 fifo_header[BMI160_FIFO_FRAME_CNT]; /**< FIFO header info*/
-};
-/*!
-* @brief Struct used to store the FIFO mag data
-*/
-struct bmi160_mag_fifo_data_t {
-u8 mag_x_lsb;/**< The value of mag x LSB data*/
-u8 mag_x_msb;/**< The value of mag x MSB data*/
-u8 mag_y_lsb;/**< The value of mag y LSB data*/
-u8 mag_y_msb;/**< The value of mag y MSB data*/
-u8 mag_z_lsb;/**< The value of mag z LSB data*/
-u8 mag_z_msb;/**< The value of mag z MSB data*/
-u8 mag_r_y2_lsb;
-/**< The value of mag r for BMM150 Y2 for YAMAHA LSB data*/
-u8 mag_r_y2_msb;
-/**< The value of mag r for BMM150 Y2 for YAMAHA MSB data*/
-};
-
-/**************************************************************/
-/**\name	USER DATA REGISTERS DEFINITION START    */
-/**************************************************************/
-
-/**************************************************************/
-/**\name	CHIP ID LENGTH, POSITION AND MASK    */
-/**************************************************************/
-/* Chip ID Description - Reg Addr --> (0x00), Bit --> 0...7 */
-#define BMI160_USER_CHIP_ID__POS             (0)
-#define BMI160_USER_CHIP_ID__MSK            (0xFF)
-#define BMI160_USER_CHIP_ID__LEN             (8)
-#define BMI160_USER_CHIP_ID__REG             (BMI160_USER_CHIP_ID_ADDR)
-/**************************************************************/
-/**\name	ERROR STATUS LENGTH, POSITION AND MASK    */
-/**************************************************************/
-/* Error Description - Reg Addr --> (0x02), Bit --> 0 */
-#define BMI160_USER_ERR_STAT__POS               (0)
-#define BMI160_USER_ERR_STAT__LEN               (8)
-#define BMI160_USER_ERR_STAT__MSK               (0xFF)
-#define BMI160_USER_ERR_STAT__REG               (BMI160_USER_ERROR_ADDR)
-
-#define BMI160_USER_FATAL_ERR__POS               (0)
-#define BMI160_USER_FATAL_ERR__LEN               (1)
-#define BMI160_USER_FATAL_ERR__MSK               (0x01)
-#define BMI160_USER_FATAL_ERR__REG               (BMI160_USER_ERROR_ADDR)
-
-/* Error Description - Reg Addr --> (0x02), Bit --> 1...4 */
-#define BMI160_USER_ERR_CODE__POS               (1)
-#define BMI160_USER_ERR_CODE__LEN               (4)
-#define BMI160_USER_ERR_CODE__MSK               (0x1E)
-#define BMI160_USER_ERR_CODE__REG               (BMI160_USER_ERROR_ADDR)
-
-/* Error Description - Reg Addr --> (0x02), Bit --> 5 */
-#define BMI160_USER_I2C_FAIL_ERR__POS               (5)
-#define BMI160_USER_I2C_FAIL_ERR__LEN               (1)
-#define BMI160_USER_I2C_FAIL_ERR__MSK               (0x20)
-#define BMI160_USER_I2C_FAIL_ERR__REG               (BMI160_USER_ERROR_ADDR)
-
-/* Error Description - Reg Addr --> (0x02), Bit --> 6 */
-#define BMI160_USER_DROP_CMD_ERR__POS              (6)
-#define BMI160_USER_DROP_CMD_ERR__LEN              (1)
-#define BMI160_USER_DROP_CMD_ERR__MSK              (0x40)
-#define BMI160_USER_DROP_CMD_ERR__REG              (BMI160_USER_ERROR_ADDR)
-/**************************************************************/
-/**\name	MAG DATA READY LENGTH, POSITION AND MASK    */
-/**************************************************************/
-/* Error Description - Reg Addr --> (0x02), Bit --> 7 */
-#define BMI160_USER_MAG_DADA_RDY_ERR__POS               (7)
-#define BMI160_USER_MAG_DADA_RDY_ERR__LEN               (1)
-#define BMI160_USER_MAG_DADA_RDY_ERR__MSK               (0x80)
-#define BMI160_USER_MAG_DADA_RDY_ERR__REG               (BMI160_USER_ERROR_ADDR)
-/**************************************************************/
-/**\name	MAG POWER MODE LENGTH, POSITION AND MASK    */
-/**************************************************************/
-/* PMU_Status Description of MAG - Reg Addr --> (0x03), Bit --> 1..0 */
-#define BMI160_USER_MAG_POWER_MODE_STAT__POS		(0)
-#define BMI160_USER_MAG_POWER_MODE_STAT__LEN		(2)
-#define BMI160_USER_MAG_POWER_MODE_STAT__MSK		(0x03)
-#define BMI160_USER_MAG_POWER_MODE_STAT__REG		\
-(BMI160_USER_PMU_STAT_ADDR)
-/**************************************************************/
-/**\name	GYRO POWER MODE LENGTH, POSITION AND MASK    */
-/**************************************************************/
-/* PMU_Status Description of GYRO - Reg Addr --> (0x03), Bit --> 3...2 */
-#define BMI160_USER_GYRO_POWER_MODE_STAT__POS               (2)
-#define BMI160_USER_GYRO_POWER_MODE_STAT__LEN               (2)
-#define BMI160_USER_GYRO_POWER_MODE_STAT__MSK               (0x0C)
-#define BMI160_USER_GYRO_POWER_MODE_STAT__REG		      \
-(BMI160_USER_PMU_STAT_ADDR)
-/**************************************************************/
-/**\name	ACCEL POWER MODE LENGTH, POSITION AND MASK    */
-/**************************************************************/
-/* PMU_Status Description of ACCEL - Reg Addr --> (0x03), Bit --> 5...4 */
-#define BMI160_USER_ACCEL_POWER_MODE_STAT__POS               (4)
-#define BMI160_USER_ACCEL_POWER_MODE_STAT__LEN               (2)
-#define BMI160_USER_ACCEL_POWER_MODE_STAT__MSK               (0x30)
-#define BMI160_USER_ACCEL_POWER_MODE_STAT__REG		    \
-(BMI160_USER_PMU_STAT_ADDR)
-/**************************************************************/
-/**\name	MAG DATA XYZ LENGTH, POSITION AND MASK    */
-/**************************************************************/
-/* Mag_X(LSB) Description - Reg Addr --> (0x04), Bit --> 0...7 */
-#define BMI160_USER_DATA_0_MAG_X_LSB__POS           (0)
-#define BMI160_USER_DATA_0_MAG_X_LSB__LEN           (8)
-#define BMI160_USER_DATA_0_MAG_X_LSB__MSK          (0xFF)
-#define BMI160_USER_DATA_0_MAG_X_LSB__REG          (BMI160_USER_DATA_0_ADDR)
-
-/* Mag_X(LSB) Description - Reg Addr --> (0x04), Bit --> 3...7 */
-#define BMI160_USER_DATA_MAG_X_LSB__POS           (3)
-#define BMI160_USER_DATA_MAG_X_LSB__LEN           (5)
-#define BMI160_USER_DATA_MAG_X_LSB__MSK          (0xF8)
-#define BMI160_USER_DATA_MAG_X_LSB__REG          (BMI160_USER_DATA_0_ADDR)
-
-/* Mag_X(MSB) Description - Reg Addr --> (0x05), Bit --> 0...7 */
-#define BMI160_USER_DATA_1_MAG_X_MSB__POS           (0)
-#define BMI160_USER_DATA_1_MAG_X_MSB__LEN           (8)
-#define BMI160_USER_DATA_1_MAG_X_MSB__MSK          (0xFF)
-#define BMI160_USER_DATA_1_MAG_X_MSB__REG          (BMI160_USER_DATA_1_ADDR)
-
-/* Mag_Y(LSB) Description - Reg Addr --> (0x06), Bit --> 0...7 */
-#define BMI160_USER_DATA_2_MAG_Y_LSB__POS           (0)
-#define BMI160_USER_DATA_2_MAG_Y_LSB__LEN           (8)
-#define BMI160_USER_DATA_2_MAG_Y_LSB__MSK          (0xFF)
-#define BMI160_USER_DATA_2_MAG_Y_LSB__REG          (BMI160_USER_DATA_2_ADDR)
-
-/* Mag_Y(LSB) Description - Reg Addr --> (0x06), Bit --> 3...7 */
-#define BMI160_USER_DATA_MAG_Y_LSB__POS           (3)
-#define BMI160_USER_DATA_MAG_Y_LSB__LEN           (5)
-#define BMI160_USER_DATA_MAG_Y_LSB__MSK          (0xF8)
-#define BMI160_USER_DATA_MAG_Y_LSB__REG          (BMI160_USER_DATA_2_ADDR)
-
-/* Mag_Y(MSB) Description - Reg Addr --> (0x07), Bit --> 0...7 */
-#define BMI160_USER_DATA_3_MAG_Y_MSB__POS           (0)
-#define BMI160_USER_DATA_3_MAG_Y_MSB__LEN           (8)
-#define BMI160_USER_DATA_3_MAG_Y_MSB__MSK          (0xFF)
-#define BMI160_USER_DATA_3_MAG_Y_MSB__REG          (BMI160_USER_DATA_3_ADDR)
-
-/* Mag_Z(LSB) Description - Reg Addr --> (0x08), Bit --> 0...7 */
-#define BMI160_USER_DATA_4_MAG_Z_LSB__POS           (0)
-#define BMI160_USER_DATA_4_MAG_Z_LSB__LEN           (8)
-#define BMI160_USER_DATA_4_MAG_Z_LSB__MSK          (0xFF)
-#define BMI160_USER_DATA_4_MAG_Z_LSB__REG          (BMI160_USER_DATA_4_ADDR)
-
-/* Mag_X(LSB) Description - Reg Addr --> (0x08), Bit --> 3...7 */
-#define BMI160_USER_DATA_MAG_Z_LSB__POS           (1)
-#define BMI160_USER_DATA_MAG_Z_LSB__LEN           (7)
-#define BMI160_USER_DATA_MAG_Z_LSB__MSK          (0xFE)
-#define BMI160_USER_DATA_MAG_Z_LSB__REG          (BMI160_USER_DATA_4_ADDR)
-
-/* Mag_Z(MSB) Description - Reg Addr --> (0x09), Bit --> 0...7 */
-#define BMI160_USER_DATA_5_MAG_Z_MSB__POS           (0)
-#define BMI160_USER_DATA_5_MAG_Z_MSB__LEN           (8)
-#define BMI160_USER_DATA_5_MAG_Z_MSB__MSK          (0xFF)
-#define BMI160_USER_DATA_5_MAG_Z_MSB__REG          (BMI160_USER_DATA_5_ADDR)
-
-/* RHALL(LSB) Description - Reg Addr --> (0x0A), Bit --> 0...7 */
-#define BMI160_USER_DATA_6_RHALL_LSB__POS           (0)
-#define BMI160_USER_DATA_6_RHALL_LSB__LEN           (8)
-#define BMI160_USER_DATA_6_RHALL_LSB__MSK          (0xFF)
-#define BMI160_USER_DATA_6_RHALL_LSB__REG          (BMI160_USER_DATA_6_ADDR)
-
-/* Mag_R(LSB) Description - Reg Addr --> (0x0A), Bit --> 3...7 */
-#define BMI160_USER_DATA_MAG_R_LSB__POS           (2)
-#define BMI160_USER_DATA_MAG_R_LSB__LEN           (6)
-#define BMI160_USER_DATA_MAG_R_LSB__MSK          (0xFC)
-#define BMI160_USER_DATA_MAG_R_LSB__REG          (BMI160_USER_DATA_6_ADDR)
-
-/* RHALL(MSB) Description - Reg Addr --> (0x0B), Bit --> 0...7 */
-#define BMI160_USER_DATA_7_RHALL_MSB__POS           (0)
-#define BMI160_USER_DATA_7_RHALL_MSB__LEN           (8)
-#define BMI160_USER_DATA_7_RHALL_MSB__MSK          (0xFF)
-#define BMI160_USER_DATA_7_RHALL_MSB__REG          (BMI160_USER_DATA_7_ADDR)
-/**************************************************************/
-/**\name	GYRO DATA XYZ LENGTH, POSITION AND MASK    */
-/**************************************************************/
-/* GYR_X (LSB) Description - Reg Addr --> (0x0C), Bit --> 0...7 */
-#define BMI160_USER_DATA_8_GYRO_X_LSB__POS           (0)
-#define BMI160_USER_DATA_8_GYRO_X_LSB__LEN           (8)
-#define BMI160_USER_DATA_8_GYRO_X_LSB__MSK          (0xFF)
-#define BMI160_USER_DATA_8_GYRO_X_LSB__REG          (BMI160_USER_DATA_8_ADDR)
-
-/* GYR_X (MSB) Description - Reg Addr --> (0x0D), Bit --> 0...7 */
-#define BMI160_USER_DATA_9_GYRO_X_MSB__POS           (0)
-#define BMI160_USER_DATA_9_GYRO_X_MSB__LEN           (8)
-#define BMI160_USER_DATA_9_GYRO_X_MSB__MSK          (0xFF)
-#define BMI160_USER_DATA_9_GYRO_X_MSB__REG          (BMI160_USER_DATA_9_ADDR)
-
-/* GYR_Y (LSB) Description - Reg Addr --> 0x0E, Bit --> 0...7 */
-#define BMI160_USER_DATA_10_GYRO_Y_LSB__POS           (0)
-#define BMI160_USER_DATA_10_GYRO_Y_LSB__LEN           (8)
-#define BMI160_USER_DATA_10_GYRO_Y_LSB__MSK          (0xFF)
-#define BMI160_USER_DATA_10_GYRO_Y_LSB__REG          (BMI160_USER_DATA_10_ADDR)
-
-/* GYR_Y (MSB) Description - Reg Addr --> (0x0F), Bit --> 0...7 */
-#define BMI160_USER_DATA_11_GYRO_Y_MSB__POS           (0)
-#define BMI160_USER_DATA_11_GYRO_Y_MSB__LEN           (8)
-#define BMI160_USER_DATA_11_GYRO_Y_MSB__MSK          (0xFF)
-#define BMI160_USER_DATA_11_GYRO_Y_MSB__REG          (BMI160_USER_DATA_11_ADDR)
-
-/* GYR_Z (LSB) Description - Reg Addr --> (0x10), Bit --> 0...7 */
-#define BMI160_USER_DATA_12_GYRO_Z_LSB__POS           (0)
-#define BMI160_USER_DATA_12_GYRO_Z_LSB__LEN           (8)
-#define BMI160_USER_DATA_12_GYRO_Z_LSB__MSK          (0xFF)
-#define BMI160_USER_DATA_12_GYRO_Z_LSB__REG          (BMI160_USER_DATA_12_ADDR)
-
-/* GYR_Z (MSB) Description - Reg Addr --> (0x11), Bit --> 0...7 */
-#define BMI160_USER_DATA_13_GYRO_Z_MSB__POS           (0)
-#define BMI160_USER_DATA_13_GYRO_Z_MSB__LEN           (8)
-#define BMI160_USER_DATA_13_GYRO_Z_MSB__MSK          (0xFF)
-#define BMI160_USER_DATA_13_GYRO_Z_MSB__REG          (BMI160_USER_DATA_13_ADDR)
-/**************************************************************/
-/**\name	ACCEL DATA XYZ LENGTH, POSITION AND MASK    */
-/**************************************************************/
-/* ACC_X (LSB) Description - Reg Addr --> (0x12), Bit --> 0...7 */
-#define BMI160_USER_DATA_14_ACCEL_X_LSB__POS           (0)
-#define BMI160_USER_DATA_14_ACCEL_X_LSB__LEN           (8)
-#define BMI160_USER_DATA_14_ACCEL_X_LSB__MSK          (0xFF)
-#define BMI160_USER_DATA_14_ACCEL_X_LSB__REG          (BMI160_USER_DATA_14_ADDR)
-
-/* ACC_X (MSB) Description - Reg Addr --> 0x13, Bit --> 0...7 */
-#define BMI160_USER_DATA_15_ACCEL_X_MSB__POS           (0)
-#define BMI160_USER_DATA_15_ACCEL_X_MSB__LEN           (8)
-#define BMI160_USER_DATA_15_ACCEL_X_MSB__MSK          (0xFF)
-#define BMI160_USER_DATA_15_ACCEL_X_MSB__REG          (BMI160_USER_DATA_15_ADDR)
-
-/* ACC_Y (LSB) Description - Reg Addr --> (0x14), Bit --> 0...7 */
-#define BMI160_USER_DATA_16_ACCEL_Y_LSB__POS           (0)
-#define BMI160_USER_DATA_16_ACCEL_Y_LSB__LEN           (8)
-#define BMI160_USER_DATA_16_ACCEL_Y_LSB__MSK          (0xFF)
-#define BMI160_USER_DATA_16_ACCEL_Y_LSB__REG          (BMI160_USER_DATA_16_ADDR)
-
-/* ACC_Y (MSB) Description - Reg Addr --> (0x15), Bit --> 0...7 */
-#define BMI160_USER_DATA_17_ACCEL_Y_MSB__POS           (0)
-#define BMI160_USER_DATA_17_ACCEL_Y_MSB__LEN           (8)
-#define BMI160_USER_DATA_17_ACCEL_Y_MSB__MSK          (0xFF)
-#define BMI160_USER_DATA_17_ACCEL_Y_MSB__REG          (BMI160_USER_DATA_17_ADDR)
-
-/* ACC_Z (LSB) Description - Reg Addr --> 0x16, Bit --> 0...7 */
-#define BMI160_USER_DATA_18_ACCEL_Z_LSB__POS           (0)
-#define BMI160_USER_DATA_18_ACCEL_Z_LSB__LEN           (8)
-#define BMI160_USER_DATA_18_ACCEL_Z_LSB__MSK          (0xFF)
-#define BMI160_USER_DATA_18_ACCEL_Z_LSB__REG          (BMI160_USER_DATA_18_ADDR)
-
-/* ACC_Z (MSB) Description - Reg Addr --> (0x17), Bit --> 0...7 */
-#define BMI160_USER_DATA_19_ACCEL_Z_MSB__POS           (0)
-#define BMI160_USER_DATA_19_ACCEL_Z_MSB__LEN           (8)
-#define BMI160_USER_DATA_19_ACCEL_Z_MSB__MSK          (0xFF)
-#define BMI160_USER_DATA_19_ACCEL_Z_MSB__REG          (BMI160_USER_DATA_19_ADDR)
-/**************************************************************/
-/**\name	SENSOR TIME LENGTH, POSITION AND MASK    */
-/**************************************************************/
-/* SENSORTIME_0 (LSB) Description - Reg Addr --> (0x18), Bit --> 0...7 */
-#define BMI160_USER_SENSORTIME_0_SENSOR_TIME_LSB__POS           (0)
-#define BMI160_USER_SENSORTIME_0_SENSOR_TIME_LSB__LEN           (8)
-#define BMI160_USER_SENSORTIME_0_SENSOR_TIME_LSB__MSK          (0xFF)
-#define BMI160_USER_SENSORTIME_0_SENSOR_TIME_LSB__REG          \
-		(BMI160_USER_SENSORTIME_0_ADDR)
-
-/* SENSORTIME_1 (MSB) Description - Reg Addr --> (0x19), Bit --> 0...7 */
-#define BMI160_USER_SENSORTIME_1_SENSOR_TIME_MSB__POS           (0)
-#define BMI160_USER_SENSORTIME_1_SENSOR_TIME_MSB__LEN           (8)
-#define BMI160_USER_SENSORTIME_1_SENSOR_TIME_MSB__MSK          (0xFF)
-#define BMI160_USER_SENSORTIME_1_SENSOR_TIME_MSB__REG          \
-		(BMI160_USER_SENSORTIME_1_ADDR)
-
-/* SENSORTIME_2 (MSB) Description - Reg Addr --> (0x1A), Bit --> 0...7 */
-#define BMI160_USER_SENSORTIME_2_SENSOR_TIME_MSB__POS           (0)
-#define BMI160_USER_SENSORTIME_2_SENSOR_TIME_MSB__LEN           (8)
-#define BMI160_USER_SENSORTIME_2_SENSOR_TIME_MSB__MSK          (0xFF)
-#define BMI160_USER_SENSORTIME_2_SENSOR_TIME_MSB__REG          \
-		(BMI160_USER_SENSORTIME_2_ADDR)
-/**************************************************************/
-/**\name	GYRO SELF TEST LENGTH, POSITION AND MASK    */
-/**************************************************************/
-/* Status Description - Reg Addr --> 0x1B, Bit --> 1 */
-#define BMI160_USER_STAT_GYRO_SELFTEST_OK__POS          (1)
-#define BMI160_USER_STAT_GYRO_SELFTEST_OK__LEN          (1)
-#define BMI160_USER_STAT_GYRO_SELFTEST_OK__MSK          (0x02)
-#define BMI160_USER_STAT_GYRO_SELFTEST_OK__REG         \
-		(BMI160_USER_STAT_ADDR)
-/**************************************************************/
-/**\name	MAG MANUAL OPERATION LENGTH, POSITION AND MASK    */
-/**************************************************************/
-/* Status Description - Reg Addr --> 0x1B, Bit --> 2 */
-#define BMI160_USER_STAT_MAG_MANUAL_OPERATION__POS          (2)
-#define BMI160_USER_STAT_MAG_MANUAL_OPERATION__LEN          (1)
-#define BMI160_USER_STAT_MAG_MANUAL_OPERATION__MSK          (0x04)
-#define BMI160_USER_STAT_MAG_MANUAL_OPERATION__REG          \
-		(BMI160_USER_STAT_ADDR)
-/**************************************************************/
-/**\name	FOC STATUS LENGTH, POSITION AND MASK    */
-/**************************************************************/
-/* Status Description - Reg Addr --> 0x1B, Bit --> 3 */
-#define BMI160_USER_STAT_FOC_RDY__POS          (3)
-#define BMI160_USER_STAT_FOC_RDY__LEN          (1)
-#define BMI160_USER_STAT_FOC_RDY__MSK          (0x08)
-#define BMI160_USER_STAT_FOC_RDY__REG          (BMI160_USER_STAT_ADDR)
-/**************************************************************/
-/**\name	NVM READY LENGTH, POSITION AND MASK    */
-/**************************************************************/
-/* Status Description - Reg Addr --> 0x1B, Bit --> 4 */
-#define BMI160_USER_STAT_NVM_RDY__POS           (4)
-#define BMI160_USER_STAT_NVM_RDY__LEN           (1)
-#define BMI160_USER_STAT_NVM_RDY__MSK           (0x10)
-#define BMI160_USER_STAT_NVM_RDY__REG           (BMI160_USER_STAT_ADDR)
-/**************************************************************/
-/**\name	DATA READY LENGTH, POSITION AND MASK FOR ACCEL, MAG AND GYRO*/
-/**************************************************************/
-/* Status Description - Reg Addr --> 0x1B, Bit --> 5 */
-#define BMI160_USER_STAT_DATA_RDY_MAG__POS           (5)
-#define BMI160_USER_STAT_DATA_RDY_MAG__LEN           (1)
-#define BMI160_USER_STAT_DATA_RDY_MAG__MSK           (0x20)
-#define BMI160_USER_STAT_DATA_RDY_MAG__REG           (BMI160_USER_STAT_ADDR)
-
-/* Status Description - Reg Addr --> 0x1B, Bit --> 6 */
-#define BMI160_USER_STAT_DATA_RDY_GYRO__POS           (6)
-#define BMI160_USER_STAT_DATA_RDY_GYRO__LEN           (1)
-#define BMI160_USER_STAT_DATA_RDY_GYRO__MSK           (0x40)
-#define BMI160_USER_STAT_DATA_RDY_GYRO__REG           (BMI160_USER_STAT_ADDR)
-
-/* Status Description - Reg Addr --> 0x1B, Bit --> 7 */
-#define BMI160_USER_STAT_DATA_RDY_ACCEL__POS           (7)
-#define BMI160_USER_STAT_DATA_RDY_ACCEL__LEN           (1)
-#define BMI160_USER_STAT_DATA_RDY_ACCEL__MSK           (0x80)
-#define BMI160_USER_STAT_DATA_RDY_ACCEL__REG           (BMI160_USER_STAT_ADDR)
-/**************************************************************/
-/**\name	INTERRUPT STATUS LENGTH, POSITION AND MASK    */
-/**************************************************************/
-/* Int_Status_0 Description - Reg Addr --> 0x1C, Bit --> 0 */
-#define BMI160_USER_INTR_STAT_0_STEP_INTR__POS           (0)
-#define BMI160_USER_INTR_STAT_0_STEP_INTR__LEN           (1)
-#define BMI160_USER_INTR_STAT_0_STEP_INTR__MSK          (0x01)
-#define BMI160_USER_INTR_STAT_0_STEP_INTR__REG          \
-		(BMI160_USER_INTR_STAT_0_ADDR)
-/**************************************************************/
-/**\name	SIGNIFICANT INTERRUPT STATUS LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Status_0 Description - Reg Addr --> 0x1C, Bit --> 1 */
-#define BMI160_USER_INTR_STAT_0_SIGNIFICANT_INTR__POS		(1)
-#define BMI160_USER_INTR_STAT_0_SIGNIFICANT_INTR__LEN		(1)
-#define BMI160_USER_INTR_STAT_0_SIGNIFICANT_INTR__MSK		(0x02)
-#define BMI160_USER_INTR_STAT_0_SIGNIFICANT_INTR__REG       \
-		(BMI160_USER_INTR_STAT_0_ADDR)
-/**************************************************************/
-/**\name	ANY_MOTION INTERRUPT STATUS LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Status_0 Description - Reg Addr --> 0x1C, Bit --> 2 */
-#define BMI160_USER_INTR_STAT_0_ANY_MOTION__POS           (2)
-#define BMI160_USER_INTR_STAT_0_ANY_MOTION__LEN           (1)
-#define BMI160_USER_INTR_STAT_0_ANY_MOTION__MSK          (0x04)
-#define BMI160_USER_INTR_STAT_0_ANY_MOTION__REG          \
-		(BMI160_USER_INTR_STAT_0_ADDR)
-/**************************************************************/
-/**\name	PMU TRIGGER INTERRUPT STATUS LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Status_0 Description - Reg Addr --> 0x1C, Bit --> 3 */
-#define BMI160_USER_INTR_STAT_0_PMU_TRIGGER__POS           3
-#define BMI160_USER_INTR_STAT_0_PMU_TRIGGER__LEN           (1)
-#define BMI160_USER_INTR_STAT_0_PMU_TRIGGER__MSK          (0x08)
-#define BMI160_USER_INTR_STAT_0_PMU_TRIGGER__REG          \
-		(BMI160_USER_INTR_STAT_0_ADDR)
-/**************************************************************/
-/**\name	DOUBLE TAP INTERRUPT STATUS LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Status_0 Description - Reg Addr --> 0x1C, Bit --> 4 */
-#define BMI160_USER_INTR_STAT_0_DOUBLE_TAP_INTR__POS           4
-#define BMI160_USER_INTR_STAT_0_DOUBLE_TAP_INTR__LEN           (1)
-#define BMI160_USER_INTR_STAT_0_DOUBLE_TAP_INTR__MSK          (0x10)
-#define BMI160_USER_INTR_STAT_0_DOUBLE_TAP_INTR__REG          \
-		(BMI160_USER_INTR_STAT_0_ADDR)
-/**************************************************************/
-/**\name	SINGLE TAP INTERRUPT STATUS LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Status_0 Description - Reg Addr --> 0x1C, Bit --> 5 */
-#define BMI160_USER_INTR_STAT_0_SINGLE_TAP_INTR__POS           5
-#define BMI160_USER_INTR_STAT_0_SINGLE_TAP_INTR__LEN           (1)
-#define BMI160_USER_INTR_STAT_0_SINGLE_TAP_INTR__MSK          (0x20)
-#define BMI160_USER_INTR_STAT_0_SINGLE_TAP_INTR__REG          \
-		(BMI160_USER_INTR_STAT_0_ADDR)
-/**************************************************************/
-/**\name	ORIENT INTERRUPT STATUS LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Status_0 Description - Reg Addr --> 0x1C, Bit --> 6 */
-#define BMI160_USER_INTR_STAT_0_ORIENT__POS           (6)
-#define BMI160_USER_INTR_STAT_0_ORIENT__LEN           (1)
-#define BMI160_USER_INTR_STAT_0_ORIENT__MSK          (0x40)
-#define BMI160_USER_INTR_STAT_0_ORIENT__REG          \
-		(BMI160_USER_INTR_STAT_0_ADDR)
-/**************************************************************/
-/**\name	FLAT INTERRUPT STATUS LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Status_0 Description - Reg Addr --> 0x1C, Bit --> 7 */
-#define BMI160_USER_INTR_STAT_0_FLAT__POS           (7)
-#define BMI160_USER_INTR_STAT_0_FLAT__LEN           (1)
-#define BMI160_USER_INTR_STAT_0_FLAT__MSK          (0x80)
-#define BMI160_USER_INTR_STAT_0_FLAT__REG          \
-		(BMI160_USER_INTR_STAT_0_ADDR)
-/**************************************************************/
-/**\name	HIGH_G INTERRUPT STATUS LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Status_1 Description - Reg Addr --> 0x1D, Bit --> 2 */
-#define BMI160_USER_INTR_STAT_1_HIGH_G_INTR__POS               (2)
-#define BMI160_USER_INTR_STAT_1_HIGH_G_INTR__LEN               (1)
-#define BMI160_USER_INTR_STAT_1_HIGH_G_INTR__MSK              (0x04)
-#define BMI160_USER_INTR_STAT_1_HIGH_G_INTR__REG              \
-		(BMI160_USER_INTR_STAT_1_ADDR)
-/**************************************************************/
-/**\name	LOW_G INTERRUPT STATUS LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Status_1 Description - Reg Addr --> 0x1D, Bit --> 3 */
-#define BMI160_USER_INTR_STAT_1_LOW_G_INTR__POS               (3)
-#define BMI160_USER_INTR_STAT_1_LOW_G_INTR__LEN               (1)
-#define BMI160_USER_INTR_STAT_1_LOW_G_INTR__MSK              (0x08)
-#define BMI160_USER_INTR_STAT_1_LOW_G_INTR__REG              \
-		(BMI160_USER_INTR_STAT_1_ADDR)
-/**************************************************************/
-/**\name	DATA READY INTERRUPT STATUS LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Status_1 Description - Reg Addr --> 0x1D, Bit --> 4 */
-#define BMI160_USER_INTR_STAT_1_DATA_RDY_INTR__POS               (4)
-#define BMI160_USER_INTR_STAT_1_DATA_RDY_INTR__LEN               (1)
-#define BMI160_USER_INTR_STAT_1_DATA_RDY_INTR__MSK               (0x10)
-#define BMI160_USER_INTR_STAT_1_DATA_RDY_INTR__REG               \
-		(BMI160_USER_INTR_STAT_1_ADDR)
-/**************************************************************/
-/**\name	FIFO FULL INTERRUPT STATUS LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Status_1 Description - Reg Addr --> 0x1D, Bit --> 5 */
-#define BMI160_USER_INTR_STAT_1_FIFO_FULL_INTR__POS               (5)
-#define BMI160_USER_INTR_STAT_1_FIFO_FULL_INTR__LEN               (1)
-#define BMI160_USER_INTR_STAT_1_FIFO_FULL_INTR__MSK               (0x20)
-#define BMI160_USER_INTR_STAT_1_FIFO_FULL_INTR__REG               \
-		(BMI160_USER_INTR_STAT_1_ADDR)
-/**************************************************************/
-/**\name FIFO WATERMARK INTERRUPT STATUS LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Status_1 Description - Reg Addr --> 0x1D, Bit --> 6 */
-#define BMI160_USER_INTR_STAT_1_FIFO_WM_INTR__POS               (6)
-#define BMI160_USER_INTR_STAT_1_FIFO_WM_INTR__LEN               (1)
-#define BMI160_USER_INTR_STAT_1_FIFO_WM_INTR__MSK               (0x40)
-#define BMI160_USER_INTR_STAT_1_FIFO_WM_INTR__REG               \
-		(BMI160_USER_INTR_STAT_1_ADDR)
-/**************************************************************/
-/**\name	NO MOTION INTERRUPT STATUS LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Status_1 Description - Reg Addr --> 0x1D, Bit --> 7 */
-#define BMI160_USER_INTR_STAT_1_NOMOTION_INTR__POS               (7)
-#define BMI160_USER_INTR_STAT_1_NOMOTION_INTR__LEN               (1)
-#define BMI160_USER_INTR_STAT_1_NOMOTION_INTR__MSK               (0x80)
-#define BMI160_USER_INTR_STAT_1_NOMOTION_INTR__REG               \
-		(BMI160_USER_INTR_STAT_1_ADDR)
-/**************************************************************/
-/**\name	ANY MOTION-XYZ AXIS INTERRUPT STATUS LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Status_2 Description - Reg Addr --> 0x1E, Bit --> 0 */
-#define BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_X__POS               (0)
-#define BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_X__LEN               (1)
-#define BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_X__MSK               (0x01)
-#define BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_X__REG               \
-		(BMI160_USER_INTR_STAT_2_ADDR)
-
-/* Int_Status_2 Description - Reg Addr --> 0x1E, Bit --> 1 */
-#define BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_Y__POS               (1)
-#define BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_Y__LEN               (1)
-#define BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_Y__MSK               (0x02)
-#define BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_Y__REG               \
-		(BMI160_USER_INTR_STAT_2_ADDR)
-
-/* Int_Status_2 Description - Reg Addr --> 0x1E, Bit --> 2 */
-#define BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_Z__POS               (2)
-#define BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_Z__LEN               (1)
-#define BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_Z__MSK               (0x04)
-#define BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_Z__REG               \
-		(BMI160_USER_INTR_STAT_2_ADDR)
-/**************************************************************/
-/**\name	ANY MOTION SIGN LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Status_2 Description - Reg Addr --> 0x1E, Bit --> 3 */
-#define BMI160_USER_INTR_STAT_2_ANY_MOTION_SIGN__POS               (3)
-#define BMI160_USER_INTR_STAT_2_ANY_MOTION_SIGN__LEN               (1)
-#define BMI160_USER_INTR_STAT_2_ANY_MOTION_SIGN__MSK               (0x08)
-#define BMI160_USER_INTR_STAT_2_ANY_MOTION_SIGN__REG               \
-		(BMI160_USER_INTR_STAT_2_ADDR)
-/**************************************************************/
-/**\name	TAP_XYZ AND SIGN LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Status_2 Description - Reg Addr --> 0x1E, Bit --> 4 */
-#define BMI160_USER_INTR_STAT_2_TAP_FIRST_X__POS               (4)
-#define BMI160_USER_INTR_STAT_2_TAP_FIRST_X__LEN               (1)
-#define BMI160_USER_INTR_STAT_2_TAP_FIRST_X__MSK               (0x10)
-#define BMI160_USER_INTR_STAT_2_TAP_FIRST_X__REG               \
-		(BMI160_USER_INTR_STAT_2_ADDR)
-
-/* Int_Status_2 Description - Reg Addr --> 0x1E, Bit --> 5 */
-#define BMI160_USER_INTR_STAT_2_TAP_FIRST_Y__POS               (5)
-#define BMI160_USER_INTR_STAT_2_TAP_FIRST_Y__LEN               (1)
-#define BMI160_USER_INTR_STAT_2_TAP_FIRST_Y__MSK               (0x20)
-#define BMI160_USER_INTR_STAT_2_TAP_FIRST_Y__REG               \
-		(BMI160_USER_INTR_STAT_2_ADDR)
-
-/* Int_Status_2 Description - Reg Addr --> 0x1E, Bit --> 6 */
-#define BMI160_USER_INTR_STAT_2_TAP_FIRST_Z__POS               (6)
-#define BMI160_USER_INTR_STAT_2_TAP_FIRST_Z__LEN               (1)
-#define BMI160_USER_INTR_STAT_2_TAP_FIRST_Z__MSK               (0x40)
-#define BMI160_USER_INTR_STAT_2_TAP_FIRST_Z__REG               \
-		(BMI160_USER_INTR_STAT_2_ADDR)
-
-/* Int_Status_2 Description - Reg Addr --> 0x1E, Bit --> 7 */
-#define BMI160_USER_INTR_STAT_2_TAP_SIGN__POS               (7)
-#define BMI160_USER_INTR_STAT_2_TAP_SIGN__LEN               (1)
-#define BMI160_USER_INTR_STAT_2_TAP_SIGN__MSK               (0x80)
-#define BMI160_USER_INTR_STAT_2_TAP_SIGN__REG               \
-		(BMI160_USER_INTR_STAT_2_ADDR)
-/**************************************************************/
-/**\name	INTERRUPT SATAUS FOR WHOLE 0x1E LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Status_2 Description - Reg Addr --> 0x1E, Bit --> 0...7 */
-#define BMI160_USER_INTR_STAT_2__POS               (0)
-#define BMI160_USER_INTR_STAT_2__LEN               (8)
-#define BMI160_USER_INTR_STAT_2__MSK               (0xFF)
-#define BMI160_USER_INTR_STAT_2__REG               \
-		(BMI160_USER_INTR_STAT_2_ADDR)
-/**************************************************************/
-/**\name	HIGH_G-XYZ AND SIGN LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Status_3 Description - Reg Addr --> (0x1F), Bit --> 0 */
-#define BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_X__POS               (0)
-#define BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_X__LEN               (1)
-#define BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_X__MSK               (0x01)
-#define BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_X__REG               \
-		(BMI160_USER_INTR_STAT_3_ADDR)
-
-/* Int_Status_3 Description - Reg Addr --> 0x1E, Bit --> 1 */
-#define BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_Y__POS               (1)
-#define BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_Y__LEN               (1)
-#define BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_Y__MSK               (0x02)
-#define BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_Y__REG               \
-		(BMI160_USER_INTR_STAT_3_ADDR)
-
-/* Int_Status_3 Description - Reg Addr --> (0x1F), Bit --> 2 */
-#define BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_Z__POS               (2)
-#define BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_Z__LEN               (1)
-#define BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_Z__MSK               (0x04)
-#define BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_Z__REG               \
-		(BMI160_USER_INTR_STAT_3_ADDR)
-
-/* Int_Status_3 Description - Reg Addr --> (0x1F), Bit --> 3 */
-#define BMI160_USER_INTR_STAT_3_HIGH_G_SIGN__POS               (3)
-#define BMI160_USER_INTR_STAT_3_HIGH_G_SIGN__LEN               (1)
-#define BMI160_USER_INTR_STAT_3_HIGH_G_SIGN__MSK               (0x08)
-#define BMI160_USER_INTR_STAT_3_HIGH_G_SIGN__REG               \
-		(BMI160_USER_INTR_STAT_3_ADDR)
-/**************************************************************/
-/**\name	ORIENT XY and Z AXIS LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Status_3 Description - Reg Addr --> (0x1F), Bit --> 4...5 */
-#define BMI160_USER_INTR_STAT_3_ORIENT_XY__POS               (4)
-#define BMI160_USER_INTR_STAT_3_ORIENT_XY__LEN               (2)
-#define BMI160_USER_INTR_STAT_3_ORIENT_XY__MSK               (0x30)
-#define BMI160_USER_INTR_STAT_3_ORIENT_XY__REG               \
-		(BMI160_USER_INTR_STAT_3_ADDR)
-
-/* Int_Status_3 Description - Reg Addr --> (0x1F), Bit --> 6 */
-#define BMI160_USER_INTR_STAT_3_ORIENT_Z__POS               (6)
-#define BMI160_USER_INTR_STAT_3_ORIENT_Z__LEN               (1)
-#define BMI160_USER_INTR_STAT_3_ORIENT_Z__MSK               (0x40)
-#define BMI160_USER_INTR_STAT_3_ORIENT_Z__REG               \
-		(BMI160_USER_INTR_STAT_3_ADDR)
-/**************************************************************/
-/**\name	FLAT LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Status_3 Description - Reg Addr --> (0x1F), Bit --> 7 */
-#define BMI160_USER_INTR_STAT_3_FLAT__POS               (7)
-#define BMI160_USER_INTR_STAT_3_FLAT__LEN               (1)
-#define BMI160_USER_INTR_STAT_3_FLAT__MSK               (0x80)
-#define BMI160_USER_INTR_STAT_3_FLAT__REG               \
-		(BMI160_USER_INTR_STAT_3_ADDR)
-/**************************************************************/
-/**\name	(0x1F) LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Status_3 Description - Reg Addr --> (0x1F), Bit --> 0...7 */
-#define BMI160_USER_INTR_STAT_3__POS               (0)
-#define BMI160_USER_INTR_STAT_3__LEN               (8)
-#define BMI160_USER_INTR_STAT_3__MSK               (0xFF)
-#define BMI160_USER_INTR_STAT_3__REG               \
-		(BMI160_USER_INTR_STAT_3_ADDR)
-/**************************************************************/
-/**\name	TEMPERATURE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Temperature Description - LSB Reg Addr --> (0x20), Bit --> 0...7 */
-#define BMI160_USER_TEMP_LSB_VALUE__POS               (0)
-#define BMI160_USER_TEMP_LSB_VALUE__LEN               (8)
-#define BMI160_USER_TEMP_LSB_VALUE__MSK               (0xFF)
-#define BMI160_USER_TEMP_LSB_VALUE__REG               \
-		(BMI160_USER_TEMPERATURE_0_ADDR)
-
-/* Temperature Description - LSB Reg Addr --> 0x21, Bit --> 0...7 */
-#define BMI160_USER_TEMP_MSB_VALUE__POS               (0)
-#define BMI160_USER_TEMP_MSB_VALUE__LEN               (8)
-#define BMI160_USER_TEMP_MSB_VALUE__MSK               (0xFF)
-#define BMI160_USER_TEMP_MSB_VALUE__REG               \
-		(BMI160_USER_TEMPERATURE_1_ADDR)
-/**************************************************************/
-/**\name	FIFO BYTE COUNTER LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Fifo_Length0 Description - Reg Addr --> 0x22, Bit --> 0...7 */
-#define BMI160_USER_FIFO_BYTE_COUNTER_LSB__POS           (0)
-#define BMI160_USER_FIFO_BYTE_COUNTER_LSB__LEN           (8)
-#define BMI160_USER_FIFO_BYTE_COUNTER_LSB__MSK          (0xFF)
-#define BMI160_USER_FIFO_BYTE_COUNTER_LSB__REG          \
-		(BMI160_USER_FIFO_LENGTH_0_ADDR)
-
-/*Fifo_Length1 Description - Reg Addr --> 0x23, Bit --> 0...2 */
-#define BMI160_USER_FIFO_BYTE_COUNTER_MSB__POS           (0)
-#define BMI160_USER_FIFO_BYTE_COUNTER_MSB__LEN           3
-#define BMI160_USER_FIFO_BYTE_COUNTER_MSB__MSK          (0x07)
-#define BMI160_USER_FIFO_BYTE_COUNTER_MSB__REG          \
-		(BMI160_USER_FIFO_LENGTH_1_ADDR)
-
-/**************************************************************/
-/**\name	FIFO DATA LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Fifo_Data Description - Reg Addr --> 0x24, Bit --> 0...7 */
-#define BMI160_USER_FIFO_DATA__POS           (0)
-#define BMI160_USER_FIFO_DATA__LEN           (8)
-#define BMI160_USER_FIFO_DATA__MSK          (0xFF)
-#define BMI160_USER_FIFO_DATA__REG          (BMI160_USER_FIFO_DATA_ADDR)
-
-/**************************************************************/
-/**\name	ACCEL CONFIGURATION LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Acc_Conf Description - Reg Addr --> (0x40), Bit --> 0...3 */
-#define BMI160_USER_ACCEL_CONFIG_OUTPUT_DATA_RATE__POS               (0)
-#define BMI160_USER_ACCEL_CONFIG_OUTPUT_DATA_RATE__LEN               (4)
-#define BMI160_USER_ACCEL_CONFIG_OUTPUT_DATA_RATE__MSK               (0x0F)
-#define BMI160_USER_ACCEL_CONFIG_OUTPUT_DATA_RATE__REG		       \
-(BMI160_USER_ACCEL_CONFIG_ADDR)
-
-/* Acc_Conf Description - Reg Addr --> (0x40), Bit --> 4...6 */
-#define BMI160_USER_ACCEL_CONFIG_ACCEL_BW__POS               (4)
-#define BMI160_USER_ACCEL_CONFIG_ACCEL_BW__LEN               (3)
-#define BMI160_USER_ACCEL_CONFIG_ACCEL_BW__MSK               (0x70)
-#define BMI160_USER_ACCEL_CONFIG_ACCEL_BW__REG	(BMI160_USER_ACCEL_CONFIG_ADDR)
-
-/* Acc_Conf Description - Reg Addr --> (0x40), Bit --> 7 */
-#define BMI160_USER_ACCEL_CONFIG_ACCEL_UNDER_SAMPLING__POS           (7)
-#define BMI160_USER_ACCEL_CONFIG_ACCEL_UNDER_SAMPLING__LEN           (1)
-#define BMI160_USER_ACCEL_CONFIG_ACCEL_UNDER_SAMPLING__MSK           (0x80)
-#define BMI160_USER_ACCEL_CONFIG_ACCEL_UNDER_SAMPLING__REG	\
-(BMI160_USER_ACCEL_CONFIG_ADDR)
-
-/* Acc_Range Description - Reg Addr --> 0x41, Bit --> 0...3 */
-#define BMI160_USER_ACCEL_RANGE__POS               (0)
-#define BMI160_USER_ACCEL_RANGE__LEN               (4)
-#define BMI160_USER_ACCEL_RANGE__MSK               (0x0F)
-#define BMI160_USER_ACCEL_RANGE__REG              \
-(BMI160_USER_ACCEL_RANGE_ADDR)
-/**************************************************************/
-/**\name	GYRO CONFIGURATION LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Gyro_Conf Description - Reg Addr --> (0x42), Bit --> 0...3 */
-#define BMI160_USER_GYRO_CONFIG_OUTPUT_DATA_RATE__POS               (0)
-#define BMI160_USER_GYRO_CONFIG_OUTPUT_DATA_RATE__LEN               (4)
-#define BMI160_USER_GYRO_CONFIG_OUTPUT_DATA_RATE__MSK               (0x0F)
-#define BMI160_USER_GYRO_CONFIG_OUTPUT_DATA_RATE__REG               \
-(BMI160_USER_GYRO_CONFIG_ADDR)
-
-/* Gyro_Conf Description - Reg Addr --> (0x42), Bit --> 4...5 */
-#define BMI160_USER_GYRO_CONFIG_BW__POS               (4)
-#define BMI160_USER_GYRO_CONFIG_BW__LEN               (2)
-#define BMI160_USER_GYRO_CONFIG_BW__MSK               (0x30)
-#define BMI160_USER_GYRO_CONFIG_BW__REG               \
-(BMI160_USER_GYRO_CONFIG_ADDR)
-
-/* Gyr_Range Description - Reg Addr --> 0x43, Bit --> 0...2 */
-#define BMI160_USER_GYRO_RANGE__POS               (0)
-#define BMI160_USER_GYRO_RANGE__LEN               (3)
-#define BMI160_USER_GYRO_RANGE__MSK               (0x07)
-#define BMI160_USER_GYRO_RANGE__REG               (BMI160_USER_GYRO_RANGE_ADDR)
-/**************************************************************/
-/**\name	MAG CONFIGURATION LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Mag_Conf Description - Reg Addr --> (0x44), Bit --> 0...3 */
-#define BMI160_USER_MAG_CONFIG_OUTPUT_DATA_RATE__POS               (0)
-#define BMI160_USER_MAG_CONFIG_OUTPUT_DATA_RATE__LEN               (4)
-#define BMI160_USER_MAG_CONFIG_OUTPUT_DATA_RATE__MSK               (0x0F)
-#define BMI160_USER_MAG_CONFIG_OUTPUT_DATA_RATE__REG               \
-(BMI160_USER_MAG_CONFIG_ADDR)
-/**************************************************************/
-/**\name	FIFO DOWNS LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Fifo_Downs Description - Reg Addr --> 0x45, Bit --> 0...2 */
-#define BMI160_USER_FIFO_DOWN_GYRO__POS               (0)
-#define BMI160_USER_FIFO_DOWN_GYRO__LEN               (3)
-#define BMI160_USER_FIFO_DOWN_GYRO__MSK               (0x07)
-#define BMI160_USER_FIFO_DOWN_GYRO__REG	(BMI160_USER_FIFO_DOWN_ADDR)
-/**************************************************************/
-/**\name	FIFO FILTER FOR ACCEL AND GYRO LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Fifo_filt Description - Reg Addr --> 0x45, Bit --> 3 */
-#define BMI160_USER_FIFO_FILTER_GYRO__POS               (3)
-#define BMI160_USER_FIFO_FILTER_GYRO__LEN               (1)
-#define BMI160_USER_FIFO_FILTER_GYRO__MSK               (0x08)
-#define BMI160_USER_FIFO_FILTER_GYRO__REG	  (BMI160_USER_FIFO_DOWN_ADDR)
-
-/* Fifo_Downs Description - Reg Addr --> 0x45, Bit --> 4...6 */
-#define BMI160_USER_FIFO_DOWN_ACCEL__POS               (4)
-#define BMI160_USER_FIFO_DOWN_ACCEL__LEN               (3)
-#define BMI160_USER_FIFO_DOWN_ACCEL__MSK               (0x70)
-#define BMI160_USER_FIFO_DOWN_ACCEL__REG	(BMI160_USER_FIFO_DOWN_ADDR)
-
-/* Fifo_FILT Description - Reg Addr --> 0x45, Bit --> 7 */
-#define BMI160_USER_FIFO_FILTER_ACCEL__POS               (7)
-#define BMI160_USER_FIFO_FILTER_ACCEL__LEN               (1)
-#define BMI160_USER_FIFO_FILTER_ACCEL__MSK               (0x80)
-#define BMI160_USER_FIFO_FILTER_ACCEL__REG	(BMI160_USER_FIFO_DOWN_ADDR)
-/**************************************************************/
-/**\name	FIFO WATER MARK LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Fifo_Config_0 Description - Reg Addr --> 0x46, Bit --> 0...7 */
-#define BMI160_USER_FIFO_WM__POS               (0)
-#define BMI160_USER_FIFO_WM__LEN               (8)
-#define BMI160_USER_FIFO_WM__MSK               (0xFF)
-#define BMI160_USER_FIFO_WM__REG	(BMI160_USER_FIFO_CONFIG_0_ADDR)
-/**************************************************************/
-/**\name	FIFO TIME LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Fifo_Config_1 Description - Reg Addr --> 0x47, Bit --> 1 */
-#define BMI160_USER_FIFO_TIME_ENABLE__POS               (1)
-#define BMI160_USER_FIFO_TIME_ENABLE__LEN               (1)
-#define BMI160_USER_FIFO_TIME_ENABLE__MSK               (0x02)
-#define BMI160_USER_FIFO_TIME_ENABLE__REG	(BMI160_USER_FIFO_CONFIG_1_ADDR)
-/**************************************************************/
-/**\name	FIFO TAG INTERRUPT LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Fifo_Config_1 Description - Reg Addr --> 0x47, Bit --> 2 */
-#define BMI160_USER_FIFO_TAG_INTR2_ENABLE__POS               (2)
-#define BMI160_USER_FIFO_TAG_INTR2_ENABLE__LEN               (1)
-#define BMI160_USER_FIFO_TAG_INTR2_ENABLE__MSK               (0x04)
-#define BMI160_USER_FIFO_TAG_INTR2_ENABLE__REG	(BMI160_USER_FIFO_CONFIG_1_ADDR)
-
-/* Fifo_Config_1 Description - Reg Addr --> 0x47, Bit --> 3 */
-#define BMI160_USER_FIFO_TAG_INTR1_ENABLE__POS               (3)
-#define BMI160_USER_FIFO_TAG_INTR1_ENABLE__LEN               (1)
-#define BMI160_USER_FIFO_TAG_INTR1_ENABLE__MSK               (0x08)
-#define BMI160_USER_FIFO_TAG_INTR1_ENABLE__REG	(BMI160_USER_FIFO_CONFIG_1_ADDR)
-/**************************************************************/
-/**\name	FIFO HEADER LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Fifo_Config_1 Description - Reg Addr --> 0x47, Bit --> 4 */
-#define BMI160_USER_FIFO_HEADER_ENABLE__POS               (4)
-#define BMI160_USER_FIFO_HEADER_ENABLE__LEN               (1)
-#define BMI160_USER_FIFO_HEADER_ENABLE__MSK               (0x10)
-#define BMI160_USER_FIFO_HEADER_ENABLE__REG		         \
-(BMI160_USER_FIFO_CONFIG_1_ADDR)
-/**************************************************************/
-/**\name	FIFO MAG ENABLE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Fifo_Config_1 Description - Reg Addr --> 0x47, Bit --> 5 */
-#define BMI160_USER_FIFO_MAG_ENABLE__POS               (5)
-#define BMI160_USER_FIFO_MAG_ENABLE__LEN               (1)
-#define BMI160_USER_FIFO_MAG_ENABLE__MSK               (0x20)
-#define BMI160_USER_FIFO_MAG_ENABLE__REG		     \
-(BMI160_USER_FIFO_CONFIG_1_ADDR)
-/**************************************************************/
-/**\name	FIFO ACCEL ENABLE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Fifo_Config_1 Description - Reg Addr --> 0x47, Bit --> 6 */
-#define BMI160_USER_FIFO_ACCEL_ENABLE__POS               (6)
-#define BMI160_USER_FIFO_ACCEL_ENABLE__LEN               (1)
-#define BMI160_USER_FIFO_ACCEL_ENABLE__MSK               (0x40)
-#define BMI160_USER_FIFO_ACCEL_ENABLE__REG		        \
-(BMI160_USER_FIFO_CONFIG_1_ADDR)
-/**************************************************************/
-/**\name	FIFO GYRO ENABLE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Fifo_Config_1 Description - Reg Addr --> 0x47, Bit --> 7 */
-#define BMI160_USER_FIFO_GYRO_ENABLE__POS               (7)
-#define BMI160_USER_FIFO_GYRO_ENABLE__LEN               (1)
-#define BMI160_USER_FIFO_GYRO_ENABLE__MSK               (0x80)
-#define BMI160_USER_FIFO_GYRO_ENABLE__REG		       \
-(BMI160_USER_FIFO_CONFIG_1_ADDR)
-
-/**************************************************************/
-/**\name	MAG I2C ADDRESS SELECTION LENGTH, POSITION AND MASK*/
-/**************************************************************/
-
-/* Mag_IF_0 Description - Reg Addr --> 0x4b, Bit --> 1...7 */
-#define BMI160_USER_I2C_DEVICE_ADDR__POS               (1)
-#define BMI160_USER_I2C_DEVICE_ADDR__LEN               (7)
-#define BMI160_USER_I2C_DEVICE_ADDR__MSK               (0xFE)
-#define BMI160_USER_I2C_DEVICE_ADDR__REG	(BMI160_USER_MAG_IF_0_ADDR)
-/**************************************************************/
-/**\name MAG CONFIGURATION FOR SECONDARY
-	INTERFACE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Mag_IF_1 Description - Reg Addr --> 0x4c, Bit --> 0...1 */
-#define BMI160_USER_MAG_BURST__POS               (0)
-#define BMI160_USER_MAG_BURST__LEN               (2)
-#define BMI160_USER_MAG_BURST__MSK               (0x03)
-#define BMI160_USER_MAG_BURST__REG               (BMI160_USER_MAG_IF_1_ADDR)
-
-/* Mag_IF_1 Description - Reg Addr --> 0x4c, Bit --> 2...5 */
-#define BMI160_USER_MAG_OFFSET__POS               (2)
-#define BMI160_USER_MAG_OFFSET__LEN               (4)
-#define BMI160_USER_MAG_OFFSET__MSK               (0x3C)
-#define BMI160_USER_MAG_OFFSET__REG               (BMI160_USER_MAG_IF_1_ADDR)
-
-/* Mag_IF_1 Description - Reg Addr --> 0x4c, Bit --> 7 */
-#define BMI160_USER_MAG_MANUAL_ENABLE__POS               (7)
-#define BMI160_USER_MAG_MANUAL_ENABLE__LEN               (1)
-#define BMI160_USER_MAG_MANUAL_ENABLE__MSK               (0x80)
-#define BMI160_USER_MAG_MANUAL_ENABLE__REG               \
-(BMI160_USER_MAG_IF_1_ADDR)
-
-/* Mag_IF_2 Description - Reg Addr --> 0x4d, Bit -->0... 7 */
-#define BMI160_USER_READ_ADDR__POS               (0)
-#define BMI160_USER_READ_ADDR__LEN               (8)
-#define BMI160_USER_READ_ADDR__MSK               (0xFF)
-#define BMI160_USER_READ_ADDR__REG               (BMI160_USER_MAG_IF_2_ADDR)
-
-/* Mag_IF_3 Description - Reg Addr --> 0x4e, Bit -->0... 7 */
-#define BMI160_USER_WRITE_ADDR__POS               (0)
-#define BMI160_USER_WRITE_ADDR__LEN               (8)
-#define BMI160_USER_WRITE_ADDR__MSK               (0xFF)
-#define BMI160_USER_WRITE_ADDR__REG               (BMI160_USER_MAG_IF_3_ADDR)
-
-/* Mag_IF_4 Description - Reg Addr --> 0x4f, Bit -->0... 7 */
-#define BMI160_USER_WRITE_DATA__POS               (0)
-#define BMI160_USER_WRITE_DATA__LEN               (8)
-#define BMI160_USER_WRITE_DATA__MSK               (0xFF)
-#define BMI160_USER_WRITE_DATA__REG               (BMI160_USER_MAG_IF_4_ADDR)
-/**************************************************************/
-/**\name	ANY MOTION XYZ AXIS ENABLE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_En_0 Description - Reg Addr --> 0x50, Bit -->0 */
-#define BMI160_USER_INTR_ENABLE_0_ANY_MOTION_X_ENABLE__POS               (0)
-#define BMI160_USER_INTR_ENABLE_0_ANY_MOTION_X_ENABLE__LEN               (1)
-#define BMI160_USER_INTR_ENABLE_0_ANY_MOTION_X_ENABLE__MSK               (0x01)
-#define BMI160_USER_INTR_ENABLE_0_ANY_MOTION_X_ENABLE__REG	              \
-(BMI160_USER_INTR_ENABLE_0_ADDR)
-
-/* Int_En_0 Description - Reg Addr --> 0x50, Bit -->1 */
-#define BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Y_ENABLE__POS               (1)
-#define BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Y_ENABLE__LEN               (1)
-#define BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Y_ENABLE__MSK               (0x02)
-#define BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Y_ENABLE__REG	          \
-(BMI160_USER_INTR_ENABLE_0_ADDR)
-
-/* Int_En_0 Description - Reg Addr --> 0x50, Bit -->2 */
-#define BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Z_ENABLE__POS               (2)
-#define BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Z_ENABLE__LEN               (1)
-#define BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Z_ENABLE__MSK               (0x04)
-#define BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Z_ENABLE__REG	            \
-(BMI160_USER_INTR_ENABLE_0_ADDR)
-/**************************************************************/
-/**\name	DOUBLE TAP ENABLE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_En_0 Description - Reg Addr --> 0x50, Bit -->4 */
-#define BMI160_USER_INTR_ENABLE_0_DOUBLE_TAP_ENABLE__POS               (4)
-#define BMI160_USER_INTR_ENABLE_0_DOUBLE_TAP_ENABLE__LEN               (1)
-#define BMI160_USER_INTR_ENABLE_0_DOUBLE_TAP_ENABLE__MSK               (0x10)
-#define BMI160_USER_INTR_ENABLE_0_DOUBLE_TAP_ENABLE__REG	        \
-(BMI160_USER_INTR_ENABLE_0_ADDR)
-/**************************************************************/
-/**\name	SINGLE TAP ENABLE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_En_0 Description - Reg Addr --> 0x50, Bit -->5 */
-#define BMI160_USER_INTR_ENABLE_0_SINGLE_TAP_ENABLE__POS               (5)
-#define BMI160_USER_INTR_ENABLE_0_SINGLE_TAP_ENABLE__LEN               (1)
-#define BMI160_USER_INTR_ENABLE_0_SINGLE_TAP_ENABLE__MSK               (0x20)
-#define BMI160_USER_INTR_ENABLE_0_SINGLE_TAP_ENABLE__REG	       \
-(BMI160_USER_INTR_ENABLE_0_ADDR)
-/**************************************************************/
-/**\name	ORIENT ENABLE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_En_0 Description - Reg Addr --> 0x50, Bit -->6 */
-#define BMI160_USER_INTR_ENABLE_0_ORIENT_ENABLE__POS               (6)
-#define BMI160_USER_INTR_ENABLE_0_ORIENT_ENABLE__LEN               (1)
-#define BMI160_USER_INTR_ENABLE_0_ORIENT_ENABLE__MSK               (0x40)
-#define BMI160_USER_INTR_ENABLE_0_ORIENT_ENABLE__REG	           \
-(BMI160_USER_INTR_ENABLE_0_ADDR)
-/**************************************************************/
-/**\name	FLAT ENABLE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_En_0 Description - Reg Addr --> 0x50, Bit -->7 */
-#define BMI160_USER_INTR_ENABLE_0_FLAT_ENABLE__POS               (7)
-#define BMI160_USER_INTR_ENABLE_0_FLAT_ENABLE__LEN               (1)
-#define BMI160_USER_INTR_ENABLE_0_FLAT_ENABLE__MSK               (0x80)
-#define BMI160_USER_INTR_ENABLE_0_FLAT_ENABLE__REG	           \
-(BMI160_USER_INTR_ENABLE_0_ADDR)
-/**************************************************************/
-/**\name	HIGH_G XYZ ENABLE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_En_1 Description - Reg Addr --> (0x51), Bit -->0 */
-#define BMI160_USER_INTR_ENABLE_1_HIGH_G_X_ENABLE__POS               (0)
-#define BMI160_USER_INTR_ENABLE_1_HIGH_G_X_ENABLE__LEN               (1)
-#define BMI160_USER_INTR_ENABLE_1_HIGH_G_X_ENABLE__MSK               (0x01)
-#define BMI160_USER_INTR_ENABLE_1_HIGH_G_X_ENABLE__REG	           \
-(BMI160_USER_INTR_ENABLE_1_ADDR)
-
-/* Int_En_1 Description - Reg Addr --> (0x51), Bit -->1 */
-#define BMI160_USER_INTR_ENABLE_1_HIGH_G_Y_ENABLE__POS               (1)
-#define BMI160_USER_INTR_ENABLE_1_HIGH_G_Y_ENABLE__LEN               (1)
-#define BMI160_USER_INTR_ENABLE_1_HIGH_G_Y_ENABLE__MSK               (0x02)
-#define BMI160_USER_INTR_ENABLE_1_HIGH_G_Y_ENABLE__REG	           \
-(BMI160_USER_INTR_ENABLE_1_ADDR)
-
-/* Int_En_1 Description - Reg Addr --> (0x51), Bit -->2 */
-#define BMI160_USER_INTR_ENABLE_1_HIGH_G_Z_ENABLE__POS               (2)
-#define BMI160_USER_INTR_ENABLE_1_HIGH_G_Z_ENABLE__LEN               (1)
-#define BMI160_USER_INTR_ENABLE_1_HIGH_G_Z_ENABLE__MSK               (0x04)
-#define BMI160_USER_INTR_ENABLE_1_HIGH_G_Z_ENABLE__REG	           \
-(BMI160_USER_INTR_ENABLE_1_ADDR)
-/**************************************************************/
-/**\name	LOW_G ENABLE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_En_1 Description - Reg Addr --> (0x51), Bit -->3 */
-#define BMI160_USER_INTR_ENABLE_1_LOW_G_ENABLE__POS               (3)
-#define BMI160_USER_INTR_ENABLE_1_LOW_G_ENABLE__LEN               (1)
-#define BMI160_USER_INTR_ENABLE_1_LOW_G_ENABLE__MSK               (0x08)
-#define BMI160_USER_INTR_ENABLE_1_LOW_G_ENABLE__REG	          \
-(BMI160_USER_INTR_ENABLE_1_ADDR)
-/**************************************************************/
-/**\name	DATA READY ENABLE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_En_1 Description - Reg Addr --> (0x51), Bit -->4 */
-#define BMI160_USER_INTR_ENABLE_1_DATA_RDY_ENABLE__POS               (4)
-#define BMI160_USER_INTR_ENABLE_1_DATA_RDY_ENABLE__LEN               (1)
-#define BMI160_USER_INTR_ENABLE_1_DATA_RDY_ENABLE__MSK               (0x10)
-#define BMI160_USER_INTR_ENABLE_1_DATA_RDY_ENABLE__REG	            \
-(BMI160_USER_INTR_ENABLE_1_ADDR)
-/**************************************************************/
-/**\name	FIFO FULL AND WATER MARK ENABLE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_En_1 Description - Reg Addr --> (0x51), Bit -->5 */
-#define BMI160_USER_INTR_ENABLE_1_FIFO_FULL_ENABLE__POS               (5)
-#define BMI160_USER_INTR_ENABLE_1_FIFO_FULL_ENABLE__LEN               (1)
-#define BMI160_USER_INTR_ENABLE_1_FIFO_FULL_ENABLE__MSK               (0x20)
-#define BMI160_USER_INTR_ENABLE_1_FIFO_FULL_ENABLE__REG	              \
-(BMI160_USER_INTR_ENABLE_1_ADDR)
-
-/* Int_En_1 Description - Reg Addr --> (0x51), Bit -->6 */
-#define BMI160_USER_INTR_ENABLE_1_FIFO_WM_ENABLE__POS               (6)
-#define BMI160_USER_INTR_ENABLE_1_FIFO_WM_ENABLE__LEN               (1)
-#define BMI160_USER_INTR_ENABLE_1_FIFO_WM_ENABLE__MSK               (0x40)
-#define BMI160_USER_INTR_ENABLE_1_FIFO_WM_ENABLE__REG	           \
-(BMI160_USER_INTR_ENABLE_1_ADDR)
-/**************************************************************/
-/**\name	NO MOTION XYZ ENABLE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_En_2 Description - Reg Addr --> (0x52), Bit -->0 */
-#define BMI160_USER_INTR_ENABLE_2_NOMOTION_X_ENABLE__POS               (0)
-#define BMI160_USER_INTR_ENABLE_2_NOMOTION_X_ENABLE__LEN               (1)
-#define BMI160_USER_INTR_ENABLE_2_NOMOTION_X_ENABLE__MSK               (0x01)
-#define BMI160_USER_INTR_ENABLE_2_NOMOTION_X_ENABLE__REG	  \
-(BMI160_USER_INTR_ENABLE_2_ADDR)
-
-/* Int_En_2 Description - Reg Addr --> (0x52), Bit -->1 */
-#define BMI160_USER_INTR_ENABLE_2_NOMOTION_Y_ENABLE__POS               (1)
-#define BMI160_USER_INTR_ENABLE_2_NOMOTION_Y_ENABLE__LEN               (1)
-#define BMI160_USER_INTR_ENABLE_2_NOMOTION_Y_ENABLE__MSK               (0x02)
-#define BMI160_USER_INTR_ENABLE_2_NOMOTION_Y_ENABLE__REG	  \
-(BMI160_USER_INTR_ENABLE_2_ADDR)
-
-/* Int_En_2 Description - Reg Addr --> (0x52), Bit -->2 */
-#define BMI160_USER_INTR_ENABLE_2_NOMOTION_Z_ENABLE__POS               (2)
-#define BMI160_USER_INTR_ENABLE_2_NOMOTION_Z_ENABLE__LEN               (1)
-#define BMI160_USER_INTR_ENABLE_2_NOMOTION_Z_ENABLE__MSK               (0x04)
-#define BMI160_USER_INTR_ENABLE_2_NOMOTION_Z_ENABLE__REG	  \
-(BMI160_USER_INTR_ENABLE_2_ADDR)
-/**************************************************************/
-/**\name	STEP DETECTOR ENABLE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_En_2 Description - Reg Addr --> (0x52), Bit -->3 */
-#define BMI160_USER_INTR_ENABLE_2_STEP_DETECTOR_ENABLE__POS               (3)
-#define BMI160_USER_INTR_ENABLE_2_STEP_DETECTOR_ENABLE__LEN               (1)
-#define BMI160_USER_INTR_ENABLE_2_STEP_DETECTOR_ENABLE__MSK               (0x08)
-#define BMI160_USER_INTR_ENABLE_2_STEP_DETECTOR_ENABLE__REG	  \
-(BMI160_USER_INTR_ENABLE_2_ADDR)
-/**************************************************************/
-/**\name	EDGE CONTROL ENABLE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Out_Ctrl Description - Reg Addr --> 0x53, Bit -->0 */
-#define BMI160_USER_INTR1_EDGE_CTRL__POS               (0)
-#define BMI160_USER_INTR1_EDGE_CTRL__LEN               (1)
-#define BMI160_USER_INTR1_EDGE_CTRL__MSK               (0x01)
-#define BMI160_USER_INTR1_EDGE_CTRL__REG		\
-(BMI160_USER_INTR_OUT_CTRL_ADDR)
-/**************************************************************/
-/**\name	LEVEL CONTROL ENABLE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Out_Ctrl Description - Reg Addr --> 0x53, Bit -->1 */
-#define BMI160_USER_INTR1_LEVEL__POS               (1)
-#define BMI160_USER_INTR1_LEVEL__LEN               (1)
-#define BMI160_USER_INTR1_LEVEL__MSK               (0x02)
-#define BMI160_USER_INTR1_LEVEL__REG               \
-(BMI160_USER_INTR_OUT_CTRL_ADDR)
-/**************************************************************/
-/**\name	OUTPUT TYPE ENABLE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Out_Ctrl Description - Reg Addr --> 0x53, Bit -->2 */
-#define BMI160_USER_INTR1_OUTPUT_TYPE__POS               (2)
-#define BMI160_USER_INTR1_OUTPUT_TYPE__LEN               (1)
-#define BMI160_USER_INTR1_OUTPUT_TYPE__MSK               (0x04)
-#define BMI160_USER_INTR1_OUTPUT_TYPE__REG               \
-(BMI160_USER_INTR_OUT_CTRL_ADDR)
-/**************************************************************/
-/**\name	OUTPUT TYPE ENABLE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Out_Ctrl Description - Reg Addr --> 0x53, Bit -->3 */
-#define BMI160_USER_INTR1_OUTPUT_ENABLE__POS               (3)
-#define BMI160_USER_INTR1_OUTPUT_ENABLE__LEN               (1)
-#define BMI160_USER_INTR1_OUTPUT_ENABLE__MSK               (0x08)
-#define BMI160_USER_INTR1_OUTPUT_ENABLE__REG		\
-(BMI160_USER_INTR_OUT_CTRL_ADDR)
-/**************************************************************/
-/**\name	EDGE CONTROL ENABLE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Out_Ctrl Description - Reg Addr --> 0x53, Bit -->4 */
-#define BMI160_USER_INTR2_EDGE_CTRL__POS               (4)
-#define BMI160_USER_INTR2_EDGE_CTRL__LEN               (1)
-#define BMI160_USER_INTR2_EDGE_CTRL__MSK               (0x10)
-#define BMI160_USER_INTR2_EDGE_CTRL__REG		\
-(BMI160_USER_INTR_OUT_CTRL_ADDR)
-/**************************************************************/
-/**\name	LEVEL CONTROL ENABLE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Out_Ctrl Description - Reg Addr --> 0x53, Bit -->5 */
-#define BMI160_USER_INTR2_LEVEL__POS               (5)
-#define BMI160_USER_INTR2_LEVEL__LEN               (1)
-#define BMI160_USER_INTR2_LEVEL__MSK               (0x20)
-#define BMI160_USER_INTR2_LEVEL__REG               \
-(BMI160_USER_INTR_OUT_CTRL_ADDR)
-/**************************************************************/
-/**\name	OUTPUT TYPE ENABLE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Out_Ctrl Description - Reg Addr --> 0x53, Bit -->6 */
-#define BMI160_USER_INTR2_OUTPUT_TYPE__POS               (6)
-#define BMI160_USER_INTR2_OUTPUT_TYPE__LEN               (1)
-#define BMI160_USER_INTR2_OUTPUT_TYPE__MSK               (0x40)
-#define BMI160_USER_INTR2_OUTPUT_TYPE__REG               \
-(BMI160_USER_INTR_OUT_CTRL_ADDR)
-
-/* Int_Out_Ctrl Description - Reg Addr --> 0x53, Bit -->7 */
-#define BMI160_USER_INTR2_OUTPUT_EN__POS               (7)
-#define BMI160_USER_INTR2_OUTPUT_EN__LEN               (1)
-#define BMI160_USER_INTR2_OUTPUT_EN__MSK               (0x80)
-#define BMI160_USER_INTR2_OUTPUT_EN__REG		\
-(BMI160_USER_INTR_OUT_CTRL_ADDR)
-/**************************************************************/
-/**\name	LATCH INTERRUPT LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Latch Description - Reg Addr --> 0x54, Bit -->0...3 */
-#define BMI160_USER_INTR_LATCH__POS               (0)
-#define BMI160_USER_INTR_LATCH__LEN               (4)
-#define BMI160_USER_INTR_LATCH__MSK               (0x0F)
-#define BMI160_USER_INTR_LATCH__REG               (BMI160_USER_INTR_LATCH_ADDR)
-/**************************************************************/
-/**\name	INPUT ENABLE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Latch Description - Reg Addr --> 0x54, Bit -->4 */
-#define BMI160_USER_INTR1_INPUT_ENABLE__POS               (4)
-#define BMI160_USER_INTR1_INPUT_ENABLE__LEN               (1)
-#define BMI160_USER_INTR1_INPUT_ENABLE__MSK               (0x10)
-#define BMI160_USER_INTR1_INPUT_ENABLE__REG               \
-(BMI160_USER_INTR_LATCH_ADDR)
-
-/* Int_Latch Description - Reg Addr --> 0x54, Bit -->5*/
-#define BMI160_USER_INTR2_INPUT_ENABLE__POS               (5)
-#define BMI160_USER_INTR2_INPUT_ENABLE__LEN               (1)
-#define BMI160_USER_INTR2_INPUT_ENABLE__MSK               (0x20)
-#define BMI160_USER_INTR2_INPUT_ENABLE__REG              \
-(BMI160_USER_INTR_LATCH_ADDR)
-/**************************************************************/
-/**\name	INTERRUPT1 MAPPIONG OF LOW_G LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Map_0 Description - Reg Addr --> 0x55, Bit -->0 */
-#define BMI160_USER_INTR_MAP_0_INTR1_LOW_G__POS               (0)
-#define BMI160_USER_INTR_MAP_0_INTR1_LOW_G__LEN               (1)
-#define BMI160_USER_INTR_MAP_0_INTR1_LOW_G__MSK               (0x01)
-#define BMI160_USER_INTR_MAP_0_INTR1_LOW_G__REG	(BMI160_USER_INTR_MAP_0_ADDR)
-/**************************************************************/
-/**\name	INTERRUPT1 MAPPIONG OF HIGH_G LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Map_0 Description - Reg Addr --> 0x55, Bit -->1 */
-#define BMI160_USER_INTR_MAP_0_INTR1_HIGH_G__POS               (1)
-#define BMI160_USER_INTR_MAP_0_INTR1_HIGH_G__LEN               (1)
-#define BMI160_USER_INTR_MAP_0_INTR1_HIGH_G__MSK               (0x02)
-#define BMI160_USER_INTR_MAP_0_INTR1_HIGH_G__REG	\
-(BMI160_USER_INTR_MAP_0_ADDR)
-/**************************************************************/
-/**\name	INTERRUPT MAPPIONG OF ANY MOTION_G LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Map_0 Description - Reg Addr --> 0x55, Bit -->2 */
-#define BMI160_USER_INTR_MAP_0_INTR1_ANY_MOTION__POS               (2)
-#define BMI160_USER_INTR_MAP_0_INTR1_ANY_MOTION__LEN               (1)
-#define BMI160_USER_INTR_MAP_0_INTR1_ANY_MOTION__MSK               (0x04)
-#define BMI160_USER_INTR_MAP_0_INTR1_ANY_MOTION__REG            \
-(BMI160_USER_INTR_MAP_0_ADDR)
-/**************************************************************/
-/**\name	INTERRUPT1 MAPPIONG OF NO MOTION LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Map_0 Description - Reg Addr --> 0x55, Bit -->3 */
-#define BMI160_USER_INTR_MAP_0_INTR1_NOMOTION__POS               (3)
-#define BMI160_USER_INTR_MAP_0_INTR1_NOMOTION__LEN               (1)
-#define BMI160_USER_INTR_MAP_0_INTR1_NOMOTION__MSK               (0x08)
-#define BMI160_USER_INTR_MAP_0_INTR1_NOMOTION__REG (BMI160_USER_INTR_MAP_0_ADDR)
-/**************************************************************/
-/**\name	INTERRUPT1 MAPPIONG OF DOUBLE TAP LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Map_0 Description - Reg Addr --> 0x55, Bit -->4 */
-#define BMI160_USER_INTR_MAP_0_INTR1_DOUBLE_TAP__POS               (4)
-#define BMI160_USER_INTR_MAP_0_INTR1_DOUBLE_TAP__LEN               (1)
-#define BMI160_USER_INTR_MAP_0_INTR1_DOUBLE_TAP__MSK               (0x10)
-#define BMI160_USER_INTR_MAP_0_INTR1_DOUBLE_TAP__REG	\
-(BMI160_USER_INTR_MAP_0_ADDR)
-/**************************************************************/
-/**\name	INTERRUPT1 MAPPIONG OF SINGLE TAP LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Map_0 Description - Reg Addr --> 0x55, Bit -->5 */
-#define BMI160_USER_INTR_MAP_0_INTR1_SINGLE_TAP__POS               (5)
-#define BMI160_USER_INTR_MAP_0_INTR1_SINGLE_TAP__LEN               (1)
-#define BMI160_USER_INTR_MAP_0_INTR1_SINGLE_TAP__MSK               (0x20)
-#define BMI160_USER_INTR_MAP_0_INTR1_SINGLE_TAP__REG	      \
-(BMI160_USER_INTR_MAP_0_ADDR)
-/**************************************************************/
-/**\name	INTERRUPT1 MAPPIONG OF ORIENT LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Map_0 Description - Reg Addr --> 0x55, Bit -->6 */
-#define BMI160_USER_INTR_MAP_0_INTR1_ORIENT__POS               (6)
-#define BMI160_USER_INTR_MAP_0_INTR1_ORIENT__LEN               (1)
-#define BMI160_USER_INTR_MAP_0_INTR1_ORIENT__MSK               (0x40)
-#define BMI160_USER_INTR_MAP_0_INTR1_ORIENT__REG	          \
-(BMI160_USER_INTR_MAP_0_ADDR)
-/**************************************************************/
-/**\name	INTERRUPT MAPPIONG OF FLAT LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Map_0 Description - Reg Addr --> 0x56, Bit -->7 */
-#define BMI160_USER_INTR_MAP_0_INTR1_FLAT__POS               (7)
-#define BMI160_USER_INTR_MAP_0_INTR1_FLAT__LEN               (1)
-#define BMI160_USER_INTR_MAP_0_INTR1_FLAT__MSK               (0x80)
-#define BMI160_USER_INTR_MAP_0_INTR1_FLAT__REG	(BMI160_USER_INTR_MAP_0_ADDR)
-/**************************************************************/
-/**\name	INTERRUPT1 MAPPIONG OF PMU TRIGGER LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Map_1 Description - Reg Addr --> 0x56, Bit -->0 */
-#define BMI160_USER_INTR_MAP_1_INTR2_PMU_TRIG__POS               (0)
-#define BMI160_USER_INTR_MAP_1_INTR2_PMU_TRIG__LEN               (1)
-#define BMI160_USER_INTR_MAP_1_INTR2_PMU_TRIG__MSK               (0x01)
-#define BMI160_USER_INTR_MAP_1_INTR2_PMU_TRIG__REG (BMI160_USER_INTR_MAP_1_ADDR)
-/**************************************************************/
-/**\name	INTERRUPT1 MAPPIONG OF FIFO FULL AND
-	WATER MARK LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Map_1 Description - Reg Addr --> 0x56, Bit -->1 */
-#define BMI160_USER_INTR_MAP_1_INTR2_FIFO_FULL__POS               (1)
-#define BMI160_USER_INTR_MAP_1_INTR2_FIFO_FULL__LEN               (1)
-#define BMI160_USER_INTR_MAP_1_INTR2_FIFO_FULL__MSK               (0x02)
-#define BMI160_USER_INTR_MAP_1_INTR2_FIFO_FULL__REG	         \
-(BMI160_USER_INTR_MAP_1_ADDR)
-
-/* Int_Map_1 Description - Reg Addr --> 0x56, Bit -->2 */
-#define BMI160_USER_INTR_MAP_1_INTR2_FIFO_WM__POS               (2)
-#define BMI160_USER_INTR_MAP_1_INTR2_FIFO_WM__LEN               (1)
-#define BMI160_USER_INTR_MAP_1_INTR2_FIFO_WM__MSK               (0x04)
-#define BMI160_USER_INTR_MAP_1_INTR2_FIFO_WM__REG	         \
-(BMI160_USER_INTR_MAP_1_ADDR)
-/**************************************************************/
-/**\name	INTERRUPT1 MAPPIONG OF DATA READY LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Map_1 Description - Reg Addr --> 0x56, Bit -->3 */
-#define BMI160_USER_INTR_MAP_1_INTR2_DATA_RDY__POS               (3)
-#define BMI160_USER_INTR_MAP_1_INTR2_DATA_RDY__LEN               (1)
-#define BMI160_USER_INTR_MAP_1_INTR2_DATA_RDY__MSK               (0x08)
-#define BMI160_USER_INTR_MAP_1_INTR2_DATA_RDY__REG	      \
-(BMI160_USER_INTR_MAP_1_ADDR)
-/**************************************************************/
-/**\name	INTERRUPT1 MAPPIONG OF PMU TRIGGER LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Map_1 Description - Reg Addr --> 0x56, Bit -->4 */
-#define BMI160_USER_INTR_MAP_1_INTR1_PMU_TRIG__POS               (4)
-#define BMI160_USER_INTR_MAP_1_INTR1_PMU_TRIG__LEN               (1)
-#define BMI160_USER_INTR_MAP_1_INTR1_PMU_TRIG__MSK               (0x10)
-#define BMI160_USER_INTR_MAP_1_INTR1_PMU_TRIG__REG (BMI160_USER_INTR_MAP_1_ADDR)
-/**************************************************************/
-/**\name	INTERRUPT1 MAPPIONG OF FIFO FULL AND
-	WATER MARK LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Map_1 Description - Reg Addr --> 0x56, Bit -->5 */
-#define BMI160_USER_INTR_MAP_1_INTR1_FIFO_FULL__POS               (5)
-#define BMI160_USER_INTR_MAP_1_INTR1_FIFO_FULL__LEN               (1)
-#define BMI160_USER_INTR_MAP_1_INTR1_FIFO_FULL__MSK               (0x20)
-#define BMI160_USER_INTR_MAP_1_INTR1_FIFO_FULL__REG	       \
-(BMI160_USER_INTR_MAP_1_ADDR)
-
-/* Int_Map_1 Description - Reg Addr --> 0x56, Bit -->6 */
-#define BMI160_USER_INTR_MAP_1_INTR1_FIFO_WM__POS               (6)
-#define BMI160_USER_INTR_MAP_1_INTR1_FIFO_WM__LEN               (1)
-#define BMI160_USER_INTR_MAP_1_INTR1_FIFO_WM__MSK               (0x40)
-#define BMI160_USER_INTR_MAP_1_INTR1_FIFO_WM__REG	\
-(BMI160_USER_INTR_MAP_1_ADDR)
-/**************************************************************/
-/**\name	INTERRUPT1 MAPPIONG OF DATA READY LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Map_1 Description - Reg Addr --> 0x56, Bit -->7 */
-#define BMI160_USER_INTR_MAP_1_INTR1_DATA_RDY__POS               (7)
-#define BMI160_USER_INTR_MAP_1_INTR1_DATA_RDY__LEN               (1)
-#define BMI160_USER_INTR_MAP_1_INTR1_DATA_RDY__MSK               (0x80)
-#define BMI160_USER_INTR_MAP_1_INTR1_DATA_RDY__REG	\
-(BMI160_USER_INTR_MAP_1_ADDR)
-/**************************************************************/
-/**\name	INTERRUPT2 MAPPIONG OF LOW_G LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Map_2 Description - Reg Addr --> 0x57, Bit -->0 */
-#define BMI160_USER_INTR_MAP_2_INTR2_LOW_G__POS               (0)
-#define BMI160_USER_INTR_MAP_2_INTR2_LOW_G__LEN               (1)
-#define BMI160_USER_INTR_MAP_2_INTR2_LOW_G__MSK               (0x01)
-#define BMI160_USER_INTR_MAP_2_INTR2_LOW_G__REG	(BMI160_USER_INTR_MAP_2_ADDR)
-/**************************************************************/
-/**\name	INTERRUPT2 MAPPIONG OF HIGH_G LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Map_2 Description - Reg Addr --> 0x57, Bit -->1 */
-#define BMI160_USER_INTR_MAP_2_INTR2_HIGH_G__POS               (1)
-#define BMI160_USER_INTR_MAP_2_INTR2_HIGH_G__LEN               (1)
-#define BMI160_USER_INTR_MAP_2_INTR2_HIGH_G__MSK               (0x02)
-#define BMI160_USER_INTR_MAP_2_INTR2_HIGH_G__REG	\
-(BMI160_USER_INTR_MAP_2_ADDR)
-/**************************************************************/
-/**\name	INTERRUPT2 MAPPIONG OF ANY MOTION LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Map_2 Description - Reg Addr --> 0x57, Bit -->2 */
-#define BMI160_USER_INTR_MAP_2_INTR2_ANY_MOTION__POS      (2)
-#define BMI160_USER_INTR_MAP_2_INTR2_ANY_MOTION__LEN      (1)
-#define BMI160_USER_INTR_MAP_2_INTR2_ANY_MOTION__MSK     (0x04)
-#define BMI160_USER_INTR_MAP_2_INTR2_ANY_MOTION__REG     \
-(BMI160_USER_INTR_MAP_2_ADDR)
-/**************************************************************/
-/**\name	INTERRUPT2 MAPPIONG OF NO MOTION LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Map_2 Description - Reg Addr --> 0x57, Bit -->3 */
-#define BMI160_USER_INTR_MAP_2_INTR2_NOMOTION__POS               (3)
-#define BMI160_USER_INTR_MAP_2_INTR2_NOMOTION__LEN               (1)
-#define BMI160_USER_INTR_MAP_2_INTR2_NOMOTION__MSK               (0x08)
-#define BMI160_USER_INTR_MAP_2_INTR2_NOMOTION__REG (BMI160_USER_INTR_MAP_2_ADDR)
-/**************************************************************/
-/**\name	INTERRUPT2 MAPPIONG OF DOUBLE TAP LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Map_2 Description - Reg Addr --> 0x57, Bit -->4 */
-#define BMI160_USER_INTR_MAP_2_INTR2_DOUBLE_TAP__POS               (4)
-#define BMI160_USER_INTR_MAP_2_INTR2_DOUBLE_TAP__LEN               (1)
-#define BMI160_USER_INTR_MAP_2_INTR2_DOUBLE_TAP__MSK               (0x10)
-#define BMI160_USER_INTR_MAP_2_INTR2_DOUBLE_TAP__REG	\
-(BMI160_USER_INTR_MAP_2_ADDR)
-/**************************************************************/
-/**\name	INTERRUPT2 MAPPIONG OF SINGLE TAP LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Map_2 Description - Reg Addr --> 0x57, Bit -->5 */
-#define BMI160_USER_INTR_MAP_2_INTR2_SINGLE_TAP__POS               (5)
-#define BMI160_USER_INTR_MAP_2_INTR2_SINGLE_TAP__LEN               (1)
-#define BMI160_USER_INTR_MAP_2_INTR2_SINGLE_TAP__MSK               (0x20)
-#define BMI160_USER_INTR_MAP_2_INTR2_SINGLE_TAP__REG	\
-(BMI160_USER_INTR_MAP_2_ADDR)
-/**************************************************************/
-/**\name	INTERRUPT2 MAPPIONG OF ORIENT LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Map_2 Description - Reg Addr --> 0x57, Bit -->6 */
-#define BMI160_USER_INTR_MAP_2_INTR2_ORIENT__POS               (6)
-#define BMI160_USER_INTR_MAP_2_INTR2_ORIENT__LEN               (1)
-#define BMI160_USER_INTR_MAP_2_INTR2_ORIENT__MSK               (0x40)
-#define BMI160_USER_INTR_MAP_2_INTR2_ORIENT__REG	\
-(BMI160_USER_INTR_MAP_2_ADDR)
-/**************************************************************/
-/**\name	INTERRUPT2 MAPPIONG OF FLAT LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Map_2 Description - Reg Addr --> 0x57, Bit -->7 */
-#define BMI160_USER_INTR_MAP_2_INTR2_FLAT__POS               (7)
-#define BMI160_USER_INTR_MAP_2_INTR2_FLAT__LEN               (1)
-#define BMI160_USER_INTR_MAP_2_INTR2_FLAT__MSK               (0x80)
-#define BMI160_USER_INTR_MAP_2_INTR2_FLAT__REG	(BMI160_USER_INTR_MAP_2_ADDR)
-
-/**************************************************************/
-/**\name	TAP SOURCE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Data_0 Description - Reg Addr --> 0x58, Bit --> 3 */
-#define BMI160_USER_INTR_DATA_0_INTR_TAP_SOURCE__POS               (3)
-#define BMI160_USER_INTR_DATA_0_INTR_TAP_SOURCE__LEN               (1)
-#define BMI160_USER_INTR_DATA_0_INTR_TAP_SOURCE__MSK               (0x08)
-#define BMI160_USER_INTR_DATA_0_INTR_TAP_SOURCE__REG	           \
-(BMI160_USER_INTR_DATA_0_ADDR)
-
-/**************************************************************/
-/**\name	HIGH SOURCE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Data_0 Description - Reg Addr --> 0x58, Bit --> 7 */
-#define BMI160_USER_INTR_DATA_0_INTR_LOW_HIGH_SOURCE__POS           (7)
-#define BMI160_USER_INTR_DATA_0_INTR_LOW_HIGH_SOURCE__LEN           (1)
-#define BMI160_USER_INTR_DATA_0_INTR_LOW_HIGH_SOURCE__MSK           (0x80)
-#define BMI160_USER_INTR_DATA_0_INTR_LOW_HIGH_SOURCE__REG            \
-(BMI160_USER_INTR_DATA_0_ADDR)
-
-/**************************************************************/
-/**\name	MOTION SOURCE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Data_1 Description - Reg Addr --> 0x59, Bit --> 7 */
-#define BMI160_USER_INTR_DATA_1_INTR_MOTION_SOURCE__POS               (7)
-#define BMI160_USER_INTR_DATA_1_INTR_MOTION_SOURCE__LEN               (1)
-#define BMI160_USER_INTR_DATA_1_INTR_MOTION_SOURCE__MSK               (0x80)
-#define BMI160_USER_INTR_DATA_1_INTR_MOTION_SOURCE__REG               \
-		(BMI160_USER_INTR_DATA_1_ADDR)
-/**************************************************************/
-/**\name	LOW HIGH DURATION LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_LowHigh_0 Description - Reg Addr --> 0x5a, Bit --> 0...7 */
-#define BMI160_USER_INTR_LOWHIGH_0_INTR_LOW_DURN__POS               (0)
-#define BMI160_USER_INTR_LOWHIGH_0_INTR_LOW_DURN__LEN               (8)
-#define BMI160_USER_INTR_LOWHIGH_0_INTR_LOW_DURN__MSK               (0xFF)
-#define BMI160_USER_INTR_LOWHIGH_0_INTR_LOW_DURN__REG               \
-		(BMI160_USER_INTR_LOWHIGH_0_ADDR)
-/**************************************************************/
-/**\name	LOW THRESHOLD LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_LowHigh_1 Description - Reg Addr --> 0x5b, Bit --> 0...7 */
-#define BMI160_USER_INTR_LOWHIGH_1_INTR_LOW_THRES__POS               (0)
-#define BMI160_USER_INTR_LOWHIGH_1_INTR_LOW_THRES__LEN               (8)
-#define BMI160_USER_INTR_LOWHIGH_1_INTR_LOW_THRES__MSK               (0xFF)
-#define BMI160_USER_INTR_LOWHIGH_1_INTR_LOW_THRES__REG               \
-		(BMI160_USER_INTR_LOWHIGH_1_ADDR)
-/**************************************************************/
-/**\name	LOW HYSTERESIS LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_LowHigh_2 Description - Reg Addr --> 0x5c, Bit --> 0...1 */
-#define BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_HYST__POS               (0)
-#define BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_HYST__LEN               (2)
-#define BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_HYST__MSK               (0x03)
-#define BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_HYST__REG               \
-		(BMI160_USER_INTR_LOWHIGH_2_ADDR)
-/**************************************************************/
-/**\name	LOW MODE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_LowHigh_2 Description - Reg Addr --> 0x5c, Bit --> 2 */
-#define BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_MODE__POS               (2)
-#define BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_MODE__LEN               (1)
-#define BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_MODE__MSK               (0x04)
-#define BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_MODE__REG               \
-		(BMI160_USER_INTR_LOWHIGH_2_ADDR)
-/**************************************************************/
-/**\name	HIGH_G HYSTERESIS LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_LowHigh_2 Description - Reg Addr --> 0x5c, Bit --> 6...7 */
-#define BMI160_USER_INTR_LOWHIGH_2_INTR_HIGH_G_HYST__POS               (6)
-#define BMI160_USER_INTR_LOWHIGH_2_INTR_HIGH_G_HYST__LEN               (2)
-#define BMI160_USER_INTR_LOWHIGH_2_INTR_HIGH_G_HYST__MSK               (0xC0)
-#define BMI160_USER_INTR_LOWHIGH_2_INTR_HIGH_G_HYST__REG               \
-		(BMI160_USER_INTR_LOWHIGH_2_ADDR)
-/**************************************************************/
-/**\name	HIGH_G DURATION LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_LowHigh_3 Description - Reg Addr --> 0x5d, Bit --> 0...7 */
-#define BMI160_USER_INTR_LOWHIGH_3_INTR_HIGH_G_DURN__POS               (0)
-#define BMI160_USER_INTR_LOWHIGH_3_INTR_HIGH_G_DURN__LEN               (8)
-#define BMI160_USER_INTR_LOWHIGH_3_INTR_HIGH_G_DURN__MSK               (0xFF)
-#define BMI160_USER_INTR_LOWHIGH_3_INTR_HIGH_G_DURN__REG               \
-		(BMI160_USER_INTR_LOWHIGH_3_ADDR)
-/**************************************************************/
-/**\name	HIGH_G THRESHOLD LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_LowHigh_4 Description - Reg Addr --> 0x5e, Bit --> 0...7 */
-#define BMI160_USER_INTR_LOWHIGH_4_INTR_HIGH_THRES__POS               (0)
-#define BMI160_USER_INTR_LOWHIGH_4_INTR_HIGH_THRES__LEN               (8)
-#define BMI160_USER_INTR_LOWHIGH_4_INTR_HIGH_THRES__MSK               (0xFF)
-#define BMI160_USER_INTR_LOWHIGH_4_INTR_HIGH_THRES__REG               \
-		(BMI160_USER_INTR_LOWHIGH_4_ADDR)
-/**************************************************************/
-/**\name	ANY MOTION DURATION LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Motion_0 Description - Reg Addr --> 0x5f, Bit --> 0...1 */
-#define BMI160_USER_INTR_MOTION_0_INTR_ANY_MOTION_DURN__POS               (0)
-#define BMI160_USER_INTR_MOTION_0_INTR_ANY_MOTION_DURN__LEN               (2)
-#define BMI160_USER_INTR_MOTION_0_INTR_ANY_MOTION_DURN__MSK               (0x03)
-#define BMI160_USER_INTR_MOTION_0_INTR_ANY_MOTION_DURN__REG               \
-		(BMI160_USER_INTR_MOTION_0_ADDR)
-/**************************************************************/
-/**\name	SLOW/NO MOTION DURATION LENGTH, POSITION AND MASK*/
-/**************************************************************/
-	/* Int_Motion_0 Description - Reg Addr --> 0x5f, Bit --> 2...7 */
-#define BMI160_USER_INTR_MOTION_0_INTR_SLOW_NO_MOTION_DURN__POS      (2)
-#define BMI160_USER_INTR_MOTION_0_INTR_SLOW_NO_MOTION_DURN__LEN      (6)
-#define BMI160_USER_INTR_MOTION_0_INTR_SLOW_NO_MOTION_DURN__MSK      (0xFC)
-#define BMI160_USER_INTR_MOTION_0_INTR_SLOW_NO_MOTION_DURN__REG       \
-		(BMI160_USER_INTR_MOTION_0_ADDR)
-/**************************************************************/
-/**\name	ANY MOTION THRESHOLD LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Motion_1 Description - Reg Addr --> (0x60), Bit --> 0...7 */
-#define BMI160_USER_INTR_MOTION_1_INTR_ANY_MOTION_THRES__POS      (0)
-#define BMI160_USER_INTR_MOTION_1_INTR_ANY_MOTION_THRES__LEN      (8)
-#define BMI160_USER_INTR_MOTION_1_INTR_ANY_MOTION_THRES__MSK      (0xFF)
-#define BMI160_USER_INTR_MOTION_1_INTR_ANY_MOTION_THRES__REG               \
-		(BMI160_USER_INTR_MOTION_1_ADDR)
-/**************************************************************/
-/**\name	SLOW/NO MOTION THRESHOLD LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Motion_2 Description - Reg Addr --> 0x61, Bit --> 0...7 */
-#define BMI160_USER_INTR_MOTION_2_INTR_SLOW_NO_MOTION_THRES__POS       (0)
-#define BMI160_USER_INTR_MOTION_2_INTR_SLOW_NO_MOTION_THRES__LEN       (8)
-#define BMI160_USER_INTR_MOTION_2_INTR_SLOW_NO_MOTION_THRES__MSK       (0xFF)
-#define BMI160_USER_INTR_MOTION_2_INTR_SLOW_NO_MOTION_THRES__REG       \
-		(BMI160_USER_INTR_MOTION_2_ADDR)
-/**************************************************************/
-/**\name	SLOW/NO MOTION SELECT LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Motion_3 Description - Reg Addr --> (0x62), Bit --> 0 */
-#define BMI160_USER_INTR_MOTION_3_INTR_SLOW_NO_MOTION_SELECT__POS	(0)
-#define BMI160_USER_INTR_MOTION_3_INTR_SLOW_NO_MOTION_SELECT__LEN	(1)
-#define BMI160_USER_INTR_MOTION_3_INTR_SLOW_NO_MOTION_SELECT__MSK	(0x01)
-#define BMI160_USER_INTR_MOTION_3_INTR_SLOW_NO_MOTION_SELECT__REG   \
-(BMI160_USER_INTR_MOTION_3_ADDR)
-/**************************************************************/
-/**\name	SIGNIFICANT MOTION SELECT LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Motion_3 Description - Reg Addr --> (0x62), Bit --> 1 */
-#define BMI160_USER_INTR_SIGNIFICATION_MOTION_SELECT__POS		(1)
-#define BMI160_USER_INTR_SIGNIFICATION_MOTION_SELECT__LEN		(1)
-#define BMI160_USER_INTR_SIGNIFICATION_MOTION_SELECT__MSK		(0x02)
-#define BMI160_USER_INTR_SIGNIFICATION_MOTION_SELECT__REG		\
-		(BMI160_USER_INTR_MOTION_3_ADDR)
-
-/* Int_Motion_3 Description - Reg Addr --> (0x62), Bit --> 3..2 */
-#define BMI160_USER_INTR_SIGNIFICANT_MOTION_SKIP__POS		(2)
-#define BMI160_USER_INTR_SIGNIFICANT_MOTION_SKIP__LEN		(2)
-#define BMI160_USER_INTR_SIGNIFICANT_MOTION_SKIP__MSK		(0x0C)
-#define BMI160_USER_INTR_SIGNIFICANT_MOTION_SKIP__REG		\
-		(BMI160_USER_INTR_MOTION_3_ADDR)
-
-/* Int_Motion_3 Description - Reg Addr --> (0x62), Bit --> 5..4 */
-#define BMI160_USER_INTR_SIGNIFICANT_MOTION_PROOF__POS		(4)
-#define BMI160_USER_INTR_SIGNIFICANT_MOTION_PROOF__LEN		(2)
-#define BMI160_USER_INTR_SIGNIFICANT_MOTION_PROOF__MSK		(0x30)
-#define BMI160_USER_INTR_SIGNIFICANT_MOTION_PROOF__REG		\
-		(BMI160_USER_INTR_MOTION_3_ADDR)
-/**************************************************************/
-/**\name	TAP DURATION LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* INT_TAP_0 Description - Reg Addr --> (0x63), Bit --> 0..2*/
-#define BMI160_USER_INTR_TAP_0_INTR_TAP_DURN__POS               (0)
-#define BMI160_USER_INTR_TAP_0_INTR_TAP_DURN__LEN               (3)
-#define BMI160_USER_INTR_TAP_0_INTR_TAP_DURN__MSK               (0x07)
-#define BMI160_USER_INTR_TAP_0_INTR_TAP_DURN__REG	\
-(BMI160_USER_INTR_TAP_0_ADDR)
-/**************************************************************/
-/**\name	TAP SHOCK LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Tap_0 Description - Reg Addr --> (0x63), Bit --> 6 */
-#define BMI160_USER_INTR_TAP_0_INTR_TAP_SHOCK__POS               (6)
-#define BMI160_USER_INTR_TAP_0_INTR_TAP_SHOCK__LEN               (1)
-#define BMI160_USER_INTR_TAP_0_INTR_TAP_SHOCK__MSK               (0x40)
-#define BMI160_USER_INTR_TAP_0_INTR_TAP_SHOCK__REG (BMI160_USER_INTR_TAP_0_ADDR)
-/**************************************************************/
-/**\name	TAP QUIET LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Tap_0 Description - Reg Addr --> (0x63), Bit --> 7 */
-#define BMI160_USER_INTR_TAP_0_INTR_TAP_QUIET__POS               (7)
-#define BMI160_USER_INTR_TAP_0_INTR_TAP_QUIET__LEN               (1)
-#define BMI160_USER_INTR_TAP_0_INTR_TAP_QUIET__MSK               (0x80)
-#define BMI160_USER_INTR_TAP_0_INTR_TAP_QUIET__REG (BMI160_USER_INTR_TAP_0_ADDR)
-/**************************************************************/
-/**\name	TAP THRESHOLD LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Tap_1 Description - Reg Addr --> (0x64), Bit --> 0...4 */
-#define BMI160_USER_INTR_TAP_1_INTR_TAP_THRES__POS               (0)
-#define BMI160_USER_INTR_TAP_1_INTR_TAP_THRES__LEN               (5)
-#define BMI160_USER_INTR_TAP_1_INTR_TAP_THRES__MSK               (0x1F)
-#define BMI160_USER_INTR_TAP_1_INTR_TAP_THRES__REG (BMI160_USER_INTR_TAP_1_ADDR)
-/**************************************************************/
-/**\name	ORIENT MODE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Orient_0 Description - Reg Addr --> (0x65), Bit --> 0...1 */
-#define BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_MODE__POS               (0)
-#define BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_MODE__LEN               (2)
-#define BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_MODE__MSK               (0x03)
-#define BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_MODE__REG               \
-		(BMI160_USER_INTR_ORIENT_0_ADDR)
-/**************************************************************/
-/**\name	ORIENT BLOCKING LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Orient_0 Description - Reg Addr --> (0x65), Bit --> 2...3 */
-#define BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_BLOCKING__POS               (2)
-#define BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_BLOCKING__LEN               (2)
-#define BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_BLOCKING__MSK               (0x0C)
-#define BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_BLOCKING__REG               \
-		(BMI160_USER_INTR_ORIENT_0_ADDR)
-/**************************************************************/
-/**\name	ORIENT HYSTERESIS LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Orient_0 Description - Reg Addr --> (0x65), Bit --> 4...7 */
-#define BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_HYST__POS               (4)
-#define BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_HYST__LEN               (4)
-#define BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_HYST__MSK               (0xF0)
-#define BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_HYST__REG               \
-		(BMI160_USER_INTR_ORIENT_0_ADDR)
-/**************************************************************/
-/**\name	ORIENT THETA LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Orient_1 Description - Reg Addr --> 0x66, Bit --> 0...5 */
-#define BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_THETA__POS               (0)
-#define BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_THETA__LEN               (6)
-#define BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_THETA__MSK               (0x3F)
-#define BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_THETA__REG               \
-		(BMI160_USER_INTR_ORIENT_1_ADDR)
-/**************************************************************/
-/**\name	ORIENT UD LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Orient_1 Description - Reg Addr --> 0x66, Bit --> 6 */
-#define BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_UD_ENABLE__POS         (6)
-#define BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_UD_ENABLE__LEN         (1)
-#define BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_UD_ENABLE__MSK         (0x40)
-#define BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_UD_ENABLE__REG          \
-		(BMI160_USER_INTR_ORIENT_1_ADDR)
-/**************************************************************/
-/**\name	ORIENT AXIS LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Orient_1 Description - Reg Addr --> 0x66, Bit --> 7 */
-#define BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_AXES_EX__POS               (7)
-#define BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_AXES_EX__LEN               (1)
-#define BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_AXES_EX__MSK               (0x80)
-#define BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_AXES_EX__REG               \
-		(BMI160_USER_INTR_ORIENT_1_ADDR)
-/**************************************************************/
-/**\name	FLAT THETA LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Flat_0 Description - Reg Addr --> 0x67, Bit --> 0...5 */
-#define BMI160_USER_INTR_FLAT_0_INTR_FLAT_THETA__POS               (0)
-#define BMI160_USER_INTR_FLAT_0_INTR_FLAT_THETA__LEN               (6)
-#define BMI160_USER_INTR_FLAT_0_INTR_FLAT_THETA__MSK               (0x3F)
-#define BMI160_USER_INTR_FLAT_0_INTR_FLAT_THETA__REG  \
-		(BMI160_USER_INTR_FLAT_0_ADDR)
-/**************************************************************/
-/**\name	FLAT HYSTERESIS LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Flat_1 Description - Reg Addr --> (0x68), Bit --> 0...3 */
-#define BMI160_USER_INTR_FLAT_1_INTR_FLAT_HYST__POS		(0)
-#define BMI160_USER_INTR_FLAT_1_INTR_FLAT_HYST__LEN		(4)
-#define BMI160_USER_INTR_FLAT_1_INTR_FLAT_HYST__MSK		(0x0F)
-#define BMI160_USER_INTR_FLAT_1_INTR_FLAT_HYST__REG	 \
-(BMI160_USER_INTR_FLAT_1_ADDR)
-/**************************************************************/
-/**\name	FLAT HOLD LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Int_Flat_1 Description - Reg Addr --> (0x68), Bit --> 4...5 */
-#define BMI160_USER_INTR_FLAT_1_INTR_FLAT_HOLD__POS                (4)
-#define BMI160_USER_INTR_FLAT_1_INTR_FLAT_HOLD__LEN                (2)
-#define BMI160_USER_INTR_FLAT_1_INTR_FLAT_HOLD__MSK                (0x30)
-#define BMI160_USER_INTR_FLAT_1_INTR_FLAT_HOLD__REG  \
-(BMI160_USER_INTR_FLAT_1_ADDR)
-/**************************************************************/
-/**\name	FOC ACCEL XYZ LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Foc_Conf Description - Reg Addr --> (0x69), Bit --> 0...1 */
-#define BMI160_USER_FOC_ACCEL_Z__POS               (0)
-#define BMI160_USER_FOC_ACCEL_Z__LEN               (2)
-#define BMI160_USER_FOC_ACCEL_Z__MSK               (0x03)
-#define BMI160_USER_FOC_ACCEL_Z__REG               (BMI160_USER_FOC_CONFIG_ADDR)
-
-/* Foc_Conf Description - Reg Addr --> (0x69), Bit --> 2...3 */
-#define BMI160_USER_FOC_ACCEL_Y__POS               (2)
-#define BMI160_USER_FOC_ACCEL_Y__LEN               (2)
-#define BMI160_USER_FOC_ACCEL_Y__MSK               (0x0C)
-#define BMI160_USER_FOC_ACCEL_Y__REG               (BMI160_USER_FOC_CONFIG_ADDR)
-
-/* Foc_Conf Description - Reg Addr --> (0x69), Bit --> 4...5 */
-#define BMI160_USER_FOC_ACCEL_X__POS               (4)
-#define BMI160_USER_FOC_ACCEL_X__LEN               (2)
-#define BMI160_USER_FOC_ACCEL_X__MSK               (0x30)
-#define BMI160_USER_FOC_ACCEL_X__REG               (BMI160_USER_FOC_CONFIG_ADDR)
-/**************************************************************/
-/**\name	FOC GYRO LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Foc_Conf Description - Reg Addr --> (0x69), Bit --> 6 */
-#define BMI160_USER_FOC_GYRO_ENABLE__POS               (6)
-#define BMI160_USER_FOC_GYRO_ENABLE__LEN               (1)
-#define BMI160_USER_FOC_GYRO_ENABLE__MSK               (0x40)
-#define BMI160_USER_FOC_GYRO_ENABLE__REG               \
-(BMI160_USER_FOC_CONFIG_ADDR)
-/**************************************************************/
-/**\name	NVM PROGRAM LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* CONF Description - Reg Addr --> (0x6A), Bit --> 1 */
-#define BMI160_USER_CONFIG_NVM_PROG_ENABLE__POS               (1)
-#define BMI160_USER_CONFIG_NVM_PROG_ENABLE__LEN               (1)
-#define BMI160_USER_CONFIG_NVM_PROG_ENABLE__MSK               (0x02)
-#define BMI160_USER_CONFIG_NVM_PROG_ENABLE__REG               \
-(BMI160_USER_CONFIG_ADDR)
-
-/*IF_CONF Description - Reg Addr --> (0x6B), Bit --> 0 */
-
-#define BMI160_USER_IF_CONFIG_SPI3__POS               (0)
-#define BMI160_USER_IF_CONFIG_SPI3__LEN               (1)
-#define BMI160_USER_IF_CONFIG_SPI3__MSK               (0x01)
-#define BMI160_USER_IF_CONFIG_SPI3__REG               \
-(BMI160_USER_IF_CONFIG_ADDR)
-
-/*IF_CONF Description - Reg Addr --> (0x6B), Bit --> 5..4 */
-#define BMI160_USER_IF_CONFIG_IF_MODE__POS               (4)
-#define BMI160_USER_IF_CONFIG_IF_MODE__LEN               (2)
-#define BMI160_USER_IF_CONFIG_IF_MODE__MSK               (0x30)
-#define BMI160_USER_IF_CONFIG_IF_MODE__REG		\
-(BMI160_USER_IF_CONFIG_ADDR)
-/**************************************************************/
-/**\name	GYRO SLEEP CONFIGURATION LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Pmu_Trigger Description - Reg Addr --> 0x6c, Bit --> 0...2 */
-#define BMI160_USER_GYRO_SLEEP_TRIGGER__POS               (0)
-#define BMI160_USER_GYRO_SLEEP_TRIGGER__LEN               (3)
-#define BMI160_USER_GYRO_SLEEP_TRIGGER__MSK               (0x07)
-#define BMI160_USER_GYRO_SLEEP_TRIGGER__REG	(BMI160_USER_PMU_TRIGGER_ADDR)
-
-/* Pmu_Trigger Description - Reg Addr --> 0x6c, Bit --> 3...4 */
-#define BMI160_USER_GYRO_WAKEUP_TRIGGER__POS               (3)
-#define BMI160_USER_GYRO_WAKEUP_TRIGGER__LEN               (2)
-#define BMI160_USER_GYRO_WAKEUP_TRIGGER__MSK               (0x18)
-#define BMI160_USER_GYRO_WAKEUP_TRIGGER__REG	(BMI160_USER_PMU_TRIGGER_ADDR)
-
-/* Pmu_Trigger Description - Reg Addr --> 0x6c, Bit --> 5 */
-#define BMI160_USER_GYRO_SLEEP_STATE__POS               (5)
-#define BMI160_USER_GYRO_SLEEP_STATE__LEN               (1)
-#define BMI160_USER_GYRO_SLEEP_STATE__MSK               (0x20)
-#define BMI160_USER_GYRO_SLEEP_STATE__REG	(BMI160_USER_PMU_TRIGGER_ADDR)
-
-/* Pmu_Trigger Description - Reg Addr --> 0x6c, Bit --> 6 */
-#define BMI160_USER_GYRO_WAKEUP_INTR__POS               (6)
-#define BMI160_USER_GYRO_WAKEUP_INTR__LEN               (1)
-#define BMI160_USER_GYRO_WAKEUP_INTR__MSK               (0x40)
-#define BMI160_USER_GYRO_WAKEUP_INTR__REG	(BMI160_USER_PMU_TRIGGER_ADDR)
-/**************************************************************/
-/**\name	ACCEL SELF TEST LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Self_Test Description - Reg Addr --> 0x6d, Bit --> 0...1 */
-#define BMI160_USER_ACCEL_SELFTEST_AXIS__POS               (0)
-#define BMI160_USER_ACCEL_SELFTEST_AXIS__LEN               (2)
-#define BMI160_USER_ACCEL_SELFTEST_AXIS__MSK               (0x03)
-#define BMI160_USER_ACCEL_SELFTEST_AXIS__REG	(BMI160_USER_SELF_TEST_ADDR)
-
-/* Self_Test Description - Reg Addr --> 0x6d, Bit --> 2 */
-#define BMI160_USER_ACCEL_SELFTEST_SIGN__POS               (2)
-#define BMI160_USER_ACCEL_SELFTEST_SIGN__LEN               (1)
-#define BMI160_USER_ACCEL_SELFTEST_SIGN__MSK               (0x04)
-#define BMI160_USER_ACCEL_SELFTEST_SIGN__REG	(BMI160_USER_SELF_TEST_ADDR)
-
-/* Self_Test Description - Reg Addr --> 0x6d, Bit --> 3 */
-#define BMI160_USER_SELFTEST_AMP__POS               (3)
-#define BMI160_USER_SELFTEST_AMP__LEN               (1)
-#define BMI160_USER_SELFTEST_AMP__MSK               (0x08)
-#define BMI160_USER_SELFTEST_AMP__REG		(BMI160_USER_SELF_TEST_ADDR)
-/**************************************************************/
-/**\name	GYRO SELF TEST LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Self_Test Description - Reg Addr --> 0x6d, Bit --> 4 */
-#define BMI160_USER_GYRO_SELFTEST_START__POS               (4)
-#define BMI160_USER_GYRO_SELFTEST_START__LEN               (1)
-#define BMI160_USER_GYRO_SELFTEST_START__MSK               (0x10)
-#define BMI160_USER_GYRO_SELFTEST_START__REG		    \
-(BMI160_USER_SELF_TEST_ADDR)
-/**************************************************************/
-/**\name	NV_CONFIG LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* NV_CONF Description - Reg Addr --> (0x70), Bit --> 0 */
-#define BMI160_USER_NV_CONFIG_SPI_ENABLE__POS               (0)
-#define BMI160_USER_NV_CONFIG_SPI_ENABLE__LEN               (1)
-#define BMI160_USER_NV_CONFIG_SPI_ENABLE__MSK               (0x01)
-#define BMI160_USER_NV_CONFIG_SPI_ENABLE__REG	 (BMI160_USER_NV_CONFIG_ADDR)
-
-/*IF_CONF Description - Reg Addr --> (0x70), Bit --> 1 */
-#define BMI160_USER_IF_CONFIG_I2C_WDT_SELECT__POS               (1)
-#define BMI160_USER_IF_CONFIG_I2C_WDT_SELECT__LEN               (1)
-#define BMI160_USER_IF_CONFIG_I2C_WDT_SELECT__MSK               (0x02)
-#define BMI160_USER_IF_CONFIG_I2C_WDT_SELECT__REG		\
-(BMI160_USER_NV_CONFIG_ADDR)
-
-/*IF_CONF Description - Reg Addr --> (0x70), Bit --> 2 */
-#define BMI160_USER_IF_CONFIG_I2C_WDT_ENABLE__POS               (2)
-#define BMI160_USER_IF_CONFIG_I2C_WDT_ENABLE__LEN               (1)
-#define BMI160_USER_IF_CONFIG_I2C_WDT_ENABLE__MSK               (0x04)
-#define BMI160_USER_IF_CONFIG_I2C_WDT_ENABLE__REG		\
-(BMI160_USER_NV_CONFIG_ADDR)
-
-/* NV_CONF Description - Reg Addr --> (0x70), Bit --> 3 */
-#define BMI160_USER_NV_CONFIG_SPARE0__POS               (3)
-#define BMI160_USER_NV_CONFIG_SPARE0__LEN               (1)
-#define BMI160_USER_NV_CONFIG_SPARE0__MSK               (0x08)
-#define BMI160_USER_NV_CONFIG_SPARE0__REG	(BMI160_USER_NV_CONFIG_ADDR)
-
-/* NV_CONF Description - Reg Addr --> (0x70), Bit --> 4...7 */
-#define BMI160_USER_NV_CONFIG_NVM_COUNTER__POS               (4)
-#define BMI160_USER_NV_CONFIG_NVM_COUNTER__LEN               (4)
-#define BMI160_USER_NV_CONFIG_NVM_COUNTER__MSK               (0xF0)
-#define BMI160_USER_NV_CONFIG_NVM_COUNTER__REG	(BMI160_USER_NV_CONFIG_ADDR)
-/**************************************************************/
-/**\name	ACCEL MANUAL OFFSET LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Offset_0 Description - Reg Addr --> (0x71), Bit --> 0...7 */
-#define BMI160_USER_OFFSET_0_ACCEL_OFF_X__POS               (0)
-#define BMI160_USER_OFFSET_0_ACCEL_OFF_X__LEN               (8)
-#define BMI160_USER_OFFSET_0_ACCEL_OFF_X__MSK               (0xFF)
-#define BMI160_USER_OFFSET_0_ACCEL_OFF_X__REG	(BMI160_USER_OFFSET_0_ADDR)
-
-/* Offset_1 Description - Reg Addr --> 0x72, Bit --> 0...7 */
-#define BMI160_USER_OFFSET_1_ACCEL_OFF_Y__POS               (0)
-#define BMI160_USER_OFFSET_1_ACCEL_OFF_Y__LEN               (8)
-#define BMI160_USER_OFFSET_1_ACCEL_OFF_Y__MSK               (0xFF)
-#define BMI160_USER_OFFSET_1_ACCEL_OFF_Y__REG	(BMI160_USER_OFFSET_1_ADDR)
-
-/* Offset_2 Description - Reg Addr --> 0x73, Bit --> 0...7 */
-#define BMI160_USER_OFFSET_2_ACCEL_OFF_Z__POS               (0)
-#define BMI160_USER_OFFSET_2_ACCEL_OFF_Z__LEN               (8)
-#define BMI160_USER_OFFSET_2_ACCEL_OFF_Z__MSK               (0xFF)
-#define BMI160_USER_OFFSET_2_ACCEL_OFF_Z__REG	(BMI160_USER_OFFSET_2_ADDR)
-/**************************************************************/
-/**\name	GYRO MANUAL OFFSET LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Offset_3 Description - Reg Addr --> 0x74, Bit --> 0...7 */
-#define BMI160_USER_OFFSET_3_GYRO_OFF_X__POS               (0)
-#define BMI160_USER_OFFSET_3_GYRO_OFF_X__LEN               (8)
-#define BMI160_USER_OFFSET_3_GYRO_OFF_X__MSK               (0xFF)
-#define BMI160_USER_OFFSET_3_GYRO_OFF_X__REG	(BMI160_USER_OFFSET_3_ADDR)
-
-/* Offset_4 Description - Reg Addr --> 0x75, Bit --> 0...7 */
-#define BMI160_USER_OFFSET_4_GYRO_OFF_Y__POS               (0)
-#define BMI160_USER_OFFSET_4_GYRO_OFF_Y__LEN               (8)
-#define BMI160_USER_OFFSET_4_GYRO_OFF_Y__MSK               (0xFF)
-#define BMI160_USER_OFFSET_4_GYRO_OFF_Y__REG	(BMI160_USER_OFFSET_4_ADDR)
-
-/* Offset_5 Description - Reg Addr --> 0x76, Bit --> 0...7 */
-#define BMI160_USER_OFFSET_5_GYRO_OFF_Z__POS               (0)
-#define BMI160_USER_OFFSET_5_GYRO_OFF_Z__LEN               (8)
-#define BMI160_USER_OFFSET_5_GYRO_OFF_Z__MSK               (0xFF)
-#define BMI160_USER_OFFSET_5_GYRO_OFF_Z__REG	(BMI160_USER_OFFSET_5_ADDR)
-
-
-/* Offset_6 Description - Reg Addr --> 0x77, Bit --> 0..1 */
-#define BMI160_USER_OFFSET_6_GYRO_OFF_X__POS               (0)
-#define BMI160_USER_OFFSET_6_GYRO_OFF_X__LEN               (2)
-#define BMI160_USER_OFFSET_6_GYRO_OFF_X__MSK               (0x03)
-#define BMI160_USER_OFFSET_6_GYRO_OFF_X__REG	(BMI160_USER_OFFSET_6_ADDR)
-
-/* Offset_6 Description - Reg Addr --> 0x77, Bit --> 2...3 */
-#define BMI160_USER_OFFSET_6_GYRO_OFF_Y__POS               (2)
-#define BMI160_USER_OFFSET_6_GYRO_OFF_Y__LEN               (2)
-#define BMI160_USER_OFFSET_6_GYRO_OFF_Y__MSK               (0x0C)
-#define BMI160_USER_OFFSET_6_GYRO_OFF_Y__REG	(BMI160_USER_OFFSET_6_ADDR)
-
-/* Offset_6 Description - Reg Addr --> 0x77, Bit --> 4...5 */
-#define BMI160_USER_OFFSET_6_GYRO_OFF_Z__POS               (4)
-#define BMI160_USER_OFFSET_6_GYRO_OFF_Z__LEN               (2)
-#define BMI160_USER_OFFSET_6_GYRO_OFF_Z__MSK               (0x30)
-#define BMI160_USER_OFFSET_6_GYRO_OFF_Z__REG	 (BMI160_USER_OFFSET_6_ADDR)
-/**************************************************************/
-/**\name	ACCEL OFFSET  ENABLE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Offset_6 Description - Reg Addr --> 0x77, Bit --> 6 */
-#define BMI160_USER_OFFSET_6_ACCEL_OFF_ENABLE__POS               (6)
-#define BMI160_USER_OFFSET_6_ACCEL_OFF_ENABLE__LEN               (1)
-#define BMI160_USER_OFFSET_6_ACCEL_OFF_ENABLE__MSK               (0x40)
-#define BMI160_USER_OFFSET_6_ACCEL_OFF_ENABLE__REG	 \
-(BMI160_USER_OFFSET_6_ADDR)
-/**************************************************************/
-/**\name	GYRO OFFSET  ENABLE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Offset_6 Description - Reg Addr --> 0x77, Bit -->  7 */
-#define BMI160_USER_OFFSET_6_GYRO_OFF_EN__POS               (7)
-#define BMI160_USER_OFFSET_6_GYRO_OFF_EN__LEN               (1)
-#define BMI160_USER_OFFSET_6_GYRO_OFF_EN__MSK               (0x80)
-#define BMI160_USER_OFFSET_6_GYRO_OFF_EN__REG	 (BMI160_USER_OFFSET_6_ADDR)
-/**************************************************************/
-/**\name	STEP COUNTER LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* STEP_CNT_0  Description - Reg Addr --> 0x78, Bit -->  0 to 7 */
-#define BMI160_USER_STEP_COUNT_LSB__POS               (0)
-#define BMI160_USER_STEP_COUNT_LSB__LEN               (7)
-#define BMI160_USER_STEP_COUNT_LSB__MSK               (0xFF)
-#define BMI160_USER_STEP_COUNT_LSB__REG	 (BMI160_USER_STEP_COUNT_0_ADDR)
-
-/* STEP_CNT_1  Description - Reg Addr --> 0x79, Bit -->  0 to 7 */
-#define BMI160_USER_STEP_COUNT_MSB__POS               (0)
-#define BMI160_USER_STEP_COUNT_MSB__LEN               (7)
-#define BMI160_USER_STEP_COUNT_MSB__MSK               (0xFF)
-#define BMI160_USER_STEP_COUNT_MSB__REG	 (BMI160_USER_STEP_COUNT_1_ADDR)
-/**************************************************************/
-/**\name	STEP COUNTER CONFIGURATION LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* STEP_CONFIG_0  Description - Reg Addr --> 0x7A, Bit -->  0 to 7 */
-#define BMI160_USER_STEP_CONFIG_ZERO__POS               (0)
-#define BMI160_USER_STEP_CONFIG_ZERO__LEN               (7)
-#define BMI160_USER_STEP_CONFIG_ZERO__MSK               (0xFF)
-#define BMI160_USER_STEP_CONFIG_ZERO__REG	 \
-(BMI160_USER_STEP_CONFIG_0_ADDR)
-
-
-/* STEP_CONFIG_1  Description - Reg Addr --> 0x7B, Bit -->  0 to 2 and
-4 to 7 */
-#define BMI160_USER_STEP_CONFIG_ONE_CNF1__POS               (0)
-#define BMI160_USER_STEP_CONFIG_ONE_CNF1__LEN               (3)
-#define BMI160_USER_STEP_CONFIG_ONE_CNF1__MSK               (0x07)
-#define BMI160_USER_STEP_CONFIG_ONE_CNF1__REG	 \
-(BMI160_USER_STEP_CONFIG_1_ADDR)
-
-#define BMI160_USER_STEP_CONFIG_ONE_CNF2__POS               (4)
-#define BMI160_USER_STEP_CONFIG_ONE_CNF2__LEN               (4)
-#define BMI160_USER_STEP_CONFIG_ONE_CNF2__MSK               (0xF0)
-#define BMI160_USER_STEP_CONFIG_ONE_CNF2__REG	 \
-(BMI160_USER_STEP_CONFIG_1_ADDR)
-/**************************************************************/
-/**\name	STEP COUNTER ENABLE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* STEP_CONFIG_1  Description - Reg Addr --> 0x7B, Bit -->  0 to 2 */
-#define BMI160_USER_STEP_CONFIG_1_STEP_COUNT_ENABLE__POS		(3)
-#define BMI160_USER_STEP_CONFIG_1_STEP_COUNT_ENABLE__LEN		(1)
-#define BMI160_USER_STEP_CONFIG_1_STEP_COUNT_ENABLE__MSK		(0x08)
-#define BMI160_USER_STEP_CONFIG_1_STEP_COUNT_ENABLE__REG	\
-(BMI160_USER_STEP_CONFIG_1_ADDR)
-
-/* USER REGISTERS DEFINITION END */
-/**************************************************************************/
-/* CMD REGISTERS DEFINITION START */
-/**************************************************************/
-/**\name	COMMAND REGISTER LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Command description address - Reg Addr --> 0x7E, Bit -->  0....7 */
-#define BMI160_CMD_COMMANDS__POS              (0)
-#define BMI160_CMD_COMMANDS__LEN              (8)
-#define BMI160_CMD_COMMANDS__MSK              (0xFF)
-#define BMI160_CMD_COMMANDS__REG	 (BMI160_CMD_COMMANDS_ADDR)
-/**************************************************************/
-/**\name	PAGE ENABLE LENGTH, POSITION AND MASK*/
-/**************************************************************/
-/* Target page address - Reg Addr --> 0x7F, Bit -->  4....5 */
-#define BMI160_CMD_TARGET_PAGE__POS           (4)
-#define BMI160_CMD_TARGET_PAGE__LEN           (2)
-#define BMI160_CMD_TARGET_PAGE__MSK           (0x30)
-#define BMI160_CMD_TARGET_PAGE__REG	 (BMI160_CMD_EXT_MODE_ADDR)
-
-/* Target page address - Reg Addr --> 0x7F, Bit -->  4....5 */
-#define BMI160_CMD_PAGING_EN__POS           (7)
-#define BMI160_CMD_PAGING_EN__LEN           (1)
-#define BMI160_CMD_PAGING_EN__MSK           (0x80)
-#define BMI160_CMD_PAGING_EN__REG		(BMI160_CMD_EXT_MODE_ADDR)
-
-/* Target page address - Reg Addr --> 0x7F, Bit -->  4....5 */
-#define BMI160_COM_C_TRIM_FIVE__POS           (0)
-#define BMI160_COM_C_TRIM_FIVE__LEN           (8)
-#define BMI160_COM_C_TRIM_FIVE__MSK           (0xFF)
-#define BMI160_COM_C_TRIM_FIVE__REG		(BMI160_COM_C_TRIM_FIVE_ADDR)
-
-/**************************************************************************/
-/* CMD REGISTERS DEFINITION END */
-
-/**************************************************/
-/**\name	FIFO FRAME COUNT DEFINITION           */
-/*************************************************/
-#define FIFO_FRAME				(1024)
-#define FIFO_CONFIG_CHECK1		(0x00)
-#define FIFO_CONFIG_CHECK2		(0x80)
-/**************************************************/
-/**\name	MAG SENSOR SELECT          */
-/*************************************************/
-#define BST_BMM		(0)
-#define BST_AKM		(1)
-#define BMI160_YAS537_I2C_ADDRESS	(0x2E)
-/**************************************************/
-/**\name	ACCEL RANGE          */
-/*************************************************/
-#define BMI160_ACCEL_RANGE_2G           (0X03)
-#define BMI160_ACCEL_RANGE_4G           (0X05)
-#define BMI160_ACCEL_RANGE_8G           (0X08)
-#define BMI160_ACCEL_RANGE_16G          (0X0C)
-/**************************************************/
-/**\name	ACCEL ODR          */
-/*************************************************/
-#define BMI160_ACCEL_OUTPUT_DATA_RATE_RESERVED       (0x00)
-#define BMI160_ACCEL_OUTPUT_DATA_RATE_0_78HZ         (0x01)
-#define BMI160_ACCEL_OUTPUT_DATA_RATE_1_56HZ         (0x02)
-#define BMI160_ACCEL_OUTPUT_DATA_RATE_3_12HZ         (0x03)
-#define BMI160_ACCEL_OUTPUT_DATA_RATE_6_25HZ         (0x04)
-#define BMI160_ACCEL_OUTPUT_DATA_RATE_12_5HZ         (0x05)
-#define BMI160_ACCEL_OUTPUT_DATA_RATE_25HZ           (0x06)
-#define BMI160_ACCEL_OUTPUT_DATA_RATE_50HZ           (0x07)
-#define BMI160_ACCEL_OUTPUT_DATA_RATE_100HZ          (0x08)
-#define BMI160_ACCEL_OUTPUT_DATA_RATE_200HZ          (0x09)
-#define BMI160_ACCEL_OUTPUT_DATA_RATE_400HZ          (0x0A)
-#define BMI160_ACCEL_OUTPUT_DATA_RATE_800HZ          (0x0B)
-#define BMI160_ACCEL_OUTPUT_DATA_RATE_1600HZ         (0x0C)
-#define BMI160_ACCEL_OUTPUT_DATA_RATE_RESERVED0      (0x0D)
-#define BMI160_ACCEL_OUTPUT_DATA_RATE_RESERVED1      (0x0E)
-#define BMI160_ACCEL_OUTPUT_DATA_RATE_RESERVED2      (0x0F)
-/**************************************************/
-/**\name	ACCEL BANDWIDTH PARAMETER         */
-/*************************************************/
-#define BMI160_ACCEL_OSR4_AVG1			(0)
-#define BMI160_ACCEL_OSR2_AVG2			(1)
-#define BMI160_ACCEL_NORMAL_AVG4		(2)
-#define BMI160_ACCEL_CIC_AVG8			(3)
-#define BMI160_ACCEL_RES_AVG2			(4)
-#define BMI160_ACCEL_RES_AVG4			(5)
-#define BMI160_ACCEL_RES_AVG8			(6)
-#define BMI160_ACCEL_RES_AVG16			(7)
-#define BMI160_ACCEL_RES_AVG32			(8)
-#define BMI160_ACCEL_RES_AVG64			(9)
-#define BMI160_ACCEL_RES_AVG128			(10)
-
-#define BMI160_US_DISABLE				(0)
-#define BMI160_US_ENABLE				(1)
-/**************************************************/
-/**\name	GYRO ODR         */
-/*************************************************/
-#define BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED		(0x00)
-#define BMI160_GYRO_OUTPUT_DATA_RATE_25HZ			(0x06)
-#define BMI160_GYRO_OUTPUT_DATA_RATE_50HZ			(0x07)
-#define BMI160_GYRO_OUTPUT_DATA_RATE_100HZ			(0x08)
-#define BMI160_GYRO_OUTPUT_DATA_RATE_200HZ			(0x09)
-#define BMI160_GYRO_OUTPUT_DATA_RATE_400HZ			(0x0A)
-#define BMI160_GYRO_OUTPUT_DATA_RATE_800HZ			(0x0B)
-#define BMI160_GYRO_OUTPUT_DATA_RATE_1600HZ			(0x0C)
-#define BMI160_GYRO_OUTPUT_DATA_RATE_3200HZ			(0x0D)
-/**************************************************/
-/**\name	GYRO BANDWIDTH PARAMETER         */
-/*************************************************/
-#define BMI160_GYRO_OSR4_MODE		(0x00)
-#define BMI160_GYRO_OSR2_MODE		(0x01)
-#define BMI160_GYRO_NORMAL_MODE		(0x02)
-#define BMI160_GYRO_CIC_MODE		(0x03)
-/**************************************************/
-/**\name	GYROSCOPE RANGE PARAMETER         */
-/*************************************************/
-#define BMI160_GYRO_RANGE_2000_DEG_SEC	(0x00)
-#define BMI160_GYRO_RANGE_1000_DEG_SEC	(0x01)
-#define BMI160_GYRO_RANGE_500_DEG_SEC	(0x02)
-#define BMI160_GYRO_RANGE_250_DEG_SEC	(0x03)
-#define BMI160_GYRO_RANGE_125_DEG_SEC	(0x04)
-/**************************************************/
-/**\name	MAG ODR         */
-/*************************************************/
-#define BMI160_MAG_OUTPUT_DATA_RATE_RESERVED       (0x00)
-#define BMI160_MAG_OUTPUT_DATA_RATE_0_78HZ         (0x01)
-#define BMI160_MAG_OUTPUT_DATA_RATE_1_56HZ         (0x02)
-#define BMI160_MAG_OUTPUT_DATA_RATE_3_12HZ         (0x03)
-#define BMI160_MAG_OUTPUT_DATA_RATE_6_25HZ         (0x04)
-#define BMI160_MAG_OUTPUT_DATA_RATE_12_5HZ         (0x05)
-#define BMI160_MAG_OUTPUT_DATA_RATE_25HZ           (0x06)
-#define BMI160_MAG_OUTPUT_DATA_RATE_50HZ           (0x07)
-#define BMI160_MAG_OUTPUT_DATA_RATE_100HZ          (0x08)
-#define BMI160_MAG_OUTPUT_DATA_RATE_200HZ          (0x09)
-#define BMI160_MAG_OUTPUT_DATA_RATE_400HZ          (0x0A)
-#define BMI160_MAG_OUTPUT_DATA_RATE_800HZ          (0x0B)
-#define BMI160_MAG_OUTPUT_DATA_RATE_1600HZ         (0x0C)
-#define BMI160_MAG_OUTPUT_DATA_RATE_RESERVED0      (0x0D)
-#define BMI160_MAG_OUTPUT_DATA_RATE_RESERVED1      (0x0E)
-#define BMI160_MAG_OUTPUT_DATA_RATE_RESERVED2      (0x0F)
-
-/**************************************************/
-/**\name	ENABLE/DISABLE SELECTIONS        */
-/*************************************************/
-
-/* Enable accel and gyro offset */
-#define ACCEL_OFFSET_ENABLE		(0x01)
-#define GYRO_OFFSET_ENABLE		(0x01)
-
-/* command register definition */
-#define START_FOC_ACCEL_GYRO	(0X03)
-
- /* INT ENABLE 1 */
-#define BMI160_ANY_MOTION_X_ENABLE       (0)
-#define BMI160_ANY_MOTION_Y_ENABLE       (1)
-#define BMI160_ANY_MOTION_Z_ENABLE       (2)
-#define BMI160_DOUBLE_TAP_ENABLE         (4)
-#define BMI160_SINGLE_TAP_ENABLE         (5)
-#define BMI160_ORIENT_ENABLE             (6)
-#define BMI160_FLAT_ENABLE               (7)
-
-/* INT ENABLE 1 */
-#define BMI160_HIGH_G_X_ENABLE       (0)
-#define BMI160_HIGH_G_Y_ENABLE       (1)
-#define BMI160_HIGH_G_Z_ENABLE       (2)
-#define BMI160_LOW_G_ENABLE          (3)
-#define BMI160_DATA_RDY_ENABLE       (4)
-#define BMI160_FIFO_FULL_ENABLE      (5)
-#define BMI160_FIFO_WM_ENABLE        (6)
-
-/* INT ENABLE 2 */
-#define  BMI160_NOMOTION_X_ENABLE	(0)
-#define  BMI160_NOMOTION_Y_ENABLE	(1)
-#define  BMI160_NOMOTION_Z_ENABLE	(2)
-
-/* FOC axis selection for accel*/
-#define	FOC_X_AXIS		(0)
-#define	FOC_Y_AXIS		(1)
-#define	FOC_Z_AXIS		(2)
-
-/* IN OUT CONTROL */
-#define BMI160_INTR1_EDGE_CTRL			(0)
-#define BMI160_INTR2_EDGE_CTRL			(1)
-#define BMI160_INTR1_LEVEL				(0)
-#define BMI160_INTR2_LEVEL				(1)
-#define BMI160_INTR1_OUTPUT_TYPE		(0)
-#define BMI160_INTR2_OUTPUT_TYPE		(1)
-#define BMI160_INTR1_OUTPUT_ENABLE		(0)
-#define BMI160_INTR2_OUTPUT_ENABLE		(1)
-
-#define BMI160_INTR1_INPUT_ENABLE	(0)
-#define BMI160_INTR2_INPUT_ENABLE	(1)
-
-/*  INTERRUPT MAPS    */
-#define BMI160_INTR1_MAP_LOW_G			(0)
-#define BMI160_INTR2_MAP_LOW_G			(1)
-#define BMI160_INTR1_MAP_HIGH_G			(0)
-#define BMI160_INTR2_MAP_HIGH_G			(1)
-#define BMI160_INTR1_MAP_ANY_MOTION		(0)
-#define BMI160_INTR2_MAP_ANY_MOTION		(1)
-#define BMI160_INTR1_MAP_NOMO			(0)
-#define BMI160_INTR2_MAP_NOMO			(1)
-#define BMI160_INTR1_MAP_DOUBLE_TAP		(0)
-#define BMI160_INTR2_MAP_DOUBLE_TAP		(1)
-#define BMI160_INTR1_MAP_SINGLE_TAP		(0)
-#define BMI160_INTR2_MAP_SINGLE_TAP		(1)
-#define BMI160_INTR1_MAP_ORIENT			(0)
-#define BMI160_INTR2_MAP_ORIENT			(1)
-#define BMI160_INTR1_MAP_FLAT			(0)
-#define BMI160_INTR2_MAP_FLAT			(1)
-#define BMI160_INTR1_MAP_DATA_RDY		(0)
-#define BMI160_INTR2_MAP_DATA_RDY		(1)
-#define BMI160_INTR1_MAP_FIFO_WM		(0)
-#define BMI160_INTR2_MAP_FIFO_WM		(1)
-#define BMI160_INTR1_MAP_FIFO_FULL      (0)
-#define BMI160_INTR2_MAP_FIFO_FULL      (1)
-#define BMI160_INTR1_MAP_PMUTRIG        (0)
-#define BMI160_INTR2_MAP_PMUTRIG		(1)
-
-/* Interrupt mapping*/
-#define	BMI160_MAP_INTR1		(0)
-#define	BMI160_MAP_INTR2		(1)
-/**************************************************/
-/**\name	 TAP DURATION         */
-/*************************************************/
-#define BMI160_TAP_DURN_50MS     (0x00)
-#define BMI160_TAP_DURN_100MS    (0x01)
-#define BMI160_TAP_DURN_150MS    (0x02)
-#define BMI160_TAP_DURN_200MS    (0x03)
-#define BMI160_TAP_DURN_250MS    (0x04)
-#define BMI160_TAP_DURN_375MS    (0x05)
-#define BMI160_TAP_DURN_500MS    (0x06)
-#define BMI160_TAP_DURN_700MS    (0x07)
-/**************************************************/
-/**\name	TAP SHOCK         */
-/*************************************************/
-#define BMI160_TAP_SHOCK_50MS	(0x00)
-#define BMI160_TAP_SHOCK_75MS	(0x01)
-/**************************************************/
-/**\name	TAP QUIET        */
-/*************************************************/
-#define BMI160_TAP_QUIET_30MS	(0x00)
-#define BMI160_TAP_QUIET_20MS	(0x01)
-/**************************************************/
-/**\name	STEP DETECTION SELECTION MODES      */
-/*************************************************/
-#define	BMI160_STEP_NORMAL_MODE			(0)
-#define	BMI160_STEP_SENSITIVE_MODE		(1)
-#define	BMI160_STEP_ROBUST_MODE			(2)
-/**************************************************/
-/**\name	STEP CONFIGURATION SELECT MODE    */
-/*************************************************/
-#define	STEP_CONFIG_NORMAL		(0X315)
-#define	STEP_CONFIG_SENSITIVE	(0X2D)
-#define	STEP_CONFIG_ROBUST		(0X71D)
-/**************************************************/
-/**\name	BMM150 TRIM DATA DEFINITIONS      */
-/*************************************************/
-#define BMI160_MAG_DIG_X1                      (0x5D)
-#define BMI160_MAG_DIG_Y1                      (0x5E)
-#define BMI160_MAG_DIG_Z4_LSB                  (0x62)
-#define BMI160_MAG_DIG_Z4_MSB                  (0x63)
-#define BMI160_MAG_DIG_X2                      (0x64)
-#define BMI160_MAG_DIG_Y2                      (0x65)
-#define BMI160_MAG_DIG_Z2_LSB                  (0x68)
-#define BMI160_MAG_DIG_Z2_MSB                  (0x69)
-#define BMI160_MAG_DIG_Z1_LSB                  (0x6A)
-#define BMI160_MAG_DIG_Z1_MSB                  (0x6B)
-#define BMI160_MAG_DIG_XYZ1_LSB                (0x6C)
-#define BMI160_MAG_DIG_XYZ1_MSB                (0x6D)
-#define BMI160_MAG_DIG_Z3_LSB                  (0x6E)
-#define BMI160_MAG_DIG_Z3_MSB                  (0x6F)
-#define BMI160_MAG_DIG_XY2                     (0x70)
-#define BMI160_MAG_DIG_XY1                     (0x71)
-/**************************************************/
-/**\name	BMM150 PRE-SET MODE DEFINITIONS     */
-/*************************************************/
-#define BMI160_MAG_PRESETMODE_LOWPOWER                 (1)
-#define BMI160_MAG_PRESETMODE_REGULAR                  (2)
-#define BMI160_MAG_PRESETMODE_HIGHACCURACY             (3)
-#define BMI160_MAG_PRESETMODE_ENHANCED                 (4)
-/**************************************************/
-/**\name	BMM150 PRESET MODES - DATA RATES    */
-/*************************************************/
-#define BMI160_MAG_LOWPOWER_DR                       (0x02)
-#define BMI160_MAG_REGULAR_DR                        (0x02)
-#define BMI160_MAG_HIGHACCURACY_DR                   (0x2A)
-#define BMI160_MAG_ENHANCED_DR                       (0x02)
-/**************************************************/
-/**\name	BMM150 PRESET MODES - REPETITIONS-XY RATES */
-/*************************************************/
-#define BMI160_MAG_LOWPOWER_REPXY                    (1)
-#define BMI160_MAG_REGULAR_REPXY                     (4)
-#define BMI160_MAG_HIGHACCURACY_REPXY                (23)
-#define BMI160_MAG_ENHANCED_REPXY                    (7)
-/**************************************************/
-/**\name	BMM150 PRESET MODES - REPETITIONS-Z RATES */
-/*************************************************/
-#define BMI160_MAG_LOWPOWER_REPZ                     (2)
-#define BMI160_MAG_REGULAR_REPZ                      (14)
-#define BMI160_MAG_HIGHACCURACY_REPZ                 (82)
-#define BMI160_MAG_ENHANCED_REPZ                     (26)
-#define BMI160_MAG_NOAMRL_SWITCH_TIMES               (5)
-#define MAG_INTERFACE_PMU_ENABLE                     (1)
-#define MAG_INTERFACE_PMU_DISABLE                    (0)
-/**************************************************/
-/**\name	USED FOR MAG OVERFLOW CHECK FOR BMM150  */
-/*************************************************/
-#define BMI160_MAG_OVERFLOW_OUTPUT			((s16)-32768)
-#define BMI160_MAG_OVERFLOW_OUTPUT_S32		((s32)(-2147483647-1))
-#define BMI160_MAG_NEGATIVE_SATURATION_Z   ((s16)-32767)
-#define BMI160_MAG_POSITIVE_SATURATION_Z   ((u16)32767)
-#define BMI160_MAG_FLIP_OVERFLOW_ADCVAL		((s16)-4096)
-#define BMI160_MAG_HALL_OVERFLOW_ADCVAL		((s16)-16384)
-/**************************************************/
-/**\name	BMM150 REGISTER DEFINITION */
-/*************************************************/
-#define BMI160_BMM150_CHIP_ID           (0x40)
-#define BMI160_BMM150_POWE_CONTROL_REG	(0x4B)
-#define BMI160_BMM150_POWE_MODE_REG		(0x4C)
-#define BMI160_BMM150_DATA_REG			(0x42)
-#define BMI160_BMM150_XY_REP			(0x51)
-#define BMI160_BMM150_Z_REP				(0x52)
-/**************************************************/
-/**\name	AKM COMPENSATING DATA REGISTERS     */
-/*************************************************/
-#define BMI160_BST_AKM_ASAX		(0x60)
-#define BMI160_BST_AKM_ASAY		(0x61)
-#define BMI160_BST_AKM_ASAZ		(0x62)
-/**************************************************/
-/**\name	AKM POWER MODE SELECTION     */
-/*************************************************/
-#define AKM_POWER_DOWN_MODE			(0)
-#define AKM_SINGLE_MEAS_MODE		(1)
-#define FUSE_ROM_MODE				(2)
-/**************************************************/
-/**\name	SECONDARY_MAG POWER MODE SELECTION    */
-/*************************************************/
-#define BMI160_MAG_FORCE_MODE		(0)
-#define BMI160_MAG_SUSPEND_MODE		(1)
-/**************************************************/
-/**\name	MAG POWER MODE SELECTION    */
-/*************************************************/
-#define	FORCE_MODE		(0)
-#define	SUSPEND_MODE	(1)
-#define	NORMAL_MODE		(2)
-#define MAG_SUSPEND_MODE (1)
-/**************************************************/
-/**\name	FIFO CONFIGURATIONS    */
-/*************************************************/
-#define FIFO_HEADER_ENABLE			(0x01)
-#define FIFO_MAG_ENABLE				(0x01)
-#define FIFO_ACCEL_ENABLE			(0x01)
-#define FIFO_GYRO_ENABLE			(0x01)
-#define FIFO_TIME_ENABLE			(0x01)
-#define FIFO_STOPONFULL_ENABLE		(0x01)
-#define FIFO_WM_INTERRUPT_ENABLE	(0x01)
-#define	BMI160_FIFO_INDEX_LENGTH	(1)
-#define	BMI160_FIFO_TAG_INTR_MASK	(0xFC)
-
-/* FIFO definitions*/
-#define FIFO_HEAD_A        (0x84)
-#define FIFO_HEAD_G        (0x88)
-#define FIFO_HEAD_M        (0x90)
-
-#define FIFO_HEAD_G_A	(0x8C)
-#define FIFO_HEAD_M_A   (0x94)
-#define FIFO_HEAD_M_G   (0x98)
-
-#define FIFO_HEAD_M_G_A		(0x9C)
-
-#define FIFO_HEAD_SENSOR_TIME			(0x44)
-#define FIFO_HEAD_INPUT_CONFIG			(0x48)
-#define FIFO_HEAD_SKIP_FRAME			(0x40)
-#define FIFO_HEAD_OVER_READ_LSB			(0x80)
-#define FIFO_HEAD_OVER_READ_MSB			(0x00)
-
-
-/* FIFO 1024 byte, max fifo frame count not over 150 */
-
-#define	FIFO_INPUT_CONFIG_OVER_LEN  ((s8)-11)
-#define	FIFO_OVER_READ_RETURN		((s8)-10)
-#define	FIFO_SENSORTIME_RETURN		((s8)-9)
-#define	FIFO_SKIP_OVER_LEN			((s8)-8)
-#define	FIFO_M_G_A_OVER_LEN			((s8)-7)
-#define	FIFO_M_G_OVER_LEN			((s8)-6)
-#define	FIFO_M_A_OVER_LEN			((s8)-5)
-#define	FIFO_G_A_OVER_LEN			((s8)-4)
-#define	FIFO_M_OVER_LEN				((s8)-3)
-#define	FIFO_G_OVER_LEN				((s8)-2)
-#define	FIFO_A_OVER_LEN				((s8)-1)
-/**************************************************/
-/**\name	ACCEL POWER MODE    */
-/*************************************************/
-#define ACCEL_MODE_NORMAL	(0x11)
-#define	ACCEL_LOWPOWER		(0X12)
-#define	ACCEL_SUSPEND		(0X10)
-/**************************************************/
-/**\name	GYRO POWER MODE    */
-/*************************************************/
-#define GYRO_MODE_SUSPEND		(0x14)
-#define GYRO_MODE_NORMAL		(0x15)
-#define GYRO_MODE_FASTSTARTUP	(0x17)
-/**************************************************/
-/**\name	MAG POWER MODE    */
-/*************************************************/
-#define MAG_MODE_SUSPEND	(0x18)
-#define MAG_MODE_NORMAL		(0x19)
-#define MAG_MODE_LOWPOWER	(0x1A)
-/**************************************************/
-/**\name	ENABLE/DISABLE BIT VALUES    */
-/*************************************************/
-#define BMI160_ENABLE	(0x01)
-#define BMI160_DISABLE	(0x00)
-/**************************************************/
-/**\name	INTERRUPT EDGE TRIGGER ENABLE    */
-/*************************************************/
-#define BMI160_EDGE		(0x01)
-#define BMI160_LEVEL	(0x00)
-/**************************************************/
-/**\name	INTERRUPT LEVEL ENABLE    */
-/*************************************************/
-#define BMI160_LEVEL_LOW		(0x00)
-#define BMI160_LEVEL_HIGH		(0x01)
-/**************************************************/
-/**\name	INTERRUPT OUTPUT ENABLE    */
-/*************************************************/
-#define BMI160_OPEN_DRAIN	(0x01)
-#define BMI160_PUSH_PULL	(0x00)
-
-/* interrupt output enable*/
-#define BMI160_INPUT	(0x01)
-#define BMI160_OUTPUT	(0x00)
-
-/**************************************************/
-/**\name	INTERRUPT TAP SOURCE ENABLE    */
-/*************************************************/
-#define FILTER_DATA		(0x00)
-#define UNFILTER_DATA	(0x01)
-/**************************************************/
-/**\name	SLOW MOTION/ NO MOTION SELECT   */
-/*************************************************/
-#define SLOW_MOTION		(0x00)
-#define NO_MOTION		(0x01)
-/**************************************************/
-/**\name	SIGNIFICANT MOTION SELECTION   */
-/*************************************************/
-#define ANY_MOTION			(0x00)
-#define SIGNIFICANT_MOTION	(0x01)
-/**************************************************/
-/**\name	LATCH DURATION   */
-/*************************************************/
-#define BMI160_LATCH_DUR_NONE				(0x00)
-#define BMI160_LATCH_DUR_312_5_MICRO_SEC	(0x01)
-#define BMI160_LATCH_DUR_625_MICRO_SEC		(0x02)
-#define BMI160_LATCH_DUR_1_25_MILLI_SEC		(0x03)
-#define BMI160_LATCH_DUR_2_5_MILLI_SEC		(0x04)
-#define BMI160_LATCH_DUR_5_MILLI_SEC		(0x05)
-#define BMI160_LATCH_DUR_10_MILLI_SEC		(0x06)
-#define BMI160_LATCH_DUR_20_MILLI_SEC		(0x07)
-#define BMI160_LATCH_DUR_40_MILLI_SEC		(0x08)
-#define BMI160_LATCH_DUR_80_MILLI_SEC		(0x09)
-#define BMI160_LATCH_DUR_160_MILLI_SEC		(0x0A)
-#define BMI160_LATCH_DUR_320_MILLI_SEC		(0x0B)
-#define BMI160_LATCH_DUR_640_MILLI_SEC		(0x0C)
-#define BMI160_LATCH_DUR_1_28_SEC			(0x0D)
-#define BMI160_LATCH_DUR_2_56_SEC			(0x0E)
-#define BMI160_LATCHED						(0x0F)
-/**************************************************/
-/**\name	GYRO OFFSET MASK DEFINITION   */
-/*************************************************/
-#define BMI160_GYRO_MANUAL_OFFSET_0_7	(0x00FF)
-#define BMI160_GYRO_MANUAL_OFFSET_8_9	(0x0300)
-/**************************************************/
-/**\name	STEP CONFIGURATION MASK DEFINITION   */
-/*************************************************/
-#define BMI160_STEP_CONFIG_0_7		(0x00FF)
-#define BMI160_STEP_CONFIG_8_10		(0x0700)
-#define BMI160_STEP_CONFIG_11_14	(0xF000)
-/**************************************************/
-/**\name	DEFINITION USED FOR DIFFERENT WRITE   */
-/*************************************************/
-#define	BMI160_WRITE_TARGET_PAGE0	(0x00)
-#define	BMI160_WRITE_TARGET_PAGE1	(0x01)
-#define	BMI160_WRITE_ENABLE_PAGE1	(0x01)
-#define	BMI160_MANUAL_DISABLE	    (0x00)
-#define	BMI160_MANUAL_ENABLE	    (0x01)
-#define	BMI160_YAS_DISABLE_RCOIL	(0x00)
-#define	BMI160_ENABLE_MAG_IF_MODE	(0x02)
-#define	BMI160_ENABLE_ANY_MOTION_INTR1	(0x04)
-#define	BMI160_ENABLE_ANY_MOTION_INTR2	(0x04)
-#define	BMI160_MAG_DATA_READ_REG        (0x04)
-#define BMI160_BMM_POWER_MODE_REG		(0x06)
-#define	BMI160_ENABLE_ANY_MOTION_AXIS	(0x07)
-#define	BMI160_ENABLE_LOW_G             (0x08)
-#define	BMI160_YAS532_ACQ_START         (0x11)
-#define	BMI160_YAS_DEVICE_ID_REG        (0x80)
-#define	BMI160_FIFO_GYRO_ENABLE         (0x80)
-#define	BMI160_SIG_MOTION_INTR_ENABLE   (0x01)
-#define	BMI160_STEP_DETECT_INTR_ENABLE  (0x01)
-#define	BMI160_LOW_G_INTR_STAT          (0x01)
-#define BMI160_PULL_UP_DATA             (0x30)
-#define BMI160_FIFO_M_G_A_ENABLE        (0xE0)
-#define BMI160_FIFO_M_G_ENABLE          (0xA0)
-#define BMI160_FIFO_M_A_ENABLE          (0x60)
-#define BMI160_FIFO_G_A_ENABLE          (0xC0)
-#define BMI160_FIFO_A_ENABLE            (0x40)
-#define BMI160_FIFO_M_ENABLE            (0x20)
-
-#define BMI160_SEC_IF_BMM150	(0)
-#define BMI160_SEC_IF_AKM09911	(1)
-#define BMI160_SEC_IF_AKM09912	(2)
-#define BMI160_SEC_IF_YAS532	(3)
-#define BMI160_SEC_IF_YAS537	(4)
-/**************************************************/
-/**\name	MAG INIT DEFINITION  */
-/*************************************************/
-#define BMI160_COMMAND_REG_ONE		(0x37)
-#define BMI160_COMMAND_REG_TWO		(0x9A)
-#define BMI160_COMMAND_REG_THREE	(0xC0)
-#define	RESET_STEP_COUNTER			(0xB2)
-/**************************************************/
-/**\name	BIT SLICE GET AND SET FUNCTIONS  */
-/*************************************************/
-#define BMI160_GET_BITSLICE(regvar, bitname)\
-		((regvar & bitname##__MSK) >> bitname##__POS)
-
-
-#define BMI160_SET_BITSLICE(regvar, bitname, val)\
-		((regvar & ~bitname##__MSK) | \
-		((val<<bitname##__POS)&bitname##__MSK))
-
-/**************************************************/
-/**\name	 FUNCTION DECLARATIONS  */
-/*************************************************/
-/**************************************************/
-/**\name	 FUNCTION FOR BMI160 INITIALIZE  */
-/*************************************************/
-/*!
- *	@brief
- *	This function is used for initialize
- *	bus read and bus write functions
- *	assign the chip id and device address
- *	chip id is read in the register 0x00 bit from 0 to 7
- *
- *	@param bmi160 : structure pointer
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *	@note
- *	While changing the parameter of the bmi160_t
- *	consider the following point:
- *	Changing the reference value of the parameter
- *	will changes the local copy or local reference
- *	make sure your changes will not
- *	affect the reference value of the parameter
- *	(Better case don't change the reference value of the parameter)
- *
-*/
-/* renamed from bmi160_init to avoid conflict with UPM code */
-BMI160_RETURN_FUNCTION_TYPE bmi160_init_bus(struct bmi160_t *bmi160);
-/**************************************************/
-/**\name	 FUNCTION FOR READ AND WRITE REGISTERS  */
-/*************************************************/
-/*!
- * @brief
- *	This API write the data to
- *	the given register
- *
- *
- *	@param v_addr_u8 -> Address of the register
- *	@param v_data_u8 -> The data from the register
- *	@param v_len_u8 -> no of bytes to read
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_write_reg(u8 v_addr_u8,
-u8 *v_data_u8, u8 v_len_u8);
-/*!
- * @brief
- *	This API reads the data from
- *	the given register
- *
- *
- *	@param v_addr_u8 -> Address of the register
- *	@param v_data_u8 -> The data from the register
- *	@param v_len_u8 -> no of bytes to read
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_reg(u8 v_addr_u8,
-u8 *v_data_u8, u8 v_len_u8);
-/**************************************************/
-/**\name	 FUNCTION FOR ERROR CODES  */
-/*************************************************/
-/*!
- *	@brief This API used to reads the fatal error
- *	from the Register 0x02 bit 0
- *	This flag will be reset only by power-on-reset and soft reset
- *
- *
- *  @param v_fatal_err_u8 : The status of fatal error
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_fatal_err(u8
-*v_fatal_err_u8);
-/*!
- *	@brief This API used to read the error code
- *	from register 0x02 bit 1 to 4
- *
- *
- *  @param v_err_code_u8 : The status of error codes
- *	error_code  |    description
- *  ------------|---------------
- *	0x00        |no error
- *	0x01        |ACC_CONF error (accel ODR and bandwidth not compatible)
- *	0x02        |GYR_CONF error (Gyroscope ODR and bandwidth not compatible)
- *	0x03        |Under sampling mode and interrupt uses pre filtered data
- *	0x04        |reserved
- *	0x05        |Selected trigger-readout offset in
- *    -         |MAG_IF greater than selected ODR
- *	0x06        |FIFO configuration error for header less mode
- *	0x07        |Under sampling mode and pre filtered data as FIFO source
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_err_code(u8
-*v_error_code_u8);
-/*!
- *	@brief This API Reads the i2c error code from the
- *	Register 0x02 bit 5.
- *	This error occurred in I2C master detected
- *
- *  @param v_i2c_err_code_u8 : The status of i2c fail error
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_i2c_fail_err(u8
-*v_i2c_error_code_u8);
- /*!
- *	@brief This API Reads the dropped command error
- *	from the register 0x02 bit 6
- *
- *
- *  @param v_drop_cmd_err_u8 : The status of drop command error
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_drop_cmd_err(u8
-*v_drop_cmd_err_u8);
-/*!
- *	@brief This API reads the magnetometer data ready
- *	interrupt not active.
- *	It reads from the error register 0x0x2 bit 7
- *
- *
- *
- *
- *  @param v_mag_data_rdy_err_u8 : The status of mag data ready interrupt
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_dada_rdy_err(u8
-*v_mag_data_rdy_err_u8);
-/*!
- *	@brief This API reads the error status
- *	from the error register 0x02 bit 0 to 7
- *
- *  @param v_mag_data_rdy_err_u8 : The status of mag data ready interrupt
- *  @param v_fatal_er_u8r : The status of fatal error
- *  @param v_err_code_u8 : The status of error code
- *  @param v_i2c_fail_err_u8 : The status of I2C fail error
- *  @param v_drop_cmd_err_u8 : The status of drop command error
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_error_status(u8 *v_fatal_er_u8r,
-u8 *v_err_code_u8, u8 *v_i2c_fail_err_u8,
-u8 *v_drop_cmd_err_u8, u8 *v_mag_data_rdy_err_u8);
-/******************************************************************/
-/**\name	 FUNCTIONS FOR MAG,ACCEL AND GYRO POWER MODE STATUS  */
-/*****************************************************************/
-/*!
- *	@brief This API reads the magnetometer power mode from
- *	PMU status register 0x03 bit 0 and 1
- *
- *  @param v_mag_power_mode_stat_u8 : The value of mag power mode
- *	mag_powermode    |   value
- * ------------------|----------
- *    SUSPEND        |   0x00
- *    NORMAL         |   0x01
- *   LOW POWER       |   0x02
- *
- *
- * @note The power mode of mag set by the 0x7E command register
- * @note using the function "bmi160_set_command_register()"
- *  value    |   mode
- *  ---------|----------------
- *   0x18    | MAG_MODE_SUSPEND
- *   0x19    | MAG_MODE_NORMAL
- *   0x1A    | MAG_MODE_LOWPOWER
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_power_mode_stat(u8
-*v_mag_power_mode_stat_u8);
-/*!
- *	@brief This API reads the gyroscope power mode from
- *	PMU status register 0x03 bit 2 and 3
- *
- *  @param v_gyro_power_mode_stat_u8 :	The value of gyro power mode
- *	gyro_powermode   |   value
- * ------------------|----------
- *    SUSPEND        |   0x00
- *    NORMAL         |   0x01
- *   FAST POWER UP   |   0x03
- *
- * @note The power mode of gyro set by the 0x7E command register
- * @note using the function "bmi160_set_command_register()"
- *  value    |   mode
- *  ---------|----------------
- *   0x14    | GYRO_MODE_SUSPEND
- *   0x15    | GYRO_MODE_NORMAL
- *   0x17    | GYRO_MODE_FASTSTARTUP
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_power_mode_stat(u8
-*v_gyro_power_mode_stat_u8);
-/*!
- *	@brief This API reads the accelerometer power mode from
- *	PMU status register 0x03 bit 4 and 5
- *
- *
- *  @param v_accel_power_mode_stat_u8 :	The value of accel power mode
- *	accel_powermode  |   value
- * ------------------|----------
- *    SUSPEND        |   0x00
- *    NORMAL         |   0x01
- *  LOW POWER        |   0x03
- *
- * @note The power mode of accel set by the 0x7E command register
- * @note using the function "bmi160_set_command_register()"
- *  value    |   mode
- *  ---------|----------------
- *   0x11    | ACCEL_MODE_NORMAL
- *   0x12    | ACCEL_LOWPOWER
- *   0x10    | ACCEL_SUSPEND
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_power_mode_stat(u8
-*v_accel_power_mode_stat_u8);
-/*!
- *	@brief This API switch mag interface to normal mode
- *	and confirm whether the mode switching done successfully or not
-*
- *	@return results of bus communication function and current MAG_PMU result
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_interface_normal(void);
-/**************************************************/
-/**\name	 FUNCTION FOR Mag XYZ data read */
-/*************************************************/
-/*!
- *	@brief This API reads magnetometer data X values
- *	from the register 0x04 and 0x05
- *	@brief The mag sensor data read form auxiliary mag
- *
- *  @param v_mag_x_s16 : The value of mag x
- *  @param v_sensor_select_u8 : Mag selection value
- *  value    |   sensor
- *  ---------|----------------
- *   0       | BMM150
- *   1       | AKM09911 or AKM09912
- *
- *	@note For mag data output rate configuration use the following function
- *	@note bmi160_set_mag_output_data_rate()
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_mag_x(s16 *v_mag_x_s16,
-u8 v_sensor_select_u8);
-/*!
- *	@brief This API reads magnetometer data Y values
- *	from the register 0x06 and 0x07
- *	@brief The mag sensor data read form auxiliary mag
- *
- *  @param v_mag_y_s16 : The value of mag y
- *  @param v_sensor_select_u8 : Mag selection value
- *  value    |   sensor
- *  ---------|----------------
- *   0       | BMM150
- *   1       | AKM09911 or AKM09912
- *
- *	@note For mag data output rate configuration use the following function
- *	@note bmi160_set_mag_output_data_rate()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_mag_y(s16 *v_mag_y_s16,
-u8 v_sensor_select_u8);
-/*!
- *	@brief This API reads magnetometer data Z values
- *	from the register 0x08 and 0x09
- *	@brief The mag sensor data read form auxiliary mag
- *
- *  @param v_mag_z_s16 : The value of mag z
- *  @param v_sensor_select_u8 : Mag selection value
- *  value    |   sensor
- *  ---------|----------------
- *   0       | BMM150
- *   1       | AKM09911 or AKM09912
- *
- *	@note For mag data output rate configuration use the following function
- *	@note bmi160_set_mag_output_data_rate()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_mag_z(s16 *v_mag_z_s16,
-u8 v_sensor_select_u8);
-/*!
- *	@brief This API reads magnetometer data RHALL values
- *	from the register 0x0A and 0x0B
- *
- *
- *  @param v_mag_r_s16 : The value of BMM150 r data
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_mag_r(
-s16 *v_mag_r_s16);
-/*!
- *	@brief This API reads magnetometer data X,Y,Z values
- *	from the register 0x04 to 0x09
- *
- *	@brief The mag sensor data read form auxiliary mag
- *
- *  @param mag : The value of mag xyz data
- *  @param v_sensor_select_u8 : Mag selection value
- *  value    |   sensor
- *  ---------|----------------
- *   0       | BMM150
- *   1       | AKM09911 or AKM09912
- *
- *	@note For mag data output rate configuration use the following function
- *	@note bmi160_set_mag_output_data_rate()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_mag_xyz(
-struct bmi160_mag_t *mag, u8 v_sensor_select_u8);
- /*!*
- *	@brief This API reads magnetometer data X,Y,Z,r
- *	values from the register 0x04 to 0x0B
- *
- *	@brief The mag sensor data read form auxiliary mag
- *
- *  @param mag : The value of mag-BMM150 xyzr data
- *
- *	@note For mag data output rate configuration use the following function
- *	@note bmi160_set_mag_output_data_rate()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_mag_xyzr(
-struct bmi160_mag_xyzr_t *mag);
-/**************************************************/
-/**\name	 FUNCTION FOR GYRO XYZ DATA READ  */
-/*************************************************/
-/*!
- *	@brief This API reads gyro data X values
- *	form the register 0x0C and 0x0D
- *
- *
- *
- *
- *  @param v_gyro_x_s16 : The value of gyro x data
- *
- *	@note Gyro Configuration use the following function
- *	@note bmi160_set_gyro_output_data_rate()
- *	@note bmi160_set_gyro_bw()
- *	@note bmi160_set_gyro_range()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_gyro_x(
-s16 *v_gyro_x_s16);
-/*!
- *	@brief This API reads gyro data Y values
- *	form the register 0x0E and 0x0F
- *
- *
- *
- *
- *  @param v_gyro_y_s16 : The value of gyro y data
- *
- *	@note Gyro Configuration use the following function
- *	@note bmi160_set_gyro_output_data_rate()
- *	@note bmi160_set_gyro_bw()
- *	@note bmi160_set_gyro_range()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error result of communication routines
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_gyro_y(
-s16 *v_gyro_y_s16);
-/*!
- *	@brief This API reads gyro data Z values
- *	form the register 0x10 and 0x11
- *
- *
- *
- *
- *  @param v_gyro_z_s16 : The value of gyro z data
- *
- *	@note Gyro Configuration use the following function
- *	@note bmi160_set_gyro_output_data_rate()
- *	@note bmi160_set_gyro_bw()
- *	@note bmi160_set_gyro_range()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_gyro_z(
-s16 *v_gyro_z_s16);
-/*!
- *	@brief This API reads gyro data X,Y,Z values
- *	from the register 0x0C to 0x11
- *
- *
- *
- *
- *  @param gyro : The value of gyro xyz
- *
- *	@note Gyro Configuration use the following function
- *	@note bmi160_set_gyro_output_data_rate()
- *	@note bmi160_set_gyro_bw()
- *	@note bmi160_set_gyro_range()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_gyro_xyz(
-struct bmi160_gyro_t *gyro);
-/**************************************************/
-/**\name	 FUNCTION FOR ACCEL XYZ DATA READ  */
-/*************************************************/
-/*!
- *	@brief This API reads accelerometer data X values
- *	form the register 0x12 and 0x13
- *
- *
- *
- *
- *  @param v_accel_x_s16 : The value of accel x
- *
- *	@note For accel configuration use the following functions
- *	@note bmi160_set_accel_output_data_rate()
- *	@note bmi160_set_accel_bw()
- *	@note bmi160_set_accel_under_sampling_parameter()
- *	@note bmi160_set_accel_range()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_accel_x(
-s16 *v_accel_x_s16);
-/*!
- *	@brief This API reads accelerometer data Y values
- *	form the register 0x14 and 0x15
- *
- *
- *
- *
- *  @param v_accel_y_s16 : The value of accel y
- *
- *	@note For accel configuration use the following functions
- *	@note bmi160_set_accel_output_data_rate()
- *	@note bmi160_set_accel_bw()
- *	@note bmi160_set_accel_under_sampling_parameter()
- *	@note bmi160_set_accel_range()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_accel_y(
-s16 *v_accel_y_s16);
-/*!
- *	@brief This API reads accelerometer data Z values
- *	form the register 0x16 and 0x17
- *
- *
- *
- *
- *  @param v_accel_z_s16 : The value of accel z
- *
- *	@note For accel configuration use the following functions
- *	@note bmi160_set_accel_output_data_rate()
- *	@note bmi160_set_accel_bw()
- *	@note bmi160_set_accel_under_sampling_parameter()
- *	@note bmi160_set_accel_range()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_accel_z(
-s16 *v_accel_z_s16);
-/*!
- *	@brief This API reads accelerometer data X,Y,Z values
- *	from the register 0x12 to 0x17
- *
- *
- *
- *
- *  @param accel :The value of accel xyz
- *
- *	@note For accel configuration use the following functions
- *	@note bmi160_set_accel_output_data_rate()
- *	@note bmi160_set_accel_bw()
- *	@note bmi160_set_accel_under_sampling_parameter()
- *	@note bmi160_set_accel_range()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_accel_xyz(
-struct bmi160_accel_t *accel);
-/**************************************************/
-/**\name	 FUNCTION FOR SENSOR TIME */
-/*************************************************/
-/*!
- *	@brief This API reads sensor_time from the register
- *	0x18 to 0x1A
- *
- *
- *  @param v_sensor_time_u32 : The value of sensor time
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_sensor_time(
-u32 *v_sensor_time_u32);
-/**************************************************/
-/**\name	 FUNCTION FOR GYRO SLEF TEST  */
-/*************************************************/
-/*!
- *	@brief This API reads the Gyroscope self test
- *	status from the register 0x1B bit 1
- *
- *
- *  @param v_gyro_selftest_u8 : The value of gyro self test status
- *  value    |   status
- *  ---------|----------------
- *   0       | Gyroscope self test is running or failed
- *   1       | Gyroscope self test completed successfully
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_selftest(u8
-*v_gyro_selftest_u8);
-/**************************************************/
-/**\name	 FUNCTION FOR MANUAL INTERFACE  */
-/*************************************************/
-/*!
- *	@brief This API reads the status of
- *	mag manual interface operation form the register 0x1B bit 2
- *
- *
- *
- *  @param v_mag_manual_stat_u8 : The value of mag manual operation status
- *  value    |   status
- *  ---------|----------------
- *   0       | Indicates no manual magnetometer
- *   -       | interface operation is ongoing
- *   1       | Indicates manual magnetometer
- *   -       | interface operation is ongoing
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_manual_operation_stat(u8
-*v_mag_manual_stat_u8);
-/**************************************************/
-/**\name	 FUNCTION FOR FAST OFFSET READY  */
-/*************************************************/
-/*!
- *	@brief This API reads the fast offset compensation
- *	status form the register 0x1B bit 3
- *
- *
- *  @param v_foc_rdy_u8 : The status of fast compensation
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_foc_rdy(u8
-*v_foc_rdy_u8);
-/**************************************************/
-/**\name	 FUNCTION FOR NVM READY  */
-/*************************************************/
-/*!
- * @brief This API Reads the nvm_rdy status from the
- *	resister 0x1B bit 4
- *
- *
- *  @param v_nvm_rdy_u8 : The value of NVM ready status
- *  value    |   status
- *  ---------|----------------
- *   0       | NVM write operation in progress
- *   1       | NVM is ready to accept a new write trigger
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_nvm_rdy(u8
-*v_nvm_rdy_u8);
-/**************************************************/
-/**\name	 FUNCTION FOR DATA READY FOR MAG, GYRO, AND ACCEL */
-/*************************************************/
-/*!
- *	@brief This API reads the status of mag data ready
- *	from the register 0x1B bit 5
- *	The status get reset when one mag data register is read out
- *
- *  @param v_data_rdy_u8 : The value of mag data ready status
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_data_rdy_mag(u8
-*v_data_rdy_u8);
-/*!
- *	@brief This API reads the status of gyro data ready form the
- *	register 0x1B bit 6
- *	The status get reset when gyro data register read out
- *
- *
- *	@param v_data_rdy_u8 :	The value of gyro data ready
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_data_rdy(u8
-*v_data_rdy_u8);
-/*!
- *	@brief This API reads the status of accel data ready form the
- *	register 0x1B bit 7
- *	The status get reset when accel data register read out
- *
- *
- *	@param v_data_rdy_u8 :	The value of accel data ready status
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_data_rdy(u8
-*drdy_acc);
-/**************************************************/
-/**\name	 FUNCTION FOR STEP INTERRUPT STATUS  */
-/*************************************************/
-/*!
- *	@brief This API reads the step detector interrupt status
- *	from the register 0x1C bit 0
- *	flag is associated with a specific interrupt function.
- *	It is set when the single tab interrupt triggers. The
- *	setting of INT_LATCH controls if the interrupt
- *	signal and hence the
- *	respective interrupt flag will be
- *	permanently latched, temporarily latched
- *	or not latched.
- *
- *
- *
- *
- *  @param v_step_intr_u8 : The status of step detector interrupt
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_step_intr(u8
-*v_step_intr_u8);
-/**************************************************/
-/**\name	 FUNCTION FOR SIGNIFICANT INTERRUPT STATUS  */
-/*************************************************/
-/*!
- *	@brief This API reads the
- *	significant motion interrupt status
- *	from the register 0x1C bit 1
- *	flag is associated with a specific interrupt function.
- *	It is set when the single tab interrupt triggers. The
- *	setting of INT_LATCH controls if the interrupt
- *	signal and hence the
- *	respective interrupt flag will be
- *	permanently latched, temporarily latched
- *	or not latched.
- *
- *
- *
- *
- *
- *  @param v_significant_intr_u8 : The status of step
- *	motion interrupt
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_significant_intr(u8
-*sigmot_intr);
-/**************************************************/
-/**\name	 FUNCTION FOR ANY MOTION INTERRUPT STATUS  */
-/*************************************************/
- /*!
- *	@brief This API reads the any motion interrupt status
- *	from the register 0x1C bit 2
- *	flag is associated with a specific interrupt function.
- *	It is set when the single tab interrupt triggers. The
- *	setting of INT_LATCH controls if the interrupt
- *	signal and hence the
- *	respective interrupt flag will be
- *	permanently latched, temporarily latched
- *	or not latched.
- *
- *
- *
- *  @param v_any_motion_intr_u8 : The status of any-motion interrupt
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_any_motion_intr(u8
-*v_any_motion_intr_u8);
-/**************************************************/
-/**\name	 FUNCTION FOR PMU TRIGGER INTERRUPT STATUS  */
-/*************************************************/
-/*!
- *	@brief This API reads the power mode trigger interrupt status
- *	from the register 0x1C bit 3
- *	flag is associated with a specific interrupt function.
- *	It is set when the single tab interrupt triggers. The
- *	setting of INT_LATCH controls if the interrupt
- *	signal and hence the
- *	respective interrupt flag will be
- *	permanently latched, temporarily latched
- *	or not latched.
- *
- *
- *
- *
- *
- *  @param v_pmu_trigger_intr_u8 : The status of power mode trigger interrupt
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_pmu_trigger_intr(u8
-*v_pmu_trigger_intr_u8);
-/**************************************************/
-/**\name	 FUNCTION FOR DOUBLE TAB STATUS  */
-/*************************************************/
-/*!
- *	@brief This API reads the double tab status
- *	from the register 0x1C bit 4
- *	flag is associated with a specific interrupt function.
- *	It is set when the single tab interrupt triggers. The
- *	setting of INT_LATCH controls if the interrupt
- *	signal and hence the
- *	respective interrupt flag will be
- *	permanently latched, temporarily latched
- *	or not latched.
- *
- *
- *
- *
- *  @param v_double_tap_intr_u8 :The status of double tab interrupt
- *
- *	@note Double tap interrupt can be configured by the following functions
- *	@note INTERRUPT MAPPING
- *	@note bmi160_set_intr_double_tap()
- *	@note AXIS MAPPING
- *	@note bmi160_get_stat2_tap_first_x()
- *	@note bmi160_get_stat2_tap_first_y()
- *	@note bmi160_get_stat2_tap_first_z()
- *	@note DURATION
- *	@note bmi160_set_intr_tap_durn()
- *	@note THRESHOLD
- *	@note bmi160_set_intr_tap_thres()
- *	@note TAP QUIET
- *	@note bmi160_set_intr_tap_quiet()
- *	@note TAP SHOCK
- *	@note bmi160_set_intr_tap_shock()
- *	@note TAP SOURCE
- *	@note bmi160_set_intr_tap_source()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_double_tap_intr(u8
-*v_double_tap_intr_u8);
-/**************************************************/
-/**\name	 FUNCTION FOR SINGLE TAB STATUS  */
-/*************************************************/
-/*!
- *	@brief This API reads the single tab status
- *	from the register 0x1C bit 5
- *	flag is associated with a specific interrupt function.
- *	It is set when the single tab interrupt triggers. The
- *	setting of INT_LATCH controls if the interrupt
- *	signal and hence the
- *	respective interrupt flag will be
- *	permanently latched, temporarily latched
- *	or not latched.
- *
- *
- *
- *
- *  @param v_single_tap_intr_u8 :The status of single tap interrupt
- *
- *	@note Single tap interrupt can be configured by the following functions
- *	@note INTERRUPT MAPPING
- *	@note bmi160_set_intr_single_tap()
- *	@note AXIS MAPPING
- *	@note bmi160_get_stat2_tap_first_x()
- *	@note bmi160_get_stat2_tap_first_y()
- *	@note bmi160_get_stat2_tap_first_z()
- *	@note DURATION
- *	@note bmi160_set_intr_tap_durn()
- *	@note THRESHOLD
- *	@note bmi160_set_intr_tap_thres()
- *	@note TAP QUIET
- *	@note bmi160_set_intr_tap_quiet()
- *	@note TAP SHOCK
- *	@note bmi160_set_intr_tap_shock()
- *	@note TAP SOURCE
- *	@note bmi160_set_intr_tap_source()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_single_tap_intr(u8
-*v_single_tap_intr_u8);
-/**************************************************/
-/**\name	 FUNCTION FOR ORIENT INTERRUPT STATUS  */
-/*************************************************/
-/*!
- *	@brief This API reads the orient status
- *	from the register 0x1C bit 6
- *	flag is associated with a specific interrupt function.
- *	It is set when the orient interrupt triggers. The
- *	setting of INT_LATCH controls if the
- *	interrupt signal and hence the
- *	respective interrupt flag will be
- *	permanently latched, temporarily latched
- *	or not latched.
- *
- *
- *
- *
- *  @param v_orient_intr_u8 : The status of orient interrupt
- *
- *	@note For orient interrupt configuration use the following functions
- *	@note STATUS
- *	@note bmi160_get_stat0_orient_intr()
- *	@note AXIS MAPPING
- *	@note bmi160_get_stat3_orient_xy()
- *	@note bmi160_get_stat3_orient_z()
- *	@note bmi160_set_intr_orient_axes_enable()
- *	@note INTERRUPT MAPPING
- *	@note bmi160_set_intr_orient()
- *	@note INTERRUPT OUTPUT
- *	@note bmi160_set_intr_orient_ud_enable()
- *	@note THETA
- *	@note bmi160_set_intr_orient_theta()
- *	@note HYSTERESIS
- *	@note bmi160_set_intr_orient_hyst()
- *	@note BLOCKING
- *	@note bmi160_set_intr_orient_blocking()
- *	@note MODE
- *	@note bmi160_set_intr_orient_mode()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_orient_intr(u8
-*v_orient_intr_u8);
-/**************************************************/
-/**\name	 FUNCTION FOR FLAT INTERRUPT STATUS  */
-/*************************************************/
-/*!
- *	@brief This API reads the flat interrupt status
- *	from the register 0x1C bit 7
- *	flag is associated with a specific interrupt function.
- *	It is set when the flat interrupt triggers. The
- *	setting of INT_LATCH controls if the
- *	interrupt signal and hence the
- *	respective interrupt flag will be
- *	permanently latched, temporarily latched
- *	or not latched.
- *
- *
- *
- *
- *  @param v_flat_intr_u8 : The status of  flat interrupt
- *
- *	@note For flat configuration use the following functions
- *	@note STATS
- *	@note bmi160_get_stat0_flat_intr()
- *	@note bmi160_get_stat3_flat()
- *	@note INTERRUPT MAPPING
- *	@note bmi160_set_intr_flat()
- *	@note THETA
- *	@note bmi160_set_intr_flat_theta()
- *	@note HOLD TIME
- *	@note bmi160_set_intr_flat_hold()
- *	@note HYSTERESIS
- *	@note bmi160_set_intr_flat_hyst()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_flat_intr(u8
-*v_flat_intr_u8);
-/**************************************************/
-/**\name	 FUNCTION FOR HIGH_G INTERRUPT STATUS  */
-/*************************************************/
-/*!
- *	@brief This API reads the high_g interrupt status
- *	from the register 0x1D bit 2
- *	flag is associated with a specific interrupt function.
- *	It is set when the high g  interrupt triggers. The
- *	setting of INT_LATCH controls if the interrupt signal and hence the
- *	respective interrupt flag will be permanently
- *	latched, temporarily latched
- *	or not latched.
- *
- *
- *
- *
- *  @param v_high_g_intr_u8 : The status of high_g interrupt
- *
- *	@note High_g interrupt configured by following functions
- *	@note STATUS
- *	@note bmi160_get_stat1_high_g_intr()
- *	@note AXIS MAPPING
- *	@note bmi160_get_stat3_high_g_first_x()
- *	@note bmi160_get_stat3_high_g_first_y()
- *	@note bmi160_get_stat3_high_g_first_z()
- *	@note SIGN MAPPING
- *	@note bmi160_get_stat3_high_g_first_sign()
- *	@note INTERRUPT MAPPING
- *	@note bmi160_set_intr_high_g()
-  *	@note HYSTERESIS
- *	@note bmi160_set_intr_high_g_hyst()
- *	@note DURATION
- *	@note bmi160_set_intr_high_g_durn()
- *	@note THRESHOLD
- *	@note bmi160_set_intr_high_g_thres()
- *	@note SOURCE
- *	@note bmi160_set_intr_low_high_source()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat1_high_g_intr(u8
-*v_high_g_intr_u8);
-/**************************************************/
-/**\name	 FUNCTION FOR LOW_G INTERRUPT STATUS  */
-/*************************************************/
-/*!
- *	@brief This API reads the low g interrupt status
- *	from the register 0x1D bit 3
- *	flag is associated with a specific interrupt function.
- *	It is set when the low g  interrupt triggers. The
- *	setting of INT_LATCH controls if the interrupt signal and hence the
- *	respective interrupt flag will be
- *	permanently latched, temporarily latched
- *	or not latched.
- *
- *
- *
- *
- *  @param v_low_g_intr_u8 : The status of low_g interrupt
- *
- *	@note Low_g interrupt configured by following functions
- *	@note STATUS
- *	@note bmi160_get_stat1_low_g_intr()
- *	@note INTERRUPT MAPPING
- *	@note bmi160_set_intr_low_g()
- *	@note SOURCE
- *	@note bmi160_set_intr_low_high_source()
- *	@note DURATION
- *	@note bmi160_set_intr_low_g_durn()
- *	@note THRESHOLD
- *	@note bmi160_set_intr_low_g_thres()
- *	@note HYSTERESIS
- *	@note bmi160_set_intr_low_g_hyst()
- *	@note MODE
- *	@note bmi160_set_intr_low_g_mode()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat1_low_g_intr(u8
-*v_low_g_intr_u8);
-/**************************************************/
-/**\name	 FUNCTION FOR DATA READY INTERRUPT STATUS  */
-/*************************************************/
-/*!
- *	@brief This API reads data ready interrupt status
- *	from the register 0x1D bit 4
- *	flag is associated with a specific interrupt function.
- *	It is set when the  data ready  interrupt triggers. The
- *	setting of INT_LATCH controls if the interrupt signal and hence the
- *	respective interrupt flag will be
- *	permanently latched, temporarily latched
- *	or not latched.
- *
- *
- *
- *
- *  @param v_data_rdy_intr_u8 : The status of data ready interrupt
- *
- *	@note Data ready interrupt configured by following functions
- *	@note STATUS
- *	@note bmi160_get_stat1_data_rdy_intr()
- *	@note INTERRUPT MAPPING
- *	@note bmi160_set_intr_data_rdy()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat1_data_rdy_intr(u8
-*v_data_rdy_intr_u8);
-/**************************************************/
-/**\name	 FUNCTIONS FOR FIFO FULL AND WATER MARK INTERRUPT STATUS*/
-/*************************************************/
-/*!
- *	@brief This API reads data ready FIFO full interrupt status
- *	from the register 0x1D bit 5
- *	flag is associated with a specific interrupt function.
- *	It is set when the FIFO full interrupt triggers. The
- *	setting of INT_LATCH controls if the
- *	interrupt signal and hence the
- *	respective interrupt flag will
- *	be permanently latched, temporarily latched
- *	or not latched.
- *
- *
- *
- *
- *  @param v_fifo_full_intr_u8 : The status of fifo full interrupt
- *
- *	@note FIFO full interrupt can be configured by following functions
- *	@note bmi160_set_intr_fifo_full()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat1_fifo_full_intr(u8
-*v_fifo_full_intr_u8);
-/*!
- *	@brief This API reads data
- *	 ready FIFO watermark interrupt status
- *	from the register 0x1D bit 6
- *	flag is associated with a specific interrupt function.
- *	It is set when the FIFO watermark interrupt triggers. The
- *	setting of INT_LATCH controls if the
- *	interrupt signal and hence the
- *	respective interrupt flag will be
- *	permanently latched, temporarily latched
- *	or not latched.
- *
- *
- *
- *
- *  @param v_fifo_wm_intr_u8 : The status of fifo water mark interrupt
- *
- *	@note FIFO full interrupt can be configured by following functions
- *	@note bmi160_set_intr_fifo_wm()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat1_fifo_wm_intr(u8
-*v_fifo_wm_intr_u8);
-/**************************************************/
-/**\name	 FUNCTIONS FOR NO MOTION INTERRUPT STATUS*/
-/*************************************************/
-/*!
- *	@brief This API reads data ready no motion interrupt status
- *	from the register 0x1D bit 7
- *	flag is associated with a specific interrupt function.
- *	It is set when the no motion  interrupt triggers. The
- *	setting of INT_LATCH controls if the interrupt signal and hence the
- *	respective interrupt flag will be permanently
- *	latched, temporarily latched
- *	or not latched.
- *
- *
- *
- *
- *  @param v_nomotion_intr_u8 : The status of no motion interrupt
- *
- *	@note No motion interrupt can be configured by following function
- *	@note STATUS
- *	@note bmi160_get_stat1_nomotion_intr()
- *	@note INTERRUPT MAPPING
- *	@note bmi160_set_intr_nomotion()
- *	@note DURATION
- *	@note bmi160_set_intr_slow_no_motion_durn()
- *	@note THRESHOLD
- *	@note bmi160_set_intr_slow_no_motion_thres()
- *	@note SLOW/NO MOTION SELECT
- *	@note bmi160_set_intr_slow_no_motion_select()
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat1_nomotion_intr(u8
-*nomo_intr);
-/**************************************************/
-/**\name	 FUNCTIONS FOR ANY MOTION FIRST XYZ AND SIGN INTERRUPT STATUS*/
-/*************************************************/
-/*!
- *	@brief This API reads the status of any motion first x
- *	from the register 0x1E bit 0
- *
- *
- *  @param v_anymotion_first_x_u8 : The status of any motion first x interrupt
- *  value     |  status
- * -----------|-------------
- *   0        | not triggered
- *   1        | triggered by x axis
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_any_motion_first_x(u8
-*v_anymotion_first_x_u8);
-/*!
- *	@brief This API reads the status of any motion first y interrupt
- *	from the register 0x1E bit 1
- *
- *
- *
- *@param v_any_motion_first_y_u8 : The status of any motion first y interrupt
- *  value     |  status
- * -----------|-------------
- *   0        | not triggered
- *   1        | triggered by y axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_any_motion_first_y(u8
-*v_any_motion_first_y_u8);
-/*!
- *	@brief This API reads the status of any motion first z interrupt
- *	from the register 0x1E bit 2
- *
- *
- *
- *
- *@param v_any_motion_first_z_u8 : The status of any motion first z interrupt
- *  value     |  status
- * -----------|-------------
- *   0        | not triggered
- *   1        | triggered by y axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_any_motion_first_z(u8
-*v_any_motion_first_z_u8);
-/*!
- *	@brief This API reads the any motion sign status from the
- *	register 0x1E bit 3
- *
- *
- *
- *
- *  @param v_anymotion_sign_u8 : The status of any motion sign
- *  value     |  sign
- * -----------|-------------
- *   0        | positive
- *   1        | negative
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_any_motion_sign(u8
-*v_anymotion_sign_u8);
-/**************************************************/
-/**\name	 FUNCTIONS FOR TAP FIRST XYZ AND SIGN INTERRUPT STATUS*/
-/*************************************************/
-/*!
- *	@brief This API reads the any motion tap first x status from the
- *	register 0x1E bit 4
- *
- *
- *
- *
- *  @param v_tap_first_x_u8 :The status of any motion tap first x
- *  value     |  status
- * -----------|-------------
- *   0        | not triggered
- *   1        | triggered by x axis
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_tap_first_x(u8
-*v_tap_first_x_u8);
-/*!
- *	@brief This API reads the tap first y interrupt status from the
- *	register 0x1E bit 5
- *
- *
- *
- *
- *  @param v_tap_first_y_u8 :The status of tap first y interrupt
- *  value     |  status
- * -----------|-------------
- *   0        | not triggered
- *   1        | triggered by y axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_tap_first_y(u8
-*v_tap_first_y_u8);
-/*!
- *	@brief This API reads the tap first z interrupt status  from the
- *	register 0x1E bit 6
- *
- *
- *
- *
- *  @param v_tap_first_z_u8 :The status of tap first z interrupt
- *  value     |  status
- * -----------|-------------
- *   0        | not triggered
- *   1        | triggered by z axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_tap_first_z(u8
-*v_tap_first_z_u8);
-/*!
- *	@brief This API reads the tap sign status from the
- *	register 0x1E bit 7
- *
- *
- *
- *
- *  @param v_tap_sign_u8 : The status of tap sign
- *  value     |  sign
- * -----------|-------------
- *   0        | positive
- *   1        | negative
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_tap_sign(u8
-*tap_sign);
-/**************************************************/
-/**\name	 FUNCTIONS FOR HIGH_G FIRST XYZ AND SIGN INTERRUPT STATUS*/
-/*************************************************/
-/*!
- *	@brief This API reads the high_g first x status from the
- *	register 0x1F bit 0
- *
- *
- *
- *
- *  @param v_high_g_first_x_u8 :The status of high_g first x
- *  value     |  status
- * -----------|-------------
- *   0        | not triggered
- *   1        | triggered by x axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat3_high_g_first_x(u8
-*v_high_g_first_x_u8);
-/*!
- *	@brief This API reads the high_g first y status from the
- *	register 0x1F bit 1
- *
- *
- *
- *
- *  @param v_high_g_first_y_u8 : The status of high_g first y
- *  value     |  status
- * -----------|-------------
- *   0        | not triggered
- *   1        | triggered by y axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat3_high_g_first_y(u8
-*v_high_g_first_y_u8);
-/*!
- *	@brief This API reads the high_g first z status from the
- *	register 0x1F bit 3
- *
- *
- *
- *
- *  @param v_high_g_first_z_u8 : The status of high_g first z
- *  value     |  status
- * -----------|-------------
- *   0        | not triggered
- *   1        | triggered by z axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat3_high_g_first_z(u8
-*v_high_g_first_z_u8);
-/*!
- *	@brief This API reads the high sign status from the
- *	register 0x1F bit 3
- *
- *
- *
- *
- *  @param v_high_g_sign_u8 :The status of high sign
- *  value     |  sign
- * -----------|-------------
- *   0        | positive
- *   1        | negative
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat3_high_g_sign(u8
-*v_high_g_sign_u8);
-/**************************************************/
-/**\name	 FUNCTIONS FOR ORIENT XY AND Z INTERRUPT STATUS*/
-/*************************************************/
-/*!
- *	@brief This API reads the status of orient_xy plane
- *	from the register 0x1F bit 4 and 5
- *
- *
- *  @param v_orient_xy_u8 :The status of orient_xy plane
- *  value     |  status
- * -----------|-------------
- *   0x00     | portrait upright
- *   0x01     | portrait upside down
- *   0x02     | landscape left
- *   0x03     | landscape right
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat3_orient_xy(u8
-*v_orient_xy_u8);
-/*!
- *	@brief This API reads the status of orient z plane
- *	from the register 0x1F bit 6
- *
- *
- *  @param v_orient_z_u8 :The status of orient z
- *  value     |  status
- * -----------|-------------
- *   0x00     | upward looking
- *   0x01     | downward looking
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat3_orient_z(u8
-*v_orient_z_u8);
-/**************************************************/
-/**\name	 FUNCTIONS FOR FLAT INTERRUPT STATUS*/
-/*************************************************/
-/*!
- *	@brief This API reads the flat status from the register
- *	0x1F bit 7
- *
- *
- *  @param v_flat_u8 : The status of flat interrupt
- *  value     |  status
- * -----------|-------------
- *   0x00     | non flat
- *   0x01     | flat position
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat3_flat(u8
-*flat);
-/**************************************************/
-/**\name	 FUNCTION FOR TEMPERATUE READ */
-/*************************************************/
-/*!
- *	@brief This API reads the temperature of the sensor
- *	from the register 0x21 bit 0 to 7
- *
- *
- *
- *  @param v_temp_s16 : The value of temperature
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_temp(s16
-*v_temp_s16);
-/**************************************************/
-/**\name	 FUNCTION FOR FIFO LENGTH AND FIFO DATA READ */
-/*************************************************/
-/*!
- *	@brief This API reads the  of the sensor
- *	form the register 0x23 and 0x24 bit 0 to 7 and 0 to 2
- *	@brief this byte counter is updated each time a complete frame
- *	was read or writtern
- *
- *
- *  @param v_fifo_length_u32 : The value of fifo byte counter
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_fifo_length(
-u32 *v_fifo_length_u32);
-/*!
- *	@brief This API reads the fifo data of the sensor
- *	from the register 0x24
- *	@brief Data format depends on the setting of register FIFO_CONFIG
- *
- *
- *
- *  @param v_fifodata_u8 : Pointer holding the fifo data
- *  @param v_fifo_length_u16 : The value of fifo length maximum
- *	1024
- *
- *	@note For reading FIFO data use the following functions
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_fifo_data(
-u8 *v_fifodata_u8, u16 v_fifo_length_u16);
-/**************************************************/
-/**\name	 FUNCTION FOR ACCEL CONFIGURATIONS */
-/*************************************************/
-/*!
- *	@brief This API is used to get the
- *	accel output date rate form the register 0x40 bit 0 to 3
- *
- *
- *  @param  v_output_data_rate_u8 :The value of accel output date rate
- *  value |  output data rate
- * -------|--------------------------
- *	 0    |	BMI160_ACCEL_OUTPUT_DATA_RATE_RESERVED
- *	 1	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_0_78HZ
- *	 2	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_1_56HZ
- *	 3    |	BMI160_ACCEL_OUTPUT_DATA_RATE_3_12HZ
- *	 4    | BMI160_ACCEL_OUTPUT_DATA_RATE_6_25HZ
- *	 5	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_12_5HZ
- *	 6	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_25HZ
- *	 7	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_50HZ
- *	 8	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_100HZ
- *	 9	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_200HZ
- *	 10	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_400HZ
- *	 11	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_800HZ
- *	 12	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_1600HZ
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_output_data_rate(
-u8 *v_output_data_rate_u8);
-/*!
- *	@brief This API is used to set the
- *	accel output date rate form the register 0x40 bit 0 to 3
- *
- *
- *  @param  v_output_data_rate_u8 :The value of accel output date rate
- *  value |  output data rate
- * -------|--------------------------
- *	 0    |	BMI160_ACCEL_OUTPUT_DATA_RATE_RESERVED
- *	 1	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_0_78HZ
- *	 2	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_1_56HZ
- *	 3    |	BMI160_ACCEL_OUTPUT_DATA_RATE_3_12HZ
- *	 4    | BMI160_ACCEL_OUTPUT_DATA_RATE_6_25HZ
- *	 5	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_12_5HZ
- *	 6	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_25HZ
- *	 7	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_50HZ
- *	 8	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_100HZ
- *	 9	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_200HZ
- *	 10	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_400HZ
- *	 11	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_800HZ
- *	 12	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_1600HZ
- *
- *  @param  v_accel_bw_u8 :The value of accel selected accel bandwidth
- *  value |  output data rate
- * -------|--------------------------
- *    0   |  BMI160_ACCEL_OSR4_AVG1
- *    1   |  BMI160_ACCEL_OSR2_AVG2
- *    2   |  BMI160_ACCEL_NORMAL_AVG4
- *    3   |  BMI160_ACCEL_CIC_AVG8
- *    4   |  BMI160_ACCEL_RES_AVG2
- *    5   |  BMI160_ACCEL_RES_AVG4
- *    6   |  BMI160_ACCEL_RES_AVG8
- *    7   |  BMI160_ACCEL_RES_AVG16
- *    8   |  BMI160_ACCEL_RES_AVG32
- *    9   |  BMI160_ACCEL_RES_AVG64
- *    10  |  BMI160_ACCEL_RES_AVG128
- *
- *
- *
- *	@note Verify the accel bandwidth before seting the
- *  output data rate
- *  bandwidth  | output data rate |  under sampling
- *-------------|------------------|----------------
- *   OSR4      |  12.5 TO 1600    |   0
- *   OSR2      |  12.5 TO 1600    |   0
- *  NORMAL     |  12.5 TO 1600    |   0
- *   CIC       |  12.5 TO 1600    |   0
- *   AVG2      |  0.78 TO 400     |   1
- *   AVG4      |  0.78 TO 200     |   1
- *   AVG8      |  0.78 TO 100     |   1
- *   AVG16     |  0.78 TO 50      |   1
- *   AVG32     |  0.78 TO 25      |   1
- *   AVG64     |  0.78 TO 12.5    |   1
- *   AVG128    |  0.78 TO 6.25    |   1
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_output_data_rate(
-u8 v_output_data_rate_u8, u8 v_accel_bw_u8);
-/*!
- *	@brief This API is used to get the
- *	accel bandwidth from the register 0x40 bit 4 to 6
- *	@brief bandwidth parameter determines filter configuration(acc_us=0)
- *	and averaging for under sampling mode(acc_us=1)
- *
- *
- *  @param  v_bw_u8 : The value of accel bandwidth
- *
- *	@note accel bandwidth depends on under sampling parameter
- *	@note under sampling parameter cab be set by the function
- *	"BMI160_SET_ACCEL_UNDER_SAMPLING_PARAMETER"
- *
- *	@note Filter configuration
- *  accel_us  | Filter configuration
- * -----------|---------------------
- *    0x00    |  OSR4 mode
- *    0x01    |  OSR2 mode
- *    0x02    |  normal mode
- *    0x03    |  CIC mode
- *    0x04    |  Reserved
- *    0x05    |  Reserved
- *    0x06    |  Reserved
- *    0x07    |  Reserved
- *
- *	@note accel under sampling mode
- *  accel_us  | Under sampling mode
- * -----------|---------------------
- *    0x00    |  no averaging
- *    0x01    |  average 2 samples
- *    0x02    |  average 4 samples
- *    0x03    |  average 8 samples
- *    0x04    |  average 16 samples
- *    0x05    |  average 32 samples
- *    0x06    |  average 64 samples
- *    0x07    |  average 128 samples
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_bw(u8 *v_bw_u8);
-/*!
- *	@brief This API is used to set the
- *	accel bandwidth from the register 0x40 bit 4 to 6
- *	@brief bandwidth parameter determines filter configuration(acc_us=0)
- *	and averaging for under sampling mode(acc_us=1)
- *
- *
- *  @param  v_bw_u8 : The value of accel bandwidth
- *
- *	@note accel bandwidth depends on under sampling parameter
- *	@note under sampling parameter cab be set by the function
- *	"BMI160_SET_ACCEL_UNDER_SAMPLING_PARAMETER"
- *
- *	@note Filter configuration
- *  accel_us  | Filter configuration
- * -----------|---------------------
- *    0x00    |  OSR4 mode
- *    0x01    |  OSR2 mode
- *    0x02    |  normal mode
- *    0x03    |  CIC mode
- *    0x04    |  Reserved
- *    0x05    |  Reserved
- *    0x06    |  Reserved
- *    0x07    |  Reserved
- *
- *	@note accel under sampling mode
- *  accel_us  | Under sampling mode
- * -----------|---------------------
- *    0x00    |  no averaging
- *    0x01    |  average 2 samples
- *    0x02    |  average 4 samples
- *    0x03    |  average 8 samples
- *    0x04    |  average 16 samples
- *    0x05    |  average 32 samples
- *    0x06    |  average 64 samples
- *    0x07    |  average 128 samples
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_bw(u8 v_bw_u8);
-/*!
- *	@brief This API is used to get the accel
- *	under sampling parameter form the register 0x40 bit 7
- *
- *
- *
- *
- *	@param  v_accel_under_sampling_u8 : The value of accel under sampling
- *	value    | under_sampling
- * ----------|---------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_under_sampling_parameter(
-u8 *v_accel_under_sampling_u8);
-/*!
- *	@brief This API is used to set the accel
- *	under sampling parameter form the register 0x40 bit 7
- *
- *
- *
- *
- *	@param  v_accel_under_sampling_u8 : The value of accel under sampling
- *	value    | under_sampling
- * ----------|---------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_under_sampling_parameter(
-u8 v_accel_under_sampling_u8);
-/*!
- *	@brief This API is used to get the ranges
- *	(g values) of the accel from the register 0x41 bit 0 to 3
- *
- *
- *
- *
- *  @param v_range_u8 : The value of accel g range
- *	value    | g_range
- * ----------|-----------
- *   0x03    | BMI160_ACCEL_RANGE_2G
- *   0x05    | BMI160_ACCEL_RANGE_4G
- *   0x08    | BMI160_ACCEL_RANGE_8G
- *   0x0C    | BMI160_ACCEL_RANGE_16G
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_range(
-u8 *v_range_u8);
-/*!
- *	@brief This API is used to set the ranges
- *	(g values) of the accel from the register 0x41 bit 0 to 3
- *
- *
- *
- *
- *  @param v_range_u8 : The value of accel g range
- *	value    | g_range
- * ----------|-----------
- *   0x03    | BMI160_ACCEL_RANGE_2G
- *   0x05    | BMI160_ACCEL_RANGE_4G
- *   0x08    | BMI160_ACCEL_RANGE_8G
- *   0x0C    | BMI160_ACCEL_RANGE_16G
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_range(
-u8 v_range_u8);
-/**************************************************/
-/**\name	 FUNCTION FOR GYRO CONFIGURATIONS */
-/*************************************************/
-/*!
- *	@brief This API is used to get the
- *	gyroscope output data rate from the register 0x42 bit 0 to 3
- *
- *
- *
- *
- *  @param  v_output_data_rate_u8 :The value of gyro output data rate
- *  value     |      gyro output data rate
- * -----------|-----------------------------
- *   0x00     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *   0x01     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *   0x02     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *   0x03     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *   0x04     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *   0x05     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *   0x06     | BMI160_GYRO_OUTPUT_DATA_RATE_25HZ
- *   0x07     | BMI160_GYRO_OUTPUT_DATA_RATE_50HZ
- *   0x08     | BMI160_GYRO_OUTPUT_DATA_RATE_100HZ
- *   0x09     | BMI160_GYRO_OUTPUT_DATA_RATE_200HZ
- *   0x0A     | BMI160_GYRO_OUTPUT_DATA_RATE_400HZ
- *   0x0B     | BMI160_GYRO_OUTPUT_DATA_RATE_800HZ
- *   0x0C     | BMI160_GYRO_OUTPUT_DATA_RATE_1600HZ
- *   0x0D     | BMI160_GYRO_OUTPUT_DATA_RATE_3200HZ
- *   0x0E     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *   0x0F     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_output_data_rate(
-u8 *gyro_output_typer);
-/*!
- *	@brief This API is used to set the
- *	gyroscope output data rate from the register 0x42 bit 0 to 3
- *
- *
- *
- *
- *  @param  v_output_data_rate_u8 :The value of gyro output data rate
- *  value     |      gyro output data rate
- * -----------|-----------------------------
- *   0x00     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *   0x01     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *   0x02     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *   0x03     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *   0x04     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *   0x05     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *   0x06     | BMI160_GYRO_OUTPUT_DATA_RATE_25HZ
- *   0x07     | BMI160_GYRO_OUTPUT_DATA_RATE_50HZ
- *   0x08     | BMI160_GYRO_OUTPUT_DATA_RATE_100HZ
- *   0x09     | BMI160_GYRO_OUTPUT_DATA_RATE_200HZ
- *   0x0A     | BMI160_GYRO_OUTPUT_DATA_RATE_400HZ
- *   0x0B     | BMI160_GYRO_OUTPUT_DATA_RATE_800HZ
- *   0x0C     | BMI160_GYRO_OUTPUT_DATA_RATE_1600HZ
- *   0x0D     | BMI160_GYRO_OUTPUT_DATA_RATE_3200HZ
- *   0x0E     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *   0x0F     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_output_data_rate(
-u8 gyro_output_typer);
-/*!
- *	@brief This API is used to get the
- *	data of gyro from the register 0x42 bit 4 to 5
- *
- *
- *
- *
- *  @param  v_bw_u8 : The value of gyro bandwidth
- *  value     | gyro bandwidth
- *  ----------|----------------
- *   0x00     | BMI160_GYRO_OSR4_MODE
- *   0x01     | BMI160_GYRO_OSR2_MODE
- *   0x02     | BMI160_GYRO_NORMAL_MODE
- *   0x03     | BMI160_GYRO_CIC_MODE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_bw(u8 *v_bw_u8);
-/*!
- *	@brief This API is used to set the
- *	data of gyro from the register 0x42 bit 4 to 5
- *
- *
- *
- *
- *  @param  v_bw_u8 : The value of gyro bandwidth
- *  value     | gyro bandwidth
- *  ----------|----------------
- *   0x00     | BMI160_GYRO_OSR4_MODE
- *   0x01     | BMI160_GYRO_OSR2_MODE
- *   0x02     | BMI160_GYRO_NORMAL_MODE
- *   0x03     | BMI160_GYRO_CIC_MODE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_bw(u8 v_bw_u8);
-/*!
- *	@brief This API reads the range
- *	of gyro from the register 0x43 bit 0 to 2
- *
- *  @param  v_range_u8 : The value of gyro range
- *   value    |    range
- *  ----------|-------------------------------
- *    0x00    | BMI160_GYRO_RANGE_2000_DEG_SEC
- *    0x01    | BMI160_GYRO_RANGE_1000_DEG_SEC
- *    0x02    | BMI160_GYRO_RANGE_500_DEG_SEC
- *    0x03    | BMI160_GYRO_RANGE_250_DEG_SEC
- *    0x04    | BMI160_GYRO_RANGE_125_DEG_SEC
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_range(
-u8 *v_range_u8);
-/*!
- *	@brief This API set the range
- *	of gyro from the register 0x43 bit 0 to 2
- *
- *  @param  v_range_u8 : The value of gyro range
- *   value    |    range
- *  ----------|-------------------------------
- *    0x00    | BMI160_GYRO_RANGE_2000_DEG_SEC
- *    0x01    | BMI160_GYRO_RANGE_1000_DEG_SEC
- *    0x02    | BMI160_GYRO_RANGE_500_DEG_SEC
- *    0x03    | BMI160_GYRO_RANGE_250_DEG_SEC
- *    0x04    | BMI160_GYRO_RANGE_125_DEG_SEC
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_range(
-u8 v_range_u8);
-/**************************************************/
-/**\name	 FUNCTION FOR MAG CONFIGURATIONS */
-/*************************************************/
-/*!
- *	@brief This API is used to get the
- *	output data rate of magnetometer from the register 0x44 bit 0 to 3
- *
- *
- *
- *
- *  @param  v_output_data_rat_u8e : The value of mag output data rate
- *  value   |    mag output data rate
- * ---------|---------------------------
- *  0x00    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED
- *  0x01    |BMI160_MAG_OUTPUT_DATA_RATE_0_78HZ
- *  0x02    |BMI160_MAG_OUTPUT_DATA_RATE_1_56HZ
- *  0x03    |BMI160_MAG_OUTPUT_DATA_RATE_3_12HZ
- *  0x04    |BMI160_MAG_OUTPUT_DATA_RATE_6_25HZ
- *  0x05    |BMI160_MAG_OUTPUT_DATA_RATE_12_5HZ
- *  0x06    |BMI160_MAG_OUTPUT_DATA_RATE_25HZ
- *  0x07    |BMI160_MAG_OUTPUT_DATA_RATE_50HZ
- *  0x08    |BMI160_MAG_OUTPUT_DATA_RATE_100HZ
- *  0x09    |BMI160_MAG_OUTPUT_DATA_RATE_200HZ
- *  0x0A    |BMI160_MAG_OUTPUT_DATA_RATE_400HZ
- *  0x0B    |BMI160_MAG_OUTPUT_DATA_RATE_800HZ
- *  0x0C    |BMI160_MAG_OUTPUT_DATA_RATE_1600HZ
- *  0x0D    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED0
- *  0x0E    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED1
- *  0x0F    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED2
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_output_data_rate(u8 *odr);
-/*!
- *	@brief This API is used to set the
- *	output data rate of magnetometer from the register 0x44 bit 0 to 3
- *
- *
- *
- *
- *  @param  v_output_data_rat_u8e : The value of mag output data rate
- *  value   |    mag output data rate
- * ---------|---------------------------
- *  0x00    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED
- *  0x01    |BMI160_MAG_OUTPUT_DATA_RATE_0_78HZ
- *  0x02    |BMI160_MAG_OUTPUT_DATA_RATE_1_56HZ
- *  0x03    |BMI160_MAG_OUTPUT_DATA_RATE_3_12HZ
- *  0x04    |BMI160_MAG_OUTPUT_DATA_RATE_6_25HZ
- *  0x05    |BMI160_MAG_OUTPUT_DATA_RATE_12_5HZ
- *  0x06    |BMI160_MAG_OUTPUT_DATA_RATE_25HZ
- *  0x07    |BMI160_MAG_OUTPUT_DATA_RATE_50HZ
- *  0x08    |BMI160_MAG_OUTPUT_DATA_RATE_100HZ
- *  0x09    |BMI160_MAG_OUTPUT_DATA_RATE_200HZ
- *  0x0A    |BMI160_MAG_OUTPUT_DATA_RATE_400HZ
- *  0x0B    |BMI160_MAG_OUTPUT_DATA_RATE_800HZ
- *  0x0C    |BMI160_MAG_OUTPUT_DATA_RATE_1600HZ
- *  0x0D    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED0
- *  0x0E    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED1
- *  0x0F    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED2
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_output_data_rate(u8 odr);
-/**************************************************/
-/**\name	 FUNCTION FOR FIFO CONFIGURATIONS */
-/*************************************************/
- /*!
- *	@brief This API is used to read Down sampling
- *	for gyro (2**downs_gyro) in the register 0x45 bit 0 to 2
- *
- *
- *
- *
- *  @param v_fifo_down_gyro_u8 :The value of gyro fifo down
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_down_gyro(
-u8 *v_fifo_down_gyro_u8);
- /*!
- *	@brief This API is used to set Down sampling
- *	for gyro (2**downs_gyro) in the register 0x45 bit 0 to 2
- *
- *
- *
- *
- *  @param v_fifo_down_gyro_u8 :The value of gyro fifo down
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_down_gyro(
-u8 v_fifo_down_gyro_u8);
-/*!
- *	@brief This API is used to read gyro fifo filter data
- *	from the register 0x45 bit 3
- *
- *
- *
- *  @param v_gyro_fifo_filter_data_u8 :The value of gyro filter data
- *  value      |  gyro_fifo_filter_data
- * ------------|-------------------------
- *    0x00     |  Unfiltered data
- *    0x01     |  Filtered data
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_fifo_filter_data(
-u8 *v_gyro_fifo_filter_data_u8);
-/*!
- *	@brief This API is used to set gyro fifo filter data
- *	from the register 0x45 bit 3
- *
- *
- *
- *  @param v_gyro_fifo_filter_data_u8 :The value of gyro filter data
- *  value      |  gyro_fifo_filter_data
- * ------------|-------------------------
- *    0x00     |  Unfiltered data
- *    0x01     |  Filtered data
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_fifo_filter_data(
-u8 v_gyro_fifo_filter_data_u8);
-/*!
- *	@brief This API is used to read Down sampling
- *	for accel (2*downs_accel) from the register 0x45 bit 4 to 6
- *
- *
- *
- *
- *  @param v_fifo_down_u8 :The value of accel fifo down
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_down_accel(
-u8 *v_fifo_down_u8);
- /*!
- *	@brief This API is used to set Down sampling
- *	for accel (2*downs_accel) from the register 0x45 bit 4 to 6
- *
- *
- *
- *
- *  @param v_fifo_down_u8 :The value of accel fifo down
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_down_accel(
-u8 v_fifo_down_u8);
-/*!
- *	@brief This API is used to read accel fifo filter data
- *	from the register 0x45 bit 7
- *
- *
- *
- *  @param v_accel_fifo_filter_u8 :The value of accel filter data
- *  value      |  accel_fifo_filter_data
- * ------------|-------------------------
- *    0x00     |  Unfiltered data
- *    0x01     |  Filtered data
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_fifo_filter_data(
-u8 *v_accel_fifo_filter_u8);
-/*!
- *	@brief This API is used to set accel fifo filter data
- *	from the register 0x45 bit 7
- *
- *
- *
- *  @param v_accel_fifo_filter_u8 :The value of accel filter data
- *  value      |  accel_fifo_filter_data
- * ------------|-------------------------
- *    0x00     |  Unfiltered data
- *    0x01     |  Filtered data
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_fifo_filter_data(
-u8 v_accel_fifo_filter_u8);
-/**************************************************/
-/**\name	 FUNCTION FOR FIFO WATER MARK ENABLE */
-/*************************************************/
-/*!
- *	@brief This API is used to Trigger an interrupt
- *	when FIFO contains water mark level from the register 0x46 bit 0 to 7
- *
- *
- *
- *  @param  v_fifo_wm_u8 : The value of fifo water mark level
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_wm(
-u8 *v_fifo_wm_u8);
-/*!
- *	@brief This API is used to Trigger an interrupt
- *	when FIFO contains water mark level from the register 0x46 bit 0 to 7
- *
- *
- *
- *  @param  v_fifo_wm_u8 : The value of fifo water mark level
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_wm(
-u8 v_fifo_wm_u8);
-/**************************************************/
-/**\name	 FUNCTION FOR FIFO CONFIGURATIONS */
-/*************************************************/
-/*!
- *	@brief This API reads fifo sensor time
- *	frame after the last valid data frame form the register  0x47 bit 1
- *
- *
- *
- *
- *  @param v_fifo_time_enable_u8 : The value of sensor time
- *  value      |  fifo sensor time
- * ------------|-------------------------
- *    0x00     |  do not return sensortime frame
- *    0x01     |  return sensortime frame
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_time_enable(
-u8 *v_fifo_time_enable_u8);
-/*!
- *	@brief This API set fifo sensor time
- *	frame after the last valid data frame form the register  0x47 bit 1
- *
- *
- *
- *
- *  @param v_fifo_time_enable_u8 : The value of sensor time
- *  value      |  fifo sensor time
- * ------------|-------------------------
- *    0x00     |  do not return sensortime frame
- *    0x01     |  return sensortime frame
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_time_enable(
-u8 v_fifo_time_enable_u8);
-/*!
- *	@brief This API reads FIFO tag interrupt2 enable status
- *	from the resister 0x47 bit 2
- *
- *  @param v_fifo_tag_intr2_u8 : The value of fifo tag interrupt
- *	value    | fifo tag interrupt
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_tag_intr2_enable(
-u8 *v_fifo_tag_intr2_u8);
-/*!
- *	@brief This API set FIFO tag interrupt2 enable status
- *	from the resister 0x47 bit 2
- *
- *  @param v_fifo_tag_intr2_u8 : The value of fifo tag interrupt
- *	value    | fifo tag interrupt
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_tag_intr2_enable(
-u8 v_fifo_tag_intr2_u8);
-/*!
- *	@brief This API get FIFO tag interrupt1 enable status
- *	from the resister 0x47 bit 3
- *
- *  @param v_fifo_tag_intr1_u8 :The value of fifo tag interrupt1
- *	value    | fifo tag interrupt
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_tag_intr1_enable(
-u8 *v_fifo_tag_intr1_u8);
-/*!
- *	@brief This API set FIFO tag interrupt1 enable status
- *	from the resister 0x47 bit 3
- *
- *  @param v_fifo_tag_intr1_u8 :The value of fifo tag interrupt1
- *	value    | fifo tag interrupt
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_tag_intr1_enable(
-u8 v_fifo_tag_intr1_u8);
-/*!
- *	@brief This API reads FIFO frame
- *	header enable from the register 0x47 bit 4
- *
- *  @param v_fifo_header_u8 :The value of fifo header
- *	value    | fifo header
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_header_enable(
-u8 *v_fifo_header_u8);
-/*!
- *	@brief This API set FIFO frame
- *	header enable from the register 0x47 bit 4
- *
- *  @param v_fifo_header_u8 :The value of fifo header
- *	value    | fifo header
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_header_enable(
-u8 v_fifo_header_u8);
-/*!
- *	@brief This API is used to read stored
- *	magnetometer data in FIFO (all 3 axes) from the register 0x47 bit 5
- *
- *  @param v_fifo_mag_u8 : The value of fifo mag enble
- *	value    | fifo mag
- * ----------|-------------------
- *  0x00     |  no magnetometer data is stored
- *  0x01     |  magnetometer data is stored
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_mag_enable(
-u8 *v_fifo_mag_u8);
-/*!
- *	@brief This API is used to set stored
- *	magnetometer data in FIFO (all 3 axes) from the register 0x47 bit 5
- *
- *  @param v_fifo_mag_u8 : The value of fifo mag enble
- *	value    | fifo mag
- * ----------|-------------------
- *  0x00     |  no magnetometer data is stored
- *  0x01     |  magnetometer data is stored
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_mag_enable(
-u8 v_fifo_mag_u8);
-/*!
- *	@brief This API is used to read stored
- *	accel data in FIFO (all 3 axes) from the register 0x47 bit 6
- *
- *  @param v_fifo_accel_u8 : The value of fifo accel enble
- *	value    | fifo accel
- * ----------|-------------------
- *  0x00     |  no accel data is stored
- *  0x01     |  accel data is stored
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_accel_enable(
-u8 *v_fifo_accel_u8);
-/*!
- *	@brief This API is used to set stored
- *	accel data in FIFO (all 3 axes) from the register 0x47 bit 6
- *
- *  @param v_fifo_accel_u8 : The value of fifo accel enble
- *	value    | fifo accel
- * ----------|-------------------
- *  0x00     |  no accel data is stored
- *  0x01     |  accel data is stored
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_accel_enable(
-u8 v_fifo_accel_u8);
-/*!
- *	@brief This API is used to read stored
- *	 gyro data in FIFO (all 3 axes) from the resister 0x47 bit 7
- *
- *
- *  @param v_fifo_gyro_u8 : The value of fifo gyro enble
- *	value    | fifo gyro
- * ----------|-------------------
- *  0x00     |  no gyro data is stored
- *  0x01     |  gyro data is stored
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_gyro_enable(
-u8 *v_fifo_gyro_u8);
-/*!
- *	@brief This API is used to set stored
- *	gyro data in FIFO (all 3 axes) from the resister 0x47 bit 7
- *
- *
- *  @param v_fifo_gyro_u8 : The value of fifo gyro enble
- *	value    | fifo gyro
- * ----------|-------------------
- *  0x00     |  no gyro data is stored
- *  0x01     |  gyro data is stored
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_gyro_enable(
-u8 v_fifo_gyro_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR MAG I2C ADDRESS SELECTION          */
-/***************************************************************/
-/*!
- *	@brief This API is used to read
- *	I2C device address of auxiliary mag from the register 0x4B bit 1 to 7
- *
- *
- *
- *
- *  @param v_i2c_device_addr_u8 : The value of mag I2C device address
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_i2c_device_addr(
-u8 *v_i2c_device_addr_u8);
-/*!
- *	@brief This API is used to set
- *	I2C device address of auxiliary mag from the register 0x4B bit 1 to 7
- *
- *
- *
- *
- *  @param v_i2c_device_addr_u8 : The value of mag I2C device address
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_i2c_device_addr(
-u8 v_i2c_device_addr_u8);
-/*!
- *	@brief This API is used to read
- *	Burst data length (1,2,6,8 byte) from the register 0x4C bit 0 to 1
- *
- *
- *
- *
- *  @param v_mag_burst_u8 : The data of mag burst read lenth
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_burst(
-u8 *v_mag_burst_u8);
-/*!
- *	@brief This API is used to set
- *	Burst data length (1,2,6,8 byte) from the register 0x4C bit 0 to 1
- *
- *
- *
- *
- *  @param v_mag_burst_u8 : The data of mag burst read lenth
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_burst(
-u8 v_mag_burst_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR MAG OFFSET         */
-/***************************************************************/
-/*!
- *	@brief This API is used to read
- *	trigger-readout offset in units of 2.5 ms. If set to zero,
- *	the offset is maximum, i.e. after readout a trigger
- *	is issued immediately. from the register 0x4C bit 2 to 5
- *
- *
- *
- *
- *  @param v_mag_offset_u8 : The value of mag offset
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_offset(
-u8 *v_mag_offset_u8);
-/*!
- *	@brief This API is used to set
- *	trigger-readout offset in units of 2.5 ms. If set to zero,
- *	the offset is maximum, i.e. after readout a trigger
- *	is issued immediately. from the register 0x4C bit 2 to 5
- *
- *
- *
- *
- *  @param v_mag_offset_u8 : The value of mag offset
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_offset(
-u8 v_mag_offset_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR MAG MANUAL/AUTO MODE SELECTION          */
-/***************************************************************/
-/*!
- *	@brief This API is used to read
- *	Enable register access on MAG_IF[2] or MAG_IF[3] writes.
- *	This implies that the DATA registers are not updated with
- *	magnetometer values. Accessing magnetometer requires
- *	the magnetometer in normal mode in PMU_STATUS.
- *	from the register 0x4C bit 7
- *
- *
- *
- *  @param v_mag_manual_u8 : The value of mag manual enable
- *	value    | mag manual
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_manual_enable(
-u8 *v_mag_manual_u8);
-/*!
- *	@brief This API is used to set
- *	Enable register access on MAG_IF[2] or MAG_IF[3] writes.
- *	This implies that the DATA registers are not updated with
- *	magnetometer values. Accessing magnetometer requires
- *	the magnetometer in normal mode in PMU_STATUS.
- *	from the register 0x4C bit 7
- *
- *
- *
- *  @param v_mag_manual_u8 : The value of mag manual enable
- *	value    | mag manual
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_manual_enable(
-u8 v_mag_manual_u8);
-/***************************************************************/
-/**\name	FUNCTIONS FOR MAG READ, WRITE AND WRITE DATA ADDRESS  */
-/***************************************************************/
-/*!
- *	@brief This API is used to read data
- *	magnetometer address to read from the register 0x4D bit 0 to 7
- *	@brief It used to provide mag read address of auxiliary mag
- *
- *
- *
- *
- *  @param  v_mag_read_addr_u8 : The value of address need to be read
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_read_addr(
-u8 *v_mag_read_addr_u8);
-/*!
- *	@brief This API is used to set
- *	magnetometer write address from the register 0x4D bit 0 to 7
- *	@brief mag write address writes the address of auxiliary mag to write
- *
- *
- *
- *  @param v_mag_read_addr_u8:
- *	The data of auxiliary mag address to write data
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_read_addr(
-u8 v_mag_read_addr_u8);
-/*!
- *	@brief This API is used to read
- *	magnetometer write address from the register 0x4E bit 0 to 7
- *	@brief mag write address writes the address of auxiliary mag to write
- *
- *
- *
- *  @param  v_mag_write_addr_u8:
- *	The data of auxiliary mag address to write data
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_write_addr(
-u8 *v_mag_write_addr_u8);
-/*!
- *	@brief This API is used to set
- *	magnetometer write address from the register 0x4E bit 0 to 7
- *	@brief mag write address writes the address of auxiliary mag to write
- *
- *
- *
- *  @param  v_mag_write_addr_u8:
- *	The data of auxiliary mag address to write data
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_write_addr(
-u8 v_mag_write_addr_u8);
-/*!
- *	@brief This API is used to read magnetometer write data
- *	form the resister 0x4F bit 0 to 7
- *	@brief This writes the data will be wrote to mag
- *
- *
- *
- *  @param  v_mag_write_data_u8: The value of mag data
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_write_data(
-u8 *v_mag_write_data_u8);
-/*!
- *	@brief This API is used to set magnetometer write data
- *	form the resister 0x4F bit 0 to 7
- *	@brief This writes the data will be wrote to mag
- *
- *
- *
- *  @param  v_mag_write_data_u8: The value of mag data
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_write_data(
-u8 v_mag_write_data_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR INTERRUPT ENABLE OF
-ANY-MOTION XYZ, DOUBLE AND SINGLE TAP, ORIENT AND FLAT         */
-/***************************************************************/
-/*!
- *	@brief  This API is used to read
- *	interrupt enable from the register 0x50 bit 0 to 7
- *
- *
- *
- *
- *	@param v_enable_u8 : Value to decided to select interrupt
- *   v_enable_u8   |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_ANY_MOTION_X_ENABLE
- *       1         | BMI160_ANY_MOTION_Y_ENABLE
- *       2         | BMI160_ANY_MOTION_Z_ENABLE
- *       3         | BMI160_DOUBLE_TAP_ENABLE
- *       4         | BMI160_SINGLE_TAP_ENABLE
- *       5         | BMI160_ORIENT_ENABLE
- *       6         | BMI160_FLAT_ENABLE
- *
- *	@param v_intr_enable_zero_u8 : The interrupt enable value
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_enable_0(
-u8 enable, u8 *v_intr_enable_zero_u8);
-/*!
- *	@brief  This API is used to set
- *	interrupt enable from the register 0x50 bit 0 to 7
- *
- *
- *
- *
- *	@param v_enable_u8 : Value to decided to select interrupt
- *   v_enable_u8   |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_ANY_MOTION_X_ENABLE
- *       1         | BMI160_ANY_MOTION_Y_ENABLE
- *       2         | BMI160_ANY_MOTION_Z_ENABLE
- *       3         | BMI160_DOUBLE_TAP_ENABLE
- *       4         | BMI160_SINGLE_TAP_ENABLE
- *       5         | BMI160_ORIENT_ENABLE
- *       6         | BMI160_FLAT_ENABLE
- *
- *	@param v_intr_enable_zero_u8 : The interrupt enable value
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_enable_0(
-u8 enable, u8 v_intr_enable_zero_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR INTERRUPT ENABLE OF
-HIGH_G XYZ, LOW_G, DATA READY, FIFO FULL AND FIFO WATER MARK  */
-/***************************************************************/
-/*!
- *	@brief  This API is used to read
- *	interrupt enable byte1 from the register 0x51 bit 0 to 6
- *	@brief It read the high_g_x,high_g_y,high_g_z,low_g_enable
- *	data ready, fifo full and fifo water mark.
- *
- *
- *
- *  @param  v_enable_u8 :  The value of interrupt enable
- *	@param v_enable_u8 : Value to decided to select interrupt
- *   v_enable_u8   |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_HIGH_G_X_ENABLE
- *       1         | BMI160_HIGH_G_Y_ENABLE
- *       2         | BMI160_HIGH_G_Z_ENABLE
- *       3         | BMI160_LOW_G_ENABLE
- *       4         | BMI160_DATA_RDY_ENABLE
- *       5         | BMI160_FIFO_FULL_ENABLE
- *       6         | BMI160_FIFO_WM_ENABLE
- *
- *	@param v_intr_enable_1_u8 : The interrupt enable value
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_enable_1(
-u8 enable, u8 *v_intr_enable_1_u8);
-/*!
- *	@brief  This API is used to set
- *	interrupt enable byte1 from the register 0x51 bit 0 to 6
- *	@brief It read the high_g_x,high_g_y,high_g_z,low_g_enable
- *	data ready, fifo full and fifo water mark.
- *
- *
- *
- *  @param  v_enable_u8 :  The value of interrupt enable
- *	@param v_enable_u8 : Value to decided to select interrupt
- *   v_enable_u8   |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_HIGH_G_X_ENABLE
- *       1         | BMI160_HIGH_G_Y_ENABLE
- *       2         | BMI160_HIGH_G_Z_ENABLE
- *       3         | BMI160_LOW_G_ENABLE
- *       4         | BMI160_DATA_RDY_ENABLE
- *       5         | BMI160_FIFO_FULL_ENABLE
- *       6         | BMI160_FIFO_WM_ENABLE
- *
- *	@param v_intr_enable_1_u8 : The interrupt enable value
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_enable_1(
-u8 enable, u8 v_intr_enable_1_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR INTERRUPT ENABLE OF
-NO MOTION XYZ  */
-/***************************************************************/
-/*!
- *	@brief  This API is used to read
- *	interrupt enable byte2 from the register bit 0x52 bit 0 to 3
- *	@brief It reads no motion x,y and z
- *
- *
- *
- *	@param v_enable_u8: The value of interrupt enable
- *   v_enable_u8   |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_NOMOTION_X_ENABLE
- *       1         | BMI160_NOMOTION_Y_ENABLE
- *       2         | BMI160_NOMOTION_Z_ENABLE
- *
- *	@param v_intr_enable_2_u8 : The interrupt enable value
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_enable_2(
-u8 enable, u8 *v_intr_enable_2_u8);
-/*!
- *	@brief  This API is used to set
- *	interrupt enable byte2 from the register bit 0x52 bit 0 to 3
- *	@brief It reads no motion x,y and z
- *
- *
- *
- *	@param v_enable_u8: The value of interrupt enable
- *   v_enable_u8   |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_NOMOTION_X_ENABLE
- *       1         | BMI160_NOMOTION_Y_ENABLE
- *       2         | BMI160_NOMOTION_Z_ENABLE
- *
- *	@param v_intr_enable_2_u8 : The interrupt enable value
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_enable_2(
-u8 enable, u8 v_intr_enable_2_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR INTERRUPT ENABLE OF
-  STEP DETECTOR */
-/***************************************************************/
- /*!
- *	@brief This API is used to read
- *	interrupt enable step detector interrupt from
- *	the register bit 0x52 bit 3
- *
- *
- *
- *
- *	@param v_step_intr_u8 : The value of step detector interrupt enable
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_step_detector_enable(
-u8 *v_step_intr_u8);
- /*!
- *	@brief This API is used to set
- *	interrupt enable step detector interrupt from
- *	the register bit 0x52 bit 3
- *
- *
- *
- *
- *	@param v_step_intr_u8 : The value of step detector interrupt enable
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_step_detector_enable(
-u8 v_step_intr_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR INTERRUPT CONTROL */
-/***************************************************************/
-/*!
- *	@brief  Configure trigger condition of interrupt1
- *	and interrupt2 pin from the register 0x53
- *	@brief interrupt1 - bit 0
- *	@brief interrupt2 - bit 4
- *
- *  @param v_channel_u8: The value of edge trigger selection
- *   v_channel_u8  |   Edge trigger
- *  ---------------|---------------
- *       0         | BMI160_INTR1_EDGE_CTRL
- *       1         | BMI160_INTR2_EDGE_CTRL
- *
- *	@param v_intr_edge_ctrl_u8 : The value of edge trigger enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_EDGE
- *  0x00     |  BMI160_LEVEL
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_edge_ctrl(
-u8 v_channel_u8, u8 *v_intr_edge_ctrl_u8);
-/*!
- *	@brief  Configure trigger condition of interrupt1
- *	and interrupt2 pin from the register 0x53
- *	@brief interrupt1 - bit 0
- *	@brief interrupt2 - bit 4
- *
- *  @param v_channel_u8: The value of edge trigger selection
- *   v_channel_u8  |   Edge trigger
- *  ---------------|---------------
- *       0         | BMI160_INTR1_EDGE_CTRL
- *       1         | BMI160_INTR2_EDGE_CTRL
- *
- *	@param v_intr_edge_ctrl_u8 : The value of edge trigger enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_EDGE
- *  0x00     |  BMI160_LEVEL
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_edge_ctrl(
-u8 v_channel_u8, u8 v_intr_edge_ctrl_u8);
-/*!
- *	@brief  API used for get the Configure level condition of interrupt1
- *	and interrupt2 pin form the register 0x53
- *	@brief interrupt1 - bit 1
- *	@brief interrupt2 - bit 5
- *
- *  @param v_channel_u8: The value of level condition selection
- *   v_channel_u8  |   level selection
- *  ---------------|---------------
- *       0         | BMI160_INTR1_LEVEL
- *       1         | BMI160_INTR2_LEVEL
- *
- *	@param v_intr_level_u8 : The value of level of interrupt enable
- *	value    | Behaviour
- * ----------|-------------------
- *  0x01     |  BMI160_LEVEL_HIGH
- *  0x00     |  BMI160_LEVEL_LOW
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_level(
-u8 v_channel_u8, u8 *v_intr_level_u8);
-/*!
- *	@brief  API used for set the Configure level condition of interrupt1
- *	and interrupt2 pin form the register 0x53
- *	@brief interrupt1 - bit 1
- *	@brief interrupt2 - bit 5
- *
- *  @param v_channel_u8: The value of level condition selection
- *   v_channel_u8  |   level selection
- *  ---------------|---------------
- *       0         | BMI160_INTR1_LEVEL
- *       1         | BMI160_INTR2_LEVEL
- *
- *	@param v_intr_level_u8 : The value of level of interrupt enable
- *	value    | Behaviour
- * ----------|-------------------
- *  0x01     |  BMI160_LEVEL_HIGH
- *  0x00     |  BMI160_LEVEL_LOW
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_level(
-u8 v_channel_u8, u8 v_intr_level_u8);
-/*!
- *	@brief  API used to get configured output enable of interrupt1
- *	and interrupt2 from the register 0x53
- *	@brief interrupt1 - bit 2
- *	@brief interrupt2 - bit 6
- *
- *
- *  @param v_channel_u8: The value of output type enable selection
- *   v_channel_u8  |   level selection
- *  ---------------|---------------
- *       0         | BMI160_INTR1_OUTPUT_TYPE
- *       1         | BMI160_INTR2_OUTPUT_TYPE
- *
- *	@param v_intr_output_type_u8 :
- *	The value of output type of interrupt enable
- *	value    | Behaviour
- * ----------|-------------------
- *  0x01     |  BMI160_OPEN_DRAIN
- *  0x00     |  BMI160_PUSH_PULL
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_output_type(
-u8 v_channel_u8, u8 *v_intr_output_type_u8);
-/*!
- *	@brief  API used to set output enable of interrupt1
- *	and interrupt2 from the register 0x53
- *	@brief interrupt1 - bit 2
- *	@brief interrupt2 - bit 6
- *
- *
- *  @param v_channel_u8: The value of output type enable selection
- *   v_channel_u8  |   level selection
- *  ---------------|---------------
- *       0         | BMI160_INTR1_OUTPUT_TYPE
- *       1         | BMI160_INTR2_OUTPUT_TYPE
- *
- *	@param v_intr_output_type_u8 :
- *	The value of output type of interrupt enable
- *	value    | Behaviour
- * ----------|-------------------
- *  0x01     |  BMI160_OPEN_DRAIN
- *  0x00     |  BMI160_PUSH_PULL
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_output_type(
-u8 v_channel_u8, u8 v_intr_output_type_u8);
- /*!
- *	@brief API used to get the Output enable for interrupt1
- *	and interrupt1 pin from the register 0x53
- *	@brief interrupt1 - bit 3
- *	@brief interrupt2 - bit 7
- *
- *  @param v_channel_u8: The value of output enable selection
- *   v_channel_u8  |   level selection
- *  ---------------|---------------
- *       0         | BMI160_INTR1_OUTPUT_TYPE
- *       1         | BMI160_INTR2_OUTPUT_TYPE
- *
- *	@param v_output_enable_u8 :
- *	The value of output enable of interrupt enable
- *	value    | Behaviour
- * ----------|-------------------
- *  0x01     |  BMI160_INPUT
- *  0x00     |  BMI160_OUTPUT
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_output_enable(
-u8 v_channel_u8, u8 *v_output_enable_u8);
- /*!
- *	@brief API used to set the Output enable for interrupt1
- *	and interrupt1 pin from the register 0x53
- *	@brief interrupt1 - bit 3
- *	@brief interrupt2 - bit 7
- *
- *  @param v_channel_u8: The value of output enable selection
- *   v_channel_u8  |   level selection
- *  ---------------|---------------
- *       0         | BMI160_INTR1_OUTPUT_TYPE
- *       1         | BMI160_INTR2_OUTPUT_TYPE
- *
- *	@param v_output_enable_u8 :
- *	The value of output enable of interrupt enable
- *	value    | Behaviour
- * ----------|-------------------
- *  0x01     |  BMI160_INPUT
- *  0x00     |  BMI160_OUTPUT
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_output_enable(
-u8 v_channel_u8, u8 v_output_enable_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR INTERRUPT LATCH INTERRUPT  */
-/***************************************************************/
-/*!
-*	@brief This API is used to get the latch duration
-*	from the register 0x54 bit 0 to 3
-*	@brief This latch selection is not applicable for data ready,
-*	orientation and flat interrupts.
-*
-*
-*
-*  @param v_latch_intr_u8 : The value of latch duration
-*	Latch Duration                      |     value
-* --------------------------------------|------------------
-*    BMI160_LATCH_DUR_NONE              |      0x00
-*    BMI160_LATCH_DUR_312_5_MICRO_SEC   |      0x01
-*    BMI160_LATCH_DUR_625_MICRO_SEC     |      0x02
-*    BMI160_LATCH_DUR_1_25_MILLI_SEC    |      0x03
-*    BMI160_LATCH_DUR_2_5_MILLI_SEC     |      0x04
-*    BMI160_LATCH_DUR_5_MILLI_SEC       |      0x05
-*    BMI160_LATCH_DUR_10_MILLI_SEC      |      0x06
-*    BMI160_LATCH_DUR_20_MILLI_SEC      |      0x07
-*    BMI160_LATCH_DUR_40_MILLI_SEC      |      0x08
-*    BMI160_LATCH_DUR_80_MILLI_SEC      |      0x09
-*    BMI160_LATCH_DUR_160_MILLI_SEC     |      0x0A
-*    BMI160_LATCH_DUR_320_MILLI_SEC     |      0x0B
-*    BMI160_LATCH_DUR_640_MILLI_SEC     |      0x0C
-*    BMI160_LATCH_DUR_1_28_SEC          |      0x0D
-*    BMI160_LATCH_DUR_2_56_SEC          |      0x0E
-*    BMI160_LATCHED                     |      0x0F
-*
-*
-*
-*	@return results of bus communication function
-*	@retval 0 -> Success
-*	@retval -1 -> Error
-*
-*
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_latch_intr(
-u8 *v_latch_intr_u8);
-/*!
-*	@brief This API is used to set the latch duration
-*	from the register 0x54 bit 0 to 3
-*	@brief This latch selection is not applicable for data ready,
-*	orientation and flat interrupts.
-*
-*
-*
-*  @param v_latch_intr_u8 : The value of latch duration
-*	Latch Duration                      |     value
-* --------------------------------------|------------------
-*    BMI160_LATCH_DUR_NONE              |      0x00
-*    BMI160_LATCH_DUR_312_5_MICRO_SEC   |      0x01
-*    BMI160_LATCH_DUR_625_MICRO_SEC     |      0x02
-*    BMI160_LATCH_DUR_1_25_MILLI_SEC    |      0x03
-*    BMI160_LATCH_DUR_2_5_MILLI_SEC     |      0x04
-*    BMI160_LATCH_DUR_5_MILLI_SEC       |      0x05
-*    BMI160_LATCH_DUR_10_MILLI_SEC      |      0x06
-*    BMI160_LATCH_DUR_20_MILLI_SEC      |      0x07
-*    BMI160_LATCH_DUR_40_MILLI_SEC      |      0x08
-*    BMI160_LATCH_DUR_80_MILLI_SEC      |      0x09
-*    BMI160_LATCH_DUR_160_MILLI_SEC     |      0x0A
-*    BMI160_LATCH_DUR_320_MILLI_SEC     |      0x0B
-*    BMI160_LATCH_DUR_640_MILLI_SEC     |      0x0C
-*    BMI160_LATCH_DUR_1_28_SEC          |      0x0D
-*    BMI160_LATCH_DUR_2_56_SEC          |      0x0E
-*    BMI160_LATCHED                     |      0x0F
-*
-*
-*
-*	@return results of bus communication function
-*	@retval 0 -> Success
-*	@retval -1 -> Error
-*
-*
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_latch_intr(
-u8 v_latch_intr_u8);
-/*!
- *	@brief API used to get input enable for interrupt1
- *	and interrupt2 pin from the register 0x54
- *	@brief interrupt1 - bit 4
- *	@brief interrupt2 - bit 5
- *
- *  @param v_channel_u8: The value of input enable selection
- *   v_channel_u8  |   input selection
- *  ---------------|---------------
- *       0         | BMI160_INTR1_INPUT_ENABLE
- *       1         | BMI160_INTR2_INPUT_ENABLE
- *
- *	@param v_input_en_u8 :
- *	The value of input enable of interrupt enable
- *	value    | Behaviour
- * ----------|-------------------
- *  0x01     |  BMI160_INPUT
- *  0x00     |  BMI160_OUTPUT
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_input_enable(
-u8 v_channel_u8, u8 *v_input_en_u8);
-/*!
- *	@brief API used to set input enable for interrupt1
- *	and interrupt2 pin from the register 0x54
- *	@brief interrupt1 - bit 4
- *	@brief interrupt2 - bit 5
- *
- *  @param v_channel_u8: The value of input enable selection
- *   v_channel_u8  |   input selection
- *  ---------------|---------------
- *       0         | BMI160_INTR1_INPUT_ENABLE
- *       1         | BMI160_INTR2_INPUT_ENABLE
- *
- *	@param v_input_en_u8 :
- *	The value of input enable of interrupt enable
- *	value    | Behaviour
- * ----------|-------------------
- *  0x01     |  BMI160_INPUT
- *  0x00     |  BMI160_OUTPUT
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_input_enable(
-u8 v_channel_u8, u8 v_input_en_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR INTERRUPT1 AND INTERRUPT2 MAPPING */
-/***************************************************************/
- /*!
- *	@brief reads the Low g interrupt mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 0 in the register 0x55
- *	@brief interrupt2 bit 0 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of low_g selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_LOW_G
- *       1         | BMI160_INTR2_MAP_LOW_G
- *
- *	@param v_intr_low_g_u8 : The value of low_g enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_low_g(
-u8 v_channel_u8, u8 *v_intr_low_g_u8);
- /*!
- *	@brief set the Low g interrupt mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 0 in the register 0x55
- *	@brief interrupt2 bit 0 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of low_g selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_LOW_G
- *       1         | BMI160_INTR2_MAP_LOW_G
- *
- *	@param v_intr_low_g_u8 : The value of low_g enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_low_g(
-u8 v_channel_u8, u8 v_intr_low_g_u8);
-/*!
- *	@brief Reads the HIGH g interrupt mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 1 in the register 0x55
- *	@brief interrupt2 bit 1 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of high_g selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_HIGH_G
- *       1         | BMI160_INTR2_MAP_HIGH_G
- *
- *	@param v_intr_high_g_u8 : The value of high_g enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_high_g(
-u8 v_channel_u8, u8 *v_intr_high_g_u8);
-/*!
- *	@brief Write the HIGH g interrupt mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 1 in the register 0x55
- *	@brief interrupt2 bit 1 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of high_g selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_HIGH_G
- *       1         | BMI160_INTR2_MAP_HIGH_G
- *
- *	@param v_intr_high_g_u8 : The value of high_g enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_high_g(
-u8 v_channel_u8, u8 v_intr_high_g_u8);
-/*!
- *	@brief Reads the Any motion interrupt
- *	interrupt mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 2 in the register 0x55
- *	@brief interrupt2 bit 2 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of any motion selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_ANY_MOTION
- *       1         | BMI160_INTR2_MAP_ANY_MOTION
- *
- *	@param v_intr_any_motion_u8 : The value of any motion enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_any_motion(
-u8 v_channel_u8, u8 *v_intr_any_motion_u8);
-/*!
- *	@brief Write the Any motion interrupt
- *	interrupt mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 2 in the register 0x55
- *	@brief interrupt2 bit 2 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of any motion selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_ANY_MOTION
- *       1         | BMI160_INTR2_MAP_ANY_MOTION
- *
- *	@param v_intr_any_motion_u8 : The value of any motion enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_any_motion(
-u8 v_channel_u8, u8 v_intr_any_motion_u8);
-/*!
- *	@brief Reads the No motion interrupt
- *	interrupt mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 3 in the register 0x55
- *	@brief interrupt2 bit 3 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of no motion selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_NOMO
- *       1         | BMI160_INTR2_MAP_NOMO
- *
- *	@param v_intr_nomotion_u8 : The value of no motion enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_nomotion(
-u8 v_channel_u8, u8 *v_intr_nomotion_u8);
-/*!
- *	@brief Write the No motion interrupt
- *	interrupt mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 3 in the register 0x55
- *	@brief interrupt2 bit 3 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of no motion selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_NOMO
- *       1         | BMI160_INTR2_MAP_NOMO
- *
- *	@param v_intr_nomotion_u8 : The value of no motion enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_nomotion(
-u8 v_channel_u8, u8 v_intr_nomotion_u8);
-/*!
- *	@brief Reads the Double Tap interrupt
- *	interrupt mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 4 in the register 0x55
- *	@brief interrupt2 bit 4 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of double tap interrupt selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_DOUBLE_TAP
- *       1         | BMI160_INTR2_MAP_DOUBLE_TAP
- *
- *	@param v_intr_double_tap_u8 : The value of double tap enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_double_tap(
-u8 v_channel_u8, u8 *v_intr_double_tap_u8);
-/*!
- *	@brief Write the Double Tap interrupt
- *	interrupt mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 4 in the register 0x55
- *	@brief interrupt2 bit 4 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of double tap interrupt selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_DOUBLE_TAP
- *       1         | BMI160_INTR2_MAP_DOUBLE_TAP
- *
- *	@param v_intr_double_tap_u8 : The value of double tap enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_double_tap(
-u8 v_channel_u8, u8 v_intr_double_tap_u8);
-/*!
- *	@brief Reads the Single Tap interrupt
- *	interrupt mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 5 in the register 0x55
- *	@brief interrupt2 bit 5 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of single tap interrupt selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_SINGLE_TAP
- *       1         | BMI160_INTR2_MAP_SINGLE_TAP
- *
- *	@param v_intr_single_tap_u8 : The value of single tap  enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_single_tap(
-u8 v_channel_u8, u8 *v_intr_single_tap_u8);
-/*!
- *	@brief Write the Single Tap interrupt
- *	interrupt mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 5 in the register 0x55
- *	@brief interrupt2 bit 5 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of single tap interrupt selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_SINGLE_TAP
- *       1         | BMI160_INTR2_MAP_SINGLE_TAP
- *
- *	@param v_intr_single_tap_u8 : The value of single tap  enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_single_tap(
-u8 v_channel_u8, u8 v_intr_single_tap_u8);
-/*!
- *	@brief Reads the Orient interrupt
- *	interrupt mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 6 in the register 0x55
- *	@brief interrupt2 bit 6 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of orient interrupt selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_ORIENT
- *       1         | BMI160_INTR2_MAP_ORIENT
- *
- *	@param v_intr_orient_u8 : The value of orient enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_orient(
-u8 v_channel_u8, u8 *v_intr_orient_u8);
-/*!
- *	@brief Write the Orient interrupt
- *	interrupt mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 6 in the register 0x55
- *	@brief interrupt2 bit 6 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of orient interrupt selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_ORIENT
- *       1         | BMI160_INTR2_MAP_ORIENT
- *
- *	@param v_intr_orient_u8 : The value of orient enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_orient(
-u8 v_channel_u8, u8 v_intr_orient_u8);
- /*!
- *	@brief Reads the Flat interrupt
- *	mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 7 in the register 0x55
- *	@brief interrupt2 bit 7 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of flat interrupt selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_FLAT
- *       1         | BMI160_INTR2_MAP_FLAT
- *
- *	@param v_intr_flat_u8 : The value of flat enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_flat(
-u8 v_channel_u8, u8 *v_intr_flat_u8);
- /*!
- *	@brief Write the Flat interrupt
- *	mapped to interrupt1
- *	and interrupt2 from the register 0x55 and 0x57
- *	@brief interrupt1 bit 7 in the register 0x55
- *	@brief interrupt2 bit 7 in the register 0x57
- *
- *
- *	@param v_channel_u8: The value of flat interrupt selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_FLAT
- *       1         | BMI160_INTR2_MAP_FLAT
- *
- *	@param v_intr_flat_u8 : The value of flat enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_flat(
-u8 v_channel_u8, u8 v_intr_flat_u8);
-/*!
- *	@brief Reads PMU trigger interrupt mapped to interrupt1
- *	and interrupt2 form the register 0x56 bit 0 and 4
- *	@brief interrupt1 bit 0 in the register 0x56
- *	@brief interrupt2 bit 4 in the register 0x56
- *
- *
- *	@param v_channel_u8: The value of pmu trigger selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_PMUTRIG
- *       1         | BMI160_INTR2_MAP_PMUTRIG
- *
- *	@param v_intr_pmu_trig_u8 : The value of pmu trigger enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_pmu_trig(
-u8 v_channel_u8, u8 *v_intr_pmu_trig_u8);
-/*!
- *	@brief Write PMU trigger interrupt mapped to interrupt1
- *	and interrupt2 form the register 0x56 bit 0 and 4
- *	@brief interrupt1 bit 0 in the register 0x56
- *	@brief interrupt2 bit 4 in the register 0x56
- *
- *
- *	@param v_channel_u8: The value of pmu trigger selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_PMUTRIG
- *       1         | BMI160_INTR2_MAP_PMUTRIG
- *
- *	@param v_intr_pmu_trig_u8 : The value of pmu trigger enable
- *	value    | trigger enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_pmu_trig(
-u8 v_channel_u8, u8 v_intr_pmu_trig_u8);
-/*!
- *	@brief Reads FIFO Full interrupt mapped to interrupt1
- *	and interrupt2 form the register 0x56 bit 5 and 1
- *	@brief interrupt1 bit 5 in the register 0x56
- *	@brief interrupt2 bit 1 in the register 0x56
- *
- *
- *	@param v_channel_u8: The value of fifo full interrupt selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_FIFO_FULL
- *       1         | BMI160_INTR2_MAP_FIFO_FULL
- *
- *	@param v_intr_fifo_full_u8 : The value of fifo full interrupt enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_fifo_full(
-u8 v_channel_u8, u8 *v_intr_fifo_full_u8);
-/*!
- *	@brief Write FIFO Full interrupt mapped to interrupt1
- *	and interrupt2 form the register 0x56 bit 5 and 1
- *	@brief interrupt1 bit 5 in the register 0x56
- *	@brief interrupt2 bit 1 in the register 0x56
- *
- *
- *	@param v_channel_u8: The value of fifo full interrupt selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_FIFO_FULL
- *       1         | BMI160_INTR2_MAP_FIFO_FULL
- *
- *	@param v_intr_fifo_full_u8 : The value of fifo full interrupt enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_fifo_full(
-u8 v_channel_u8, u8 v_intr_fifo_full_u8);
-/*!
- *	@brief Reads FIFO Watermark interrupt mapped to interrupt1
- *	and interrupt2 form the register 0x56 bit 6 and 2
- *	@brief interrupt1 bit 6 in the register 0x56
- *	@brief interrupt2 bit 2 in the register 0x56
- *
- *
- *	@param v_channel_u8: The value of fifo Watermark interrupt selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_FIFO_WM
- *       1         | BMI160_INTR2_MAP_FIFO_WM
- *
- *	@param v_intr_fifo_wm_u8 : The value of fifo Watermark interrupt enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_fifo_wm(
-u8 v_channel_u8, u8 *v_intr_fifo_wm_u8);
-/*!
- *	@brief Write FIFO Watermark interrupt mapped to interrupt1
- *	and interrupt2 form the register 0x56 bit 6 and 2
- *	@brief interrupt1 bit 6 in the register 0x56
- *	@brief interrupt2 bit 2 in the register 0x56
- *
- *
- *	@param v_channel_u8: The value of fifo Watermark interrupt selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_FIFO_WM
- *       1         | BMI160_INTR2_MAP_FIFO_WM
- *
- *	@param v_intr_fifo_wm_u8 : The value of fifo Watermark interrupt enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_fifo_wm(
-u8 v_channel_u8, u8 v_intr_fifo_wm_u8);
-/*!
- *	@brief Reads Data Ready interrupt mapped to interrupt1
- *	and interrupt2 form the register 0x56
- *	@brief interrupt1 bit 7 in the register 0x56
- *	@brief interrupt2 bit 3 in the register 0x56
- *
- *
- *	@param v_channel_u8: The value of data ready interrupt selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_DATA_RDY
- *       1         | BMI160_INTR2_MAP_DATA_RDY
- *
- *	@param v_intr_data_rdy_u8 : The value of data ready interrupt enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_data_rdy(
-u8 v_channel_u8, u8 *v_intr_data_rdy_u8);
-/*!
- *	@brief Write Data Ready interrupt mapped to interrupt1
- *	and interrupt2 form the register 0x56
- *	@brief interrupt1 bit 7 in the register 0x56
- *	@brief interrupt2 bit 3 in the register 0x56
- *
- *
- *	@param v_channel_u8: The value of data ready interrupt selection
- *   v_channel_u8  |   interrupt
- *  ---------------|---------------
- *       0         | BMI160_INTR1_MAP_DATA_RDY
- *       1         | BMI160_INTR2_MAP_DATA_RDY
- *
- *	@param v_intr_data_rdy_u8 : The value of data ready interrupt enable
- *	value    | interrupt enable
- * ----------|-------------------
- *  0x01     |  BMI160_ENABLE
- *  0x00     |  BMI160_DISABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_data_rdy(
-u8 v_channel_u8, u8 v_intr_data_rdy_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR TAP SOURCE CONFIGURATION          */
-/***************************************************************/
- /*!
- *	@brief This API reads data source for the interrupt
- *	engine for the single and double tap interrupts from the register
- *	0x58 bit 3
- *
- *
- *  @param v_tap_source_u8 : The value of the tap source
- *	value    | Description
- * ----------|-------------------
- *  0x01     |  UNFILTER_DATA
- *  0x00     |  FILTER_DATA
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_tap_source(
-u8 *v_tap_source_u8);
- /*!
- *	@brief This API write data source for the interrupt
- *	engine for the single and double tap interrupts from the register
- *	0x58 bit 3
- *
- *
- *  @param v_tap_source_u8 : The value of the tap source
- *	value    | Description
- * ----------|-------------------
- *  0x01     |  UNFILTER_DATA
- *  0x00     |  FILTER_DATA
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_tap_source(
-u8 v_tap_source_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR LOW_G AND HIGH_G SOURCE CONFIGURATION */
-/***************************************************************/
- /*!
- *	@brief This API Reads Data source for the
- *	interrupt engine for the low and high g interrupts
- *	from the register 0x58 bit 7
- *
- *  @param v_low_high_source_u8 : The value of the tap source
- *	value    | Description
- * ----------|-------------------
- *  0x01     |  UNFILTER_DATA
- *  0x00     |  FILTER_DATA
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_low_high_source(
-u8 *v_low_high_source_u8);
- /*!
- *	@brief This API write Data source for the
- *	interrupt engine for the low and high g interrupts
- *	from the register 0x58 bit 7
- *
- *  @param v_low_high_source_u8 : The value of the tap source
- *	value    | Description
- * ----------|-------------------
- *  0x01     |  UNFILTER_DATA
- *  0x00     |  FILTER_DATA
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_low_high_source(
-u8 v_low_high_source_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR MOTION SOURCE CONFIGURATION          */
-/***************************************************************/
- /*!
- *	@brief This API reads Data source for the
- *	interrupt engine for the nomotion and anymotion interrupts
- *	from the register 0x59 bit 7
- *
- *  @param v_motion_source_u8 :
- *	The value of the any/no motion interrupt source
- *	value    | Description
- * ----------|-------------------
- *  0x01     |  UNFILTER_DATA
- *  0x00     |  FILTER_DATA
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_motion_source(
-u8 *v_motion_source_u8);
- /*!
- *	@brief This API write Data source for the
- *	interrupt engine for the nomotion and anymotion interrupts
- *	from the register 0x59 bit 7
- *
- *  @param v_motion_source_u8 :
- *	The value of the any/no motion interrupt source
- *	value    | Description
- * ----------|-------------------
- *  0x01     |  UNFILTER_DATA
- *  0x00     |  FILTER_DATA
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_motion_source(
-u8 v_motion_source_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR LOW_G DURATION CONFIGURATION          */
-/***************************************************************/
-/*!
- *	@brief This API is used to read the low_g duration from register
- *	0x5A bit 0 to 7
- *
- *
- *
- *
- *  @param v_low_g_durn_u8 : The value of low_g duration
- *
- *	@note Low_g duration trigger trigger delay according to
- *	"(v_low_g_durn_u8 * 2.5)ms" in a range from 2.5ms to 640ms.
- *	the default corresponds delay is 20ms
- *	@note When low_g data source of interrupt is unfiltered
- *	the sensor must not be in low power mode
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_low_g_durn(
-u8 *v_low_durn_u8);
- /*!
- *	@brief This API is used to write the low_g duration from register
- *	0x5A bit 0 to 7
- *
- *
- *
- *
- *  @param v_low_g_durn_u8 : The value of low_g duration
- *
- *	@note Low_g duration trigger trigger delay according to
- *	"(v_low_g_durn_u8 * 2.5)ms" in a range from 2.5ms to 640ms.
- *	the default corresponds delay is 20ms
- *	@note When low_g data source of interrupt is unfiltered
- *	the sensor must not be in low power mode
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_low_g_durn(
-u8 v_low_durn_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR LOW_G THRESH CONFIGURATION          */
-/***************************************************************/
-/*!
- *	@brief This API is used to read Threshold
- *	definition for the low-g interrupt from the register 0x5B bit 0 to 7
- *
- *
- *
- *
- *  @param v_low_g_thres_u8 : The value of low_g threshold
- *
- *	@note Low_g interrupt trigger threshold according to
- *	(v_low_g_thres_u8 * 7.81)mg for v_low_g_thres_u8 > 0
- *	3.91 mg for v_low_g_thres_u8 = 0
- *	The threshold range is form 3.91mg to 2.000mg
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_low_g_thres(
-u8 *v_low_g_thres_u8);
-/*!
- *	@brief This API is used to write Threshold
- *	definition for the low-g interrupt from the register 0x5B bit 0 to 7
- *
- *
- *
- *
- *  @param v_low_g_thres_u8 : The value of low_g threshold
- *
- *	@note Low_g interrupt trigger threshold according to
- *	(v_low_g_thres_u8 * 7.81)mg for v_low_g_thres_u8 > 0
- *	3.91 mg for v_low_g_thres_u8 = 0
- *	The threshold range is form 3.91mg to 2.000mg
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_low_g_thres(
-u8 v_low_g_thres_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR LOW_G HYSTERESIS CONFIGURATION     */
-/***************************************************************/
- /*!
- *	@brief This API Reads Low-g interrupt hysteresis
- *	from the register 0x5C bit 0 to 1
- *
- *  @param v_low_hyst_u8 :The value of low_g hysteresis
- *
- *	@note Low_g hysteresis calculated by v_low_hyst_u8*125 mg
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_low_g_hyst(
-u8 *v_low_hyst_u8);
- /*!
- *	@brief This API write Low-g interrupt hysteresis
- *	from the register 0x5C bit 0 to 1
- *
- *  @param v_low_hyst_u8 :The value of low_g hysteresis
- *
- *	@note Low_g hysteresis calculated by v_low_hyst_u8*125 mg
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_low_g_hyst(
-u8 v_low_hyst_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR LOW_G MODE CONFIGURATION     */
-/***************************************************************/
-/*!
- *	@brief This API reads Low-g interrupt mode
- *	from the register 0x5C bit 2
- *
- *  @param v_low_g_mode_u8 : The value of low_g mode
- *	Value    |  Description
- * ----------|-----------------
- *	   0     | single-axis
- *     1     | axis-summing
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_low_g_mode(
-u8 *v_low_g_mode_u8);
-/*!
- *	@brief This API write Low-g interrupt mode
- *	from the register 0x5C bit 2
- *
- *  @param v_low_g_mode_u8 : The value of low_g mode
- *	Value    |  Description
- * ----------|-----------------
- *	   0     | single-axis
- *     1     | axis-summing
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_low_g_mode(
-u8 v_low_g_mode_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR HIGH_G HYST CONFIGURATION     */
-/***************************************************************/
-/*!
- *	@brief This API reads High-g interrupt hysteresis
- *	from the register 0x5C bit 6 and 7
- *
- *  @param v_high_g_hyst_u8 : The value of high hysteresis
- *
- *	@note High_g hysteresis changes according to accel g range
- *	accel g range can be set by the function ""
- *   accel_range    | high_g hysteresis
- *  ----------------|---------------------
- *      2g          |  high_hy*125 mg
- *      4g          |  high_hy*250 mg
- *      8g          |  high_hy*500 mg
- *      16g         |  high_hy*1000 mg
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_high_g_hyst(
-u8 *v_high_g_hyst_u8);
-/*!
- *	@brief This API write High-g interrupt hysteresis
- *	from the register 0x5C bit 6 and 7
- *
- *  @param v_high_g_hyst_u8 : The value of high hysteresis
- *
- *	@note High_g hysteresis changes according to accel g range
- *	accel g range can be set by the function ""
- *   accel_range    | high_g hysteresis
- *  ----------------|---------------------
- *      2g          |  high_hy*125 mg
- *      4g          |  high_hy*250 mg
- *      8g          |  high_hy*500 mg
- *      16g         |  high_hy*1000 mg
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_high_g_hyst(
-u8 v_high_g_hyst_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR HIGH_G DURATION CONFIGURATION     */
-/***************************************************************/
-/*!
- *	@brief This API is used to read Delay
- *	time definition for the high-g interrupt from the register
- *	0x5D bit 0 to 7
- *
- *
- *
- *  @param  v_high_g_durn_u8 :  The value of high duration
- *
- *	@note High_g interrupt delay triggered according to
- *	v_high_g_durn_u8 * 2.5ms in a range from 2.5ms to 640ms
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_high_g_durn(
-u8 *v_high_g_durn_u8);
-/*!
- *	@brief This API is used to write Delay
- *	time definition for the high-g interrupt from the register
- *	0x5D bit 0 to 7
- *
- *
- *
- *  @param  v_high_g_durn_u8 :  The value of high duration
- *
- *	@note High_g interrupt delay triggered according to
- *	v_high_g_durn_u8 * 2.5ms in a range from 2.5ms to 640ms
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_high_g_durn(
-u8 v_high_g_durn_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR HIGH_G THRESHOLD CONFIGURATION     */
-/***************************************************************/
-/*!
- *	@brief This API is used to read Threshold
- *	definition for the high-g interrupt from the register 0x5E 0 to 7
- *
- *
- *
- *
- *  @param  v_high_g_thres_u8 : Pointer holding the value of Threshold
- *	@note High_g threshold changes according to accel g range
- *	accel g range can be set by the function ""
- *   accel_range    | high_g threshold
- *  ----------------|---------------------
- *      2g          |  v_high_g_thres_u8*7.81 mg
- *      4g          |  v_high_g_thres_u8*15.63 mg
- *      8g          |  v_high_g_thres_u8*31.25 mg
- *      16g         |  v_high_g_thres_u8*62.5 mg
- *	@note when v_high_g_thres_u8 = 0
- *   accel_range    | high_g threshold
- *  ----------------|---------------------
- *      2g          |  3.91 mg
- *      4g          |  7.81 mg
- *      8g          |  15.63 mg
- *      16g         |  31.25 mg
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_high_g_thres(
-u8 *v_high_g_thres_u8);
-/*!
- *	@brief This API is used to write Threshold
- *	definition for the high-g interrupt from the register 0x5E 0 to 7
- *
- *
- *
- *
- *  @param  v_high_g_thres_u8 : Pointer holding the value of Threshold
- *	@note High_g threshold changes according to accel g range
- *	accel g range can be set by the function ""
- *   accel_range    | high_g threshold
- *  ----------------|---------------------
- *      2g          |  v_high_g_thres_u8*7.81 mg
- *      4g          |  v_high_g_thres_u8*15.63 mg
- *      8g          |  v_high_g_thres_u8*31.25 mg
- *      16g         |  v_high_g_thres_u8*62.5 mg
- *	@note when v_high_g_thres_u8 = 0
- *   accel_range    | high_g threshold
- *  ----------------|---------------------
- *      2g          |  3.91 mg
- *      4g          |  7.81 mg
- *      8g          |  15.63 mg
- *      16g         |  31.25 mg
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_high_g_thres(
-u8 v_high_g_thres_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR ANY MOTION DURATION CONFIGURATION     */
-/***************************************************************/
-/*!
- *	@brief This API reads any motion duration
- *	from the register 0x5F bit 0 and 1
- *
- *  @param v_any_motion_durn_u8 : The value of any motion duration
- *
- *	@note Any motion duration can be calculated by "v_any_motion_durn_u8 + 1"
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_any_motion_durn(
-u8 *v_any_motion_durn_u8);
-/*!
- *	@brief This API write any motion duration
- *	from the register 0x5F bit 0 and 1
- *
- *  @param v_any_motion_durn_u8 : The value of any motion duration
- *
- *	@note Any motion duration can be calculated by "v_any_motion_durn_u8 + 1"
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_any_motion_durn(
-u8 nomotion);
-/***************************************************************/
-/**\name	FUNCTION FOR SLOW NO MOTION DURATION CONFIGURATION  */
-/***************************************************************/
- /*!
- *	@brief This API read Slow/no-motion
- *	interrupt trigger delay duration from the register 0x5F bit 2 to 7
- *
- *  @param v_slow_no_motion_u8 :The value of slow no motion duration
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *	@note
- *	@note v_slow_no_motion_u8(5:4)=0b00 ->
- *	[v_slow_no_motion_u8(3:0) + 1] * 1.28s (1.28s-20.48s)
- *	@note v_slow_no_motion_u8(5:4)=1 ->
- *	[v_slow_no_motion_u8(3:0)+5] * 5.12s (25.6s-102.4s)
- *	@note v_slow_no_motion_u8(5)='1' ->
- *	[(v_slow_no_motion_u8:0)+11] * 10.24s (112.64s-430.08s);
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_slow_no_motion_durn(
-u8 *v_slow_no_motion_u8);
- /*!
- *	@brief This API write Slow/no-motion
- *	interrupt trigger delay duration from the register 0x5F bit 2 to 7
- *
- *  @param v_slow_no_motion_u8 :The value of slow no motion duration
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *	@note
- *	@note v_slow_no_motion_u8(5:4)=0b00 ->
- *	[v_slow_no_motion_u8(3:0) + 1] * 1.28s (1.28s-20.48s)
- *	@note v_slow_no_motion_u8(5:4)=1 ->
- *	[v_slow_no_motion_u8(3:0)+5] * 5.12s (25.6s-102.4s)
- *	@note v_slow_no_motion_u8(5)='1' ->
- *	[(v_slow_no_motion_u8:0)+11] * 10.24s (112.64s-430.08s);
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_slow_no_motion_durn(
-u8 v_slow_no_motion_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR ANY MOTION THRESHOLD CONFIGURATION  */
-/***************************************************************/
-/*!
- *	@brief This API is used to read threshold
- *	definition for the any-motion interrupt
- *	from the register 0x60 bit 0 to 7
- *
- *
- *  @param  v_any_motion_thres_u8 : The value of any motion threshold
- *
- *	@note any motion threshold changes according to accel g range
- *	accel g range can be set by the function ""
- *   accel_range    | any motion threshold
- *  ----------------|---------------------
- *      2g          |  v_any_motion_thres_u8*3.91 mg
- *      4g          |  v_any_motion_thres_u8*7.81 mg
- *      8g          |  v_any_motion_thres_u8*15.63 mg
- *      16g         |  v_any_motion_thres_u8*31.25 mg
- *	@note when v_any_motion_thres_u8 = 0
- *   accel_range    | any motion threshold
- *  ----------------|---------------------
- *      2g          |  1.95 mg
- *      4g          |  3.91 mg
- *      8g          |  7.81 mg
- *      16g         |  15.63 mg
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_any_motion_thres(
-u8 *v_any_motion_thres_u8);
-/*!
- *	@brief This API is used to write threshold
- *	definition for the any-motion interrupt
- *	from the register 0x60 bit 0 to 7
- *
- *
- *  @param  v_any_motion_thres_u8 : The value of any motion threshold
- *
- *	@note any motion threshold changes according to accel g range
- *	accel g range can be set by the function ""
- *   accel_range    | any motion threshold
- *  ----------------|---------------------
- *      2g          |  v_any_motion_thres_u8*3.91 mg
- *      4g          |  v_any_motion_thres_u8*7.81 mg
- *      8g          |  v_any_motion_thres_u8*15.63 mg
- *      16g         |  v_any_motion_thres_u8*31.25 mg
- *	@note when v_any_motion_thres_u8 = 0
- *   accel_range    | any motion threshold
- *  ----------------|---------------------
- *      2g          |  1.95 mg
- *      4g          |  3.91 mg
- *      8g          |  7.81 mg
- *      16g         |  15.63 mg
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_any_motion_thres(
-u8 v_any_motion_thres_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR SLO/NO MOTION THRESHOLD CONFIGURATION  */
-/***************************************************************/
- /*!
- *	@brief This API is used to read threshold
- *	for the slow/no-motion interrupt
- *	from the register 0x61 bit 0 to 7
- *
- *
- *
- *
- *  @param v_slow_no_motion_thres_u8 : The value of slow no motion threshold
- *	@note slow no motion threshold changes according to accel g range
- *	accel g range can be set by the function ""
- *   accel_range    | slow no motion threshold
- *  ----------------|---------------------
- *      2g          |  v_slow_no_motion_thres_u8*3.91 mg
- *      4g          |  v_slow_no_motion_thres_u8*7.81 mg
- *      8g          |  v_slow_no_motion_thres_u8*15.63 mg
- *      16g         |  v_slow_no_motion_thres_u8*31.25 mg
- *	@note when v_slow_no_motion_thres_u8 = 0
- *   accel_range    | slow no motion threshold
- *  ----------------|---------------------
- *      2g          |  1.95 mg
- *      4g          |  3.91 mg
- *      8g          |  7.81 mg
- *      16g         |  15.63 mg
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_slow_no_motion_thres(
-u8 *v_slow_no_motion_thres_u8);
- /*!
- *	@brief This API is used to write threshold
- *	for the slow/no-motion interrupt
- *	from the register 0x61 bit 0 to 7
- *
- *
- *
- *
- *  @param v_slow_no_motion_thres_u8 : The value of slow no motion threshold
- *	@note slow no motion threshold changes according to accel g range
- *	accel g range can be set by the function ""
- *   accel_range    | slow no motion threshold
- *  ----------------|---------------------
- *      2g          |  v_slow_no_motion_thres_u8*3.91 mg
- *      4g          |  v_slow_no_motion_thres_u8*7.81 mg
- *      8g          |  v_slow_no_motion_thres_u8*15.63 mg
- *      16g         |  v_slow_no_motion_thres_u8*31.25 mg
- *	@note when v_slow_no_motion_thres_u8 = 0
- *   accel_range    | slow no motion threshold
- *  ----------------|---------------------
- *      2g          |  1.95 mg
- *      4g          |  3.91 mg
- *      8g          |  7.81 mg
- *      16g         |  15.63 mg
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_slow_no_motion_thres(
-u8 v_slow_no_motion_thres_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR SLO/NO MOTION SELECT CONFIGURATION  */
-/***************************************************************/
- /*!
- *	@brief This API is used to read
- *	the slow/no-motion selection from the register 0x62 bit 0
- *
- *
- *
- *
- *  @param  v_intr_slow_no_motion_select_u8 :
- *	The value of slow/no-motion select
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     |  SLOW_MOTION
- *  0x01     |  NO_MOTION
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_slow_no_motion_select(
-u8 *v_intr_slow_no_motion_select_u8);
- /*!
- *	@brief This API is used to write
- *	the slow/no-motion selection from the register 0x62 bit 0
- *
- *
- *
- *
- *  @param  v_intr_slow_no_motion_select_u8 :
- *	The value of slow/no-motion select
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     |  SLOW_MOTION
- *  0x01     |  NO_MOTION
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_slow_no_motion_select(
-u8 v_intr_slow_no_motion_select_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR SIGNIFICANT MOTION SELECT CONFIGURATION*/
-/***************************************************************/
- /*!
- *	@brief This API is used to select
- *	the significant or any motion interrupt from the register 0x62 bit 1
- *
- *
- *
- *
- *  @param  v_intr_significant_motion_select_u8 :
- *	the value of significant or any motion interrupt selection
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     |  ANY_MOTION
- *  0x01     |  SIGNIFICANT_MOTION
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_significant_motion_select(
-u8 *int_sig_mot_sel);
- /*!
- *	@brief This API is used to write, select
- *	the significant or any motion interrupt from the register 0x62 bit 1
- *
- *
- *
- *
- *  @param  v_intr_significant_motion_select_u8 :
- *	the value of significant or any motion interrupt selection
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     |  ANY_MOTION
- *  0x01     |  SIGNIFICANT_MOTION
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_significant_motion_select(
-u8 int_sig_mot_sel);
- /*!
- *	@brief This API is used to read
- *	the significant skip time from the register 0x62 bit  2 and 3
- *
- *
- *
- *
- *  @param  v_int_sig_mot_skip_u8 : the value of significant skip time
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     |  skip time 1.5 seconds
- *  0x01     |  skip time 3 seconds
- *  0x02     |  skip time 6 seconds
- *  0x03     |  skip time 12 seconds
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_significant_motion_skip(
-u8 *v_int_sig_mot_skip_u8);
- /*!
- *	@brief This API is used to write
- *	the significant skip time from the register 0x62 bit  2 and 3
- *
- *
- *
- *
- *  @param  v_int_sig_mot_skip_u8 : the value of significant skip time
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     |  skip time 1.5 seconds
- *  0x01     |  skip time 3 seconds
- *  0x02     |  skip time 6 seconds
- *  0x03     |  skip time 12 seconds
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_significant_motion_skip(
-u8 v_int_sig_mot_skip_u8);
- /*!
- *	@brief This API is used to read
- *	the significant proof time from the register 0x62 bit  4 and 5
- *
- *
- *
- *
- *  @param  v_significant_motion_proof_u8 :
- *	the value of significant proof time
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     |  proof time 0.25 seconds
- *  0x01     |  proof time 0.5 seconds
- *  0x02     |  proof time 1 seconds
- *  0x03     |  proof time 2 seconds
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_significant_motion_proof(
-u8 *int_sig_mot_proof);
- /*!
- *	@brief This API is used to write
- *	the significant proof time from the register 0x62 bit  4 and 5
- *
- *
- *
- *
- *  @param  v_significant_motion_proof_u8 :
- *	the value of significant proof time
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     |  proof time 0.25 seconds
- *  0x01     |  proof time 0.5 seconds
- *  0x02     |  proof time 1 seconds
- *  0x03     |  proof time 2 seconds
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_significant_motion_proof(
-u8 int_sig_mot_proof);
-/***************************************************************/
-/**\name	FUNCTION FOR TAP DURATION CONFIGURATION*/
-/***************************************************************/
-/*!
- *	@brief This API is used to get the tap duration
- *	from the register 0x63 bit 0 to 2
- *
- *
- *
- *  @param v_tap_durn_u8 : The value of tap duration
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | BMI160_TAP_DURN_50MS
- *  0x01     | BMI160_TAP_DURN_100MS
- *  0x03     | BMI160_TAP_DURN_150MS
- *  0x04     | BMI160_TAP_DURN_200MS
- *  0x05     | BMI160_TAP_DURN_250MS
- *  0x06     | BMI160_TAP_DURN_375MS
- *  0x07     | BMI160_TAP_DURN_700MS
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_tap_durn(
-u8 *v_tap_durn_u8);
-/*!
- *	@brief This API is used to write the tap duration
- *	from the register 0x63 bit 0 to 2
- *
- *
- *
- *  @param v_tap_durn_u8 : The value of tap duration
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | BMI160_TAP_DURN_50MS
- *  0x01     | BMI160_TAP_DURN_100MS
- *  0x03     | BMI160_TAP_DURN_150MS
- *  0x04     | BMI160_TAP_DURN_200MS
- *  0x05     | BMI160_TAP_DURN_250MS
- *  0x06     | BMI160_TAP_DURN_375MS
- *  0x07     | BMI160_TAP_DURN_700MS
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_tap_durn(
-u8 v_tap_durn_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR TAP SHOCK CONFIGURATION*/
-/***************************************************************/
- /*!
- *	@brief This API read the
- *	tap shock duration from the register 0x63 bit 2
- *
- *  @param v_tap_shock_u8 :The value of tap shock
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | BMI160_TAP_SHOCK_50MS
- *  0x01     | BMI160_TAP_SHOCK_75MS
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_tap_shock(
-u8 *v_tap_shock_u8);
- /*!
- *	@brief This API write the
- *	tap shock duration from the register 0x63 bit 2
- *
- *  @param v_tap_shock_u8 :The value of tap shock
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | BMI160_TAP_SHOCK_50MS
- *  0x01     | BMI160_TAP_SHOCK_75MS
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_tap_shock(
-u8 v_tap_shock_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR TAP QUIET CONFIGURATION*/
-/***************************************************************/
-/*!
- *	@brief This API read
- *	tap quiet duration from the register 0x63 bit 7
- *
- *
- *  @param v_tap_quiet_u8 : The value of tap quiet
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | BMI160_TAP_QUIET_30MS
- *  0x01     | BMI160_TAP_QUIET_20MS
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_tap_quiet(
-u8 *v_tap_quiet_u8);
-/*!
- *	@brief This API write
- *	tap quiet duration from the register 0x63 bit 7
- *
- *
- *  @param v_tap_quiet_u8 : The value of tap quiet
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | BMI160_TAP_QUIET_30MS
- *  0x01     | BMI160_TAP_QUIET_20MS
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_tap_quiet(
-u8 v_tap_quiet_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR TAP THRESHOLD CONFIGURATION*/
-/***************************************************************/
- /*!
- *	@brief This API read Threshold of the
- *	single/double tap interrupt from the register 0x64 bit 0 to 4
- *
- *
- *	@param v_tap_thres_u8 : The value of single/double tap threshold
- *
- *	@note single/double tap threshold changes according to accel g range
- *	accel g range can be set by the function ""
- *   accel_range    | single/double tap threshold
- *  ----------------|---------------------
- *      2g          |  ((v_tap_thres_u8 + 1) * 62.5)mg
- *      4g          |  ((v_tap_thres_u8 + 1) * 125)mg
- *      8g          |  ((v_tap_thres_u8 + 1) * 250)mg
- *      16g         |  ((v_tap_thres_u8 + 1) * 500)mg
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_tap_thres(
-u8 *v_tap_thres_u8);
- /*!
- *	@brief This API write Threshold of the
- *	single/double tap interrupt from the register 0x64 bit 0 to 4
- *
- *
- *	@param v_tap_thres_u8 : The value of single/double tap threshold
- *
- *	@note single/double tap threshold changes according to accel g range
- *	accel g range can be set by the function ""
- *   accel_range    | single/double tap threshold
- *  ----------------|---------------------
- *      2g          |  ((v_tap_thres_u8 + 1) * 62.5)mg
- *      4g          |  ((v_tap_thres_u8 + 1) * 125)mg
- *      8g          |  ((v_tap_thres_u8 + 1) * 250)mg
- *      16g         |  ((v_tap_thres_u8 + 1) * 500)mg
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_tap_thres(
-u8 v_tap_thres_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR ORIENT MODE CONFIGURATION*/
-/***************************************************************/
- /*!
- *	@brief This API read the threshold for orientation interrupt
- *	from the register 0x65 bit 0 and 1
- *
- *  @param v_orient_mode_u8 : The value of threshold for orientation
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | symmetrical
- *  0x01     | high-asymmetrical
- *  0x02     | low-asymmetrical
- *  0x03     | symmetrical
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_orient_mode(
-u8 *v_orient_mode_u8);
- /*!
- *	@brief This API write the threshold for orientation interrupt
- *	from the register 0x65 bit 0 and 1
- *
- *  @param v_orient_mode_u8 : The value of threshold for orientation
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | symmetrical
- *  0x01     | high-asymmetrical
- *  0x02     | low-asymmetrical
- *  0x03     | symmetrical
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_orient_mode(
-u8 v_orient_mode_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR ORIENT BLOCKING CONFIGURATION*/
-/***************************************************************/
-/*!
- *	@brief This API read the orient blocking mode
- *	that is used for the generation of the orientation interrupt.
- *	from the register 0x65 bit 2 and 3
- *
- *  @param v_orient_blocking_u8 : The value of orient blocking mode
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | No blocking
- *  0x01     | Theta blocking or acceleration in any axis > 1.5g
- *  0x02     | Theta blocking or acceleration slope in any axis >
- *   -       | 0.2g or acceleration in any axis > 1.5g
- *  0x03     | Theta blocking or acceleration slope in any axis >
- *   -       | 0.4g or acceleration in any axis >
- *   -       | 1.5g and value of orient is not stable
- *   -       | for at least 100 ms
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_orient_blocking(
-u8 *v_orient_blocking_u8);
-/*!
- *	@brief This API write the orient blocking mode
- *	that is used for the generation of the orientation interrupt.
- *	from the register 0x65 bit 2 and 3
- *
- *  @param v_orient_blocking_u8 : The value of orient blocking mode
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | No blocking
- *  0x01     | Theta blocking or acceleration in any axis > 1.5g
- *  0x02     | Theta blocking or acceleration slope in any axis >
- *   -       | 0.2g or acceleration in any axis > 1.5g
- *  0x03     | Theta blocking or acceleration slope in any axis >
- *   -       | 0.4g or acceleration in any axis >
- *   -       | 1.5g and value of orient is not stable
- *   -       | for at least 100 ms
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_orient_blocking(
-u8 v_orient_blocking_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR ORIENT HYSTERESIS CONFIGURATION*/
-/***************************************************************/
-/*!
- *	@brief This API read Orient interrupt
- *	hysteresis, from the register 0x64 bit 4 to 7
- *
- *
- *
- *  @param v_orient_hyst_u8 : The value of orient hysteresis
- *
- *	@note 1 LSB corresponds to 62.5 mg,
- *	irrespective of the selected accel range
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_orient_hyst(
-u8 *v_orient_hyst_u8);
-/*!
- *	@brief This API write Orient interrupt
- *	hysteresis, from the register 0x64 bit 4 to 7
- *
- *
- *
- *  @param v_orient_hyst_u8 : The value of orient hysteresis
- *
- *	@note 1 LSB corresponds to 62.5 mg,
- *	irrespective of the selected accel range
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_orient_hyst(
-u8 v_orient_hyst_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR ORIENT THETA CONFIGURATION*/
-/***************************************************************/
- /*!
- *	@brief This API read Orient
- *	blocking angle (0 to 44.8) from the register 0x66 bit 0 to 5
- *
- *  @param v_orient_theta_u8 : The value of Orient blocking angle
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_orient_theta(
-u8 *v_orient_theta_u8);
- /*!
- *	@brief This API write Orient
- *	blocking angle (0 to 44.8) from the register 0x66 bit 0 to 5
- *
- *  @param v_orient_theta_u8 : The value of Orient blocking angle
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_orient_theta(
-u8 v_orient_theta_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR ORIENT OUTPUT ENABLE CONFIGURATION*/
-/***************************************************************/
-/*!
- *	@brief This API read orient change
- *	of up/down bit from the register 0x66 bit 6
- *
- *  @param v_orient_ud_u8 : The value of orient change of up/down
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | Is ignored
- *  0x01     | Generates orientation interrupt
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_orient_ud_enable(
-u8 *v_orient_ud_u8);
-/*!
- *	@brief This API write orient change
- *	of up/down bit from the register 0x66 bit 6
- *
- *  @param v_orient_ud_u8 : The value of orient change of up/down
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | Is ignored
- *  0x01     | Generates orientation interrupt
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_orient_ud_enable(
-u8 v_orient_ud_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR ORIENT AXIS ENABLE CONFIGURATION*/
-/***************************************************************/
- /*!
- *	@brief This API read orientation axes changes
- *	from the register 0x66 bit 7
- *
- *  @param v_orient_axes_u8 : The value of orient axes assignment
- *	value    |       Behaviour    | Name
- * ----------|--------------------|------
- *  0x00     | x = x, y = y, z = z|orient_ax_noex
- *  0x01     | x = y, y = z, z = x|orient_ax_ex
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_orient_axes_enable(
-u8 *v_orient_axes_u8);
- /*!
- *	@brief This API write orientation axes changes
- *	from the register 0x66 bit 7
- *
- *  @param v_orient_axes_u8 : The value of orient axes assignment
- *	value    |       Behaviour    | Name
- * ----------|--------------------|------
- *  0x00     | x = x, y = y, z = z|orient_ax_noex
- *  0x01     | x = y, y = z, z = x|orient_ax_ex
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_orient_axes_enable(
-u8 v_orient_axes_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR FLAT THETA CONFIGURATION*/
-/***************************************************************/
- /*!
- *	@brief This API read Flat angle (0 to 44.8) for flat interrupt
- *	from the register 0x67 bit 0 to 5
- *
- *  @param v_flat_theta_u8 : The value of flat angle
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_flat_theta(
-u8 *v_flat_theta_u8);
- /*!
- *	@brief This API write Flat angle (0 to 44.8) for flat interrupt
- *	from the register 0x67 bit 0 to 5
- *
- *  @param v_flat_theta_u8 : The value of flat angle
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_flat_theta(
-u8 v_flat_theta_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR FLAT HOLD CONFIGURATION*/
-/***************************************************************/
-/*!
- *	@brief This API read Flat interrupt hold time;
- *	from the register 0x68 bit 4 and 5
- *
- *  @param v_flat_hold_u8 : The value of flat hold time
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | 0ms
- *  0x01     | 512ms
- *  0x01     | 1024ms
- *  0x01     | 2048ms
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_flat_hold(
-u8 *v_flat_hold_u8);
-/*!
- *	@brief This API write Flat interrupt hold time;
- *	from the register 0x68 bit 4 and 5
- *
- *  @param v_flat_hold_u8 : The value of flat hold time
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | 0ms
- *  0x01     | 512ms
- *  0x01     | 1024ms
- *  0x01     | 2048ms
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_flat_hold(
-u8 v_flat_hold_u8);
-/***************************************************************/
-/**\name	FUNCTION FOR FLAT HYSTERESIS CONFIGURATION*/
-/***************************************************************/
-/*!
- *	@brief This API read flat interrupt hysteresis
- *	from the register 0x68 bit 0 to 3
- *
- *  @param v_flat_hyst_u8 : The value of flat hysteresis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_flat_hyst(
-u8 *v_flat_hyst_u8);
-/*!
- *	@brief This API write flat interrupt hysteresis
- *	from the register 0x68 bit 0 to 3
- *
- *  @param v_flat_hyst_u8 : The value of flat hysteresis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_flat_hyst(
-u8 v_flat_hyst_u8);
-/***************************************************************/
-/**\name	FUNCTION FAST OFFSET COMPENSATION FOR ACCEL */
-/***************************************************************/
- /*!
- *	@brief This API read accel offset compensation
- *	target value for z-axis from the register 0x69 bit 0 and 1
- *
- *  @param v_foc_accel_z_u8 : the value of accel offset compensation z axis
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | disable
- *  0x01     | +1g
- *  0x01     | -1g
- *  0x01     | 0g
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_foc_accel_z(
-u8 *v_foc_accel_z_u8);
- /*!
- *	@brief This API write accel offset compensation
- *	target value for z-axis from the register 0x69 bit 0 and 1
- *
- *  @param v_foc_accel_z_u8 : the value of accel offset compensation z axis
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | disable
- *  0x01     | +1g
- *  0x01     | -1g
- *  0x01     | 0g
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_foc_accel_z(
-u8 v_foc_accel_z_u8);
-/*!
- *	@brief This API read accel offset compensation
- *	target value for y-axis
- *	from the register 0x69 bit 2 and 3
- *
- *  @param v_foc_accel_y_u8 : the value of accel offset compensation y axis
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | disable
- *  0x01     | +1g
- *  0x01     | -1g
- *  0x01     | 0g
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_foc_accel_y(
-u8 *v_foc_accel_y_u8);
-/*!
- *	@brief This API write accel offset compensation
- *	target value for y-axis
- *	from the register 0x69 bit 2 and 3
- *
- *  @param v_foc_accel_y_u8 : the value of accel offset compensation y axis
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | disable
- *  0x01     | +1g
- *  0x01     | -1g
- *  0x01     | 0g
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_foc_accel_y(
-u8 v_foc_accel_y_u8);
-/*!
- *	@brief This API read accel offset compensation
- *	target value for x-axis is
- *	from the register 0x69 bit 4 and 5
- *
- *  @param v_foc_accel_x_u8 : the value of accel offset compensation x axis
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | disable
- *  0x01     | +1g
- *  0x01     | -1g
- *  0x01     | 0g
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_foc_accel_x(
-u8 *v_foc_accel_x_u8);
-/*!
- *	@brief This API write accel offset compensation
- *	target value for x-axis is
- *	from the register 0x69 bit 4 and 5
- *
- *  @param v_foc_accel_x_u8 : the value of accel offset compensation x axis
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | disable
- *  0x01     | +1g
- *  0x01     | -1g
- *  0x01     | 0g
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_foc_accel_x(
-u8 v_foc_accel_x_u8);
-/***************************************************************/
-/**\name	FUNCTION FAST OFFSET COMPENSATION FOR GYRO */
-/***************************************************************/
-/*!
- *	@brief This API write gyro fast offset enable
- *	from the register 0x69 bit 6
- *
- *  @param v_foc_gyro_u8 : The value of gyro fast offset enable
- *  value    |  Description
- * ----------|-------------
- *    0      | fast offset compensation disabled
- *    1      |  fast offset compensation enabled
- *
- *	@param v_gyro_off_x_s16 : The value of gyro fast offset x axis data
- *	@param v_gyro_off_y_s16 : The value of gyro fast offset y axis data
- *	@param v_gyro_off_z_s16 : The value of gyro fast offset z axis data
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_foc_gyro_enable(
-u8 v_foc_gyro_u8, s16 *v_gyro_off_x_s16,
-s16 *v_gyro_off_y_s16, s16 *v_gyro_off_z_s16);
-/***************************************************/
-/**\name	FUNCTION FOR NVM*/
-/***************************************************/
- /*!
- *	@brief This API read NVM program enable
- *	from the register 0x6A bit 1
- *
- *  @param v_nvm_prog_u8 : The value of NVM program enable
- *  Value  |  Description
- * --------|-------------
- *   0     |  DISABLE
- *   1     |  ENABLE
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_nvm_prog_enable(
-u8 *v_nvm_prog_u8);
- /*!
- *	@brief This API write NVM program enable
- *	from the register 0x6A bit 1
- *
- *  @param v_nvm_prog_u8 : The value of NVM program enable
- *  Value  |  Description
- * --------|-------------
- *   0     |  DISABLE
- *   1     |  ENABLE
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_nvm_prog_enable(
-u8 v_nvm_prog_u8);
-/***************************************************/
-/**\name	FUNCTION FOR SPI MODE*/
-/***************************************************/
-/*!
- * @brief This API read to configure SPI
- * Interface Mode for primary and OIS interface
- * from the register 0x6B bit 0
- *
- *  @param v_spi3_u8 : The value of SPI mode selection
- *  Value  |  Description
- * --------|-------------
- *   0     |  SPI 4-wire mode
- *   1     |  SPI 3-wire mode
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_spi3(
-u8 *v_spi3_u8);
-/*!
- * @brief This API write to configure SPI
- * Interface Mode for primary and OIS interface
- * from the register 0x6B bit 0
- *
- *  @param v_spi3_u8 : The value of SPI mode selection
- *  Value  |  Description
- * --------|-------------
- *   0     |  SPI 4-wire mode
- *   1     |  SPI 3-wire mode
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_spi3(
-u8 v_spi3_u8);
-/***************************************************/
-/**\name	FUNCTION FOR FOC GYRO */
-/***************************************************/
-/*!
- *	@brief This API read gyro fast offset enable
- *	from the register 0x69 bit 6
- *
- *  @param v_foc_gyro_u8 : The value of gyro fast offset enable
- *  value    |  Description
- * ----------|-------------
- *    0      | fast offset compensation disabled
- *    1      |  fast offset compensation enabled
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_foc_gyro_enable(
-u8 *v_foc_gyro_u8);
-/***************************************************/
-/**\name	FUNCTION FOR I2C WATCHDOG TIMBER */
-/***************************************************/
-/*!
- *	@brief This API read I2C Watchdog timer
- *	from the register 0x70 bit 1
- *
- *  @param v_i2c_wdt_u8 : The value of I2C watch dog timer
- *  Value  |  Description
- * --------|-------------
- *   0     |  I2C watchdog v_timeout_u8 after 1 ms
- *   1     |  I2C watchdog v_timeout_u8 after 50 ms
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_i2c_wdt_select(
-u8 *v_i2c_wdt_u8);
-/*!
- *	@brief This API write I2C Watchdog timer
- *	from the register 0x70 bit 1
- *
- *  @param v_i2c_wdt_u8 : The value of I2C watch dog timer
- *  Value  |  Description
- * --------|-------------
- *   0     |  I2C watchdog v_timeout_u8 after 1 ms
- *   1     |  I2C watchdog v_timeout_u8 after 50 ms
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE
-bmi160_set_i2c_wdt_select(u8 v_i2c_wdt_u8);
-/*!
- *	@brief This API read I2C watchdog enable
- *	from the register 0x70 bit 2
- *
- *  @param v_i2c_wdt_u8 : The value of I2C watchdog enable
- *  Value  |  Description
- * --------|-------------
- *   0     |  DISABLE
- *   1     |  ENABLE
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_i2c_wdt_enable(
-u8 *v_i2c_wdt_u8);
-/*!
- *	@brief This API write I2C watchdog enable
- *	from the register 0x70 bit 2
- *
- *  @param v_i2c_wdt_u8 : The value of I2C watchdog enable
- *  Value  |  Description
- * --------|-------------
- *   0     |  DISABLE
- *   1     |  ENABLE
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_i2c_wdt_enable(
-u8 v_i2c_wdt_u8);
-/***************************************************/
-/**\name	FUNCTION FOR IF MODE*/
-/***************************************************/
-/*!
- * @brief This API read I2C interface configuration(if) moe
- * from the register 0x6B bit 4 and 5
- *
- *  @param  v_if_mode_u8 : The value of interface configuration mode
- *  Value  |  Description
- * --------|-------------
- *   0x00  |  Primary interface:autoconfig / secondary interface:off
- *   0x01  |  Primary interface:I2C / secondary interface:OIS
- *   0x02  |  Primary interface:autoconfig/secondary interface:Magnetometer
- *   0x03  |   Reserved
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_if_mode(
-u8 *v_if_mode_u8);
-/*!
- * @brief This API write I2C interface configuration(if) moe
- * from the register 0x6B bit 4 and 5
- *
- *  @param  v_if_mode_u8 : The value of interface configuration mode
- *  Value  |  Description
- * --------|-------------
- *   0x00  |  Primary interface:autoconfig / secondary interface:off
- *   0x01  |  Primary interface:I2C / secondary interface:OIS
- *   0x02  |  Primary interface:autoconfig/secondary interface:Magnetometer
- *   0x03  |   Reserved
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_if_mode(
-u8 v_if_mode_u8);
-/***************************************************/
-/**\name	FUNCTION FOR GYRO SLEEP TRIGGER INTERRUPT CONFIGURATION*/
-/***************************************************/
-/*!
- *	@brief This API read gyro sleep trigger
- *	from the register 0x6C bit 0 to 2
- *
- *  @param v_gyro_sleep_trigger_u8 : The value of gyro sleep trigger
- *  Value  |  Description
- * --------|-------------
- *   0x00  | nomotion: no / Not INT1 pin: no / INT2 pin: no
- *   0x01  | nomotion: no / Not INT1 pin: no / INT2 pin: yes
- *   0x02  | nomotion: no / Not INT1 pin: yes / INT2 pin: no
- *   0x03  | nomotion: no / Not INT1 pin: yes / INT2 pin: yes
- *   0x04  | nomotion: yes / Not INT1 pin: no / INT2 pin: no
- *   0x05  | anymotion: yes / Not INT1 pin: no / INT2 pin: yes
- *   0x06  | anymotion: yes / Not INT1 pin: yes / INT2 pin: no
- *   0x07  | anymotion: yes / Not INT1 pin: yes / INT2 pin: yes
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_sleep_trigger(
-u8 *v_gyro_sleep_trigger_u8);
-/*!
- *	@brief This API write gyro sleep trigger
- *	from the register 0x6C bit 0 to 2
- *
- *  @param v_gyro_sleep_trigger_u8 : The value of gyro sleep trigger
- *  Value  |  Description
- * --------|-------------
- *   0x00  | nomotion: no / Not INT1 pin: no / INT2 pin: no
- *   0x01  | nomotion: no / Not INT1 pin: no / INT2 pin: yes
- *   0x02  | nomotion: no / Not INT1 pin: yes / INT2 pin: no
- *   0x03  | nomotion: no / Not INT1 pin: yes / INT2 pin: yes
- *   0x04  | nomotion: yes / Not INT1 pin: no / INT2 pin: no
- *   0x05  | anymotion: yes / Not INT1 pin: no / INT2 pin: yes
- *   0x06  | anymotion: yes / Not INT1 pin: yes / INT2 pin: no
- *   0x07  | anymotion: yes / Not INT1 pin: yes / INT2 pin: yes
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_sleep_trigger(
-u8 v_gyro_sleep_trigger_u8);
-/*!
- *	@brief This API read gyro wakeup trigger
- *	from the register 0x6C bit 3 and 4
- *
- *  @param v_gyro_wakeup_trigger_u8 : The value of gyro wakeup trigger
- *  Value  |  Description
- * --------|-------------
- *   0x00  | anymotion: no / INT1 pin: no
- *   0x01  | anymotion: no / INT1 pin: yes
- *   0x02  | anymotion: yes / INT1 pin: no
- *   0x03  | anymotion: yes / INT1 pin: yes
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_wakeup_trigger(
-u8 *v_gyro_wakeup_trigger_u8);
-/*!
- *	@brief This API write gyro wakeup trigger
- *	from the register 0x6C bit 3 and 4
- *
- *  @param v_gyro_wakeup_trigger_u8 : The value of gyro wakeup trigger
- *  Value  |  Description
- * --------|-------------
- *   0x00  | anymotion: no / INT1 pin: no
- *   0x01  | anymotion: no / INT1 pin: yes
- *   0x02  | anymotion: yes / INT1 pin: no
- *   0x03  | anymotion: yes / INT1 pin: yes
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_wakeup_trigger(
-u8 v_gyro_wakeup_trigger_u8);
-/*!
- *	@brief This API read Target state for gyro sleep mode
- *	from the register 0x6C bit 5
- *
- *  @param v_gyro_sleep_state_u8 : The value of gyro sleep mode
- *  Value  |  Description
- * --------|-------------
- *   0x00  | Sleep transition to fast wake up state
- *   0x01  | Sleep transition to suspend state
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_sleep_state(
-u8 *v_gyro_sleep_state_u8);
-/*!
- *	@brief This API write Target state for gyro sleep mode
- *	from the register 0x6C bit 5
- *
- *  @param v_gyro_sleep_state_u8 : The value of gyro sleep mode
- *  Value  |  Description
- * --------|-------------
- *   0x00  | Sleep transition to fast wake up state
- *   0x01  | Sleep transition to suspend state
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_sleep_state(
-u8 v_gyro_sleep_state_u8);
-/*!
- *	@brief This API read gyro wakeup interrupt
- *	from the register 0x6C bit 6
- *
- *  @param v_gyro_wakeup_intr_u8 : The valeu of gyro wakeup interrupt
- *  Value  |  Description
- * --------|-------------
- *   0x00  | DISABLE
- *   0x01  | ENABLE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_wakeup_intr(
-u8 *v_gyro_wakeup_intr_u8);
-/*!
- *	@brief This API write gyro wakeup interrupt
- *	from the register 0x6C bit 6
- *
- *  @param v_gyro_wakeup_intr_u8 : The valeu of gyro wakeup interrupt
- *  Value  |  Description
- * --------|-------------
- *   0x00  | DISABLE
- *   0x01  | ENABLE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_wakeup_intr(
-u8 v_gyro_wakeup_intr_u8);
-/***************************************************/
-/**\name	FUNCTION FOR ACCEL SELF TEST */
-/***************************************************/
-/*!
- * @brief This API read accel select axis to be self-test
- *
- *  @param v_accel_selftest_axis_u8 :
- *	The value of accel self test axis selection
- *  Value  |  Description
- * --------|-------------
- *   0x00  | disabled
- *   0x01  | x-axis
- *   0x02  | y-axis
- *   0x03  | z-axis
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_selftest_axis(
-u8 *acc_selftest_axis);
-/*!
- * @brief This API write accel select axis to be self-test
- *
- *  @param v_accel_selftest_axis_u8 :
- *	The value of accel self test axis selection
- *  Value  |  Description
- * --------|-------------
- *   0x00  | disabled
- *   0x01  | x-axis
- *   0x02  | y-axis
- *   0x03  | z-axis
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_selftest_axis(
-u8 acc_selftest_axis);
-/*!
- *	@brief This API read accel self test axis sign
- *	from the register 0x6D bit 2
- *
- *  @param v_accel_selftest_sign_u8: The value of accel self test axis sign
- *  Value  |  Description
- * --------|-------------
- *   0x00  | negative
- *   0x01  | positive
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_selftest_sign(
-u8 *acc_selftest_sign);
-/*!
- *	@brief This API write accel self test axis sign
- *	from the register 0x6D bit 2
- *
- *  @param v_accel_selftest_sign_u8: The value of accel self test axis sign
- *  Value  |  Description
- * --------|-------------
- *   0x00  | negative
- *   0x01  | positive
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_selftest_sign(
-u8 acc_selftest_sign);
-/*!
- *	@brief This API read accel self test amplitude
- *	from the register 0x6D bit 3
- *        select amplitude of the selftest deflection:
- *
- *  @param v_accel_selftest_amp_u8 : The value of accel self test amplitude
- *  Value  |  Description
- * --------|-------------
- *   0x00  | LOW
- *   0x01  | HIGH
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_selftest_amp(
-u8 *acc_selftest_amp);
-/*!
- *	@brief This API write accel self test amplitude
- *	from the register 0x6D bit 3
- *        select amplitude of the selftest deflection:
- *
- *  @param v_accel_selftest_amp_u8 : The value of accel self test amplitude
- *  Value  |  Description
- * --------|-------------
- *   0x00  | LOW
- *   0x01  | HIGH
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_selftest_amp(
-u8 acc_selftest_amp);
-/***************************************************/
-/**\name	FUNCTION FOR GYRO SELF TEST */
-/***************************************************/
-/*!
- *	@brief This API read gyro self test trigger
- *
- *	@param v_gyro_selftest_start_u8: The value of gyro self test start
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_selftest_start(
-u8 *v_gyro_selftest_start_u8);
-/*!
- *	@brief This API write gyro self test trigger
- *
- *	@param v_gyro_selftest_start_u8: The value of gyro self test start
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_selftest_start(
-u8 v_gyro_selftest_start_u8);
-/***************************************************/
-/**\name	FUNCTION FOR SPI/I2C ENABLE */
-/***************************************************/
- /*!
- * @brief This API read primary interface selection I2C or SPI
- *	from the register 0x70 bit 0
- *
- *  @param v_spi_enable_u8: The value of Interface selection
- *  Value  |  Description
- * --------|-------------
- *   0x00  | I2C Enable
- *   0x01  | I2C DISBALE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_spi_enable(
-u8 *v_spi_enable_u8);
- /*!
- * @brief This API write primary interface selection I2C or SPI
- *	from the register 0x70 bit 0
- *
- *  @param v_spi_enable_u8: The value of Interface selection
- *  Value  |  Description
- * --------|-------------
- *   0x00  | I2C Enable
- *   0x01  | I2C DISBALE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_spi_enable(
-u8 v_spi_enable_u8);
- /*!
- *	@brief This API read the spare zero
- *	form register 0x70 bit 3
- *
- *
- *  @param v_spare0_trim_u8: The value of spare zero
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_spare0_trim
-(u8 *v_spare0_trim_u8);
- /*!
- *	@brief This API write the spare zero
- *	form register 0x70 bit 3
- *
- *
- *  @param v_spare0_trim_u8: The value of spare zero
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_spare0_trim
-(u8 v_spare0_trim_u8);
-/***************************************************/
-/**\name	FUNCTION FOR NVM COUNTER */
-/***************************************************/
- /*!
- *	@brief This API read the NVM counter
- *	form register 0x70 bit 4 to 7
- *
- *
- *  @param v_nvm_counter_u8: The value of NVM counter
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_nvm_counter(
-u8 *v_nvm_counter_u8);
- /*!
- *	@brief This API write the NVM counter
- *	form register 0x70 bit 4 to 7
- *
- *
- *  @param v_nvm_counter_u8: The value of NVM counter
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_nvm_counter(
-u8 v_nvm_counter_u8);
-/***************************************************/
-/**\name	FUNCTION FOR ACCEL MANUAL OFFSET COMPENSATION */
-/***************************************************/
-/*!
- *	@brief This API read accel manual offset compensation of x axis
- *	from the register 0x71 bit 0 to 7
- *
- *
- *
- *  @param v_accel_off_x_s8:
- *	The value of accel manual offset compensation of x axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_offset_compensation_xaxis(
-s8 *v_accel_off_x_s8);
-/*!
- *	@brief This API write accel manual offset compensation of x axis
- *	from the register 0x71 bit 0 to 7
- *
- *
- *
- *  @param v_accel_off_x_s8:
- *	The value of accel manual offset compensation of x axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_offset_compensation_xaxis(
-s8 v_accel_off_x_s8);
-/*!
- *	@brief This API read accel manual offset compensation of y axis
- *	from the register 0x72 bit 0 to 7
- *
- *
- *
- *  @param v_accel_off_y_s8:
- *	The value of accel manual offset compensation of y axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_offset_compensation_yaxis(
-s8 *v_accel_off_y_s8);
-/*!
- *	@brief This API write accel manual offset compensation of y axis
- *	from the register 0x72 bit 0 to 7
- *
- *
- *
- *  @param v_accel_off_y_s8:
- *	The value of accel manual offset compensation of y axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_offset_compensation_yaxis(
-s8 v_accel_off_y_s8);
-/*!
- *	@brief This API read accel manual offset compensation of z axis
- *	from the register 0x73 bit 0 to 7
- *
- *
- *
- *  @param v_accel_off_z_s8:
- *	The value of accel manual offset compensation of z axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_offset_compensation_zaxis(
-s8 *v_accel_off_z_s8);
-/*!
- *	@brief This API write accel manual offset compensation of z axis
- *	from the register 0x73 bit 0 to 7
- *
- *
- *
- *  @param v_accel_off_z_s8:
- *	The value of accel manual offset compensation of z axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_offset_compensation_zaxis(
-s8 v_accel_off_z_s8);
-/***************************************************/
-/**\name	FUNCTION FOR GYRO MANUAL OFFSET COMPENSATION */
-/***************************************************/
-/*!
- *	@brief This API read gyro manual offset compensation of x axis
- *	from the register 0x74 bit 0 to 7 and 0x77 bit 0 and 1
- *
- *
- *
- *  @param v_gyro_off_x_s16:
- *	The value of gyro manual offset compensation of x axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_offset_compensation_xaxis(
-s16 *v_gyro_off_x_s16);
-/*!
- *	@brief This API write gyro manual offset compensation of x axis
- *	from the register 0x74 bit 0 to 7 and 0x77 bit 0 and 1
- *
- *
- *
- *  @param v_gyro_off_x_s16:
- *	The value of gyro manual offset compensation of x axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_offset_compensation_xaxis(
-s16 v_gyro_off_x_s16);
-/*!
- *	@brief This API read gyro manual offset compensation of y axis
- *	from the register 0x75 bit 0 to 7 and 0x77 bit 2 and 3
- *
- *
- *
- *  @param v_gyro_off_y_s16:
- *	The value of gyro manual offset compensation of y axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_offset_compensation_yaxis(
-s16 *v_gyro_off_y_s16);
-/*!
- *	@brief This API write gyro manual offset compensation of y axis
- *	from the register 0x75 bit 0 to 7 and 0x77 bit 2 and 3
- *
- *
- *
- *  @param v_gyro_off_y_s16:
- *	The value of gyro manual offset compensation of y axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_offset_compensation_yaxis(
-s16 v_gyro_off_y_s16);
-/*!
- *	@brief This API read gyro manual offset compensation of z axis
- *	from the register 0x76 bit 0 to 7 and 0x77 bit 4 and 5
- *
- *
- *
- *  @param v_gyro_off_z_s16:
- *	The value of gyro manual offset compensation of z axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_offset_compensation_zaxis(
-s16 *v_gyro_off_z_s16);
-/*!
- *	@brief This API write gyro manual offset compensation of z axis
- *	from the register 0x76 bit 0 to 7 and 0x77 bit 4 and 5
- *
- *
- *
- *  @param v_gyro_off_z_s16:
- *	The value of gyro manual offset compensation of z axis
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_offset_compensation_zaxis(
-s16 v_gyro_off_z_s16);
-/*!
- *	@brief This API writes accel fast offset compensation
- *	from the register 0x69 bit 0 to 5
- *	@brief This API writes each axis individually
- *	FOC_X_AXIS - bit 4 and 5
- *	FOC_Y_AXIS - bit 2 and 3
- *	FOC_Z_AXIS - bit 0 and 1
- *
- *  @param  v_foc_accel_u8: The value of accel offset compensation
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | disable
- *  0x01     | +1g
- *  0x01     | -1g
- *  0x01     | 0g
- *
- *  @param  v_axis_u8: The value of accel offset axis selection
-  *	value    | axis
- * ----------|-------------------
- *  0        | FOC_X_AXIS
- *  1        | FOC_Y_AXIS
- *  2        | FOC_Z_AXIS
- *
- *	@param v_accel_offset_s8: The accel offset value
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_foc_trigger(u8 axis,
-u8 foc_acc, s8 *accel_offset);
-/*!
- *	@brief This API write fast accel offset compensation
- *	it writes all axis together.To the register 0x69 bit 0 to 5
- *	FOC_X_AXIS - bit 4 and 5
- *	FOC_Y_AXIS - bit 2 and 3
- *	FOC_Z_AXIS - bit 0 and 1
- *
- *  @param  v_foc_accel_x_u8: The value of accel offset x compensation
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | disable
- *  0x01     | +1g
- *  0x01     | -1g
- *  0x01     | 0g
- *
- *  @param  v_foc_accel_y_u8: The value of accel offset y compensation
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | disable
- *  0x01     | +1g
- *  0x01     | -1g
- *  0x01     | 0g
- *
- *  @param  v_foc_accel_z_u8: The value of accel offset z compensation
- *	value    | Behaviour
- * ----------|-------------------
- *  0x00     | disable
- *  0x01     | +1g
- *  0x01     | -1g
- *  0x01     | 0g
- *
- *  @param  v_accel_off_x_s8: The value of accel offset x axis
- *  @param  v_accel_off_y_s8: The value of accel offset y axis
- *  @param  v_accel_off_z_s8: The value of accel offset z axis
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_accel_foc_trigger_xyz(u8 v_foc_accel_x_u8,
-u8 v_foc_accel_y_u8, u8 v_foc_accel_z_u8,
-s8 *acc_off_x, s8 *acc_off_y, s8 *acc_off_z);
-/***************************************************/
-/**\name	FUNCTION FOR ACEL AND GYRO OFFSET ENABLE */
-/***************************************************/
-/*!
- *	@brief This API read the accel offset enable bit
- *	from the register 0x77 bit 6
- *
- *
- *
- *  @param v_accel_off_enable_u8: The value of accel offset enable
- *  value    |  Description
- * ----------|--------------
- *   0x01    | ENABLE
- *   0x00    | DISABLE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_offset_enable(
-u8 *acc_off_en);
-/*!
- *	@brief This API write the accel offset enable bit
- *	from the register 0x77 bit 6
- *
- *
- *
- *  @param v_accel_off_enable_u8: The value of accel offset enable
- *  value    |  Description
- * ----------|--------------
- *   0x01    | ENABLE
- *   0x00    | DISABLE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_offset_enable(
-u8 acc_off_en);
-/*!
- *	@brief This API read the accel offset enable bit
- *	from the register 0x77 bit 7
- *
- *
- *
- *  @param v_gyro_off_enable_u8: The value of gyro offset enable
- *  value    |  Description
- * ----------|--------------
- *   0x01    | ENABLE
- *   0x00    | DISABLE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_offset_enable(
-u8 *v_gyro_off_enable_u8);
-/*!
- *	@brief This API write the accel offset enable bit
- *	from the register 0x77 bit 7
- *
- *
- *
- *  @param v_gyro_off_enable_u8: The value of gyro offset enable
- *  value    |  Description
- * ----------|--------------
- *   0x01    | ENABLE
- *   0x00    | DISABLE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_offset_enable(
-u8 v_gyro_off_enable_u8);
-/***************************************************/
-/**\name	FUNCTION FOR STEP COUNTER INTERRUPT */
-/***************************************************/
-/*!
- *	@brief This API reads step counter value
- *	form the register 0x78 and 0x79
- *
- *
- *
- *
- *  @param v_step_cnt_s16 : The value of step counter
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_step_count(s16 *v_step_cnt_s16);
- /*!
- *	@brief This API Reads
- *	step counter configuration
- *	from the register 0x7A bit 0 to 7
- *	and from the register 0x7B bit 0 to 2 and 4 to 7
- *
- *
- *  @param v_step_config_u16 : The value of step configuration
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_step_config(
-u16 *v_step_config_u16);
- /*!
- *	@brief This API write
- *	step counter configuration
- *	from the register 0x7A bit 0 to 7
- *	and from the register 0x7B bit 0 to 2 and 4 to 7
- *
- *
- *  @param v_step_config_u16   :
- *	the value of  Enable step configuration
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_step_config(
-u16 v_step_config_u16);
- /*!
- *	@brief This API read enable step counter
- *	from the register 0x7B bit 3
- *
- *
- *  @param v_step_counter_u8 : The value of step counter enable
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_step_counter_enable(
-u8 *v_step_counter_u8);
- /*!
- *	@brief This API write enable step counter
- *	from the register 0x7B bit 3
- *
- *
- *  @param v_step_counter_u8 : The value of step counter enable
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_step_counter_enable(
-u8 v_step_counter_u8);
- /*!
- *	@brief This API set Step counter modes
- *
- *
- *  @param  v_step_mode_u8 : The value of step counter mode
- *  value    |   mode
- * ----------|-----------
- *   0       | BMI160_STEP_NORMAL_MODE
- *   1       | BMI160_STEP_SENSITIVE_MODE
- *   2       | BMI160_STEP_ROBUST_MODE
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_step_mode(u8 v_step_mode_u8);
-/*!
- *	@brief This API used to trigger the  signification motion
- *	interrupt
- *
- *
- *  @param  v_significant_u8 : The value of interrupt selection
- *  value    |  interrupt
- * ----------|-----------
- *   0       |  BMI160_MAP_INTR1
- *   1       |  BMI160_MAP_INTR2
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_map_significant_motion_intr(
-u8 v_significant_u8);
-/*!
- *	@brief This API used to trigger the step detector
- *	interrupt
- *
- *
- *  @param  v_step_detector_u8 : The value of interrupt selection
- *  value    |  interrupt
- * ----------|-----------
- *   0       |  BMI160_MAP_INTR1
- *   1       |  BMI160_MAP_INTR2
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_map_step_detector_intr(
-u8 v_step_detector_u8);
- /*!
- *	@brief This API used to clear the step counter interrupt
- *	interrupt
- *
- *
- *  @param  : None
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_clear_step_counter(void);
-/***************************************************/
-/**\name	FUNCTION FOR STEP COMMAND REGISTER WRITE */
-/***************************************************/
- /*!
- *	@brief This API writes value to the register 0x7E bit 0 to 7
- *
- *
- *  @param  v_command_reg_u8 : The value to write command register
- *  value   |  Description
- * ---------|--------------------------------------------------------
- *	0x00	|	Reserved
- *  0x03	|	Starts fast offset calibration for the accel and gyro
- *	0x10	|	Sets the PMU mode for the Accelerometer to suspend
- *	0x11	|	Sets the PMU mode for the Accelerometer to normal
- *	0x12	|	Sets the PMU mode for the Accelerometer Lowpower
- *  0x14	|	Sets the PMU mode for the Gyroscope to suspend
- *	0x15	|	Sets the PMU mode for the Gyroscope to normal
- *	0x16	|	Reserved
- *	0x17	|	Sets the PMU mode for the Gyroscope to fast start-up
- *  0x18	|	Sets the PMU mode for the Magnetometer to suspend
- *	0x19	|	Sets the PMU mode for the Magnetometer to normal
- *	0x1A	|	Sets the PMU mode for the Magnetometer to Lowpower
- *	0xB0	|	Clears all data in the FIFO
- *  0xB1	|	Resets the interrupt engine
- *	0xB2	|	step_cnt_clr Clears the step counter
- *	0xB6	|	Triggers a reset
- *	0x37	|	See extmode_en_last
- *	0x9A	|	See extmode_en_last
- *	0xC0	|	Enable the extended mode
- *  0xC4	|	Erase NVM cell
- *	0xC8	|	Load NVM cell
- *	0xF0	|	Reset acceleration data path
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_command_register(
-u8 v_command_reg_u8);
-/***************************************************/
-/**\name	FUNCTION FOR PAGE ENABLE */
-/***************************************************/
- /*!
- *	@brief This API read target page from the register 0x7F bit 4 and 5
- *
- *  @param v_target_page_u8: The value of target page
- *  value   |  page
- * ---------|-----------
- *   0      |  User data/configure page
- *   1      |  Chip level trim/test page
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_target_page(
-u8 *v_target_page_u8);
- /*!
- *	@brief This API write target page from the register 0x7F bit 4 and 5
- *
- *  @param v_target_page_u8: The value of target page
- *  value   |  page
- * ---------|-----------
- *   0      |  User data/configure page
- *   1      |  Chip level trim/test page
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_target_page(
-u8 v_target_page_u8);
- /*!
- *	@brief This API read page enable from the register 0x7F bit 7
- *
- *
- *
- *  @param v_page_enable_u8: The value of page enable
- *  value   |  page
- * ---------|-----------
- *   0      |  DISABLE
- *   1      |  ENABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_paging_enable(
-u8 *v_page_enable_u8);
- /*!
- *	@brief This API write page enable from the register 0x7F bit 7
- *
- *
- *
- *  @param v_page_enable_u8: The value of page enable
- *  value   |  page
- * ---------|-----------
- *   0      |  DISABLE
- *   1      |  ENABLE
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_paging_enable(
-u8 v_page_enable_u8);
- /*!
- *	@brief This API read
- *	pull up configuration from the register 0X85 bit 4 an 5
- *
- *
- *
- *  @param v_control_pullup_u8: The value of pull up register
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_get_pullup_configuration(
-u8 *v_control_pullup_u8);
- /*!
- *	@brief This API write
- *	pull up configuration from the register 0X85 bit 4 an 5
- *
- *
- *
- *  @param v_control_pullup_u8: The value of pull up register
- *
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_pullup_configuration(
-u8 v_control_pullup_u8);
-/***************************************************/
-/**\name	FUNCTION FOR BMM150 */
-/***************************************************/
- /*!
- *	@brief This function used for initialize the bmm150 sensor
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_bmm150_mag_interface_init(u8 *v_chip_id_u8);
- /*!
- *	@brief This function used for set the mag power control
- *	bit enable
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_bmm150_mag_wakeup(void);
- /*!
- *	@brief This function used for read the trim values of magnetometer
- *
- *	@note
- *	Before reading the mag trimming values
- *	make sure the following two points are addressed
- *	@note
- *	1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note
- *	2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_bmm150_mag_trim(void);
- /*!
- *	@brief This function used for read the compensated value of mag
- *	Before start reading the mag compensated data's
- *	make sure the following two points are addressed
- *	@note
- *	1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note
- *	2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_bmm150_mag_compensate_xyz(
-struct bmi160_mag_xyz_s32_t *mag_comp_xyz);
-/*!
- *	@brief This API used to get the compensated BMM150-X data
- *	the out put of X as s32
- *	Before start reading the mag compensated X data
- *	make sure the following two points are addressed
- *	@note
- *	1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note
- *	2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
- *
- *
- *
- *  @param  v_mag_data_x_s16 : The value of mag raw X data
- *  @param  v_data_r_u16 : The value of mag R data
- *
- *	@return results of compensated X data value output as s32
- *
- */
-s32 bmi160_bmm150_mag_compensate_X(s16 v_mag_data_x_s16, u16 v_data_r_u16);
-/*!
- *	@brief This API used to get the compensated BMM150-Y data
- *	the out put of Y as s32
- *	Before start reading the mag compensated Y data
- *	make sure the following two points are addressed
- *	@note
- *	1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note
- *	2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
- *
- *
- *
- *  @param  v_mag_data_y_s16 : The value of mag raw Y data
- *  @param  v_data_r_u16 : The value of mag R data
- *
- *	@return results of compensated Y data value output as s32
- */
-s32 bmi160_bmm150_mag_compensate_Y(s16 v_mag_data_y_s16, u16 v_data_r_u16);
-/*!
- *	@brief This API used to get the compensated BMM150-Z data
- *	the out put of Z as s32
- *	Before start reading the mag compensated Z data
- *	make sure the following two points are addressed
- *	@note
- *	1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note
- *	2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
- *
- *
- *
- *  @param  v_mag_data_z_s16 : The value of mag raw Z data
- *  @param  v_data_r_u16 : The value of mag R data
- *
- *	@return results of compensated Z data value output as s32
- */
-s32 bmi160_bmm150_mag_compensate_Z(s16 v_mag_data_z_s16, u16 v_data_r_u16);
-/*!
- *	@brief This API used to set the pre-set modes of bmm150
- *	The pre-set mode setting is depend on data rate and xy and z repetitions
- *
- *	@note
- *	Before set the mag preset mode
- *	make sure the following two points are addressed
- *	@note
- *	1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note
- *	2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
- *
- *
- *  @param  v_mode_u8: The value of pre-set mode selection value
- *  value    |  pre_set mode
- * ----------|------------
- *   1       | BMI160_MAG_PRESETMODE_LOWPOWER
- *   2       | BMI160_MAG_PRESETMODE_REGULAR
- *   3       | BMI160_MAG_PRESETMODE_HIGHACCURACY
- *   4       | BMI160_MAG_PRESETMODE_ENHANCED
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_bmm150_mag_presetmode(u8 mode);
-/*!
- *	@brief This function used for set the magnetometer
- *	power mode.
- *	@note
- *	Before set the mag power mode
- *	make sure the following two points are addressed
- *	@note
- *	1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note
- *	2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
- *
- *	@param v_mag_pow_mode_u8 : The value of mag power mode
- *  value    |  mode
- * ----------|------------
- *   0       | FORCE_MODE
- *   1       | SUSPEND_MODE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_bmm150_mag_set_power_mode(u8 mag_pow_mode);
- /*!
- *	@brief This function used for set the magnetometer
- *	power mode.
- *	@note
- *	Before set the mag power mode
- *	make sure the following two point is addressed
- *		Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *
- *	@param v_mag_sec_if_pow_mode_u8 : The value of mag power mode
- *  value    |  mode
- * ----------|------------
- *   0       | BMI160_MAG_FORCE_MODE
- *   1       | BMI160_MAG_SUSPEND_MODE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_bmm150_mag_and_secondary_if_power_mode(
-u8 v_mag_sec_if_pow_mode_u8);
-/***************************************************/
-/**\name	FUNCTIONS FOR AKM09911 AND AKM09912*/
-/***************************************************/
- /*!
- *	@brief This function used for initialize
- *	the AKM09911 and AKM09912 sensor
- *
- *
- *	@param v_akm_i2c_address_u8: The value of device address
- *	AKM sensor   |  Slave address
- * --------------|---------------------
- *  AKM09911     |  AKM09911_I2C_ADDR_1
- *     -         |  and AKM09911_I2C_ADDR_2
- *  AKM09912     |  AKM09912_I2C_ADDR_1
- *     -         |  AKM09912_I2C_ADDR_2
- *     -         |  AKM09912_I2C_ADDR_3
- *     -         |  AKM09912_I2C_ADDR_4
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_akm_mag_interface_init(
-u8 v_akm_i2c_address_u8);
- /*!
- *	@brief This function used for read the sensitivity data of
- *	AKM09911 and AKM09912
- *
- *	@note Before reading the mag sensitivity values
- *	make sure the following two points are addressed
- *	@note	1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note	2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_bst_akm_sensitivity_data(void);
-/*!
- *	@brief This API used to get the compensated X data
- *	of AKM09911 the out put of X as s32
- *	@note	Before start reading the mag compensated X data
- *			make sure the following two points are addressed
- *	@note 1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note 2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
- *
- *
- *  @param v_bst_akm_x_s16 : The value of X data
- *
- *	@return results of compensated X data value output as s32
- *
- */
-s32 bmi160_bst_akm09911_compensate_X(s16 v_bst_akm_x_s16);
-/*!
- *	@brief This API used to get the compensated Y data
- *	of AKM09911 the out put of Y as s32
- *	@note	Before start reading the mag compensated Y data
- *			make sure the following two points are addressed
- *	@note 1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note 2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
- *
- *
- *  @param v_bst_akm_y_s16 : The value of Y data
- *
- *	@return results of compensated Y data value output as s32
- *
- */
-s32 bmi160_bst_akm09911_compensate_Y(s16 v_bst_akm_y_s16);
-/*!
- *	@brief This API used to get the compensated Z data
- *	of AKM09911 the out put of Z as s32
- *	@note	Before start reading the mag compensated Z data
- *			make sure the following two points are addressed
- *	@note 1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note 2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
- *
- *
- *  @param v_bst_akm_z_s16 : The value of Z data
- *
- *	@return results of compensated Z data value output as s32
- *
- */
-s32 bmi160_bst_akm09911_compensate_Z(s16 v_bst_akm_z_s16);
-/*!
- *	@brief This API used to get the compensated X data
- *	of AKM09912 the out put of X as s32
- *	@note	Before start reading the mag compensated X data
- *			make sure the following two points are addressed
- *	@note 1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note 2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
- *
- *
- *  @param v_bst_akm_x_s16 : The value of X data
- *
- *	@return results of compensated X data value output as s32
- *
- */
-s32 bmi160_bst_akm09912_compensate_X(s16 v_bst_akm_x_s16);
-/*!
- *	@brief This API used to get the compensated Y data
- *	of AKM09912 the out put of Y as s32
- *	@note	Before start reading the mag compensated Y data
- *			make sure the following two points are addressed
- *	@note 1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note 2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
- *
- *
- *  @param v_bst_akm_y_s16 : The value of Y data
- *
- *	@return results of compensated Y data value output as s32
- *
- */
-s32 bmi160_bst_akm09912_compensate_Y(s16 v_bst_akm_y_s16);
-/*!
- *	@brief This API used to get the compensated Z data
- *	of AKM09912 the out put of Z as s32
- *	@note	Before start reading the mag compensated Z data
- *			make sure the following two points are addressed
- *	@note 1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note 2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
- *
- *
- *  @param v_bst_akm_z_s16 : The value of Z data
- *
- *	@return results of compensated Z data value output as s32
- *
- */
-s32 bmi160_bst_akm09912_compensate_Z(s16 v_bst_akm_z_s16);
- /*!
- *	@brief This function used for read the compensated value of
- *	AKM09911
- *	@note Before start reading the mag compensated data's
- *	make sure the following two points are addressed
- *	@note	1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note	2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
-
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_akm09911_compensate_xyz(
-struct bmi160_bst_akm_xyz_t *bst_akm_xyz);
- /*!
- *	@brief This function used for read the compensated value of
- *	AKM09912
- *	@note Before start reading the mag compensated data's
- *	make sure the following two points are addressed
- *	@note	1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note	2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
-
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_akm09912_compensate_xyz(
-struct bmi160_bst_akm_xyz_t *bst_akm_xyz);
-/*!
- *	@brief This function used for set the AKM09911 and AKM09912
- *	power mode.
- *	@note Before set the AKM power mode
- *	make sure the following two points are addressed
- *	@note	1.	Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *	@note	2.	And also confirm the secondary-interface power mode
- *		is not in the SUSPEND mode.
- *		by using the function bmi160_get_mag_pmu_status().
- *		If the secondary-interface power mode is in SUSPEND mode
- *		set the value of 0x19(NORMAL mode)by using the
- *		bmi160_set_command_register(0x19) function.
- *
- *	@param v_akm_pow_mode_u8 : The value of akm power mode
- *  value   |    Description
- * ---------|--------------------
- *    0     |  AKM_POWER_DOWN_MODE
- *    1     |  AKM_SINGLE_MEAS_MODE
- *    2     |  FUSE_ROM_MODE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_akm_set_powermode(u8 v_akm_pow_mode_u8);
- /*!
- *	@brief This function used for set the magnetometer
- *	power mode of AKM09911 and AKM09912
- *	@note Before set the mag power mode
- *	make sure the following two point is addressed
- *		Make sure the mag interface is enabled or not,
- *		by using the bmi160_get_if_mode() function.
- *		If mag interface is not enabled set the value of 0x02
- *		to the function bmi160_get_if_mode(0x02)
- *
- *	@param v_mag_sec_if_pow_mode_u8 : The value of secondary if power mode
- *  value   |    Description
- * ---------|--------------------
- *    0     |  BMI160_MAG_FORCE_MODE
- *    1     |  BMI160_MAG_SUSPEND_MODE
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_set_bst_akm_and_secondary_if_powermode(
-u8 v_mag_sec_if_pow_mode_u8);
-/***************************************************/
-/**\name	FUNCTIONS FOR YAMAH-YAS532 */
-/***************************************************/
-/*!
- *	@brief This function used for read the YAMAH-YAS532 init
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yamaha_yas532_mag_interface_init(
-void);
-/*!
- *	@brief This function used to set the YAS532 initial values
- *
- *
-  *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_set_initial_values(void);
-/*!
- *	@brief This function used for YAS532 offset correction
- *
- *
-  *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_magnetic_measure_set_offset(
-void);
-/*!
- *	@brief This function used for read the
- *	YAMAHA YAS532 calibration data
- *
- *
-  *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yamaha_yas532_calib_values(void);
-/*!
- *	@brief This function used for calculate the
- *	YAS532 read the linear data
- *
- *
-  *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_xy1y2_to_linear(
-u16 *v_xy1y2_u16, s32 *xy1y2_linear);
-/*!
- *	@brief This function used for read the YAS532 sensor data
- *	@param	v_acquisition_command_u8: used to set the data acquisition
- *	acquisition_command  |   operation
- *  ---------------------|-------------------------
- *         0x17          | turn on the acquisition coil
- *         -             | set direction of the coil
- *         _             | (x and y as minus(-))
- *         _             | Deferred acquisition mode
- *        0x07           | turn on the acquisition coil
- *         _             | set direction of the coil
- *         _             | (x and y as minus(-))
- *         _             | Normal acquisition mode
- *        0x11           | turn OFF the acquisition coil
- *         _             | set direction of the coil
- *         _             | (x and y as plus(+))
- *         _             | Deferred acquisition mode
- *       0x01            | turn OFF the acquisition coil
- *        _              | set direction of the coil
- *        _              | (x and y as plus(+))
- *        _              | Normal acquisition mode
- *
- *	@param	v_busy_u8 : used to get the busy flay for sensor data read
- *	@param	v_temp_u16 : used to get the temperature data
- *	@param	v_xy1y2_u16 : used to get the sensor xy1y2 data
- *	@param	v_overflow_u8 : used to get the overflow data
- *
- *
- *
-  *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_normal_measurement_data(
-u8 v_acquisition_command_u8, u8 *v_busy_u8,
-u16 *v_temp_u16, u16 *v_xy1y2_u16, u8 *v_overflow_u8);
-/*!
- *	@brief This function used for YAS532 sensor data
- *	@param	v_acquisition_command_u8	:	the value of CMDR
- *	acquisition_command  |   operation
- *  ---------------------|-------------------------
- *         0x17          | turn on the acquisition coil
- *         -             | set direction of the coil
- *         _             | (x and y as minus(-))
- *         _             | Deferred acquisition mode
- *        0x07           | turn on the acquisition coil
- *         _             | set direction of the coil
- *         _             | (x and y as minus(-))
- *         _             | Normal acquisition mode
- *        0x11           | turn OFF the acquisition coil
- *         _             | set direction of the coil
- *         _             | (x and y as plus(+))
- *         _             | Deferred acquisition mode
- *       0x01            | turn OFF the acquisition coil
- *        _              | set direction of the coil
- *        _              | (x and y as plus(+))
- *        _              | Normal acquisition mode
- *
- * @param xyz_data : the vector xyz output
- * @param v_overflow_s8 : the value of overflow
- * @param v_temp_correction_u8 : the value of temperate correction enable
- *
- *
-  *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_measurement_xyz_data(
-struct yas532_vector *xyz_data, u8 *v_overflow_s8, u8 v_temp_correction_u8,
-u8 v_acquisition_command_u8);
-/*!
- *	@brief This function used for YAS532 write data acquisition
- *	command register write
- *	@param	v_command_reg_data_u8	:	the value of data acquisition
- *	acquisition_command  |   operation
- *  ---------------------|-------------------------
- *         0x17          | turn on the acquisition coil
- *         -             | set direction of the coil
- *         _             | (x and y as minus(-))
- *         _             | Deferred acquisition mode
- *        0x07           | turn on the acquisition coil
- *         _             | set direction of the coil
- *         _             | (x and y as minus(-))
- *         _             | Normal acquisition mode
- *        0x11           | turn OFF the acquisition coil
- *         _             | set direction of the coil
- *         _             | (x and y as plus(+))
- *         _             | Deferred acquisition mode
- *       0x01            | turn OFF the acquisition coil
- *        _              | set direction of the coil
- *        _              | (x and y as plus(+))
- *        _              | Normal acquisition mode
- *
- *
- *
-  *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_acquisition_command_register(
-u8 v_command_reg_data_u8);
-/*!
- *	@brief This function used write offset of YAS532
- *
- *	@param	p_offset_s8	: The value of offset to write
- *
- *
-  *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_set_offset(
-const s8 *p_offset_s8);
-/*!
- *	@brief This function used to init the YAMAH-YAS537
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yamaha_yas537_mag_interface_init(
-void);
-/*!
- *	@brief This function used for read the
- *	YAMAHA YAS537 calibration data
- *
- *
- *	@param v_rcoil_u8 : The value of r coil
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yamaha_yas537_calib_values(
-u8 v_rcoil_u8);
-/*!
- *	@brief This function used for YAS537 write data acquisition
- *	command register write
- *	@param	v_command_reg_data_u8	:	the value of data acquisition
- *	acquisition_command  |   operation
- *  ---------------------|-------------------------
- *         0x17          | turn on the acquisition coil
- *         -             | set direction of the coil
- *         _             | (x and y as minus(-))
- *         _             | Deferred acquisition mode
- *        0x07           | turn on the acquisition coil
- *         _             | set direction of the coil
- *         _             | (x and y as minus(-))
- *         _             | Normal acquisition mode
- *        0x11           | turn OFF the acquisition coil
- *         _             | set direction of the coil
- *         _             | (x and y as plus(+))
- *         _             | Deferred acquisition mode
- *       0x01            | turn OFF the acquisition coil
- *        _              | set direction of the coil
- *        _              | (x and y as plus(+))
- *        _              | Normal acquisition mode
- *
- *
- *
-  *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas537_acquisition_command_register(
-u8 v_command_reg_data_u8);
-/*!
- *	@brief This function used for read the
- *	YAMAHA YAS537 xy1y2 data
- *
- *	@param xy1y2: The value of raw xy1y2 data
- *	@param xyz: The value of  xyz data
- *
- *
- *	@return None
- *
- *
- */
-/*JET
-static void xy1y2_to_xyz(u16 *xy1y2, s32 *xyz);*/
-/*!
- *	@brief This function used for read the
- *	YAMAHA YAS537 xy1y2 data
- *
- *	@param v_coil_stat_u8: The value of R coil status
- *	@param v_busy_u8: The value of busy status
- *	@param v_temperature_u16: The value of temperature
- *	@param xy1y2: The value of raw xy1y2 data
- *	@param v_ouflow_u8: The value of overflow
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yamaha_yas537_read_xy1y2_data(
-u8 *v_coil_stat_u8, u8 *v_busy_u8,
-u16 *v_temperature_u16, u16 *xy1y2, u8 *v_ouflow_u8);
-/*!
- *	@brief This function used for read the
- *	YAMAHA YAS537 xy1y2 data
- *
- *	@param v_ouflow_u8: The value of overflow
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yamaha_yas537_measure_xyz_data(
-u8 *v_ouflow_u8, struct yas_vector *vector_xyz);
-/*!
- *	@brief This function used for read the
- *	YAMAHA YAS537 xy1y2 data
- *
- *	@param v_ouflow_u8: The value of overflow
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-/* JET
-static BMI160_RETURN_FUNCTION_TYPE invalid_magnetic_field(
-  u16 *v_cur_u16, u16 *v_last_u16);*/
-/***************************************************/
-/**\name	FUNCTIONS FOR FIFO DATA READ */
-/***************************************************/
-/*!
- *	@brief This function used for reading the
- *	fifo data of  header less mode
- *
- *
- *
- *	@note Configure the below functions for FIFO header less mode
- *	@note 1. bmi160_set_fifo_down_gyro
- *	@note 2. bmi160_set_gyro_fifo_filter_data
- *	@note 3. bmi160_set_fifo_down_accel
- *	@note 4. bmi160_set_accel_fifo_filter_dat
- *	@note 5. bmi160_set_fifo_mag_enable
- *	@note 6. bmi160_set_fifo_accel_enable
- *	@note 7. bmi160_set_fifo_gyro_enable
- *	@note For interrupt configuration
- *	@note 1. bmi160_set_intr_fifo_full
- *	@note 2. bmi160_set_intr_fifo_wm
- *	@note 3. bmi160_set_fifo_tag_intr2_enable
- *	@note 4. bmi160_set_fifo_tag_intr1_enable
- *
- *	@note The fifo reads the whole 1024 bytes
- *	and processing the data
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_fifo_headerless_mode(
-u8 v_mag_if_u8);
-/*!
- *	@brief This function used for reading the
- *	fifo data of  header less mode for using user defined length
- *
- *
- *	@param v_fifo_user_length_u16: The value of length of fifo read data
- *
- *	@note Configure the below functions for FIFO header less mode
- *	@note 1. bmi160_set_fifo_down_gyro
- *	@note 2. bmi160_set_gyro_fifo_filter_data
- *	@note 3. bmi160_set_fifo_down_accel
- *	@note 4. bmi160_set_accel_fifo_filter_dat
- *	@note 5. bmi160_set_fifo_mag_enable
- *	@note 6. bmi160_set_fifo_accel_enable
- *	@note 7. bmi160_set_fifo_gyro_enable
- *	@note For interrupt configuration
- *	@note 1. bmi160_set_intr_fifo_full
- *	@note 2. bmi160_set_intr_fifo_wm
- *	@note 3. bmi160_set_fifo_tag_intr2_enable
- *	@note 4. bmi160_set_fifo_tag_intr1_enable
- *
- *	@note The fifo reads the whole 1024 bytes
- *	and processing the data
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE
-bmi160_read_fifo_headerless_mode_user_defined_length(
-u16 v_fifo_user_length_u16,
-struct bmi160_fifo_data_header_less_t *fifo_data, u8 v_mag_if_mag_u8);
-/*!
- *	@brief This function used for reading the
- *	fifo data of  header mode
- *
- *
- *	@note Configure the below functions for FIFO header mode
- *	@note 1. bmi160_set_fifo_down_gyro()
- *	@note 2. bmi160_set_gyro_fifo_filter_data()
- *	@note 3. bmi160_set_fifo_down_accel()
- *	@note 4. bmi160_set_accel_fifo_filter_dat()
- *	@note 5. bmi160_set_fifo_mag_enable()
- *	@note 6. bmi160_set_fifo_accel_enable()
- *	@note 7. bmi160_set_fifo_gyro_enable()
- *	@note 8. bmi160_set_fifo_header_enable()
- *	@note For interrupt configuration
- *	@note 1. bmi160_set_intr_fifo_full()
- *	@note 2. bmi160_set_intr_fifo_wm()
- *	@note 3. bmi160_set_fifo_tag_intr2_enable()
- *	@note 4. bmi160_set_fifo_tag_intr1_enable()
- *
- *	@note The fifo reads the whole 1024 bytes
- *	and processing the data
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_fifo_header_data(
-u8 v_mag_if_u8);
-/*!
- *	@brief This function used for reading the
- *	fifo data of  header mode for using user defined length
- *
- *
- *	@note Configure the below functions for FIFO header mode
- *	@note 1. bmi160_set_fifo_down_gyro()
- *	@note 2. bmi160_set_gyro_fifo_filter_data()
- *	@note 3. bmi160_set_fifo_down_accel()
- *	@note 4. bmi160_set_accel_fifo_filter_dat()
- *	@note 5. bmi160_set_fifo_mag_enable()
- *	@note 6. bmi160_set_fifo_accel_enable()
- *	@note 7. bmi160_set_fifo_gyro_enable()
- *	@note 8. bmi160_set_fifo_header_enable()
- *	@note For interrupt configuration
- *	@note 1. bmi160_set_intr_fifo_full()
- *	@note 2. bmi160_set_intr_fifo_wm()
- *	@note 3. bmi160_set_fifo_tag_intr2_enable()
- *	@note 4. bmi160_set_fifo_tag_intr1_enable()
- *
- *	@note The fifo reads the whole 1024 bytes
- *	and processing the data
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_read_fifo_header_data_user_defined_length(
-u16 v_fifo_user_length_u16, u8 v_mag_if_mag_u8,
-struct bmi160_fifo_data_header_t *fifo_header_data);
-/*!
- *	@brief This function used for reading
- *	bmi160_t structure
- *
- *  @return the reference and values of bmi160_t
- *
- *
-*/
-struct bmi160_t *bmi160_get_ptr(void);
-/*!
- *	@brief This function used for reading the compensated data of
- *	mag secondary interface xyz data
- *	@param v_mag_x_s16: The value of mag x data
- *	@param v_mag_y_s16: The value of mag y data
- *	@param v_mag_z_s16: The value of mag z data
- *	@param v_mag_r_s16: The value of mag r data
- *	@param v_mag_second_if_u8: The value of mag selection
- *
- *  value   |   v_mag_second_if_u8
- * ---------|----------------------
- *    0     |    BMM150
- *    1     |    AKM09911
- *    2     |    AKM09912
- *    3     |    YAS532
- *    4     |    YAS537
- *	@param mag_fifo_data: The value of compensated mag xyz data
- *
- *
- *  @return
- *
- *
-*/
-BMI160_RETURN_FUNCTION_TYPE bmi160_second_if_mag_compensate_xyz(
-struct bmi160_mag_fifo_data_t mag_fifo_data,
-u8 v_mag_second_if_u8);
-/*!
- *	@brief This function used for read the
- *	YAMAHA YAS537 xy1y2 data of fifo
- *
- *	@param a_xy1y2_u16: The value of xyy1 data
- *	@param v_over_flow_u8: The value of overflow
- *	@param v_rcoil_u8: The value of rcoil
- *	@param v_busy_u8: The value of busy flag
- *
- *
- *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yamaha_yas537_fifo_xyz_data(
-u16 *a_xy1y2_u16, u8 v_over_flow_u8, u8 v_rcoil_u8, u8 v_busy_u8);
-/*!
- *	@brief This function used for YAS532 sensor data
- *	@param	v_acquisition_command_u8	:	the value of CMDR
- *
- * @param v_xy1y2_u16 : the vector xyz output
- * @param v_overflow_s8 : the value of overflow
- * @param v_temp_correction_u8 : the value of temperate correction enable
- *
- *
-  *	@return results of bus communication function
- *	@retval 0 -> Success
- *	@retval -1 -> Error
- *
- *
- */
-BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_fifo_xyz_data(
-u16 *v_xy1y2_u16, u8 v_temp_correction_u8,
-s8 v_overflow_s8, u16 v_temp_u16, u8 v_busy_u8);
-
-#endif
diff --git a/src/bmi160/license.txt b/src/bmi160/license.txt
deleted file mode 100644
index f9e8cd4..0000000
--- a/src/bmi160/license.txt
+++ /dev/null
@@ -1,55 +0,0 @@
-/** \mainpage
-*
-****************************************************************************
-* Copyright (C) 2014 Bosch Sensortec GmbH
-*
-* File : bmi160.hpp
-*
-* Date : 2014/10/27
-*
-* Revision : 2.0.6 $
-*
-* Usage: Sensor Driver for BMI160 sensor
-*
-****************************************************************************
-*
-* \section License
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*
-*   Redistributions of source code must retain the above copyright
-*   notice, this list of conditions and the following disclaimer.
-*
-*   Redistributions in binary form must reproduce the above copyright
-*   notice, this list of conditions and the following disclaimer in the
-*   documentation and/or other materials provided with the distribution.
-*
-*   Neither the name of the copyright holder nor the names of the
-*   contributors may be used to endorse or promote products derived from
-*   this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
-* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
-* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDER
-* OR CONTRIBUTORS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
-* OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT NOT LIMITED TO,
-* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-* ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
-*
-* The information provided is believed to be accurate and reliable.
-* The copyright holder assumes no responsibility
-* for the consequences of use
-* of such information nor for any infringement of patents or
-* other rights of third parties which may result from its use.
-* No license is granted by implication or otherwise under any patent or
-* patent rights of the copyright holder.
-**************************************************************************/
diff --git a/src/bmm150/CMakeLists.txt b/src/bmm150/CMakeLists.txt
deleted file mode 100644
index e2ca296..0000000
--- a/src/bmm150/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME bmm150
-    DESCRIPTION "3-Axis Digital Magnetometer"
-    C_HDR bmm150.h bmm150_defs.h
-    C_SRC bmm150.c
-    CPP_HDR bmm150.hpp
-    CPP_SRC bmm150.cxx
-    FTI_SRC bmm150_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/bmm150/bmm150.c b/src/bmm150/bmm150.c
deleted file mode 100644
index bd5b903..0000000
--- a/src/bmm150/bmm150.c
+++ /dev/null
@@ -1,803 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-
-#include <unistd.h>
-#include <assert.h>
-
-#include "upm_utilities.h"
-
-#include "bmm150.h"
-
-// SPI CS on and off functions
-static void _csOn(const bmm150_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->gpioCS)
-        mraa_gpio_write(dev->gpioCS, 0);
-}
-
-static void _csOff(const bmm150_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->gpioCS)
-        mraa_gpio_write(dev->gpioCS, 1);
-}
-
-// These trimming algorithms (bmm050_bosch_compensate_*()) are taken
-// from the Bosch BMM050 reference driver code.  See license.txt.
-
-// Bosch compensation functions
-static float _bmm050_compensate_X_float(bmm150_context dev,
-                                        int16_t mag_data_x)
-{
-    assert(dev != NULL);
-
-    uint16_t data_r = dev->hall;
-    float inter_retval = 0;
-
-    if (mag_data_x != -4096	/* no overflow */
-        ) {
-        if ((data_r != 0)
-            && (dev->dig_xyz1 != 0)) {
-            inter_retval = ((((float)dev->dig_xyz1)
-                             * 16384.0 / data_r) - 16384.0);
-        } else {
-            inter_retval = 0.0f;
-            return inter_retval;
-        }
-        inter_retval = (((mag_data_x * ((((((float)dev->dig_xy2) *
-                                           (inter_retval*inter_retval /
-                                            268435456.0) +
-                                           inter_retval * ((float)dev->dig_xy1)
-                                           / 16384.0)) + 256.0) *
-                                        (((float)dev->dig_x2) + 160.0)))
-                         / 8192.0)
-                        + (((float)dev->dig_x1) *
-                           8.0)) / 16.0;
-    } else {
-        inter_retval = 0.0f;
-    }
-    return inter_retval;
-}
-
-static float _bmm050_compensate_Y_float(bmm150_context dev,
-                                        int16_t mag_data_y)
-{
-    assert(dev != NULL);
-
-    uint16_t data_r = dev->hall;
-    float inter_retval = 0;
-
-    if (mag_data_y != -4096 /* no overflow */
-        ) {
-        if ((data_r != 0)
-            && (dev->dig_xyz1 != 0)) {
-            inter_retval = ((((float)dev->dig_xyz1)
-                             * 16384.0
-                             /data_r) - 16384.0);
-        } else {
-            inter_retval = 0.0f;
-            return inter_retval;
-        }
-        inter_retval = (((mag_data_y * ((((((float)dev->dig_xy2) *
-                                           (inter_retval*inter_retval
-                                            / 268435456.0) +
-                                           inter_retval * ((float)dev->dig_xy1)
-                                           / 16384.0)) +
-                                         256.0) *
-                                        (((float)dev->dig_y2) + 160.0)))
-                         / 8192.0) +
-                        (((float)dev->dig_y1) * 8.0))
-            / 16.0;
-    } else {
-        /* overflow, set output to 0.0f */
-        inter_retval = 0.0f;
-    }
-    return inter_retval;
-}
-
-static float _bmm050_compensate_Z_float(bmm150_context dev,
-                                        int16_t mag_data_z)
-{
-    assert(dev != NULL);
-
-    uint16_t data_r = dev->hall;
-    float inter_retval = 0;
-    /* no overflow */
-    if (mag_data_z != -16384) {
-        if ((dev->dig_z2 != 0)
-            && (dev->dig_z1 != 0)
-            && (dev->dig_xyz1 != 0)
-            && (data_r != 0)) {
-            inter_retval = ((((((float)mag_data_z)-
-                               ((float)dev->dig_z4)) * 131072.0)-
-                             (((float)dev->dig_z3)*(((float)data_r)
-                                                    -((float)dev->dig_xyz1))))
-                            /((((float)dev->dig_z2)+
-                               ((float)dev->dig_z1)*((float)data_r) /
-                               32768.0) * 4.0)) / 16.0;
-        }
-    } else {
-        /* overflow, set output to 0.0f */
-        inter_retval = 0.0f;
-    }
-    return inter_retval;
-}
-
-// read trim data
-static upm_result_t _bmm150_read_trim_data(const bmm150_context dev)
-{
-    assert(dev != NULL);
-
-    int bufLen = 10;
-    uint8_t calibData[bufLen];
-
-    // 2 bytes first
-    if (bmm150_read_regs(dev, BMM150_REG_TRIM_DIG_X1, calibData, 2) != 2)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    dev->dig_x1 = (int8_t)calibData[0];
-    dev->dig_y1 = (int8_t)calibData[1];
-
-    // next block of 4 bytes
-    if (bmm150_read_regs(dev, BMM150_REG_TRIM_DIG_Z4_LSB, calibData, 4) != 4)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    dev->dig_z4 = (int16_t)((calibData[1] << 8) | calibData[0]);
-    dev->dig_x2 = (int8_t)calibData[2];
-    dev->dig_y2 = (int8_t)calibData[3];
-
-    // final block of 10 bytes
-    if (bmm150_read_regs(dev, BMM150_REG_TRIM_DIG_Z2_LSB, calibData, 10) != 10)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    dev->dig_z2 = (int16_t)((calibData[1] << 8) | calibData[0]);
-    dev->dig_z1 = (uint16_t)((calibData[3] << 8) | calibData[2]);
-    dev->dig_xyz1 = (uint16_t)((calibData[5] << 8) | calibData[4]);
-    dev->dig_z3 = (int16_t)((calibData[7] << 8) | calibData[6]);
-    dev->dig_xy2 = (int8_t)calibData[8];
-    dev->dig_xy1 = calibData[9];
-
-    return UPM_SUCCESS;
-}
-
-
-// init
-bmm150_context bmm150_init(int bus, int addr, int cs)
-{
-    bmm150_context dev =
-        (bmm150_context)malloc(sizeof(struct _bmm150_context));
-
-    if (!dev)
-        return NULL;
-
-    // zero out context
-    memset((void *)dev, 0, sizeof(struct _bmm150_context));
-
-    // make sure MRAA is initialized
-    if (mraa_init() != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed.\n", __FUNCTION__);
-        bmm150_close(dev);
-        return NULL;
-    }
-
-    if (addr < 0)
-        dev->isSPI = true;
-
-    if (dev->isSPI)
-    {
-        if (!(dev->spi = mraa_spi_init(bus)))
-        {
-            printf("%s: mraa_spi_init() failed.\n", __FUNCTION__);
-            bmm150_close(dev);
-            return NULL;
-        }
-
-        // Only create cs context if we are actually using a valid pin.
-        // A hardware controlled pin should specify cs as -1.
-        if (cs >= 0)
-        {
-            if (!(dev->gpioCS = mraa_gpio_init(cs)))
-            {
-                printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
-                bmm150_close(dev);
-                return NULL;
-            }
-            mraa_gpio_dir(dev->gpioCS, MRAA_GPIO_OUT);
-        }
-
-        mraa_spi_mode(dev->spi, MRAA_SPI_MODE0);
-        if (mraa_spi_frequency(dev->spi, 5000000))
-        {
-            printf("%s: mraa_spi_frequency() failed.\n", __FUNCTION__);
-            bmm150_close(dev);
-            return NULL;
-        }
-    }
-    else
-    {
-        // I2C
-
-        if (!(dev->i2c = mraa_i2c_init(bus)))
-        {
-            printf("%s: mraa_i2c_init() failed.\n", __FUNCTION__);
-            bmm150_close(dev);
-            return NULL;
-        }
-
-        if (mraa_i2c_address(dev->i2c, addr))
-        {
-            printf("%s: mraa_i2c_address() failed.\n", __FUNCTION__);
-            bmm150_close(dev);
-            return NULL;
-        }
-    }
-
-    // power bit must be on for chip ID to be accessible
-    bmm150_set_power_bit(dev, true);
-
-    // not really, just need to set it to something valid until
-    // bmm150_set_opmode() is called in bmm150_devinit().
-    dev->opmode = BMM150_OPERATION_MODE_SLEEP;
-
-    upm_delay_ms(50);
-
-    // check the chip id
-
-    uint8_t chipID = bmm150_get_chip_id(dev);
-
-    if (chipID != BMM150_DEFAULT_CHIPID)
-    {
-        printf("%s: invalid chip id: %02x.  Expected %02x\n",
-               __FUNCTION__, chipID, BMM150_DEFAULT_CHIPID);
-        bmm150_close(dev);
-        return NULL;
-    }
-
-    // call devinit with a default high resolution mode
-    if (bmm150_devinit(dev, BMM150_USAGE_HIGH_ACCURACY))
-    {
-        printf("%s: bmm150_devinit() failed.\n", __FUNCTION__);
-        bmm150_close(dev);
-        return NULL;
-    }
-
-    return dev;
-}
-
-void bmm150_close(bmm150_context dev)
-{
-    assert(dev != NULL);
-
-    bmm150_uninstall_isr(dev, BMM150_INTERRUPT_INT);
-    bmm150_uninstall_isr(dev, BMM150_INTERRUPT_DR);
-
-    if (dev->i2c)
-        mraa_i2c_stop(dev->i2c);
-    if (dev->spi)
-        mraa_spi_stop(dev->spi);
-    if (dev->gpioCS)
-        mraa_gpio_close(dev->gpioCS);
-
-    free(dev);
-}
-
-upm_result_t bmm150_devinit(const bmm150_context dev,
-                            BMM150_USAGE_PRESETS_T usage)
-{
-    assert(dev != NULL);
-
-    // just in case...
-    if (bmm150_set_power_bit(dev, true))
-    {
-        printf("%s: bmm150_set_power_bit() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // get trim data
-    if (_bmm150_read_trim_data(dev))
-    {
-        printf("%s: _bmm150_read_trim_data() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    if (bmm150_set_opmode(dev, BMM150_OPERATION_MODE_NORMAL))
-    {
-        printf("%s: bmm150_set_opmode() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    upm_delay_ms(50); // 50ms, in case we are waking up
-
-    if (bmm150_set_preset_mode(dev, usage))
-    {
-        printf("%s: bmm150_set_preset_mode() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // settle
-    upm_delay_ms(50);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bmm150_update(const bmm150_context dev)
-{
-    assert(dev != NULL);
-
-    // special care when in a forced mode - need to trigger a
-    // measurement, and wait for the opmode to return to OPMODE_SLEEP,
-    // then we can read the values.
-
-    if (dev->opmode == BMM150_OPERATION_MODE_FORCED)
-    {
-        // trigger measurement
-        if (bmm150_set_opmode(dev, BMM150_OPERATION_MODE_FORCED))
-        {
-            printf("%s: bmm150_set_opmode() failed.\n", __FUNCTION__);
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-
-        // opmode will return to BMM150_OPERATION_MODE_SLEEP after
-        // measurement is complete
-        do {
-            upm_delay_ms(5);
-        } while (bmm150_get_opmode(dev) == BMM150_OPERATION_MODE_FORCED);
-    }
-
-    const int bufLen = 8;
-    uint8_t buf[bufLen];
-
-    if (bmm150_read_regs(dev, BMM150_REG_MAG_X_LSB, buf, bufLen) != bufLen)
-    {
-        printf("%s: bmm150_read_regs() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // we need to get the hall data first, since it's needed for the
-    // bosch compensation functions for each of the xyz axes
-
-    dev->hall = (uint16_t)(buf[7] << 8 | (buf[6] &
-                                          (_BMM150_MAG_RHALL_LSB_LSB_MASK <<
-                                           _BMM150_MAG_RHALL_LSB_LSB_SHIFT)));
-    dev->hall /= 4;
-
-    int16_t val;
-
-    // x
-    val = (int16_t)(buf[1] << 8 | (buf[0] & (_BMM150_MAG_XY_LSB_LSB_MASK <<
-                                             _BMM150_MAG_XY_LSB_LSB_SHIFT)));
-    val /= 8;
-    dev->magX = _bmm050_compensate_X_float(dev, val);
-
-    // y
-    val = (int16_t)(buf[3] << 8 | (buf[2] & (_BMM150_MAG_XY_LSB_LSB_MASK <<
-                                             _BMM150_MAG_XY_LSB_LSB_SHIFT)));
-    val /= 8;
-    dev->magY = _bmm050_compensate_Y_float(dev, val);
-
-    // z
-    val = (int16_t)(buf[5] << 8 | (buf[4] & (_BMM150_MAG_Z_LSB_LSB_MASK <<
-                                             _BMM150_MAG_Z_LSB_LSB_SHIFT)));
-    val /= 2;
-    dev->magZ = _bmm050_compensate_Z_float(dev, val);
-
-    return UPM_SUCCESS;
-}
-
-uint8_t bmm150_read_reg(const bmm150_context dev, uint8_t reg)
-{
-    assert(dev != NULL);
-
-    if (dev->isSPI)
-    {
-        reg |= 0x80; // needed for read
-        uint8_t pkt[2] = {reg, 0};
-
-        _csOn(dev);
-        if (mraa_spi_transfer_buf(dev->spi, pkt, pkt, 2))
-        {
-            _csOff(dev);
-            printf("%s: mraa_spi_transfer_buf() failed.\n", __FUNCTION__);
-            return 0xff;
-        }
-        _csOff(dev);
-
-        return pkt[1];
-    }
-    else
-        return (uint8_t)mraa_i2c_read_byte_data(dev->i2c, reg);
-}
-
-int bmm150_read_regs(const bmm150_context dev, uint8_t reg,
-                     uint8_t *buffer, int len)
-{
-    assert(dev != NULL);
-
-    if (dev->isSPI)
-    {
-        reg |= 0x80; // needed for read
-
-        uint8_t sbuf[len + 1];
-        memset((char *)sbuf, 0, len + 1);
-        sbuf[0] = reg;
-
-        _csOn(dev);
-        if (mraa_spi_transfer_buf(dev->spi, sbuf, sbuf, len + 1))
-        {
-            _csOff(dev);
-            printf("%s: mraa_spi_transfer_buf() failed.\n", __FUNCTION__);
-            return -1;
-        }
-        _csOff(dev);
-
-        // now copy it into user buffer
-        for (int i=0; i<len; i++)
-            buffer[i] = sbuf[i + 1];
-    }
-    else
-    {
-        if (mraa_i2c_read_bytes_data(dev->i2c, reg, buffer, len) != len)
-            return -1;
-    }
-
-    return len;
-}
-
-upm_result_t bmm150_write_reg(const bmm150_context dev,
-                              uint8_t reg, uint8_t val)
-{
-    assert(dev != NULL);
-
-    if (dev->isSPI)
-    {
-        reg &= 0x7f; // mask off 0x80 for writing
-        uint8_t pkt[2] = {reg, val};
-
-        _csOn(dev);
-        if (mraa_spi_transfer_buf(dev->spi, pkt, NULL, 2))
-        {
-            _csOff(dev);
-            printf("%s: mraa_spi_transfer_buf() failed.\n",
-                   __FUNCTION__);
-
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-        _csOff(dev);
-    }
-    else
-    {
-        if (mraa_i2c_write_byte_data(dev->i2c, val, reg))
-        {
-            printf("%s: mraa_i2c_write_byte_data() failed.\n",
-                   __FUNCTION__);
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-    }
-
-    return UPM_SUCCESS;
-}
-
-uint8_t bmm150_get_chip_id(const bmm150_context dev)
-{
-    assert(dev != NULL);
-
-    return bmm150_read_reg(dev, BMM150_REG_CHIP_ID);
-}
-
-void bmm150_get_magnetometer(const bmm150_context dev,
-                             float *x, float *y, float *z)
-{
-    assert(dev != NULL);
-
-    if (x)
-        *x = dev->magX;
-
-    if (y)
-        *y = dev->magY;
-
-    if (z)
-        *z = dev->magZ;
-}
-
-upm_result_t bmm150_reset(const bmm150_context dev)
-{
-    assert(dev != NULL);
-
-    // mask off reserved bits
-    uint8_t reg =
-        (bmm150_read_reg(dev, BMM150_REG_POWER_CTRL)
-         & ~_BMM150_POWER_CTRL_RESERVED_BITS);
-
-    reg |= BMM150_POWER_CTRL_SOFT_RESET0 | BMM150_POWER_CTRL_SOFT_RESET1;
-
-    if (bmm150_write_reg(dev, BMM150_REG_POWER_CTRL, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    upm_delay(1);
-    // device will return to SLEEP mode...
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bmm150_set_output_data_rate(const bmm150_context dev,
-                                         BMM150_DATA_RATE_T odr)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = bmm150_read_reg(dev, BMM150_REG_OPMODE);
-
-    reg &= ~(_BMM150_OPMODE_DATA_RATE_MASK << _BMM150_OPMODE_DATA_RATE_SHIFT);
-    reg |= (odr << _BMM150_OPMODE_DATA_RATE_SHIFT);
-
-    if (bmm150_write_reg(dev, BMM150_REG_OPMODE, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bmm150_set_power_bit(const bmm150_context dev, bool power)
-{
-    assert(dev != NULL);
-
-    // mask off reserved bits
-    uint8_t reg =
-        (bmm150_read_reg(dev, BMM150_REG_POWER_CTRL)
-         & ~_BMM150_POWER_CTRL_RESERVED_BITS);
-
-    if (power)
-        reg |= BMM150_POWER_CTRL_POWER_CTRL_BIT;
-    else
-        reg &= ~BMM150_POWER_CTRL_POWER_CTRL_BIT;
-
-    if (bmm150_write_reg(dev, BMM150_REG_POWER_CTRL, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bmm150_set_opmode(const bmm150_context dev,
-                               BMM150_OPERATION_MODE_T opmode)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = bmm150_read_reg(dev, BMM150_REG_OPMODE);
-
-    reg &= ~(_BMM150_OPMODE_OPERATION_MODE_MASK
-             << _BMM150_OPMODE_OPERATION_MODE_SHIFT);
-    reg |= (opmode << _BMM150_OPMODE_OPERATION_MODE_SHIFT);
-
-    if (bmm150_write_reg(dev, BMM150_REG_OPMODE, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    dev->opmode = opmode;
-    return UPM_SUCCESS;
-}
-
-BMM150_OPERATION_MODE_T bmm150_get_opmode(const bmm150_context dev)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = bmm150_read_reg(dev, BMM150_REG_OPMODE);
-
-    reg &= (_BMM150_OPMODE_OPERATION_MODE_MASK
-            << _BMM150_OPMODE_OPERATION_MODE_SHIFT);
-    reg >>=  _BMM150_OPMODE_OPERATION_MODE_SHIFT;
-
-    return (BMM150_OPERATION_MODE_T)reg;
-}
-
-uint8_t bmm150_get_interrupt_enable(const bmm150_context dev)
-{
-    assert(dev != NULL);
-
-    return bmm150_read_reg(dev, BMM150_REG_INT_EN);
-}
-
-upm_result_t bmm150_set_interrupt_enable(const bmm150_context dev,
-                                         uint8_t bits)
-{
-    assert(dev != NULL);
-
-    if (bmm150_write_reg(dev, BMM150_REG_INT_EN, bits))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-uint8_t bmm150_get_interrupt_config(const bmm150_context dev)
-{
-    assert(dev != NULL);
-
-    return bmm150_read_reg(dev, BMM150_REG_INT_CONFIG);
-}
-
-upm_result_t bmm150_set_interrupt_config(const bmm150_context dev,
-                                         uint8_t bits)
-{
-    assert(dev != NULL);
-
-    if (bmm150_write_reg(dev, BMM150_REG_INT_CONFIG, bits))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-uint8_t bmm150_get_interrupt_status(const bmm150_context dev)
-{
-    assert(dev != NULL);
-
-    return bmm150_read_reg(dev, BMM150_REG_INT_STATUS);
-}
-
-upm_result_t bmm150_set_repetitions_xy(const bmm150_context dev,
-                                       uint8_t reps)
-{
-    assert(dev != NULL);
-
-    if (bmm150_write_reg(dev, BMM150_REG_REP_XY, reps))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bmm150_set_repetitions_z(const bmm150_context dev,
-                                      uint8_t reps)
-{
-    assert(dev != NULL);
-
-    if (bmm150_write_reg(dev, BMM150_REG_REP_Z, reps))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bmm150_set_preset_mode(const bmm150_context dev,
-                                    BMM150_USAGE_PRESETS_T usage)
-{
-    assert(dev != NULL);
-
-    bool error = false;
-
-    // these recommended presets come from the datasheet, Table 3,
-    // Section 4.2
-    switch (usage)
-    {
-    case BMM150_USAGE_LOW_POWER:
-        if (bmm150_set_repetitions_xy(dev, 3)
-            || bmm150_set_repetitions_z(dev, 3)
-            || bmm150_set_output_data_rate(dev, BMM150_DATA_RATE_10HZ))
-            error = true;
-
-        break;
-
-    case BMM150_USAGE_REGULAR:
-        if (bmm150_set_repetitions_xy(dev, 9)
-            || bmm150_set_repetitions_z(dev, 15)
-            || bmm150_set_output_data_rate(dev, BMM150_DATA_RATE_10HZ))
-            error = true;
-
-        break;
-
-    case BMM150_USAGE_ENHANCED_REGULAR:
-        if (bmm150_set_repetitions_xy(dev, 15)
-            || bmm150_set_repetitions_z(dev, 27)
-            || bmm150_set_output_data_rate(dev, BMM150_DATA_RATE_10HZ))
-            error = true;
-
-        break;
-
-    case BMM150_USAGE_HIGH_ACCURACY:
-        if (bmm150_set_repetitions_xy(dev, 47)
-            || bmm150_set_repetitions_z(dev, 83)
-            || bmm150_set_output_data_rate(dev, BMM150_DATA_RATE_20HZ))
-            error = true;
-
-        break;
-
-    default:
-        printf("%s: Invalid usage value passed.\n", __FUNCTION__);
-        error = true;
-    }
-
-    if (error)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bmm150_install_isr(const bmm150_context dev,
-                                BMM150_INTERRUPT_PINS_T intr, int gpio,
-                                mraa_gpio_edge_t level,
-                                void (*isr)(void *), void *arg)
-{
-    assert(dev != NULL);
-
-    // delete any existing ISR and GPIO context for this interrupt
-    bmm150_uninstall_isr(dev, intr);
-
-    mraa_gpio_context gpio_isr = NULL;
-
-    // create gpio context
-    if (!(gpio_isr = mraa_gpio_init(gpio)))
-    {
-        printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    mraa_gpio_dir(gpio_isr, MRAA_GPIO_IN);
-
-    if (mraa_gpio_isr(gpio_isr, level, isr, arg))
-    {
-        mraa_gpio_close(gpio_isr);
-        printf("%s: mraa_gpio_isr() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    switch (intr)
-    {
-    case BMM150_INTERRUPT_INT:
-        dev->gpioINT = gpio_isr;
-        break;
-
-    case BMM150_INTERRUPT_DR:
-        dev->gpioDR = gpio_isr;
-        break;
-    }
-
-    return UPM_SUCCESS;
-}
-
-void bmm150_uninstall_isr(const bmm150_context dev,
-                          BMM150_INTERRUPT_PINS_T intr)
-{
-    assert(dev != NULL);
-
-    switch (intr)
-    {
-    case BMM150_INTERRUPT_INT:
-        if (dev->gpioINT)
-        {
-            mraa_gpio_isr_exit(dev->gpioINT);
-            mraa_gpio_close(dev->gpioINT);
-            dev->gpioINT = NULL;
-        }
-        break;
-
-    case BMM150_INTERRUPT_DR:
-        if (dev->gpioDR)
-        {
-            mraa_gpio_isr_exit(dev->gpioDR);
-            mraa_gpio_close(dev->gpioDR);
-            dev->gpioDR = NULL;
-        }
-        break;
-    }
-}
diff --git a/src/bmm150/bmm150.cxx b/src/bmm150/bmm150.cxx
deleted file mode 100644
index 3cfbd59..0000000
--- a/src/bmm150/bmm150.cxx
+++ /dev/null
@@ -1,201 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016-2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <iostream>
-#include <stdexcept>
-#include <string>
-#include <string.h>
-
-#include "bmm150.hpp"
-
-using namespace upm;
-using namespace std;
-
-BMM150::BMM150(int bus, int addr, int cs) :
-    m_bmm150(bmm150_init(bus, addr, cs))
-{
-    if (!m_bmm150)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmm150_init() failed");
-}
-
-BMM150::~BMM150()
-{
-    bmm150_close(m_bmm150);
-}
-
-void BMM150::init(BMM150_USAGE_PRESETS_T usage)
-{
-    if (bmm150_devinit(m_bmm150, usage))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmm150_devinit() failed");
-}
-
-void BMM150::update()
-{
-    if (bmm150_update(m_bmm150))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmm150_update() failed");
-}
-
-uint8_t BMM150::readReg(uint8_t reg)
-{
-    return bmm150_read_reg(m_bmm150, reg);
-}
-
-int BMM150::readRegs(uint8_t reg, uint8_t *buffer, int len)
-{
-    int rv = bmm150_read_regs(m_bmm150, reg, buffer, len);
-    if (rv < 0)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmm150_read_regs() failed");
-
-    return rv;
-}
-
-void BMM150::writeReg(uint8_t reg, uint8_t val)
-{
-    if (bmm150_write_reg(m_bmm150, reg, val))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmm150_write_reg() failed");
-}
-
-uint8_t BMM150::getChipID()
-{
-    return bmm150_get_chip_id(m_bmm150);
-}
-
-void BMM150::getMagnetometer(float *x, float *y, float *z)
-{
-    bmm150_get_magnetometer(m_bmm150, x, y, z);
-}
-
-std::vector<float> BMM150::getMagnetometer()
-{
-    float v[3];
-
-    getMagnetometer(&v[0], &v[1], &v[2]);
-    return std::vector<float>(v, v+3);
-}
-
-void BMM150::reset()
-{
-    if (bmm150_reset(m_bmm150))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmm150_reset() failed");
-}
-
-void BMM150::setOutputDataRate(BMM150_DATA_RATE_T odr)
-{
-    if (bmm150_set_output_data_rate(m_bmm150, odr))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmm150_set_output_data_rate() failed");
-}
-
-void BMM150::setPowerBit(bool power)
-{
-    if (bmm150_set_power_bit(m_bmm150, power))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmm150_set_set_power_bit() failed");
-}
-
-void BMM150::setOpmode(BMM150_OPERATION_MODE_T opmode)
-{
-    if (bmm150_set_opmode(m_bmm150, opmode))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmm150_set_opmode() failed");
-}
-
-BMM150_OPERATION_MODE_T BMM150::getOpmode()
-{
-    return bmm150_get_opmode(m_bmm150);
-}
-
-uint8_t BMM150::getInterruptEnable()
-{
-    return bmm150_get_interrupt_enable(m_bmm150);
-}
-
-void BMM150::setInterruptEnable(uint8_t bits)
-{
-    if (bmm150_set_interrupt_enable(m_bmm150, bits))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmm150_set_interrupt_enable() failed");
-}
-
-uint8_t BMM150::getInterruptConfig()
-{
-    return bmm150_get_interrupt_config(m_bmm150);
-}
-
-void BMM150::setInterruptConfig(uint8_t bits)
-{
-    if (bmm150_set_interrupt_config(m_bmm150, bits))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmm150_set_interrupt_config() failed");
-}
-
-uint8_t BMM150::getInterruptStatus()
-{
-    return bmm150_get_interrupt_status(m_bmm150);
-}
-
-void BMM150::setRepetitionsXY(uint8_t reps)
-{
-    if (bmm150_set_repetitions_xy(m_bmm150, reps))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmm150_set_repetitions_xy() failed");
-}
-
-void BMM150::setRepetitionsZ(uint8_t reps)
-{
-    if (bmm150_set_repetitions_z(m_bmm150, reps))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmm150_set_repetitions_z() failed");
-}
-
-void BMM150::setPresetMode(BMM150_USAGE_PRESETS_T usage)
-{
-    if (bmm150_set_preset_mode(m_bmm150, usage))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmm150_set_preset_mode() failed");
-}
-
-void BMM150::installISR(BMM150_INTERRUPT_PINS_T intr, int gpio,
-                        mraa::Edge level,
-                        void (*isr)(void *), void *arg)
-{
-    if (bmm150_install_isr(m_bmm150, intr, gpio, (mraa_gpio_edge_t) level,
-                           isr, arg))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmm150_install_isr() failed");
-}
-
-void BMM150::uninstallISR(BMM150_INTERRUPT_PINS_T intr)
-{
-    bmm150_uninstall_isr(m_bmm150, intr);
-}
diff --git a/src/bmm150/bmm150.h b/src/bmm150/bmm150.h
deleted file mode 100644
index 4d5ec00..0000000
--- a/src/bmm150/bmm150.h
+++ /dev/null
@@ -1,374 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <unistd.h>
-#include <string.h>
-
-#include <mraa/i2c.h>
-#include <mraa/spi.h>
-#include <mraa/gpio.h>
-
-#include "upm.h"
-
-#include "bmm150_defs.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    /**
-     * @file bmm150.h
-     * @library bmm150
-     * @brief C API for the bmm150 driver
-     *
-     * @include bmm150.c
-     */
-
-    /**
-     * Device context
-     */
-    typedef struct _bmm150_context {
-        mraa_i2c_context i2c;
-        mraa_spi_context spi;
-        mraa_gpio_context gpioCS;   // SPI CS pin
-        mraa_gpio_context gpioINT;  // intr
-        mraa_gpio_context gpioDR;   // DR (Data Ready) intr
-
-        // using SPI?
-        bool isSPI;
-        BMM150_OPERATION_MODE_T opmode;
-
-        // mag data
-        float magX;
-        float magY;
-        float magZ;
-
-        // hall resistance (it is NOT futile!)
-        uint16_t hall;
-
-        // trimming data
-        int8_t dig_x1;
-        int8_t dig_y1;
-
-        int16_t dig_z4;
-        int8_t dig_x2;
-        int8_t dig_y2;
-
-        int16_t dig_z2;
-        uint16_t dig_z1;
-        uint16_t dig_xyz1;
-        int16_t dig_z3;
-        int8_t dig_xy2;
-        uint8_t dig_xy1;
-    } *bmm150_context;
-
-
-    /**
-     * BMM150 initialization.
-     *
-     * This device can support both I2C and SPI. For SPI, set the addr
-     * to -1, and specify a positive integer representing the Chip
-     * Select (CS) pin for the cs argument.  If you are using a
-     * hardware CS pin (like edison with arduino breakout), then you
-     * can connect the proper pin to the hardware CS pin on your MCU
-     * and supply -1 for cs.  The default operating mode is I2C.
-     *
-     * @param bus I2C or SPI bus to use.
-     * @param addr The address for this device, or -1 for SPI.
-     * @param cs The gpio pin to use for the SPI Chip Select.  Use -1
-     * for I2C or for SPI with a hardware controlled pin.
-     * @return The device context, or NULL if an error occurred.
-     */
-    bmm150_context bmm150_init(int bus, int addr, int cs);
-
-    /**
-     * BMM150 Destructor.
-     *
-     * @param dev The device context.
-     */
-    void bmm150_close(bmm150_context dev);
-
-    /**
-     * Update the internal stored values from sensor data.
-     *
-     * @param dev The device context.
-     * @return UPM result.
-     */
-    upm_result_t bmm150_update(const bmm150_context dev);
-
-    /**
-     * Return the chip ID.
-     *
-     * @param dev The device context.
-     * @return The chip ID.
-     */
-    uint8_t bmm150_get_chip_id(const bmm150_context dev);
-
-    /**
-     * Return magnetometer data in micro-Teslas (uT).  update() must
-     * have been called prior to calling this method.
-     *
-     * @param dev The device context.
-     * @param x Pointer to a floating point value that will have the
-     * current x component placed into it.
-     * @param y Pointer to a floating point value that will have the
-     * current y component placed into it.
-     * @param z Pointer to a floating point value that will have the
-     * current z component placed into it.
-     */
-    void bmm150_get_magnetometer(const bmm150_context dev,
-                                 float *x, float *y, float *z);
-
-    /**
-     * Initialize the device and start operation.  This function is
-     * called from the constructor so it will not typically need to be
-     * called by a user unless the device is reset.  This method will
-     * call bmm150_set_preset_mode() with the passed parameter.
-     *
-     * @param dev The device context.
-     * @param usage One of the BMM150_USAGE_PRESETS_T values.  The
-     * default is BMM150_USAGE_HIGH_ACCURACY.
-     * @return UPM result.
-     */
-    upm_result_t bmm150_devinit(const bmm150_context dev,
-                                BMM150_USAGE_PRESETS_T usage);
-
-    /**
-     * Set one of the Bosch recommended preset modes.  These modes
-     * configure the sensor for varying use cases.
-     *
-     * @param dev The device context.
-     * @param usage One of the BMM150_USAGE_PRESETS_T values.  The
-     * default set at initilaization time is
-     * BMM150_USAGE_HIGH_ACCURACY.
-     * @return UPM result.
-     */
-    upm_result_t bmm150_set_preset_mode(const bmm150_context dev,
-                                        BMM150_USAGE_PRESETS_T usage);
-
-    /**
-     * Perform a device soft-reset.  The device will be placed in
-     * SUSPEND mode afterward with all configured setting lost, so
-     * some re-initialization will be required to get data from the
-     * sensor.  Calling bmm150_devinit() will get everything running
-     * again.
-     *
-     * @param dev The device context.
-     * @return UPM result.
-     */
-    upm_result_t bmm150_reset(const bmm150_context dev);
-
-    /**
-     * Set the magnetometer Output Data Rate. See the datasheet for
-     * details.
-     *
-     * @param dev The device context.
-     * @param odr One of the BMM150_DATA_RATE_T values.
-     * @return UPM result.
-     */
-    upm_result_t bmm150_set_output_data_rate(const bmm150_context dev,
-                                             BMM150_DATA_RATE_T odr);
-
-    /**
-     * Set or clear the Power bit.  When the power bit is cleared, the
-     * device enters a deep suspend mode where only the
-     * BMM150_REG_POWER_CTRL register can be accessed.  This bit needs
-     * to be enabled for the device to operate.  See the datasheet for
-     * details.  The constructor enables this by default.  After a
-     * deep suspend mode has been entered, all configured data is lost
-     * and the device must be reconfigured (as via bmm150_devinit()).
-     *
-     * @param dev The device context.
-     * @param power True to enable the bit, false otherwise.
-     * @return UPM result.
-     */
-    upm_result_t bmm150_set_power_bit(const bmm150_context dev, bool power);
-
-    /**
-     * Set the operating mode of the device.  See the datasheet for
-     * details.
-     *
-     * @param dev The device context.
-     * @param power One of the BMM150_POWER_MODE_T values.
-     * @return UPM result.
-     */
-    upm_result_t bmm150_set_opmode(const bmm150_context dev,
-                                   BMM150_OPERATION_MODE_T opmode);
-
-    /**
-     * Get the current operating mode of the device.  See the datasheet for
-     * details.  The power bit must be one for this method to succeed.
-     *
-     * @param dev The device context.
-     * @return One of the BMM150_OPERATION_MODE_T values.
-     */
-    BMM150_OPERATION_MODE_T bmm150_get_opmode(const bmm150_context dev);
-
-    /**
-     * Return the Interrupt Enables register.  This register
-     * allows you to enable various interrupt conditions.  See the
-     * datasheet for details.
-     *
-     * @param dev The device context.
-     * @return A bitmask of BMM150_INT_EN_BITS_T bits.
-     */
-    uint8_t bmm150_get_interrupt_enable(const bmm150_context dev);
-
-    /**
-     * Set the Interrupt Enables register.  See the datasheet for
-     * details.
-     *
-     * @param dev The device context.
-     * @param bits A bitmask of BMM150_INT_EN_BITS_T bits.
-     * @return UPM result.
-     */
-    upm_result_t bmm150_set_interrupt_enable(const bmm150_context dev,
-                                             uint8_t bits);
-
-    /**
-     * Return the Interrupt Config register.  This register allows
-     * determining the electrical characteristics of the 2 interrupt
-     * pins (open-drain/push-pull and level/edge triggering) as well
-     * as other options.  See the datasheet for details.
-     *
-     * @param dev The device context.
-     * @return A bitmask of BMM150_INT_CONFIG_BITS_T bits.
-     */
-    uint8_t bmm150_get_interrupt_config(const bmm150_context dev);
-
-    /**
-     * Set the Interrupt Config register.  This register
-     * allows determining the electrical characteristics of the 2
-     * interrupt pins (open-drain/push-pull and level/edge
-     * triggering).  See the datasheet for details.
-     *
-     * @param dev The device context.
-     * @param bits A bitmask of BMM150_INT_CONFIG_BITS_T bits.
-     * @return UPM result.
-     */
-    upm_result_t bmm150_set_interrupt_config(const bmm150_context dev,
-                                             uint8_t bits);
-
-    /**
-     * Return the interrupt status register.  This register
-     * indicates which interrupts have been triggered.  See the
-     * datasheet for details.
-     *
-     * @param dev The device context.
-     * @return a bitmask of BMM150_INT_STATUS_BITS_T bits.
-     */
-    uint8_t bmm150_get_interrupt_status(const bmm150_context dev);
-
-    /**
-     * Set the repetition counter for the X and Y axes.  This allows the
-     * device to average a number of measurements for a more stable
-     * output.  See the datasheet for details.
-     *
-     * @param dev The device context.
-     * @param reps A coefficient for specifying the number of
-     * repititions to perform. (1 + 2(reps))
-     * @return UPM result.
-     */
-    upm_result_t bmm150_set_repetitions_xy(const bmm150_context dev,
-                                           uint8_t reps);
-
-    /**
-     * Set the repetition counter for the Z axis.  This allows the
-     * device to average a number of measurements for a more stable
-     * output.  See the datasheet for details.
-     *
-     * @param dev The device context.
-     * @param reps A coefficient for specifying the number of
-     * repititions to perform. (1 + (reps))
-     * @return UPM result.
-     */
-    upm_result_t bmm150_set_repetitions_z(const bmm150_context dev,
-                                          uint8_t reps);
-
-    /**
-     * Install an interrupt handler.
-     *
-     * @param dev The device context.
-     * @param intr One of the BMM150_INTERRUPT_PINS_T values
-     * specifying which interrupt pin you are installing.
-     * @param gpio GPIO pin to use as interrupt pin.
-     * @param level The interrupt trigger level (one of the
-     * mraa_gpio_edge_t values).  Make sure that you have configured
-     * the interrupt pin properly for whatever level you choose.
-     * @param isr The interrupt handler, accepting a void * argument
-     * @param arg The argument to pass the the interrupt handler.
-     * @return UPM result.
-     */
-    upm_result_t bmm150_install_isr(const bmm150_context dev,
-                                    BMM150_INTERRUPT_PINS_T intr,
-                                    int gpio, mraa_gpio_edge_t level,
-                                    void (*isr)(void *), void *arg);
-
-   /**
-     * Uninstall a previously installed interrupt handler.
-     *
-     * @param dev The device context.
-     * @param intr One of the BMM150_INTERRUPT_PINS_T values
-     * specifying which interrupt pin you are removing.
-     */
-    void bmm150_uninstall_isr(const bmm150_context dev,
-                              BMM150_INTERRUPT_PINS_T intr);
-
-    /**
-     * Read a register.
-     *
-     * @param dev The device context.
-     * @param reg The register to read.
-     * @return The value of the register.
-     */
-    uint8_t bmm150_read_reg(const bmm150_context dev, uint8_t reg);
-
-    /**
-     * Read contiguous registers into a buffer.
-     *
-     * @param dev The device context.
-     * @param buffer The buffer to store the results.
-     * @param len The number of registers to read.
-     * @return The number of bytes read, or -1 on error.
-     */
-    int bmm150_read_regs(const bmm150_context dev, uint8_t reg,
-                         uint8_t *buffer, int len);
-
-    /**
-     * Write to a register.
-     *
-     * @param dev The device context.
-     * @param reg The register to write to.
-     * @param val The value to write.
-     * @return UPM result.
-     */
-    upm_result_t bmm150_write_reg(const bmm150_context dev,
-                                  uint8_t reg, uint8_t val);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/bmm150/bmm150.hpp b/src/bmm150/bmm150.hpp
deleted file mode 100644
index 4d72195..0000000
--- a/src/bmm150/bmm150.hpp
+++ /dev/null
@@ -1,345 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016-2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <vector>
-
-#include <mraa/gpio.hpp>
-#include "bmm150.h"
-
-namespace upm {
-
-    /**
-     * @brief BMM150 3-axis Magnetometer
-     * @defgroup bmm150 libupm-bmm150
-     * @ingroup i2c spi gpio bosch compass
-     */
-
-    /**
-     * @library bmm150
-     * @sensor bmm150
-     * @comname 3-axis Geomagnetic Sensor
-     * @altname bmm050
-     * @type compass
-     * @man bosch
-     * @con i2c spi gpio
-     * @web https://www.bosch-sensortec.com/bst/products/all_products/bmm150
-     *
-     * @brief API for the BMM150 3-Axis Geomagnetic Sensor
-     *
-     * The BMM150 is a standalone geomagnetic sensor for consumer market
-     * applications. It allows measurements of the magnetic field in
-     * three perpendicular axes. Based on Bosch's proprietary FlipCore
-     * technology, performance and features of BMM150 are carefully
-     * tuned and perfectly match the demanding requirements of all
-     * 3-axis mobile applications such as electronic compass, navigation
-     * or augmented reality.
-     *
-     * An evaluation circuitry (ASIC) converts the output of the
-     * geomagnetic sensor to digital results which can be read out over
-     * the industry standard digital interfaces (SPI and I2C).
-     *
-     * Not all functionality of this chip has been implemented in this
-     * driver, however all the pieces are present to add any desired
-     * functionality.  This driver supports both I2C (default) and SPI
-     * operation.
-     *
-     * This device requires 3.3v operation.
-     *
-     * @snippet bmm150.cxx Interesting
-     */
-
-    class BMM150 {
-    public:
-        /**
-         * BMM150 constructor.
-         *
-         * This device can support both I2C and SPI. For SPI, set the addr
-         * to -1, and specify a positive integer representing the Chip
-         * Select (CS) pin for the cs argument.  If you are using a
-         * hardware CS pin (like edison with arduino breakout), then you
-         * can connect the proper pin to the hardware CS pin on your MCU
-         * and supply -1 for cs.  The default operating mode is I2C.
-         *
-         * @param bus I2C or SPI bus to use.
-         * @param addr The address for this device.  -1 for SPI.
-         * @param cs The gpio pin to use for the SPI Chip Select.  -1 for
-         * I2C or for SPI with a hardware controlled pin.
-         *
-         * @throws std::runtime_error on failure.
-         */
-        BMM150(int bus=BMM150_DEFAULT_I2C_BUS,
-               int addr=BMM150_DEFAULT_ADDR,
-               int cs=-1);
-
-        /**
-         * BMM150 Destructor.
-         */
-        ~BMM150();
-
-        /**
-         * Update the internal stored values from sensor data.
-         *
-         * @throws std::runtime_error on failure.
-         */
-        void update();
-
-        /**
-         * Return the chip ID.
-         *
-         * @return The chip ID.
-         */
-        uint8_t getChipID();
-
-        /**
-         * Return magnetometer data in micro-Teslas (uT).  update() must
-         * have been called prior to calling this method.
-         *
-         * @param x Pointer to a floating point value that will have the
-         * current x component placed into it.
-         * @param y Pointer to a floating point value that will have the
-         * current y component placed into it.
-         * @param z Pointer to a floating point value that will have the
-         * current z component placed into it.
-         */
-        void getMagnetometer(float *x, float *y, float *z);
-
-        /**
-         * Return magnetometer data in micro-Teslas (uT) in the form
-         * of a floating point vector.  update() must have been called
-         * prior to calling this method.
-         *
-         * @return A floating point vector containing x, y, and z in
-         * that order.
-         */
-        std::vector<float> getMagnetometer();
-
-        /**
-         * Initialize the device and start operation.  This function is
-         * called from the constructor so will not typically need to be
-         * called by a user unless the device is reset.  This method will
-         * call setPresetMode() with the passed parameter.
-         *
-         * @param usage One of the BMM150_USAGE_PRESETS_T values.  The
-         * default is BMM150_USAGE_HIGH_ACCURACY.
-         * @throws std::runtime_error on failure.
-         */
-        void init(BMM150_USAGE_PRESETS_T usage=BMM150_USAGE_HIGH_ACCURACY);
-
-        /**
-         * Set one of the Bosch recommended preset modes.  These modes
-         * configure the sensor for varying use cases.
-         *
-         * @param usage One of the BMM150_USAGE_PRESETS_T values.  The
-         * default is BMM150_USAGE_HIGH_ACCURACY.
-         *
-         * @throws std::runtime_error on failure.
-         */
-        void setPresetMode(BMM150_USAGE_PRESETS_T usage);
-
-        /**
-         * Perform a device soft-reset.  The device will be placed in
-         * SUSPEND mode afterward with all configured setting lost, so
-         * some re-initialization will be required to get data from the
-         * sensor.  Calling init() will get everything running again.
-         *
-         * @throws std::runtime_error on failure.
-         */
-        void reset();
-
-        /**
-         * Set the magnetometer Output Data Rate. See the datasheet for
-         * details.
-         *
-         * @param odr One of the BMM150_DATA_RATE_T values.
-         * @throws std::runtime_error on failure.
-         */
-        void setOutputDataRate(BMM150_DATA_RATE_T odr);
-
-        /**
-         * Set or clear the Power bit.  When the power bit is cleared, the
-         * device enters a deep suspend mode where only the REG_POWER_CTRL
-         * register can be accessed.  This bit needs to be enabled for the
-         * device to operate.  See the datasheet for details.  The
-         * constructor enables this by default.  After a deep suspend mode
-         * has been entered, all configured data is lost and the device
-         * must be reconfigured (as via init()).
-         *
-         * @param power true to enable the bit, false otherwise.
-         * @throws std::runtime_error on failure.
-         */
-        void setPowerBit(bool power);
-
-        /**
-         * Set the operating mode of the device.  See the datasheet for
-         * details.
-         *
-         * @param opmode One of the BMM150_OPERATION_MODE_T values.
-         * @throws std::runtime_error on failure.
-         */
-        void setOpmode(BMM150_OPERATION_MODE_T opmode);
-
-        /**
-         * Get the current operating mode of the device.  See the datasheet for
-         * details.  The power bit must be one for this method to succeed.
-         *
-         * @return One of the BMM150_OPERATION_MODE_T values.
-         */
-        BMM150_OPERATION_MODE_T getOpmode();
-
-        /**
-         * Return the Interrupt Enables register.  This register
-         * allows you to enable various interrupt conditions.  See the
-         * datasheet for details.
-         *
-         * @return A bitmask of BMM150_INT_EN_BITS_T bits.
-         */
-        uint8_t getInterruptEnable();
-
-        /**
-         * Set the Interrupt Enables register.  See the datasheet for
-         * details.
-         *
-         * @param bits A bitmask of BMM150_INT_EN_BITS_T bits.
-         * @throws std::runtime_error on failure.
-         */
-        void setInterruptEnable(uint8_t bits);
-
-        /**
-         * Return the Interrupt Config register.  This register allows
-         * determining the electrical characteristics of the 2 interrupt
-         * pins (open-drain/push-pull and level/edge triggering) as well
-         * as other options.  See the datasheet for details.
-         *
-         * @return A bitmask of BMM150_INT_CONFIG_BITS_T bits.
-         */
-        uint8_t getInterruptConfig();
-
-        /**
-         * Set the Interrupt Config register.  This register
-         * allows determining the electrical characteristics of the 2
-         * interrupt pins (open-drain/push-pull and level/edge
-         * triggering).  See the datasheet for details.
-         *
-         * @param bits A bitmask of BMM150_INT_CONFIG_BITS_T bits.
-         * @throws std::runtime_error on failure.
-         */
-        void setInterruptConfig(uint8_t bits);
-
-        /**
-         * Return the interrupt status register.  This register
-         * indicates which interrupts have been triggered.  See the
-         * datasheet for details.
-         *
-         * @return a bitmask of BMM150_INT_STATUS_BITS_T bits.
-         */
-        uint8_t getInterruptStatus();
-
-        /**
-         * Set the repetition counter for the X and Y axes.  This allows the
-         * device to average a number of measurements for a more stable
-         * output.  See the datasheet for details.
-         *
-         * @param reps A coefficient for specifying the number of
-         * repititions to perform. (1 + 2(reps))
-         * @throws std::runtime_error on failure.
-         */
-        void setRepetitionsXY(uint8_t reps);
-
-        /**
-         * Set the repetition counter for the Z axis.  This allows the
-         * device to average a number of measurements for a more stable
-         * output.  See the datasheet for details.
-         *
-         * @param reps A coefficient for specifying the number of
-         * repititions to perform. (1 + (reps))
-         * @throws std::runtime_error on failure.
-         */
-        void setRepetitionsZ(uint8_t reps);
-
-        /**
-         * Install an interrupt handler.
-         *
-         * @param intr One of the BMM150_INTERRUPT_PINS_T values
-         * specifying which interrupt pin you are installing.
-         * @param gpio GPIO pin to use as interrupt pin.
-         * @param level The interrupt trigger level (one of mraa::Edge
-         * values).  Make sure that you have configured the interrupt pin
-         * properly for whatever level you choose.
-         * @param isr The interrupt handler, accepting a void * argument.
-         * @param arg The argument to pass the the interrupt handler.
-         * @throws std::runtime_error on failure.
-         */
-        void installISR(BMM150_INTERRUPT_PINS_T intr, int gpio,
-                        mraa::Edge level,
-                        void (*isr)(void *), void *arg);
-
-        /**
-         * Uninstall a previously installed interrupt handler.
-         *
-         * @param intr One of the BMM150_INTERRUPT_PINS_T values
-         * specifying which interrupt pin you are removing.
-         */
-        void uninstallISR(BMM150_INTERRUPT_PINS_T intr);
-
-        /**
-         * Read a register.
-         *
-         * @param reg The register to read.
-         * @return The value of the register.
-         */
-        uint8_t readReg(uint8_t reg);
-
-        /**
-         * Read contiguous registers into a buffer.
-         *
-         * @param buffer The buffer to store the results.
-         * @param len The number of registers to read.
-         * @return The number of bytes read.
-         * @throws std::runtime_error on failure.
-         */
-        int readRegs(uint8_t reg, uint8_t *buffer, int len);
-
-        /**
-         * Write to a register.
-         *
-         * @param reg The register to write to.
-         * @param val The value to write.
-         * @throws std::runtime_error on failure.
-         */
-        void writeReg(uint8_t reg, uint8_t val);
-
-    protected:
-        bmm150_context m_bmm150;
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        BMM150(const BMM150&) = delete;
-        BMM150 &operator=(const BMM150&) = delete;
-
-    };
-}
diff --git a/src/bmm150/bmm150.i b/src/bmm150/bmm150.i
deleted file mode 100644
index ef364d9..0000000
--- a/src/bmm150/bmm150.i
+++ /dev/null
@@ -1,57 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "../upm_javastdvector.i"
-
-%ignore getMagnetometer(float *, float *, float *);
-
-%typemap(javaimports) SWIGTYPE %{
-import java.util.AbstractList;
-import java.lang.Float;
-%}
-
-%typemap(javaout) SWIGTYPE {
-    return new $&javaclassname($jnicall, true);
-}
-%typemap(javaout) std::vector<float> {
-    return (AbstractList<Float>)(new $&javaclassname($jnicall, true));
-}
-%typemap(jstype) std::vector<float> "AbstractList<Float>"
-
-%template(floatVector) std::vector<float>;
-
-%ignore installISR (BMM150_INTERRUPT_PINS_T , int ,  mraa::Edge ,  void *, void *);
-
-%define INTERRUPT BMM150_INTERRUPT_PINS_T
-%enddef
-JAVA_ADD_INSTALLISR_INTERRUPT(upm::BMM150)
-
-JAVA_JNI_LOADLIBRARY(javaupm_bmm150)
-#endif
-/* END Java syntax */
-
-/* BEGIN Javascript syntax  ------------------------------------------------- */
-#ifdef SWIGJAVASCRIPT
-%include "../upm_vectortypes.i"
-%pointer_functions(int, intp);
-%pointer_functions(float, floatp);
-#endif
-/* END Javascript syntax */
-
-/* BEGIN Python syntax  ----------------------------------------------------- */
-#ifdef SWIGPYTHON
-%include "../upm_vectortypes.i"
-%pointer_functions(int, intp);
-%pointer_functions(float, floatp);
-#endif
-/* END Python syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "bmm150_defs.h"
-#include "bmm150.hpp"
-%}
-%include "bmm150_defs.h"
-%include "bmm150.hpp"
-/* END Common SWIG syntax */
diff --git a/src/bmm150/bmm150.json b/src/bmm150/bmm150.json
deleted file mode 100644
index c715c88..0000000
--- a/src/bmm150/bmm150.json
+++ /dev/null
@@ -1,46 +0,0 @@
-{
-    "Library": "bmx050",
-    "Description": "Bosch 3-axis Magnetometer",
-    "Sensor Class":
-    {
-        "BMM150":
-        {
-            "Name": "3-axis Geomagnetic Sensor",
-            "Description": "The BMM150 is a standalone geomagnetic sensor for consumer market applications. It allows measurements of the magnetic field in three perpendicular axes. Based on Bosch's proprietary FlipCore technology, performance and features of BMM150 are carefully tuned and perfectly match the demanding requirements of all 3-axis mobile applications such as electronic compass, navigation or augmented reality. An evaluation circuitry (ASIC) converts the output of the geomagnetic sensor to digital results which can be read out over the industry standard digital interfaces (SPI and I2C). Not all functionality of this chip has been implemented in this driver, however all the pieces are present to add any desired functionality.  This driver supports both I2C (default) and SPI operation.",
-            "Aliases": ["bme280"],
-            "Categories": ["pressure", "humidity", "temperature"],
-            "Connections": ["gpio", "i2c", "spi"],
-            "Project Type": ["prototyping", "industrial"],
-            "Manufacturers": ["bosch"],
-            "Kits": [],
-            "Examples":
-            {
-                "Java": ["BMM150_Example.java"],
-                "Python": ["bmm150.py"],
-                "Node.js": ["bmm150.js"],
-                "C++": ["bmm150.cxx"],
-                "C": ["bmm150.c"]
-            },
-            "Specifications":
-            {
-                "Vdd": {"unit": "v", "low" : 1.62, "high": 3.6},
-                "Temperature Range": {"unit": "degC", "low" : -40, "high": 85},
-                "Sensing Range": {"unit": "uT ()", "low": 1300, "high": 2500}
-            },
-            "Platforms":
-            {
-                "Intel Joule Module":
-                {
-                    "Notes": ["Requires pull-up resistors with carrier board"],
-                    "Images": [""]
-                }
-            },
-            "Urls" :
-            {
-                "Product Pages": ["https://www.bosch-sensortec.com/bst/products/all_products/bmm150"],
-                "Datasheets": ["https://ae-bst.resource.bosch.com/media/_tech/media/datasheets/BST-BMM150-DS001-01.pdf"],
-                "Schematics": []
-            }
-        }
-    }
-}
diff --git a/src/bmm150/bmm150_defs.h b/src/bmm150/bmm150_defs.h
deleted file mode 100644
index 76db9f1..0000000
--- a/src/bmm150/bmm150_defs.h
+++ /dev/null
@@ -1,272 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define BMM150_DEFAULT_I2C_BUS 0
-#define BMM150_DEFAULT_SPI_BUS 0
-#define BMM150_DEFAULT_ADDR 0x10
-
-#define BMM150_DEFAULT_CHIPID 0x32
-
-    // NOTE: Reserved registers must not be written into.  Reading
-    // from them may return indeterminate values.  Registers
-    // containing reserved bitfields must be written as 0.  Reading
-    // reserved bitfields may return indeterminate values.
-
-    /**
-     * BMM150 registers
-     */
-    typedef enum {
-        BMM150_REG_CHIP_ID                      = 0x40,
-
-        // 0x41 reserved
-
-        BMM150_REG_MAG_X_LSB                    = 0x42,
-        BMM150_REG_MAG_X_MSB                    = 0x43,
-        BMM150_REG_MAG_Y_LSB                    = 0x44,
-        BMM150_REG_MAG_Y_MSB                    = 0x45,
-        BMM150_REG_MAG_Z_LSB                    = 0x46,
-        BMM150_REG_MAG_Z_MSB                    = 0x47,
-
-        BMM150_REG_RHALL_LSB                    = 0x48,
-        BMM150_REG_RHALL_MSB                    = 0x49,
-
-        BMM150_REG_INT_STATUS                   = 0x4a,
-
-        BMM150_REG_POWER_CTRL                   = 0x4b,
-
-        BMM150_REG_OPMODE                       = 0x4c,
-
-        BMM150_REG_INT_EN                       = 0x4d,
-        BMM150_REG_INT_CONFIG                   = 0x4e,
-
-        BMM150_REG_LOW_THRES                    = 0x4f,
-        BMM150_REG_HIGH_THRES                   = 0x50,
-
-        BMM150_REG_REP_XY                       = 0x51,
-        BMM150_REG_REP_Z                        = 0x52,
-
-        // 0x53-0x71 reserved (mostly)
-
-        // TRIM registers from Bosch BMM050 driver
-        BMM150_REG_TRIM_DIG_X1                  = 0x5d,
-        BMM150_REG_TRIM_DIG_Y1                  = 0x5e,
-
-        BMM150_REG_TRIM_DIG_Z4_LSB              = 0x62,
-        BMM150_REG_TRIM_DIG_Z4_MSB              = 0x63,
-        BMM150_REG_TRIM_DIG_X2                  = 0x64,
-        BMM150_REG_TRIM_DIG_Y2                  = 0x65,
-
-        BMM150_REG_TRIM_DIG_Z2_LSB              = 0x68,
-        BMM150_REG_TRIM_DIG_Z2_MSB              = 0x69,
-        BMM150_REG_TRIM_DIG_Z1_LSB              = 0x6a,
-        BMM150_REG_TRIM_DIG_Z1_MSB              = 0x6b,
-        BMM150_REG_TRIM_DIG_XYZ1_LSB            = 0x6c,
-        BMM150_REG_TRIM_DIG_XYZ1_MSB            = 0x6d,
-        BMM150_REG_TRIM_DIG_Z3_LSB              = 0x6e,
-        BMM150_REG_TRIM_DIG_Z3_MSB              = 0x6f,
-        BMM150_REG_TRIM_DIG_XY2                 = 0x70,
-        BMM150_REG_TRIM_DIG_XY1                 = 0x71
-    } BMM150_REGS_T;
-
-    /**
-     * REG_MAG_XY_LSB bits (for X and Y mag data LSB's only)
-     */
-    typedef enum {
-        _BMM150_MAG_XY_LSB_RESERVED_BITS        = 0x02 | 0x04,
-
-        BMM150_MAG_XY_LSB_SELFTEST_XY           = 0x01,
-
-        BMM150_MAG_XY_LSB_LSB0                  = 0x08,
-        BMM150_MAG_XY_LSB_LSB1                  = 0x10,
-        BMM150_MAG_XY_LSB_LSB2                  = 0x20,
-        BMM150_MAG_XY_LSB_LSB3                  = 0x40,
-        BMM150_MAG_XY_LSB_LSB4                  = 0x80,
-        _BMM150_MAG_XY_LSB_LSB_MASK             = 31,
-        _BMM150_MAG_XY_LSB_LSB_SHIFT            = 3
-    } BMM150_MAG_XY_LSB_BITS_T;
-
-    /**
-     * REG_MAG_Z_LSB bits (for Z LSB only)
-     */
-    typedef enum {
-        BMM150_MAG_Z_LSB_SELFTEST_Z             = 0x01,
-
-        BMM150_MAG_Z_LSB_LSB0                   = 0x02,
-        BMM150_MAG_Z_LSB_LSB1                   = 0x04,
-        BMM150_MAG_Z_LSB_LSB2                   = 0x08,
-        BMM150_MAG_Z_LSB_LSB3                   = 0x10,
-        BMM150_MAG_Z_LSB_LSB4                   = 0x20,
-        BMM150_MAG_Z_LSB_LSB5                   = 0x40,
-        BMM150_MAG_Z_LSB_LSB6                   = 0x80,
-        _BMM150_MAG_Z_LSB_LSB_MASK              = 127,
-        _BMM150_MAG_Z_LSB_LSB_SHIFT             = 1
-    } MAG_Z_LSB_BITS_T;
-
-    /**
-     * REG_MAG_RHALL_LSB bits (for RHALL LSB only)
-     */
-    typedef enum {
-        _BMM150_MAG_RHALL_LSB_RESERVED_BITS     = 0x02,
-
-        BMM150_MAG_RHALL_LSB_DATA_READY_STATUS  = 0x01,
-
-        BMM150_MAG_RHALL_LSB_LSB0               = 0x04,
-        BMM150_MAG_RHALL_LSB_LSB1               = 0x08,
-        BMM150_MAG_RHALL_LSB_LSB2               = 0x10,
-        BMM150_MAG_RHALL_LSB_LSB3               = 0x20,
-        BMM150_MAG_RHALL_LSB_LSB4               = 0x40,
-        BMM150_MAG_RHALL_LSB_LSB5               = 0x80,
-        _BMM150_MAG_RHALL_LSB_LSB_MASK          = 63,
-        _BMM150_MAG_RHALL_LSB_LSB_SHIFT         = 2
-    } BMM150_MAG_RHALL_LSB_BITS_T;
-
-    /**
-     * REG_INT_STATUS bits
-     */
-    typedef enum {
-        BMM150_INT_STATUS_LOW_INT_X             = 0x01,
-        BMM150_INT_STATUS_LOW_INT_Y             = 0x02,
-        BMM150_INT_STATUS_LOW_INT_Z             = 0x04,
-        BMM150_INT_STATUS_HIGH_INT_X            = 0x08,
-        BMM150_INT_STATUS_HIGH_INT_Y            = 0x10,
-        BMM150_INT_STATUS_HIGH_INT_Z            = 0x20,
-        BMM150_INT_STATUS_OVERFLOW              = 0x40,
-        BMM150_INT_STATUS_DATA_OVERRUN          = 0x80
-    } BMM150_INT_STATUS_BITS_T;
-
-    /**
-     * REG_POWER_CTRL bits
-     */
-    typedef enum {
-        _BMM150_POWER_CTRL_RESERVED_BITS        = 0x40 | 0x20 | 0x10 | 0x08,
-
-        BMM150_POWER_CTRL_POWER_CTRL_BIT        = 0x01,
-        BMM150_POWER_CTRL_SOFT_RESET0           = 0x02,
-        BMM150_POWER_CTRL_SPI3EN                = 0x04, // not supported
-
-        BMM150_POWER_CTRL_SOFT_RESET1           = 0x80
-    } POWER_CTRL_BITS_T;
-
-    /**
-     * REG_OPMODE bits
-     */
-    typedef enum {
-        BMM150_OPMODE_SELFTTEST                 = 0x01,
-
-        BMM150_OPMODE_OPERATION_MODE0           = 0x02,
-        BMM150_OPMODE_OPERATION_MODE1           = 0x04,
-        _BMM150_OPMODE_OPERATION_MODE_MASK      = 3,
-        _BMM150_OPMODE_OPERATION_MODE_SHIFT     = 1,
-
-        BMM150_OPMODE_DATA_RATE0                = 0x08,
-        BMM150_OPMODE_DATA_RATE1                = 0x10,
-        BMM150_OPMODE_DATA_RATE2                = 0x20,
-        _BMM150_OPMODE_DATA_RATE_MASK           = 7,
-        _BMM150_OPMODE_DATA_RATE_SHIFT          = 3,
-
-        BMM150_OPMODE_ADV_SELFTEST0             = 0x40,
-        BMM150_OPMODE_ADV_SELFTEST1             = 0x80,
-        _BMM150_OPMODE_ADV_SELFTEST_MASK        = 3,
-        _BMM150_OPMODE_ADV_SELFTEST_SHIFT       = 6
-    } OPMODE_BITS_T;
-
-    /**
-     * OPMODE_OPERATION_MODE values
-     */
-    typedef enum {
-        BMM150_OPERATION_MODE_NORMAL            = 0,
-        BMM150_OPERATION_MODE_FORCED            = 1,
-        BMM150_OPERATION_MODE_SLEEP             = 3
-    } BMM150_OPERATION_MODE_T;
-
-    /**
-     * OPMODE_DATA_RATE values
-     */
-    typedef enum {
-        BMM150_DATA_RATE_10HZ                   = 0,
-        BMM150_DATA_RATE_2HZ                    = 1,
-        BMM150_DATA_RATE_6HZ                    = 2,
-        BMM150_DATA_RATE_8HZ                    = 3,
-        BMM150_DATA_RATE_15HZ                   = 4,
-        BMM150_DATA_RATE_20HZ                   = 5,
-        BMM150_DATA_RATE_25HZ                   = 6,
-        BMM150_DATA_RATE_30HZ                   = 7
-    } BMM150_DATA_RATE_T;
-
-    /**
-     * REG_INT_EN bits
-     */
-    typedef enum {
-        BMM150_INT_EN_LOW_INT_X_EN              = 0x01,
-        BMM150_INT_EN_LOW_INT_Y_EN              = 0x02,
-        BMM150_INT_EN_LOW_INT_Z_EN              = 0x04,
-        BMM150_INT_EN_HIGH_INT_X_EN             = 0x08,
-        BMM150_INT_EN_HIGH_INT_Y_EN             = 0x10,
-        BMM150_INT_EN_HIGH_INT_Z_EN             = 0x20,
-        BMM150_INT_EN_OVERFLOW_INT_EN           = 0x40,
-        BMM150_INT_EN_DATA_OVERRUN_INT_EN       = 0x80
-    } BMM150_INT_EN_T;
-
-    /**
-     * REG_INT_CONFIG bits
-     */
-    typedef enum {
-        BMM150_INT_CONFIG_INT_POLARITY          = 0x01,
-        BMM150_INT_CONFIG_INT_LATCH             = 0x02,
-        BMM150_INT_CONFIG_DR_POLARITY           = 0x04,
-        BMM150_INT_CONFIG_CHANNEL_X             = 0x08,
-        BMM150_INT_CONFIG_CHANNEL_Y             = 0x10,
-        BMM150_INT_CONFIG_CHANNEL_Z             = 0x20,
-        BMM150_INT_CONFIG_INT_PIN_EN            = 0x40,
-        BMM150_INT_CONFIG_DR_PIN_EN             = 0x80
-    } BMM150_INT_CONFIG_T;
-
-    /**
-     * Interrupt selection for installISR() and uninstallISR()
-     */
-    typedef enum {
-        BMM150_INTERRUPT_INT,
-        BMM150_INTERRUPT_DR
-    } BMM150_INTERRUPT_PINS_T;
-
-    /**
-     * Bosch recommended usage preset modes
-     */
-    typedef enum {
-        BMM150_USAGE_LOW_POWER,
-        BMM150_USAGE_REGULAR,
-        BMM150_USAGE_ENHANCED_REGULAR,
-        BMM150_USAGE_HIGH_ACCURACY
-    } BMM150_USAGE_PRESETS_T;
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/bmm150/bmm150_fti.c b/src/bmm150/bmm150_fti.c
deleted file mode 100644
index e1a4ae7..0000000
--- a/src/bmm150/bmm150_fti.c
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "bmm150.h"
-#include "upm_fti.h"
-
-/**
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_bmm150_name[] = "BMM150";
-const char upm_bmm150_description[] = "Triple Axis Digital Magnetometer";
-const upm_protocol_t upm_bmm150_protocol[] = {UPM_I2C, UPM_SPI, UPM_GPIO};
-const upm_sensor_t upm_bmm150_category[] = {UPM_MAGNETOMETER};
-
-// forward declarations
-const void* upm_bmm150_get_ft(upm_sensor_t sensor_type);
-void* upm_bmm150_init_name();
-void upm_bmm150_close(void *dev);
-upm_result_t upm_bmm150_get_value(void *dev, float *value);
-
-const upm_sensor_descriptor_t upm_bmm150_get_descriptor()
-{
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_bmm150_name;
-    usd.description = upm_bmm150_description;
-    usd.protocol_size = 3;
-    usd.protocol = upm_bmm150_protocol;
-    usd.category_size = 1;
-    usd.category = upm_bmm150_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = &upm_bmm150_init_name,
-    .upm_sensor_close = &upm_bmm150_close,
-};
-
-static const upm_magnetometer_ft mft =
-{
-    .upm_magnetometer_get_value = &upm_bmm150_get_value
-};
-
-const void* upm_bmm150_get_ft(upm_sensor_t sensor_type)
-{
-  switch(sensor_type)
-    {
-    case UPM_SENSOR:
-      return &ft;
-
-    case UPM_MAGNETOMETER:
-      return &mft;
-
-    default:
-      return NULL;
-    }
-}
-
-void* upm_bmm150_init_name()
-{
-    return NULL;
-}
-
-
-void upm_bmm150_close(void *dev)
-{
-    bmm150_close((bmm150_context)dev);
-}
-
-upm_result_t upm_bmm150_get_value(void *dev, float *value)
-{
-    if (bmm150_update((bmm150_context)dev))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    float x, y, z;
-
-    bmm150_get_magnetometer(dev, &x, &y, &z);
-
-    value[0] = x;
-    value[1] = y;
-    value[2] = z;
-
-    return UPM_SUCCESS;
-}
diff --git a/src/bmm150/license.txt b/src/bmm150/license.txt
deleted file mode 100644
index 07a89c5..0000000
--- a/src/bmm150/license.txt
+++ /dev/null
@@ -1,56 +0,0 @@
-// The trimming algorithms used (bmm050_bosch_compensate_*()) were
-// taken from the Bosch BMM050 driver code
-
-/****************************************************************************
-* Copyright (C) 2015 - 2016 Bosch Sensortec GmbH
-*
-* File : bmm050.h
-*
-* Date : 2016/03/17
-*
-* Revision : 2.0.5 $
-*
-* Usage: Sensor Driver for BMM050 and BMM150 sensor
-*
-****************************************************************************
-*
-* section License
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*
-*   Redistributions of source code must retain the above copyright
-*   notice, this list of conditions and the following disclaimer.
-*
-*   Redistributions in binary form must reproduce the above copyright
-*   notice, this list of conditions and the following disclaimer in the
-*   documentation and/or other materials provided with the distribution.
-*
-*   Neither the name of the copyright holder nor the names of the
-*   contributors may be used to endorse or promote products derived from
-*   this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
-* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
-* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDER
-* OR CONTRIBUTORS BE LIABLE FOR ANY
-* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
-* OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT NOT LIMITED TO,
-* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-* ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
-*
-* The information provided is believed to be accurate and reliable.
-* The copyright holder assumes no responsibility
-* for the consequences of use
-* of such information nor for any infringement of patents or
-* other rights of third parties which may result from its use.
-* No license is granted by implication or otherwise under any patent or
-* patent rights of the copyright holder.
-**************************************************************************/
diff --git a/src/bmpx8x/CMakeLists.txt b/src/bmpx8x/CMakeLists.txt
deleted file mode 100644
index ea36351..0000000
--- a/src/bmpx8x/CMakeLists.txt
+++ /dev/null
@@ -1,10 +0,0 @@
-upm_mixed_module_init (NAME bmpx8x
-    DESCRIPTION "Pressure and temperature sensor"
-    C_HDR bmpx8x.h bmpx8x_defs.h
-    C_SRC bmpx8x.c
-    CPP_HDR bmpx8x.hpp
-    CPP_SRC bmpx8x.cxx
-    FTI_SRC bmpx8x_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa interfaces utilities-c)
-target_link_libraries(${libnamec} m)
diff --git a/src/bmpx8x/bmpx8x.c b/src/bmpx8x/bmpx8x.c
deleted file mode 100644
index 71ad6a7..0000000
--- a/src/bmpx8x/bmpx8x.c
+++ /dev/null
@@ -1,360 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * This driver was rewritten based on the original driver written by:
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <assert.h>
-
-#include "upm_utilities.h"
-#include "upm_math.h"
-
-#include "bmpx8x.h"
-
-// UT is uncompensated temperature
-static int32_t _bmpx8x_computeB5(const bmpx8x_context dev, int32_t UT)
-{
-    assert(dev != NULL);
-
-    int32_t X1 = (UT - (int32_t)dev->ac6) * ((int32_t)dev->ac5) >> 15;
-    int32_t X2 = ((int32_t)dev->mc << 11) / (X1+(int32_t)dev->md);
-
-    return X1 + X2;
-}
-
-static upm_result_t _bmpx8x_read_calibration_data(const bmpx8x_context dev)
-{
-    assert(dev != NULL);
-
-    const int dataLen = 22;
-    uint8_t calData[dataLen];
-
-    if (bmpx8x_read_regs(dev, BMPX8X_CAL_AC1, calData, dataLen) != dataLen)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    dev->ac1 = (int16_t)( (calData[0] << 8) | calData[1] );
-    dev->ac2 = (int16_t)( (calData[2] << 8) | calData[3] );
-    dev->ac3 = (int16_t)( (calData[4] << 8) | calData[5] );
-    dev->ac4 = (uint16_t)( (calData[6] << 8) | calData[7] );
-    dev->ac5 = (uint16_t)( (calData[8] << 8) | calData[9] );
-    dev->ac6 = (uint16_t)( (calData[10] << 8) | calData[11] );
-
-    dev->b1 = (int16_t)( (calData[12] << 8) | calData[13] );
-    dev->b2 = (int16_t)( (calData[14] << 8) | calData[15] );
-
-    dev->mb = (int16_t)( (calData[16] << 8) | calData[17] );
-    dev->mc = (int16_t)( (calData[18] << 8) | calData[19] );
-    dev->md = (int16_t)( (calData[20] << 8) | calData[21] );
-
-    return UPM_SUCCESS;
-}
-
-// init
-bmpx8x_context bmpx8x_init(int bus, int addr)
-{
-    bmpx8x_context dev =
-        (bmpx8x_context)malloc(sizeof(struct _bmpx8x_context));
-
-    if (!dev)
-        return NULL;
-
-    // zero out context
-    memset((void *)dev, 0, sizeof(struct _bmpx8x_context));
-
-    // make sure MRAA is initialized
-    if (mraa_init() != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed.\n", __FUNCTION__);
-        bmpx8x_close(dev);
-        return NULL;
-    }
-
-    if (!(dev->i2c = mraa_i2c_init(bus)))
-    {
-        printf("%s: mraa_i2c_init() failed.\n", __FUNCTION__);
-        bmpx8x_close(dev);
-        return NULL;
-    }
-
-    if (mraa_i2c_address(dev->i2c, addr))
-    {
-        printf("%s: mraa_i2c_address() failed.\n", __FUNCTION__);
-        bmpx8x_close(dev);
-        return NULL;
-    }
-
-    // check the chip id
-
-    uint8_t chipID = bmpx8x_get_chip_id(dev);
-
-    if (chipID != BMPX8X_DEFAULT_CHIPID)
-    {
-        printf("%s: invalid chip id: %02x.  Expected %02x\n",
-               __FUNCTION__, chipID, BMPX8X_DEFAULT_CHIPID);
-        bmpx8x_close(dev);
-        return NULL;
-    }
-
-    // call devinit with a default ultrahigh resolution mode
-    if (bmpx8x_devinit(dev, BMPX8X_OSS_ULTRAHIGHRES))
-    {
-        printf("%s: bmpx8x_devinit() failed.\n", __FUNCTION__);
-        bmpx8x_close(dev);
-        return NULL;
-    }
-
-    return dev;
-}
-
-void bmpx8x_close(bmpx8x_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->i2c)
-        mraa_i2c_stop(dev->i2c);
-
-    free(dev);
-}
-
-upm_result_t bmpx8x_devinit(const bmpx8x_context dev,
-                            BMPX8X_OSS_T oss)
-{
-    assert(dev != NULL);
-
-    // first read calibration data
-    if (_bmpx8x_read_calibration_data(dev))
-    {
-        printf("%s: _bmpx8x_read_calibration_data() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // now set our oversampling mode
-    bmpx8x_set_oversampling(dev, oss);
-
-    return UPM_SUCCESS;
-}
-
-uint8_t bmpx8x_get_chip_id(const bmpx8x_context dev)
-{
-    assert(dev != NULL);
-
-    return bmpx8x_read_reg(dev, BMPX8X_CHIP_ID);
-}
-
-upm_result_t bmpx8x_reset(const bmpx8x_context dev)
-{
-    assert(dev != NULL);
-
-    if (bmpx8x_write_reg(dev, BMPX8X_RESET, BMPX8X_RESET_BYTE))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    upm_delay(1);
-
-    return UPM_SUCCESS;
-}
-
-void bmpx8x_set_oversampling(const bmpx8x_context dev,
-                             BMPX8X_OSS_T oss)
-{
-    assert(dev != NULL);
-
-    dev->oversampling = oss;
-}
-
-upm_result_t bmpx8x_update(const bmpx8x_context dev)
-{
-    assert(dev != NULL);
-
-    const int maxLen = 3; // maximum number of bytes we will read
-    uint8_t buffer[maxLen];
-
-    // first we need to read the temperature
-
-    // send the measurement command, and sleep the required time
-    // before reading it
-
-    if (bmpx8x_write_reg(dev, BMPX8X_CTRL_MEAS, BMPX8X_CMD_READ_TEMP))
-    {
-        printf("%s: bmpx8x_write_reg(tempcmd) failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-    upm_delay_ms(5);
-
-    if (bmpx8x_read_regs(dev, BMPX8X_OUTDATA_MSB, buffer, maxLen) != maxLen)
-    {
-        printf("%s: bmpx8x_read_regs(temp) failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // we only need the first 2 bytes, uncompensated temperature
-    int32_t UT = (int32_t)( (buffer[0] << 8) | buffer[1] );
-
-    // now read in the uncompensated pressure - the delay time depends
-    // on the oversampling value
-
-    uint8_t reg = BMPX8X_CMD_READ_PRESSURE |
-        (dev->oversampling << _BMPX8X_CTRL_MEAS_OSS_SHIFT);
-
-    if (bmpx8x_write_reg(dev, BMPX8X_CTRL_MEAS, reg))
-    {
-        printf("%s: bmpx8x_write_reg(prescmd) failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    switch(dev->oversampling)
-    {
-    case BMPX8X_OSS_ULTRALOWPOWER:
-        upm_delay_ms(5);
-        break;
-
-    case BMPX8X_OSS_STANDARD:
-        upm_delay_ms(8);
-        break;
-
-    case BMPX8X_OSS_HIGHRES:
-        upm_delay_ms(14);
-        break;
-
-    case BMPX8X_OSS_ULTRAHIGHRES:
-        upm_delay_ms(26);
-        break;
-    }
-
-    if (bmpx8x_read_regs(dev, BMPX8X_OUTDATA_MSB, buffer, maxLen) != maxLen)
-    {
-        printf("%s: bmpx8x_read_regs(pres) failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // uncompensated pressure
-
-    int32_t UP = ( (buffer[0] << 16) | (buffer[1] << 8) | buffer[2] );
-    UP >>= (8 - dev->oversampling);
-
-    // now, compensate and store
-    int32_t B3, B5, B6, X1, X2, X3, p;
-    uint32_t B4, B7;
-
-    // temperature
-    B5 = _bmpx8x_computeB5(dev, UT);
-
-    dev->temperature = (float)( (B5 + 8) >> 4 );
-    dev->temperature /= 10.0;
-
-    // pressure
-    B6 = B5 - 4000;
-    X1 = ((int32_t)dev->b2 * ( (B6 * B6)>>12 )) >> 11;
-    X2 = ((int32_t)dev->ac2 * B6) >> 11;
-    X3 = X1 + X2;
-    B3 = ((((int32_t)dev->ac1*4 + X3) << dev->oversampling) + 2) / 4;
-
-    X1 = ((int32_t)dev->ac3 * B6) >> 13;
-    X2 = ((int32_t)dev->b1 * ((B6 * B6) >> 12)) >> 16;
-    X3 = ((X1 + X2) + 2) >> 2;
-    B4 = ((uint32_t)dev->ac4 * (uint32_t)(X3 + 32768)) >> 15;
-    B7 = ((uint32_t)UP - B3) * (uint32_t)( 50000UL >> dev->oversampling );
-
-    if (B7 < 0x80000000)
-        p = (B7 * 2) / B4;
-    else
-        p = (B7 / B4) * 2;
-
-    X1 = (p >> 8) * (p >> 8);
-    X1 = (X1 * 3038) >> 16;
-    X2 = (-7357 * p) >> 16;
-
-    dev->pressure = p + ((X1 + X2 + (int32_t)3791)>>4);
-
-    return UPM_SUCCESS;
-}
-
-int bmpx8x_get_pressure(const bmpx8x_context dev)
-{
-    assert(dev != NULL);
-
-    return dev->pressure;
-}
-
-float bmpx8x_get_temperature(const bmpx8x_context dev)
-{
-    assert(dev != NULL);
-
-    return dev->temperature;
-}
-
-int bmpx8x_get_sealevel_pressure(const bmpx8x_context dev,
-                                   float altitude)
-{
-    assert(dev != NULL);
-
-    return ((float)dev->pressure / powf(1.0-altitude/44330.0, 5.255));
-}
-
-float bmpx8x_get_altitude(const bmpx8x_context dev, int sealevel)
-{
-    assert(dev != NULL);
-
-    // avoid potential divide-by-0, and set the default to 101325 Pa
-    if (sealevel <= 0)
-        sealevel = 101325;
-
-    return 44307.69 * (1.0 - powf((float)dev->pressure / (float)sealevel,
-                                 0.190284));
-}
-
-uint8_t bmpx8x_read_reg(const bmpx8x_context dev, uint8_t reg)
-{
-    assert(dev != NULL);
-
-    return (uint8_t)mraa_i2c_read_byte_data(dev->i2c, reg);
-}
-
-int bmpx8x_read_regs(const bmpx8x_context dev, uint8_t reg,
-                     uint8_t *buffer, int len)
-{
-    assert(dev != NULL);
-
-    if (mraa_i2c_read_bytes_data(dev->i2c, reg, buffer, len) != len)
-        return -1;
-
-    return len;
-}
-
-upm_result_t bmpx8x_write_reg(const bmpx8x_context dev,
-                              uint8_t reg, uint8_t val)
-{
-    assert(dev != NULL);
-
-    if (mraa_i2c_write_byte_data(dev->i2c, val, reg))
-    {
-        printf("%s: mraa_i2c_write_byte_data() failed.\n",
-               __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
diff --git a/src/bmpx8x/bmpx8x.cxx b/src/bmpx8x/bmpx8x.cxx
deleted file mode 100644
index 3614490..0000000
--- a/src/bmpx8x/bmpx8x.cxx
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * This driver was rewritten based on the original driver written by:
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-#include <unistd.h>
-#include <stdlib.h>
-
-#include "bmpx8x.hpp"
-
-using namespace upm;
-using namespace std;
-
-BMPX8X::BMPX8X (int bus, int addr) :
-    m_bmpx8x(bmpx8x_init(bus, addr))
-{
-    if (!m_bmpx8x)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmpx8x_init() failed");
-}
-
-BMPX8X::~BMPX8X()
-{
-    bmpx8x_close(m_bmpx8x);
-}
-
-void BMPX8X::init(BMPX8X_OSS_T oss)
-{
-    if (bmpx8x_devinit(m_bmpx8x, oss))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmpx8x_devinit() failed");
-}
-
-void BMPX8X::update()
-{
-    if (bmpx8x_update(m_bmpx8x))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmpx8x_update() failed");
-}
-
-void BMPX8X::reset()
-{
-    if (bmpx8x_reset(m_bmpx8x))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmpx8x_reset() failed");
-}
-
-void BMPX8X::setOversampling(BMPX8X_OSS_T oss)
-{
-    bmpx8x_set_oversampling(m_bmpx8x, oss);
-}
-
-uint8_t BMPX8X::readReg(uint8_t reg)
-{
-    return bmpx8x_read_reg(m_bmpx8x, reg);
-}
-
-int BMPX8X::readRegs(uint8_t reg, uint8_t *buffer, int len)
-{
-    int rv = bmpx8x_read_regs(m_bmpx8x, reg, buffer, len);
-    if (rv < 0)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmpx8x_read_regs() failed");
-
-    return rv;
-}
-
-void BMPX8X::writeReg(uint8_t reg, uint8_t val)
-{
-    if (bmpx8x_write_reg(m_bmpx8x, reg, val))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bmpx8x_write_reg() failed");
-}
-
-int BMPX8X::getPressure()
-{
-    return bmpx8x_get_pressure(m_bmpx8x);
-}
-
-float BMPX8X::getTemperature()
-{
-    return bmpx8x_get_temperature(m_bmpx8x);
-}
-
-int BMPX8X::getSealevelPressure(float altitudeMeters)
-{
-    return bmpx8x_get_sealevel_pressure(m_bmpx8x, altitudeMeters);
-}
-
-float BMPX8X::getAltitude(int sealevelPressure)
-{
-    return bmpx8x_get_altitude(m_bmpx8x, sealevelPressure);
-}
diff --git a/src/bmpx8x/bmpx8x.h b/src/bmpx8x/bmpx8x.h
deleted file mode 100644
index aa4fa9c..0000000
--- a/src/bmpx8x/bmpx8x.h
+++ /dev/null
@@ -1,230 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * This driver was rewritten based on the original driver written by:
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <unistd.h>
-#include <string.h>
-
-#include <mraa/i2c.h>
-
-#include "upm.h"
-
-#include "bmpx8x_defs.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-    /**
-     * @file bmpx8x.h
-     * @library bmpx8x
-     * @brief C API for the bmpx8x driver
-     *
-     * @include bmpx8x.c
-     */
-
-    /**
-     * Device context
-     */
-    typedef struct _bmpx8x_context {
-        mraa_i2c_context i2c;
-
-        // our oversampling (precision)
-        BMPX8X_OSS_T oversampling;
-
-        // compensated temperature and pressure
-        float temperature;
-        int pressure;
-
-        // compensation coefficients
-        int16_t ac1;
-        int16_t ac2;
-        int16_t ac3;
-        uint16_t ac4;
-        uint16_t ac5;
-        uint16_t ac6;
-        int16_t b1;
-        int16_t b2;
-        int16_t mb;
-        int16_t mc;
-        int16_t md;
-    } *bmpx8x_context;
-
-
-    /**
-     * BMPX8X initialization.
-     *
-     * By default, the device is initialized to it's highest accuracy
-     * (BMP085_OSS_ULTRAHIGHRES).
-     *
-     * @param bus I2C bus number.
-     * @param addr I2C address of the device.
-     * @return Device context, or NULL if an error occurred.
-     */
-    bmpx8x_context bmpx8x_init(int bus, int addr);
-
-    /**
-     * BMPX8X close function.
-     *
-     * @param dev Device context.
-     */
-    void bmpx8x_close(bmpx8x_context dev);
-
-    /**
-     * Return the chip ID.
-     *
-     * @param dev The device context.
-     * @return The chip ID.
-     */
-    uint8_t bmpx8x_get_chip_id(const bmpx8x_context dev);
-
-    /**
-     * Initialize the device, read calibration data, and start
-     * operation.  This function is called from bmpx8x_init() so it
-     * will not typically need to be called by a user unless the
-     * device is reset.  This method will call
-     * bmpx8x_set_oversampling() with the passed parameter.
-     *
-     * @param dev The device context.
-     * @param oss One of the BMPX8X_OSS_T values.  The default set
-     * at bmpx8x_init() time is BMP085_OSS_ULTRAHIGHRES.
-     * @return UPM result.
-     */
-    upm_result_t bmpx8x_devinit(const bmpx8x_context dev,
-                                BMPX8X_OSS_T oss);
-
-    /**
-     * Perform a device reset.  The device will be reset as if it was
-     * just powered on.  All compensation values will be lost.  You
-     * should call bmpx8x_devinit() afterward, or perform the same
-     * steps that bmpx8x_devinit() performs before attempting to use
-     * the device.
-     *
-     * @param dev The device context.
-     * @return UPM result.
-     */
-    upm_result_t bmpx8x_reset(const bmpx8x_context dev);
-
-    /**
-     * Update the internal stored values from sensor data.
-     *
-     * @param dev The device context.
-     * @return UPM result.
-     */
-    upm_result_t bmpx8x_update(const bmpx8x_context dev);
-
-    /**
-     * Set the oversampling (precision mode) of the device.  Higher
-     * precision requires more time to complete.
-     *
-     * @param dev The device context.
-     * @param oss The desired oversampling mode, one of the
-     * BMPX8X_OSS_T values.
-     */
-    void bmpx8x_set_oversampling(const bmpx8x_context dev,
-                                 BMPX8X_OSS_T oss);
-
-    /**
-     * Returns the pressure in Pascals.  bmpx8x_update() must have
-     * been called prior to calling this function.
-     *
-     * @param dev Device context.
-     * @return The pressure in Pascals.
-     */
-    int bmpx8x_get_pressure(const bmpx8x_context dev);
-
-    /**
-     * Returns the temperature in degrees Celsius.  bmpx8x_update()
-     * must have been called prior to calling this function.
-     *
-     * @param dev Device context.
-     * @return The temperature in degrees Celsius.
-     */
-    float bmpx8x_get_temperature(const bmpx8x_context dev);
-
-    /**
-     * With a given current altitude, calculate pressure at sea level.
-     * bmpx8x_update() must have been called prior to calling this
-     * function.
-     *
-     * @param dev Device context.
-     * @param altitude Current altitude in Meters.
-     * @return The pressure in Pascals at sea level.
-     */
-    int bmpx8x_get_sealevel_pressure(const bmpx8x_context dev,
-                                     float altitude);
-
-    /**
-     * With a given sea level, calculate altitude in meters.
-     * bmpx8x_update() must have been called prior to calling this
-     * function.
-     *
-     * @param dev Device context.
-     * @param sealevel Sea level pressure in Pascals. If a negative
-     * number, or zero is supplied, a default sealevel of 101325 Pa
-     * will be used instead.
-     * @return The current altitude in Meters.
-     */
-    float bmpx8x_get_altitude(const bmpx8x_context dev, int sealevel);
-
-    /**
-     * Read a register.
-     *
-     * @param dev The device context.
-     * @param reg The register to read.
-     * @return The value of the register.
-     */
-    uint8_t bmpx8x_read_reg(const bmpx8x_context dev, uint8_t reg);
-
-    /**
-     * Read contiguous registers into a buffer.
-     *
-     * @param dev The device context.
-     * @param buffer The buffer to store the results.
-     * @param len The number of registers to read.
-     * @return The number of bytes read, or -1 on error.
-     */
-    int bmpx8x_read_regs(const bmpx8x_context dev, uint8_t reg,
-                         uint8_t *buffer, int len);
-
-    /**
-     * Write to a register.
-     *
-     * @param dev The device context.
-     * @param reg The register to write to.
-     * @param val The value to write.
-     * @return UPM result.
-     */
-    upm_result_t bmpx8x_write_reg(const bmpx8x_context dev,
-                                  uint8_t reg, uint8_t val);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/bmpx8x/bmpx8x.hpp b/src/bmpx8x/bmpx8x.hpp
deleted file mode 100644
index 680c2b5..0000000
--- a/src/bmpx8x/bmpx8x.hpp
+++ /dev/null
@@ -1,249 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * This driver was rewritten based on the original driver written by:
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-
-#include "bmpx8x.h"
-
-#include "interfaces/iPressureSensor.hpp"
-#include "interfaces/iTemperatureSensor.hpp"
-
-namespace upm {
-
-    /**
-     * @brief BMP & GY65 Atmospheric Pressure Sensors
-     * @defgroup bmpx8x libupm-bmpx8x
-     * @ingroup bosch seeed adafruit sparkfun i2c
-     * pressure
-     */
-
-    /**
-     * @library bmpx8x
-     * @sensor bmpx8x
-     * @comname BMP Atmospheric Pressure Sensor
-     * @altname GY65 BMP085 BMP180 BMP183
-     * @type pressure
-     * @man bosch seeed adafruit sparkfun
-     * @con i2c
-     * @web https://www.sparkfun.com/datasheets/Components/General/BST-BMP085-DS000-05.pdf
-     * @web https://www.bosch-sensortec.com/bst/products/all_products/bmp180
-     * @web https://cdn-shop.adafruit.com/datasheets/1900_BMP183.pdf
-     *
-     * @brief API for the GY65/BMP085 and BMP180 Atmospheric Pressure Sensors
-     *
-     * Bosch GY65/BMP085 and BMP180 are high-precision, ultra-low
-     * power consumption pressure sensors. They operate in the range of
-     * 30,000-110,000 Pa.
-     *
-     * This module has been tested on the GY65/BMP085 and BMP180 sensors.
-     *
-     * @image html bmp085.jpeg
-     * @snippet bmpx8x.cxx Interesting
-     */
-
-    class BMPX8X : public IPressureSensor, public ITemperatureSensor {
-    public:
-        /**
-         * Instantiates a BMPX8X object
-         *
-         * @param bus I2C bus to use.
-         * @param addr The I2C address of the device.
-         * @throws std::runtime_error on failure.
-         */
-        BMPX8X(int bus=BMPX8X_DEFAULT_I2C_BUS,
-               int addr=BMPX8X_DEFAULT_I2C_ADDR);
-
-        /**
-         * BMPX8X object destructor.
-         */
-        virtual ~BMPX8X();
-
-        /**
-         * Query the device and update the internal state.  This
-         * method must be called before calling getPressure(),
-         * getTemperature(), getSealevelPressure(), and getAltitude()
-         * to retrieve values.
-         *
-         * @throws std::runtime_error on failure.
-         */
-        void update();
-
-        /**
-         * Reset the device to power-on defaults.  All calibration
-         * data is lost when the device is reset, so you should call
-         * init() before attempting to use the device.
-         *
-         * @throws std::runtime_error on failure.
-         */
-        void reset();
-
-        /**
-         * Initialize the device, read calibration data, and start
-         * operation.  This function is called from the constructor,
-         * so it will not typically need to be called by a user unless
-         * the device is reset.
-         *
-         * @param oss One of the BMPX8X_OSS_T values.  The
-         * default is BMPX8X_OSS_ULTRAHIGHRES.
-         * @throws std::runtime_error on failure.
-         */
-        void init(BMPX8X_OSS_T oss=BMPX8X_OSS_ULTRAHIGHRES);
-
-        /**
-         * Set the oversampling (precision mode) of the device.
-         * Higher precision requires more time to complete.  This call
-         * takes effect the next time update() is called.
-         *
-         * @param oss One of the BMPX8X_OSS_T values.  The
-         * default is BMPX8X_OSS_ULTRAHIGHRES.
-         */
-        void setOversampling(BMPX8X_OSS_T oss=BMPX8X_OSS_ULTRAHIGHRES);
-
-        /**
-         * Returns the calculated pressure in Pascals.  update() must
-         * have been called prior to calling this function.
-         *
-         * @returns The pressure in Pascals.
-         */
-        int getPressure();
-
-        /**
-         * Returns the calculated temperature in Celsius.  update()
-         * must have been called prior to calling this function.
-         *
-         * @returns The temperature in Celsius.
-         */
-        float getTemperature();
-
-        /**
-         * Using the supplied altitude in meters, compute the pressure
-         * at sea level in Pascals.  update() must have been called
-         * prior to calling this function.
-         *
-         * @param meters The altitude in meters.
-         * @returns The computed sea level pressure in Pascals.
-         */
-        int getSealevelPressure(float meters);
-
-        /**
-         * Using the current calculated altitude, compute the pressure
-         * at sea level in Pascals.  update() must have been called
-         * prior to calling this function.
-         *
-         * @returns The computed sea level pressure in Pascals.
-         */
-        int getSealevelPressure()
-        {
-            return getSealevelPressure(getAltitude());
-        }
-
-        /**
-         * Calculate the current altitude in meters, given a sea level
-         * pressure in Pascals.  The default sea level pressure is
-         * 101325 Pascals.  update() must have been called prior to
-         * calling this function.
-         *
-         * @param sealevelPressure The pressure at sea level in
-         * Pascals.  The default is 101325 Pascals.
-         * @returns the computed altitude in meters.
-         */
-        float getAltitude(int sealevelPressure = 101325);
-
-        /**
-         * Return latest calculated temperature value in Celsius.  See
-         * ITemperatureSensor.
-         *
-         * @return The current temperature in Celsius.
-         */
-        int getTemperatureCelsius()
-        {
-            update();
-            return (int)getTemperature();
-        }
-
-        /**
-         * Return latest calculated pressure value in Pascals.  See
-         * IPressureSensor.
-         *
-         * @return The current pressure in Pascals.
-         */
-        int getPressurePa()
-        {
-            update();
-            return getPressure();
-        }
-
-        /**
-         * Returns the name of module.
-         *
-         * @return The name of the module.
-         */
-        const char *getModuleName()
-        {
-            return "BMPX8X";
-        }
-
-    protected:
-        // our underlying C context.
-        bmpx8x_context m_bmpx8x;
-
-        /**
-         * Read a register.
-         *
-         * @param reg The register to read.
-         * @return The value of the register.
-         */
-        uint8_t readReg(uint8_t reg);
-
-        /**
-         * Read contiguous registers into a buffer.
-         *
-         * @param buffer The buffer to store the results.
-         * @param len The number of registers to read.
-         * @return The number of bytes read.
-         * @throws std::runtime_error on failure.
-         */
-        int readRegs(uint8_t reg, uint8_t *buffer, int len);
-
-        /**
-         * Write to a register.
-         *
-         * @param reg The register to write to.
-         * @param val The value to write.
-         * @throws std::runtime_error on failure.
-         */
-        void writeReg(uint8_t reg, uint8_t val);
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        BMPX8X(const BMPX8X&) = delete;
-        BMPX8X &operator=(const BMPX8X&) = delete;
-    };
-}
diff --git a/src/bmpx8x/bmpx8x.i b/src/bmpx8x/bmpx8x.i
deleted file mode 100644
index 08465a5..0000000
--- a/src/bmpx8x/bmpx8x.i
+++ /dev/null
@@ -1,28 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%import "../interfaces/javaupm_iPressureSensor.i"
-%typemap(javaimports) SWIGTYPE %{import upm_interfaces.*;%}
-%import "../interfaces/javaupm_iTemperatureSensor.i"
-
-JAVA_JNI_LOADLIBRARY(javaupm_bmpx8x)
-#endif
-/* END Java syntax */
-
-/* BEGIN Python syntax  ----------------------------------------------------- */
-#ifdef SWIGPYTHON
-%include "iModuleStatus.hpp"
-%include "iTemperatureSensor.hpp"
-%include "iPressureSensor.hpp"
-#endif
-/* END Python syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "bmpx8x_defs.h"
-#include "bmpx8x.hpp"
-%}
-%include "bmpx8x_defs.h"
-%include "bmpx8x.hpp"
-/* END Common SWIG syntax */
diff --git a/src/bmpx8x/bmpx8x.json b/src/bmpx8x/bmpx8x.json
deleted file mode 100644
index 492d611..0000000
--- a/src/bmpx8x/bmpx8x.json
+++ /dev/null
@@ -1,49 +0,0 @@
-{
-    "Library": "bmpx8x",
-    "Description": "BMP Atmospheric Pressure Sensor",
-    "Sensor Class":
-    {
-        "BMPX8X":
-        {
-            "Name": "BMP Atmospheric Pressure Sensor",
-            "Description": "The BME280 is as combined digital humidity, pressure and temperature sensor based on proven sensing principles. The sensor module is housed in an extremely compact metal-lid LGA package with a footprint of only 2.5 * 2.5 mm2 with a height of 0.93 mm. Its small dimensions and its low power consumption allow the implementation in battery driven devices such as handsets, GPS modules or watches. The BME280 is register and performance compatible to the Bosch Sensortec BMP280 digital pressure sensor",
-            "Aliases": ["bmpx8x"],
-            "Categories": ["pressure"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping", "industrial"],
-            "Manufacturers": ["seeed", "adafruit", "sparkfun"],
-            "Kits": [],
-            "Examples":
-            {
-                "Java": ["BMPX8X_Example.java"],
-                "Python": ["bmpx8x.py"],
-                "Node.js": ["bmpx8x.js"],
-                "C++": ["bmpx8x.cxx"],
-                "C": ["bmpx8x.c"]
-            },
-            "Specifications":
-            {
-                "Vdd": {"unit": "v", "low" : 1.8, "high": 3.6},
-                "Supply Current": {"unit": "uA", "low": 3, "high": 32},
-                "Peak Current": {"unit": "uA", "low": 650, "high": 1000},
-                "Standby Current": {"unit": "uA", "low": 0.1, "high": 0.1},
-                "Pressure Range": {"unit": "hPa", "low" : 300, "high": 1100},
-                "Temperature Range": {"unit": "C", "low" : -40, "high": 85}
-            },
-            "Platforms":
-            {
-                "Intel Joule Module":
-                {
-                    "Notes": ["Requires pull-up resistors with carrier board"],
-                    "Images": [""]
-                }
-            },
-            "Urls" :
-            {
-                "Product Pages": ["https://www.adafruit.com/product/1900"],
-                "Datasheets": ["https://cdn-shop.adafruit.com/datasheets/1900_BMP183.pdf", "https://www.sparkfun.com/datasheets/Components/General/BST-BMP085-DS000-05.pdf"],
-                "Schematics": ["https://learn.adafruit.com/adafruit-bmp183-spi-barometric-pressure-and-altitude-sensor/downloads#schematic"]
-            }
-        }
-    }
-}
diff --git a/src/bmpx8x/bmpx8x_defs.h b/src/bmpx8x/bmpx8x_defs.h
deleted file mode 100644
index 1fe4a2b..0000000
--- a/src/bmpx8x/bmpx8x_defs.h
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * This driver was rewritten based on the original driver written by:
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#define BMPX8X_DEFAULT_I2C_BUS   0
-#define BMPX8X_DEFAULT_I2C_ADDR  0x77
-#define BMPX8X_DEFAULT_CHIPID    0x55
-// special reset byte
-#define BMPX8X_RESET_BYTE        0xb6
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    /**
-     * BMPX8X registers.
-     */
-    typedef enum {
-        BMPX8X_CAL_AC1           = 0xaa,  // Calibration data (16
-                                          // bits, msb/lsb)
-        BMPX8X_CAL_AC2           = 0xac,
-        BMPX8X_CAL_AC3           = 0xae,
-        BMPX8X_CAL_AC4           = 0xb0,
-        BMPX8X_CAL_AC5           = 0xb2,
-        BMPX8X_CAL_AC6           = 0xb4,
-        BMPX8X_CAL_B1            = 0xb6,
-        BMPX8X_CAL_B2            = 0xb8,
-        BMPX8X_CAL_MB            = 0xba,
-        BMPX8X_CAL_MC            = 0xbc,
-        BMPX8X_CAL_MD            = 0xbe,
-
-        BMPX8X_CTRL_MEAS         = 0xf4, // command reg
-
-        BMPX8X_OUTDATA_MSB       = 0xf6,
-        BMPX8X_OUTDATA_LSB       = 0xf7,
-        BMPX8X_OUTDATA_XLSB      = 0xf8,
-
-        BMPX8X_RESET             = 0xe0,
-
-        BMPX8X_CHIP_ID           = 0xd0
-    } BMPX8X_REGS_T;
-
-    /**
-     * BMPX8X_CTRL_MEAS register bits
-     */
-    typedef enum {
-        BMPX8X_CTRL_MEAS_CMD0    = 0x01, // measurement command
-        BMPX8X_CTRL_MEAS_CMD1    = 0x02,
-        BMPX8X_CTRL_MEAS_CMD2    = 0x04,
-        BMPX8X_CTRL_MEAS_CMD3    = 0x08,
-        BMPX8X_CTRL_MEAS_CMD4    = 0x10,
-        _BMPX8X_CTRL_MEAS_CMD_MASK  = 31,
-        _BMPX8X_CTRL_MEAS_CMD_SHIFT = 0,
-
-        BMPX8X_CTRL_MEAS_SCO     = 0x20, // start conversion status
-
-        BMPX8X_CTRL_MEAS_OSS0    = 0x40, // oversampling (precision)
-        BMPX8X_CTRL_MEAS_OSS1    = 0x80,
-        _BMPX8X_CTRL_MEAS_OSS_MASK  = 3,
-        _BMPX8X_CTRL_MEAS_OSS_SHIFT = 6,
-    } BMPX8X_CTRL_MEAS_BITS_T;
-
-    /**
-     * BMPX8X_CTRL_MEAS_CMD commands.
-     */
-    typedef enum {
-        BMPX8X_CMD_READ_TEMP     = 0x2e,
-        BMPX8X_CMD_READ_PRESSURE = 0x34
-    } BMPX8X_CMD_T;
-
-    /**
-     * BMPX8X_CTRL_MEAS_OSS, Oversampling ratio values.
-     */
-    typedef enum {
-        BMPX8X_OSS_ULTRALOWPOWER = 0,
-        BMPX8X_OSS_STANDARD      = 1,
-        BMPX8X_OSS_HIGHRES       = 2,
-        BMPX8X_OSS_ULTRAHIGHRES  = 3
-    } BMPX8X_OSS_T;
-
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/bmpx8x/bmpx8x_fti.c b/src/bmpx8x/bmpx8x_fti.c
deleted file mode 100644
index a45f66d..0000000
--- a/src/bmpx8x/bmpx8x_fti.c
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "bmpx8x.h"
-#include "upm_fti.h"
-
-/**
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_bmpx8x_name[] = "BMPX8X";
-const char upm_bmpx8x_description[] = "BMPX8X Pressure and Temperature Sensor";
-const upm_protocol_t upm_bmpx8x_protocol[] = {UPM_I2C};
-const upm_sensor_t upm_bmpx8x_category[] = {UPM_TEMPERATURE, UPM_PRESSURE};
-
-// forward declarations
-const void* upm_bmpx8x_get_ft(upm_sensor_t sensor_type);
-void* upm_bmpx8x_init_name();
-void upm_bmpx8x_close(void *dev);
-upm_result_t upm_bmpx8x_get_pressure(void *dev, float *value);
-upm_result_t upm_bmpx8x_get_temperature(void *dev, float *value,
-                                        upm_temperature_u unit);
-
-const upm_sensor_descriptor_t upm_bmpx8x_get_descriptor()
-{
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_bmpx8x_name;
-    usd.description = upm_bmpx8x_description;
-    usd.protocol_size = 1;
-    usd.protocol = upm_bmpx8x_protocol;
-    usd.category_size = 2;
-    usd.category = upm_bmpx8x_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-  .upm_sensor_init_name = upm_bmpx8x_init_name,
-  .upm_sensor_close = upm_bmpx8x_close,
-};
-
-static const upm_temperature_ft tft =
-{
-  .upm_temperature_get_value = upm_bmpx8x_get_temperature,
-};
-
-static const upm_pressure_ft pft =
-{
-  .upm_pressure_get_value = upm_bmpx8x_get_pressure,
-};
-
-const void* upm_bmpx8x_get_ft(upm_sensor_t sensor_type)
-{
-  switch(sensor_type)
-    {
-    case UPM_SENSOR:
-      return &ft;
-    case UPM_PRESSURE:
-      return &pft;
-    case UPM_TEMPERATURE:
-      return &tft;
-    default:
-      return NULL;
-    }
-}
-
-void* upm_bmpx8x_init_name()
-{
-  return NULL;
-}
-
-void upm_bmpx8x_close(void *dev)
-{
-  bmpx8x_close((bmpx8x_context)dev);
-}
-
-upm_result_t upm_bmpx8x_get_pressure(void *dev, float *value)
-{
-  upm_result_t rv;
-
-  if ((rv = bmpx8x_update((bmpx8x_context)dev)))
-    return rv;
-
-  *value = bmpx8x_get_pressure((bmpx8x_context)dev);
-
-  return UPM_SUCCESS;
-}
-
-upm_result_t upm_bmpx8x_get_temperature(void *dev, float *value,
-                                        upm_temperature_u unit)
-{
-  upm_result_t rv;
-
-  if ((rv = bmpx8x_update((bmpx8x_context)dev)))
-    return rv;
-
-  // always in C
-  float temp = bmpx8x_get_temperature((bmpx8x_context)dev);
-
-  switch (unit)
-    {
-    case CELSIUS:
-      *value = temp;
-      return UPM_SUCCESS;
-
-    case KELVIN:
-      *value = temp + 273.15;
-      return UPM_SUCCESS;
-
-    case FAHRENHEIT:
-      *value = temp * (9.0/5.0) + 32.0;
-      return UPM_SUCCESS;
-    }
-
-  return UPM_SUCCESS;
-}
diff --git a/src/bmx055/CMakeLists.txt b/src/bmx055/CMakeLists.txt
deleted file mode 100644
index 8045c45..0000000
--- a/src/bmx055/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-upm_mixed_module_init (NAME bmx055
-    DESCRIPTION "Bosch IMU Sensor Library"
-    CPP_HDR bmx055.hpp bmc150.hpp bmi055.hpp
-    CPP_SRC bmx055.cxx bmc150.cxx bmi055.cxx
-    REQUIRES mraa bmg160 bma250e bmm150)
diff --git a/src/bmx055/bmc150.cxx b/src/bmx055/bmc150.cxx
deleted file mode 100644
index 8b8af2e..0000000
--- a/src/bmx055/bmc150.cxx
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016-2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <iostream>
-#include <stdexcept>
-#include <string>
-
-#include "bmc150.hpp"
-
-using namespace upm;
-using namespace std;
-
-BMC150::BMC150(int accelBus, int accelAddr, int accelCS,
-               int magBus, int magAddr, int magCS) :
-    m_accel(0), m_mag(0)
-{
-    // if -1 is supplied as a bus for any of these, we will not
-    // instantiate them
-
-    if (accelBus >= 0)
-        m_accel = new BMA250E(accelBus, accelAddr, accelCS);
-
-    if (magBus >= 0)
-        m_mag = new BMM150(magBus, magAddr, magCS);
-
-    // now initialize them...
-    if (m_accel)
-        m_accel->init();
-
-    if (m_mag)
-        m_mag->init();
-}
-
-BMC150::~BMC150()
-{
-    if (m_accel)
-        delete m_accel;
-
-    if (m_mag)
-        delete m_mag;
-}
-
-void BMC150::initAccelerometer(BMA250E_POWER_MODE_T pwr,
-                               BMA250E_RANGE_T range,
-                               BMA250E_BW_T bw)
-{
-    if (m_accel)
-        m_accel->init(pwr, range, bw);
-}
-
-void BMC150::initMagnetometer(BMM150_USAGE_PRESETS_T usage)
-{
-    if (m_mag)
-        m_mag->init(usage);
-}
-
-void BMC150::update()
-{
-    if (m_accel)
-        m_accel->update();
-
-    if (m_mag)
-        m_mag->update();
-}
-
-void BMC150::getAccelerometer(float *x, float *y, float *z)
-{
-    if (m_accel)
-        m_accel->getAccelerometer(x, y, z);
-}
-
-std::vector<float> BMC150::getAccelerometer()
-{
-    if (m_accel)
-        return m_accel->getAccelerometer();
-    else
-        return {0, 0, 0};
-}
-
-void BMC150::getMagnetometer(float *x, float *y, float *z)
-{
-    if (m_mag)
-        m_mag->getMagnetometer(x, y, z);
-}
-
-std::vector<float> BMC150::getMagnetometer()
-{
-    if (m_mag)
-        return m_mag->getMagnetometer();
-    else
-        return {0, 0, 0};
-}
diff --git a/src/bmx055/bmc150.hpp b/src/bmx055/bmc150.hpp
deleted file mode 100644
index 1f9233d..0000000
--- a/src/bmx055/bmc150.hpp
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016-2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <vector>
-
-#include "bma250e.hpp"
-#include "bmm150.hpp"
-
-#define BMC150_DEFAULT_BUS 0
-#define BMC150_DEFAULT_ACC_ADDR 0x10
-#define BMC150_DEFAULT_MAG_ADDR 0x12
-
-namespace upm {
-
-    /**
-     * @library bmx055
-     * @sensor bmc150
-     * @comname 6-axis Ecompass
-     * @type accelerometer compass
-     * @man bosch
-     * @con i2c gpio spi
-     * @web http://www.bosch-sensortec.com/en/bst/products/all_products/homepage_1_ohne_marginalspalte_52
-     *
-     * @brief API for the BMC150 6-axis eCompass
-     *
-     *
-     * The BMC150 is an integrated electronic compass solution for
-     * consumer market applications. It comprises a 12bit leading edge
-     * triaxial, low-g acceleration sensor and an ultra-low power, high
-     * precision triaxial magnetic field sensor. It allows measurements
-     * of acceleration and magnetic field in three perpendicular
-     * axes. Performance and features of both sensing technologies are
-     * carefully tuned and perfectly match the demanding requirements of
-     * all 6-axis mobile applications such as electronic compass,
-     * navigation or augmented reality.
-
-     * The BMC150 is essentially 2 separate devices in one: the BMA250E
-     * Accelerometer and the BMM150 Magnetometer.  They are completely
-     * independent of each other.
-     *
-     * This driver provides a very simple interface to these 2 devices.
-     * If finer control is desired, you should just use the separate
-     * BMA25E and BMM150 device classes directly.  This driver simply
-     * initializes both devices, and provides a mechanism to read
-     * accelerometer and magnetometer data from them.
-     *
-     * @snippet bmx055-bmc150.cxx Interesting
-     */
-
-    class BMC150 {
-    public:
-        /**
-         * BMC150 constructor.
-         *
-         * This device can support both I2C and SPI. For SPI, set the addr
-         * to -1, and specify a positive integer representing the Chip
-         * Select (CS) pin for the cs argument.  If you are using a
-         * hardware CS pin (like edison with arduino breakout), then you
-         * can connect the proper pin to the hardware CS pin on your MCU
-         * and supply -1 for cs.  The default operating mode is I2C.
-         *
-         * @param accelBus I2C or SPI bus to use. -1 to skip initializing
-         * this device.
-         * @param accelAddr The address for this device.  -1 for SPI.
-         * @param accelCS The gpio pin to use for the SPI Chip Select.  -1 for
-         * I2C or for SPI with a hardware controlled pin.
-         * @param magBus I2C or SPI bus to use. -1 to skip initializing
-         * this device.
-         * @param magAddr The address for this device.  -1 for SPI.
-         * @param magCS The gpio pin to use for the SPI Chip Select.  -1 for
-         * I2C or for SPI with a hardware controlled pin.
-         */
-        BMC150(int accelBus=BMC150_DEFAULT_BUS,
-               int accelAddr=BMC150_DEFAULT_ACC_ADDR,
-               int accelCS=-1,
-               int magBus=BMC150_DEFAULT_BUS,
-               int magAddr=BMC150_DEFAULT_MAG_ADDR,
-               int magCS=-1);
-
-        /**
-         * BMC150 Destructor.
-         */
-        ~BMC150();
-
-        /**
-         * Update the internal stored values from sensor data.
-         */
-        void update();
-
-        /**
-         * Initialize the accelerometer and start operation.  This
-         * function is called from the constructor so will not typically
-         * need to be called by a user unless the device is reset or you
-         * want to change these values.
-         *
-         * @param pwr One of the BMA250E_POWER_MODE_T values.  The default is
-         * BMA250E_POWER_MODE_NORMAL.
-         * @param range One of the BMA250E_RANGE_T values.  The default is
-         * BMA250E_RANGE_2G.
-         * @param bw One of the filtering BMA250E_BW_T values.  The default is
-         * BMA250E_BW_250.
-         */
-        void initAccelerometer(
-            BMA250E_POWER_MODE_T pwr=BMA250E_POWER_MODE_NORMAL,
-            BMA250E_RANGE_T range=BMA250E_RANGE_2G,
-            BMA250E_BW_T bw=BMA250E_BW_250);
-
-        /**
-         * Initialize the magnetometer and start operation.  This function
-         * is called from the constructor so will not typically need to be
-         * called by a user unless the device is reset or you want to
-         * change these values.  This method will call
-         * BMM150::setPresetMode() with the passed parameter.
-         *
-         * @param usage One of the BMM150_USAGE_PRESETS_T values.
-         * The default is BMM150_USAGE_HIGH_ACCURACY.
-         */
-        void initMagnetometer(
-            BMM150_USAGE_PRESETS_T usage=BMM150_USAGE_HIGH_ACCURACY);
-
-        /**
-         * Return accelerometer data in gravities.  update() must have
-         * been called prior to calling this method.
-         *
-         * @param x Pointer to a floating point value that will have the
-         * current x component placed into it.
-         * @param y Pointer to a floating point value that will have the
-         * current y component placed into it.
-         * @param z Pointer to a floating point value that will have the
-         * current z component placed into it.
-         */
-        void getAccelerometer(float *x, float *y, float *z);
-
-        /**
-         * Return accelerometer data in gravities in the form of a
-         * floating point vector.  update() must have been called
-         * prior to calling this method.
-         *
-         * @return A floating point vector containing x, y, and z in
-         * that order.
-         */
-        std::vector<float> getAccelerometer();
-
-        /**
-         * Return magnetometer data in micro-Teslas (uT).  update() must
-         * have been called prior to calling this method.
-         *
-         * @param x Pointer to a floating point value that will have the
-         * current x component placed into it.
-         * @param y Pointer to a floating point value that will have the
-         * current y component placed into it.
-         * @param z Pointer to a floating point value that will have the
-         * current z component placed into it.
-         */
-        void getMagnetometer(float *x, float *y, float *z);
-
-        /**
-         * Return magnetometer data in micro-Teslas (uT) in the form
-         * of a floating point vector.  update() must have been called
-         * prior to calling this method.
-         *
-         * @return A floating point vector containing x, y, and z in
-         * that order.
-         */
-        std::vector<float> getMagnetometer();
-
-
-    protected:
-        BMA250E *m_accel;
-        BMM150 *m_mag;
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        BMC150(const BMC150&) = delete;
-        BMC150 &operator=(const BMC150&) = delete;
-    };
-}
diff --git a/src/bmx055/bmi055.cxx b/src/bmx055/bmi055.cxx
deleted file mode 100644
index f8edd97..0000000
--- a/src/bmx055/bmi055.cxx
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016-2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <iostream>
-#include <stdexcept>
-#include <string>
-
-#include "bmi055.hpp"
-
-using namespace upm;
-using namespace std;
-
-BMI055::BMI055(int accelBus, int accelAddr, int accelCS,
-               int gyroBus, int gyroAddr, int gyroCS) :
-    m_accel(0), m_gyro(0)
-{
-    // if -1 is supplied as a bus for any of these, we will not
-    // instantiate them
-
-    if (accelBus >= 0)
-        m_accel = new BMA250E(accelBus, accelAddr, accelCS);
-
-    if (gyroBus >= 0)
-        m_gyro = new BMG160(gyroBus, gyroAddr, gyroCS);
-
-    // now initialize them...
-    if (m_accel)
-        m_accel->init();
-
-    if (m_gyro)
-        m_gyro->init();
-}
-
-BMI055::~BMI055()
-{
-    if (m_accel)
-        delete m_accel;
-
-    if (m_gyro)
-        delete m_gyro;
-}
-
-void BMI055::initAccelerometer(BMA250E_POWER_MODE_T pwr,
-                               BMA250E_RANGE_T range,
-                               BMA250E_BW_T bw)
-{
-    if (m_accel)
-        m_accel->init(pwr, range, bw);
-}
-
-void BMI055::initGyroscope(BMG160_POWER_MODE_T pwr,
-                           BMG160_RANGE_T range,
-                           BMG160_BW_T bw)
-{
-    if (m_gyro)
-        m_gyro->init(pwr, range, bw);
-}
-
-void BMI055::update()
-{
-    if (m_accel)
-        m_accel->update();
-
-    if (m_gyro)
-        m_gyro->update();
-}
-
-void BMI055::getAccelerometer(float *x, float *y, float *z)
-{
-    if (m_accel)
-        m_accel->getAccelerometer(x, y, z);
-}
-
-std::vector<float> BMI055::getAccelerometer()
-{
-    if (m_accel)
-        return m_accel->getAccelerometer();
-    else
-        return {0, 0, 0};
-}
-
-void BMI055::getGyroscope(float *x, float *y, float *z)
-{
-    if (m_gyro)
-        m_gyro->getGyroscope(x, y, z);
-}
-
-std::vector<float> BMI055::getGyroscope()
-{
-    if (m_gyro)
-        return m_gyro->getGyroscope();
-    else
-        return {0, 0, 0};
-}
diff --git a/src/bmx055/bmi055.hpp b/src/bmx055/bmi055.hpp
deleted file mode 100644
index e2c5095..0000000
--- a/src/bmx055/bmi055.hpp
+++ /dev/null
@@ -1,198 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016-2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <vector>
-
-#include "bma250e.hpp"
-#include "bmg160.hpp"
-
-namespace upm {
-
-    /**
-     * @library bmx055
-     * @sensor bmi055
-     * @comname 6DoF Sensor Module
-     * @type accelerometer compass
-     * @man bosch
-     * @con i2c gpio spi
-     * @web https://www.bosch-sensortec.com/bst/products/all_products/bmi055
-     *
-     * @brief API for the BMI055 6-axis Sensor Module
-     *
-     * The BMI055 is an inertial measurement unit (IMU) for the
-     * detection of movements and rotations in 6 degrees of freedom
-     * (6DoF). It reflects the full functionality of a triaxial, low-g
-     * acceleration sensor and at the same time it is capable to measure
-     * angular rates. Both - acceleration and angular rate - in three
-     * perpendicular room dimensions, the x-, y- and z-axis.
-     *
-     * The BMI055 is essentially 2 separate devices in one: the BMA250E
-     * Accelerometer and the BMG160 Gyroscope.  They are completely
-     * independent of each other.
-     *
-     * This driver provides a very simple interface to these two devices.
-     * If finer control is desired, you should just use the separate
-     * BMA25E and BMG160 device classes directly.  This driver
-     * simply initializes both devices, and provides a mechanism to
-     * read accelerometer and gyroscope data from them.
-     *
-     * @snippet bmx055-bmi055.cxx Interesting
-     */
-
-    class BMI055 {
-    public:
-        /**
-         * BMI055 constructor.
-         *
-         * This device can support both I2C and SPI. For SPI, set the addr
-         * to -1, and specify a positive integer representing the Chip
-         * Select (CS) pin for the cs argument.  If you are using a
-         * hardware CS pin (like edison with arduino breakout), then you
-         * can connect the proper pin to the hardware CS pin on your MCU
-         * and supply -1 for cs.  The default operating mode is I2C.
-         *
-         * @param accelBus I2C or SPI bus to use. -1 to skip initializing
-         * this device.
-         * @param accelAddr The address for this device.  -1 for SPI.
-         * @param accelCS The gpio pin to use for the SPI Chip Select.  -1 for
-         * I2C or for SPI with a hardware controlled pin.
-         * @param gyroBus I2C or SPI bus to use. -1 to skip initializing
-         * this device.
-         * @param gyroAddr The address for this device.  -1 for SPI.
-         * @param gyroCS The gpio pin to use for the SPI Chip Select.  -1 for
-         * I2C or for SPI with a hardware controlled pin.
-         */
-        BMI055(int accelBus=BMA250E_DEFAULT_I2C_BUS,
-               int accelAddr=BMA250E_DEFAULT_ADDR,
-               int accelCS=-1,
-               int gyroBus=BMG160_DEFAULT_I2C_BUS,
-               int gyroAddr=BMG160_DEFAULT_ADDR,
-               int gyroCS=-1);
-
-        /**
-         * BMI055 Destructor.
-         */
-        ~BMI055();
-
-        /**
-         * Update the internal stored values from sensor data.
-         */
-        void update();
-
-        /**
-         * Initialize the accelerometer and start operation.  This
-         * function is called from the constructor so will not typically
-         * need to be called by a user unless the device is reset or you
-         * want to change these values.
-         *
-         * @param pwr One of the BMA250E_POWER_MODE_T values.  The default is
-         * BMA250E_POWER_MODE_NORMAL.
-         * @param range One of the BMA250E_RANGE_T values.  The default is
-         * BMA250E_RANGE_2G.
-         * @param bw One of the filtering BMA250E_BW_T values.  The default is
-         * BMA250E_BW_250.
-         */
-        void initAccelerometer(
-            BMA250E_POWER_MODE_T pwr=BMA250E_POWER_MODE_NORMAL,
-            BMA250E_RANGE_T range=BMA250E_RANGE_2G,
-            BMA250E_BW_T bw=BMA250E_BW_250);
-
-        /**
-         * Initialize the gyroscope and start operation.  This function is
-         * called from the constructor so will not typically need to be
-         * called by a user unless the device is reset or you want to
-         * change these values.
-         *
-         * @param pwr One of the BMG160_POWER_MODE_T values.  The default is
-         * BMG160_POWER_MODE_NORMAL.
-         * @param range One of the BMG160_RANGE_T values.  The default is
-         * BMG160_RANGE_250.
-         * @param bw One of the filtering BMG160_BW_T values.  The default is
-         * BMG160_BW_400_47.
-         */
-        void initGyroscope(BMG160_POWER_MODE_T pwr=BMG160_POWER_MODE_NORMAL,
-                           BMG160_RANGE_T range=BMG160_RANGE_250,
-                           BMG160_BW_T bw=BMG160_BW_400_47);
-
-        /**
-         * Return accelerometer data in gravities.  update() must have
-         * been called prior to calling this method.
-         *
-         * @param x Pointer to a floating point value that will have the
-         * current x component placed into it.
-         * @param y Pointer to a floating point value that will have the
-         * current y component placed into it.
-         * @param z Pointer to a floating point value that will have the
-         * current z component placed into it.
-         */
-        void getAccelerometer(float *x, float *y, float *z);
-
-        /**
-         * Return accelerometer data in gravities in the form of a
-         * floating point vector.  update() must have been called prior to
-         * calling this method.
-         *
-         * @return A floating point vector containing x, y, and z in
-         * that order.
-         */
-        std::vector<float> getAccelerometer();
-
-        /**
-         * Return gyroscope data in degrees per second.  update() must
-         * have been called prior to calling this method.
-         *
-         * @param x Pointer to a floating point value that will have the
-         * current x component placed into it.
-         * @param y Pointer to a floating point value that will have the
-         * current y component placed into it.
-         * @param z Pointer to a floating point value that will have the
-         * current z component placed into it.
-         */
-        void getGyroscope(float *x, float *y, float *z);
-
-        /**
-         * Return gyroscope data in degrees per second in the form of a
-         * floating point vector.  update() must have been called prior to
-         * calling this method.
-         *
-         * @return A floating point vector containing x, y, and z in
-         * that order.
-         */
-        std::vector<float> getGyroscope();
-
-
-    protected:
-        BMA250E *m_accel;
-        BMG160 *m_gyro;
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        BMI055(const BMI055&) = delete;
-        BMI055 &operator=(const BMI055&) = delete;
-    };
-}
diff --git a/src/bmx055/bmx055.cxx b/src/bmx055/bmx055.cxx
deleted file mode 100644
index 4fbc5c7..0000000
--- a/src/bmx055/bmx055.cxx
+++ /dev/null
@@ -1,168 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016-2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <iostream>
-#include <stdexcept>
-#include <string>
-
-#include "bmx055.hpp"
-
-using namespace upm;
-using namespace std;
-
-BMX055::BMX055(int accelBus, int accelAddr, int accelCS,
-               int gyroBus, int gyroAddr, int gyroCS,
-               int magBus, int magAddr, int magCS) :
-    m_accel(0), m_gyro(0), m_mag(0)
-{
-    // if -1 is supplied as a bus for any of these, we will not
-    // instantiate them
-
-    if (accelBus >= 0)
-        m_accel = new BMA250E(accelBus, accelAddr, accelCS);
-
-    if (gyroBus >= 0)
-        m_gyro = new BMG160(gyroBus, gyroAddr, gyroCS);
-
-    if (magBus >= 0)
-        m_mag = new BMM150(magBus, magAddr, magCS);
-}
-
-BMX055::~BMX055()
-{
-    if (m_accel)
-        delete m_accel;
-
-    if (m_gyro)
-        delete m_gyro;
-
-    if (m_mag)
-        delete m_mag;
-}
-
-void BMX055::initAccelerometer(BMA250E_POWER_MODE_T pwr,
-                               BMA250E_RANGE_T range,
-                               BMA250E_BW_T bw)
-{
-    if (m_accel)
-        m_accel->init(pwr, range, bw);
-}
-
-void BMX055::initGyroscope(BMG160_POWER_MODE_T pwr,
-                           BMG160_RANGE_T range,
-                           BMG160_BW_T bw)
-{
-    if (m_gyro)
-        m_gyro->init(pwr, range, bw);
-}
-
-void BMX055::initMagnetometer(BMM150_USAGE_PRESETS_T usage)
-{
-    if (m_mag)
-        m_mag->init(usage);
-}
-
-void BMX055::update()
-{
-    if (m_accel)
-        m_accel->update();
-
-    if (m_gyro)
-        m_gyro->update();
-
-    if (m_mag)
-        m_mag->update();
-}
-
-void BMX055::getAccelerometer(float *x, float *y, float *z)
-{
-    if (m_accel)
-        m_accel->getAccelerometer(x, y, z);
-    else
-    {
-        if (x)
-            *x = 0;
-        if (y)
-            *y = 0;
-        if (z)
-            *z = 0;
-    }
-}
-
-std::vector<float> BMX055::getAccelerometer()
-{
-    if (m_accel)
-        return m_accel->getAccelerometer();
-    else
-        return {0, 0, 0};
-}
-
-void BMX055::getGyroscope(float *x, float *y, float *z)
-{
-    if (m_gyro)
-        m_gyro->getGyroscope(x, y, z);
-    else
-    {
-        if (x)
-            *x = 0;
-        if (y)
-            *y = 0;
-        if (z)
-            *z = 0;
-    }
-}
-
-std::vector<float> BMX055::getGyroscope()
-{
-    if (m_gyro)
-        return m_gyro->getGyroscope();
-    else
-        return {0, 0, 0};
-}
-
-void BMX055::getMagnetometer(float *x, float *y, float *z)
-{
-    if (m_mag)
-        m_mag->getMagnetometer(x, y, z);
-    else
-    {
-        if (x)
-            *x = 0;
-        if (y)
-            *y = 0;
-        if (z)
-            *z = 0;
-    }
-}
-
-std::vector<float> BMX055::getMagnetometer()
-{
-    if (m_mag)
-        return m_mag->getMagnetometer();
-    else
-        return {0, 0, 0};
-}
diff --git a/src/bmx055/bmx055.hpp b/src/bmx055/bmx055.hpp
deleted file mode 100644
index 333cd44..0000000
--- a/src/bmx055/bmx055.hpp
+++ /dev/null
@@ -1,254 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016-2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <vector>
-
-#include "bma250e.hpp"
-#include "bmg160.hpp"
-#include "bmm150.hpp"
-
-#define BMX055_DEFAULT_MAG_I2C_ADDR 0x12
-
-namespace upm {
-
-  /**
-   * @brief BMX055/BMI055/BMC150 Sensor Modules
-   * @defgroup bmx055 libupm-bmx055
-   * @ingroup i2c spi accelerometer compass
-   */
-
-  /**
-   * @library bmx055
-   * @sensor bmx055
-   * @comname 9-axis Sensor Module
-   * @type accelerometer compass
-   * @man bosch
-   * @con i2c gpio spi
-   * @web https://www.bosch-sensortec.com/bst/products/all_products/bmx055
-   *
-   * @brief API for the BMX055 9-axis Sensor Module
-   *
-   * The BMX055 is an integrated 9-axis sensor for the detection of
-   * movements and rotations and magnetic heading. It comprises the
-   * full functionality of a triaxial, low-g acceleration sensor, a
-   * triaxial angular rate sensor and a triaxial geomagnetic sensor.
-   *
-   * The BMX055 senses orientation, tilt, motion, acceleration,
-   * rotation, shock, vibration and heading in cell phones, handhelds,
-   * computer peripherals, man-machine interfaces, virtual reality
-   * features and game controllers.
-   *
-   * The BMX055 is essentially 3 separate devices in one: the BMA250E
-   * Accelerometer, the BMG160 Gyroscope, and the BMM150 Magnetometer.
-   * They are completely independent of each other.
-   *
-   * This driver provides a very simple interface to these 3 devices.
-   * If finer control is desired, you should just use the separate
-   * BMA250E, BMG160, and BMM150 device classes directly.  This driver
-   * simply initializes all three devices, and provides a mechanism to
-   * read accelerometer, gyroscope and magnetometer data from them.
-   *
-   * @snippet bmx055.cxx Interesting
-   */
-
-    class BMX055 {
-    public:
-        /**
-         * BMX055 constructor.
-         *
-         * This device can support both I2C and SPI. For SPI, set the addr
-         * to -1, and specify a positive integer representing the Chip
-         * Select (CS) pin for the cs argument.  If you are using a
-         * hardware CS pin (like edison with arduino breakout), then you
-         * can connect the proper pin to the hardware CS pin on your MCU
-         * and supply -1 for cs.  The default operating mode is I2C.
-         *
-         * @param accelBus I2C or SPI bus to use. -1 to skip initializing
-         * this device.
-         * @param accelAddr The address for this device.  -1 for SPI.
-         * @param accelCS The gpio pin to use for the SPI Chip Select.  -1 for
-         * I2C or for SPI with a hardware controlled pin.
-         * @param gyroBus I2C or SPI bus to use. -1 to skip initializing
-         * this device.
-         * @param gyroAddr The address for this device.  -1 for SPI.
-         * @param gyroCS The gpio pin to use for the SPI Chip Select.  -1 for
-         * I2C or for SPI with a hardware controlled pin.
-         * @param magBus I2C or SPI bus to use. -1 to skip initializing
-         * this device.
-         * @param magAddr The address for this device.  -1 for SPI.
-         * @param magCS The gpio pin to use for the SPI Chip Select.  -1 for
-         * I2C or for SPI with a hardware controlled pin.
-         */
-        BMX055(int accelBus=BMA250E_DEFAULT_I2C_BUS,
-               int accelAddr=BMA250E_DEFAULT_ADDR,
-               int accelCS=-1,
-               int gyroBus=BMG160_DEFAULT_I2C_BUS,
-               int gyroAddr=BMG160_DEFAULT_ADDR,
-               int gyroCS=-1,
-               int magBus=BMM150_DEFAULT_I2C_BUS,
-               int magAddr=BMX055_DEFAULT_MAG_I2C_ADDR,
-               int magCS=-1);
-
-        /**
-         * BMX055 Destructor.
-         */
-        ~BMX055();
-
-        /**
-         * Update the internal stored values from sensor data.
-         */
-        void update();
-
-        /**
-         * Initialize the accelerometer and start operation.  This
-         * function is called from the constructor so will not typically
-         * need to be called by a user unless the device is reset or you
-         * want to change these values.
-         *
-         * @param pwr One of the BMA250E_POWER_MODE_T values.  The default is
-         * BMA250E_POWER_MODE_NORMAL.
-         * @param range One of the BMA250E_RANGE_T values.  The default is
-         * BMA250E_RANGE_2G.
-         * @param bw One of the filtering BMA250E_BW_T values.  The default is
-         * BMA250E_BW_250.
-         */
-        void initAccelerometer(
-            BMA250E_POWER_MODE_T pwr=BMA250E_POWER_MODE_NORMAL,
-            BMA250E_RANGE_T range=BMA250E_RANGE_2G,
-            BMA250E_BW_T bw=BMA250E_BW_250);
-
-        /**
-         * Initialize the gyroscope and start operation.  This function is
-         * called from the constructor so will not typically need to be
-         * called by a user unless the device is reset or you want to
-         * change these values.
-         *
-         * @param pwr One of the BMG160_POWER_MODE_T values.  The default is
-         * BMG160_POWER_MODE_NORMAL.
-         * @param range One of the BMG160_RANGE_T values.  The default is
-         * BMG160_RANGE_250.
-         * @param bw One of the filtering BMG160_BW_T values.  The default is
-         * BMG160_BW_400_47.
-         */
-        void initGyroscope(BMG160_POWER_MODE_T pwr=BMG160_POWER_MODE_NORMAL,
-                           BMG160_RANGE_T range=BMG160_RANGE_250,
-                           BMG160_BW_T bw=BMG160_BW_400_47);
-
-        /**
-         * Initialize the magnetometer and start operation.  This function
-         * is called from the constructor so will not typically need to be
-         * called by a user unless the device is reset or you want to
-         * change these values.  This method will call
-         * BMM150::setPresetMode() with the passed parameter.
-         *
-         * @param usage One of the BMM150_USAGE_PRESETS_T values.
-         * The default is BMM150_USAGE_HIGH_ACCURACY.
-         */
-        void initMagnetometer(
-            BMM150_USAGE_PRESETS_T usage=BMM150_USAGE_HIGH_ACCURACY);
-
-        /**
-         * Return accelerometer data in gravities.  update() must have
-         * been called prior to calling this method.
-         *
-         * @param x Pointer to a floating point value that will have the
-         * current x component placed into it.
-         * @param y Pointer to a floating point value that will have the
-         * current y component placed into it.
-         * @param z Pointer to a floating point value that will have the
-         * current z component placed into it.
-         */
-        void getAccelerometer(float *x, float *y, float *z);
-
-        /**
-         * Return accelerometer data in gravities in the form of a
-         * floating point vector.  update() must have been called prior to
-         * calling this method.
-         *
-         * @return A floating point vector containing x, y, and z in
-         * that order.
-         */
-        std::vector<float> getAccelerometer();
-
-        /**
-         * Return gyroscope data in degrees per second.  update() must
-         * have been called prior to calling this method.
-         *
-         * @param x Pointer to a floating point value that will have the
-         * current x component placed into it.
-         * @param y Pointer to a floating point value that will have the
-         * current y component placed into it.
-         * @param z Pointer to a floating point value that will have the
-         * current z component placed into it.
-         */
-        void getGyroscope(float *x, float *y, float *z);
-
-        /**
-         * Return gyroscope data in degrees per second in the form of a
-         * floating point vector.  update() must have been called prior to
-         * calling this method.
-         *
-         * @return A floating point vector containing x, y, and z in
-         * that order.
-         */
-        std::vector<float> getGyroscope();
-
-        /**
-         * Return magnetometer data in micro-Teslas (uT).  update() must
-         * have been called prior to calling this method.
-         *
-         * @param x Pointer to a floating point value that will have the
-         * current x component placed into it.
-         * @param y Pointer to a floating point value that will have the
-         * current y component placed into it.
-         * @param z Pointer to a floating point value that will have the
-         * current z component placed into it.
-         */
-        void getMagnetometer(float *x, float *y, float *z);
-
-        /**
-         * Return magnetometer data in micro-Teslas (uT) in the form of a
-         * floating point vector.  update() must have been called prior to
-         * calling this method.
-         *
-         * @return A floating point vector containing x, y, and z in
-         * that order.
-         */
-        std::vector<float> getMagnetometer();
-
-    protected:
-        BMA250E *m_accel;
-        BMG160 *m_gyro;
-        BMM150 *m_mag;
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        BMX055(const BMX055&) = delete;
-        BMX055 &operator=(const BMX055&) = delete;
-    };
-}
diff --git a/src/bmx055/bmx055.i b/src/bmx055/bmx055.i
deleted file mode 100644
index c71695f..0000000
--- a/src/bmx055/bmx055.i
+++ /dev/null
@@ -1,65 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "../upm_javastdvector.i"
-
-%apply int {mraa::Edge};
-
-%ignore getAccelerometer(float *, float *, float *);
-%ignore getMagnetometer(float *, float *, float *);
-%ignore getGyroscope(float *, float *, float *);
-
-%typemap(javaimports) SWIGTYPE %{
-import java.util.AbstractList;
-import java.lang.Float;
-%}
-
-%typemap(javaout) SWIGTYPE {
-    return new $&javaclassname($jnicall, true);
-}
-%typemap(javaout) std::vector<float> {
-    return (AbstractList<Float>)(new $&javaclassname($jnicall, true));
-}
-%typemap(jstype) std::vector<float> "AbstractList<Float>"
-
-%template(floatVector) std::vector<float>;
-
-JAVA_JNI_LOADLIBRARY(javaupm_bmx055)
-#endif
-/* END Java syntax */
-
-/* BEGIN Javascript syntax  ------------------------------------------------- */
-#ifdef SWIGJAVASCRIPT
-%include "../upm_vectortypes.i"
-%pointer_functions(int, intp);
-%pointer_functions(float, floatp);
-#endif
-/* END Javascript syntax */
-
-/* BEGIN Python syntax  ----------------------------------------------------- */
-#ifdef SWIGPYTHON
-%include "../upm_vectortypes.i"
-%pointer_functions(int, intp);
-%pointer_functions(float, floatp);
-#endif
-/* END Python syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "bmm150_defs.h"
-#include "bmg160_defs.h"
-#include "bma250e_defs.h"
-#include "bmm150.hpp"
-#include "bmc150.hpp"
-#include "bmx055.hpp"
-#include "bmi055.hpp"
-%}
-%include "bmm150_defs.h"
-%include "bmg160_defs.h"
-%include "bma250e_defs.h"
-%include "bmm150.hpp"
-%include "bmx055.hpp"
-%include "bmi055.hpp"
-%include "bmc150.hpp"
-/* END Common SWIG syntax */
diff --git a/src/bmx055/bmx055.json b/src/bmx055/bmx055.json
deleted file mode 100644
index 6f96f40..0000000
--- a/src/bmx055/bmx055.json
+++ /dev/null
@@ -1,49 +0,0 @@
-{
-    "Library": "bmx055",
-    "Description": "BMX055 9-axis Sensor Module",
-    "Sensor Class":
-    {
-        "BMX055":
-        {
-            "Name": "BMX055 9-axis Sensor Module",
-            "Description": "The BMX055 is an integrated 9-axis sensor for the detection of movements and rotations and magnetic heading. It comprises the full functionality of a triaxial, low-g acceleration sensor, a triaxial angular rate sensor and a triaxial geomagnetic sensor. The BMX055 senses orientation, tilt, motion, acceleration, rotation, shock, vibration and heading in cell phones, handhelds, computer peripherals, man-machine interfaces, virtual reality features and game controllers. The BMX055 is essentially 3 separate devices in one: the BMA250E Accelerometer, the BMG160 Gyroscope, and the BMM150 Magnetometer. They are completely independant of each other. This driver provides a very simple interface to these 3 devices. If finer control is desired, you should just use the separate BMA25E, BMG160, and BMM150 device classes directly.  This driver simply initializes all three devices, and provides a mechanism to read accelerometer, gyroscope and magnetometer data from them.",
-            "Aliases": ["bmx055"],
-            "Categories": ["imu", "accelerometer", "gyroscope", "magnetometer"],
-            "Connections": ["gpio", "i2c", "spi"],
-            "Project Type": ["prototyping", "industrial"],
-            "Manufacturers": ["bosch"],
-            "Kits": [],
-            "Examples":
-            {
-                "Java": ["BMX055_Example.java"],
-                "Python": ["bmx055.py"],
-                "Node.js": ["bmx055.js"],
-                "C++": ["bmx055.cxx"],
-                "C": []
-            },
-            "Specifications":
-            {
-                "Vdd": {"unit": "v", "low" : 2.4, "high": 3.6},
-                "Measurement Range (Accelerometer)": {"unit": "g", "low": 2, "high": 16},
-                "Measurement Range (Gyroscope)": {"unit": "deg/s", "low": 125, "high": 2000},
-                "Measurement Range (Magnetometer)": {"unit": "LSB/uT", "typ": 3.3},
-                "Iavg": {"unit": "uA", "low" : 130, "high": 5000},
-                "Temperature Range": {"unit": "C", "low" : -40, "high": 85}
-            },
-            "Platforms":
-            {
-                "Intel Joule Module":
-                {
-                    "Notes": ["Requires pull-up resistors with carrier board"],
-                    "Images": [""]
-                }
-            },
-            "Urls" :
-            {
-                "Product Pages": ["https://www.bosch-sensortec.com/bst/products/all_products/bmx055"],
-                "Datasheets": ["https://ae-bst.resource.bosch.com/media/_tech/media/datasheets/BST-BMX055-DS000-02.pdf"],
-                "Schematics": []
-            }
-        }
-    }
-}
diff --git a/src/bno055/CMakeLists.txt b/src/bno055/CMakeLists.txt
deleted file mode 100644
index 5dc45e6..0000000
--- a/src/bno055/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-upm_mixed_module_init (NAME bno055
-    DESCRIPTION "Intelligent 9-axis Absolute Orientation Sensor"
-    C_HDR bno055.h bno055_regs.h
-    C_SRC bno055.c
-    CPP_HDR bno055.hpp
-    CPP_SRC bno055.cxx
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/bno055/bno055.c b/src/bno055/bno055.c
deleted file mode 100644
index 015877d..0000000
--- a/src/bno055/bno055.c
+++ /dev/null
@@ -1,1057 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016-2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string.h>
-#include <assert.h>
-
-#include <upm_utilities.h>
-
-#include "bno055.h"
-
-// macro for converting a uint8_t low/high pair into a float
-#define INT16_TO_FLOAT(l, h) \
-    (float)( (int16_t)( (l) | ((h) << 8) ) )
-
-
-// clear internal data items
-static void _clear_data(const bno055_context dev)
-{
-    assert(dev != NULL);
-
-    dev->magX = dev->magY = dev->magZ = 0;
-    dev->accX = dev->accY = dev->accZ = 0;
-    dev->gyrX = dev->gyrY = dev->gyrZ = 0;
-    dev->eulHeading = dev->eulRoll = dev->eulPitch = 0;
-    dev->quaW = dev->quaX = dev->quaY = dev->quaZ = 0;
-    dev->liaX = dev->liaY = dev->liaZ = 0;
-    dev->grvX = dev->grvY = dev->grvZ = 0;
-}
-
-// load fusion data
-static upm_result_t _update_fusion_data(const bno055_context dev)
-{
-    assert(dev != NULL);
-
-    // bail (with success code) if we are in config mode, or aren't in
-    // a fusion mode...
-    if (dev->currentMode == BNO055_OPERATION_MODE_CONFIGMODE ||
-        dev->currentMode < BNO055_OPERATION_MODE_IMU)
-        return UPM_SUCCESS;
-
-    if (bno055_set_page(dev, 0, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    // FIXME/MAYBE? - abort early if SYS calibration is == 0?
-
-    const int fusionBytes = 26;
-    uint8_t buf[fusionBytes];
-
-    if (bno055_read_regs(dev, BNO055_REG_EUL_HEADING_LSB, buf, fusionBytes))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    dev->eulHeading = INT16_TO_FLOAT(buf[0], buf[1]);
-    dev->eulRoll    = INT16_TO_FLOAT(buf[2], buf[3]);
-    dev->eulPitch   = INT16_TO_FLOAT(buf[4], buf[5]);
-
-    dev->quaW       = INT16_TO_FLOAT(buf[6], buf[7]);
-    dev->quaX       = INT16_TO_FLOAT(buf[8], buf[9]);
-    dev->quaY       = INT16_TO_FLOAT(buf[10], buf[11]);
-    dev->quaZ       = INT16_TO_FLOAT(buf[12], buf[13]);
-
-    dev->liaX       = INT16_TO_FLOAT(buf[14], buf[15]);
-    dev->liaY       = INT16_TO_FLOAT(buf[16], buf[17]);
-    dev->liaZ       = INT16_TO_FLOAT(buf[18], buf[19]);
-
-    dev->grvX       = INT16_TO_FLOAT(buf[20], buf[21]);
-    dev->grvY       = INT16_TO_FLOAT(buf[22], buf[23]);
-    dev->grvZ       = INT16_TO_FLOAT(buf[24], buf[25]);
-
-    return UPM_SUCCESS;
-}
-
-// update non-fusion data
-static upm_result_t _update_non_fusion_data(const bno055_context dev)
-{
-    assert(dev != NULL);
-
-    // bail (with success code) if we are in config mode...
-    if (dev->currentMode == BNO055_OPERATION_MODE_CONFIGMODE)
-        return UPM_SUCCESS;
-
-    if (bno055_set_page(dev, 0, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    const int nonFusionBytes = 18;
-    uint8_t buf[nonFusionBytes];
-
-    if (bno055_read_regs(dev, BNO055_REG_ACC_DATA_X_LSB, buf, nonFusionBytes))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    dev->accX = INT16_TO_FLOAT(buf[0], buf[1]);
-    dev->accY = INT16_TO_FLOAT(buf[2], buf[3]);
-    dev->accZ = INT16_TO_FLOAT(buf[4], buf[5]);
-
-    dev->magX = INT16_TO_FLOAT(buf[6], buf[7]);
-    dev->magY = INT16_TO_FLOAT(buf[8], buf[9]);
-    dev->magZ = INT16_TO_FLOAT(buf[10], buf[11]);
-
-    dev->gyrX = INT16_TO_FLOAT(buf[12], buf[13]);
-    dev->gyrY = INT16_TO_FLOAT(buf[14], buf[15]);
-    dev->gyrZ = INT16_TO_FLOAT(buf[16], buf[17]);
-
-    return UPM_SUCCESS;
-}
-
-// init
-bno055_context bno055_init(int bus, uint8_t addr)
-{
-    bno055_context dev =
-        (bno055_context)malloc(sizeof(struct _bno055_context));
-
-    if (!dev)
-        return NULL;
-
-    // zero out context
-    memset((void *)dev, 0, sizeof(struct _bno055_context));
-
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        bno055_close(dev);
-        return NULL;
-    }
-
-    if (!(dev->i2c = mraa_i2c_init(bus)))
-    {
-        printf("%s: mraa_i2c_init() failed.\n", __FUNCTION__);
-        bno055_close(dev);
-        return NULL;
-    }
-
-    if (mraa_i2c_address(dev->i2c, addr) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_i2c_address() failed.\n", __FUNCTION__);
-        bno055_close(dev);
-        return NULL;
-    }
-
-    _clear_data(dev);
-
-    // forcibly set page 0, so we are synced with the device
-    if (bno055_set_page(dev, 0, true))
-    {
-        printf("%s: bno055_set_page() failed.\n", __FUNCTION__);
-        bno055_close(dev);
-        return NULL;
-    }
-
-    // check the chip id.  This has to be done after forcibly setting
-    // page 0, as that is the only page where the chip id is present.
-    uint8_t chipID = 0;
-    if (bno055_get_chip_id(dev, &chipID))
-    {
-        printf("%s: Could not read chip id\n", __FUNCTION__);
-        bno055_close(dev);
-        return NULL;
-    }
-
-    if (chipID != BNO055_CHIPID)
-    {
-        printf("%s: Invalid chip ID. Expected 0x%02x, got 0x%02x\n",
-               __FUNCTION__, BNO055_CHIPID, chipID);
-        bno055_close(dev);
-        return NULL;
-    }
-
-    upm_result_t urv = UPM_SUCCESS;
-    // set config mode
-    urv += bno055_set_operation_mode(dev, BNO055_OPERATION_MODE_CONFIGMODE);
-
-    // default to internal clock
-    urv += bno055_set_clock_external(dev, false);
-
-    // we specifically avoid doing a reset so that if the device is
-    // already calibrated, it will remain so.
-
-    // we always use C for temperature
-    urv += bno055_set_temperature_units_celsius(dev);
-
-    // default to accelerometer temp
-    urv += bno055_set_temperature_source(dev, BNO055_TEMP_SOURCE_ACC);
-
-    // set accel units to m/s^2
-    urv += bno055_set_accelerometer_units(dev, false);
-
-    // set gyro units to degrees
-    urv += bno055_set_gyroscope_units(dev, false);
-
-    // set Euler units to degrees
-    urv += bno055_set_euler_units(dev, false);
-
-    // by default, we set the operating mode to the NDOF fusion mode
-    urv += bno055_set_operation_mode(dev, BNO055_OPERATION_MODE_NDOF);
-
-    // if any of those failed, bail
-    if (urv != UPM_SUCCESS)
-    {
-        printf("%s: Initial device configuration failed\n", __FUNCTION__);
-        bno055_close(dev);
-        return NULL;
-    }
-
-    return dev;
-}
-
-void bno055_close(bno055_context dev)
-{
-    assert(dev != NULL);
-
-    bno055_uninstall_isr(dev);
-
-    if (dev->i2c)
-        mraa_i2c_stop(dev->i2c);
-
-    free(dev);
-}
-
-upm_result_t bno055_update(const bno055_context dev)
-{
-    assert(dev != NULL);
-
-    if (bno055_set_page(dev, 0, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    // temperature first, always in Celsius
-    uint8_t tempreg = 0;
-    if (bno055_read_reg(dev, BNO055_REG_TEMPERATURE, &tempreg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    dev->temperature = (float)((int8_t)tempreg);
-
-    if (_update_fusion_data(dev))
-        return UPM_ERROR_OPERATION_FAILED;
-    if (_update_non_fusion_data(dev))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bno055_read_reg(const bno055_context dev, uint8_t reg,
-                             uint8_t *retval)
-{
-    assert(dev != NULL);
-
-    int rv = mraa_i2c_read_byte_data(dev->i2c, reg);
-    if (rv < 0)
-    {
-        printf("%s: mraa_i2c_read_byte_data() failed\n",
-               __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    if (retval)
-        *retval = (uint8_t)(rv & 0xff);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bno055_read_regs(const bno055_context dev, uint8_t reg,
-                              uint8_t *buffer, size_t len)
-{
-    assert(dev != NULL);
-
-    if (mraa_i2c_read_bytes_data(dev->i2c, reg, buffer, len) < 0)
-    {
-        printf("%s: mraa_i2c_read_bytes() failed\n",
-               __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bno055_write_reg(const bno055_context dev,
-                              uint8_t reg, uint8_t val)
-{
-    assert(dev != NULL);
-
-    if (mraa_i2c_write_byte_data(dev->i2c, val, reg))
-    {
-        printf("%s: mraa_i2c_write_byte_data() failed\n",
-               __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bno055_write_regs(const bno055_context dev, uint8_t reg,
-                               uint8_t *buffer, size_t len)
-{
-    assert(dev != NULL);
-
-    uint8_t buf[len + 1];
-
-    buf[0] = reg;
-    for (size_t i=0; i<len; i++)
-        buf[i+1] = buffer[i];
-
-    if (mraa_i2c_write(dev->i2c, buf, len + 1))
-    {
-        printf("%s: mraa_i2c_write() failed\n",
-               __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bno055_get_chip_id(const bno055_context dev, uint8_t *chip_id)
-{
-    assert(dev != NULL);
-
-    if (bno055_set_page(dev, 0, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return bno055_read_reg(dev, BNO055_REG_CHIP_ID, chip_id);
-}
-
-upm_result_t bno055_get_acc_id(const bno055_context dev, uint8_t *chip_id)
-{
-    assert(dev != NULL);
-
-    if (bno055_set_page(dev, 0, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return bno055_read_reg(dev, BNO055_REG_ACC_ID, chip_id);
-}
-
-upm_result_t bno055_get_mag_id(const bno055_context dev, uint8_t *chip_id)
-{
-    assert(dev != NULL);
-
-    if (bno055_set_page(dev, 0, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return bno055_read_reg(dev, BNO055_REG_MAG_ID, chip_id);
-}
-
-upm_result_t bno055_get_gyr_id(const bno055_context dev, uint8_t *chip_id)
-{
-    assert(dev != NULL);
-
-    if (bno055_set_page(dev, 0, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return bno055_read_reg(dev, BNO055_REG_GYR_ID, chip_id);
-}
-
-upm_result_t bno055_get_sw_revision(const bno055_context dev, uint16_t *sw_rev)
-{
-    assert(dev != NULL);
-
-    if (bno055_set_page(dev, 0, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t lsb = 0, msb = 0;
-    if (bno055_read_reg(dev, BNO055_REG_SW_REV_ID_LSB, &lsb))
-        return UPM_ERROR_OPERATION_FAILED;
-    if (bno055_read_reg(dev, BNO055_REG_SW_REV_ID_MSB, &msb))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if (sw_rev)
-        *sw_rev = (uint16_t)(lsb | (msb << 8));
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bno055_get_bootloader_id(const bno055_context dev, uint8_t *bl_id)
-{
-    assert(dev != NULL);
-
-    if (bno055_set_page(dev, 0, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return bno055_read_reg(dev, BNO055_REG_BL_REV_ID, bl_id);
-}
-
-upm_result_t bno055_set_page(const bno055_context dev, uint8_t page,
-                             bool force)
-{
-    assert(dev != NULL);
-
-    // page can only be 0 or 1
-    if (!(page == 0 || page == 1))
-    {
-        printf("%s: page number can only be 0 or 1.\n",
-               __FUNCTION__);
-        return UPM_ERROR_INVALID_PARAMETER;
-    }
-
-    if (force || page != dev->currentPage)
-    {
-        if (bno055_write_reg(dev, BNO055_REG_PAGE_ID, page))
-            return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    dev->currentPage = page;
-    return UPM_SUCCESS;
-}
-
-upm_result_t bno055_set_clock_external(const bno055_context dev,
-                                       bool extClock)
-{
-    assert(dev != NULL);
-
-    if (bno055_set_page(dev, 0, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    // first we need to be in config mode
-    BNO055_OPERATION_MODES_T currentMode = dev->currentMode;
-    if (bno055_set_operation_mode(dev, BNO055_OPERATION_MODE_CONFIGMODE))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t reg = 0;
-    if (bno055_read_reg(dev, BNO055_REG_SYS_TRIGGER, &reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if (extClock)
-        reg |= BNO055_SYS_TRIGGER_CLK_SEL;
-    else
-        reg &= ~BNO055_SYS_TRIGGER_CLK_SEL;
-
-    if (bno055_write_reg(dev, BNO055_REG_SYS_TRIGGER, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    // now reset our operating mode
-    if (bno055_set_operation_mode(dev, currentMode))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bno055_set_temperature_source(const bno055_context dev,
-                                           BNO055_TEMP_SOURCES_T src)
-{
-    assert(dev != NULL);
-
-    if (bno055_set_page(dev, 0, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return bno055_write_reg(dev, BNO055_REG_TEMP_SOURCE, src);
-}
-
-upm_result_t bno055_set_temperature_units_celsius(const bno055_context dev)
-{
-    assert(dev != NULL);
-
-    if (bno055_set_page(dev, 0, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t reg = 0;
-    if (bno055_read_reg(dev, BNO055_REG_UNIT_SEL, &reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    reg &= ~BNO055_UNIT_SEL_TEMP_UNIT;
-
-    return bno055_write_reg(dev, BNO055_REG_UNIT_SEL, reg);
-}
-
-upm_result_t bno055_set_accelerometer_units(const bno055_context dev, bool mg)
-{
-    assert(dev != NULL);
-
-    if (bno055_set_page(dev, 0, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t reg = 0;
-    if (bno055_read_reg(dev, BNO055_REG_UNIT_SEL, &reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if (mg)
-    {
-        reg |= BNO055_UNIT_SEL_ACC_UNIT;
-        dev->accUnitScale = 1.0;
-    }
-    else
-    {
-        reg &= ~BNO055_UNIT_SEL_ACC_UNIT;
-        dev->accUnitScale = 100.0;
-    }
-
-    return bno055_write_reg(dev, BNO055_REG_UNIT_SEL, reg);
-}
-
-upm_result_t bno055_set_gyroscope_units(const bno055_context dev, bool radians)
-{
-    assert(dev != NULL);
-
-    if (bno055_set_page(dev, 0, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t reg = 0;
-    if (bno055_read_reg(dev, BNO055_REG_UNIT_SEL, &reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if (radians)
-    {
-        reg |= BNO055_UNIT_SEL_GYR_UNIT;
-        dev->gyrUnitScale = 900.0;
-    }
-    else
-    {
-        reg &= ~BNO055_UNIT_SEL_GYR_UNIT;
-        dev->gyrUnitScale = 16.0;
-    }
-
-    return bno055_write_reg(dev, BNO055_REG_UNIT_SEL, reg);
-}
-
-upm_result_t bno055_set_euler_units(const bno055_context dev, bool radians)
-{
-    assert(dev != NULL);
-
-    if (bno055_set_page(dev, 0, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t reg = 0;
-    if (bno055_read_reg(dev, BNO055_REG_UNIT_SEL, &reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if (radians)
-    {
-        reg |= BNO055_UNIT_SEL_EUL_UNIT;
-        dev->eulUnitScale = 900.0;
-    }
-    else
-    {
-        reg &= ~BNO055_UNIT_SEL_EUL_UNIT;
-        dev->eulUnitScale = 16.0;
-    }
-
-    return bno055_write_reg(dev, BNO055_REG_UNIT_SEL, reg);
-}
-
-upm_result_t bno055_set_operation_mode(const bno055_context dev,
-                                       BNO055_OPERATION_MODES_T mode)
-{
-    assert(dev != NULL);
-
-    if (bno055_set_page(dev, 0, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    // we clear all of our loaded data on mode changes
-    _clear_data(dev);
-
-    uint8_t reg = 0;
-    if (bno055_read_reg(dev, BNO055_REG_OPER_MODE, &reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    reg &= ~(_BNO055_OPR_MODE_OPERATION_MODE_MASK
-             << _BNO055_OPR_MODE_OPERATION_MODE_SHIFT);
-
-    reg |= (mode << _BNO055_OPR_MODE_OPERATION_MODE_SHIFT);
-
-    if (bno055_write_reg(dev, BNO055_REG_OPER_MODE, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    dev->currentMode = mode;
-
-    upm_delay_us(30);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bno055_get_calibration_status(const bno055_context dev,
-                                           int *mag, int *acc,
-                                           int *gyr, int *sys)
-{
-    assert(dev != NULL);
-
-    if (bno055_set_page(dev, 0, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t reg = 0;
-    if (bno055_read_reg(dev, BNO055_REG_CALIB_STAT, &reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if (mag)
-        *mag = (reg >> _BNO055_CALIB_STAT_MAG_SHIFT)
-            & _BNO055_CALIB_STAT_MAG_MASK;
-
-    if (acc)
-        *acc = (reg >> _BNO055_CALIB_STAT_ACC_SHIFT)
-            & _BNO055_CALIB_STAT_ACC_MASK;
-
-    if (gyr)
-        *gyr = (reg >> _BNO055_CALIB_STAT_GYR_SHIFT)
-            & _BNO055_CALIB_STAT_GYR_MASK;
-
-    if (sys)
-        *sys = (reg >> _BNO055_CALIB_STAT_SYS_SHIFT)
-            & _BNO055_CALIB_STAT_SYS_MASK;
-
-    return UPM_SUCCESS;
-}
-
-bool bno055_is_fully_calibrated(const bno055_context dev)
-{
-    assert(dev != NULL);
-
-    int mag, acc, gyr, sys;
-
-    // fail on error
-    if (bno055_get_calibration_status(dev, &mag, &acc, &gyr, &sys))
-        return false;
-
-    // all of them equal to 3 means fully calibrated
-    if (mag == 3 && acc == 3 && gyr == 3 && sys == 3)
-        return true;
-    else
-        return false;
-}
-
-upm_result_t bno055_reset_system(const bno055_context dev)
-{
-    assert(dev != NULL);
-
-    if (bno055_set_page(dev, 0, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t reg = 0;
-    if (bno055_read_reg(dev, BNO055_REG_SYS_TRIGGER, &reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    reg |= BNO055_SYS_TRIGGER_RST_SYS;
-
-    if (bno055_write_reg(dev, BNO055_REG_SYS_TRIGGER, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    upm_delay(1);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bno055_reset_interrupt_status(const bno055_context dev)
-{
-    assert(dev != NULL);
-
-    if (bno055_set_page(dev, 0, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t reg = 0;
-    if (bno055_read_reg(dev, BNO055_REG_SYS_TRIGGER, &reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    reg |= BNO055_SYS_TRIGGER_RST_INT;
-
-    return bno055_write_reg(dev, BNO055_REG_SYS_TRIGGER, reg);
-}
-
-upm_result_t bno055_get_interrupt_status(const bno055_context dev,
-                                         uint8_t *istat)
-{
-    assert(dev != NULL);
-
-    if (bno055_set_page(dev, 0, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return bno055_read_reg(dev, BNO055_REG_INT_STA, istat);
-}
-
-upm_result_t bno055_get_interrupt_enable(const bno055_context dev,
-                                         uint8_t *ienable)
-{
-    assert(dev != NULL);
-
-    if (bno055_set_page(dev, 1, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return bno055_read_reg(dev, BNO055_REG_INT_EN, ienable);
-}
-
-upm_result_t bno055_set_interrupt_enable(const bno055_context dev,
-                                         uint8_t enables)
-{
-    assert(dev != NULL);
-
-    if (bno055_set_page(dev, 1, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return bno055_write_reg(dev, BNO055_REG_INT_EN, enables);
-}
-
-upm_result_t bno055_get_interrupt_mask(const bno055_context dev,
-                                       uint8_t *imask)
-{
-    assert(dev != NULL);
-
-    if (bno055_set_page(dev, 1, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return bno055_read_reg(dev, BNO055_REG_INT_MSK, imask);
-}
-
-upm_result_t bno055_set_interrupt_mask(const bno055_context dev, uint8_t mask)
-{
-    assert(dev != NULL);
-
-    if (bno055_set_page(dev, 1, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return bno055_write_reg(dev, BNO055_REG_INT_MSK, mask);
-}
-
-upm_result_t bno055_get_system_status(const bno055_context dev,
-    BNO055_SYS_STATUS_T *sys_stat)
-{
-    assert(dev != NULL);
-
-    if (bno055_set_page(dev, 0, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t reg = 0;
-    if (bno055_read_reg(dev, BNO055_REG_SYS_STATUS, &reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if (sys_stat)
-        *sys_stat = (BNO055_SYS_STATUS_T)reg;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bno055_get_system_error(const bno055_context dev,
-                                     BNO055_SYS_ERR_T *sys_err)
-{
-    assert(dev != NULL);
-
-    if (bno055_set_page(dev, 0, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t reg = 0;
-    if (bno055_read_reg(dev, BNO055_REG_SYS_ERROR, &reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if (sys_err)
-        *sys_err = (BNO055_SYS_ERR_T)reg;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bno055_read_calibration_data(const bno055_context dev,
-                                          uint8_t *data, size_t len)
-{
-    assert(dev != NULL);
-    assert(data != NULL);
-
-    if (!bno055_is_fully_calibrated(dev))
-    {
-        printf("%s: Sensor must be fully calibrated first.\n",
-               __FUNCTION__);
-        return UPM_ERROR_NO_DATA;
-    }
-
-    if (len != BNO055_CALIBRATION_DATA_SIZE)
-    {
-        printf("%s: len must equal BNO055_CALIBRATION_DATA_SIZE (%d).\n",
-               __FUNCTION__, BNO055_CALIBRATION_DATA_SIZE);
-        return UPM_ERROR_INVALID_SIZE;
-    }
-
-    // should be at page 0, but lets make sure
-    if (bno055_set_page(dev, 0, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    // first we need to go back into config mode
-    BNO055_OPERATION_MODES_T currentMode = dev->currentMode;
-    if (bno055_set_operation_mode(dev, BNO055_OPERATION_MODE_CONFIGMODE))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if (bno055_read_regs(dev, BNO055_REG_ACC_OFFSET_X_LSB, data,
-                         BNO055_CALIBRATION_DATA_SIZE))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    // now reset our operating mode
-    if (bno055_set_operation_mode(dev, currentMode))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t bno055_write_calibration_data(const bno055_context dev,
-                                           uint8_t *data,
-                                           size_t len)
-{
-    assert(dev != NULL);
-    assert(data != NULL);
-
-    if (len != BNO055_CALIBRATION_DATA_SIZE)
-    {
-        printf("%s: len must equal BNO055_CALIBRATION_DATA_SIZE "
-               "(expected %d, got %d).\n",
-               __FUNCTION__, BNO055_CALIBRATION_DATA_SIZE, (int)len);
-        return UPM_ERROR_INVALID_SIZE;
-    }
-
-    // should be at page 0, but lets make sure
-    if (bno055_set_page(dev, 0, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    // first we need to go back into config mode
-    BNO055_OPERATION_MODES_T currentMode = dev->currentMode;
-    if (bno055_set_operation_mode(dev, BNO055_OPERATION_MODE_CONFIGMODE))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    // write the data
-    if (bno055_write_regs(dev, BNO055_REG_ACC_OFFSET_X_LSB, data,
-                          BNO055_CALIBRATION_DATA_SIZE))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    // now reset our operating mode
-    if (bno055_set_operation_mode(dev, currentMode))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-float bno055_get_temperature(const bno055_context dev)
-{
-    assert(dev != NULL);
-
-    return dev->temperature;
-}
-
-void bno055_get_euler_angles(const bno055_context dev, float *heading,
-                             float *roll, float *pitch)
-{
-    assert(dev != NULL);
-
-    if (heading)
-        *heading = dev->eulHeading / dev->eulUnitScale;
-
-    if (roll)
-        *roll = dev->eulRoll / dev->eulUnitScale;
-
-    if (pitch)
-        *pitch = dev->eulPitch / dev->eulUnitScale;
-}
-
-void bno055_get_quaternions(const bno055_context dev, float *w, float *x,
-                            float *y, float *z)
-{
-    assert(dev != NULL);
-
-    // from the datasheet
-    const float scale = (float)(1.0 / (float)(1 << 14));
-
-    if (w)
-        *w = dev->quaW * scale;
-
-    if (x)
-        *x = dev->quaX * scale;
-
-    if (y)
-        *y = dev->quaY * scale;
-
-    if (z)
-        *z = dev->quaZ * scale;
-}
-
-void bno055_get_linear_acceleration(const bno055_context dev, float *x,
-                                    float *y, float *z)
-{
-    assert(dev != NULL);
-
-    if (x)
-        *x = dev->liaX / dev->accUnitScale;
-
-    if (y)
-        *y = dev->liaY / dev->accUnitScale;
-
-    if (z)
-        *z = dev->liaZ / dev->accUnitScale;
-}
-
-void bno055_get_gravity_vectors(const bno055_context dev,
-                                float *x, float *y, float *z)
-{
-    assert(dev != NULL);
-
-    if (x)
-        *x = dev->grvX / dev->accUnitScale;
-
-    if (y)
-        *y = dev->grvY / dev->accUnitScale;
-
-    if (z)
-        *z = dev->grvZ / dev->accUnitScale;
-}
-
-void bno055_get_accelerometer(const bno055_context dev, float *x, float *y,
-                              float *z)
-{
-    assert(dev != NULL);
-
-    if (x)
-        *x = dev->accX / dev->accUnitScale;
-
-    if (y)
-        *y = dev->accY / dev->accUnitScale;
-
-    if (z)
-        *z = dev->accZ / dev->accUnitScale;
-}
-
-void bno055_get_magnetometer(const bno055_context dev, float *x, float *y,
-                             float *z)
-{
-    assert(dev != NULL);
-
-    // from the datasheet - 16 uT's per LSB
-    const float scale = 16.0;
-
-    if (x)
-        *x = dev->magX / scale;
-
-    if (y)
-        *y = dev->magY / scale;
-
-    if (z)
-        *z = dev->magZ / scale;
-}
-
-void bno055_get_gyroscope(const bno055_context dev,
-                          float *x, float *y, float *z)
-{
-    assert(dev != NULL);
-
-    if (x)
-        *x = dev->gyrX / dev->gyrUnitScale;
-
-    if (y)
-        *y = dev->gyrY / dev->gyrUnitScale;
-
-    if (z)
-        *z = dev->gyrZ / dev->gyrUnitScale;
-}
-
-upm_result_t bno055_set_acceleration_config(const bno055_context dev,
-                                            BNO055_ACC_RANGE_T range,
-                                            BNO055_ACC_BW_T bw,
-                                            BNO055_ACC_PWR_MODE_T pwr)
-{
-    assert(dev != NULL);
-
-    if (bno055_set_page(dev, 1, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t reg = ((range << _BNO055_ACC_CONFIG_ACC_RANGE_SHIFT)
-                   | (bw << _BNO055_ACC_CONFIG_ACC_BW_SHIFT)
-                   | (pwr << _BNO055_ACC_CONFIG_ACC_PWR_MODE_SHIFT));
-
-    return bno055_write_reg(dev, BNO055_REG_ACC_CONFIG, reg);
-}
-
-upm_result_t bno055_set_magnetometer_config(const bno055_context dev,
-                                            BNO055_MAG_ODR_T odr,
-                                            BNO055_MAG_OPR_T opr,
-                                            BNO055_MAG_POWER_T pwr)
-{
-    assert(dev != NULL);
-
-    if (bno055_set_page(dev, 1, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t reg = ((odr << _BNO055_MAG_CONFIG_MAG_ODR_SHIFT)
-                   | (opr << _BNO055_MAG_CONFIG_MAG_OPR_MODE_SHIFT)
-                   | (pwr << _BNO055_MAG_CONFIG_MAG_POWER_MODE_SHIFT));
-
-    return bno055_write_reg(dev, BNO055_REG_MAG_CONFIG, reg);
-}
-
-upm_result_t bno055_set_gyroscope_config(const bno055_context dev,
-                                         BNO055_GYR_RANGE_T range,
-                                         BNO055_GYR_BW_T bw,
-                                         BNO055_GYR_POWER_MODE_T pwr)
-{
-    assert(dev != NULL);
-
-    if (bno055_set_page(dev, 1, false))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t reg = ((range << _BNO055_GYR_CONFIG0_GYR_RANGE_SHIFT)
-                   | (bw << _BNO055_GYR_CONFIG0_GYR_BW_SHIFT));
-
-    if (bno055_write_reg(dev, BNO055_REG_GYR_CONFIG0, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    reg = (pwr << _BNO055_GYR_CONFIG1_GYR_POWER_MODE_SHIFT);
-
-    return bno055_write_reg(dev, BNO055_REG_GYR_CONFIG1, reg);
-}
-
-upm_result_t bno055_install_isr(const bno055_context dev,
-                                int gpio, mraa_gpio_edge_t level,
-                                void (*isr)(void *), void *arg)
-{
-    assert(dev != NULL);
-
-    // delete any existing ISR and GPIO context
-    bno055_uninstall_isr(dev);
-
-    // create gpio context
-    if (!(dev->gpio = mraa_gpio_init(gpio)))
-    {
-        printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    mraa_gpio_dir(dev->gpio, MRAA_GPIO_IN);
-
-    if (mraa_gpio_isr(dev->gpio, level, isr, arg))
-    {
-        mraa_gpio_close(dev->gpio);
-        dev->gpio = NULL;
-        printf("%s: mraa_gpio_isr() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-void bno055_uninstall_isr(const bno055_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->gpio)
-    {
-        mraa_gpio_isr_exit(dev->gpio);
-        mraa_gpio_close(dev->gpio);
-        dev->gpio = NULL;
-    }
-}
diff --git a/src/bno055/bno055.cxx b/src/bno055/bno055.cxx
deleted file mode 100644
index 2f9a53f..0000000
--- a/src/bno055/bno055.cxx
+++ /dev/null
@@ -1,453 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016-17 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <stdexcept>
-
-#include "bno055.hpp"
-
-using namespace upm;
-using namespace std;
-
-// conversion from Celsius to Fahrenheit
-
-static float c2f(float c)
-{
-    return (c * (9.0 / 5.0) + 32.0);
-}
-
-BNO055::BNO055(int bus, uint8_t addr) :
-    m_bno055(bno055_init(bus, addr))
-{
-    if (!m_bno055)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_init() failed");
-}
-
-BNO055::~BNO055()
-{
-    bno055_close(m_bno055);
-}
-
-void BNO055::update()
-{
-    if (bno055_update(m_bno055))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_update() failed");
-}
-
-uint8_t BNO055::readReg(uint8_t reg)
-{
-    uint8_t rv = 0;
-    if (bno055_read_reg(m_bno055, reg, &rv))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_read_reg() failed");
-
-    return rv;
-}
-
-void BNO055::readRegs(uint8_t reg, uint8_t *buffer, int len)
-{
-    if (bno055_read_regs(m_bno055, reg, buffer, len))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_read_regs() failed");
-}
-
-void BNO055::writeReg(uint8_t reg, uint8_t val)
-{
-    if (bno055_write_reg(m_bno055, reg, val))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_write_reg() failed");
-}
-
-void BNO055::writeRegs(uint8_t reg, uint8_t *buffer, int len)
-{
-    if (bno055_write_regs(m_bno055, reg, buffer, len))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_write_regs() failed");
-}
-
-uint8_t BNO055::getChipID()
-{
-    uint8_t rv = 0;
-    if (bno055_get_chip_id(m_bno055, &rv))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_get_chip_id() failed");
-
-    return rv;
-}
-
-uint8_t BNO055::getACCID()
-{
-    uint8_t rv = 0;
-    if (bno055_get_acc_id(m_bno055, &rv))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_get_acc_id() failed");
-
-    return rv;
-}
-
-uint8_t BNO055::getMAGID()
-{
-    uint8_t rv = 0;
-    if (bno055_get_mag_id(m_bno055, &rv))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_get_mag_id() failed");
-
-    return rv;
-}
-
-uint8_t BNO055::getGYRID()
-{
-    uint8_t rv = 0;
-    if (bno055_get_gyr_id(m_bno055, &rv))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_get_gyr_id() failed");
-
-    return rv;
-}
-
-uint16_t BNO055::getSWRevID()
-{
-    uint16_t rv = 0;
-    if (bno055_get_sw_revision(m_bno055, &rv))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_get_sw_revision() failed");
-
-    return rv;
-}
-
-uint8_t BNO055::getBootLoaderID()
-{
-    uint8_t rv = 0;
-    if (bno055_get_bootloader_id(m_bno055, &rv))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_get_bootloader_id() failed");
-
-    return rv;
-}
-
-void BNO055::setPage(uint8_t page, bool force)
-{
-    if (bno055_set_page(m_bno055, page, force))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_set_page() failed");
-}
-
-void BNO055::setClockExternal(bool extClock)
-{
-    if (bno055_set_clock_external(m_bno055, extClock))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_set_clock_external() failed");
-}
-
-void BNO055::setTemperatureSource(BNO055_TEMP_SOURCES_T src)
-{
-    if (bno055_set_temperature_source(m_bno055, src))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_set_temperature_source() failed");
-}
-
-void BNO055::setAccelerometerUnits(bool mg)
-{
-    if (bno055_set_accelerometer_units(m_bno055, mg))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_set_accelerometer_units() failed");
-}
-
-void BNO055::setGyroscopeUnits(bool radians)
-{
-    if (bno055_set_gyroscope_units(m_bno055, radians))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_set_gyroscope_units() failed");
-}
-
-void BNO055::setEulerUnits(bool radians)
-{
-    if (bno055_set_euler_units(m_bno055, radians))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_set_euler_units() failed");
-}
-
-void BNO055::setOperationMode(BNO055_OPERATION_MODES_T mode)
-{
-    if (bno055_set_operation_mode(m_bno055, mode))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_set_operation_mode() failed");
-}
-
-void BNO055::getCalibrationStatus(int *mag, int *acc, int *gyr, int *sys)
-{
-    if (bno055_get_calibration_status(m_bno055, mag, acc, gyr, sys))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_get_calibration_status() failed");
-}
-
-vector<int> BNO055::getCalibrationStatus()
-{
-    int v[4]; // mag, acc, gyr, sys;
-
-    getCalibrationStatus(&v[0], &v[1], &v[2], &v[3]);
-    return vector<int>(v, v+4);
-}
-
-bool BNO055::isFullyCalibrated()
-{
-    return bno055_is_fully_calibrated(m_bno055);
-}
-
-void BNO055::resetSystem()
-{
-    if (bno055_reset_system(m_bno055))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_reset_system() failed");
-}
-
-void BNO055::resetInterruptStatus()
-{
-    if (bno055_reset_interrupt_status(m_bno055))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": reset_interrupt_status() failed");
-}
-
-uint8_t BNO055::getInterruptStatus()
-{
-    uint8_t rv = 0;
-    if (bno055_get_interrupt_status(m_bno055, &rv))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055get_interrupt_status() failed");
-
-    return rv;
-}
-
-uint8_t BNO055::getInterruptEnable()
-{
-    uint8_t rv = 0;
-    if (bno055_get_interrupt_enable(m_bno055, &rv))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_get_interrupt_enable() failed");
-
-    return rv;
-}
-
-void BNO055::setInterruptEnable(uint8_t enables)
-{
-    if (bno055_set_interrupt_enable(m_bno055, enables))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_set_interrupt_enable() failed");
-}
-
-uint8_t BNO055::getInterruptMask()
-{
-    uint8_t rv = 0;
-    if (bno055_get_interrupt_mask(m_bno055, &rv))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_get_interrupt_mask() failed");
-
-    return rv;
-}
-
-void BNO055::setInterruptMask(uint8_t mask)
-{
-    if (bno055_set_interrupt_mask(m_bno055, mask))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_set_interrupt_mask() failed");
-}
-
-BNO055_SYS_STATUS_T BNO055::getSystemStatus()
-{
-    BNO055_SYS_STATUS_T rv;
-    if (bno055_get_system_status(m_bno055, &rv))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_get_system_status() failed");
-
-    return rv;
-}
-
-BNO055_SYS_ERR_T BNO055::getSystemError()
-{
-    BNO055_SYS_ERR_T rv;
-    if (bno055_get_system_error(m_bno055, &rv))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_get_system_error() failed");
-
-    return rv;
-}
-
-std::vector<uint8_t> BNO055::readCalibrationData()
-{
-    uint8_t calibrationData[BNO055_CALIBRATION_DATA_SIZE];
-
-    if (bno055_read_calibration_data(m_bno055, calibrationData,
-                                     BNO055_CALIBRATION_DATA_SIZE))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_read_calibration_data() failed");
-
-    return vector<uint8_t>(calibrationData,
-                           calibrationData+BNO055_CALIBRATION_DATA_SIZE);
-}
-
-void BNO055::writeCalibrationData(vector<uint8_t> calibrationData)
-{
-    if (bno055_write_calibration_data(m_bno055, calibrationData.data(),
-                                      calibrationData.size()))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_write_calibration_data() failed");
-}
-
-float BNO055::getTemperature(bool fahrenheit)
-{
-    float temperature = bno055_get_temperature(m_bno055);
-
-    if (fahrenheit)
-        return c2f(temperature);
-    else
-        return temperature;
-}
-
-void BNO055::getEulerAngles(float *heading, float *roll, float *pitch)
-{
-    bno055_get_euler_angles(m_bno055, heading, roll, pitch);
-}
-
-vector<float> BNO055::getEulerAngles()
-{
-    float v[3];
-    getEulerAngles(&v[0], &v[1], &v[2]);
-    return vector<float>(v, v+3);
-}
-
-void BNO055::getQuaternions(float *w, float *x, float *y, float *z)
-{
-    bno055_get_quaternions(m_bno055, w, x, y, z);
-}
-
-vector<float> BNO055::getQuaternions()
-{
-    float v[4];
-    getQuaternions(&v[0], &v[1], &v[2], &v[3]);
-    return vector<float>(v, v+4);
-}
-
-void BNO055::getLinearAcceleration(float *x, float *y, float *z)
-{
-    bno055_get_linear_acceleration(m_bno055, x, y, z);
-}
-
-vector<float> BNO055::getLinearAcceleration()
-{
-    float v[3];
-    getLinearAcceleration(&v[0], &v[1], &v[2]);
-    return vector<float>(v, v+3);
-}
-
-void BNO055::getGravityVectors(float *x, float *y, float *z)
-{
-    bno055_get_gravity_vectors(m_bno055, x, y, z);
-}
-
-vector<float> BNO055::getGravityVectors()
-{
-    static float v[3];
-    getGravityVectors(&v[0], &v[1], &v[2]);
-    return vector<float>(v, v+3);
-}
-
-void BNO055::getAccelerometer(float *x, float *y, float *z)
-{
-    bno055_get_accelerometer(m_bno055, x, y, z);
-}
-
-vector<float> BNO055::getAccelerometer()
-{
-    static float v[3];
-    getAccelerometer(&v[0], &v[1], &v[2]);
-    return vector<float>(v, v+3);
-}
-
-void BNO055::getMagnetometer(float *x, float *y, float *z)
-{
-    bno055_get_magnetometer(m_bno055, x, y, z);
-}
-
-vector<float> BNO055::getMagnetometer()
-{
-    float v[3];
-    getMagnetometer(&v[0], &v[1], &v[2]);
-    return vector<float>(v, v+3);
-}
-
-void BNO055::getGyroscope(float *x, float *y, float *z)
-{
-    bno055_get_gyroscope(m_bno055, x, y, z);
-}
-
-vector<float> BNO055::getGyroscope()
-{
-    float v[3];
-    getGyroscope(&v[0], &v[1], &v[2]);
-    return vector<float>(v, v+3);
-}
-
-void BNO055::setAccelerationConfig(BNO055_ACC_RANGE_T range,
-                                   BNO055_ACC_BW_T bw,
-                                   BNO055_ACC_PWR_MODE_T pwr)
-{
-    if (bno055_set_acceleration_config(m_bno055, range, bw, pwr))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_set_acceleration_config() failed");
-}
-
-void BNO055::setMagnetometerConfig(BNO055_MAG_ODR_T odr,
-                                   BNO055_MAG_OPR_T opr,
-                                   BNO055_MAG_POWER_T pwr)
-{
-    if (bno055_set_magnetometer_config(m_bno055, odr, opr, pwr))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_set_magnetometer_config() failed");
-}
-
-void BNO055::setGyroscopeConfig(BNO055_GYR_RANGE_T range,
-                                BNO055_GYR_BW_T bw,
-                                BNO055_GYR_POWER_MODE_T pwr)
-{
-    if (bno055_set_gyroscope_config(m_bno055, range, bw, pwr))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_set_gyroscope_config() failed");
-}
-
-void BNO055::installISR(int gpio, mraa_gpio_edge_t level,
-                        void (*isr)(void *), void *arg)
-{
-    if (bno055_install_isr(m_bno055, gpio, level, isr, arg))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": bno055_install_isr() failed");
-}
-
-void BNO055::uninstallISR()
-{
-    bno055_uninstall_isr(m_bno055);
-}
diff --git a/src/bno055/bno055.h b/src/bno055/bno055.h
deleted file mode 100644
index 38244a5..0000000
--- a/src/bno055/bno055.h
+++ /dev/null
@@ -1,717 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <stdlib.h>
-#include <unistd.h>
-#include <stdio.h>
-#include <upm.h>
-
-#include <mraa/i2c.h>
-#include <mraa/gpio.h>
-
-#include "bno055_regs.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    /**
-     * @file bno055.h
-     * @library bno055
-     * @brief C API for the bno055 driver
-     *
-     * @include bno055.c
-     */
-
-    /**
-     * Device context
-     */
-    typedef struct _bno055_context {
-        mraa_i2c_context i2c;
-        mraa_gpio_context gpio;
-
-        // always stored in C
-        float temperature;
-
-        int currentPage;
-        BNO055_OPERATION_MODES_T currentMode;
-
-        // uncompensated data
-
-        // mag data
-        float magX;
-        float magY;
-        float magZ;
-
-        // acc data
-        float accX;
-        float accY;
-        float accZ;
-
-        // acc units
-        float accUnitScale;
-
-        // gyr data
-        float gyrX;
-        float gyrY;
-        float gyrZ;
-
-        // gyr units
-        float gyrUnitScale;
-
-        // eul (euler angle) data
-        float eulHeading;
-        float eulRoll;
-        float eulPitch;
-
-        // eul units
-        float eulUnitScale;
-
-        // qua (quaternion) data
-        float quaW;
-        float quaX;
-        float quaY;
-        float quaZ;
-
-        // lia (linear acceleration) data
-        float liaX;
-        float liaY;
-        float liaZ;
-
-        // grv (gravity vector) data
-        float grvX;
-        float grvY;
-        float grvZ;
-    } *bno055_context;
-
-    /**
-     * BNO055 initialization.
-     *
-     * By default, this function sets the acceleration units to m/s^2,
-     * gyro and Euler units to degrees, and temperature to celsius.
-     * It then enters the NDOF fusion mode.
-     *
-     * In addition, the internal clock is used so that compatibility
-     * with other implementations is assured.  If you are using a
-     * device with an external clock, call setClockExternal(true) to
-     * enable it.
-     *
-     * @param bus I2C bus to use.
-     * @param address The I2C address for this device.
-     * @return The device context, or NULL if an error occurred.
-     */
-    bno055_context bno055_init(int bus, uint8_t addr);
-
-    /**
-     * BNO055 close function.
-     *
-     * @param dev The device context.
-     */
-    void bno055_close(bno055_context dev);
-
-    /**
-     * Update the internal stored values from sensor data.
-     *
-     * @param dev The device context.
-     * @return UPM result.
-     */
-    upm_result_t bno055_update(const bno055_context dev);
-
-    /**
-     * Return the chip ID.
-     *
-     * @param dev The device context.
-     * @param chip_id The chip ID (BNO055_CHIPID).
-     * @return UPM result.
-     */
-    upm_result_t bno055_get_chip_id(const bno055_context dev,
-                                    uint8_t *chip_id);
-
-    /**
-     * Return the accelerometer chip ID.
-     *
-     * @param dev The device context.
-     * @param chip_id The chip ID
-     * @return UPM result.
-     */
-    upm_result_t bno055_get_acc_id(const bno055_context dev,
-                                   uint8_t *chip_id);
-
-    /**
-     * Return the magnetometer chip ID.
-     *
-     * @param dev The device context.
-     * @param chip_id The chip ID
-     * @return UPM result.
-     */
-    upm_result_t bno055_get_mag_id(const bno055_context dev,
-                                   uint8_t *chip_id);
-
-    /**
-     * Return the gyroscope chip ID.
-     *
-     * @param dev The device context.
-     * @param chip_id The chip ID
-     * @return UPM result.
-     */
-    upm_result_t bno055_get_gyr_id(const bno055_context dev,
-                                   uint8_t *chip_id);
-
-    /**
-     * Return the fusion firmware revison.
-     *
-     * @param dev The device context.
-     * @param sw_rev The firmware revison.
-     * @return UPM result.
-     */
-    upm_result_t bno055_get_sw_revision(const bno055_context dev,
-                                        uint16_t *sw_rev);
-
-    /**
-     * Return the bootloader ID.
-     *
-     * @param dev The device context.
-     * @param bl_id The bootloader ID.
-     * @return UPM result.
-     */
-    upm_result_t bno055_get_bootloader_id(const bno055_context dev,
-                                          uint8_t *bl_id);
-
-    /**
-     * Enable or disables the use of the external clock.  The Adafriut
-     * device does contain an external clock which might be more
-     * stable.  By default, the internal clock is used.
-     *
-     * @param dev The device context.
-     * @param extClock true to use external clock, false otherwise.
-     * @return UPM result.
-     */
-    upm_result_t bno055_set_clock_external(const bno055_context dev,
-                                           bool extClock);
-
-    /**
-     * Select the temperature source.  This can be the accelerometer
-     * or the gyroscope.  By default, the accelerometer temperature is
-     * used as the source.
-     *
-     * @param dev The device context.
-     * @param src One of the TEMP_SOURCES_T values.
-     * @return UPM result.
-     */
-    upm_result_t bno055_set_temperature_source(const bno055_context dev,
-                                               BNO055_TEMP_SOURCES_T src);
-
-    /**
-     * Set the temperature units of the device to Celsius (always).
-     *
-     * @param dev The device context.
-     * @return UPM result.
-     */
-    upm_result_t bno055_set_temperature_units_celsius(const bno055_context dev);
-
-    /**
-     * Set the operating mode for the device.  This places the device
-     * into a config mode, one of 7 non-fusion modes, or one of 5
-     * fusion modes.  All stored sensor data is cleared when switching
-     * modes.  The device must be in config mode for most
-     * configuration operations.  See the datasheet for details.
-     *
-     * @param dev The device context.
-     * @param mode One of the OPERATION_MODES_T values.
-     * @return UPM result.
-     */
-    upm_result_t bno055_set_operation_mode(const bno055_context dev,
-                                           BNO055_OPERATION_MODES_T mode);
-
-    /**
-     * Reboot the sensor.  This is equivalent to a power on reset.
-     * All calibration data will be lost, and the device must be
-     * re-calibrated.
-     *
-     * @param dev The device context.
-     * @return UPM result.
-     */
-    upm_result_t bno055_reset_system(const bno055_context dev);
-
-    /**
-     * Read the calibration status registers and return them.  The
-     * values range from 0 (uncalibrated) to 3 (fully calibrated).
-     *
-     * @param dev The device context.
-     * @param mag The calibration status of the magnetometer.
-     * @param acc The calibration status of the accelerometer.
-     * @param mag The calibration status of the gyroscope.
-     * @param mag The calibration status of the overall system.
-     * @return UPM result.
-     */
-    upm_result_t bno055_get_calibration_status(const bno055_context dev,
-                                               int *mag, int *acc,
-                                               int *gyr, int *sys);
-
-    /**
-     * Read the calibration status registers and return true or false,
-     * indicating whether all of the calibration parameters are fully
-     * calibrated.
-     *
-     * @param dev The device context.
-     * @return true if all 4 calibration parameters are fully
-     * calibrated, else false.
-     */
-    bool bno055_is_fully_calibrated(const bno055_context dev);
-
-    /**
-     * Read the calibration data and place it into a buffer.  The
-     * buffer must be BNO055_CALIBRATION_DATA_SIZE bytes in size.
-     * This data can then be saved for later reuse by
-     * bno055_write_calibration_data() to restore calibration data
-     * after a reset.  Note: bno055_is_fully_calibrated() (calibration
-     * is complete) must be true or an error will result.
-     *
-     * @param dev The device context.
-     * @param data A pointer to a buffer to hold the calibration data.
-     * This buffer must be BNO055_CALIBRATION_DATA_SIZE bytes in
-     * length.
-     * @param len The length of the buffer.  An error will be returned
-     * if the length is not equal to BNO055_CALIBRATION_DATA_SIZE.
-     * @return UPM result.
-     */
-    upm_result_t bno055_read_calibration_data(const bno055_context dev,
-                                              uint8_t *data, size_t len);
-
-    /**
-     * Write previously saved calibration data to the calibration
-     * registers.  The array containing the data must be
-     * BNO055_CALIBRATION_DATA_SIZE bytes in size.
-     *
-     * @param dev The device context.
-     * @param data uint8_t array representing calibration data, as obtained
-     * by bno055_read_calibration_data().
-     * @param len The length of the supplied buffer.  An error will be
-     * returned if the length is not equal to BNO055_CALIBRATION_DATA_SIZE.
-     * @return UPM result.
-     */
-    upm_result_t bno055_write_calibration_data(const bno055_context dev,
-                                               uint8_t *data,
-                                               size_t len);
-
-    /**
-     * Return the current measured temperature.  Note, this is not
-     * ambient temperature - this is the temperature of the selected
-     * source on the chip.  update() must have been called prior to
-     * calling this method.
-     *
-     * @param dev The device context.
-     * @return The temperature in degrees Celsius.
-     */
-    float bno055_get_temperature(const bno055_context dev);
-
-    /**
-     * Return current orientation fusion data in the form of Euler
-     * Angles.  By default, the returned values are in degrees.
-     * update() must have been called prior to calling this method.
-     *
-     * @param dev The device context.
-     * @param heading Pointer to a floating point value that will have
-     * the current heading angle placed into it.
-     * @param roll Pointer to a floating point value that will have
-     * the current roll angle placed into it.
-     * @param pitch Pointer to a floating point value that will have
-     * the current pitch angle placed into it.
-     */
-    void bno055_get_euler_angles(const bno055_context dev, float *heading,
-                                 float *roll, float *pitch);
-
-    /**
-     * Return current orientation fusion data in the form of
-     * Quaternions.  update() must have been called prior to calling
-     * this method.
-     *
-     * @param dev The device context.
-     * @param w Pointer to a floating point value that will have
-     * the current w component placed into it.
-     * @param x Pointer to a floating point value that will have
-     * the current x component placed into it.
-     * @param y Pointer to a floating point value that will have
-     * the current y component placed into it.
-     * @param z Pointer to a floating point value that will have
-     * the current z component placed into it.
-     */
-    void bno055_get_quaternions(const bno055_context dev, float *w, float *x,
-                                float *y, float *z);
-
-    /**
-     * Return current orientation fusion data in the form of Linear
-     * Acceleration.  By default the returned values are in meters
-     * per-second squared (m/s^2).  update() must have been called
-     * prior to calling this method.
-     *
-     * @param dev The device context.
-     * @param x Pointer to a floating point value that will have
-     * the current x component placed into it.
-     * @param y Pointer to a floating point value that will have
-     * the current y component placed into it.
-     * @param z Pointer to a floating point value that will have
-     * the current z component placed into it.
-     */
-    void bno055_get_linear_acceleration(const bno055_context dev, float *x,
-                                        float *y, float *z);
-
-    /**
-     * Return current orientation fusion data in the form of a Gravity
-     * Vector per-axis.  By default the returned values are in meters
-     * per-second squared (m/s^2).  update() must have been called
-     * prior to calling this method.
-     *
-     * @param dev The device context.
-     * @param x Pointer to a floating point value that will have
-     * the current x component placed into it.
-     * @param y Pointer to a floating point value that will have
-     * the current y component placed into it.
-     * @param z Pointer to a floating point value that will have
-     * the current z component placed into it.
-     */
-    void bno055_get_gravity_vectors(const bno055_context dev,
-                                    float *x, float *y, float *z);
-
-    /**
-     * Return accelerometer data (non-fusion).  In fusion modes, this
-     * data will be of little value.  By default the returned values
-     * are in meters per-second squared (m/s^2).  update() must have
-     * been called prior to calling this method.
-     *
-     * @param dev The device context.
-     * @param x Pointer to a floating point value that will have
-     * the current x component placed into it.
-     * @param y Pointer to a floating point value that will have
-     * the current y component placed into it.
-     * @param z Pointer to a floating point value that will have
-     * the current z component placed into it.
-     */
-    void bno055_get_accelerometer(const bno055_context dev, float *x, float *y,
-                                  float *z);
-
-    /**
-     * Return magnetometer data (non-fusion).  In fusion modes, this
-     * data will be of little value.  The returned values are in
-     * micro-teslas (uT).  update() must have been called prior to
-     * calling this method.
-     *
-     * @param dev The device context.
-     * @param x Pointer to a floating point value that will have
-     * the current x component placed into it.
-     * @param y Pointer to a floating point value that will have
-     * the current y component placed into it.
-     * @param z Pointer to a floating point value that will have
-     * the current z component placed into it.
-     */
-    void bno055_get_magnetometer(const bno055_context dev, float *x, float *y,
-                                 float *z);
-
-    /**
-     * Return gyroscope data (non-fusion).  In fusion modes, this data
-     * will be of little value.  By default the returned values are in
-     * meters per-second squared (m/s^2).  update() must have been
-     * called prior to calling this method.
-     *
-     * @param dev The device context.
-     * @param x Pointer to a floating point value that will have
-     * the current x component placed into it.
-     * @param y Pointer to a floating point value that will have
-     * the current y component placed into it.
-     * @param z Pointer to a floating point value that will have
-     * the current z component placed into it.
-     */
-    void bno055_get_gyroscope(const bno055_context dev,
-                              float *x, float *y, float *z);
-
-    /**
-     * Set the bandwidth, range, and power modes of the accelerometer.
-     * In fusion modes, these values will be ignored.
-     *
-     * @param dev The device context.
-     * @param range One of the BNO055_ACC_RANGE_T values.
-     * @param bw One of the BNO055_ACC_BW_T values.
-     * @param pwr One of the BNO055_ACC_PWR_MODE_T values.
-     * @return UPM result.
-     */
-    upm_result_t bno055_set_acceleration_config(const bno055_context dev,
-                                                BNO055_ACC_RANGE_T range,
-                                                BNO055_ACC_BW_T bw,
-                                                BNO055_ACC_PWR_MODE_T pwr);
-
-    /**
-     * Set the output data rate, operating mode and power mode of the
-     * magnetometer.  In fusion modes, these values will be ignored.
-     *
-     * @param dev The device context.
-     * @param odr One of the BNO055_MAG_ODR_T values.
-     * @param opr One of the BNO055_MAG_OPR_T values.
-     * @param pwr One of the BNO055_MAG_POWER_T values.
-     * @return UPM result.
-     */
-    upm_result_t bno055_set_magnetometer_config(const bno055_context dev,
-                                                BNO055_MAG_ODR_T odr,
-                                                BNO055_MAG_OPR_T opr,
-                                                BNO055_MAG_POWER_T pwr);
-
-    /**
-     * Set the range, bandwidth and power modes of the gyroscope.  In
-     * fusion modes, these values will be ignored.
-     *
-     * @param dev The device context.
-     * @param range One of the BNO055_GYR_RANGE_T values.
-     * @param bw One of the BNO055_GYR_BW_T values.
-     * @param pwr One of the BNO055_GYR_POWER_MODE_T values.
-     * @return UPM result.
-     */
-    upm_result_t bno055_set_gyroscope_config(const bno055_context dev,
-                                             BNO055_GYR_RANGE_T range,
-                                             BNO055_GYR_BW_T bw,
-                                             BNO055_GYR_POWER_MODE_T pwr);
-
-    /**
-     * Set the unit of measurement for the accelerometer related
-     * sensor values.  The choices are mg (milli-gravities) or meters
-     * per-second squared (m/s^2).  The default is m/s^2.
-     *
-     * @param dev The device context.
-     * @param mg true for mg, false for m/s^2.
-     * @return UPM result.
-     */
-    upm_result_t bno055_set_accelerometer_units(const bno055_context dev,
-                                                bool mg);
-
-    /**
-     * Set the unit of measurement for the gyroscope related sensor
-     * values.  The choices are degrees and radians.  The default is
-     * degrees.
-     *
-     * @param dev The device context.
-     * @param radians true for radians, false for degrees.
-     * @return UPM result.
-     */
-    upm_result_t bno055_set_gyroscope_units(const bno055_context dev,
-                                            bool radians);
-
-    /**
-     * Set the unit of measurement for the Euler Angle related sensor
-     * values.  The choices are degrees and radians.  The default is
-     * degrees.
-     *
-     * @param dev The device context.
-     * @param radians true for radians, false for degrees.
-     * @return UPM result.
-     */
-    upm_result_t bno055_set_euler_units(const bno055_context dev,
-                                        bool radians);
-
-    /**
-     * Reset all interrupt status bits and interrupt output.
-     *
-     * @param dev The device context.
-     * @return UPM result.
-     */
-    upm_result_t bno055_reset_interrupt_status(const bno055_context dev);
-
-    /**
-     * Get the interrupt status register.  This is a bitmask of the
-     * INT_STA_BITS_T bits.
-     *
-     * @param dev The device context.
-     * @param istat A bitmask of INT_STA_BITS_T bits.
-     * @return UPM result.
-     */
-    upm_result_t bno055_get_interrupt_status(const bno055_context dev,
-                                             uint8_t *istat);
-
-    /**
-     * Get the interrupt enables register.  This is a bitmask of the
-     * INT_STA_BITS_T bits.
-     *
-     * @param dev The device context.
-     * @param ienable A bitmask of INT_STA_BITS_T bits currently set in the
-     * enable register.
-     * @return UPM result.
-     */
-    upm_result_t bno055_get_interrupt_enable(const bno055_context dev,
-                                             uint8_t *ienable);
-
-    /**
-     * Set the interrupt enable register. This is composed of a
-     * bitmask of the INT_STA_BITS_T bits.
-     *
-     * @param dev The device context.
-     * @param enables a bitmask of INT_STA_BITS_T bits to enable
-     * @return UPM result.
-     */
-    upm_result_t bno055_set_interrupt_enable(const bno055_context dev,
-                                             uint8_t enables);
-
-    /**
-     * Get the interrupt mask register.  This is a bitmask of the
-     * INT_STA_BITS_T bits.  The interrupt mask is used to mask off
-     * enabled interrupts from generating a hardware interrupt.  The
-     * interrupt status register can still be used to detect masked
-     * interrupts if they are enabled.
-     *
-     * @param dev The device context.
-     * @param imask a bitmask of INT_STA_BITS_T bits currently set in the
-     * interrupt mask register.
-     * @return UPM result.
-     */
-    upm_result_t bno055_get_interrupt_mask(const bno055_context dev,
-                                           uint8_t *imask);
-
-    /**
-     * Set the interrupt mask register.  This is a bitmask of the
-     * INT_STA_BITS_T bits.  The interrupt mask is used to mask off
-     * enabled interrupts from generating a hardware interrupt.  The
-     * interrupt status register can still be used to detect masked
-     * interrupts if they are enabled.
-     *
-     * @param dev The device context.
-     * @param mask A bitmask of INT_STA_BITS_T bits to set in the interrupt
-     * mask register.
-     * @return UPM result.
-     */
-    upm_result_t bno055_set_interrupt_mask(const bno055_context dev,
-                                           uint8_t mask);
-
-    /**
-     * Get the value of the system status register.  This method
-     * can be used to determine the overall status of the device.
-     *
-     * @param dev The device context.
-     * @param sys_stat One of the SYS_STATUS_T values.
-     * @return UPM result.
-     */
-    upm_result_t bno055_get_system_status(const bno055_context dev,
-                                          BNO055_SYS_STATUS_T *sys_stat);
-
-    /**
-     * Return the value of the system error register.  This mathod can
-     * be used to determine a variety of system related error
-     * conditions.
-     *
-     * @param dev The device context.
-     * @param sys_stat One of the SYS_ERR_T values.
-     * @return UPM result.
-     */
-    upm_result_t bno055_get_system_error(const bno055_context dev,
-                                         BNO055_SYS_ERR_T *sys_err);
-
-    /**
-     * install an interrupt handler.
-     *
-     * @param dev The device context.
-     * @param gpio The GPIO pin to use as interrupt pin.
-     * @param level The interrupt trigger level (one of mraa_gpio_edge_t
-     * values).  Make sure that you have configured the interrupt pin
-     * properly (on the device) for whatever level method you choose.
-     * @param isr The interrupt handler, accepting a void * argument.
-     * @param arg The argument to pass the the interrupt handler.
-     * @return UPM result.
-     */
-    upm_result_t bno055_install_isr(const bno055_context dev,
-                                    int gpio, mraa_gpio_edge_t level,
-                                    void (*isr)(void *), void *arg);
-
-    /**
-     * uninstall a previously installed interrupt handler
-     *
-     * @param dev The device context.
-     */
-    void bno055_uninstall_isr(const bno055_context dev);
-
-    /**
-     * Set the current internal device register page.  This is a low
-     * level function and should not be used unless you know what you
-     * are doing.
-     *
-     * @param dev The device context.
-     * @param page The page number to set.  This can only be 0 or 1.
-     * @param force If true, force the device page state to match
-     * indicated internal page state regardless of current state.
-     * @return UPM result.
-     */
-    upm_result_t bno055_set_page(const bno055_context dev, uint8_t page,
-                                 bool force);
-
-    /**
-     * Read a register.  This is a low level function and should not
-     * be used unless you know what you are doing.
-     *
-     * @param dev The device context.
-     * @param reg The register to read
-     * @param retval The returned value of the register
-     * @return UPM result.
-     */
-    upm_result_t bno055_read_reg(const bno055_context dev, uint8_t reg,
-                                 uint8_t *retval);
-
-    /**
-     * Read contiguous registers into a buffer.  This is a low level
-     * function and should not be used unless you know what you are
-     * doing.
-     *
-     * @param dev The device context.
-     * @param buffer The buffer to store the results
-     * @param len The number of registers to read
-     * @return UPM result.
-     */
-    upm_result_t bno055_read_regs(const bno055_context dev, uint8_t reg,
-                                  uint8_t *buffer, size_t len);
-
-    /**
-     * Write to a register.  This is a low level function and should
-     * not be used unless you know what you are doing.
-     *
-     * @param dev The device context.
-     * @param reg The register to write to
-     * @param val The value to write
-     * @return UPM result.
-     */
-    upm_result_t bno055_write_reg(const bno055_context dev,
-                                  uint8_t reg, uint8_t val);
-
-    /**
-     * Write data to contiguous registers.  This is a low level
-     * function and should not be used unless you know what you are
-     * doing.
-     *
-     * @param dev The device context.
-     * @param reg The starting register to write to
-     * @param buffer The buffer containing the data to write
-     * @param len The number of bytes to write
-     * @return UPM result.
-     */
-    upm_result_t bno055_write_regs(const bno055_context dev, uint8_t reg,
-                                   uint8_t *buffer, size_t len);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/bno055/bno055.hpp b/src/bno055/bno055.hpp
deleted file mode 100644
index 744523d..0000000
--- a/src/bno055/bno055.hpp
+++ /dev/null
@@ -1,704 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016-2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <vector>
-#include "bno055.h"
-
-namespace upm {
-
-    /**
-     * @brief BNO055 9DOF Fusion Hub
-     * @defgroup bno055 libupm-bno055
-     * @ingroup i2c gpio accelerometer compass bosch adafruit
-     */
-
-    /**
-     * @library bno055
-     * @sensor bno055
-     * @comname Intelligent 9-axis Absolute Orientation Sensor
-     * @type accelerometer compass
-     * @man bosch adafruit
-     * @con i2c gpio
-     * @web https://www.adafruit.com/products/2472
-     *
-     * @brief API for the BNO055 Absolute Orientation 9DOF Fusion Hub
-     *
-     * The BNO055 is a System in Package (SiP), integrating a triaxial
-     * 14-bit accelerometer, a triaxial 16-bit gyroscope with a range of
-     * +/- 2000 degrees per second, a triaxial geomagnetic sensor and a
-     * 32-bit cortex M0+ microcontroller running Bosch Sensortec sensor
-     * fusion software, in a single package.
-     *
-     * This sensor handles the hard problem of combining various sensor
-     * information into a reliable measurement of sensor orientation
-     * (refered to as 'sensor fusion').  The onboard MCU runs this
-     * software and can provide fusion output in the form of Euler
-     * Angles, Quaternions, Linear Acceleration, and Gravity Vectors in
-     * 3 axes.
-     *
-     * The focus on this driver has been on supporting the fusion
-     * components.  Less support is available for use of this device as
-     * a generic accelerometer, gyroscope and magnetometer, however
-     * enough infrastructure is available to add any missing
-     * functionality.
-     *
-     * This device requires calibration in order to operate accurately.
-     * Methods are provided to retrieve calibration data (once
-     * calibrated) to be stored somewhere else, like in a file.  A
-     * method is provided to load this data as well.  Calibration data
-     * is lost on a power cycle.  See one of the examples for a
-     * description of how to calibrate the device, but in essence:
-     *
-     * There is a calibration status register available
-     * (getCalibrationStatus()) that returns the calibration status of
-     * the accelerometer (ACC), magnetometer (MAG), gyroscope (GYR), and
-     * overall system (SYS).  Each of these values range from 0
-     * (uncalibrated) to 3 (fully calibrated).  Calibration involves
-     * certain motions to get all 4 values at 3.  The motions are as
-     * follows (though see the datasheet for more information):
-     *
-     * GYR: Simply let the sensor sit flat for a few seconds.
-     *
-     * ACC: Move the sensor in various positions.  Start flat, then
-     * rotate slowly by 45 degrees, hold for a few seconds, then
-     * continue rotating another 45 degrees and hold, etc.  6 or more
-     * movements of this type may be required.  You can move through any
-     * axis you desire, but make sure that the device is lying at least
-     * once perpendicular to the x, y, and z axis.
-     *
-     * MAG: Move slowly in a figure 8 pattern in the air, until the
-     * calibration values reaches 3.
-     *
-     * SYS: This will usually reach 3 when the other items have also
-     * reached 3.  If not, continue slowly moving the device though
-     * various axes until it does.
-     *
-     * @snippet bno055.cxx Interesting
-     */
-
-    class BNO055 {
-
-    public:
-        /**
-         * BNO055 constructor.
-         *
-         * By default, the constructor sets the acceleration units to
-         * m/s^2, gyro and Euler units to degrees, and temperature to
-         * celsius.  It then enters the NDOF fusion mode.
-         *
-         * In addition, the internal clock is used so that compatibility
-         * with other implementations is assured.  If you are using a
-         * device with an external clock, call setClockExternal(true) to
-         * enable it.
-         *
-         * @param bus I2C bus to use.
-         * @param address The address for this device.
-         * @throws std::runtime_error on initialization failure.
-         */
-        BNO055(int bus=BNO055_DEFAULT_I2C_BUS,
-               uint8_t addr=BNO055_DEFAULT_ADDR);
-
-        /**
-         * BNO055 Destructor.
-         */
-        virtual ~BNO055();
-
-        /**
-         * Update the internal stored values from sensor data.
-         *
-         * @throws std::runtime_error on failure.
-         */
-        void update();
-
-        /**
-         * Return the chip ID.
-         *
-         * @return The chip ID (BNO055_CHIPID).
-         * @throws std::runtime_error on failure.
-         */
-        uint8_t getChipID();
-
-        /**
-         * Return the accelerometer chip ID.
-         *
-         * @return The chip ID.
-         * @throws std::runtime_error on failure.
-         */
-        uint8_t getACCID();
-
-        /**
-         * Return the magnetometer chip ID.
-         *
-         * @return The chip ID.
-         * @throws std::runtime_error on failure.
-         */
-        uint8_t getMAGID();
-
-        /**
-         * Return the gyroscope chip ID.
-         *
-         * @return The chip ID.
-         * @throws std::runtime_error on failure.
-         */
-        uint8_t getGYRID();
-
-        /**
-         * Return the fusion firmware revison.
-         *
-         * @return The firmware revison.
-         * @throws std::runtime_error on failure.
-         */
-        uint16_t getSWRevID();
-
-        /**
-         * Return the bootloader ID.
-         *
-         * @return The bootloader ID.
-         * @throws std::runtime_error on failure.
-         */
-        uint8_t getBootLoaderID();
-
-        /**
-         * Enable or disables the use of the external clock.  The Adafruit
-         * device does contain an external clock which might be more
-         * stable.  By default, the internal clock is used.
-         *
-         * @param extClock true to use external clock, false otherwise.
-         * @throws std::runtime_error on failure.
-         */
-        void setClockExternal(bool extClock);
-
-        /**
-         * Select the temperature source.  This can be the accelerometer
-         * or the gyroscope.  By default, the accelerometer temperature is
-         * used as the source.
-         *
-         * @param src One of the BNO055_TEMP_SOURCES_T values.
-         * @throws std::runtime_error on failure.
-         */
-        void setTemperatureSource(BNO055_TEMP_SOURCES_T src);
-
-        /**
-         * Set the operating mode for the device.  This places the device
-         * into a config mode, one of 7 non-fusion modes, or one of 5
-         * fusion modes.  All stored sensor data is cleared when switching
-         * modes.  The device must be in config mode for most
-         * configuration operations.  See the datasheet for details.
-         *
-         * @param mode One of the BNO055_OPERATION_MODES_T values.
-         * @throws std::runtime_error on failure.
-         */
-        void setOperationMode(BNO055_OPERATION_MODES_T mode);
-
-        /**
-         * Reboot the sensor.  This is equivalent to a power on reset.
-         * All calibration data will be lost, and the device must be
-         * recalibrated.
-         * @throws std::runtime_error on failure.
-         */
-        void resetSystem();
-
-        /**
-         * Read the calibration status registers and return them.  The
-         * values range from 0 (uncalibrated) to 3 (fully calibrated).
-         *
-         * @param mag The calibration status of the magnetometer.
-         * @param acc The calibration status of the accelerometer.
-         * @param mag The calibration status of the gyroscope.
-         * @param mag The calibration status of the overall system.
-         * @throws std::runtime_error on failure.
-         */
-        void getCalibrationStatus(int *mag, int *acc, int *gyr, int *sys);
-
-        /**
-         * Read the calibration status registers and return them as an
-         * integer vector.  The values range from 0 (uncalibrated) to 3
-         * (fully calibrated).
-         *
-         * @return An integer vector containing the values in the
-         * order: mag, acc, gyr, and sys.
-         * @throws std::runtime_error on failure.
-         */
-        std::vector<int> getCalibrationStatus();
-
-        /**
-         * Read the calibration status registers and return true or false,
-         * indicating whether all of the calibration parameters are fully
-         * calibrated.
-         *
-         * @return True if all 4 calibration parameters are fully
-         * calibrated, else false.
-         */
-        bool isFullyCalibrated();
-
-        /**
-         * Read the calibration data and return it as a string.  This
-         * data can then be saved for later reuse by
-         * writeCalibrationData() to restore calibration data after a
-         * reset.  The sensor must be fully calibrated before
-         * calibration data can be read.
-         *
-         * @return A vector of uint8_t's representing the calibration
-         * data.  This vector will always be exactly
-         * BNO055_CALIBRATION_DATA_SIZE in size.
-         * @throws std::runtime_error if an error occurs.
-         */
-        std::vector<uint8_t> readCalibrationData();
-
-        /**
-         * Write previously saved calibration data to the calibration
-         * registers.
-         *
-         * @param calibrationData A vector of uint8_t (bytes) representing
-         * calibration data as returned by readCalibrationData().
-         * It's length must always be exactly BNO055_CALIBRATION_DATA_SIZE.
-         * @throws std::length_error if the vector size is not equal to
-         * BNO055_CALIBRATION_DATA_SIZE.
-         */
-        void writeCalibrationData(std::vector<uint8_t> calibrationData);
-
-        /**
-         * Return the current measured temperature.  Note, this is not
-         * ambient temperature - this is the temperature of the selected
-         * source on the chip.  update() must have been called prior to
-         * calling this method.
-         *
-         * @param fahrenheit true to return data in Fahrenheit, false for
-         * Celicus.  Celsius is the default.
-         * @return The temperature in degrees Celsius or Fahrenheit.
-         */
-        float getTemperature(bool fahrenheit=false);
-
-        /**
-         * Return current orientation fusion data in the form of Euler
-         * Angles.  By default, the returned values are in degrees.
-         * update() must have been called prior to calling this method.
-         *
-         * @param heading Pointer to a floating point value that will have
-         * the current heading angle placed into it.
-         * @param roll Pointer to a floating point value that will have
-         * the current roll angle placed into it.
-         * @param pitch Pointer to a floating point value that will have
-         * the current pitch angle placed into it.
-         */
-        void getEulerAngles(float *heading, float *roll, float *pitch);
-
-        /**
-         * Return current orientation fusion data in the form of Euler
-         * Angles as a floating point vector.  By default, the returned
-         * values are in degrees.  update() must have been called prior to
-         * calling this method.
-         *
-         * @return A floating point vector containing heading, roll, and
-         * pitch, in that order.
-         */
-        std::vector<float> getEulerAngles();
-
-        /**
-         * Return current orientation fusion data in the form of
-         * Quaternions.  update() must have been called prior to calling
-         * this method.
-         *
-         * @param w Pointer to a floating point value that will have
-         * the current w component placed into it.
-         * @param x Pointer to a floating point value that will have
-         * the current x component placed into it.
-         * @param y Pointer to a floating point value that will have
-         * the current y component placed into it.
-         * @param z Pointer to a floating point value that will have
-         * the current z component placed into it.
-         */
-        void getQuaternions(float *w, float *x, float *y, float *z);
-
-        /**
-         * Return current orientation fusion data in the form of
-         * Quaternions, as a floating point vector.  update() must have
-         * been called prior to calling this method.
-         *
-         * @return A floating point vector containing w, x, y, and z in
-         * that order.
-         */
-        std::vector<float> getQuaternions();
-
-        /**
-         * Return current orientation fusion data in the form of Linear
-         * Acceleration.  By default the returned values are in meters
-         * per-second squared (m/s^2).  update() must have been called
-         * prior to calling this method.
-         *
-         * @param x Pointer to a floating point value that will have
-         * the current x component placed into it.
-         * @param y Pointer to a floating point value that will have
-         * the current y component placed into it.
-         * @param z Pointer to a floating point value that will have
-         * the current z component placed into it.
-         */
-        void getLinearAcceleration(float *x, float *y, float *z);
-
-        /**
-         * Return current orientation fusion data in the form of Linear
-         * Acceleration, as a floating point vector.  update() must have
-         * been called prior to calling this method.
-         *
-         * @return A floating point vector containing x, y, and z in
-         * that order.
-         */
-        std::vector<float> getLinearAcceleration();
-
-        /**
-         * Return current orientation fusion data in the form of a Gravity
-         * Vector per-axis.  By default the returned values are in meters
-         * per-second squared (m/s^2).  update() must have been called
-         * prior to calling this method.
-         *
-         * @param x Pointer to a floating point value that will have
-         * the current x component placed into it.
-         * @param y Pointer to a floating point value that will have
-         * the current y component placed into it.
-         * @param z Pointer to a floating point value that will have
-         * the current z component placed into it.
-         */
-        void getGravityVectors(float *x, float *y, float *z);
-
-        /**
-         * Return current orientation fusion data in the form of a Gravity
-         * Vector per-axis as a floating point vector.  update() must have
-         * been called prior to calling this method.
-         *
-         * @return A floating point vector containing x, y, and z in
-         * that order.
-         */
-        std::vector<float> getGravityVectors();
-
-        /**
-         * Return uncompensated accelerometer data (non-fusion).  In
-         * fusion modes, this data will be of little value.  By default
-         * the returned values are in meters per-second squared (m/s^2).
-         * update() must have been called prior to calling this method.
-         *
-         * @param x Pointer to a floating point value that will have
-         * the current x component placed into it.
-         * @param y Pointer to a floating point value that will have
-         * the current y component placed into it.
-         * @param z Pointer to a floating point value that will have
-         * the current z component placed into it.
-         */
-        void getAccelerometer(float *x, float *y, float *z);
-
-        /**
-         * Return current uncompensated accelerometer (non-fusion) data in
-         * the form of a floating point vector.  By default the returned
-         * values are in meters per-second squared (m/s^2).  update() must
-         * have been called prior to calling this method.
-         *
-         * @return A floating point vector containing x, y, and z in
-         * that order.
-         */
-        std::vector<float> getAccelerometer();
-
-        /**
-         * Return uncompensated magnetometer data (non-fusion).  In fusion
-         * modes, this data will be of little value.  The returned values
-         * are in micro-teslas (uT).  update() must have been called prior
-         * to calling this method.
-         *
-         * @param x Pointer to a floating point value that will have
-         * the current x component placed into it.
-         * @param y Pointer to a floating point value that will have
-         * the current y component placed into it.
-         * @param z Pointer to a floating point value that will have
-         * the current z component placed into it.
-         */
-        void getMagnetometer(float *x, float *y, float *z);
-
-        /**
-         * Return current uncompensated magnetometer (non-fusion) data in
-         * the form of a floating point vector.  The returned values are in
-         * micro-teslas (uT).  update() must have been called prior to
-         * calling this method.
-         *
-         * @return A floating point vector containing x, y, and z in
-         * that order.
-         */
-        std::vector<float> getMagnetometer();
-
-        /**
-         * Return uncompensated gyroscope data (non-fusion).  In fusion
-         * modes, this data will be of little value.  By default the
-         * returned values are in meters per-second squared (m/s^2).
-         * update() must have been called prior to calling this method.
-         *
-         * @param x Pointer to a floating point value that will have
-         * the current x component placed into it.
-         * @param y Pointer to a floating point value that will have
-         * the current y component placed into it.
-         * @param z Pointer to a floating point value that will have
-         * the current z component placed into it.
-         */
-        void getGyroscope(float *x, float *y, float *z);
-
-        /**
-         * Return current uncompensated gyroscope (non-fusion) data in the
-         * form of a floating point vector.  By default the returned values
-         * are in meters per-second squared (m/s^2).  update() must have
-         * been called prior to calling this method.
-         *
-         * @return A floating point vector containing x, y, and z in
-         * that order.
-         */
-        std::vector<float> getGyroscope();
-
-        /**
-         * Set the bandwidth, range, and power modes of the accelerometer.
-         * In fusion modes, these values will be ignored.
-         *
-         * @param range One of the BNO055_ACC_RANGE_T values.
-         * @param bw One of the BNO055_ACC_BW_T values.
-         * @param pwr One of the BNO055_ACC_PWR_MODE_T values.
-         * @throws std::runtime_error on failure.
-         */
-        void setAccelerationConfig(BNO055_ACC_RANGE_T range,
-                                   BNO055_ACC_BW_T bw,
-                                   BNO055_ACC_PWR_MODE_T pwr);
-
-        /**
-         * Set the output data rate, operating mode and power mode of the
-         * magnetometer.  In fusion modes, these values will be ignored.
-         *
-         * @param odr One of the BNO055_MAG_ODR_T values.
-         * @param opr One of the BNO055_MAG_OPR_T values.
-         * @param pwr One of the BNO055_MAG_POWER_T values.
-         * @throws std::runtime_error on failure.
-         */
-        void setMagnetometerConfig(BNO055_MAG_ODR_T odr,
-                                   BNO055_MAG_OPR_T opr,
-                                   BNO055_MAG_POWER_T pwr);
-
-        /**
-         * Set the range, bandwidth and power modes of the gyroscope.  In
-         * fusion modes, these values will be ignored.
-         *
-         * @param range One of the BNO055_GYR_RANGE_T values.
-         * @param bw One of the BNO055_GYR_BW_T values.
-         * @param pwr One of the BNO055_GYR_POWER_MODE_T values.
-         * @throws std::runtime_error on failure.
-         */
-        void setGyroscopeConfig(BNO055_GYR_RANGE_T range,
-                                BNO055_GYR_BW_T bw,
-                                BNO055_GYR_POWER_MODE_T pwr);
-
-        /**
-         * Set the unit of measurement for the accelerometer related
-         * sensor values.  The choices are mg (milligravities) or meters
-         * per-second squared (m/s^2).  The default is m/s^2.
-         *
-         * @param mg true for mg, false for m/s^2.
-         * @throws std::runtime_error on failure.
-         */
-        void setAccelerometerUnits(bool mg=false);
-
-        /**
-         * Set the unit of measurement for the gyroscope related sensor
-         * values.  The choices are degrees and radians.  The default is
-         * degrees.
-         *
-         * @param radians true for radians, false for degrees.
-         * @throws std::runtime_error on failure.
-         */
-        void setGyroscopeUnits(bool radians=false);
-
-        /**
-         * Set the unit of measurement for the Euler Angle related sensor
-         * values.  The choices are degrees and radians.  The default is
-         * degrees.
-         *
-         * @param radians true for radians, false for degrees.
-         * @throws std::runtime_error on failure.
-         */
-        void setEulerUnits(bool radians=false);
-
-        /**
-         * Reset all interrupt status bits and interrupt output.
-         *
-         * @throws std::runtime_error on failure.
-         */
-        void resetInterruptStatus();
-
-        /**
-         * Return the interrupt status register.  This is a bitmask of the
-         * BNO055_INT_STA_BITS_T bits.
-         *
-         * @return a bitmask of BNO055_INT_STA_BITS_T bits.
-         * @throws std::runtime_error on failure.
-         */
-        uint8_t getInterruptStatus();
-
-        /**
-         * Return the interrupt enables register.  This is a bitmask of the
-         * BNO055_INT_STA_BITS_T bits.
-         *
-         * @return a bitmask of BNO055_INT_STA_BITS_T bits currently set in the
-         * enable register.
-         * @throws std::runtime_error on failure.
-         */
-        uint8_t getInterruptEnable();
-
-        /**
-         * Set the interrupt enable register. This is composed of a
-         * bitmask of the BNO055_INT_STA_BITS_T bits.
-         *
-         * @param enables a bitmask of BNO055_INT_STA_BITS_T bits to enable
-         * @throws std::runtime_error on failure.
-         */
-        void setInterruptEnable(uint8_t enables);
-
-        /**
-         * Return the interrupt mask register.  This is a bitmask of
-         * the BNO055_INT_STA_BITS_T bits.  The interrupt mask is used
-         * to mask off enabled interrupts from generating a hardware
-         * interrupt.  The interrupt status register can still be used
-         * to detect masked interrupts if they are enabled.
-         *
-         * @return a bitmask of BNO055_INT_STA_BITS_T bits currently set in the
-         * interrupt mask register.
-         * @throws std::runtime_error on failure.
-         */
-        uint8_t getInterruptMask();
-
-        /**
-         * Set the interrupt mask register.  This is a bitmask of the
-         * BNO055_INT_STA_BITS_T bits.  The interrupt mask is used to
-         * mask off enabled interrupts from generating a hardware
-         * interrupt.  The interrupt status register can still be used
-         * to detect masked interrupts if they are enabled.
-         *
-         * @param mask A bitmask of BNO055_INT_STA_BITS_T bits to set in
-         * the interrupt mask register.
-         * @throws std::runtime_error on failure.
-         */
-        void setInterruptMask(uint8_t mask);
-
-        /**
-         * Return the value of the system status register.  This method
-         * can be used to determine the overall status of the device.
-         *
-         * @return One of the BNO055_SYS_STATUS_T values.
-         * @throws std::runtime_error on failure.
-         */
-        BNO055_SYS_STATUS_T getSystemStatus();
-
-        /**
-         * Return the value of the system error register.  This mathod can
-         * be used to determine a variety of system related error
-         * conditions.
-         *
-         * @return One of the BNO055_SYS_ERR_T values.
-         * @throws std::runtime_error on failure.
-         */
-        BNO055_SYS_ERR_T getSystemError();
-
-
-        /**
-         * install an interrupt handler.
-         *
-         * @param gpio gpio pin to use as interrupt pin
-         * @param level the interrupt trigger level (one of mraa_gpio_edge_t
-         * values).  Make sure that you have configured the interrupt pin
-         * properly for whatever level you choose.
-         * @param isr the interrupt handler, accepting a void * argument
-         * @param arg the argument to pass the the interrupt handler
-         * @throws std::runtime_error on failure.
-         */
-        void installISR(int gpio, mraa_gpio_edge_t level,
-                        void (*isr)(void *), void *arg);
-
-        /**
-         * uninstall a previously installed interrupt handler
-         *
-         */
-        void uninstallISR();
-
-    protected:
-        bno055_context m_bno055;
-
-        /**
-         * Set the current internal device register page.  This is a low
-         * level function and should not be used unless you know what you
-         * are doing.
-         *
-         * @param dev The device context.
-         * @param page The page number to set.  This can only be 0 or 1.
-         * @param force If true, force the device page state to match
-         * indicated internal page state regardless of current state.
-         * @throws std::runtime_error on failure.
-         */
-        void setPage(uint8_t page, bool force=false);
-
-        /**
-         * Read a register.
-         *
-         * @param reg The register to read
-         * @return The value of the register
-         * @throws std::runtime_error on failure.
-         */
-        uint8_t readReg(uint8_t reg);
-
-        /**
-         * Read contiguous registers into a buffer.
-         *
-         * @param buffer The buffer to store the results
-         * @param len The number of registers to read
-         * @throws std::runtime_error on failure.
-         */
-        void readRegs(uint8_t reg, uint8_t *buffer, int len);
-
-        /**
-         * Write to a register
-         *
-         * @param reg The register to write to
-         * @param val The value to write
-         * @throws std::runtime_error on failure.
-         */
-        void writeReg(uint8_t reg, uint8_t val);
-
-        /**
-         * Write data to contiguous registers
-         *
-         * @param reg The starting register to write to
-         * @param buffer The buffer containing the data to write
-         * @param len The number of bytes to write
-         * @throws std::runtime_error on failure.
-         */
-        void writeRegs(uint8_t reg, uint8_t *buffer, int len);
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        BNO055(const BNO055&) = delete;
-        BNO055 &operator=(const BNO055&) = delete;
-
-    };
-}
diff --git a/src/bno055/bno055.i b/src/bno055/bno055.i
deleted file mode 100644
index 0007cc2..0000000
--- a/src/bno055/bno055.i
+++ /dev/null
@@ -1,53 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "std_vector.i"
-%ignore getCalibrationStatus(int *, int *, int *, int *);
-%ignore getAccelerometer(float *, float *, float *);
-%ignore getMagnetometer(float *, float *, float *);
-%ignore getGyroscope(float *, float *, float *);
-%ignore getEulerAngles(float *, float *, float *);
-%ignore getQuaternions(float *, float *, float *, float *);
-%ignore getLinearAcceleration(float *, float *, float *);
-%ignore getGravityVectors(float *, float *, float *);
-%ignore installISR(int , mraa::Edge ,  void *, void *);
-
-%template(floatVector) std::vector<float>;
-%template(byteVector) std::vector<uint8_t>;
-%template(intVector) std::vector<int>;
-
-%extend upm::BNO055 {
-    void installISR(int gpio, mraa_gpio_edge_t level, jobject runnable)
-    {
-        $self->installISR(gpio, level, mraa_java_isr_callback, runnable);
-    }
-}
-
-JAVA_JNI_LOADLIBRARY(javaupm_bno055)
-#endif
-/* END Java syntax */
-
-/* BEGIN Javascript syntax  ------------------------------------------------- */
-#ifdef SWIGJAVASCRIPT
-%include "../upm_vectortypes.i"
-%pointer_functions(int, intp);
-%pointer_functions(float, floatp);
-#endif
-/* END Javascript syntax */
-
-/* BEGIN Python syntax  ----------------------------------------------------- */
-#ifdef SWIGPYTHON
-%include "../upm_vectortypes.i"
-%pointer_functions(int, intp);
-%pointer_functions(float, floatp);
-#endif
-/* END Python syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "bno055.hpp"
-%}
-%include "bno055_regs.h"
-%include "bno055.hpp"
-/* END Common SWIG syntax */
diff --git a/src/bno055/bno055.json b/src/bno055/bno055.json
deleted file mode 100644
index d31d4ac..0000000
--- a/src/bno055/bno055.json
+++ /dev/null
@@ -1,48 +0,0 @@
-{
-    "Library": "bno055",
-    "Description": "API for the BNO055 Absolute Orientation 9DOF Fusion Hub",
-    "Sensor Class":
-    {
-        "BNO055":
-        {
-            "Name": "Intelligent 9-axis Absolute Orientation Sensor",
-            "Description": "The BNO055 is a System in Package (SiP), integrating a triaxial 14-bit accelerometer, a triaxial 16-bit gyroscope with a range of +/- 2000 degrees per second, a triaxial geomagnetic sensor and a 32-bit cortex M0+ microcontroller running Bosch Sensortec sensor fusion software, in a single package. This sensor handles the hard problem of combining various sensor information into a reliable measurement of sensor orientation (refered to as 'sensor fusion'). The onboard MCU runs this software and can provide fusion output in the form of Euler Angles, Quaternions, Linear Acceleration, and Gravity Vectors in 3 axes. The focus on this driver has been on supporting the fusion components. Less support is available for use of this device as a generic accelerometer, gyroscope and magnetometer, however enough infrastructure is available to add any missing functionality. This device requires calibration in order to operate accurately. Methods are provided to retrieve calibration data (once calibrated) to be stored somewhere else, like in a file. A method is provided to load this data as well. Calibration data is lost on a power cycle. See one of the examples for a description of how to calibrate the device, but in essence: There is a calibration status register available (getCalibrationStatus()) that returns the calibration status of the accelerometer (ACC), magnetometer (MAG), gyroscope (GYR), and overall system (SYS). Each of these values range from 0 (uncalibrated) to 3 (fully calibrated). Calibration involves certain motions to get all 4 values at 3. The motions are as follows (though see the datasheet for more information): GYR: Simply let the sensor sit flat for a few seconds. ACC: Move the sensor in various positions. Start flat, then rotate slowly by 45 degrees, hold for a few seconds, then continue rotating another 45 degrees and hold, etc. 6 or more movements of this type may be required. You can move through any axis you desire, but make sure that the device is lying at least once perpendicular to the x, y, and z axis. MAG: Move slowly in a figure 8 pattern in the air, until the calibration values reaches 3. SYS: This will usually reach 3 when the other items have also reached 3. If not, continue slowly moving the device though various axes until it does.",
-            "Aliases": ["bno055"],
-            "Categories": ["accelerometer", "compass"],
-            "Connections": ["gpio", "i2c"],
-            "Project Type": ["prototyping", "industrial"],
-            "Manufacturers": ["adafruit"],
-            "Kits": [],
-            "Examples":
-            {
-                "Java": ["BNO055_Example.java"],
-                "Python": ["bno055.py"],
-                "Node.js": ["bno055.js"],
-                "C++": ["bno055.cxx"],
-                "C": ["bno055.c"]
-            },
-            "Specifications":
-            {
-                "Vsource": {"unit": "v", "low" : 2.4, "high": 3.6},
-                "Supply Current": {"unit": "mA", "low": 0.33, "high": 12.3},
-                "Supply Current (Suspended)": {"unit": "uA", "typ": 40},
-                "Gyroscope Ranges": {"unit": "deg/s", "low": 125, "high": 2000},
-                "Magnetometer Ranges": {}
-            },
-            "Platforms":
-            {
-                "Intel Joule Module":
-                {
-                    "Notes": ["Requires pull-up resistors with carrier board"],
-                    "Images": [""]
-                }
-            },
-            "Urls" :
-            {
-                "Product Pages": ["https://www.adafruit.com/products/2472"],
-                "Datasheets": ["https://cdn-learn.adafruit.com/assets/assets/000/036/832/original/BST_BNO055_DS000_14.pdf"],
-                "Schematics": ["https://cdn-learn.adafruit.com/assets/assets/000/024/546/medium800/sensors_BNO055_REV-C.png?1429569060"]
-            }
-        }
-    }
-}
diff --git a/src/bno055/bno055_regs.h b/src/bno055/bno055_regs.h
deleted file mode 100644
index f0648a1..0000000
--- a/src/bno055/bno055_regs.h
+++ /dev/null
@@ -1,825 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016-2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#define BNO055_DEFAULT_I2C_BUS 0
-#define BNO055_DEFAULT_ADDR    0x28
-
-// The chip ID, for verification in bno055_init().
-#define BNO055_CHIPID          0xa0
-
-// number of bytes of stored calibration data
-#define BNO055_CALIBRATION_DATA_SIZE (22)
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    // NOTE: Reserved registers should not be written into.  Reading
-    // from them will return indeterminate values.
-    //
-    // The register map is divided into two pages - page 1 contains
-    // sensor specific configuration registers, and page 0 contains all
-    // other configuration data and sensor output registers.
-
-    /**
-     * BNO055 registers
-     */
-    typedef enum {
-        // The first register listed here is the page ID register.  It
-        // is the same on both pages, and selects or indicates the
-        // currently active register page.
-
-        BNO055_REG_PAGE_ID                      = 0x07,
-
-        // Page 0
-        BNO055_REG_CHIP_ID                      = 0x00,
-        BNO055_REG_ACC_ID                       = 0x01, // accel id
-        BNO055_REG_MAG_ID                       = 0x02, // mag id
-        BNO055_REG_GYR_ID                       = 0x03, // gyro id
-        BNO055_REG_SW_REV_ID_LSB                = 0x04,
-        BNO055_REG_SW_REV_ID_MSB                = 0x05,
-        BNO055_REG_BL_REV_ID                    = 0x06, // bootloader rev
-
-        BNO055_REG_ACC_DATA_X_LSB               = 0x08,
-        BNO055_REG_ACC_DATA_X_MSB               = 0x09,
-        BNO055_REG_ACC_DATA_Y_LSB               = 0x0a,
-        BNO055_REG_ACC_DATA_Y_MSB               = 0x0b,
-        BNO055_REG_ACC_DATA_Z_LSB               = 0x0c,
-        BNO055_REG_ACC_DATA_Z_MSB               = 0x0d,
-
-        BNO055_REG_MAG_DATA_X_LSB               = 0x0e,
-        BNO055_REG_MAG_DATA_X_MSB               = 0x0f,
-        BNO055_REG_MAG_DATA_Y_LSB               = 0x10,
-        BNO055_REG_MAG_DATA_Y_MSB               = 0x11,
-        BNO055_REG_MAG_DATA_Z_LSB               = 0x12,
-        BNO055_REG_MAG_DATA_Z_MSB               = 0x13,
-
-        BNO055_REG_GYR_DATA_X_LSB               = 0x14,
-        BNO055_REG_GYR_DATA_X_MSB               = 0x15,
-        BNO055_REG_GYR_DATA_Y_LSB               = 0x16,
-        BNO055_REG_GYR_DATA_Y_MSB               = 0x17,
-        BNO055_REG_GYR_DATA_Z_LSB               = 0x18,
-        BNO055_REG_GYR_DATA_Z_MSB               = 0x19,
-
-        // euler angles
-        BNO055_REG_EUL_HEADING_LSB              = 0x1a,
-        BNO055_REG_EUL_HEADING_MSB              = 0x1b,
-        BNO055_REG_EUL_ROLL_LSB                 = 0x1c,
-        BNO055_REG_EUL_ROLL_MSB                 = 0x1d,
-        BNO055_REG_EUL_PITCH_LSB                = 0x1e,
-        BNO055_REG_EUL_PITCH_MSB                = 0x1f,
-
-        // Quaternions
-        BNO055_REG_QUA_DATA_W_LSB               = 0x20,
-        BNO055_REG_QUA_DATA_W_MSB               = 0x21,
-        BNO055_REG_QUA_DATA_X_LSB               = 0x22,
-        BNO055_REG_QUA_DATA_X_MSB               = 0x23,
-        BNO055_REG_QUA_DATA_Y_LSB               = 0x24,
-        BNO055_REG_QUA_DATA_Y_MSB               = 0x25,
-        BNO055_REG_QUA_DATA_Z_LSB               = 0x26,
-        BNO055_REG_QUA_DATA_Z_MSB               = 0x27,
-
-        // linear accel data
-        BNO055_REG_LIA_DATA_X_LSB               = 0x28,
-        BNO055_REG_LIA_DATA_X_MSB               = 0x29,
-        BNO055_REG_LIA_DATA_Y_LSB               = 0x2a,
-        BNO055_REG_LIA_DATA_Y_MSB               = 0x2b,
-        BNO055_REG_LIA_DATA_Z_LSB               = 0x2c,
-        BNO055_REG_LIA_DATA_Z_MSB               = 0x2d,
-
-        // gravity vector
-        BNO055_REG_GRV_DATA_X_LSB               = 0x2e,
-        BNO055_REG_GRV_DATA_X_MSB               = 0x2f,
-        BNO055_REG_GRV_DATA_Y_LSB               = 0x30,
-        BNO055_REG_GRV_DATA_Y_MSB               = 0x31,
-        BNO055_REG_GRV_DATA_Z_LSB               = 0x32,
-        BNO055_REG_GRV_DATA_Z_MSB               = 0x33,
-
-        BNO055_REG_TEMPERATURE                  = 0x34,
-
-        BNO055_REG_CALIB_STAT                   = 0x35, // calibration status
-        BNO055_REG_ST_RESULT                    = 0x36, // selftest result
-
-        BNO055_REG_INT_STA                      = 0x37, // interrupt status
-
-        BNO055_REG_SYS_CLK_STATUS               = 0x38,
-
-        BNO055_REG_SYS_STATUS                   = 0x39,
-        BNO055_REG_SYS_ERROR                    = 0x3a,
-
-        BNO055_REG_UNIT_SEL                     = 0x3b,
-
-        // 0x3c reserved
-
-        BNO055_REG_OPER_MODE                    = 0x3d, // operating mode
-        BNO055_REG_POWER_MODE                   = 0x3e,
-
-        BNO055_REG_SYS_TRIGGER                  = 0x3f,
-        BNO055_REG_TEMP_SOURCE                  = 0x40, // temperature src
-
-        BNO055_REG_AXIS_MAP_CONFIG              = 0x41,
-        BNO055_REG_AXIS_MAP_SIGN                = 0x42,
-
-        // 0x43-0x54 reserved
-
-        // stored calibration data
-        BNO055_REG_ACC_OFFSET_X_LSB             = 0x55,
-        BNO055_REG_ACC_OFFSET_X_MSB             = 0x56,
-        BNO055_REG_ACC_OFFSET_Y_LSB             = 0x57,
-        BNO055_REG_ACC_OFFSET_Y_MSB             = 0x58,
-        BNO055_REG_ACC_OFFSET_Z_LSB             = 0x59,
-        BNO055_REG_ACC_OFFSET_Z_MSB             = 0x5a,
-
-        BNO055_REG_MAG_OFFSET_X_LSB             = 0x5b,
-        BNO055_REG_MAG_OFFSET_X_MSB             = 0x5c,
-        BNO055_REG_MAG_OFFSET_Y_LSB             = 0x5d,
-        BNO055_REG_MAG_OFFSET_Y_MSB             = 0x5e,
-        BNO055_REG_MAG_OFFSET_Z_LSB             = 0x5f,
-        BNO055_REG_MAG_OFFSET_Z_MSB             = 0x60,
-
-        BNO055_REG_GYR_OFFSET_X_LSB             = 0x61,
-        BNO055_REG_GYR_OFFSET_X_MSB             = 0x62,
-        BNO055_REG_GYR_OFFSET_Y_LSB             = 0x63,
-        BNO055_REG_GYR_OFFSET_Y_MSB             = 0x64,
-        BNO055_REG_GYR_OFFSET_Z_LSB             = 0x65,
-        BNO055_REG_GYR_OFFSET_Z_MSB             = 0x66,
-
-        BNO055_REG_ACC_RADIUS_LSB               = 0x67,
-        BNO055_REG_ACC_RADIUS_MSB               = 0x68,
-
-        BNO055_REG_MAG_RADIUS_LSB               = 0x69,
-        BNO055_REG_MAG_RADIUS_MSB               = 0x6a,
-
-        // 0x6b-0x7f reserved
-        // end of page 0
-
-        // Page 1
-
-        // 0x00-0x06 reserved
-        // 0x07 - page id
-
-        BNO055_REG_ACC_CONFIG                   = 0x08,
-        BNO055_REG_MAG_CONFIG                   = 0x09,
-        BNO055_REG_GYR_CONFIG0                  = 0x0a,
-        BNO055_REG_GYR_CONFIG1                  = 0x0b,
-        BNO055_REG_ACC_SLEEP_CONFIG             = 0x0c,
-        BNO055_REG_GYR_SLEEP_CONFIG             = 0x0d,
-
-        // 0x0e reserved
-        BNO055_REG_INT_MSK                      = 0x0f,
-        BNO055_REG_INT_EN                       = 0x10,
-
-        BNO055_REG_ACC_AM_THRES                 = 0x11,
-        BNO055_REG_ACC_INT_SETTINGS             = 0x12,
-        BNO055_REG_ACC_HG_DURATION              = 0x13,
-        BNO055_REG_ACC_HG_THRES                 = 0x14,
-        BNO055_REG_ACC_NM_THRES                 = 0x15,
-        BNO055_REG_ACC_NM_SET                   = 0x16,
-
-        BNO055_REG_GYR_INT_SETTING              = 0x17,
-        BNO055_REG_GYR_HR_X_SET                 = 0x18,
-        BNO055_REG_GYR_DUR_X                    = 0x19,
-        BNO055_REG_GYR_HR_Y_SET                 = 0x1a,
-        BNO055_REG_GYR_DUR_Y                    = 0x1b,
-        BNO055_REG_GYR_HR_Z_SET                 = 0x1c,
-        BNO055_REG_GYR_DUR_Z                    = 0x1d,
-        BNO055_REG_GYR_AM_THRES                 = 0x1e,
-        BNO055_REG_GYR_AM_SET                   = 0x1f,
-
-        // 0x20-0x4f reserved
-
-        // 16 byte (0x50-0x5f) unique ID
-        BNO055_REG_BNO_UNIQUE_ID                = 0x50
-
-        // 0x60-0x7f reserved
-    } BNO055_REGS_T;
-
-    // Page 0 register enumerants
-
-    /**
-     * BNO055_REG_CALIB_STAT bits
-     */
-    typedef enum {
-        BNO055_CALIB_STAT_MAG0                  = 0x01,
-        BNO055_CALIB_STAT_MAG1                  = 0x02,
-        _BNO055_CALIB_STAT_MAG_MASK             = 3,
-        _BNO055_CALIB_STAT_MAG_SHIFT            = 0,
-
-        BNO055_CALIB_STAT_ACC0                  = 0x04,
-        BNO055_CALIB_STAT_ACC1                  = 0x08,
-        _BNO055_CALIB_STAT_ACC_MASK             = 3,
-        _BNO055_CALIB_STAT_ACC_SHIFT            = 2,
-
-        BNO055_CALIB_STAT_GYR0                  = 0x10,
-        BNO055_CALIB_STAT_GYR1                  = 0x20,
-        _BNO055_CALIB_STAT_GYR_MASK             = 3,
-        _BNO055_CALIB_STAT_GYR_SHIFT            = 4,
-
-        BNO055_CALIB_STAT_SYS0                  = 0x40,
-        BNO055_CALIB_STAT_SYS1                  = 0x80,
-        _BNO055_CALIB_STAT_SYS_MASK             = 3,
-        _BNO055_CALIB_STAT_SYS_SHIFT            = 6
-    } BNO055_CALIB_STAT_BITS_T;
-
-    /**
-     * BNO055_REG_ST_RESULT bits
-     */
-    typedef enum {
-        BNO055_ST_RESULT_ACC                    = 0x01,
-        BNO055_ST_RESULT_MAG                    = 0x02,
-        BNO055_ST_RESULT_GYR                    = 0x04,
-        BNO055_ST_RESULT_MCU                    = 0x08
-        // 0x10-0x80 reserved
-    } BNO055_ST_RESULT_BITS_T;
-
-    /**
-     * BNO055_REG_INT_STA bits
-     */
-    typedef enum {
-        // 0x01-0x02 reserved
-        BNO055_INT_STA_GYRO_AM                  = 0x04, // gyro any-motion
-        BNO055_INT_STA_GYR_HIGH_RATE            = 0x08,
-        // 0x010 reserved
-        BNO055_INT_STA_ACC_HIGH_G               = 0x20,
-        BNO055_INT_STA_ACC_AM                   = 0x40, // accel any-motion
-        BNO055_INT_STA_ACC_NM                   = 0x80  // accel no-motion
-    } BNO055_INT_STA_BITS_T;
-
-    /**
-     * BNO055_REG_SYS_CLK_STATUS bits
-     */
-    typedef enum {
-        BNO055_SYS_CLK_STATUS_ST_MAIN_CLK       = 0x01
-        // 0x02-0x80 reserved
-    } BNO055_SYS_CLK_STATUS_BITS_T;
-
-    /**
-     * BNO055_REG_SYS_STATUS values
-     */
-    typedef enum {
-        BNO055_SYS_STATUS_IDLE                   = 0,
-        BNO055_SYS_STATUS_SYS_ERR                = 1,
-        BNO055_SYS_STATUS_INIT_PERIPHERALS       = 2,
-        BNO055_SYS_STATUS_SYSTEM_INIT            = 3,
-        BNO055_SYS_STATUS_EXECUTING_SELFTEST     = 4,
-        BNO055_SYS_STATUS_FUSION_RUNNING         = 5,
-        BNO055_SYS_STATUS_NO_FUSION_RUNNING      = 6
-    } BNO055_SYS_STATUS_T;
-
-    /**
-     * BNO055_REG_SYS_ERR values
-     */
-    typedef enum {
-        BNO055_SYS_ERR_NOERROR                   = 0,
-        BNO055_SYS_ERR_PERIPH_INIT_ERROR         = 1,
-        BNO055_SYS_ERR_SYS_INIT_ERROR            = 2,
-        BNO055_SYS_ERR_SELFTEST_FAIL_ERROR       = 3,
-        BNO055_SYS_ERR_REG_VAL_OUTOFRANGE_ERROR  = 4,
-        BNO055_SYS_ERR_REG_ADDR_OUTOFRANGE_ERROR = 5,
-        BNO055_SYS_ERR_REG_WRITE_ERROR           = 6,
-        BNO055_SYS_ERR_LP_MODE_NOT_AVAIL_ERROR   = 7,
-        BNO055_SYS_ERR_ACC_PWR_MODE_NOT_AVAIL_ERROR = 8,
-        BNO055_SYS_ERR_FUSION_CONFIG_ERROR       = 9,
-        BNO055_SYS_ERR_SENSOR_CONFIG_ERROR       = 10
-    } BNO055_SYS_ERR_T;
-
-
-    /**
-     * BNO055_REG_UNIT_SEL bits
-     */
-    typedef enum {
-        BNO055_UNIT_SEL_ACC_UNIT                = 0x01, // 0=m/s^2, 1=mg
-        BNO055_UNIT_SEL_GYR_UNIT                = 0x02, // 0=dps, 1=rps
-        BNO055_UNIT_SEL_EUL_UNIT                = 0x04, // 0=degrees, 1=radians
-        // 0x08 reserved
-        BNO055_UNIT_SEL_TEMP_UNIT               = 0x10, // 0=C, 1=F
-        // 0x20-0x40 reserved
-        BNO055_UNIT_SEL_ORI_ANDROID_WINDOWS     = 0x80  // 0=windows
-                                                        // orient,
-                                                        // 1=android
-    } BNO055_UNIT_SEL_BITS_T;
-
-    /**
-     * BNO055_REG_OPR_MODE bits
-     */
-    typedef enum {
-        BNO055_OPR_MODE_OPERATION_MODE0         = 0x01,
-        BNO055_OPR_MODE_OPERATION_MODE1         = 0x02,
-        BNO055_OPR_MODE_OPERATION_MODE2         = 0x04,
-        BNO055_OPR_MODE_OPERATION_MODE3         = 0x08,
-        _BNO055_OPR_MODE_OPERATION_MODE_MASK    = 15,
-        _BNO055_OPR_MODE_OPERATION_MODE_SHIFT   = 0
-        // 0x10-0x80 reserved
-    } BNO055_OPR_MODE_BITS_T;
-
-    /**
-     * BNO055_OPR_MODE_OPERATION values
-     */
-    typedef enum {
-        BNO055_OPERATION_MODE_CONFIGMODE        = 0,
-        BNO055_OPERATION_MODE_ACCONLY           = 1,
-        BNO055_OPERATION_MODE_MAGONLY           = 2,
-        BNO055_OPERATION_MODE_GYROONLY          = 3,
-        BNO055_OPERATION_MODE_ACCMAG            = 4,
-        BNO055_OPERATION_MODE_ACCGYRO           = 5,
-        BNO055_OPERATION_MODE_MAGGYRO           = 6,
-        BNO055_OPERATION_MODE_AMG               = 7,
-        // fusion modes
-        BNO055_OPERATION_MODE_IMU               = 8,
-        BNO055_OPERATION_MODE_COMPASS           = 9,
-        BNO055_OPERATION_MODE_M4G               = 10,
-        BNO055_OPERATION_MODE_NDOF_FMC_OFF      = 11,
-        BNO055_OPERATION_MODE_NDOF              = 12
-    } BNO055_OPERATION_MODES_T;
-
-    /**
-     * BNO055_REG_PWR_MODE bits
-     */
-    typedef enum {
-        BNO055_PWR_MODE_POWER_MODE0             = 0x01,
-        BNO055_PWR_MODE_POWER_MODE1             = 0x02,
-        _BNO055_PWR_MODE_POWER_MODE_MASK        = 3,
-        _BNO055_PWR_MODE_POWER_MODE_SHIFT       = 0
-        // 0x04-0x80 reserved
-    } BNO055_PWR_MODE_BITS_T;
-
-    /**
-     * BNO055_POWER_MODE values
-     */
-    typedef enum {
-        BNO055_POWER_MODE_NORMAL                = 0,
-        BNO055_POWER_MODE_LOW                   = 1,
-        BNO055_POWER_MODE_SUSPEND               = 2
-    } POWER_MODES_T;
-
-    /**
-     * BNO055_REG_SYS_TRIGGER bits
-     */
-    typedef enum {
-        BNO055_SYS_TRIGGER_SELF_TEST            = 0x01,
-        // 0x02-0x10 reserved
-        BNO055_SYS_TRIGGER_RST_SYS              = 0x20,
-        BNO055_SYS_TRIGGER_RST_INT              = 0x40,
-        BNO055_SYS_TRIGGER_CLK_SEL              = 0x80
-    } BNO055_SYS_TRIGGER_BITS_T;
-
-    /**
-     * BNO055_REG_TEMP_SOURCE bits
-     */
-    typedef enum {
-        BNO055_TEMP_SOURCE_TEMP_SOURCE0         = 0x01,
-        BNO055_TEMP_SOURCE_TEMP_SOURCE1         = 0x02,
-        _BNO055_TEMP_SOURCE_TEMP_SOURCE_MASK    = 3,
-        _BNO055_TEMP_SOURCE_TEMP_SOURCE_SHIFT   = 0
-        // 0x04-0x80 reserved
-    } BNO055_TEMP_SOURCE_BITS_T;
-
-    /**
-     * BNO055_TEMP_SOURCE values
-     */
-    typedef enum {
-        BNO055_TEMP_SOURCE_ACC                  = 0,
-        BNO055_TEMP_SOURCE_GYR                  = 1
-    } BNO055_TEMP_SOURCES_T;
-
-    /**
-     * BNO055_REG_AXIS_MAP_CONFIG bits
-     */
-    typedef enum {
-        BNO055_AXIS_MAP_CONFIG_REMAPPED_X_VAL0  = 0x01,
-        BNO055_AXIS_MAP_CONFIG_REMAPPED_X_VAL1  = 0x02,
-        _BNO055_AXIS_MAP_CONFIG_REMAPPED_X_VAL_MASK = 3,
-        _BNO055_AXIS_MAP_CONFIG_REMAPPED_X_VAL_SHIFT = 0,
-
-        BNO055_AXIS_MAP_CONFIG_REMAPPED_Y_VAL0  = 0x04,
-        BNO055_AXIS_MAP_CONFIG_REMAPPED_Y_VAL1  = 0x08,
-        _BNO055_AXIS_MAP_CONFIG_REMAPPED_Y_VAL_MASK = 3,
-        _BNO055_AXIS_MAP_CONFIG_REMAPPED_Y_VAL_SHIFT = 2,
-
-        BNO055_AXIS_MAP_CONFIG_REMAPPED_Z_VAL0  = 0x10,
-        BNO055_AXIS_MAP_CONFIG_REMAPPED_Z_VAL1  = 0x20,
-        _BNO055_AXIS_MAP_CONFIG_REMAPPED_Z_VAL_MASK = 3,
-        _BNO055_AXIS_MAP_CONFIG_REMAPPED_Z_VAL_SHIFT = 4
-        // 0x40-0x80 reserved
-    } BNO055_AXIS_MAP_CONFIG_BITS_T;
-
-    /**
-     * REMAPPED_AXIS values, applied to X, Y, and Z axes
-     * (BNO055_REG_AXIS_MAP_CONFIG)
-     */
-    typedef enum {
-        BNO055_REMAPPED_AXIS_X                  = 0,
-        BNO055_REMAPPED_AXIS_Y                  = 1,
-        BNO055_REMAPPED_AXIS_Z                  = 2
-    } BNO055_REMAPPED_AXIS_T;
-
-    /**
-     * BNO055_REG_AXIS_MAP_SIGN bits
-     */
-    typedef enum {
-        BNO055_AXIS_MAP_SIGN_REMAPPED_Z_SIGN    = 0x01,
-        BNO055_AXIS_MAP_SIGN_REMAPPED_Y_SIGN    = 0x02,
-        BNO055_AXIS_MAP_SIGN_REMAPPED_X_SIGN    = 0x04
-        // 0x08-0x80 reserved
-    } BNO055_AXIS_MAP_SIGN_BITS_T;
-
-    // Page 1 register enumerants
-
-    /**
-     * BNO055_REG_ACC_CONFIG bits
-     */
-    typedef enum {
-        BNO055_ACC_CONFIG_ACC_RANGE0            = 0x01,
-        BNO055_ACC_CONFIG_ACC_RANGE1            = 0x02,
-        _BNO055_ACC_CONFIG_ACC_RANGE_MASK       = 3,
-        _BNO055_ACC_CONFIG_ACC_RANGE_SHIFT      = 0,
-
-        BNO055_ACC_CONFIG_ACC_BW0               = 0x04,
-        BNO055_ACC_CONFIG_ACC_BW1               = 0x08,
-        BNO055_ACC_CONFIG_ACC_BW2               = 0x10,
-        _BNO055_ACC_CONFIG_ACC_BW_MASK          = 7,
-        _BNO055_ACC_CONFIG_ACC_BW_SHIFT         = 2,
-
-        BNO055_ACC_CONFIG_ACC_PWR_MODE0         = 0x20,
-        BNO055_ACC_CONFIG_ACC_PWR_MODE1         = 0x40,
-        BNO055_ACC_CONFIG_ACC_PWR_MODE2         = 0x80,
-        _BNO055_ACC_CONFIG_ACC_PWR_MODE_MASK    = 7,
-        _BNO055_ACC_CONFIG_ACC_PWR_MODE_SHIFT   = 5
-    } BNO055_ACC_CONFIG_BITS_T;
-
-    /**
-     * BNO055_ACC_CONFIG_ACC_RANGE values
-     */
-    typedef enum {
-        BNO055_ACC_RANGE_2G                     = 0,
-        BNO055_ACC_RANGE_4G                     = 1,
-        BNO055_ACC_RANGE_8G                     = 2,
-        BNO055_ACC_RANGE_16G                    = 3
-    } BNO055_ACC_RANGE_T;
-
-    /**
-     * BNO055_ACC_CONFIG_ACC_BW values
-     */
-    typedef enum {
-        BNO055_ACC_BW_7_81                      = 0, // 7.81 Hz
-        BNO055_ACC_BW_15_53                     = 1,
-        BNO055_ACC_BW_31_25                     = 2,
-        BNO055_ACC_BW_62_5                      = 3,
-        BNO055_ACC_BW_125                       = 4, // 125 Hz
-        BNO055_ACC_BW_250                       = 5,
-        BNO055_ACC_BW_500                       = 6,
-        BNO055_ACC_BW_1000                      = 7
-    } BNO055_ACC_BW_T;
-
-    /**
-     * BNO055_ACC_PWR_MODE values
-     */
-    typedef enum {
-        BNO055_ACC_PWR_MODE_NORMAL              = 0,
-        BNO055_ACC_PWR_MODE_SUSPEND             = 1,
-        BNO055_ACC_PWR_MODE_LOWPOWER1           = 2,
-        BNO055_ACC_PWR_MODE_STANDBY             = 3,
-        BNO055_ACC_PWR_MODE_LOWPOWER2           = 4,
-        BNO055_ACC_PWR_MODE_DEEPSUSPEND         = 5
-    } BNO055_ACC_PWR_MODE_T;
-
-    /**
-     * BNO055_REG_MAG_CONFIG bits
-     */
-    typedef enum {
-        BNO055_MAG_CONFIG_MAG_ODR0              = 0x01,
-        BNO055_MAG_CONFIG_MAG_ODR1              = 0x02,
-        BNO055_MAG_CONFIG_MAG_ODR2              = 0x04,
-        _BNO055_MAG_CONFIG_MAG_ODR_MASK         = 7,
-        _BNO055_MAG_CONFIG_MAG_ODR_SHIFT        = 0,
-
-        BNO055_MAG_CONFIG_MAG_OPR_MODE0         = 0x08,
-        BNO055_MAG_CONFIG_MAG_OPR_MODE1         = 0x10,
-        _BNO055_MAG_CONFIG_MAG_OPR_MODE_MASK    = 3,
-        _BNO055_MAG_CONFIG_MAG_OPR_MODE_SHIFT   = 3,
-
-        BNO055_MAG_CONFIG_MAG_POWER_MODE0       = 0x20,
-        BNO055_MAG_CONFIG_MAG_POWER_MODE1       = 0x40,
-        _BNO055_MAG_CONFIG_MAG_POWER_MODE_MASK  = 3,
-        _BNO055_MAG_CONFIG_MAG_POWER_MODE_SHIFT = 5
-        // 0x80 reserved
-    } BNO055_MAG_CONFIG_BITS_T;
-
-    /**
-     * MAG_ODR values
-     */
-    typedef enum {
-        BNO055_MAG_ODR_2                        = 0, // 2Hz
-        BNO055_MAG_ODR_6                        = 1,
-        BNO055_MAG_ODR_8                        = 2,
-        BNO055_MAG_ODR_10                       = 3,
-        BNO055_MAG_ODR_15                       = 4,
-        BNO055_MAG_ODR_20                       = 5,
-        BNO055_MAG_ODR_25                       = 6,
-        BNO055_MAG_ODR_30                       = 7
-    } BNO055_MAG_ODR_T;
-
-    /**
-     * BNO055_MAG_OPR values
-     */
-    typedef enum {
-        BNO055_MAG_OPR_LOW                      = 0, // low power
-        BNO055_MAG_OPR_REGULAR                  = 1,
-        BNO055_MAG_OPR_ENHANCED_REGULAR         = 2,
-        BNO055_MAG_OPR_HIGH_ACCURACY            = 3
-    } BNO055_MAG_OPR_T;
-
-    /**
-     * BNO055_MAG_POWER values
-     */
-    typedef enum {
-        BNO055_MAG_POWER_NORMAL                 = 0,
-        BNO055_MAG_POWER_SLEEP                  = 1,
-        BNO055_MAG_POWER_SUSPEND                = 2,
-        BNO055_MAG_POWER_FORCE_MODE             = 3
-    } BNO055_MAG_POWER_T;
-
-    /**
-     * BNO055_REG_GYR_CONFIG0 bits
-     */
-    typedef enum {
-        BNO055_GYR_CONFIG0_GYR_RANGE0           = 0x01,
-        BNO055_GYR_CONFIG0_GYR_RANGE1           = 0x02,
-        BNO055_GYR_CONFIG0_GYR_RANGE2           = 0x04,
-        _BNO055_GYR_CONFIG0_GYR_RANGE_MASK      = 7,
-        _BNO055_GYR_CONFIG0_GYR_RANGE_SHIFT     = 0,
-
-        BNO055_GYR_CONFIG0_GYR_BW0              = 0x08,
-        BNO055_GYR_CONFIG0_GYR_BW1              = 0x10,
-        BNO055_GYR_CONFIG0_GYR_BW2              = 0x20,
-        _BNO055_GYR_CONFIG0_GYR_BW_MASK         = 7,
-        _BNO055_GYR_CONFIG0_GYR_BW_SHIFT        = 3
-        // 0x40-0x80 reserved
-    } BNO055_GYR_CONFIG0_BITS_T;
-
-    /**
-     * BNO055_GYR_RANGE values
-     */
-    typedef enum {
-        BNO055_GYR_RANGE_2000                   = 0, // degrees/sec
-        BNO055_GYR_RANGE_1000                   = 1,
-        BNO055_GYR_RANGE_500                    = 2,
-        BNO055_GYR_RANGE_250                    = 3,
-        BNO055_GYR_RANGE_125                    = 4
-    } BNO055_GYR_RANGE_T;
-
-    /**
-     * BNO055_GYR_BW values
-     */
-    typedef enum {
-        BNO055_GYR_BW_523                       = 0, // Hz
-        BNO055_GYR_BW_230                       = 1,
-        BNO055_GYR_BW_116                       = 2,
-        BNO055_GYR_BW_47                        = 3,
-        BNO055_GYR_BW_23                        = 4,
-        BNO055_GYR_BW_12                        = 5,
-        BNO055_GYR_BW_64                        = 6,
-        BNO055_GYR_BW_32                        = 7
-    } BNO055_GYR_BW_T;
-
-    /**
-     * BNO055_REG_GYR_CONFIG1 bits
-     */
-    typedef enum {
-        BNO055_GYR_CONFIG1_GYR_POWER_MODE0      = 0x01,
-        BNO055_GYR_CONFIG1_GYR_POWER_MODE1      = 0x02,
-        BNO055_GYR_CONFIG1_GYR_POWER_MODE2      = 0x04,
-        _BNO055_GYR_CONFIG1_GYR_POWER_MODE_MASK = 7,
-        _BNO055_GYR_CONFIG1_GYR_POWER_MODE_SHIFT = 0
-        // 0x08-0x80 reserved
-    } BNO055_GYR_CONFIG1_BITS_T;
-
-    /**
-     * BNO055_GYR_POWER_MODE values
-     */
-    typedef enum {
-        BNO055_GYR_POWER_MODE_NORMAL            = 0,
-        BNO055_GYR_POWER_MODE_FAST_POWERUP      = 1,
-        BNO055_GYR_POWER_MODE_DEEP_SUSPEND      = 2,
-        BNO055_GYR_POWER_MODE_SUSPEND           = 3,
-        BNO055_GYR_POWER_MODE_ADVANCED_POWERSAVE= 4
-    } BNO055_GYR_POWER_MODE_T;
-
-    /**
-     * BNO055_REG_ACC_SLEEP_CONFIG bits
-     */
-    typedef enum {
-        BNO055_ACC_SLEEP_CONFIG_SLP_MODE        = 0x01, // 0=event,
-                                                        // 1=equidistant
-                                                        // sample
-
-        BNO055_ACC_SLEEP_CONFIG_ACC_SLP_DUR0    = 0x02,
-        BNO055_ACC_SLEEP_CONFIG_ACC_SLP_DUR1    = 0x04,
-        BNO055_ACC_SLEEP_CONFIG_ACC_SLP_DUR2    = 0x08,
-        BNO055_ACC_SLEEP_CONFIG_ACC_SLP_DUR3    = 0x10,
-        _BNO055_ACC_SLEEP_CONFIG_ACC_SLP_DUR_MASK = 15,
-        _BNO055_ACC_SLEEP_CONFIG_ACC_SLP_DUR_SHIFT = 1
-        // 0x20-0x80 reserved
-    } BNO055_ACC_SLEEP_CONFIG_BITS_T;
-
-    /**
-     * BNO055_ACC_SLP_DUR values
-     */
-    typedef enum {
-        BNO055_ACC_SLP_DUR_0_5                  = 0, // 0.5ms
-        // same for 1-5
-
-        BNO055_ACC_SLP_DUR_1                    = 6, // 1ms
-        BNO055_ACC_SLP_DUR_2                    = 7,
-        BNO055_ACC_SLP_DUR_4                    = 8,
-        BNO055_ACC_SLP_DUR_6                    = 9,
-        BNO055_ACC_SLP_DUR_10                   = 10,
-        BNO055_ACC_SLP_DUR_25                   = 11,
-        BNO055_ACC_SLP_DUR_50                   = 12,
-        BNO055_ACC_SLP_DUR_100                  = 13,
-        BNO055_ACC_SLP_DUR_500                  = 14
-        // 15 = 1ms
-    } BNO055_ACC_SLP_DUR_T;
-
-    /**
-     * BNO055_REG_GYR_SLEEP_CONFIG bits
-     */
-    typedef enum {
-        BNO055_GYR_SLEEP_CONFIG_GYR_SLEEP_DUR0  = 0x01,
-        BNO055_GYR_SLEEP_CONFIG_GYR_SLEEP_DUR1  = 0x02,
-        BNO055_GYR_SLEEP_CONFIG_GYR_SLEEP_DUR2  = 0x04,
-        _BNO055_GYR_SLEEP_CONFIG_GYR_SLEEP_DUR_MASK = 7,
-        _BNO055_GYR_SLEEP_CONFIG_GYR_SLEEP_DUR_SHIFT = 0,
-
-        BNO055_GYR_SLEEP_CONFIG_GYR_AUTO_SLP_DUR0 = 0x08,
-        BNO055_GYR_SLEEP_CONFIG_GYR_AUTO_SLP_DUR1 = 0x10,
-        BNO055_GYR_SLEEP_CONFIG_GYR_AUTO_SLP_DUR2 = 0x20,
-        _BNO055_GYR_SLEEP_CONFIG_GYR_AUTO_SLP_DUR_MASK = 7,
-        _BNO055_GYR_SLEEP_CONFIG_GYR_AUTO_SLP_DUR_SHIFT = 3
-        // 0x40-0x80 reserved
-    } BNO055_GYR_SLEEP_CONFIG_BITS_T;
-
-    /**
-     * BNO055_GYR_SLEEP_DUR values
-     */
-    typedef enum {
-        BNO055_GYR_SLEEP_DUR_2                  = 0, // 2ms
-        BNO055_GYR_SLEEP_DUR_4                  = 1,
-        BNO055_GYR_SLEEP_DUR_5                  = 2,
-        BNO055_GYR_SLEEP_DUR_8                  = 3,
-        BNO055_GYR_SLEEP_DUR_10                 = 4,
-        BNO055_GYR_SLEEP_DUR_15                 = 5,
-        BNO055_GYR_SLEEP_DUR_18                 = 6,
-        BNO055_GYR_SLEEP_DUR_20                 = 7
-    } BNO055_GYR_SLEEP_DUR_T;
-
-    /**
-     * BNO055_GYR_AUTO_SLP_DUR values
-     */
-    typedef enum {
-        // 0 = illegal
-        BNO055_GYR_AUTO_SLP_DUR_4               = 1, // ms
-        BNO055_GYR_AUTO_SLP_DUR_5               = 2,
-        BNO055_GYR_AUTO_SLP_DUR_8               = 3,
-        BNO055_GYR_AUTO_SLP_DUR_10              = 4,
-        BNO055_GYR_AUTO_SLP_DUR_15              = 5,
-        BNO055_GYR_AUTO_SLP_DUR_20              = 6,
-        BNO055_GYR_AUTO_SLP_DUR_40              = 7
-    } BNO055_GYR_AUTO_SLP_DUR_T;
-
-    /**
-     * BNO055_REG_INT_MSK and BNO055_REG_INT_EN bits
-     */
-    typedef enum {
-        // 0x00-0x02 reserved
-        BNO055_INT_GYRO_AM                      = 0x04, // gyro any-motion
-        BNO055_INT_GYRO_HIGH_RATE               = 0x08,
-        // 0x10 reserved
-        BNO055_INT_ACC_HIGH_G                   = 0x20,
-        BNO055_INT_ACC_AM                       = 0x40, // acc any-motion
-        BNO055_INT_ACC_NM                       = 0x80, // acc no-motion
-    } BNO055_INT_BITS_T;
-
-    /**
-     * BNO055_REG_ACC_INT_SETTINGS bits
-     */
-    typedef enum {
-        BNO055_ACC_INT_SETTINGS_AM_DUR0         = 0x01,
-        BNO055_ACC_INT_SETTINGS_AM_DUR1         = 0x02,
-        _BNO055_ACC_INT_SETTINGS_AM_DUR_MASK    = 3,
-        _BNO055_ACC_INT_SETTINGS_AM_DUR_SHIFT   = 0,
-
-        BNO055_ACC_INT_SETTINGS_AM_NM_X_AXIS    = 0x04,
-        BNO055_ACC_INT_SETTINGS_AM_NM_Y_AXIS    = 0x08,
-        BNO055_ACC_INT_SETTINGS_AM_NM_Z_AXIS    = 0x10,
-
-        BNO055_ACC_INT_SETTINGS_HG_X_AXIS       = 0x20,
-        BNO055_ACC_INT_SETTINGS_HG_Y_AXIS       = 0x40,
-        BNO055_ACC_INT_SETTINGS_HG_Z_AXIS       = 0x80
-    } BNO055_ACC_INT_SETTINGS_BITS_T;
-
-    /**
-     * BNO055_REG_ACC_NM_SET bits
-     */
-    typedef enum {
-        BNO055_ACC_NM_SET_SM_NM                 = 0x01, // 0=slowmotion,
-                                                        // 1=nomotion
-
-        BNO055_ACC_NM_SET_SM_NM_DUR0            = 0x02,
-        BNO055_ACC_NM_SET_SM_NM_DUR1            = 0x04,
-        BNO055_ACC_NM_SET_SM_NM_DUR2            = 0x08,
-        BNO055_ACC_NM_SET_SM_NM_DUR3            = 0x10,
-        BNO055_ACC_NM_SET_SM_NM_DUR4            = 0x20,
-        BNO055_ACC_NM_SET_SM_NM_DUR5            = 0x40,
-        _BNO055_ACC_NM_SET_SM_NM_DUR_MASK       = 63,
-        _BNO055_ACC_NM_SET_SM_NM_DUR_SHIFT      = 1
-        // 0x80 reserved
-    } BNO055_ACC_NM_SET_BITS_T;
-
-    /**
-     * BNO055_REG_GYR_INT_SETTING bits
-     */
-    typedef enum {
-        BNO055_GYR_INT_SETTING_AM_X_AXIS        = 0x01,
-        BNO055_GYR_INT_SETTING_AM_Y_AXIS        = 0x02,
-        BNO055_GYR_INT_SETTING_AM_Z_AXIS        = 0x04,
-
-        BNO055_GYR_INT_SETTING_HR_X_AXIS        = 0x08,
-        BNO055_GYR_INT_SETTING_HR_Y_AXIS        = 0x10,
-        BNO055_GYR_INT_SETTING_HR_Z_AXIS        = 0x20,
-
-        BNO055_GYR_INT_SETTING_AM_FILT          = 0x40,
-        BNO055_GYR_INT_SETTING_HR_FILT          = 0x80
-    } BNO055_GYR_INT_SETTING_BITS_T;
-
-    /**
-     * BNO055_REG_GYR_HR_X_SET, BNO055_REG_GYR_HR_Y_SET, and
-     * BNO055_REG_GYR_HR_Z_SET bits
-     */
-    typedef enum {
-        BNO055_GYR_HR_XYZ_SET_HR_THRESH0        = 0x01,
-        BNO055_GYR_HR_XYZ_SET_HR_THRESH1        = 0x02,
-        BNO055_GYR_HR_XYZ_SET_HR_THRESH2        = 0x04,
-        BNO055_GYR_HR_XYZ_SET_HR_THRESH3        = 0x08,
-        BNO055_GYR_HR_XYZ_SET_HR_THRESH4        = 0x10,
-        _BNO055_GYR_HR_XYZ_SET_HR_THRESH_MASK   = 31,
-        _BNO055_GYR_HR_XYZ_SET_HR_THRESH_SHIFT  = 0,
-
-        BNO055_GYR_HR_XYZ_SET_HR_THRESH_HYST0   = 0x20,
-        BNO055_GYR_HR_XYZ_SET_HR_THRESH_HYST1   = 0x40,
-        _BNO055_GYR_HR_XYZ_SET_HR_THRESH_HYST_MASK = 3,
-        _BNO055_GYR_HR_XYZ_SET_HR_THRESH_HYST_SHIFT = 5
-    } BNO055_GYR_HR_XYZ_SET_BITS_T;
-
-    /**
-     * BNO055_REG_GYR_AM_SET bits
-     */
-    typedef enum {
-        BNO055_GYR_AM_SET_SLOPE_SAMPLES0        = 0x01,
-        BNO055_GYR_AM_SET_SLOPE_SAMPLES1        = 0x02,
-        _BNO055_GYR_AM_SET_SLOPE_SAMPLES_MASK   = 3,
-        _BNO055_GYR_AM_SET_SLOPE_SAMPLES_SHIFT  = 0,
-
-        BNO055_GYR_AM_SET_AWAKE_DUR0            = 0x04,
-        BNO055_GYR_AM_SET_AWAKE_DUR1            = 0x08,
-        _BNO055_GYR_AM_SET_AWAKE_DUR_MASK       = 3,
-        _BNO055_GYR_AM_SET_AWAKE_DUR_SHIFT      = 2
-
-        // 0x10-0x80 reserved
-    } BNO055_GYR_AM_SET_BITS_T;
-
-    /**
-     * BNO055_GYR_AM_SET_SLOPE_SAMPLES values
-     */
-    typedef enum {
-        BNO055_SLOPE_SAMPLES_8                  = 0, // 8 samples
-        BNO055_SLOPE_SAMPLES_16                 = 1,
-        BNO055_SLOPE_SAMPLES_32                 = 2,
-        BNO055_SLOPE_SAMPLES_64                 = 3
-    } BNO055_SLOPE_SAMPLES_T;
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/button/CMakeLists.txt b/src/button/CMakeLists.txt
deleted file mode 100644
index 7881c80..0000000
--- a/src/button/CMakeLists.txt
+++ /dev/null
@@ -1,7 +0,0 @@
-upm_mixed_module_init (NAME button
-    DESCRIPTION "Button"
-    C_HDR button.h
-    C_SRC button.c
-    CPP_HDR button.hpp
-    CPP_SRC button.cxx
-    REQUIRES mraa)
diff --git a/src/button/button.c b/src/button/button.c
deleted file mode 100644
index 530190f..0000000
--- a/src/button/button.c
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Authors: Brendan Le Foll <brendan.le.foll@intel.com>
- *          Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- *          Sarah Knepper <sarah.knepper@intel.com>
- *          Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2014 - 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "button.h"
-
-button_context button_init(int pin){
-    // make sure that mraa is initialized
-    int mraa_rv;
-    if((mraa_rv = mraa_init()) != MRAA_SUCCESS){
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        return NULL;
-    }
-
-    button_context dev = (button_context) malloc(sizeof(struct _button_context));
-
-    if (dev == NULL){
-        printf("Unable to allocate space for the sensor structure\n");
-        return NULL;
-    }
-
-    dev->gpio = mraa_gpio_init(pin);
-    mraa_gpio_dir(dev->gpio, MRAA_GPIO_IN);
-    dev->isr_installed = false;
-
-    return dev;
-}
-
-void button_close(button_context dev){
-    mraa_gpio_close(dev->gpio);
-    free(dev);
-}
-
-upm_result_t button_get_value(button_context dev, bool* val){
-    int ret = mraa_gpio_read(dev->gpio);
-
-    if(ret > 0)
-        *val = true;
-    else
-        *val = false;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t button_install_isr(button_context dev, mraa_gpio_edge_t edge_level, void (*isr)(void *), void *arg){
-    button_uninstall_isr(dev);
-
-    mraa_gpio_isr(dev->gpio, edge_level, isr, arg);
-    dev->isr_installed = true;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t button_uninstall_isr(button_context dev){
-    if(dev->isr_installed)
-        mraa_gpio_isr_exit(dev->gpio);
-
-    dev->isr_installed = false;
-
-    return UPM_SUCCESS;
-}
diff --git a/src/button/button.cxx b/src/button/button.cxx
deleted file mode 100644
index 2c3018f..0000000
--- a/src/button/button.cxx
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Authors: Brendan Le Foll <brendan.le.foll@intel.com>
- *          Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- *          Sarah Knepper <sarah.knepper@intel.com>
- * Copyright (c) 2014 - 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "button.hpp"
-
-using namespace std;
-using namespace upm;
-
-Button::Button(unsigned int pin)
-{
-    if ( !(m_gpio = mraa_gpio_init(pin)) ) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_gpio_init() failed, invalid pin?");
-        return;
-    }
-    mraa_gpio_dir(m_gpio, MRAA_GPIO_IN);
-    m_name = "Button Sensor";
-}
-
-Button::~Button()
-{
-    mraa_gpio_close(m_gpio);
-}
-
-std::string Button::name()
-{
-    return m_name;
-}
-
-int Button::value()
-{
-    return mraa_gpio_read(m_gpio);
-}
-
-void Button::installISR(mraa::Edge level, void (*isr)(void *), void *arg)
-{
-  if (m_isrInstalled)
-    uninstallISR();
-
-  // install our interrupt handler
-  mraa_gpio_isr(m_gpio, (mraa_gpio_edge_t) level, isr, arg);
-  m_isrInstalled = true;
-}
-
-void Button::uninstallISR()
-{
-  mraa_gpio_isr_exit(m_gpio);
-  m_isrInstalled = false;
-}
diff --git a/src/button/button.h b/src/button/button.h
deleted file mode 100644
index 9a9ac01..0000000
--- a/src/button/button.h
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Authors: Brendan Le Foll <brendan.le.foll@intel.com>
- *          Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- *          Sarah Knepper <sarah.knepper@intel.com>
- *          Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2014 - 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-#include <stdio.h>
-
-#include "upm.h"
-#include "mraa/gpio.h"
-
-/**
- * @brief Button library
- * @defgroup buttonlib libupm-button
- * @ingroup seeed gpio button gsk
- */
-
-/**
- * @library buttonlib
- * @sensor button
- * @comname Button
- * @altname Grove Button
- * @type button
- * @man seeed
- * @con gpio
- * @kit gsk
- *
- * @brief API for the Button
- *
- * Basic UPM module for the button sensor
- *
- * @image html button.jpg
- * @snippet button.cxx Interesting
- */
-
-typedef struct _button_context {
-    mraa_gpio_context    gpio;
-    bool                 isr_installed;
-} *button_context;
-
-/**
- * button init function
- *
- * @param pin Pin to use
- */
-button_context button_init(int pin);
-
-/**
- * button destructor
- */
-void button_close(button_context dev);
-/**
- * Gets the value from the GPIO pin
- *
- * @return Value from the GPIO pin
- */
-upm_result_t button_get_value(button_context dev, bool* val);
-/**
- * Installs an interrupt service routine (ISR) to be called when
- * the button is activated or deactivated.
- *
- * @param fptr Pointer to a function to be called on interrupt
- * @param arg Pointer to an object to be supplied as an
- * argument to the ISR.
- */
-upm_result_t button_install_isr(button_context dev, mraa_gpio_edge_t edge_level, void (*isr)(void *), void *arg);
-/**
- * Uninstalls the previously installed ISR
- *
- */
-upm_result_t button_uninstall_isr(button_context);
diff --git a/src/button/button.hpp b/src/button/button.hpp
deleted file mode 100644
index f90bbe9..0000000
--- a/src/button/button.hpp
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Authors: Brendan Le Foll <brendan.le.foll@intel.com>
- *          Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- *          Sarah Knepper <sarah.knepper@intel.com>
- * Copyright (c) 2014 - 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <string>
-#include <mraa/gpio.hpp>
-
-namespace upm {
-
-/**
- * @brief Button/Switch Library
- * @defgroup buttonlib libupm-button
- * @ingroup seeed gpio button gsk
- */
-
-/**
- * @library buttonlib
- * @sensor button
- * @comname Button
- * @altname Grove Button
- * @type button
- * @man seeed
- * @con gpio
- * @kit gsk
- *
- * @brief API for the Button
- *
- * Basic UPM module for the button sensor
- *
- * @image html button.jpg
- * @snippet button.cxx Interesting
- */
-class Button{
-    public:
-        /**
-         * button constructor
-         *
-         * @param pin Pin to use
-         */
-        Button(unsigned int pin);
-        /**
-         * button destructor
-         */
-        ~Button();
-        /**
-         * Gets the name of the sensor
-         *
-         * @return Name of this sensor
-         */
-        std::string name();
-        /**
-         * Gets the value from the GPIO pin
-         *
-         * @return Value from the GPIO pin
-         */
-        int value();
-
-        /**
-         * Installs an interrupt service routine (ISR) to be called when
-         * the button is activated or deactivated.
-         *
-         * @param fptr Pointer to a function to be called on interrupt
-         * @param arg Pointer to an object to be supplied as an
-         * argument to the ISR.
-         */
-        void installISR(mraa::Edge level, void (*isr)(void *), void *arg);
-
-        /**
-         * Uninstalls the previously installed ISR
-         *
-         */
-        void uninstallISR();
-
-    private:
-        bool m_isrInstalled;
-        std::string m_name;
-        mraa_gpio_context m_gpio;
-};
-}
diff --git a/src/button/button.i b/src/button/button.i
deleted file mode 100644
index ac34e35..0000000
--- a/src/button/button.i
+++ /dev/null
@@ -1,18 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%apply int {mraa::Edge}
-
-JAVA_ADD_INSTALLISR_EDGE(upm::Button)
-
-JAVA_JNI_LOADLIBRARY(javaupm_button)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "button.hpp"
-%}
-%include "button.hpp"
-/* END Common SWIG syntax */
diff --git a/src/button/button.json b/src/button/button.json
deleted file mode 100644
index e3fac42..0000000
--- a/src/button/button.json
+++ /dev/null
@@ -1,32 +0,0 @@
-{
-    "Library": "button",
-    "Description": "Generic library for buttons & switches",
-    "Sensor Class":
-    {
-        "Button":
-        {
-            "Name": "Button",
-            "Description": "Basic UPM module for buttons and switches. Allows attaching a callback function to state transitions.",
-            "Aliases": ["Grove - Button"],
-            "Categories": ["button"],
-            "Connections": ["gpio"],
-            "Project Type": ["prototyping", "industrial"],
-            "Manufacturers": ["seeed", "dfrobot", "sparkfun", "adafruit", "generic"],
-            "Kits": ["gsk"],
-            "Image": "button.jpg",
-            "Examples":
-            {
-                "Java": ["Button_Example.java", "Button_intr_Example.java"],
-                "Python": ["button.py"],
-                "Node.js": ["button.js"],
-                "C++": ["button.cxx"],
-                "C": ["button.c", "button-intr.c"]
-            },
-            "Urls" :
-            {
-                "Product Pages": ["http://wiki.seeed.cc/Grove-Button/"],
-                "Schematics": ["https://easyeda.com/Seeed/Grove_Button_v1_2-f0f9f212fcee460ebe3703dab813e5c4"]
-            }
-        }
-    }
-}
diff --git a/src/buzzer/CMakeLists.txt b/src/buzzer/CMakeLists.txt
deleted file mode 100644
index d4917f7..0000000
--- a/src/buzzer/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME buzzer
-    DESCRIPTION "Buzzer"
-    C_HDR buzzer.h buzzer_tones.h
-    C_SRC buzzer.c
-    CPP_HDR buzzer.hpp
-    CPP_SRC buzzer.cxx
-#    FTI_SRC buzzer_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/buzzer/buzzer.c b/src/buzzer/buzzer.c
deleted file mode 100644
index dfb2a1b..0000000
--- a/src/buzzer/buzzer.c
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * based on original C++ driver by
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <assert.h>
-#include <unistd.h>
-#include <upm_utilities.h>
-#include "buzzer.h"
-
-buzzer_context buzzer_init(int pin)
-{
-    buzzer_context dev =
-        (buzzer_context)malloc(sizeof(struct _buzzer_context));
-
-    if (!dev)
-        return NULL;
-
-    dev->pwm = NULL;
-    dev->volume = 0.0;
-    dev->initialized = false;
-
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        buzzer_close(dev);
-        return NULL;
-    }
-
-    // MRAA contexts...
-    if ( !(dev->pwm = mraa_pwm_init(pin)) )
-    {
-        printf("%s: mraa_pwm_init() failed\n",
-               __FUNCTION__);
-        buzzer_close(dev);
-        return NULL;
-    }
-
-    mraa_pwm_enable(dev->pwm, 1);
-
-    buzzer_set_volume(dev, 1.0);
-
-    dev->initialized = true;
-    return dev;
-}
-
-void buzzer_close(buzzer_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->initialized)
-        buzzer_stop_sound(dev);
-
-    if (dev->pwm)
-    {
-        mraa_pwm_enable(dev->pwm, 0);
-        mraa_pwm_close(dev->pwm);
-    }
-
-    free(dev);
-}
-
-void buzzer_set_volume(const buzzer_context dev, float vol)
-{
-    assert(dev != NULL);
-
-    dev->volume = vol;
-}
-
-float buzzer_get_volume(const buzzer_context dev)
-{
-    assert(dev != NULL);
-
-    return dev->volume;
-}
-
-upm_result_t buzzer_play_sound(const buzzer_context dev, int note, int delay)
-{
-    assert(dev != NULL);
-
-    if (mraa_pwm_period_us(dev->pwm, note) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_pwm_period_us() did not succeed\n", __FUNCTION__);
-    }
-
-    if (mraa_pwm_write(dev->pwm, dev->volume * 0.5))
-    {
-        printf("%s: mraa_pwm_write() failed\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    if (delay >= 0)
-    {
-        upm_delay_us(delay);
-        return buzzer_stop_sound(dev);
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t buzzer_stop_sound(const buzzer_context dev)
-{
-    assert(dev != NULL);
-
-    mraa_result_t rv = MRAA_SUCCESS;
-
-    rv = mraa_pwm_period_us(dev->pwm, 1);
-    rv = mraa_pwm_write(dev->pwm, 0);
-
-    if (rv)
-    {
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
diff --git a/src/buzzer/buzzer.cxx b/src/buzzer/buzzer.cxx
deleted file mode 100644
index bb29666..0000000
--- a/src/buzzer/buzzer.cxx
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * based on original C++ driver by
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-#include <unistd.h>
-
-#include "buzzer.hpp"
-
-using namespace upm;
-using namespace std;
-
-Buzzer::Buzzer(int pinNumber) : m_buzzer(buzzer_init(pinNumber))
-{
-    if (!m_buzzer)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": buzzer_init() failed");
-}
-
-Buzzer::~Buzzer()
-{
-    buzzer_close(m_buzzer);
-}
-
-void Buzzer::setVolume(float vol)
-{
-    buzzer_set_volume(m_buzzer, vol);
-}
-
-float Buzzer::getVolume()
-{
-    return buzzer_get_volume(m_buzzer);
-}
-
-int Buzzer::playSound(int note, int delay)
-{
-    if (buzzer_play_sound(m_buzzer, note, delay))
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": buzzer_play_sound() failed");
-    return note;
-}
-
-void Buzzer::stopSound()
-{
-    if (buzzer_stop_sound(m_buzzer))
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": buzzer_stop_sound() failed");
-}
-
diff --git a/src/buzzer/buzzer.h b/src/buzzer/buzzer.h
deleted file mode 100644
index 712dc1e..0000000
--- a/src/buzzer/buzzer.h
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * based on original C++ driver by
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <upm.h>
-
-#include <mraa/pwm.h>
-#include "buzzer_tones.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    /**
-     * @file buzzer.h
-     * @library buzzer
-     * @brief C API for the buzzer driver
-     *
-     * @include buzzer.c
-     */
-
-    /**
-     * Device context
-     */
-    typedef struct _buzzer_context {
-        mraa_pwm_context pwm;
-
-        float volume;
-        bool initialized;
-    } *buzzer_context;
-
-    /**
-     * Initialize a buzzer context.
-     *
-     * @param pin Buzzer pin number (pwm capable)
-     * @return buzzer device context
-     */
-    buzzer_context buzzer_init(int pin);
-
-    /**
-     * Buzzer object destructor.
-     *
-     * @param dev Device context.
-     */
-    void buzzer_close(buzzer_context dev);
-
-    /**
-     * Plays a tone for a certain amount of time or indefinitely. When delay
-     * is not used, the sound can be stopped by calling stopSound().
-     *
-     * @param dev Device context.
-     * @param note Note to play (DO, RE, MI, etc.) or frequency
-     * @param delay Time in microseconds for which to play the sound;
-     * if the value is 0, the sound is played indefinitely
-     * @return UPM result
-     */
-    upm_result_t buzzer_play_sound(const buzzer_context dev, int note,
-                                   int delay);
-
-    /**
-     * Stops the sound currently playing. Should be called when playSound()
-     * does not have a delay value.
-     *
-     * @param dev Device context.
-     * @return UPM result
-     */
-    upm_result_t buzzer_stop_sound(const buzzer_context dev);
-
-    /**
-     * Sets the volume for the buzzer, but may affect the sound timbre.
-     * Works best with halved values; e.g., 1.0, 0.5, 0.25, etc.
-     *
-     * @param dev Device context.
-     * @param vol Value to set the volume to, from 0.0 to 1.0
-     */
-    void buzzer_set_volume(const buzzer_context dev, float vol);
-
-    /**
-     * Gets the buzzer volume.
-     *
-     * @param dev Device context.
-     * @return Value the volume was set to
-     */
-    float buzzer_get_volume(const buzzer_context dev);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/buzzer/buzzer.hpp b/src/buzzer/buzzer.hpp
deleted file mode 100644
index ab1dac0..0000000
--- a/src/buzzer/buzzer.hpp
+++ /dev/null
@@ -1,127 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * based on original C++ driver by
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <buzzer.h>
-
-namespace upm {
-
-    /**
-     * @brief Piezoelectric Buzzers Library
-     * @defgroup buzzer libupm-buzzer
-     * @ingroup seeed pwm sound gsk
-     */
-
-    /**
-     * @library buzzer
-     * @sensor buzzer
-     * @comname Buzzer
-     * @type sound
-     * @man seeed
-     * @con pwm
-     * @kit gsk
-     *
-     * @brief API for the Buzzer component
-     *
-     * This module defines the Buzzer interface for libbuzzer.
-     * This sensor can make different tones when connected to
-     * a pin capable of analog pulse-width modulation. It emits
-     * sound using a piezoelectric material that vibrates at different
-     * frequencies based on the input voltage.
-     *
-     * @image html buzzer.jpg
-     * @snippet buzzer.cxx Interesting
-     */
-
-    class Buzzer {
-    public:
-        /**
-         * Instantiates a Buzzer object.
-         *
-         * @param pinNumber Buzzer pin number
-         */
-        Buzzer(int pinNumber);
-
-        /**
-         * Buzzer object destructor.
-         */
-        ~Buzzer();
-
-        /**
-         * Plays a tone for a certain amount of time or indefinitely. When delay
-         * is not used, the sound can be stopped by calling stopSound().
-         *
-         * @param note Note to play (DO, RE, MI, etc.) or frequency
-         * @param delay Time in microseconds for which to play the
-         * sound; if the value is 0, the sound is played indefinitely
-         *
-         * @return Note played
-         */
-        int playSound(int note, int delay);
-
-        /**
-         * Stops the sound currently playing. Should be called when playSound()
-         * does not have a delay value.
-         */
-        void stopSound();
-
-        /**
-         * Sets the volume for the buzzer, but may affect the sound timbre.
-         * Works best with halved values; e.g., 1.0, 0.5, 0.25, etc.
-         *
-         * @param vol Value to set the volume to, from 0.0 to 1.0
-         */
-        void setVolume(float vol);
-
-        /**
-         * Gets the buzzer volume.
-         *
-         * @return Value the volume was set to
-         */
-        float getVolume();
-
-        /**
-         * Returns the name of the sensor.
-         *
-         * @return Name of the sensor
-         */
-        std::string name()
-        {
-            return m_name;
-        }
-    protected:
-        std::string m_name;
-        buzzer_context m_buzzer;
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        Buzzer(const Buzzer&) = delete;
-        Buzzer &operator=(const Buzzer&) = delete;
-    };
-}
diff --git a/src/buzzer/buzzer.i b/src/buzzer/buzzer.i
deleted file mode 100644
index b2191d6..0000000
--- a/src/buzzer/buzzer.i
+++ /dev/null
@@ -1,15 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_buzzer)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "buzzer.hpp"
-%}
-%include "buzzer_tones.h"
-%include "buzzer.hpp"
-/* END Common SWIG syntax */
diff --git a/src/buzzer/buzzer.json b/src/buzzer/buzzer.json
deleted file mode 100644
index b61d985..0000000
--- a/src/buzzer/buzzer.json
+++ /dev/null
@@ -1,40 +0,0 @@
-{
-    "Library": "buzzer",
-    "Description": "Generic library for piezoelectric buzzers",
-    "Sensor Class":
-    {
-        "Buzzer":
-        {
-            "Name": "Buzzer",
-            "Description": "This module defines the Buzzer interface for libbuzzer. This sensor can make different tones when connected to a pin capable of analog pulse-width modulation. It emits sound using a piezoelectric material that vibrates at different frequencies based on the input voltage.",
-            "Aliases": ["Grove - Buzzer"],
-            "Categories": ["sound"],
-            "Connections": ["pwm"],
-            "Project Type": ["prototyping", "industrial"],
-            "Manufacturers": ["seeed", "dfrobot", "sparkfun", "adafruit", "generic"],
-            "Kits": ["gsk"],
-            "Image": "buzzer.jpg",
-            "Examples":
-            {
-                "Java": ["Buzzer_Example.java"],
-                "Python": ["buzzer.py"],
-                "Node.js": ["buzzer.js"],
-                "C++": ["buzzer.cxx"],
-                "C": ["buzzer.c"]
-            },
-            "Platforms":
-            {
-                "Intel Edison":
-                {
-                    "Notes": ["Might not work correctly with early versions of MRAA/UPM libraries, please use the latest versions."]
-                }
-            },
-            "Urls" :
-            {
-                "Product Pages": ["http://wiki.seeed.cc/Grove-Buzzer/"],
-                "Datasheets": ["https://cdn.sparkfun.com/datasheets/Components/General/cem-1203-42-.pdf"],
-                "Schematics": ["https://easyeda.com/Seeed/Grove_Buzzer_v1_2-c713baf3c1774da39ce0c995544ce5da"]
-            }
-        }
-    }
-}
diff --git a/src/buzzer/buzzer_tones.h b/src/buzzer/buzzer_tones.h
deleted file mode 100644
index 969c098..0000000
--- a/src/buzzer/buzzer_tones.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * based on original C++ driver by
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-// Hz = 1000000 / N
-#define  BUZZER_DO     3800    // 262 Hz - C4
-#define  BUZZER_RE     3400    // 294 Hz - D
-#define  BUZZER_MI     3000    // 330 Hz - E
-#define  BUZZER_FA     2900    // 349 Hz - F
-#define  BUZZER_SOL    2550    // 392 Hz - G
-#define  BUZZER_LA     2270    // 440 Hz - A
-#define  BUZZER_SI     2000    // 494 Hz - B
-- 
2.7.4

