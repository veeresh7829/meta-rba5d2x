From 5951b6ed94142591c6722268ffe8d28d0f85c77e Mon Sep 17 00:00:00 2001
From: Ganesh K <ganesh.k@phytec.in>
Date: Mon, 24 Jun 2019 18:48:43 +0530
Subject: [PATCH 11/11] starting with jklm files

---
 src/jhd1313m1/CMakeLists.txt     |    8 -
 src/jhd1313m1/jhd1313m1.c        |  367 ----------
 src/jhd1313m1/jhd1313m1.cxx      |  170 -----
 src/jhd1313m1/jhd1313m1.h        |  253 -------
 src/jhd1313m1/jhd1313m1.hpp      |  259 -------
 src/jhd1313m1/jhd1313m1.i        |   29 -
 src/jhd1313m1/jhd1313m1.json     |   37 -
 src/joystick12/CMakeLists.txt    |    8 -
 src/joystick12/joystick12.c      |  214 ------
 src/joystick12/joystick12.cxx    |  100 ---
 src/joystick12/joystick12.h      |  159 ----
 src/joystick12/joystick12.hpp    |   97 ---
 src/joystick12/joystick12.i      |   14 -
 src/joystick12/joystick12.json   |   33 -
 src/joystick12/joystick12_fti.c  |  143 ----
 src/kx122/CMakeLists.txt         |    8 -
 src/kx122/kx122.c                | 1093 ----------------------------
 src/kx122/kx122.cxx              |  369 ----------
 src/kx122/kx122.h                |  675 -----------------
 src/kx122/kx122.hpp              |  513 -------------
 src/kx122/kx122.i                |   20 -
 src/kx122/kx122.json             |   47 --
 src/kx122/kx122_registers.h      |  539 --------------
 src/kxcjk1013/CMakeLists.txt     |    7 -
 src/kxcjk1013/kxcjk1013.cxx      |  202 ------
 src/kxcjk1013/kxcjk1013.hpp      |  135 ----
 src/kxcjk1013/kxcjk1013.json     |   39 -
 src/kxtj3/CMakeLists.txt         |    8 -
 src/kxtj3/kxtj3.c                | 1095 ----------------------------
 src/kxtj3/kxtj3.cxx              |  315 --------
 src/kxtj3/kxtj3.h                |  746 -------------------
 src/kxtj3/kxtj3.hpp              |  565 ---------------
 src/kxtj3/kxtj3.i                |   20 -
 src/kxtj3/kxtj3.json             |   72 --
 src/kxtj3/kxtj3_registers.h      |  204 ------
 src/l298/CMakeLists.txt          |    5 -
 src/l298/l298.cxx                |  348 ---------
 src/l298/l298.hpp                |  194 -----
 src/l298/l298.json               |   38 -
 src/l3gd20/CMakeLists.txt        |    7 -
 src/l3gd20/l3gd20.cxx            |  709 ------------------
 src/l3gd20/l3gd20.hpp            |  712 ------------------
 src/l3gd20/l3gd20.json           |   39 -
 src/lcd/CMakeLists.txt           |    5 -
 src/lcd/eboled.cxx               |  567 ---------------
 src/lcd/eboled.hpp               |  375 ----------
 src/lcd/hd44780_bits.hpp         |   86 ---
 src/lcd/lcd.cxx                  |   52 --
 src/lcd/lcd.hpp                  |   54 --
 src/lcd/lcd.i                    |   56 --
 src/lcd/lcd_private.hpp          |   34 -
 src/lcd/license.txt              |   24 -
 src/lcd/ssd.hpp                  |  135 ----
 src/lcd/ssd1306.cxx              |  312 --------
 src/lcd/ssd1306.hpp              |  230 ------
 src/lcd/ssd1308.cxx              |  166 -----
 src/lcd/ssd1308.hpp              |  116 ---
 src/lcd/ssd1327.cxx              |  318 --------
 src/lcd/ssd1327.hpp              |  126 ----
 src/lcdks/CMakeLists.txt         |    8 -
 src/lcdks/lcdks.c                |  217 ------
 src/lcdks/lcdks.cxx              |  160 ----
 src/lcdks/lcdks.h                |  235 ------
 src/lcdks/lcdks.hpp              |  275 -------
 src/lcdks/lcdks.i                |   29 -
 src/lcdks/lcdks.json             |   36 -
 src/lcm1602/CMakeLists.txt       |    8 -
 src/lcm1602/hd44780_bits.h       |   82 ---
 src/lcm1602/lcm1602.c            |  640 ----------------
 src/lcm1602/lcm1602.cxx          |  172 -----
 src/lcm1602/lcm1602.h            |  278 -------
 src/lcm1602/lcm1602.hpp          |  263 -------
 src/lcm1602/lcm1602.i            |   29 -
 src/lcm1602/lcm1602.json         |   37 -
 src/ldt0028/CMakeLists.txt       |    8 -
 src/ldt0028/ldt0028.c            |  136 ----
 src/ldt0028/ldt0028.cxx          |   54 --
 src/ldt0028/ldt0028.h            |  141 ----
 src/ldt0028/ldt0028.hpp          |   88 ---
 src/ldt0028/ldt0028.json         |   37 -
 src/ldt0028/ldt0028_fti.c        |   92 ---
 src/led/CMakeLists.txt           |    9 -
 src/led/led.c                    |  126 ----
 src/led/led.cxx                  |   75 --
 src/led/led.h                    |  104 ---
 src/led/led.hpp                  |  110 ---
 src/led/led.i                    |   16 -
 src/led/led.json                 |   32 -
 src/led/led_fti.c                |   76 --
 src/lidarlitev3/CMakeLists.txt   |    5 -
 src/lidarlitev3/lidarlitev3.cxx  |  134 ----
 src/lidarlitev3/lidarlitev3.hpp  |  162 -----
 src/lidarlitev3/lidarlitev3.i    |   14 -
 src/lidarlitev3/lidarlitev3.json |   38 -
 src/light/CMakeLists.txt         |   10 -
 src/light/light.c                |  140 ----
 src/light/light.cxx              |  119 ---
 src/light/light.h                |  141 ----
 src/light/light.hpp              |  179 -----
 src/light/light.json             |   40 -
 src/light/light_fti.c            |  119 ---
 src/linefinder/CMakeLists.txt    |    9 -
 src/linefinder/linefinder.c      |   84 ---
 src/linefinder/linefinder.cxx    |   55 --
 src/linefinder/linefinder.h      |   77 --
 src/linefinder/linefinder.hpp    |   91 ---
 src/linefinder/linefinder.json   |   40 -
 src/linefinder/linefinder_fti.c  |   94 ---
 src/lis2ds12/CMakeLists.txt      |    9 -
 src/lis2ds12/lis2ds12.c          |  624 ----------------
 src/lis2ds12/lis2ds12.cxx        |  201 ------
 src/lis2ds12/lis2ds12.h          |  323 ---------
 src/lis2ds12/lis2ds12.hpp        |  312 --------
 src/lis2ds12/lis2ds12.i          |   23 -
 src/lis2ds12/lis2ds12.json       |   38 -
 src/lis2ds12/lis2ds12_defs.h     |  561 --------------
 src/lis2ds12/lis2ds12_fti.c      |  113 ---
 src/lis3dh/CMakeLists.txt        |    9 -
 src/lis3dh/lis3dh.c              |  809 ---------------------
 src/lis3dh/lis3dh.cxx            |  276 -------
 src/lis3dh/lis3dh.h              |  382 ----------
 src/lis3dh/lis3dh.hpp            |  368 ----------
 src/lis3dh/lis3dh.i              |   26 -
 src/lis3dh/lis3dh.json           |   38 -
 src/lis3dh/lis3dh_defs.h         |  505 -------------
 src/lis3dh/lis3dh_fti.c          |  116 ---
 src/lm35/CMakeLists.txt          |    9 -
 src/lm35/lm35.c                  |  109 ---
 src/lm35/lm35.cxx                |   65 --
 src/lm35/lm35.h                  |  104 ---
 src/lm35/lm35.hpp                |  108 ---
 src/lm35/lm35.json               |   38 -
 src/lm35/lm35_fti.c              |  135 ----
 src/lol/CMakeLists.txt           |    5 -
 src/lol/lol.cxx                  |  186 -----
 src/lol/lol.hpp                  |  100 ---
 src/lol/lol.i                    |   29 -
 src/lol/lol.json                 |   32 -
 src/loudness/CMakeLists.txt      |    9 -
 src/loudness/loudness.c          |   62 --
 src/loudness/loudness.cxx        |   48 --
 src/loudness/loudness.h          |   75 --
 src/loudness/loudness.hpp        |   96 ---
 src/loudness/loudness.json       |   39 -
 src/loudness/loudness_fti.c      |   79 --
 src/lp8860/CMakeLists.txt        |    5 -
 src/lp8860/lp8860.cxx            |  280 -------
 src/lp8860/lp8860.hpp            |   86 ---
 src/lp8860/lp8860.i              |   17 -
 src/lp8860/lp8860.json           |   42 --
 src/lp8860/mraa-utils.cxx        |   74 --
 src/lp8860/mraa-utils.hpp        |   37 -
 src/lpd8806/CMakeLists.txt       |    5 -
 src/lpd8806/lpd8806.cxx          |  118 ---
 src/lpd8806/lpd8806.hpp          |  129 ----
 src/lpd8806/lpd8806.json         |   37 -
 src/lsm303agr/CMakeLists.txt     |    9 -
 src/lsm303agr/lsm303agr.c        |  792 --------------------
 src/lsm303agr/lsm303agr.cxx      |  210 ------
 src/lsm303agr/lsm303agr.h        |  382 ----------
 src/lsm303agr/lsm303agr.hpp      |  367 ----------
 src/lsm303agr/lsm303agr.i        |   53 --
 src/lsm303agr/lsm303agr.json     |   37 -
 src/lsm303agr/lsm303agr_defs.h   |  675 -----------------
 src/lsm303agr/lsm303agr_fti.c    |  137 ----
 src/lsm303d/CMakeLists.txt       |    8 -
 src/lsm303d/lsm303d.c            |  417 -----------
 src/lsm303d/lsm303d.cxx          |  142 ----
 src/lsm303d/lsm303d.h            |  238 ------
 src/lsm303d/lsm303d.hpp          |  244 -------
 src/lsm303d/lsm303d.i            |   48 --
 src/lsm303d/lsm303d.json         |   39 -
 src/lsm303d/lsm303d_defs.h       |  301 --------
 src/lsm303dlh/CMakeLists.txt     |    5 -
 src/lsm303dlh/lsm303dlh.cxx      |  229 ------
 src/lsm303dlh/lsm303dlh.hpp      |  185 -----
 src/lsm303dlh/lsm303dlh.i        |   51 --
 src/lsm303dlh/lsm303dlh.json     |   36 -
 src/lsm6ds3h/CMakeLists.txt      |    9 -
 src/lsm6ds3h/lsm6ds3h.c          |  640 ----------------
 src/lsm6ds3h/lsm6ds3h.cxx        |  208 ------
 src/lsm6ds3h/lsm6ds3h.h          |  340 ---------
 src/lsm6ds3h/lsm6ds3h.hpp        |  325 ---------
 src/lsm6ds3h/lsm6ds3h.i          |   28 -
 src/lsm6ds3h/lsm6ds3h.json       |   39 -
 src/lsm6ds3h/lsm6ds3h_defs.h     |  644 -----------------
 src/lsm6ds3h/lsm6ds3h_fti.c      |  127 ----
 src/lsm9ds0/CMakeLists.txt       |    5 -
 src/lsm9ds0/lsm9ds0.cxx          |  789 --------------------
 src/lsm9ds0/lsm9ds0.hpp          | 1484 --------------------------------------
 src/lsm9ds0/lsm9ds0.i            |   69 --
 src/lsm9ds0/lsm9ds0.json         |   39 -
 src/m24lr64e/CMakeLists.txt      |    9 -
 src/m24lr64e/m24lr64e.c          |  344 ---------
 src/m24lr64e/m24lr64e.cxx        |  306 --------
 src/m24lr64e/m24lr64e.h          |  272 -------
 src/m24lr64e/m24lr64e.hpp        |  287 --------
 src/m24lr64e/m24lr64e.i          |   32 -
 src/m24lr64e/m24lr64e.json       |   38 -
 src/m24lr64e/m24lr64e_fti.c      |   49 --
 src/mag3110/CMakeLists.txt       |    5 -
 src/mag3110/mag3110.cpp          |  269 -------
 src/mag3110/mag3110.hpp          |  296 --------
 src/mag3110/mag3110.json         |   38 -
 src/max30100/CMakeLists.txt      |    9 -
 src/max30100/max30100.c          |  536 --------------
 src/max30100/max30100.cxx        |  213 ------
 src/max30100/max30100.h          |  318 --------
 src/max30100/max30100.hpp        |  295 --------
 src/max30100/max30100.i          |   28 -
 src/max30100/max30100.json       |   37 -
 src/max30100/max30100_fti.c      |  109 ---
 src/max30100/max30100_regs.h     |  170 -----
 src/max31723/CMakeLists.txt      |    5 -
 src/max31723/max31723.cxx        |  109 ---
 src/max31723/max31723.hpp        |  118 ---
 src/max31723/max31723.json       |   39 -
 src/max31855/CMakeLists.txt      |    5 -
 src/max31855/max31855.cxx        |  110 ---
 src/max31855/max31855.hpp        |   88 ---
 src/max31855/max31855.i          |   17 -
 src/max31855/max31855.json       |   38 -
 src/max44000/CMakeLists.txt      |    5 -
 src/max44000/max44000.cxx        |  106 ---
 src/max44000/max44000.hpp        |  145 ----
 src/max44000/max44000.i          |   14 -
 src/max44000/max44000.json       |   39 -
 src/max44009/CMakeLists.txt      |    5 -
 src/max44009/max44009.cxx        |   93 ---
 src/max44009/max44009.hpp        |  148 ----
 src/max44009/max44009.i          |   19 -
 src/max44009/max44009.json       |   40 -
 src/max5487/CMakeLists.txt       |    5 -
 src/max5487/max5487.cxx          |   93 ---
 src/max5487/max5487.hpp          |  114 ---
 src/max5487/max5487.json         |   51 --
 src/maxds3231m/CMakeLists.txt    |    5 -
 src/maxds3231m/maxds3231m.cxx    |  124 ----
 src/maxds3231m/maxds3231m.hpp    |  134 ----
 src/maxds3231m/maxds3231m.json   |   56 --
 src/maxsonarez/CMakeLists.txt    |    5 -
 src/maxsonarez/maxsonarez.cxx    |   64 --
 src/maxsonarez/maxsonarez.hpp    |  103 ---
 src/maxsonarez/maxsonarez.json   |   57 --
 src/mb704x/CMakeLists.txt        |    9 -
 src/mb704x/mb704x.c              |  115 ---
 src/mb704x/mb704x.cxx            |   49 --
 src/mb704x/mb704x.h              |   78 --
 src/mb704x/mb704x.hpp            |   97 ---
 src/mb704x/mb704x.i              |   14 -
 src/mb704x/mb704x.json           |   58 --
 src/mb704x/mb704x_fti.c          |  113 ---
 src/mcp2515/CMakeLists.txt       |    8 -
 src/mcp2515/license.txt          |   51 --
 src/mcp2515/mcp2515.c            | 1107 ----------------------------
 src/mcp2515/mcp2515.cxx          |  253 -------
 src/mcp2515/mcp2515.h            |  525 --------------
 src/mcp2515/mcp2515.hpp          |  517 -------------
 src/mcp2515/mcp2515.i            |   25 -
 src/mcp2515/mcp2515.json         |   60 --
 src/mcp2515/mcp2515_regs.h       |  641 ----------------
 src/md/CMakeLists.txt            |    8 -
 src/md/md.c                      |  265 -------
 src/md/md.cxx                    |  104 ---
 src/md/md.h                      |  186 -----
 src/md/md.hpp                    |  193 -----
 src/md/md.i                      |   16 -
 src/md/md.json                   |   53 --
 src/md/md_defs.h                 |   69 --
 src/mg811/CMakeLists.txt         |    5 -
 src/mg811/mg811.cxx              |   94 ---
 src/mg811/mg811.hpp              |  147 ----
 src/mg811/mg811.json             |   54 --
 src/mhz16/CMakeLists.txt         |    5 -
 src/mhz16/mhz16.cxx              |  262 -------
 src/mhz16/mhz16.hpp              |  179 -----
 src/mhz16/mhz16.i                |   23 -
 src/mhz16/mhz16.json             |   73 --
 src/mic/CMakeLists.txt           |    8 -
 src/mic/mic.c                    |   58 --
 src/mic/mic.cxx                  |  106 ---
 src/mic/mic.h                    |   77 --
 src/mic/mic.hpp                  |  108 ---
 src/mic/mic.i                    |   58 --
 src/mic/mic.json                 |   31 -
 src/mic/mic_fti.c                |   91 ---
 src/micsv89/CMakeLists.txt       |    5 -
 src/micsv89/micsv89.cxx          |   83 ---
 src/micsv89/micsv89.hpp          |  131 ----
 src/micsv89/micsv89.json         |   40 -
 src/mlx90614/CMakeLists.txt      |    5 -
 src/mlx90614/mlx90614.cxx        |   81 ---
 src/mlx90614/mlx90614.hpp        |  131 ----
 src/mlx90614/mlx90614.json       |   66 --
 src/mma7361/CMakeLists.txt       |    9 -
 src/mma7361/mma7361.c            |  402 -----------
 src/mma7361/mma7361.cxx          |  150 ----
 src/mma7361/mma7361.h            |  248 -------
 src/mma7361/mma7361.hpp          |  211 ------
 src/mma7361/mma7361.i            |   61 --
 src/mma7361/mma7361.json         |   65 --
 src/mma7361/mma7361_fti.c        |  122 ----
 src/mma7455/CMakeLists.txt       |    5 -
 src/mma7455/mma7455.cxx          |  170 -----
 src/mma7455/mma7455.hpp          |  244 -------
 src/mma7455/mma7455.i            |   20 -
 src/mma7455/mma7455.json         |   63 --
 src/mma7660/CMakeLists.txt       |    9 -
 src/mma7660/mma7660.c            |  368 ----------
 src/mma7660/mma7660.cxx          |  192 -----
 src/mma7660/mma7660.h            |  251 -------
 src/mma7660/mma7660.hpp          |  250 -------
 src/mma7660/mma7660.i            |   31 -
 src/mma7660/mma7660.json         |   56 --
 src/mma7660/mma7660_fti.c        |   98 ---
 src/mma7660/mma7660_regs.h       |  104 ---
 src/mma8x5x/CMakeLists.txt       |    5 -
 src/mma8x5x/mma8x5x.cpp          |  346 ---------
 src/mma8x5x/mma8x5x.hpp          |  473 ------------
 src/mma8x5x/mma8x5x.json         |  281 --------
 src/mmc35240/CMakeLists.txt      |    7 -
 src/mmc35240/mat.h               |  406 -----------
 src/mmc35240/mmc35240.cxx        |  811 ---------------------
 src/mmc35240/mmc35240.hpp        |  212 ------
 src/mmc35240/mmc35240.json       |   54 --
 src/mmc35240/traits.h            |  118 ---
 src/mmc35240/vec.h               |  438 -----------
 src/moisture/CMakeLists.txt      |    9 -
 src/moisture/moisture.c          |   69 --
 src/moisture/moisture.cxx        |   48 --
 src/moisture/moisture.h          |   82 ---
 src/moisture/moisture.hpp        |   82 ---
 src/moisture/moisture.json       |   54 --
 src/moisture/moisture_fti.c      |   88 ---
 src/mpl3115a2/CMakeLists.txt     |    5 -
 src/mpl3115a2/mpl3115a2.cpp      |  323 ---------
 src/mpl3115a2/mpl3115a2.hpp      |  256 -------
 src/mpl3115a2/mpl3115a2.json     |   69 --
 src/mpr121/CMakeLists.txt        |    9 -
 src/mpr121/mpr121.c              |  208 ------
 src/mpr121/mpr121.cxx            |  205 ------
 src/mpr121/mpr121.h              |  119 ---
 src/mpr121/mpr121.hpp            |  123 ----
 src/mpr121/mpr121.i              |   17 -
 src/mpr121/mpr121.json           |   53 --
 src/mpr121/mpr121_fti.c          |   75 --
 src/mpu9150/CMakeLists.txt       |    5 -
 src/mpu9150/ak8975.cxx           |  239 ------
 src/mpu9150/ak8975.hpp           |  235 ------
 src/mpu9150/mpu60x0.cxx          |  416 -----------
 src/mpu9150/mpu60x0.hpp          |  943 ------------------------
 src/mpu9150/mpu9150.cxx          |  117 ---
 src/mpu9150/mpu9150.hpp          |  135 ----
 src/mpu9150/mpu9150.i            |   47 --
 src/mpu9150/mpu9150.json         |   59 --
 src/mpu9150/mpu9250.cxx          |   50 --
 src/mpu9150/mpu9250.hpp          |   85 ---
 src/mq303a/CMakeLists.txt        |    9 -
 src/mq303a/mq303a.c              |   76 --
 src/mq303a/mq303a.cxx            |   69 --
 src/mq303a/mq303a.h              |   83 ---
 src/mq303a/mq303a.hpp            |   94 ---
 src/mq303a/mq303a.json           |   67 --
 src/mq303a/mq303a_fti.c          |   79 --
 src/ms5611/CMakeLists.txt        |    5 -
 src/ms5611/ms5611.cxx            |  210 ------
 src/ms5611/ms5611.hpp            |   96 ---
 src/ms5611/ms5611.i              |   18 -
 src/ms5611/ms5611.json           |   89 ---
 src/ms5803/CMakeLists.txt        |    9 -
 src/ms5803/ms5803.c              |  504 -------------
 src/ms5803/ms5803.cxx            |  118 ---
 src/ms5803/ms5803.h              |  205 ------
 src/ms5803/ms5803.hpp            |  186 -----
 src/ms5803/ms5803.i              |   21 -
 src/ms5803/ms5803.json           |   92 ---
 src/ms5803/ms5803_defs.h         |   77 --
 src/ms5803/ms5803_fti.c          |  125 ----
 src/my9221/CMakeLists.txt        |    8 -
 src/my9221/grovecircularled.cxx  |  101 ---
 src/my9221/grovecircularled.hpp  |   96 ---
 src/my9221/groveledbar.cxx       |   91 ---
 src/my9221/groveledbar.hpp       |  100 ---
 src/my9221/my9221.c              |  274 -------
 src/my9221/my9221.cxx            |   90 ---
 src/my9221/my9221.h              |  183 -----
 src/my9221/my9221.hpp            |  133 ----
 src/my9221/my9221.i              |   18 -
 src/my9221/my9221.json           |  148 ----
 389 files changed, 60765 deletions(-)
 delete mode 100644 src/jhd1313m1/CMakeLists.txt
 delete mode 100644 src/jhd1313m1/jhd1313m1.c
 delete mode 100644 src/jhd1313m1/jhd1313m1.cxx
 delete mode 100644 src/jhd1313m1/jhd1313m1.h
 delete mode 100644 src/jhd1313m1/jhd1313m1.hpp
 delete mode 100644 src/jhd1313m1/jhd1313m1.i
 delete mode 100644 src/jhd1313m1/jhd1313m1.json
 delete mode 100644 src/joystick12/CMakeLists.txt
 delete mode 100644 src/joystick12/joystick12.c
 delete mode 100644 src/joystick12/joystick12.cxx
 delete mode 100644 src/joystick12/joystick12.h
 delete mode 100644 src/joystick12/joystick12.hpp
 delete mode 100644 src/joystick12/joystick12.i
 delete mode 100644 src/joystick12/joystick12.json
 delete mode 100644 src/joystick12/joystick12_fti.c
 delete mode 100644 src/kx122/CMakeLists.txt
 delete mode 100644 src/kx122/kx122.c
 delete mode 100644 src/kx122/kx122.cxx
 delete mode 100644 src/kx122/kx122.h
 delete mode 100644 src/kx122/kx122.hpp
 delete mode 100644 src/kx122/kx122.i
 delete mode 100644 src/kx122/kx122.json
 delete mode 100644 src/kx122/kx122_registers.h
 delete mode 100644 src/kxcjk1013/CMakeLists.txt
 delete mode 100644 src/kxcjk1013/kxcjk1013.cxx
 delete mode 100644 src/kxcjk1013/kxcjk1013.hpp
 delete mode 100644 src/kxcjk1013/kxcjk1013.json
 delete mode 100755 src/kxtj3/CMakeLists.txt
 delete mode 100755 src/kxtj3/kxtj3.c
 delete mode 100755 src/kxtj3/kxtj3.cxx
 delete mode 100755 src/kxtj3/kxtj3.h
 delete mode 100755 src/kxtj3/kxtj3.hpp
 delete mode 100644 src/kxtj3/kxtj3.i
 delete mode 100755 src/kxtj3/kxtj3.json
 delete mode 100755 src/kxtj3/kxtj3_registers.h
 delete mode 100644 src/l298/CMakeLists.txt
 delete mode 100644 src/l298/l298.cxx
 delete mode 100644 src/l298/l298.hpp
 delete mode 100644 src/l298/l298.json
 delete mode 100644 src/l3gd20/CMakeLists.txt
 delete mode 100644 src/l3gd20/l3gd20.cxx
 delete mode 100644 src/l3gd20/l3gd20.hpp
 delete mode 100644 src/l3gd20/l3gd20.json
 delete mode 100644 src/lcd/CMakeLists.txt
 delete mode 100644 src/lcd/eboled.cxx
 delete mode 100644 src/lcd/eboled.hpp
 delete mode 100644 src/lcd/hd44780_bits.hpp
 delete mode 100644 src/lcd/lcd.cxx
 delete mode 100644 src/lcd/lcd.hpp
 delete mode 100644 src/lcd/lcd.i
 delete mode 100644 src/lcd/lcd_private.hpp
 delete mode 100644 src/lcd/license.txt
 delete mode 100644 src/lcd/ssd.hpp
 delete mode 100644 src/lcd/ssd1306.cxx
 delete mode 100644 src/lcd/ssd1306.hpp
 delete mode 100644 src/lcd/ssd1308.cxx
 delete mode 100644 src/lcd/ssd1308.hpp
 delete mode 100644 src/lcd/ssd1327.cxx
 delete mode 100644 src/lcd/ssd1327.hpp
 delete mode 100644 src/lcdks/CMakeLists.txt
 delete mode 100644 src/lcdks/lcdks.c
 delete mode 100644 src/lcdks/lcdks.cxx
 delete mode 100644 src/lcdks/lcdks.h
 delete mode 100644 src/lcdks/lcdks.hpp
 delete mode 100644 src/lcdks/lcdks.i
 delete mode 100644 src/lcdks/lcdks.json
 delete mode 100644 src/lcm1602/CMakeLists.txt
 delete mode 100644 src/lcm1602/hd44780_bits.h
 delete mode 100644 src/lcm1602/lcm1602.c
 delete mode 100644 src/lcm1602/lcm1602.cxx
 delete mode 100644 src/lcm1602/lcm1602.h
 delete mode 100644 src/lcm1602/lcm1602.hpp
 delete mode 100644 src/lcm1602/lcm1602.i
 delete mode 100644 src/lcm1602/lcm1602.json
 delete mode 100644 src/ldt0028/CMakeLists.txt
 delete mode 100644 src/ldt0028/ldt0028.c
 delete mode 100644 src/ldt0028/ldt0028.cxx
 delete mode 100644 src/ldt0028/ldt0028.h
 delete mode 100644 src/ldt0028/ldt0028.hpp
 delete mode 100644 src/ldt0028/ldt0028.json
 delete mode 100644 src/ldt0028/ldt0028_fti.c
 delete mode 100644 src/led/CMakeLists.txt
 delete mode 100644 src/led/led.c
 delete mode 100644 src/led/led.cxx
 delete mode 100644 src/led/led.h
 delete mode 100644 src/led/led.hpp
 delete mode 100644 src/led/led.i
 delete mode 100644 src/led/led.json
 delete mode 100644 src/led/led_fti.c
 delete mode 100644 src/lidarlitev3/CMakeLists.txt
 delete mode 100644 src/lidarlitev3/lidarlitev3.cxx
 delete mode 100644 src/lidarlitev3/lidarlitev3.hpp
 delete mode 100644 src/lidarlitev3/lidarlitev3.i
 delete mode 100644 src/lidarlitev3/lidarlitev3.json
 delete mode 100644 src/light/CMakeLists.txt
 delete mode 100644 src/light/light.c
 delete mode 100644 src/light/light.cxx
 delete mode 100644 src/light/light.h
 delete mode 100644 src/light/light.hpp
 delete mode 100644 src/light/light.json
 delete mode 100644 src/light/light_fti.c
 delete mode 100644 src/linefinder/CMakeLists.txt
 delete mode 100644 src/linefinder/linefinder.c
 delete mode 100644 src/linefinder/linefinder.cxx
 delete mode 100644 src/linefinder/linefinder.h
 delete mode 100644 src/linefinder/linefinder.hpp
 delete mode 100644 src/linefinder/linefinder.json
 delete mode 100644 src/linefinder/linefinder_fti.c
 delete mode 100644 src/lis2ds12/CMakeLists.txt
 delete mode 100644 src/lis2ds12/lis2ds12.c
 delete mode 100644 src/lis2ds12/lis2ds12.cxx
 delete mode 100644 src/lis2ds12/lis2ds12.h
 delete mode 100644 src/lis2ds12/lis2ds12.hpp
 delete mode 100644 src/lis2ds12/lis2ds12.i
 delete mode 100644 src/lis2ds12/lis2ds12.json
 delete mode 100644 src/lis2ds12/lis2ds12_defs.h
 delete mode 100644 src/lis2ds12/lis2ds12_fti.c
 delete mode 100644 src/lis3dh/CMakeLists.txt
 delete mode 100644 src/lis3dh/lis3dh.c
 delete mode 100644 src/lis3dh/lis3dh.cxx
 delete mode 100644 src/lis3dh/lis3dh.h
 delete mode 100644 src/lis3dh/lis3dh.hpp
 delete mode 100644 src/lis3dh/lis3dh.i
 delete mode 100644 src/lis3dh/lis3dh.json
 delete mode 100644 src/lis3dh/lis3dh_defs.h
 delete mode 100644 src/lis3dh/lis3dh_fti.c
 delete mode 100644 src/lm35/CMakeLists.txt
 delete mode 100644 src/lm35/lm35.c
 delete mode 100644 src/lm35/lm35.cxx
 delete mode 100644 src/lm35/lm35.h
 delete mode 100644 src/lm35/lm35.hpp
 delete mode 100644 src/lm35/lm35.json
 delete mode 100644 src/lm35/lm35_fti.c
 delete mode 100644 src/lol/CMakeLists.txt
 delete mode 100644 src/lol/lol.cxx
 delete mode 100644 src/lol/lol.hpp
 delete mode 100644 src/lol/lol.i
 delete mode 100644 src/lol/lol.json
 delete mode 100644 src/loudness/CMakeLists.txt
 delete mode 100644 src/loudness/loudness.c
 delete mode 100644 src/loudness/loudness.cxx
 delete mode 100644 src/loudness/loudness.h
 delete mode 100644 src/loudness/loudness.hpp
 delete mode 100644 src/loudness/loudness.json
 delete mode 100644 src/loudness/loudness_fti.c
 delete mode 100644 src/lp8860/CMakeLists.txt
 delete mode 100644 src/lp8860/lp8860.cxx
 delete mode 100644 src/lp8860/lp8860.hpp
 delete mode 100644 src/lp8860/lp8860.i
 delete mode 100644 src/lp8860/lp8860.json
 delete mode 100644 src/lp8860/mraa-utils.cxx
 delete mode 100644 src/lp8860/mraa-utils.hpp
 delete mode 100644 src/lpd8806/CMakeLists.txt
 delete mode 100644 src/lpd8806/lpd8806.cxx
 delete mode 100644 src/lpd8806/lpd8806.hpp
 delete mode 100644 src/lpd8806/lpd8806.json
 delete mode 100644 src/lsm303agr/CMakeLists.txt
 delete mode 100644 src/lsm303agr/lsm303agr.c
 delete mode 100644 src/lsm303agr/lsm303agr.cxx
 delete mode 100644 src/lsm303agr/lsm303agr.h
 delete mode 100644 src/lsm303agr/lsm303agr.hpp
 delete mode 100644 src/lsm303agr/lsm303agr.i
 delete mode 100644 src/lsm303agr/lsm303agr.json
 delete mode 100644 src/lsm303agr/lsm303agr_defs.h
 delete mode 100644 src/lsm303agr/lsm303agr_fti.c
 delete mode 100644 src/lsm303d/CMakeLists.txt
 delete mode 100644 src/lsm303d/lsm303d.c
 delete mode 100644 src/lsm303d/lsm303d.cxx
 delete mode 100644 src/lsm303d/lsm303d.h
 delete mode 100644 src/lsm303d/lsm303d.hpp
 delete mode 100644 src/lsm303d/lsm303d.i
 delete mode 100644 src/lsm303d/lsm303d.json
 delete mode 100644 src/lsm303d/lsm303d_defs.h
 delete mode 100644 src/lsm303dlh/CMakeLists.txt
 delete mode 100644 src/lsm303dlh/lsm303dlh.cxx
 delete mode 100644 src/lsm303dlh/lsm303dlh.hpp
 delete mode 100644 src/lsm303dlh/lsm303dlh.i
 delete mode 100644 src/lsm303dlh/lsm303dlh.json
 delete mode 100644 src/lsm6ds3h/CMakeLists.txt
 delete mode 100644 src/lsm6ds3h/lsm6ds3h.c
 delete mode 100644 src/lsm6ds3h/lsm6ds3h.cxx
 delete mode 100644 src/lsm6ds3h/lsm6ds3h.h
 delete mode 100644 src/lsm6ds3h/lsm6ds3h.hpp
 delete mode 100644 src/lsm6ds3h/lsm6ds3h.i
 delete mode 100644 src/lsm6ds3h/lsm6ds3h.json
 delete mode 100644 src/lsm6ds3h/lsm6ds3h_defs.h
 delete mode 100644 src/lsm6ds3h/lsm6ds3h_fti.c
 delete mode 100644 src/lsm9ds0/CMakeLists.txt
 delete mode 100644 src/lsm9ds0/lsm9ds0.cxx
 delete mode 100644 src/lsm9ds0/lsm9ds0.hpp
 delete mode 100644 src/lsm9ds0/lsm9ds0.i
 delete mode 100644 src/lsm9ds0/lsm9ds0.json
 delete mode 100644 src/m24lr64e/CMakeLists.txt
 delete mode 100644 src/m24lr64e/m24lr64e.c
 delete mode 100644 src/m24lr64e/m24lr64e.cxx
 delete mode 100644 src/m24lr64e/m24lr64e.h
 delete mode 100644 src/m24lr64e/m24lr64e.hpp
 delete mode 100644 src/m24lr64e/m24lr64e.i
 delete mode 100644 src/m24lr64e/m24lr64e.json
 delete mode 100644 src/m24lr64e/m24lr64e_fti.c
 delete mode 100644 src/mag3110/CMakeLists.txt
 delete mode 100644 src/mag3110/mag3110.cpp
 delete mode 100644 src/mag3110/mag3110.hpp
 delete mode 100644 src/mag3110/mag3110.json
 delete mode 100644 src/max30100/CMakeLists.txt
 delete mode 100644 src/max30100/max30100.c
 delete mode 100644 src/max30100/max30100.cxx
 delete mode 100644 src/max30100/max30100.h
 delete mode 100644 src/max30100/max30100.hpp
 delete mode 100644 src/max30100/max30100.i
 delete mode 100644 src/max30100/max30100.json
 delete mode 100644 src/max30100/max30100_fti.c
 delete mode 100644 src/max30100/max30100_regs.h
 delete mode 100644 src/max31723/CMakeLists.txt
 delete mode 100644 src/max31723/max31723.cxx
 delete mode 100644 src/max31723/max31723.hpp
 delete mode 100644 src/max31723/max31723.json
 delete mode 100644 src/max31855/CMakeLists.txt
 delete mode 100644 src/max31855/max31855.cxx
 delete mode 100644 src/max31855/max31855.hpp
 delete mode 100644 src/max31855/max31855.i
 delete mode 100644 src/max31855/max31855.json
 delete mode 100644 src/max44000/CMakeLists.txt
 delete mode 100644 src/max44000/max44000.cxx
 delete mode 100644 src/max44000/max44000.hpp
 delete mode 100644 src/max44000/max44000.i
 delete mode 100644 src/max44000/max44000.json
 delete mode 100644 src/max44009/CMakeLists.txt
 delete mode 100644 src/max44009/max44009.cxx
 delete mode 100644 src/max44009/max44009.hpp
 delete mode 100644 src/max44009/max44009.i
 delete mode 100644 src/max44009/max44009.json
 delete mode 100644 src/max5487/CMakeLists.txt
 delete mode 100644 src/max5487/max5487.cxx
 delete mode 100644 src/max5487/max5487.hpp
 delete mode 100644 src/max5487/max5487.json
 delete mode 100644 src/maxds3231m/CMakeLists.txt
 delete mode 100644 src/maxds3231m/maxds3231m.cxx
 delete mode 100644 src/maxds3231m/maxds3231m.hpp
 delete mode 100644 src/maxds3231m/maxds3231m.json
 delete mode 100644 src/maxsonarez/CMakeLists.txt
 delete mode 100644 src/maxsonarez/maxsonarez.cxx
 delete mode 100644 src/maxsonarez/maxsonarez.hpp
 delete mode 100644 src/maxsonarez/maxsonarez.json
 delete mode 100644 src/mb704x/CMakeLists.txt
 delete mode 100644 src/mb704x/mb704x.c
 delete mode 100644 src/mb704x/mb704x.cxx
 delete mode 100644 src/mb704x/mb704x.h
 delete mode 100644 src/mb704x/mb704x.hpp
 delete mode 100644 src/mb704x/mb704x.i
 delete mode 100644 src/mb704x/mb704x.json
 delete mode 100644 src/mb704x/mb704x_fti.c
 delete mode 100644 src/mcp2515/CMakeLists.txt
 delete mode 100644 src/mcp2515/license.txt
 delete mode 100644 src/mcp2515/mcp2515.c
 delete mode 100644 src/mcp2515/mcp2515.cxx
 delete mode 100644 src/mcp2515/mcp2515.h
 delete mode 100644 src/mcp2515/mcp2515.hpp
 delete mode 100644 src/mcp2515/mcp2515.i
 delete mode 100644 src/mcp2515/mcp2515.json
 delete mode 100644 src/mcp2515/mcp2515_regs.h
 delete mode 100644 src/md/CMakeLists.txt
 delete mode 100644 src/md/md.c
 delete mode 100644 src/md/md.cxx
 delete mode 100644 src/md/md.h
 delete mode 100644 src/md/md.hpp
 delete mode 100644 src/md/md.i
 delete mode 100644 src/md/md.json
 delete mode 100644 src/md/md_defs.h
 delete mode 100644 src/mg811/CMakeLists.txt
 delete mode 100644 src/mg811/mg811.cxx
 delete mode 100644 src/mg811/mg811.hpp
 delete mode 100644 src/mg811/mg811.json
 delete mode 100644 src/mhz16/CMakeLists.txt
 delete mode 100644 src/mhz16/mhz16.cxx
 delete mode 100644 src/mhz16/mhz16.hpp
 delete mode 100644 src/mhz16/mhz16.i
 delete mode 100644 src/mhz16/mhz16.json
 delete mode 100644 src/mic/CMakeLists.txt
 delete mode 100644 src/mic/mic.c
 delete mode 100644 src/mic/mic.cxx
 delete mode 100644 src/mic/mic.h
 delete mode 100644 src/mic/mic.hpp
 delete mode 100644 src/mic/mic.i
 delete mode 100644 src/mic/mic.json
 delete mode 100644 src/mic/mic_fti.c
 delete mode 100644 src/micsv89/CMakeLists.txt
 delete mode 100644 src/micsv89/micsv89.cxx
 delete mode 100644 src/micsv89/micsv89.hpp
 delete mode 100644 src/micsv89/micsv89.json
 delete mode 100644 src/mlx90614/CMakeLists.txt
 delete mode 100644 src/mlx90614/mlx90614.cxx
 delete mode 100644 src/mlx90614/mlx90614.hpp
 delete mode 100644 src/mlx90614/mlx90614.json
 delete mode 100644 src/mma7361/CMakeLists.txt
 delete mode 100644 src/mma7361/mma7361.c
 delete mode 100644 src/mma7361/mma7361.cxx
 delete mode 100644 src/mma7361/mma7361.h
 delete mode 100644 src/mma7361/mma7361.hpp
 delete mode 100644 src/mma7361/mma7361.i
 delete mode 100644 src/mma7361/mma7361.json
 delete mode 100644 src/mma7361/mma7361_fti.c
 delete mode 100644 src/mma7455/CMakeLists.txt
 delete mode 100644 src/mma7455/mma7455.cxx
 delete mode 100644 src/mma7455/mma7455.hpp
 delete mode 100644 src/mma7455/mma7455.i
 delete mode 100644 src/mma7455/mma7455.json
 delete mode 100644 src/mma7660/CMakeLists.txt
 delete mode 100644 src/mma7660/mma7660.c
 delete mode 100644 src/mma7660/mma7660.cxx
 delete mode 100644 src/mma7660/mma7660.h
 delete mode 100644 src/mma7660/mma7660.hpp
 delete mode 100644 src/mma7660/mma7660.i
 delete mode 100644 src/mma7660/mma7660.json
 delete mode 100644 src/mma7660/mma7660_fti.c
 delete mode 100644 src/mma7660/mma7660_regs.h
 delete mode 100644 src/mma8x5x/CMakeLists.txt
 delete mode 100644 src/mma8x5x/mma8x5x.cpp
 delete mode 100644 src/mma8x5x/mma8x5x.hpp
 delete mode 100644 src/mma8x5x/mma8x5x.json
 delete mode 100644 src/mmc35240/CMakeLists.txt
 delete mode 100644 src/mmc35240/mat.h
 delete mode 100644 src/mmc35240/mmc35240.cxx
 delete mode 100644 src/mmc35240/mmc35240.hpp
 delete mode 100644 src/mmc35240/mmc35240.json
 delete mode 100644 src/mmc35240/traits.h
 delete mode 100644 src/mmc35240/vec.h
 delete mode 100644 src/moisture/CMakeLists.txt
 delete mode 100644 src/moisture/moisture.c
 delete mode 100644 src/moisture/moisture.cxx
 delete mode 100644 src/moisture/moisture.h
 delete mode 100644 src/moisture/moisture.hpp
 delete mode 100644 src/moisture/moisture.json
 delete mode 100644 src/moisture/moisture_fti.c
 delete mode 100644 src/mpl3115a2/CMakeLists.txt
 delete mode 100644 src/mpl3115a2/mpl3115a2.cpp
 delete mode 100644 src/mpl3115a2/mpl3115a2.hpp
 delete mode 100644 src/mpl3115a2/mpl3115a2.json
 delete mode 100644 src/mpr121/CMakeLists.txt
 delete mode 100644 src/mpr121/mpr121.c
 delete mode 100644 src/mpr121/mpr121.cxx
 delete mode 100644 src/mpr121/mpr121.h
 delete mode 100644 src/mpr121/mpr121.hpp
 delete mode 100644 src/mpr121/mpr121.i
 delete mode 100644 src/mpr121/mpr121.json
 delete mode 100644 src/mpr121/mpr121_fti.c
 delete mode 100644 src/mpu9150/CMakeLists.txt
 delete mode 100644 src/mpu9150/ak8975.cxx
 delete mode 100644 src/mpu9150/ak8975.hpp
 delete mode 100644 src/mpu9150/mpu60x0.cxx
 delete mode 100644 src/mpu9150/mpu60x0.hpp
 delete mode 100644 src/mpu9150/mpu9150.cxx
 delete mode 100644 src/mpu9150/mpu9150.hpp
 delete mode 100644 src/mpu9150/mpu9150.i
 delete mode 100644 src/mpu9150/mpu9150.json
 delete mode 100644 src/mpu9150/mpu9250.cxx
 delete mode 100644 src/mpu9150/mpu9250.hpp
 delete mode 100644 src/mq303a/CMakeLists.txt
 delete mode 100644 src/mq303a/mq303a.c
 delete mode 100644 src/mq303a/mq303a.cxx
 delete mode 100644 src/mq303a/mq303a.h
 delete mode 100644 src/mq303a/mq303a.hpp
 delete mode 100644 src/mq303a/mq303a.json
 delete mode 100644 src/mq303a/mq303a_fti.c
 delete mode 100644 src/ms5611/CMakeLists.txt
 delete mode 100644 src/ms5611/ms5611.cxx
 delete mode 100644 src/ms5611/ms5611.hpp
 delete mode 100644 src/ms5611/ms5611.i
 delete mode 100644 src/ms5611/ms5611.json
 delete mode 100644 src/ms5803/CMakeLists.txt
 delete mode 100644 src/ms5803/ms5803.c
 delete mode 100644 src/ms5803/ms5803.cxx
 delete mode 100644 src/ms5803/ms5803.h
 delete mode 100644 src/ms5803/ms5803.hpp
 delete mode 100644 src/ms5803/ms5803.i
 delete mode 100644 src/ms5803/ms5803.json
 delete mode 100644 src/ms5803/ms5803_defs.h
 delete mode 100644 src/ms5803/ms5803_fti.c
 delete mode 100644 src/my9221/CMakeLists.txt
 delete mode 100644 src/my9221/grovecircularled.cxx
 delete mode 100644 src/my9221/grovecircularled.hpp
 delete mode 100644 src/my9221/groveledbar.cxx
 delete mode 100644 src/my9221/groveledbar.hpp
 delete mode 100644 src/my9221/my9221.c
 delete mode 100644 src/my9221/my9221.cxx
 delete mode 100644 src/my9221/my9221.h
 delete mode 100644 src/my9221/my9221.hpp
 delete mode 100644 src/my9221/my9221.i
 delete mode 100644 src/my9221/my9221.json

diff --git a/src/jhd1313m1/CMakeLists.txt b/src/jhd1313m1/CMakeLists.txt
deleted file mode 100644
index 593c12f..0000000
--- a/src/jhd1313m1/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-upm_mixed_module_init (NAME jhd1313m1
-    DESCRIPTION "LCD Display Driver for the JHD1313M1 Controller for HD44780-based Displays"
-    C_HDR jhd1313m1.h
-    C_SRC jhd1313m1.c
-    CPP_HDR jhd1313m1.hpp
-    CPP_SRC jhd1313m1.cxx
-    CPP_WRAPS_C
-    REQUIRES mraa lcm1602 utilities-c)
diff --git a/src/jhd1313m1/jhd1313m1.c b/src/jhd1313m1/jhd1313m1.c
deleted file mode 100644
index 0faaa6d..0000000
--- a/src/jhd1313m1/jhd1313m1.c
+++ /dev/null
@@ -1,367 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Based on UPM C++ drivers originally developed by:
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <assert.h>
-#include <string.h>
-
-#include <upm_utilities.h>
-
-#include "jhd1313m1.h"
-#include "hd44780_bits.h"
-
-jhd1313m1_context jhd1313m1_init(int bus, int lcd_addr, int rgb_addr)
-{
-    jhd1313m1_context dev =
-        (jhd1313m1_context)malloc(sizeof(struct _jhd1313m1_context));
-
-    if (!dev)
-        return NULL;
-
-    memset((void *)dev, 0, sizeof(struct _jhd1313m1_context));
-
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        jhd1313m1_close(dev);
-        return NULL;
-    }
-
-    // initialize the MRAA contexts
-
-    if (!(dev->i2cLCD = mraa_i2c_init(bus)))
-    {
-        printf("%s: mraa_i2c_init(LCD) failed.\n", __FUNCTION__);
-        jhd1313m1_close(dev);
-
-        return NULL;
-    }
-
-    // now check the address...
-    if (mraa_i2c_address(dev->i2cLCD, lcd_addr) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_i2c_address(LCD) failed.\n", __FUNCTION__);
-
-        jhd1313m1_close(dev);
-
-        return NULL;
-    }
-
-    if (!(dev->i2cRGB = mraa_i2c_init(bus)))
-    {
-        printf("%s: mraa_i2c_init(RGB) failed.\n", __FUNCTION__);
-        jhd1313m1_close(dev);
-
-        return NULL;
-    }
-
-    // now check the address...
-    if (mraa_i2c_address(dev->i2cRGB, rgb_addr) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_i2c_address(RGB) failed.\n", __FUNCTION__);
-
-        jhd1313m1_close(dev);
-
-        return NULL;
-    }
-
-    /* HD44780 requires writing three times to initialize or reset
-       according to the hardware errata on page 45 figure 23 of
-       the Hitachi HD44780 datasheet */
-
-    /* First try */
-    upm_delay_us(50000);
-    jhd1313m1_command(dev, HD44780_FUNCTIONSET | HD44780_8BITMODE);
-
-    /* Second try */
-    upm_delay_us(4500);
-    jhd1313m1_command(dev, HD44780_FUNCTIONSET | HD44780_8BITMODE);
-
-    /* Third try */
-    upm_delay_us(150);
-    jhd1313m1_command(dev, HD44780_FUNCTIONSET | HD44780_8BITMODE);
-
-    /* Set 2 row mode and font size */
-    jhd1313m1_command(dev, HD44780_FUNCTIONSET | HD44780_8BITMODE
-                      | HD44780_2LINE | HD44780_5x10DOTS);
-    upm_delay_us(100);
-
-    jhd1313m1_display_on(dev, true);
-    upm_delay_us(100);
-
-    jhd1313m1_clear(dev);
-    upm_delay_us(2000);
-
-    jhd1313m1_command(dev, HD44780_ENTRYMODESET | HD44780_ENTRYLEFT
-                      | HD44780_ENTRYSHIFTDECREMENT);
-
-    jhd1313m1_backlight_on(dev, true);
-    // full white
-    jhd1313m1_set_color(dev, 0xff, 0xff, 0xff);
-
-    return dev;
-}
-
-void jhd1313m1_close(jhd1313m1_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->i2cLCD)
-        mraa_i2c_stop(dev->i2cLCD);
-    if (dev->i2cRGB)
-        mraa_i2c_stop(dev->i2cRGB);
-
-    free(dev);
-}
-
-upm_result_t jhd1313m1_set_color(jhd1313m1_context dev, uint8_t r, uint8_t g,
-                                 uint8_t b)
-{
-    assert(dev != NULL);
-
-    mraa_result_t rv = MRAA_SUCCESS;
-    rv = mraa_i2c_write_byte_data(dev->i2cRGB, 0, 0);
-    rv = mraa_i2c_write_byte_data(dev->i2cRGB, 0, 1);
-
-    rv = mraa_i2c_write_byte_data(dev->i2cRGB, r, 0x04);
-    rv = mraa_i2c_write_byte_data(dev->i2cRGB, g, 0x03);
-    rv = mraa_i2c_write_byte_data(dev->i2cRGB, b, 0x02);
-
-    if (rv)
-    {
-        printf("%s: mraa_i2c_write_byte_data() failed\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t jhd1313m1_write(const jhd1313m1_context dev, char *buffer,
-                             int len)
-{
-    assert(dev != NULL);
-
-    upm_result_t error = UPM_SUCCESS;
-
-    int i;
-    for (i=0; i<len; ++i)
-        error = jhd1313m1_data(dev, buffer[i]);
-
-    return error;
-}
-
-upm_result_t jhd1313m1_set_cursor(const jhd1313m1_context dev, unsigned int row,
-                                  unsigned int column)
-{
-    assert(dev != NULL);
-
-    column = column % 16;
-    uint8_t offset = column;
-
-    // this should work for any display with two rows
-    // DDRAM mapping:
-    // 00 .. 27
-    // 40 .. 67
-    offset += row * 0x40;
-
-    return jhd1313m1_command(dev, HD44780_CMD | offset);
-}
-
-upm_result_t jhd1313m1_clear(const jhd1313m1_context dev)
-{
-    assert(dev != NULL);
-
-    upm_result_t ret;
-    ret = jhd1313m1_command(dev, HD44780_CLEARDISPLAY);
-    upm_delay_us(2000); // this command takes awhile
-    return ret;
-}
-
-upm_result_t jhd1313m1_home(const jhd1313m1_context dev)
-{
-    assert(dev != NULL);
-
-    upm_result_t ret;
-    ret = jhd1313m1_command(dev, HD44780_RETURNHOME);
-    upm_delay_us(2000); // this command takes awhile
-    return ret;
-}
-
-upm_result_t jhd1313m1_create_char(const jhd1313m1_context dev,
-                                 unsigned int slot,
-                                 char *data)
-{
-    assert(dev != NULL);
-
-    upm_result_t error = UPM_SUCCESS;
-
-    slot &= 0x07; // only have 8 positions we can set
-
-    error = jhd1313m1_command(dev, HD44780_SETCGRAMADDR | (slot << 3));
-
-    if (error == UPM_SUCCESS)
-    {
-        int i;
-        for (i = 0; i < 8; i++) {
-            error = jhd1313m1_data(dev, data[i]);
-        }
-    }
-
-    return error;
-}
-
-upm_result_t jhd1313m1_display_on(const jhd1313m1_context dev, bool on)
-{
-    assert(dev != NULL);
-
-    if (on)
-        dev->displayControl |= HD44780_DISPLAYON;
-    else
-        dev->displayControl &= ~HD44780_DISPLAYON;
-
-    return jhd1313m1_command(dev, HD44780_DISPLAYCONTROL | dev->displayControl);
-}
-
-upm_result_t jhd1313m1_cursor_on(const jhd1313m1_context dev, bool on)
-{
-    assert(dev != NULL);
-
-    if (on)
-        dev->displayControl |= HD44780_CURSORON;
-    else
-        dev->displayControl &= ~HD44780_CURSORON;
-
-    return jhd1313m1_command(dev, HD44780_DISPLAYCONTROL | dev->displayControl);
-}
-
-upm_result_t jhd1313m1_cursor_blink_on(const jhd1313m1_context dev, bool on)
-{
-    assert(dev != NULL);
-
-    if (on)
-        dev->displayControl |= HD44780_BLINKON;
-    else
-        dev->displayControl &= ~HD44780_BLINKON;
-
-    return jhd1313m1_command(dev, HD44780_DISPLAYCONTROL | dev->displayControl);
-}
-
-upm_result_t jhd1313m1_backlight_on(const jhd1313m1_context dev, bool on)
-{
-    assert(dev != NULL);
-
-    mraa_result_t rv = MRAA_SUCCESS;
-    if (on)
-        rv = mraa_i2c_write_byte_data(dev->i2cRGB, 0xaa, 0x08);
-    else
-        rv = mraa_i2c_write_byte_data(dev->i2cRGB, 0x00, 0x08);
-
-    if (rv)
-    {
-        printf("%s: mraa_i2c_write_byte_data() failed\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t jhd1313m1_scroll(const jhd1313m1_context dev, bool direction)
-{
-    if (direction)
-        return jhd1313m1_scroll_display_left(dev);
-    else
-        return jhd1313m1_scroll_display_right(dev);
-}
-
-upm_result_t jhd1313m1_scroll_display_left(const jhd1313m1_context dev)
-{
-    assert(dev != NULL);
-
-    return jhd1313m1_command(dev, HD44780_CURSORSHIFT | HD44780_DISPLAYMOVE
-                             | HD44780_MOVELEFT);
-}
-
-upm_result_t jhd1313m1_scroll_display_right(const jhd1313m1_context dev)
-{
-    assert(dev != NULL);
-
-    return jhd1313m1_command(dev, HD44780_CURSORSHIFT | HD44780_DISPLAYMOVE
-                             | HD44780_MOVERIGHT);
-}
-
-upm_result_t jhd1313m1_entry_left_to_right(const jhd1313m1_context dev, bool on)
-{
-    assert(dev != NULL);
-
-    if (on)
-        dev->entryDisplayMode |= HD44780_ENTRYLEFT;
-    else
-        dev->entryDisplayMode &= ~HD44780_ENTRYLEFT;
-
-    return jhd1313m1_command(dev, HD44780_ENTRYMODESET | dev->entryDisplayMode);
-}
-
-upm_result_t jhd1313m1_autoscroll_on(const jhd1313m1_context dev, bool on)
-{
-    assert(dev != NULL);
-
-    if (on)
-        dev->entryDisplayMode |= HD44780_ENTRYSHIFTINCREMENT;
-    else
-        dev->entryDisplayMode &= ~HD44780_ENTRYSHIFTINCREMENT;
-
-    return jhd1313m1_command(dev, HD44780_ENTRYMODESET | dev->entryDisplayMode);
-}
-
-upm_result_t jhd1313m1_command(const jhd1313m1_context dev, uint8_t cmd)
-{
-    assert(dev != NULL);
-
-    if (mraa_i2c_write_byte_data(dev->i2cLCD, cmd, HD44780_CMD))
-    {
-        printf("%s: mraa_i2c_write_byte_data() failed\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t jhd1313m1_data(const jhd1313m1_context dev, uint8_t cmd)
-{
-    assert(dev != NULL);
-
-    if (mraa_i2c_write_byte_data(dev->i2cLCD, cmd, HD44780_DATA))
-    {
-        printf("%s: mraa_i2c_write_byte_data() failed\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
diff --git a/src/jhd1313m1/jhd1313m1.cxx b/src/jhd1313m1/jhd1313m1.cxx
deleted file mode 100644
index fb79ea9..0000000
--- a/src/jhd1313m1/jhd1313m1.cxx
+++ /dev/null
@@ -1,170 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Based on UPM C++ drivers originally developed by:
- * Author: Daniel Mosquera
- * Copyright (c) 2013 Daniel Mosquera
- *
- * Author: Thomas Ingleby <thomas.c.ingleby@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Contributions: Sergey Kiselev <sergey.kiselev@intel.com>
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string>
-#include <stdexcept>
-#include <unistd.h>
-
-#include "jhd1313m1.hpp"
-
-using namespace upm;
-
-Jhd1313m1::Jhd1313m1(int bus, int lcdAddress, int rgbAddress) :
-    m_jhd1313m1(jhd1313m1_init(bus, lcdAddress, rgbAddress))
-{
-    if (!m_jhd1313m1)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": jhd1313m1_init failed");
-}
-
-Jhd1313m1::~Jhd1313m1()
-{
-    jhd1313m1_close(m_jhd1313m1);
-}
-
-upm_result_t Jhd1313m1::write(std::string msg)
-{
-    return jhd1313m1_write(m_jhd1313m1, (char *)msg.data(), msg.size());
-}
-
-upm_result_t Jhd1313m1::setCursor(int row, int column)
-{
-    return jhd1313m1_set_cursor(m_jhd1313m1, row, column);
-}
-
-upm_result_t Jhd1313m1::scroll(bool direction)
-{
-    return jhd1313m1_scroll(m_jhd1313m1, direction);
-}
-
-upm_result_t Jhd1313m1::setColor(uint8_t r, uint8_t g, uint8_t b)
-{
-    return jhd1313m1_set_color(m_jhd1313m1, r, g, b);
-}
-
-upm_result_t Jhd1313m1::clear()
-{
-    return jhd1313m1_clear(m_jhd1313m1);
-}
-
-upm_result_t Jhd1313m1::home()
-{
-    return jhd1313m1_home(m_jhd1313m1);
-}
-
-upm_result_t Jhd1313m1::createChar(uint8_t charSlot,
-                                   std::vector<uint8_t> charData)
-{
-    return jhd1313m1_create_char(m_jhd1313m1, charSlot,
-                                 (char *)charData.data());
-}
-
-upm_result_t Jhd1313m1::displayOn()
-{
-    return jhd1313m1_display_on(m_jhd1313m1, true);
-}
-
-upm_result_t Jhd1313m1::displayOff()
-{
-    return jhd1313m1_display_on(m_jhd1313m1, false);
-}
-
-upm_result_t Jhd1313m1::cursorOn()
-{
-    return jhd1313m1_cursor_on(m_jhd1313m1, true);
-}
-
-upm_result_t Jhd1313m1::cursorOff()
-{
-    return jhd1313m1_cursor_on(m_jhd1313m1, false);
-}
-
-upm_result_t Jhd1313m1::cursorBlinkOn()
-{
-    return jhd1313m1_cursor_blink_on(m_jhd1313m1, true);
-}
-
-upm_result_t Jhd1313m1::cursorBlinkOff()
-{
-    return jhd1313m1_cursor_blink_on(m_jhd1313m1, false);
-}
-
-upm_result_t Jhd1313m1::backlightOn()
-{
-    return jhd1313m1_backlight_on(m_jhd1313m1, true);
-}
-
-upm_result_t Jhd1313m1::backlightOff()
-{
-    return jhd1313m1_backlight_on(m_jhd1313m1, false);
-}
-
-upm_result_t Jhd1313m1::scrollDisplayLeft()
-{
-    return jhd1313m1_scroll_display_left(m_jhd1313m1);
-}
-
-upm_result_t Jhd1313m1::scrollDisplayRight()
-{
-    return jhd1313m1_scroll_display_right(m_jhd1313m1);
-}
-
-upm_result_t Jhd1313m1::entryLeftToRight()
-{
-    return jhd1313m1_entry_left_to_right(m_jhd1313m1, true);
-}
-
-upm_result_t Jhd1313m1::entryRightToLeft()
-{
-    return jhd1313m1_entry_left_to_right(m_jhd1313m1, false);
-}
-
-upm_result_t Jhd1313m1::autoscrollOn()
-{
-    return jhd1313m1_autoscroll_on(m_jhd1313m1, true);
-}
-
-upm_result_t Jhd1313m1::autoscrollOff()
-{
-    return jhd1313m1_autoscroll_on(m_jhd1313m1, false);
-}
-
-upm_result_t Jhd1313m1::command(uint8_t cmd)
-{
-    return jhd1313m1_command(m_jhd1313m1, cmd);
-}
-
-upm_result_t Jhd1313m1::data(uint8_t data)
-{
-    return jhd1313m1_data(m_jhd1313m1, data);
-}
diff --git a/src/jhd1313m1/jhd1313m1.h b/src/jhd1313m1/jhd1313m1.h
deleted file mode 100644
index db1aa69..0000000
--- a/src/jhd1313m1/jhd1313m1.h
+++ /dev/null
@@ -1,253 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Based on UPM C++ drivers originally developed by:
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <upm.h>
-
-#include <mraa/i2c.h>
-#include <mraa/gpio.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-    /**
-     * @file jhd1313m1.h
-     * @library jhd1313m1
-     * @brief C API for the JHD1313M1 family of LCD displays, like the
-     * Grove RGB LCD
-     *
-     * @include jhd1313m1.c
-     */
-
-    /**
-     * Device context
-     */
-    typedef struct _jhd1313m1_context {
-        // I2C LCD command (lcm1602-like)
-        mraa_i2c_context         i2cLCD;
-        // I2C RGB backlight control
-        mraa_i2c_context         i2cRGB;
-
-        // display command
-        uint8_t                  displayControl;
-        uint8_t                  entryDisplayMode;
-    } *jhd1313m1_context;
-
-    /**
-     * JHD1313M1 I2C initialization.
-     *
-     * @param bus I2C bus to use.
-     * @param lcd_addr I2C address the LCD controller is on.
-     * @param rgb_addr I2C address the RGB backlight controller is on.
-     * @return Device Ccontext, or NULL on error.
-     */
-    jhd1313m1_context jhd1313m1_init(int bus, int lcd_addr, int rgb_addr);
-
-    /**
-     * JHD1313M1 close.
-     *
-     * @param dev The device context.
-     */
-    void jhd1313m1_close(jhd1313m1_context dev);
-
-    /**
-     * Writes a string to the LCD.
-     *
-     * @param dev The device context.
-     * @param buffer Character buffer containing characters to write to
-     * the display; note: only ASCII characters are supported
-     * @param len The number of characters to write.
-     * @return UPM result.
-     */
-    upm_result_t jhd1313m1_write(const jhd1313m1_context dev, char *buffer,
-                                 int len);
-
-    /**
-     * Sets the cursor to specified coordinates
-     *
-     * @param dev The device context.
-     * @param row Row to set the cursor to.
-     * @param column Column to set the cursor to.
-     * @return UPM result.
-     */
-    upm_result_t jhd1313m1_set_cursor(const jhd1313m1_context dev,
-                                      unsigned int row, unsigned int column);
-
-    /**
-     * Clears the display of all characters.
-     *
-     * @param dev The device context.
-     * @return UPM result.
-     */
-    upm_result_t jhd1313m1_clear(const jhd1313m1_context dev);
-
-    /**
-     * Returns to the home coordinates (0,0).
-     *
-     * @param dev The device context.
-     * @return UPM result.
-     */
-    upm_result_t jhd1313m1_home(const jhd1313m1_context dev);
-
-    /**
-     * Sets the color of the backlight
-     * Can be used to change the color even when the backlight is off
-     *
-     * @param dev The device context.
-     * @param r 0-255 value for red
-     * @param g 0-255 value for green
-     * @param b 0-255 value for blue
-     * @return UPM result.
-     */
-    upm_result_t jhd1313m1_set_color(const jhd1313m1_context dev,
-                                     uint8_t r, uint8_t g, uint8_t b);
-
-    /**
-     * Create a custom character.
-     *
-     * @param dev The device context.
-     * @param slot The character slot to write, only 8 are available.
-     * @param data The character data (8 bytes) making up the character.
-     * @return UPM result.
-     */
-    upm_result_t jhd1313m1_create_char(const jhd1313m1_context dev,
-                                       unsigned int slot,
-                                       char *data);
-
-    /**
-     * Turn the display on.
-     *
-     * @param dev The device context.
-     * @param on true to turn display on, false otherwise.
-     * @return UPM result.
-     */
-    upm_result_t jhd1313m1_display_on(const jhd1313m1_context dev, bool on);
-
-    /**
-     * Turn the cursor on.
-     *
-     * @param dev The device context.
-     * @param on true to turn cursor on, false otherwise.
-     * @return UPM result.
-     */
-    upm_result_t jhd1313m1_cursor_on(const jhd1313m1_context dev, bool on);
-
-    /**
-     * Turn cursor blink on.
-     *
-     * @param dev The device context.
-     * @param on true to turn cursor blink on, false otherwise.
-     * @return UPM result.
-     */
-    upm_result_t jhd1313m1_cursor_blink_on(const jhd1313m1_context dev,
-                                           bool on);
-
-    /**
-     * Turn backlight on.
-     *
-     * @param dev The device context.
-     * @param on true to turn backlight on, false otherwise.
-     * @return UPM result.
-     */
-    upm_result_t jhd1313m1_backlight_on(const jhd1313m1_context dev, bool on);
-
-    /**
-     * Makes the LCD scroll text
-     *
-     * @param direction True if scrolling to the right, false otherwise
-     * @return Result of the operation
-     */
-    upm_result_t jhd1313m1_scroll(const jhd1313m1_context dev, bool direction);
-
-    /**
-     * Scroll the display left, without changing the character RAM.
-     *
-     * @param dev The device context.
-     * @return UPM result.
-     */
-    upm_result_t jhd1313m1_scroll_display_left(const jhd1313m1_context dev);
-
-    /**
-     * Scroll the display right, without changing the character RAM.
-     *
-     * @param dev The device context.
-     * @return UPM result.
-     */
-    upm_result_t jhd1313m1_scroll_display_right(const jhd1313m1_context dev);
-
-    /**
-     * Set the entry mode so that characters are added left to right.
-     *
-     * @param dev The device context.
-     * @param on true to add characters left to right, false for right
-     * to left.
-     * @return UPM result.
-     */
-    upm_result_t jhd1313m1_entry_left_to_right(const jhd1313m1_context dev,
-                                               bool on);
-
-    /**
-     * Right justify text entered from the cursor.
-     *
-     * @param dev The device context.
-     * @param on true right justify text, false to left justify text.
-     * @return UPM result.
-     */
-    upm_result_t jhd1313m1_autoscroll_on(const jhd1313m1_context dev, bool on);
-
-    /**
-     * Send a command byte to the LCD controller.  This is a low level
-     * function that should not be used directly unless you know what
-     * you are doing.
-     *
-     * @param dev The device context.
-     * @param cmd The command byte to send.
-     * @return UPM result.
-     */
-    upm_result_t jhd1313m1_command(const jhd1313m1_context dev, uint8_t cmd);
-
-    /**
-     * Send a data byte the LCD controller.  This is a low level
-     * function that should not be used directly unless you know what
-     * you are doing.
-     *
-     * @param dev The device context.
-     * @param cmd The command byte to send.
-     * @return UPM result.
-     */
-    upm_result_t jhd1313m1_data(const jhd1313m1_context dev, uint8_t data);
-
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/jhd1313m1/jhd1313m1.hpp b/src/jhd1313m1/jhd1313m1.hpp
deleted file mode 100644
index 08f4355..0000000
--- a/src/jhd1313m1/jhd1313m1.hpp
+++ /dev/null
@@ -1,259 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Based on UPM C++ drivers originally developed by:
- * Author: Daniel Mosquera
- * Copyright (c) 2013 Daniel Mosquera
- *
- * Author: Thomas Ingleby <thomas.c.ingleby@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Contributions: Sergey Kiselev <sergey.kiselev@intel.com>
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <string>
-#include <vector>
-#include "jhd1313m1.h"
-
-namespace upm
-{
-/**
- * @brief JHD1313M1 Display Controller
- * @defgroup jhd1313m1 libupm-jhd1313m1
- * @ingroup seeed i2c display gsk
- */
-
-/**
- * @library jhd1313m1
- * @sensor jhd1313m1
- * @comname LCD Display Driver for the JHD1313M1 Controller for HD44780-based Displays
- * @altname Grove RGB LCD
- * @type display
- * @man seeed adafruit sparkfun
- * @web http://www.seeedstudio.com/depot/Grove-LCD-RGB-Backlight-p-1643.html?cPath=34_36
- * @con i2c
- * @kit gsk
- *
- * @brief API for the JHD1313M1 I2C controller for HD44780-based displays with
- * an RGB backlight, such as a Grove RGB I2C LCD display
- *
- * JHD1313M1 has two I2C addreses: one belongs to a controller, very
- * similar to the upm::Lcm1602 LCD driver, that controls the
- * HD44780-based display, and the other controls only the
- * backlight. This module was tested with the Seeed Grove LCD RGB
- * Backlight v2.0 display that requires 5V to operate.
- *
- * @image html grovergblcd.jpg
- * @snippet jhd1313m1-lcd.cxx Interesting
- */
-
-    class Jhd1313m1
-    {
-    public:
-        /**
-         * Jhd1313m1 constructor
-         *
-         * @param bus I2C bus to use
-         * @param lcdAddress Slave address the LCD is registered on
-         * @param rgbAddress Slave address the RGB backlight is registered on
-         */
-        Jhd1313m1(int bus, int lcdAddress = 0x3E, int rgbAddress = 0x62);
-
-        /**
-         * Jhd1313m1 destructor
-         */
-        ~Jhd1313m1();
-
-        /**
-         * Writes a string to the LCD
-         *
-         * @param msg std::string to write to the display; note: only ASCII
-         * characters are supported
-         * @return Result of the operation
-         */
-        upm_result_t write(std::string msg);
-
-        /**
-         * Makes the LCD scroll text
-         *
-         * @param direction True if scrolling to the right, false otherwise
-         * @return Result of the operation
-         */
-        upm_result_t scroll(bool direction);
-
-        /**
-         * Sets the color of the backlight
-         * Can be used to change the color even when the backlight is off
-         *
-         * @param r 0-255 value for red
-         * @param g 0-255 value for green
-         * @param b 0-255 value for blue
-         * @return Result of the operation
-         */
-        upm_result_t setColor(uint8_t r, uint8_t g, uint8_t b);
-
-        /**
-         * Sets the cursor to specified coordinates
-         *
-         * @param row Row to set the cursor to
-         * @param column Column to set the cursor to
-         * @return Result of the operation
-         */
-        upm_result_t setCursor(int row, int column);
-
-        /**
-         * Clears the display of all characters
-         *
-         * @return Result of the operation
-         */
-        upm_result_t clear();
-
-        /**
-         * Returns to the original coordinates (0,0)
-         *
-         * @return Result of the operation
-         */
-        upm_result_t home();
-
-        /**
-         * Create a custom character
-         *
-         * @param charSlot the character slot to write, only 8 are available
-         * @param charData A vector containing 8 bytes making up the character
-         * @return Result of operation
-         */
-        upm_result_t createChar(uint8_t charSlot,
-                                std::vector<uint8_t> charData);
-
-        /**
-         * Turn the display on
-         *
-         * @return Result of operation
-         */
-        upm_result_t displayOn();
-
-        /**
-         * Turn the display off
-         *
-         * @return Result of operation
-         */
-        upm_result_t displayOff();
-
-        /**
-         * Turn the cursor on
-         *
-         * @return Result of operation
-         */
-        upm_result_t cursorOn();
-
-        /**
-         * Turn the cursor off
-         *
-         * @return Result of operation
-         */
-        upm_result_t cursorOff();
-
-        /**
-         * Turn cursor blink on
-         *
-         * @return Result of operation
-         */
-        upm_result_t cursorBlinkOn();
-
-        /**
-         * Turn cursor blink off
-         *
-         * @return Result of operation
-         */
-        upm_result_t cursorBlinkOff();
-
-        /**
-        * Turn backlight on
-        *
-        * @return Result of operation
-        */
-        upm_result_t backlightOn();
-
-        /**
-         * Turn backlight off
-         *
-         * @return Result of operation
-         */
-        upm_result_t backlightOff();
-
-        /**
-         * Scroll the display left, without changing the character RAM
-         *
-         * @return Result of operation
-         */
-        upm_result_t scrollDisplayLeft();
-
-        /**
-         * Scroll the display right, without changing the character RAM
-         *
-         * @return Result of operation
-         */
-        upm_result_t scrollDisplayRight();
-
-        /**
-         * set the entry mode so that characters are added left to right
-         *
-         * @return Result of operation
-         */
-        upm_result_t entryLeftToRight();
-
-        /**
-         * set the entry mode so that characters are added right to left
-         *
-         * @return Result of operation
-         */
-        upm_result_t entryRightToLeft();
-
-        /**
-         * Right justify text entered from the cursor
-         *
-         * @return Result of operation
-         */
-        upm_result_t autoscrollOn();
-
-        /**
-         * Left justify text entered from the cursor
-         *
-         * @return Result of operation
-         */
-        upm_result_t autoscrollOff();
-
-
-    protected:
-        jhd1313m1_context m_jhd1313m1;
-        upm_result_t command(uint8_t cmd);
-        upm_result_t data(uint8_t data);
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        Jhd1313m1(const Jhd1313m1&) = delete;
-        Jhd1313m1 &operator=(const Jhd1313m1&) = delete;
-    };
-}
diff --git a/src/jhd1313m1/jhd1313m1.i b/src/jhd1313m1/jhd1313m1.i
deleted file mode 100644
index 75c4f39..0000000
--- a/src/jhd1313m1/jhd1313m1.i
+++ /dev/null
@@ -1,29 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "std_vector.i"
-%template(byteVector) std::vector<uint8_t>;
-
-JAVA_JNI_LOADLIBRARY(javaupm_jhd1313m1)
-#endif
-/* END Java syntax */
-
-/* BEGIN Javascript syntax  ------------------------------------------------- */
-#ifdef SWIGJAVASCRIPT
-%include "../upm_vectortypes.i"
-#endif
-/* END Javascript syntax */
-
-/* BEGIN Python syntax  ----------------------------------------------------- */
-#ifdef SWIGPYTHON
-%include "../upm_vectortypes.i"
-#endif
-/* END Python syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "jhd1313m1.hpp"
-%}
-%include "jhd1313m1.hpp"
-/* END Common SWIG syntax */
diff --git a/src/jhd1313m1/jhd1313m1.json b/src/jhd1313m1/jhd1313m1.json
deleted file mode 100644
index 0c14ccb..0000000
--- a/src/jhd1313m1/jhd1313m1.json
+++ /dev/null
@@ -1,37 +0,0 @@
-{
-    "Library": "jhd1313m1",
-    "Description": "API for the JHD1313M1 I2C LCD Controller",
-    "Sensor Class":
-    {
-        "Jhd1313m1":
-        {
-            "Name": "LCD Display Driver for the JHD1313M1 Controller for HD44780-based Displays",
-            "Description": "JHD1313M1 has two I2C addreses: one belongs to a controller, very similar to the upm::Lcm1602 LCD driver, that controls the HD44780-based display, and the other controls only the backlight. This module was tested with the Seeed Grove LCD RGB Backlight v2.0 display that requires 5V to operate.",
-            "Aliases": ["jhd1313m1"],
-            "Categories": ["display"],
-            "Connections": ["i2c"],
-            "Project Type": ["display", "prototyping"],
-            "Manufacturers": ["seeed"],
-            "Kits": ["gsk"],
-            "Examples":
-            {
-                "Java": ["Jhd1313m1_Example.java", "Jhd1313m1_lcd_Example.java"],
-                "Python": ["jhd1313m1-lcd.py"],
-                "Node.js": ["jhd1313m1-lcd.js"],
-                "C++": ["jhd1313m1-lcd.cxx"],
-                "C": ["jhd1313m1.c"]
-            },
-            "Specifications":
-            {
-                "Operating Voltage": {"unit": "V", "typ": 5},
-                "Operating Current": {"unit": "mA", "max": 60}
-            },
-            "Urls" :
-            {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-LCD-RGB-Backlight-p-1643.html?cPath=34_36"],
-                "Datasheets": ["http://wiki.seeed.cc/Grove-LCD_RGB_Backlight/"],
-                "Schematics": []
-            }
-        }
-    }
-}
diff --git a/src/joystick12/CMakeLists.txt b/src/joystick12/CMakeLists.txt
deleted file mode 100644
index 335911a..0000000
--- a/src/joystick12/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-upm_mixed_module_init (NAME joystick12
-    DESCRIPTION "2-axis Analog Joystick"
-    C_HDR joystick12.h
-    C_SRC joystick12.c
-    CPP_HDR joystick12.hpp
-    CPP_SRC joystick12.cxx
-    FTI_SRC joystick12_fti.c
-    REQUIRES mraa)
diff --git a/src/joystick12/joystick12.c b/src/joystick12/joystick12.c
deleted file mode 100644
index 08009ee..0000000
--- a/src/joystick12/joystick12.c
+++ /dev/null
@@ -1,214 +0,0 @@
-/*
- * Author: Noel Eck <noel.eck@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string.h>
-#include <stdlib.h>
-
-#include "joystick12.h"
-
-joystick12_context joystick12_init(int16_t apin_x, int16_t apin_y)
-{
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        return NULL;
-    }
-
-    joystick12_context dev =
-      (joystick12_context) malloc(sizeof(struct _joystick12_context));
-
-    if(dev == NULL) return NULL;
-
-    /* Init analog pins */
-    dev->ai_x = mraa_aio_init(apin_x);
-    dev->ai_y = mraa_aio_init(apin_y);
-
-    /* Set the ref, zero the offset */
-    dev->m_count_offset_x = 0.0;
-    dev->m_count_scale_x = 2.0;
-    dev->m_count_offset_y = 0.0;
-    dev->m_count_scale_y = 2.0;
-
-    if((dev->ai_x == NULL) || (dev->ai_y == NULL))
-    {
-        free(dev);
-        return NULL;
-    }
-
-    return dev;
-}
-
-void joystick12_close(joystick12_context dev)
-{
-    mraa_aio_close(dev->ai_x);
-    mraa_aio_close(dev->ai_y);
-    free(dev);
-}
-
-upm_result_t joystick12_read_data(const joystick12_context dev, int* values)
-{
-    /* Throw away first read */
-    mraa_aio_read(dev->ai_x);
-    values[0] = mraa_aio_read(dev->ai_x);
-    /* Throw away first read */
-    mraa_aio_read(dev->ai_y);
-    values[1] = mraa_aio_read(dev->ai_y);
-
-    if (values[0] < 0 || values[1] < 0)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t joystick12_set_offset_x(const joystick12_context dev, float offset)
-{
-    dev->m_count_offset_x = offset;
-    return UPM_SUCCESS;
-}
-
-upm_result_t joystick12_set_offset_y(const joystick12_context dev, float offset)
-{
-    dev->m_count_offset_y = offset;
-    return UPM_SUCCESS;
-}
-
-upm_result_t joystick12_set_scale_x(const joystick12_context dev, float scale)
-{
-    dev->m_count_scale_x = scale;
-    return UPM_SUCCESS;
-}
-
-upm_result_t joystick12_set_scale_y(const joystick12_context dev, float scale)
-{
-    dev->m_count_scale_y = scale;
-    return UPM_SUCCESS;
-}
-
-upm_result_t joystick12_get_value_x(const joystick12_context dev, float *value)
-{
-    int counts[2] = {0,0};
-
-    /* Read counts from the generic read method */
-    joystick12_read_data(dev, counts);
-
-    /* Get max adc value range 1023, 2047, 4095, etc... */
-    float max_adc = (1 << mraa_aio_get_bit(dev->ai_x)) - 1;
-
-    /* Apply raw offset */
-    *value = counts[0] + dev->m_count_offset_x;
-
-    // Scale to +/- 1.0
-    *value =  -2.0 * (((max_adc/2.0 - *value))/max_adc * dev->m_count_scale_x);
-
-    // Clip to +/- 1.0
-    if (*value > 1.0) *value = 1.0;
-    else if (*value < -1.0) *value = -1.0;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t joystick12_get_value_y(const joystick12_context dev, float *value)
-{
-    int counts[2] = {0,0};
-
-    /* Read counts from the generic read method */
-    joystick12_read_data(dev, counts);
-
-    /* Get max adc value range 1023, 2047, 4095, etc... */
-    float max_adc = (1 << mraa_aio_get_bit(dev->ai_y)) - 1;
-
-    /* Apply raw offset */
-    *value = counts[1] + dev->m_count_offset_y;
-
-    // Scale to +/- 1.0
-    *value =  -2.0 * (((max_adc/2.0 - *value))/max_adc * dev->m_count_scale_y);
-
-    // Clip to +/- 1.0
-    if (*value > 1.0) *value = 1.0;
-    else if (*value < -1.0) *value = -1.0;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t joystick12_zero(const joystick12_context dev)
-{
-    int counts[2] = {0, 0};
-
-    /* Read counts from the generic read method */
-    joystick12_read_data(dev, counts);
-
-    /* Get max adc value range 1023, 2047, 4095, etc... */
-    float max_adc = (1 << mraa_aio_get_bit(dev->ai_y)) - 1;
-
-    dev->m_count_offset_x = max_adc/2.0 - counts[0];
-    dev->m_count_offset_y = max_adc/2.0 - counts[1];
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t joystick12_calibrate_x(const joystick12_context dev)
-{
-    int counts[2] = {0, 0};
-
-    /* Read counts from the generic read method */
-    joystick12_read_data(dev, counts);
-
-    /* Get max adc value range 1023, 2047, 4095, etc... */
-    float max_adc = (1 << mraa_aio_get_bit(dev->ai_y)) - 1;
-
-    float fcounts = counts[0];
-
-    /* no need to scale if counts is a max or min value */
-    if ((fcounts == 0) || (fcounts == max_adc)) return UPM_SUCCESS;
-
-    dev->m_count_scale_x =
-      1.0 / (1.0 - 2.0 * fcounts/max_adc);
-    dev->m_count_scale_x = fabs(dev->m_count_scale_x);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t joystick12_calibrate_y(const joystick12_context dev)
-{
-    int counts[2] = {0, 0};
-
-    /* Read counts from the generic read method */
-    joystick12_read_data(dev, counts);
-
-    /* Get max adc value range 1023, 2047, 4095, etc... */
-    float max_adc = (1 << mraa_aio_get_bit(dev->ai_y)) - 1;
-
-    float fcounts = counts[1];
-
-    /* no need to scale if counts is a max or min value */
-    if ((fcounts == 0) || (fcounts == max_adc)) return UPM_SUCCESS;
-
-    dev->m_count_scale_y =
-      1.0 / (1.0 - 2.0 * fcounts/max_adc);
-    dev->m_count_scale_y = fabs(dev->m_count_scale_y);
-
-    return UPM_SUCCESS;
-}
diff --git a/src/joystick12/joystick12.cxx b/src/joystick12/joystick12.cxx
deleted file mode 100644
index 4f7245b..0000000
--- a/src/joystick12/joystick12.cxx
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- * Author: Alexander Komarov <alexander.komarov@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-#include <unistd.h>
-#include <stdlib.h>
-#include <functional>
-#include <string.h>
-#include "joystick12.hpp"
-
-using namespace upm;
-
-// FIXME AK: to make configurable if needed
-const int Joystick12::X_left = 100;
-const int Joystick12::X_center = 1610;
-const int Joystick12::X_right= 4070;
-
-const int Joystick12::Y_left = 2;
-const int Joystick12::Y_center = 1610;
-const int Joystick12::Y_right= 4070;
-
-
-Joystick12::Joystick12(int pinX, int pinY) {
-
-    if ( !(m_joystickCtxX = mraa_aio_init(pinX)) ) 
-      {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_aio_init(pinX) failed, invalid pin?");
-        return;
-      }
-
-    if ( !(m_joystickCtxY = mraa_aio_init(pinY)) ) 
-      {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_aio_init(pinY) failed, invalid pin?");
-        return;
-      }
-}
-
-Joystick12::~Joystick12() {
-    // close inputs
-    mraa_result_t error;
-    error = mraa_aio_close(m_joystickCtxX);
-    if (error != MRAA_SUCCESS) {
-        mraa_result_print(error);
-    }
-    error = mraa_aio_close(m_joystickCtxY);
-    if (error != MRAA_SUCCESS) {
-        mraa_result_print(error);
-    }
-}
-
-float Joystick12::getXInput() {
-    float in = mraa_aio_read (m_joystickCtxX);
-    if (in == -1.0) return -1;
-    if (in < X_left) return -1;
-    if (in < X_center) return -(X_center - in) / (X_center - X_left);
-    if (in == X_center) return 0;
-    if (in < X_right) return (in - X_center) / (X_right - X_center);
-    if (in >= X_right) return 1;
-    mraa_result_print(MRAA_ERROR_UNSPECIFIED);
-    return 0;
-}
-
-float Joystick12::getYInput() {
-    float  in = mraa_aio_read (m_joystickCtxY);
-    if (in == -1.0) return -1;
-    if (in < Y_left) return -1;
-    if (in < Y_center) return -(Y_center - in) / (Y_center - Y_left);
-    if (in == Y_center) return 0;
-    if (in < Y_right) return (in - Y_center) / (Y_right - Y_center);
-    if (in >= Y_right) return 1;
-    mraa_result_print(MRAA_ERROR_UNSPECIFIED);
-    return 0;
-}
-
-
diff --git a/src/joystick12/joystick12.h b/src/joystick12/joystick12.h
deleted file mode 100644
index 4fae2b9..0000000
--- a/src/joystick12/joystick12.h
+++ /dev/null
@@ -1,159 +0,0 @@
-/*
- * Author: Noel Eck <noel.eck@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include "upm.h"
-#include "mraa/aio.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @file joystick12.h
- * @library joystick12
- * @brief C API for Analog 2-Axis Joysticks
- *
- * @include joystick12.c
- */
-
-/**
- * device context
- */
-typedef struct _joystick12_context {
-    /* mraa ai_x pin context */
-    mraa_aio_context ai_x;
-    /* mraa ai_y pin context */
-    mraa_aio_context ai_y;
-    /* Raw count offset - x axis */
-    float m_count_offset_x;
-    /* Raw count offset - y axis */
-    float m_count_offset_y;
-    /* Raw count scale - x axis */
-    float m_count_scale_x;
-    /* Raw count scale - y axis */
-    float m_count_scale_y;
-} *joystick12_context;
-
-/**
- * Initialize analog sensor
- * @param pin is Analog pin
- * @return sensor context as void pointer
- */
-joystick12_context joystick12_init(int16_t apin_x, int16_t apin_y);
-
-/**
- * Analog sensor destructor
- * @param sensor context pointer deallocate memory
- */
-void joystick12_close(joystick12_context dev);
-
-/**
- * Generic read joystick data method
- * @param dev sensor device context pointer
- * @param value pointer to an int[2] in which data is returned
- */
-upm_result_t joystick12_read_data(const joystick12_context dev, int* values);
-
-/**
- * Set sensor offset.  This offset is applied to the return value:
- *     counts = counts + offset
- * @param dev sensor context pointer
- * @param offset count offset value used
- * @return Function result code
- */
-upm_result_t joystick12_set_offset_x(const joystick12_context dev,
-                                     float offset);
-
-/**
- * Set sensor offset.  This offset is applied to the return value:
- *     counts = counts + offset
- * @param dev sensor context pointer
- * @param offset count offset value used
- * @return Function result code
- */
-upm_result_t joystick12_set_offset_y(const joystick12_context dev,
-                                     float offset);
-
-/**
- * Set sensor scale.  This scale is applied to the return value:
- *     counts = counts * scale
- * @param dev sensor context pointer
- * @param scale count scale value used
- * @return Function result code
- */
-upm_result_t joystick12_set_scale_x(const joystick12_context dev, float scale);
-
-/**
- * Set sensor scale.  This scale is applied to the return value:
- *     counts = counts * scale
- * @param dev sensor context pointer
- * @param scale count scale value used
- * @return Function result code
- */
-upm_result_t joystick12_set_scale_y(const joystick12_context dev, float scale);
-
-/**
- * Read value from sensor
- * @param dev sensor context pointer
- * @param *value normalized value from sensor, units depend on unit enum
- * @param unit Enum which specifies units returned in *value
- * @return Function result code
- */
-upm_result_t joystick12_get_value_x(const joystick12_context dev, float *value);
-
-/**
- * Read value from sensor
- * @param dev sensor context pointer
- * @param *value normalized value from sensor, units depend on unit enum
- * @param unit Enum which specifies units returned in *value
- * @return Function result code
- */
-upm_result_t joystick12_get_value_y(const joystick12_context dev, float *value);
-
-/**
- * Zero out the sensor x and y axis
- * @param dev sensor context pointer
- * @return Function result code
- */
-upm_result_t joystick12_zero(const joystick12_context dev);
-
-/**
- * Set x scale.  Move joystick to min or max x and call calibrate
- * @param dev sensor context pointer
- * @return Function result code
- */
-upm_result_t joystick12_calibrate_x(const joystick12_context dev);
-
-/**
- * Set y scale.  Move joystick to min or max y and call calibrate
- * @param dev sensor context pointer
- * @return Function result code
- */
-upm_result_t joystick12_calibrate_y(const joystick12_context dev);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/joystick12/joystick12.hpp b/src/joystick12/joystick12.hpp
deleted file mode 100644
index 9ba9b39..0000000
--- a/src/joystick12/joystick12.hpp
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Author: Alexander Komarov <alexander.komarov@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/gpio.h>
-#include <mraa/aio.h>
-
-namespace upm {
-
-/**
- * @brief Analog Joystick Library
- * @defgroup joystick12 libupm-joystick12
- * @ingroup generic analog ainput robok
- */
-
-/**
- * @library joystick12
- * @sensor joystick12
- * @comname 2-axis Analog Joystick
- * @type ainput
- * @man generic
- * @con analog
- * @kit robok
- *
- * @brief API for the ElecFreaks* Joystick v 1.2-1.4 Breakout
- *
- * This module defines the Joystick API, and implementation for the X and Y
- * buttons could be treated as normal GPIO - this enables easier
- * interrupt support. This driver should be compatible with any
- * 2-axis analog joystick.
- *
- * @image html joystick12.jpg
- * @snippet joystick12.cxx Interesting
- */
-class Joystick12 {
-    public:
-        /**
-         * Instantiates a Joystick object
-         *
-         * @param pinX Analog pin where the X input is connected
-         * @param pinY Analog pin where the Y input is connected
-         */
-        Joystick12(int pinX, int pinY);
-
-        /**
-         * Joystick object destructor
-         */
-        ~Joystick12();
-
-        /**
-         * Gets the X input
-         * @return float X value, ranging from -1 to 1; 0 is mid
-         */
-        float getXInput();
-
-        /**
-         * Gets the Y input
-         *
-         * @return float Y value, ranging from -1 to 1; 0 is mid
-         */
-        float getYInput();
-
-    private:
-        mraa_aio_context    m_joystickCtxX;
-        mraa_aio_context    m_joystickCtxY;
-
-        static const int X_left;
-        static const int X_center;
-        static const int X_right;
-        static const int Y_left;
-        static const int Y_center;
-        static const int Y_right;
-};
-};
-
diff --git a/src/joystick12/joystick12.i b/src/joystick12/joystick12.i
deleted file mode 100644
index 2712705..0000000
--- a/src/joystick12/joystick12.i
+++ /dev/null
@@ -1,14 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_joystick12)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "joystick12.hpp"
-%}
-%include "joystick12.hpp"
-/* END Common SWIG syntax */
diff --git a/src/joystick12/joystick12.json b/src/joystick12/joystick12.json
deleted file mode 100644
index 3365449..0000000
--- a/src/joystick12/joystick12.json
+++ /dev/null
@@ -1,33 +0,0 @@
-{
-    "Library": "joystick12",
-    "Description": "API for the ElecFreaks* Joystick v 1.2-1.4 Breakout",
-    "Sensor Class":
-    {
-        "Joystick12":
-        {
-            "Name": "2-axis Analog Joystick",
-            "Description": "This module defines the Joystick API, and implementation for the X and Y buttons could be treated as normal GPIO - this enables easier interrupt support. This driver should be compatible with any 2-axis analog joystick.",
-            "Aliases": ["joystick12"],
-            "Categories": ["input"],
-            "Connections": ["analog"],
-            "Project Type": ["prototyping"],
-            "Manufacturers": ["generic"],
-            "Kits": ["robok"],
-            "Image": "joystick12.jpg",
-            "Examples":
-            {
-                "Java": ["Joystick12_Example.java", "Joystick12_example_Example.java"],
-                "Python": ["joystick12.py"],
-                "Node.js": ["joystick12.js"],
-                "C++": ["joystick12.cxx"],
-                "C": ["joystick12.c"]
-            },
-            "Urls" :
-            {
-                "Product Pages": ["http://www.elecfreaks.com/estore/joystick-breakout-module-bkout-md01.html"],
-                "Datasheets": ["https://www.elecfreaks.com/wiki/index.php?title=Joystick_breakout_module"],
-                "Schematics": ["http://elecfreaks.com/store/download/schematic-red.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/joystick12/joystick12_fti.c b/src/joystick12/joystick12_fti.c
deleted file mode 100644
index c89bef6..0000000
--- a/src/joystick12/joystick12_fti.c
+++ /dev/null
@@ -1,143 +0,0 @@
-/*
- * Author: Noel Eck <noel.eck@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string.h>
-#include <stdlib.h>
-
-#include "joystick12.h"
-#include "upm_fti.h"
-#include "fti/upm_sensor.h"
-#include "fti/upm_joystick.h"
-
-/** 
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_joystick12_name[] = "JOYSTICK12";
-const char upm_joystick12_description[] = "Analog joystick sensor";
-const upm_protocol_t upm_joystick12_protocol[] = {UPM_ANALOG};
-const upm_sensor_t upm_joystick12_category[] = {UPM_JOYSTICK};
-
-// forward declarations
-const void* upm_joystick12_get_ft(upm_sensor_t sensor_type);
-void* upm_joystick12_init_str(const char* protocol, const char* params);
-void upm_joystick12_close(void* dev);
-const upm_sensor_descriptor_t upm_joystick12_get_descriptor();
-upm_result_t upm_joystick12_set_offset_x(const void* dev, float offset);
-upm_result_t upm_joystick12_set_offset_y(const void* dev, float offset);
-upm_result_t upm_joystick12_set_scale_x(const void* dev, float scale);
-upm_result_t upm_joystick12_set_scale_y(const void* dev, float scale);
-upm_result_t upm_joystick12_get_value_x(const void* dev, float *value);
-upm_result_t upm_joystick12_get_value_y(const void* dev, float *value);
-
-
-
-/* This sensor implementes 2 function tables */
-/* 1. Generic base function table */
-static const upm_sensor_ft ft_gen =
-{
-    .upm_sensor_init_name = &upm_joystick12_init_str,
-    .upm_sensor_close = &upm_joystick12_close,
-    .upm_sensor_get_descriptor = &upm_joystick12_get_descriptor
-};
-
-/* 2. JOYSTICK function table */
-static const upm_joystick_ft ft_joystick =
-{
-    .upm_joystick_set_offset_x = &upm_joystick12_set_offset_x,
-    .upm_joystick_set_offset_y = &upm_joystick12_set_offset_y,
-    .upm_joystick_set_scale_x = &upm_joystick12_set_scale_x,
-    .upm_joystick_set_scale_y = &upm_joystick12_set_scale_y,
-    .upm_joystick_get_value_x = &upm_joystick12_get_value_x,
-    .upm_joystick_get_value_y = &upm_joystick12_get_value_y
-};
-
-const void* upm_joystick12_get_ft(upm_sensor_t sensor_type)
-{
-    switch(sensor_type)
-    {
-        case UPM_SENSOR:
-            return &ft_gen;
-        case UPM_JOYSTICK:
-            return &ft_joystick;
-        default:
-            return NULL;
-    }
-}
-
-void* upm_joystick12_init_str(const char* protocol, const char* params)
-{
-    fprintf(stderr, "String initialization - not implemented, using ain0 = x ain1 = y: %s\n", __FILENAME__);
-    return joystick12_init(0, 1);
-}
-
-void upm_joystick12_close(void* dev)
-{
-    joystick12_close((joystick12_context)dev);
-}
-
-const upm_sensor_descriptor_t upm_joystick12_get_descriptor()
-{
-    /* Fill in the descriptor */
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_joystick12_name;
-    usd.description = upm_joystick12_description;
-    usd.protocol_size = 1;
-    usd.protocol = upm_joystick12_protocol;
-    usd.category_size = 1;
-    usd.category = upm_joystick12_category;
-
-    return usd;
-}
-
-upm_result_t upm_joystick12_set_offset_x(const void* dev, float offset)
-{
-    return joystick12_set_offset_x((joystick12_context)dev, offset);
-}
-
-upm_result_t upm_joystick12_set_offset_y(const void* dev, float offset)
-{
-    return joystick12_set_offset_y((joystick12_context)dev, offset);
-}
-
-upm_result_t upm_joystick12_set_scale_x(const void* dev, float scale)
-{
-    return joystick12_set_scale_x((joystick12_context)dev, scale);
-}
-
-upm_result_t upm_joystick12_set_scale_y(const void* dev, float scale)
-{
-    return joystick12_set_scale_y((joystick12_context)dev, scale);
-}
-
-upm_result_t upm_joystick12_get_value_x(const void* dev, float *value)
-{
-    return joystick12_get_value_x((joystick12_context)dev, value);
-}
-
-upm_result_t upm_joystick12_get_value_y(const void* dev, float *value)
-{
-    return joystick12_get_value_y((joystick12_context)dev, value);
-}
-
diff --git a/src/kx122/CMakeLists.txt b/src/kx122/CMakeLists.txt
deleted file mode 100644
index 71108be..0000000
--- a/src/kx122/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-upm_mixed_module_init (NAME kx122
-    DESCRIPTION "3-Axis Digital Accelerometer"
-    C_HDR kx122.h kx122_registers.h
-    C_SRC kx122.c
-    CPP_HDR kx122.hpp
-    CPP_SRC kx122.cxx
-    CPP_WRAPS_C
-    REQUIRES mraa m)
diff --git a/src/kx122/kx122.c b/src/kx122/kx122.c
deleted file mode 100644
index 711c39e..0000000
--- a/src/kx122/kx122.c
+++ /dev/null
@@ -1,1093 +0,0 @@
-/*
-* The MIT License (MIT)
-*
-* Author: Samuli Rissanen <samuli.rissanen@hotmail.com>
-* Copyright (c) 2018 Rohm Semiconductor.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy of
-* this software and associated documentation files (the "Software"), to deal in
-* the Software without restriction, including without limitation the rights to
-* use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-* the Software, and to permit persons to whom the Software is furnished to do so,
-* subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in all
-* copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-* COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-#include "kx122.h"
-
-//Used to set the bit required for SPI reading
-#define SPI_READ 0x80
-
-//Used to mask the read bit required for SPI writing
-#define SPI_WRITE 0x7F
-
-//Used to determine amount of samples in the buffer.
-#define LOW_RES_SAMPLE_MODIFIER 3
-#define HIGH_RES_SAMPLE_MODIFIER 6
-
-//Mask for software reset
-#define KX122_CNTL2_SRST_MASK 0x80
-
-//Masks for interrupt control registers
-#define KX122_INC1_MASK 0xFB
-#define KX122_INC4_MASK 0xF7
-#define KX122_INC5_MASK 0xFB
-#define KX122_INC6_MASK 0xF7
-
-//Acceleration data buffer length
-#define BUFFER_LEN 6
-
-//Acceleration per decimal value for each acceleration ranges
-#define RANGE_2G_G 0.00006f
-#define RANGE_4G_G 0.00012f
-#define RANGE_8G_G 0.00024f
-
-//Acceleration scaling between high and low resolution modes
-#define RANGE_RES_SCALE 260
-
-//Maximum loop iterations, used in software reset and self testing
-#define MAX_LOOP_COUNT 100
-
-//Sensor self-test defines
-#define SELF_TEST_LOOP_WAIT_TIME 10000
-#define SELF_TEST_MAX_DIFFERENCE 0.75f
-#define SELF_TEST_MIN_XY_DIFFERENCE 0.25f
-#define SELF_TEST_MIN_Z_DIFFERENCE 0.20f
-
-//Maximum amount of samples in the buffer for high and low resolutions
-#define MAX_BUFFER_SAMPLES_LOW_RES 681
-#define MAX_BUFFER_SAMPLES_HIGH_RES 340
-
-//Earth gravity constant (m/s^2)
-#define GRAVITY 9.81f
-/**
-Enables the chip select on the chip_select GPIO pin.
-Chip select is active low.
-
-@param dev The device context.
-*/
-static void kx122_chip_select_on(const kx122_context dev);
-
-/**
-Disables the chip select on the chip_select GPIO pin.
-
-@param dev The device context.
-*/
-static void kx122_chip_select_off(const kx122_context dev);
-
-/**
-Reads a register.
-
-@param dev The device context.
-@param reg The register to read.
-@param data Pointer to a uint8_t variable to store the value.
-@return UPM result
-*/
-static upm_result_t kx122_read_register(const kx122_context dev, uint8_t reg, uint8_t *data);
-
-/**
-Reads multiple continous registers.
-
-@param dev The device context.
-@param reg The start register.
-@param buffer Pointer to a uint8_t buffer to store the values.
-@param len Amount of bytes to read.
-@return UPM result
-*/
-static upm_result_t kx122_read_registers(const kx122_context dev, uint8_t reg, uint8_t *buffer, uint len);
-
-/**
-Writes to a register.
-
-@param dev The device context.
-@param reg The register to write to.
-@param val The value to write to the register.
-@return UPM result
-*/
-static upm_result_t kx122_write_register(const kx122_context dev, uint8_t reg, uint8_t val);
-
-/**
-Writes to a register using a bitmask.
-
-@param dev The device context.
-@param reg The register to write to.
-@param val The value to write to the register.
-@param bit_mask The bitmask to be used.
-@return UPM result.
-*/
-static upm_result_t kx122_set_bit_pattern(const kx122_context dev, uint8_t reg, uint8_t val, uint8_t bit_mask);
-
-/**
-Sets a specific bit on (1) in a register.
-
-@param dev The device context.
-@param reg The register to write to.
-@param val The value to write to the register.
-@return UPM result.
-*/
-static upm_result_t kx122_set_bit_on(const kx122_context dev, uint8_t reg, uint8_t val);
-
-/**
-Sets a specific bit off (0) in a register.
-
-@param dev The device context.
-@param reg The register to write to.
-@param val The value to write to the register.
-@return UPM result.
-*/
-static upm_result_t kx122_set_bit_off(const kx122_context dev, uint8_t reg, uint8_t val);
-
-/**
-Sets the default internal variable values.
-
-@param dev The device context.
-*/
-static void kx122_set_default_values(const kx122_context dev);
-
-/**
-Sets acceleration scale of sensor and the buffer.
-
-@param dev The device context.
-@param grange One of the KX122_RANGE_T values.
-*/
-static void kx122_map_grange(const kx122_context dev, KX122_RANGE_T grange);
-
-kx122_context kx122_init(int bus, int addr, int chip_select_pin, int spi_bus_frequency)
-{
-  kx122_context dev = (kx122_context)malloc(sizeof(struct _kx122_context));
-
-  if(!dev){
-    return NULL;
-  }
-
-  dev->using_spi = false;
-
-  dev->i2c = NULL;
-  dev->spi = NULL;
-  dev->chip_select = NULL;
-
-  dev->gpio1 = NULL;
-  dev->gpio2 = NULL;
-
-  if(mraa_init() != MRAA_SUCCESS){
-    printf("%s: mraa_init() failed.\n", __FUNCTION__);
-    kx122_close(dev);
-    return NULL;
-  }
-
-  if(addr == -1){
-    dev->using_spi = true;
-  }
-
-  if(dev->using_spi){
-
-    if (spi_bus_frequency > 10000000){	// KX122 has a maximum SPI bus speed of 10MHz
-      printf("%s: bus frequency too high - KX122 has a maximum SPI bus speed of 10MHz.\n", __FUNCTION__);
-      kx122_close(dev);
-      return NULL;
-    }
-
-    if (!(dev->spi = mraa_spi_init(bus))){
-      printf("%s: mraa_spi_init() failed.\n", __FUNCTION__);
-      kx122_close(dev);
-      return NULL;
-    }
-
-    if (!(dev->chip_select = mraa_gpio_init(chip_select_pin))){
-      printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
-      kx122_close(dev);
-      return NULL;
-    }
-
-    mraa_gpio_dir(dev->chip_select,MRAA_GPIO_OUT);
-    mraa_spi_mode(dev->spi,MRAA_SPI_MODE0);
-
-    if (mraa_spi_frequency(dev->spi, spi_bus_frequency)){
-      printf("%s: mraa_spi_frequency() failed.\n", __FUNCTION__);
-      kx122_close(dev);
-      return NULL;
-    }
-  }
-  else{ //Using I2C
-    if (!(dev->i2c = mraa_i2c_init(bus))){
-      printf("%s: mraa_i2c_init() failed, used bus: %d\n", __FUNCTION__,bus);
-      kx122_close(dev);
-      return NULL;
-    }
-
-    if (mraa_i2c_address(dev->i2c, addr)){
-      printf("%s: mraa_i2c_address() failed.\n", __FUNCTION__);
-      kx122_close(dev);
-      return NULL;
-    }
-  }
-
-  uint8_t who_am_i;
-  kx122_get_who_am_i(dev,&who_am_i);
-
-  if(who_am_i != KX122_WHO_AM_I_WIA_ID){
-    printf("%s: Wrong WHO AM I received, expected: 0x%x | got: 0x%x\n", __FUNCTION__,KX122_WHO_AM_I_WIA_ID,who_am_i);
-    kx122_close(dev);
-    return NULL;
-  }
-
-  kx122_set_default_values(dev);
-
-  kx122_device_init(dev,KX122_ODR_50,HIGH_RES,KX122_RANGE_2G);
-  return dev;
-}
-
-void kx122_close(kx122_context dev)
-{
-  assert(dev != NULL);
-  kx122_uninstall_isr(dev,INT1);
-  kx122_uninstall_isr(dev,INT2);
-
-  if(dev->i2c){
-    mraa_i2c_stop(dev->i2c);
-  }
-  if(dev->spi){
-    mraa_spi_stop(dev->spi);
-  }
-  if(dev->chip_select){
-    mraa_gpio_close(dev->chip_select);
-  }
-  free(dev);
-}
-
-static void kx122_chip_select_on(const kx122_context dev)
-{
-  if(dev->chip_select){
-    mraa_gpio_write(dev->chip_select,0);
-  }
-}
-
-static void kx122_chip_select_off(const kx122_context dev)
-{
-  if(dev->chip_select){
-    mraa_gpio_write(dev->chip_select,1);
-  }
-}
-
-//Register operations
-static upm_result_t kx122_read_register(const kx122_context dev, uint8_t reg, uint8_t *data)
-{
-  if(dev->using_spi){
-    reg |= SPI_READ;
-
-    uint8_t spi_data[2] = {reg,0};
-
-    kx122_chip_select_on(dev);
-
-    if(mraa_spi_transfer_buf(dev->spi,spi_data,spi_data,(sizeof(spi_data) / sizeof(uint8_t))) != MRAA_SUCCESS){
-      printf("%s: mraa_spi_transfer_buf() failed.\n", __FUNCTION__);
-
-      kx122_chip_select_off(dev);
-      return UPM_ERROR_OPERATION_FAILED;
-    }
-      *data = spi_data[1];
-
-      kx122_chip_select_off(dev);
-      return UPM_SUCCESS;
-  }
-  else{
-    int value = mraa_i2c_read_byte_data(dev->i2c,reg);
-
-    if(value != -1){
-      *data = (uint8_t) value;
-      return UPM_SUCCESS;
-    }
-
-    printf("%s: mraa_i2c_read_byte_data() failed, reading from register 0x%x\n",__FUNCTION__, reg);
-    return UPM_ERROR_OPERATION_FAILED;
-  }
-}
-
-static upm_result_t kx122_read_registers(const kx122_context dev, uint8_t reg, uint8_t *buffer, uint len)
-{
-  if(dev->using_spi){
-    reg |= SPI_READ;
-
-    uint8_t spi_data_buffer[len + 1];
-    spi_data_buffer[0] = reg;
-
-    kx122_chip_select_on(dev);
-
-    if(mraa_spi_transfer_buf(dev->spi,spi_data_buffer,spi_data_buffer,
-    (sizeof(spi_data_buffer) / sizeof(uint8_t))) != MRAA_SUCCESS){
-      printf("%s: mraa_spi_transfer_buf() failed.\n", __FUNCTION__);
-
-      kx122_chip_select_off(dev);
-      return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    for (size_t i = 0; i < len; i++) {
-      buffer[i] = spi_data_buffer[i + 1];
-    }
-
-    kx122_chip_select_off(dev);
-    return UPM_SUCCESS;
-  }
-  else{
-      uint8_t data_buffer[len];
-      if(mraa_i2c_read_bytes_data(dev->i2c,reg,data_buffer,len) != (int)len){
-        return UPM_ERROR_OPERATION_FAILED;
-      }
-      else{
-        for(size_t i = 0; i < len; i++){
-          buffer[i] = data_buffer[i];
-        }
-        return UPM_SUCCESS;
-      }
-  }
-}
-
-static upm_result_t kx122_write_register(const kx122_context dev, uint8_t reg, uint8_t val)
-{
-  if(dev->using_spi){
-    reg &= SPI_WRITE;
-    uint8_t spi_data[2] = {reg,val};
-
-    kx122_chip_select_on(dev);
-    if(mraa_spi_transfer_buf(dev->spi,spi_data,NULL,(sizeof(spi_data) / sizeof(uint8_t))) != MRAA_SUCCESS){
-      printf("%s: mraa_spi_transfer_buf() failed.\n", __FUNCTION__);
-
-      kx122_chip_select_off(dev);
-      return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    kx122_chip_select_off(dev);
-    return UPM_SUCCESS;
-  }
-  else{
-    if(mraa_i2c_write_byte_data(dev->i2c,val,reg) != MRAA_SUCCESS){
-      printf("%s: mraa_i2c_write_byte_data() failed.\n",__FUNCTION__);
-      return UPM_ERROR_OPERATION_FAILED;
-    }
-    return UPM_SUCCESS;
-  }
-}
-
-static upm_result_t kx122_set_bit_pattern(const kx122_context dev, uint8_t reg, uint8_t val, uint8_t bit_mask)
-{
-  uint8_t reg_val;
-
-  if(kx122_read_register(dev,reg,&reg_val) != UPM_SUCCESS){
-    return UPM_ERROR_OPERATION_FAILED;
-  }
-
-  reg_val &= ~bit_mask;
-  reg_val |= val;
-  return kx122_write_register(dev,reg,reg_val);
-}
-
-static upm_result_t kx122_set_bit_on(const kx122_context dev, uint8_t reg, uint8_t val)
-{
-  uint8_t reg_val;
-
-  if(kx122_read_register(dev,reg,&reg_val) != UPM_SUCCESS){
-    return UPM_ERROR_OPERATION_FAILED;
-  }
-
-  reg_val |= val;
-  return kx122_write_register(dev,reg,reg_val);
-}
-
-static upm_result_t kx122_set_bit_off(const kx122_context dev, uint8_t reg, uint8_t val)
-{
-  uint8_t reg_val;
-
-  if(kx122_read_register(dev,reg,&reg_val) != UPM_SUCCESS){
-    return UPM_ERROR_OPERATION_FAILED;
-  }
-
-  reg_val &= ~val;
-  return kx122_write_register(dev,reg,reg_val);
-}
-
-static void kx122_set_default_values(const kx122_context dev)
-{
-  dev->accel_scale = RANGE_2G_G;
-  dev->grange_mode = KX122_RANGE_2G;
-  dev->res_mode = HIGH_RES;
-
-  dev->buffer_accel_scale = RANGE_2G_G;
-  dev->buffer_res = LOW_RES;
-  dev->buffer_mode = KX122_FIFO_MODE;
-}
-
-static void kx122_map_grange(const kx122_context dev, KX122_RANGE_T grange)
-{
-  switch (grange) {
-    case KX122_RANGE_2G:
-      dev->accel_scale = RANGE_2G_G;
-      dev->buffer_accel_scale = RANGE_2G_G;
-      break;
-    case KX122_RANGE_4G:
-      dev->accel_scale = RANGE_4G_G;
-      dev->buffer_accel_scale = RANGE_4G_G;
-      break;
-    case KX122_RANGE_8G:
-      dev->accel_scale = RANGE_8G_G;
-      dev->buffer_accel_scale = RANGE_8G_G;
-      break;
-  }
-
-  if(dev->res_mode == LOW_RES){
-    dev->accel_scale *= RANGE_RES_SCALE;
-  }
-  if(dev->buffer_res == LOW_RES){
-    dev->buffer_accel_scale *= RANGE_RES_SCALE;
-  }
-
-  dev->grange_mode = grange;
-}
-
-float kx122_get_sample_period(const kx122_context dev)
-{
-  assert(dev != NULL);
-
-  odr_item odr_map[16] = {
-    {KX122_ODR_0P781,0.781f},{KX122_ODR_1P563,1.563f},{KX122_ODR_3P125,3.125f},{KX122_ODR_6P25,6.25f},
-    {KX122_ODR_12P5,12.5f},{KX122_ODR_25,25},{KX122_ODR_50,50},{KX122_ODR_100,100},{KX122_ODR_200,200},
-    {KX122_ODR_400,400},{KX122_ODR_800,800},{KX122_ODR_1600,1600},{KX122_ODR_3200,3200},{KX122_ODR_6400,6400},
-    {KX122_ODR_12800,128000},{KX122_ODR_25600,25600}
-  };
-
-  uint8_t reg_val = 0;
-
-  kx122_read_register(dev,KX122_ODCNTL, &reg_val);
-  reg_val = reg_val & KX122_ODCNTL_OSA_MASK;
-
-  for (size_t i = 0; i < (sizeof(odr_map) / sizeof(odr_item)); i++) {
-    if(reg_val == odr_map[i].odr_value){
-      return (1 / odr_map[i].odr_decimal);
-    }
-  }
-  return -1; //Return -1 if failed
-}
-//Driver functions
-upm_result_t kx122_device_init(const kx122_context dev, KX122_ODR_T odr, KX122_RES_T res, KX122_RANGE_T grange)
-{
-  assert(dev != NULL);
-  kx122_set_sensor_standby(dev);
-
-  if(kx122_set_odr(dev,odr) != UPM_SUCCESS){
-    return UPM_ERROR_OPERATION_FAILED;
-  }
-  if(kx122_set_resolution(dev,res) != UPM_SUCCESS){
-    return UPM_ERROR_OPERATION_FAILED;
-  }
-  if(kx122_set_grange(dev,grange) != UPM_SUCCESS){
-    return UPM_ERROR_OPERATION_FAILED;
-  }
-
-  kx122_set_sensor_active(dev);
-  return UPM_SUCCESS;
-}
-
-upm_result_t kx122_get_who_am_i(const kx122_context dev, uint8_t *data)
-{
-  assert(dev != NULL);
-  return kx122_read_register(dev,KX112_WHO_AM_I,data);
-}
-
-upm_result_t kx122_set_sensor_standby(const kx122_context dev)
-{
-	assert(dev != NULL);
-	return kx122_set_bit_off(dev,KX122_CNTL1,KX122_CNTL1_PC1);
-}
-
-upm_result_t kx122_set_sensor_active(const kx122_context dev)
-{
-  assert(dev != NULL);
-  upm_result_t result = kx122_set_bit_on(dev,KX122_CNTL1,KX122_CNTL1_PC1);
-
-  usleep((kx122_get_sample_period(dev) * 1.5f) * MICRO_S); //Sleep 1.5/ODR
-
-  return result;
-}
-
-upm_result_t kx122_get_acceleration_data_raw(const kx122_context dev, float *x, float *y, float *z)
-{
-  assert(dev != NULL);
-
-  uint8_t buffer[BUFFER_LEN];
-
-  if(kx122_read_registers(dev,KX122_XOUT_L,buffer,BUFFER_LEN) != UPM_SUCCESS){
-    printf("%s: kx122_read_registers() failed to read %d bytes\n",__FUNCTION__, BUFFER_LEN);
-    return UPM_ERROR_OPERATION_FAILED;
-  }
-
-  if(dev->res_mode == HIGH_RES){
-    if(x){
-      *x = (float)((int16_t)(buffer[1] << 8) | buffer[0]);
-    }
-    if(y){
-      *y = (float)((int16_t)(buffer[3] << 8) | buffer[2]);
-    }
-    if(z){
-      *z = (float)((int16_t)(buffer[5] << 8) | buffer[4]);
-    }
-  }
-  else{
-    if(x){
-      *x = (float)(int8_t)buffer[1];
-    }
-    if(y){
-      *y = (float)(int8_t)buffer[3];
-    }
-    if(z){
-      *z = (float)(int8_t)buffer[5];
-    }
-  }
-
-  return UPM_SUCCESS;
-}
-
-upm_result_t kx122_get_acceleration_data(const kx122_context dev, float *x, float *y, float *z)
-{
-  float x_raw,y_raw,z_raw;
-
-  if(kx122_get_acceleration_data_raw(dev,&x_raw,&y_raw,&z_raw) != UPM_SUCCESS){
-    return UPM_ERROR_OPERATION_FAILED;
-  }
-
-  if(x){
-    *x = (x_raw * dev->accel_scale) * GRAVITY;
-  }
-  if(y){
-    *y = (y_raw * dev->accel_scale) * GRAVITY;
-  }
-  if(z){
-    *z = (z_raw * dev->accel_scale) * GRAVITY;
-  }
-
-  return UPM_SUCCESS;
-}
-
-upm_result_t kx122_sensor_software_reset(const kx122_context dev)
-{
-  assert(dev != NULL);
-  if(kx122_set_bit_on(dev,KX122_CNTL2,KX122_CNTL2_SRST) != UPM_SUCCESS){
-    return UPM_ERROR_OPERATION_FAILED;
-  }
-
-  int counter = 0;
-  uint8_t reg_val;
-
-  kx122_read_register(dev,KX122_CNTL2, &reg_val);
-
-  while((reg_val & KX122_CNTL2_SRST_MASK) != 0x00 && counter < MAX_LOOP_COUNT){
-    if(kx122_read_register(dev,KX122_CNTL2, &reg_val) != UPM_SUCCESS){
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-    usleep(100000);
-    counter++;
-  }
-
-  if(counter == MAX_LOOP_COUNT){
-    return UPM_ERROR_OPERATION_FAILED;
-  }
-
-  kx122_set_default_values(dev);
-
-  return UPM_SUCCESS;
-}
-
-upm_result_t kx122_enable_iir(const kx122_context dev)
-{
-  assert(dev != NULL);
-  return kx122_set_bit_off(dev,KX122_ODCNTL,KX122_ODCNTL_IIR_BYPASS_BYPASS);
-}
-
-upm_result_t kx122_disable_iir(const kx122_context dev)
-{
-  assert(dev != NULL);
-  return kx122_set_bit_on(dev,KX122_ODCNTL,KX122_ODCNTL_IIR_BYPASS_BYPASS);
-}
-
-upm_result_t kx122_self_test(const kx122_context dev)
-{
-  assert(dev != NULL);
-  float x,y,z;
-
-  float x_before_test_avg = 0, x_during_test_avg = 0;
-  float y_before_test_avg = 0, y_during_test_avg = 0;
-  float z_before_test_avg = 0, z_during_test_avg = 0;
-
-  for (size_t i = 0; i < MAX_LOOP_COUNT; i++) {
-    kx122_get_acceleration_data(dev,&x,&y,&z);
-    x_before_test_avg += fabs((x / GRAVITY));
-    y_before_test_avg += fabs((y / GRAVITY));
-    z_before_test_avg += fabs((z / GRAVITY));
-    usleep(SELF_TEST_LOOP_WAIT_TIME);
-  }
-
-  kx122_write_register(dev,KX122_SELF_TEST,KX122_SELF_TEST_MEMS_TEST_ON);
-
-  for (size_t i = 0; i < MAX_LOOP_COUNT; i++) {
-    kx122_get_acceleration_data(dev,&x,&y,&z);
-    x_during_test_avg += fabs((x / GRAVITY));
-    y_during_test_avg += fabs((y / GRAVITY));
-    z_during_test_avg += fabs((z / GRAVITY));
-    usleep(SELF_TEST_LOOP_WAIT_TIME);
-  }
-
-  kx122_write_register(dev,KX122_SELF_TEST,KX122_SELF_TEST_MEMS_TEST_OFF);
-
-  x_before_test_avg /= MAX_LOOP_COUNT;
-  x_during_test_avg /= MAX_LOOP_COUNT;
-
-  y_before_test_avg /= MAX_LOOP_COUNT;
-  y_during_test_avg /= MAX_LOOP_COUNT;
-
-  z_before_test_avg /= MAX_LOOP_COUNT;
-  z_during_test_avg /= MAX_LOOP_COUNT;
-
-  bool success = true;
-  float difference;
-  //X-AXIS
-  difference = fabs(x_during_test_avg - x_before_test_avg);
-  difference = ceilf(difference * 100) / 100;
-
-  if(difference >= SELF_TEST_MIN_XY_DIFFERENCE && difference <= SELF_TEST_MAX_DIFFERENCE){
-    printf("X-AXIS OK DIFFERENCE %.02f\n",difference);
-  }
-  else{
-    printf("X-AXIS FAILED, DIFFERENCE %.02f\n", difference);
-    success = false;
-  }
-  //Y-AXIS
-  difference = fabs(y_during_test_avg - y_before_test_avg);
-  difference = ceilf(difference * 100) / 100;
-  if(difference >= SELF_TEST_MIN_XY_DIFFERENCE && difference <= SELF_TEST_MAX_DIFFERENCE){
-    printf("Y-AXIS OK DIFFERENCE %.02f\n",difference);
-  }
-  else{
-    printf("Y-AXIS FAILED, DIFFERENCE %.02f\n", difference);
-    success = false;
-  }
-  //Z-AXIS
-  difference = fabs(z_during_test_avg - z_before_test_avg);
-  difference = ceilf(difference * 100) / 100;
-  if(difference >= SELF_TEST_MIN_Z_DIFFERENCE && difference <= SELF_TEST_MAX_DIFFERENCE){
-    printf("Z-AXIS OK DIFFERENCE %.02f\n",difference);
-  }
-  else{
-    printf("Z-AXIS FAILED, DIFFERENCE %.02f\n", difference);
-    success = false;
-  }
-
-  if(success){
-    return UPM_SUCCESS;
-  }
-
-  return UPM_ERROR_OPERATION_FAILED;
-}
-
-upm_result_t kx122_set_odr(const kx122_context dev, KX122_ODR_T odr)
-{
-  assert(dev != NULL);
-  return kx122_set_bit_pattern(dev,KX122_ODCNTL,odr,KX122_ODCNTL_OSA_MASK);
-}
-
-upm_result_t kx122_set_grange(const kx122_context dev, KX122_RANGE_T grange)
-{
-  assert(dev != NULL);
-  kx122_map_grange(dev,grange);
-
-  return kx122_set_bit_pattern(dev,KX122_CNTL1,grange,KX122_CNTL1_GSEL_MASK);
-}
-
-upm_result_t kx122_set_resolution(const kx122_context dev, KX122_RES_T res)
-{
-  assert(dev != NULL);
-
-  dev->res_mode = res;
-  kx122_map_grange(dev,dev->grange_mode);
-
-  if(res == HIGH_RES){
-    return kx122_set_bit_on(dev,KX122_CNTL1,KX122_CNTL1_RES);
-  }
-  else{
-    return kx122_set_bit_off(dev,KX122_CNTL1,KX122_CNTL1_RES);
-  }
-}
-
-upm_result_t kx122_set_bw(const kx122_context dev, LPRO_STATE_T lpro)
-{
-  assert(dev != NULL);
-  if(lpro == ODR_9){
-    return kx122_set_bit_off(dev, KX122_ODCNTL, KX122_ODCNTL_LPRO_ODR_2);
-  }
-  else{
-    return kx122_set_bit_on(dev, KX122_ODCNTL, KX122_ODCNTL_LPRO_ODR_2);
-  }
-}
-
-upm_result_t kx122_set_average(const kx122_context dev, KX122_AVG_T avg)
-{
-  assert(dev != NULL);
-  return kx122_set_bit_pattern(dev,KX122_LP_CNTL,avg,KX122_LP_CNTL_AVC_MASK);
-}
-
-upm_result_t kx122_install_isr(const kx122_context dev, mraa_gpio_edge_t edge,KX122_INTERRUPT_PIN_T intp, int pin, void (*isr)(void *), void *arg)
-{
-  assert(dev != NULL);
-  mraa_gpio_context isr_gpio = NULL;
-
-  if (!(isr_gpio = mraa_gpio_init(pin))){
-    printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
-    return UPM_ERROR_OPERATION_FAILED;
-  }
-
-  mraa_gpio_dir(isr_gpio, MRAA_GPIO_IN);
-
-  if (mraa_gpio_isr(isr_gpio, edge, isr, arg)){
-    mraa_gpio_close(isr_gpio);
-    printf("%s: mraa_gpio_isr() failed.\n", __FUNCTION__);
-    return UPM_ERROR_OPERATION_FAILED;
-  }
-
-  if(intp == INT1){
-    dev->gpio1 = isr_gpio;
-  }
-  else{
-    dev->gpio2 = isr_gpio;
-  }
-
-  return UPM_SUCCESS;
-}
-
-void kx122_uninstall_isr(const kx122_context dev, KX122_INTERRUPT_PIN_T intp)
-{
-  assert(dev != NULL);
-  if(intp == INT1 && dev->gpio1){
-    mraa_gpio_isr_exit(dev->gpio1);
-    mraa_gpio_close(dev->gpio1);
-    dev->gpio1 = NULL;
-  }
-  else if(intp == INT2 && dev->gpio2){
-    mraa_gpio_isr_exit(dev->gpio2);
-    mraa_gpio_close(dev->gpio2);
-    dev->gpio2 = NULL;
-  }
-}
-
-upm_result_t kx122_enable_interrupt1(const kx122_context dev, KX122_INTERRUPT_POLARITY_T polarity)
-{
-  assert(dev != NULL);
-
-  uint8_t bits = KX122_INC1_PWSEL1_50US_10US | KX122_INC1_IEL1 | KX122_INC1_IEN1;
-  if(polarity == ACTIVE_HIGH){
-    bits |= KX122_INC1_IEA1;
-  }
-
-  return kx122_set_bit_pattern(dev,KX122_INC1,bits,KX122_INC1_MASK);
-}
-
-upm_result_t kx122_enable_interrupt2(const kx122_context dev, KX122_INTERRUPT_POLARITY_T polarity)
-{
-  assert(dev != NULL);
-
-  uint8_t bits = KX122_INC5_PWSEL2_50US_10US | KX122_INC5_IEL2 | KX122_INC5_IEN2;
-  if(polarity == ACTIVE_HIGH){
-    bits |= KX122_INC5_IEA2;
-  }
-
-  return kx122_set_bit_pattern(dev,KX122_INC5,bits,KX122_INC5_MASK);
-}
-
-upm_result_t kx122_disable_interrupt1(const kx122_context dev)
-{
-  assert(dev != NULL);
-  return kx122_set_bit_off(dev,KX122_INC1,KX122_INC1_IEN1);
-}
-
-upm_result_t kx122_disable_interrupt2(const kx122_context dev)
-{
-  assert(dev != NULL);
-  return kx122_set_bit_off(dev,KX122_INC5,KX122_INC5_IEN2);
-}
-
-upm_result_t kx122_route_interrupt1(const kx122_context dev, uint8_t bits)
-{
-  assert(dev != NULL);
-  return kx122_set_bit_pattern(dev,KX122_INC4,bits,KX122_INC4_MASK);
-}
-
-upm_result_t kx122_route_interrupt2(const kx122_context dev, uint8_t bits)
-{
-  assert(dev != NULL);
-  return kx122_set_bit_pattern(dev,KX122_INC6,bits,KX122_INC6_MASK);
-}
-
-upm_result_t kx122_enable_data_ready_interrupt(const kx122_context dev)
-{
-  assert(dev != NULL);
-  return kx122_set_bit_on(dev,KX122_CNTL1,KX122_CNTL1_DRDYE);
-}
-
-upm_result_t kx122_disable_data_ready_interrupt(const kx122_context dev)
-{
-  assert(dev != NULL);
-  return kx122_set_bit_off(dev,KX122_CNTL1,KX122_CNTL1_DRDYE);
-}
-
-upm_result_t kx122_enable_buffer_full_interrupt(const kx122_context dev)
-{
-  assert(dev != NULL);
-  return kx122_set_bit_on(dev,KX122_BUF_CNTL2,KX122_BUF_CNTL2_BFIE);
-}
-
-upm_result_t kx122_disable_buffer_full_interrupt(const kx122_context dev)
-{
-  assert(dev != NULL);
-  return kx122_set_bit_off(dev,KX122_BUF_CNTL2,KX122_BUF_CNTL2_BFIE);
-}
-
-upm_result_t kx122_get_interrupt_source(const kx122_context dev, uint8_t *data)
-{
-  assert(dev != NULL);
-  return kx122_read_register(dev,KX122_INS2,data);
-}
-
-upm_result_t kx122_clear_interrupt(const kx122_context dev)
-{
-  assert(dev != NULL);
-  uint8_t reg_val;
-
-  return kx122_read_register(dev,KX122_INT_REL,&reg_val);
-}
-
-bool kx122_get_interrupt_status(const kx122_context dev)
-{
-  assert(dev != NULL);
-  uint8_t reg_val;
-
-  if(kx122_read_register(dev,KX122_STATUS_REG,&reg_val) != UPM_SUCCESS){
-    printf("%s: kx122_read_register() failed.\n", __FUNCTION__);
-    return false;
-  }
-
-  if(reg_val != 0x00){
-    return true;
-  }
-  return false;
-}
-
-upm_result_t kx122_enable_buffer(const kx122_context dev)
-{
-  assert(dev != NULL);
-  return kx122_set_bit_on(dev,KX122_BUF_CNTL2,KX122_BUF_CNTL2_BUFE);
-}
-
-upm_result_t kx122_disable_buffer(const kx122_context dev)
-{
-  assert(dev != NULL);
-  return kx122_set_bit_off(dev,KX122_BUF_CNTL2,KX122_BUF_CNTL2_BUFE);
-}
-
-upm_result_t kx122_buffer_init(const kx122_context dev, uint samples, KX122_RES_T res, KX122_BUFFER_MODE_T mode)
-{
-  assert(dev != NULL);
-  kx122_set_sensor_standby(dev);
-
-  if(kx122_set_buffer_threshold(dev,samples) != UPM_SUCCESS){
-    return UPM_ERROR_OPERATION_FAILED;
-  }
-  if(kx122_set_buffer_resolution(dev,res) != UPM_SUCCESS){
-    return UPM_ERROR_OPERATION_FAILED;
-  }
-  if(kx122_set_buffer_mode(dev,mode) != UPM_SUCCESS){
-    return UPM_ERROR_OPERATION_FAILED;
-  }
-
-  kx122_enable_buffer(dev);
-  kx122_set_sensor_active(dev);
-
-  return UPM_SUCCESS;
-}
-
-upm_result_t kx122_set_buffer_resolution(const kx122_context dev, KX122_RES_T res)
-{
-  assert(dev != NULL);
-  dev->buffer_res = res;
-  kx122_map_grange(dev,dev->grange_mode);
-
-  if(res == HIGH_RES){
-    return kx122_set_bit_on(dev,KX122_BUF_CNTL2,KX122_BUF_CNTL2_BRES);
-  }
-  return kx122_set_bit_off(dev, KX122_BUF_CNTL2, KX122_BUF_CNTL2_BRES);
-}
-
-upm_result_t kx122_set_buffer_threshold(const kx122_context dev, uint samples)
-{
-  assert(dev != NULL);
-  if(dev->buffer_res == LOW_RES && samples > MAX_BUFFER_SAMPLES_LOW_RES){
-    samples = MAX_BUFFER_SAMPLES_LOW_RES;
-  }
-  else if(dev->buffer_res == HIGH_RES && samples > MAX_BUFFER_SAMPLES_HIGH_RES){
-    samples = MAX_BUFFER_SAMPLES_HIGH_RES;
-  }
-
-  uint16_t bits = (uint16_t)samples;
-
-  uint8_t temp = (uint8_t) (bits & 0x00FF);//Get first 8 bits and set them to BUF_CNTL1
-
-  if(kx122_write_register(dev,KX122_BUF_CNTL1,temp) != UPM_SUCCESS){
-    return UPM_ERROR_OPERATION_FAILED;
-  }
-
-  temp = (uint8_t)((bits & 0x0300) >> 6); //Get last 2 bits and set them to BUF_CNTL2
-
-  return kx122_set_bit_pattern(dev,KX122_BUF_CNTL2,temp,KX122_BUF_CNTL2_SMP_TH8_9_MASK);
-}
-
-upm_result_t kx122_set_buffer_mode(const kx122_context dev, KX122_BUFFER_MODE_T mode)
-{
-  assert(dev != NULL);
-  dev->buffer_mode = mode;
-
-  return kx122_set_bit_pattern(dev,KX122_BUF_CNTL2,mode,KX122_BUF_CNTL2_BUF_M_MASK);
-}
-
-upm_result_t kx122_clear_buffer(const kx122_context dev)
-{
-  assert(dev != NULL);
-  return kx122_write_register(dev,KX122_BUF_CLEAR,0xFF); //Writing anything to the register clears the buffer
-}
-
-upm_result_t kx122_get_buffer_status(const kx122_context dev, uint *samples)
-{
-  uint8_t reg_val;
-  uint16_t temp; //Using only 10 bits
-
-  if(kx122_read_register(dev,KX122_BUF_STATUS_2,&reg_val) != UPM_SUCCESS){
-    return UPM_ERROR_OPERATION_FAILED;
-  }
-
-  temp = (reg_val & 0x0007) << 8; //Get 3 MSb from BUF_STATUS 2
-
-  if(kx122_read_register(dev,KX122_BUF_STATUS_1, &reg_val) != UPM_SUCCESS){
-    return UPM_ERROR_OPERATION_FAILED;
-  }
-
-  temp = (temp + (reg_val & 0x00FF)); //Get rest of the bits from BUF_STATUS 1
-
-  //Get the amount of samples
-  if(dev->buffer_res == LOW_RES){
-    //3 axis / sample
-    *samples = ((uint)(int16_t)temp) / 3;
-  }
-  else{
-    //3 axis * MSB/LSB / sample
-    *samples = ((uint)(int16_t)temp) / 6;
-  }
-
-  return UPM_SUCCESS;
-}
-
-upm_result_t kx122_read_buffer_samples_raw(const kx122_context dev, uint len, float *x_array, float *y_array, float *z_array)
-{
-  assert(dev != NULL);
-  if(dev->buffer_res == LOW_RES){
-    len *= LOW_RES_SAMPLE_MODIFIER; //3 axis / sample
-  }
-  else{
-    len *= HIGH_RES_SAMPLE_MODIFIER; //3 axis * 2 bytes / sample
-  }
-
-  uint8_t buffer[len];
-
-  if(kx122_read_registers(dev,KX122_BUF_READ,buffer,len) != UPM_SUCCESS){
-    return UPM_ERROR_OPERATION_FAILED;
-  }
-
-  if(dev->buffer_res == HIGH_RES){
-    for (size_t i = 0; i < len; i+= HIGH_RES_SAMPLE_MODIFIER) {
-      if(dev->buffer_mode != KX122_FILO_MODE){
-        if(x_array){
-          x_array[i / HIGH_RES_SAMPLE_MODIFIER] = (float)((int16_t) (buffer[i + 1] << 8) | buffer[i]);
-        }
-        if(y_array){
-          y_array[i / HIGH_RES_SAMPLE_MODIFIER] = (float)((int16_t) (buffer[i + 3] << 8) | buffer[i + 2]);
-        }
-        if(z_array){
-          z_array[i / HIGH_RES_SAMPLE_MODIFIER] = (float)((int16_t) (buffer[i + 5] << 8) | buffer[i + 4]);
-        }
-      }
-      else{
-        if(x_array){
-          x_array[i / HIGH_RES_SAMPLE_MODIFIER] = (float)((int16_t) (buffer[i + 4] << 8) | buffer[i + 5]);
-        }
-        if(y_array){
-          y_array[i / HIGH_RES_SAMPLE_MODIFIER] = (float)((int16_t) (buffer[i + 2] << 8) | buffer[i + 3]);
-        }
-        if(z_array){
-          z_array[i / HIGH_RES_SAMPLE_MODIFIER] = (float)((int16_t) (buffer[i] << 8) | buffer[i + 1]);
-        }
-      }
-    }
-  }
-  else{ //Low resolution
-    for (size_t i = 0; i < len; i+= LOW_RES_SAMPLE_MODIFIER) {
-      if(dev->buffer_mode != KX122_FILO_MODE){
-        if(x_array){
-          x_array[i / LOW_RES_SAMPLE_MODIFIER] = (float)(int8_t)buffer[i];
-        }
-        if(y_array){
-          y_array[i / LOW_RES_SAMPLE_MODIFIER] = (float)(int8_t)buffer[i + 1];
-        }
-        if(z_array){
-          z_array[i / LOW_RES_SAMPLE_MODIFIER] = (float)(int8_t)buffer[i + 2];
-        }
-      }
-      else{
-        if(x_array){
-          x_array[i / LOW_RES_SAMPLE_MODIFIER] = (float)(int8_t)buffer[i + 2];
-        }
-        if(y_array){
-          y_array[i / LOW_RES_SAMPLE_MODIFIER] = (float)(int8_t)buffer[i + 1];
-        }
-        if(z_array){
-          z_array[i / LOW_RES_SAMPLE_MODIFIER] = (float)(int8_t)buffer[i];
-        }
-      }
-    }
-  }
-
-  return UPM_SUCCESS;
-}
-
-upm_result_t kx122_read_buffer_samples(const kx122_context dev, uint len, float *x_array, float *y_array, float *z_array)
-{
-  assert(dev != NULL);
-  if(kx122_read_buffer_samples_raw(dev,len,x_array,y_array,z_array) != UPM_SUCCESS){
-    return UPM_ERROR_OPERATION_FAILED;
-  }
-
-  for (size_t i = 0; i < len; i++) {
-    if(x_array){
-      x_array[i] = (x_array[i] * dev->buffer_accel_scale) * GRAVITY;
-    }
-    if(y_array){
-      y_array[i] = (y_array[i] * dev->buffer_accel_scale) * GRAVITY;
-    }
-    if(z_array){
-      z_array[i] = (z_array[i] * dev->buffer_accel_scale) * GRAVITY;
-    }
-  }
-
-  return UPM_SUCCESS;
-}
diff --git a/src/kx122/kx122.cxx b/src/kx122/kx122.cxx
deleted file mode 100644
index a3550f5..0000000
--- a/src/kx122/kx122.cxx
+++ /dev/null
@@ -1,369 +0,0 @@
-/*
-* The MIT License (MIT)
-*
-* Author: Samuli Rissanen <samuli.rissanen@hotmail.com>
-* Copyright (c) 2018 Rohm Semiconductor.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy of
-* this software and associated documentation files (the "Software"), to deal in
-* the Software without restriction, including without limitation the rights to
-* use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-* the Software, and to permit persons to whom the Software is furnished to do so,
-* subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in all
-* copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-* COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-#include <iostream>
-#include <stdexcept>
-#include <string>
-
-#include <unistd.h>
-
-#include "kx122.hpp"
-
-using namespace upm;
-
-KX122::KX122(int bus, int addr, int chip_select, int spi_bus_frequency)
-  : m_kx122(kx122_init(bus, addr, chip_select, spi_bus_frequency))
-{
-  if(!m_kx122){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_init() failed");
-  }
-}
-
-KX122::~KX122()
-{
-  kx122_close(m_kx122);
-}
-
-void KX122::deviceInit(KX122_ODR_T odr, KX122_RES_T res, KX122_RANGE_T grange)
-{
-  if(kx122_device_init(m_kx122,odr,res,grange)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_device_init() failed");
-  }
-}
-
-float KX122::getSamplePeriod()
-{
-  return kx122_get_sample_period(m_kx122);
-}
-
-uint8_t KX122::getWhoAmI()
-{
-  uint8_t data;
-
-  if(kx122_get_who_am_i(m_kx122, &data)){
-	throw std::runtime_error(std::string(__FUNCTION__) + "kx122_get_who_am_i failed");
-  }
-
-  return data;
-}
-void KX122::getRawAccelerationData(float *x, float *y, float *z)
-{
-  if(kx122_get_acceleration_data_raw(m_kx122,x,y,z)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_get_accleration_data_raw failed");
-  }
-}
-
-void KX122::getAccelerationData(float *x, float *y, float *z)
-{
-  if(kx122_get_acceleration_data(m_kx122,x,y,z)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_get_acceleration_data failed");
-  }
-}
-
-std::vector<float> KX122::getAccelerationDataVector()
-{
-    std::vector<float> xyz(3);
-    getAccelerationData(&xyz[0], &xyz[1], &xyz[2]);
-
-    return xyz;
-}
-
-void KX122::softwareReset()
-{
-  if(kx122_sensor_software_reset(m_kx122)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_sensor_software_reset failed");
-  }
-}
-
-void KX122::enableIIR()
-{
-  if(kx122_enable_iir(m_kx122)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_enable_iir failed");
-  }
-}
-
-void KX122::disableIIR()
-{
-  if(kx122_disable_iir(m_kx122)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_disable_iir failed");
-  }
-}
-
-void KX122::selfTest()
-{
-  if(kx122_self_test(m_kx122)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_self_test failed");
-  }
-}
-
-void KX122::setSensorStandby()
-{
-  if(kx122_set_sensor_standby(m_kx122)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_set_sensor_standby failed");
-  }
-}
-
-void KX122::setSensorActive()
-{
-  if(kx122_set_sensor_active(m_kx122)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_set_sensor_active failed");
-  }
-}
-
-void KX122::setODR(KX122_ODR_T odr)
-{
-  if(kx122_set_odr(m_kx122,odr)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_set_odr failed");
-  }
-}
-
-void KX122::setGrange(KX122_RANGE_T grange)
-{
-  if(kx122_set_grange(m_kx122,grange)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_set_grange failed");
-  }
-}
-
-void KX122::setResolution(KX122_RES_T res)
-{
-  if(kx122_set_resolution(m_kx122,res)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_set_resolution failed");
-  }
-}
-
-void KX122::setBW(LPRO_STATE_T lpro)
-{
-  if(kx122_set_bw(m_kx122,lpro)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_set_bw failed");
-  }
-}
-
-void KX122::setAverage(KX122_AVG_T avg)
-{
-  if(kx122_set_average(m_kx122,avg)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_set_average failed");
-  }
-}
-
-void KX122::installISR(mraa::Edge edge, KX122_INTERRUPT_PIN_T intp, int pin, void(*isr)(void*),void *arg)
-{
-  if(kx122_install_isr(m_kx122,(mraa_gpio_edge_t)edge,intp,pin,isr,arg)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_install_isr failed");
-  }
-}
-
-void KX122::uninstallISR(KX122_INTERRUPT_PIN_T intp)
-{
-  kx122_uninstall_isr(m_kx122,intp);
-}
-
-void KX122::enableInterrupt1(KX122_INTERRUPT_POLARITY_T polarity)
-{
-  if(kx122_enable_interrupt1(m_kx122,polarity)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_enable_interrupt1 failed");
-  }
-}
-
-void KX122::enableInterrupt2(KX122_INTERRUPT_POLARITY_T polarity)
-{
-  if(kx122_enable_interrupt2(m_kx122,polarity)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_enable_interrupt2 failed");
-  }
-}
-
-void KX122::disableInterrupt1()
-{
-  if(kx122_disable_interrupt1(m_kx122)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_disable_interrupt1 failed");
-  }
-}
-
-void KX122::disableInterrupt2()
-{
-  if(kx122_disable_interrupt2(m_kx122)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_disable_interrupt2 failed");
-  }
-}
-
-void KX122::routeInterrupt1(uint8_t bits)
-{
-  if(kx122_route_interrupt1(m_kx122,bits)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_route_interrupt1 failed");
-  }
-}
-
-void KX122::routeInterrupt2(uint8_t bits)
-{
-  if(kx122_route_interrupt2(m_kx122,bits)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_route_interrupt2 failed");
-  }
-}
-
-bool KX122::getInterruptStatus()
-{
-  return kx122_get_interrupt_status(m_kx122);
-}
-
-uint8_t KX122::getInterruptSource()
-{
-  uint8_t data;
-  if(kx122_get_interrupt_source(m_kx122, &data)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_get_interrupt_source failed");
-  }
-
-  return data;
-}
-
-void KX122::clearInterrupt()
-{
-  if(kx122_clear_interrupt(m_kx122)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_clear_interrupt failed");
-  }
-}
-
-void KX122::enableDataReadyInterrupt()
-{
-  if(kx122_enable_data_ready_interrupt(m_kx122)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_enable_data_ready_interrupt failed");
-  }
-}
-
-void KX122::disableDataReadyInterrupt()
-{
-  if(kx122_disable_data_ready_interrupt(m_kx122)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_disable_data_ready_interrupt failed");
-  }
-}
-
-void KX122::enableBufferFullInterrupt()
-{
-  if(kx122_enable_buffer_full_interrupt(m_kx122)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_enable_buffer_full_interrupt failed");
-  }
-}
-
-void KX122::disableBufferFullInterrupt()
-{
-  if(kx122_disable_buffer_full_interrupt(m_kx122)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_disable_buffer_full_interrupt failed");
-  }
-}
-
-void KX122::enableBuffer()
-{
-  if(kx122_enable_buffer(m_kx122)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_enable_buffer failed");
-  }
-}
-
-void KX122::disableBuffer()
-{
-  if(kx122_disable_buffer(m_kx122)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_disable_buffer failed");
-  }
-}
-
-void KX122::bufferInit(uint samples, KX122_RES_T res, KX122_BUFFER_MODE_T mode)
-{
-  if(kx122_buffer_init(m_kx122,samples,res,mode)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_buffer_init failed");
-  }
-}
-
-void KX122::setBufferResolution(KX122_RES_T res)
-{
-  if(kx122_set_buffer_resolution(m_kx122,res)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_set_buffer_resolution failed");
-  }
-}
-
-void KX122::setBufferThreshold(uint samples)
-{
-  if(kx122_set_buffer_threshold(m_kx122,samples)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_set_buffer_threshold failed");
-  }
-}
-
-void KX122::setBufferMode(KX122_BUFFER_MODE_T mode)
-{
-  if(kx122_set_buffer_mode(m_kx122,mode)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_set_buffer_mode failed");
-  }
-}
-
-uint KX122::getBufferStatus()
-{
-  uint nb_samples = 0;
-  if(kx122_get_buffer_status(m_kx122, &nb_samples)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_get_buffer_status failed");
-  }
-
-  return nb_samples;
-}
-
-//Maximum number of samples that can be stored in the buffer of the KX122
-#define MAX_SAMPLES_IN_BUFFER 681
-
-std::vector<float> KX122::getRawBufferSamples(uint len)
-{
-  float bufferx[MAX_SAMPLES_IN_BUFFER], buffery[MAX_SAMPLES_IN_BUFFER], bufferz[MAX_SAMPLES_IN_BUFFER];
-  if(kx122_read_buffer_samples_raw(m_kx122,len,bufferx,buffery,bufferz)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_read_buffer_samples_raw failed");
-  }
-
-  std::vector<float> xyz_array(len * 3);
-  for (uint i = 0; i < len; i++)
-  {
-	  xyz_array[i * 3 + 0] = bufferx[i];
-	  xyz_array[i * 3 + 1] = buffery[i];
-	  xyz_array[i * 3 + 2] = bufferz[i];
-  }
-
-  return xyz_array;
-}
-
-std::vector<float> KX122::getBufferSamples(uint len)
-{
-  float bufferx[MAX_SAMPLES_IN_BUFFER], buffery[MAX_SAMPLES_IN_BUFFER], bufferz[MAX_SAMPLES_IN_BUFFER];
-  if(kx122_read_buffer_samples(m_kx122,len,bufferx,buffery,bufferz)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_read_buffer_samples failed");
-  }
-
-  std::vector<float> xyz_array(len * 3);
-  for (uint i = 0; i < len; i++)
-  {
-	  xyz_array[i * 3 + 0] = bufferx[i];
-	  xyz_array[i * 3 + 1] = buffery[i];
-	  xyz_array[i * 3 + 2] = bufferz[i];
-  }
-
-  return xyz_array;
-}
-
-void KX122::clearBuffer()
-{
-  if(kx122_clear_buffer(m_kx122)){
-    throw std::runtime_error(std::string(__FUNCTION__) + "kx122_clear_buffer failed");
-  }
-}
diff --git a/src/kx122/kx122.h b/src/kx122/kx122.h
deleted file mode 100644
index 56e5215..0000000
--- a/src/kx122/kx122.h
+++ /dev/null
@@ -1,675 +0,0 @@
-/*
-* The MIT License (MIT)
-*
-* Author: Samuli Rissanen <samuli.rissanen@hotmail.com>
-* Copyright (c) 2018 Rohm Semiconductor.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy of
-* this software and associated documentation files (the "Software"), to deal in
-* the Software without restriction, including without limitation the rights to
-* use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-* the Software, and to permit persons to whom the Software is furnished to do so,
-* subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in all
-* copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-* COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-#pragma once
-
-#ifdef __cplusplus
-extern "C"{
-#endif
-
-#include <assert.h>
-#include <unistd.h>
-#include <math.h>
-#include <sys/types.h>
-
-#include <mraa/i2c.h>
-#include <mraa/spi.h>
-#include <mraa/gpio.h>
-
-#include <upm.h>
-
-#include "kx122_registers.h"
-
-/**
- * @file kx122.h
- * @library kx122
- * @brief C API for the kx122 driver
- *
- * @include kx122.c
- */
-
-//Frequency of the SPI connection
-#define DEFAULT_SPI_FREQUENCY 10000
-
-//Default slave addresses for the sensor
-#define KX122_DEFAULT_SLAVE_ADDR_1 0x1F
-#define KX122_DEFAULT_SLAVE_ADDR_2 0x1E
-
-//Microseconds in a second
-#define MICRO_S 1000000
-
-//Sensor ODR values
-typedef enum{
-  KX122_ODR_12P5 = KX122_ODCNTL_OSA_12P5,
-  KX122_ODR_25 = KX122_ODCNTL_OSA_25,
-  KX122_ODR_50 = KX122_ODCNTL_OSA_50,
-  KX122_ODR_100 = KX122_ODCNTL_OSA_100,
-  KX122_ODR_200 = KX122_ODCNTL_OSA_200,
-  KX122_ODR_400 = KX122_ODCNTL_OSA_400,
-  KX122_ODR_800 = KX122_ODCNTL_OSA_800,
-  KX122_ODR_1600 = KX122_ODCNTL_OSA_1600,
-  KX122_ODR_0P781 = KX122_ODCNTL_OSA_0P781,
-  KX122_ODR_1P563 = KX122_ODCNTL_OSA_1P563,
-  KX122_ODR_3P125 = KX122_ODCNTL_OSA_3P125,
-  KX122_ODR_6P25 = KX122_ODCNTL_OSA_6P25,
-  KX122_ODR_3200 = KX122_ODCNTL_OSA_3200,
-  KX122_ODR_6400 = KX122_ODCNTL_OSA_6400,
-  KX122_ODR_12800 = KX122_ODCNTL_OSA_12800,
-  KX122_ODR_25600 = KX122_ODCNTL_OSA_25600
-} KX122_ODR_T;
-
-//Sensor average values
-typedef enum{
-  KX122_NO_AVG = KX122_LP_CNTL_AVC_NO_AVG,
-  KX122_2_SAMPLE_AVG = KX122_LP_CNTL_AVC_2_SAMPLE_AVG,
-  KX122_4_SAMPLE_AVG = KX122_LP_CNTL_AVC_4_SAMPLE_AVG,
-  KX122_8_SAMPLE_AVG = KX122_LP_CNTL_AVC_8_SAMPLE_AVG,
-  KX122_16_SAMPLE_AVG = KX122_LP_CNTL_AVC_16_SAMPLE_AVG,
-  KX122_32_SAMPLE_AVG = KX122_LP_CNTL_AVC_32_SAMPLE_AVG,
-  KX122_64_SAMPLE_AVG = KX122_LP_CNTL_AVC_64_SAMPLE_AVG,
-  KX122_128_SAMPLE_AVG = KX122_LP_CNTL_AVC_128_SAMPLE_AVG
-} KX122_AVG_T;
-
-//Sensor range values
-typedef enum{
-  KX122_RANGE_2G = KX122_CNTL1_GSEL_2G,
-  KX122_RANGE_4G = KX122_CNTL1_GSEL_4G,
-  KX122_RANGE_8G = KX122_CNTL1_GSEL_8G
-} KX122_RANGE_T;
-
-//Sensor buffer modes
-typedef enum{
-  KX122_FIFO_MODE = KX122_BUF_CNTL2_BUF_M_FIFO,
-  KX122_FILO_MODE = KX122_BUF_CNTL2_BUF_M_FILO,
-  KX122_STREAM_MODE = KX122_BUF_CNTL2_BUF_M_STREAM,
-} KX122_BUFFER_MODE_T;
-
-//Sensor interrupt types
-typedef enum{
-  KX122_BUF_FULL_INT = KX122_INC4_BFI1,
-  KX122_WATERMARK_INT = KX122_INC4_WMI1,
-  KX122_DATA_READY_INT = KX122_INC4_DRDYI1
-} KX122_INTERRUPT_T;
-
-//High and low resolution modes
-typedef enum{
-  HIGH_RES,
-  LOW_RES
-} KX122_RES_T;
-
-//Sensor low-pass filter roll of values
-typedef enum{
-  ODR_9,
-  ODR_2
-} LPRO_STATE_T;
-
-//Interrupt pins
-typedef enum{
-  INT1,
-  INT2
-}KX122_INTERRUPT_PIN_T;
-
-//Interrupt polarity
-typedef enum{
-  ACTIVE_LOW,
-  ACTIVE_HIGH
-} KX122_INTERRUPT_POLARITY_T;
-
-//Device context
-typedef struct _kx122_context {
-  mraa_i2c_context i2c;
-  mraa_spi_context spi;
-  mraa_gpio_context gpio1; //Interrupt pin 1
-  mraa_gpio_context gpio2; //Interrupt pin 2
-  mraa_gpio_context chip_select; //Chip select pin (SPI)
-
-  float accel_scale; //Acceleration scaling
-  KX122_RES_T res_mode; //Sensor resolution
-  KX122_RANGE_T grange_mode; //Sensor range
-
-  float buffer_accel_scale; //Buffer acceleration scaling
-  KX122_BUFFER_MODE_T buffer_mode; //Buffer mode
-  KX122_RES_T buffer_res; //Buffer resolution
-
-  bool using_spi;
-
-} *kx122_context;
-
-//Struct for ODR values and their decimal counterparts.
-typedef struct _odr_item{
-  uint8_t odr_value;
-  float odr_decimal;
-} odr_item;
-
-/**
-KX122 initialization
-
-Set addr to -1 if using SPI.
-When using I2C, set chip_select_pin to -1;
-
-If no errors occur, the device gets initialized with default values and gets set to active state.
-
-@param bus I2C or SPI bus to use.
-@param addr I2C address of the sensor.
-@param chip_select Chip select pin for SPI.
-@param spi_bus_frequency Speed of the SPI communication bus in Hz (ignored when using I2C).
-@return The device context, or NULL if an error occurs.
-*/
-kx122_context kx122_init(int bus, int addr, int chip_select_pin, int spi_bus_frequency);
-
-/**
-KX122 destructor
-Closes the I2C or SPI context, and removes interrupts.
-Frees memory of the kx122_context.
-
-@param dev The device context.
-*/
-void kx122_close(kx122_context dev);
-
-
-/**
-Intilializes the sensor with the given sampling rate, resolution and acceleration range.
-
-This gets called during the kx122_init(), so it will not need to be called unless the device is reset.
-
-Sensor is automatically set into standby mode during the initialization.
-Sensor is set to active mode after initialization.
-
-@param dev The device context.
-@param odr One of the KX122_ODR_T values.
-@param res One of the KX122_RES_T values.
-@param grange One of the KX122_RANGE_T values.
-@return UPM result.
-*/
-upm_result_t kx122_device_init(const kx122_context dev, KX122_ODR_T odr, KX122_RES_T res, KX122_RANGE_T grange);
-
-/**
-Gets the length of one sample period depending on the sampling rate of the sensor.
-
-@param dev The device context.
-@return Floating point value of the sampling period, or if an error occurs returns -1.
-*/
-float kx122_get_sample_period(const kx122_context dev);
-
-/**
-Gets who am i value of the sensor.
-
-@param dev The device context.
-@param data Pointer to a uint8_t variable to store the value.
-@return UPM result.
-*/
-upm_result_t kx122_get_who_am_i(const kx122_context dev, uint8_t *data);
-
-/**
-Gets raw accelerometer data from the sensor.
-
-@param dev The device context.
-@param x Pointer to a floating point variable to store the x-axis value. Can be set to NULL if not wanted.
-@param y Pointer to a floating point variable to store the y-axis value. Can be set to NULL if not wanted.
-@param z Pointer to a floating point variable to store the z-axis value. Can be set to NULL if not wanted.
-@return UPM result.
-*/
-upm_result_t kx122_get_acceleration_data_raw(const kx122_context dev, float *x, float *y, float *z);
-
-/**
-Gets converted (m/s^2) accelerometer data from the sensor.
-
-@param dev The device context.
-@param x Pointer to a floating point variable to store the x-axis value. Can be set to NULL if not wanted.
-@param y Pointer to a floating point variable to store the y-axis value. Can be set to NULL if not wanted.
-@param z Pointer to a floating point variable to store the z-axis value. Can be set to NULL if not wanted.
-*/
-upm_result_t kx122_get_acceleration_data(const kx122_context dev, float *x, float *y, float *z);
-
-/**
-Performs a sensor software reset. The software reset clears the RAM of the sensor and resets all registers
-to pre-defined values.
-
-You should call kx122_device_init() after the software reset.
-
-See the datasheet for more details.
-
-@param dev The device context.
-@return UPM result.
-*/
-upm_result_t kx122_sensor_software_reset(const kx122_context dev);
-
-/**
-Enables sensor filter bypass.
-
-Sensor needs to be in standby mode when enabling the filter bypass.
-
-@param dev The device context.
-@return UPM result.
-*/
-upm_result_t kx122_enable_iir(const kx122_context dev);
-
-/**
-Disables sensor filter bypass.
-
-Sensor needs to be in standby mode when disabling the filter bypass.
-
-@param dev The device context.
-@return UPM result.
-*/
-upm_result_t kx122_disable_iir(const kx122_context dev);
-
-/**
-Performs a self-test of the sensor. The test applies an electrostatic force to the sensor,
-simulating input acceleration. The test compares samples from all axis before and after
-applying the electrostatic force to the sensor. If the amount of acceleration increases according
-to the values defined in TABLE 1 of the datasheet, the test passes.
-
-The function prints out the minimum, maximum and values calculated during the test
-for each axis, and the result of the test for each axis.
-
-See the datasheet for more information.
-
-@param dev The device context.
-@return UPM result.
-*/
-upm_result_t kx122_self_test(const kx122_context dev);
-
-/**
-Sets the sensor to the standby mode.
-
-@param dev The device context.
-@return UPM result.
-*/
-upm_result_t kx122_set_sensor_standby(const kx122_context dev);
-
-/**
-Sets the sensor to active mode.
-
-@param dev The device context.
-@return UPM result.
-*/
-upm_result_t kx122_set_sensor_active(const kx122_context dev);
-
-/**
-Sets the ODR of the sensor.
-
-Sensor needs to be in standby mode when setting the ODR.
-
-@param dev The device context.
-@param odr One of the KX122_ODR_T values.
-@return UPM result.
-*/
-upm_result_t kx122_set_odr(const kx122_context dev, KX122_ODR_T odr);
-
-/**
-Sets the acceleration range of the sensor.
-
-Sensor needs to be in standby mode when setting the acceleration range value.
-
-@param dev The device context.
-@param grange One of the KX122_RANGE_T values.
-@return UPM result.
-*/
-upm_result_t kx122_set_grange(const kx122_context dev, KX122_RANGE_T grange);
-
-/**
-Sets the resolution of the sensor. High resolution (16 bits) or low resolution (8 bits).
-
-Sensor needs to be in standby mode when setting the sensor resolution.
-
-When sensor is set to low resolution mode, the sensor runs in low power mode, which in turn
-enables features such as averaging.(kx122_set_average()).
-
-@param dev The device context.
-@param res One of the KX122_RES_T values.
-@return UPM result.
-*/
-upm_result_t kx122_set_resolution(const kx122_context dev, KX122_RES_T res);
-
-/**
-Sets the low pass filter roll off
-
-Sensor needs to be in standby mode when setting the filter roll off value.
-
-@param dev The device context.
-@param lpro One of the LPRO_STATE_T values.
-@return UPM result.
-*/
-upm_result_t kx122_set_bw(const kx122_context dev, LPRO_STATE_T lpro);
-
-/**
-Set the amount of samples to be averaged in low power mode.
-
-Sensor needs to be in standby mode when setting the average value.
-
-@param dev The device context.
-@param avg One of the KX122_AVG_T values.
-@return UPM result.
-*/
-upm_result_t kx122_set_average(const kx122_context dev, KX122_AVG_T avg);
-
-/**
-Installs an interrupt handler to be executed when an interrupt is detected on the interrupt pin.
-
-@param dev The device context.
-@param edge One of the mraa_gpio_edge_t values. Interrupt trigger edge.
-@param intp One of the KX122_INTERRUPT_PIN_T values. Specifies which interrupt pin you are setting.
-@param pin The GPIO pin to use as the interrupt pin.
-@param isr Pointer to the function to be called, when the interrupt occurs.
-@param arg The arguments to be passed to the function.
-@return UPM result.
-*/
-upm_result_t kx122_install_isr(const kx122_context dev, mraa_gpio_edge_t edge,KX122_INTERRUPT_PIN_T intp, int pin,void (*isr)(void *), void *arg);
-
-/**
-Uninstalls a previously installed interrupt handler.
-
-@param dev The device context.
-@param intp One of the KX122_INTERRUPT_PIN_T values. Specifies which interrupt pin handler is uninstalled.
-*/
-void kx122_uninstall_isr(const kx122_context dev, KX122_INTERRUPT_PIN_T intp);
-
-/**
-Enables interrupts on the interrupt pin 1 of the sensor.
-
-Pulse width = 50us (10us if data sampling rate > 1600Hz).
-Using pulse mode.
-
-Sensor needs to be in standby mode when enabling the interrupt.
-
-See datasheet for more details.
-
-@param dev The device context.
-@param polarity One of the KX122_INTERRUPT_POLARITY_T values. Select the polarity of the interrupt.
-@return UPM result.
-*/
-upm_result_t kx122_enable_interrupt1(const kx122_context dev, KX122_INTERRUPT_POLARITY_T polarity);
-
-/**
-Enables interrupts on the interrupt pin 2 of the sensor.
-
-Pulse width = 50us (10us if data sampling rate > 1600Hz).
-Using pulse mode.
-
-Sensor needs to be in standby mode when enabling the interrupt.
-
-See datasheet for more details.
-
-@param dev The device context.
-@param polarity One of the KX122_INTERRUPT_POLARITY_T values. Select the polarity of the interrupt.
-@return UPM result.
-*/
-upm_result_t kx122_enable_interrupt2(const kx122_context dev, KX122_INTERRUPT_POLARITY_T polarity);
-
-/**
-Disables interrupts on the interrupt pin 1 of the sensor.
-
-Sensor needs to be in standby mode when disabling the interrupt pin 1.
-
-@param dev The device context.
-@return UPM result.
-*/
-upm_result_t kx122_disable_interrupt1(const kx122_context dev);
-
-/**
-Disables interrupts on the interrupt pin 2 of the sensor.
-
-Sensor needs to be in standby mode when disabling the interrupt pin 2.
-
-@param dev The device context.
-@return UPM result.
-*/
-upm_result_t kx122_disable_interrupt2(const kx122_context dev);
-
-/**
-Routes the interrupts to the interrupt pin 1 of the sensor.
-
-Sensor needs to be in standby mode when routing the interrupts.
-
-See datasheet for more details.
-
-@param dev The device context.
-@param bits One or more of the KX122_INTERRUPT_T values. Combine with bitwise OR (|)
-@return UPM result.
-*/
-upm_result_t kx122_route_interrupt1(const kx122_context dev, uint8_t bits);
-
-/**
-Routes the interrupts to the interrupt pin 2 of the sensor.
-
-Sensor needs to be in standby mode when routing the interrupts.
-
-See datasheet for more details.
-
-@param dev The device context.
-@param bits One or more of the KX122_INTERRUPT_T values. Combine with bitwise OR (|)
-@return UPM result.
-*/
-upm_result_t kx122_route_interrupt2(const kx122_context dev, uint8_t bits);
-
-/**
-Gets the status of the interrupts. (Has an interrupt occured)
-
-See datasheet for more details.
-
-@param dev The device context.
-@return Return true if an interrupt event has occured, returns false if no interrupts have occured.
-*/
-bool kx122_get_interrupt_status(const kx122_context dev);
-
-/**
-Gets the source of the interrupt.
-The value stored is one or more of the KX122_INTERRUPT_T values, depending on the interrupts
-that have occured.
-
-If multiple interrupts have occured, and you need to determine a specific interrupt,
-you can use masking to get the state of the specific interrupt:
-(int_source & KX122_DATA_READY_INT) == KX122_DATA_READY_INT)
-
-See datasheet for more details.
-
-@param dev The device context.
-@param data Pointer to a uint8_t variable to store the value.
-@return UPM result.
-*/
-upm_result_t kx122_get_interrupt_source(const kx122_context dev, uint8_t *data);
-
-/**
-Clears latching interrupts (Wakeup, Data Ready).
-
-See datasheet for more details.
-
-@param dev The device context.
-@return UPM result.
-*/
-upm_result_t kx122_clear_interrupt(const kx122_context dev);
-
-/**
-Enables the data ready interrupt. Availability of new acceleration data is
-reflected as an interrupt.
-
-Sensor needs to be in standby mode when enabling the interrupt.
-
-@param dev The device context.
-@return UPM result.
-*/
-upm_result_t kx122_enable_data_ready_interrupt(const kx122_context dev);
-
-/**
-Disables the data ready interrupt.
-
-Sensor needs to be in standby mode when disabling the interrupt.
-
-@param dev The device context.
-@return UPM result.
-*/
-upm_result_t kx122_disable_data_ready_interrupt(const kx122_context dev);
-
-/**
-Enables the buffer full interrupt.
-Buffer can hold 681 sets of values (8 bit, low resolution mode) or
-340 sets of values (16 bit, high resolution mode).
-
-Sensor needs to be in standby mode when enabling the interrupt.
-
-@param dev The device context.
-@return UPM result.
-*/
-upm_result_t kx122_enable_buffer_full_interrupt(const kx122_context dev);
-
-/**
-Disables the buffer full interrupt.
-
-Sensor needs to be in standby mode when disabling the interrupt.
-
-@param dev The device context.
-@return UPM result.
-*/
-upm_result_t kx122_disable_buffer_full_interrupt(const kx122_context dev);
-
-/**
-Enables the buffer.
-
-Sensor needs to be in standby mode when enabling the buffer.
-
-@param dev The device context.
-@return UPM result.
-*/
-upm_result_t kx122_enable_buffer(const kx122_context dev);
-
-/**
-Disables the buffer.
-
-Sensor needs to be in standby mode when disabling the buffer.
-
-@param dev The device context.
-@return UPM result.
-*/
-upm_result_t kx122_disable_buffer(const kx122_context dev);
-
-/**
-Initializes the buffer with the given sample watermark level, buffer resolution and buffer operating mode.
-Buffer is enabled after the initialization.
-
-Sensor is automatically set into standby mode during the buffer initialization.
-Sensor is set to active mode after initialization.
-
-See the other buffer functions for details about the different parameter values.
-
-@param dev The device context.
-@param samples Amount of samples to trigger the watermark interrupt.
-@param res One of the KX122_RES_T values.
-@param mode One of the KX122_BUFFER_MODE_T values.
-@return UPM result.
-*/
-upm_result_t kx122_buffer_init(const kx122_context dev, uint samples, KX122_RES_T res, KX122_BUFFER_MODE_T mode);
-
-/**
-Sets the buffer resolution.
-Buffer resolution is indepedent of the sensor resolution.
-
-Sensor needs to be in standby mode when setting the buffer resolution.
-
-@param dev The device context.
-@return UPM result.
-*/
-upm_result_t kx122_set_buffer_resolution(const kx122_context dev, KX122_RES_T res);
-
-/**
-Sets the buffer watermark interrupt threshold.
-When the buffer sample count reaches the watermark, watermark interrupt will be given.
-
-In low resolution mode, maxiumum number of samples is 681. In high resolution, the maximum
-number is 340.
-
-See datasheet for more details.
-
-Sensor needs to be in standby mode when setting the buffer threshold.
-
-@param dev The device context.
-@param samples Amount of samples to trigger the watermark interrupt.
-@return UPM result.
-*/
-upm_result_t kx122_set_buffer_threshold(const kx122_context dev, uint samples);
-
-/**
-Sets the buffer operating mode.
-The buffer can operate in FIFO,FILO or Stream mode.
-The buffer gathers data, reports data and interracts with the status indicators
-in a slightly different way depending on the operating mode.
-
-See datasheet for more details.
-
-Sensor needs to be in standby mode when setting the buffer mode.
-
-@param dev The device context.
-@param mode One of the KX122_BUFFER_MODE_T values.
-@return UPM result.
-*/
-upm_result_t kx122_set_buffer_mode(const kx122_context dev, KX122_BUFFER_MODE_T mode);
-
-/**
-Gets the current amount of samples in the buffer.
-
-@param dev The device context.
-@param samples Pointer to an uint variable to store the data.
-@return UPM result.
-*/
-upm_result_t kx122_get_buffer_status(const kx122_context dev, uint *samples);
-
-/**
-Gets the specified amount of raw acceleration samples from the buffer.
-
-Make sure the array size is atleast the amount of samples to be read.
-
-@param dev The device context.
-@param len The amount of samples to read from the buffer.
-@param x_array Pointer to an floating point array to store the x-axis data. Can be set to NULL if not wanted.
-@param y_array Pointer to an floating point array to store the y-axis data. Can be set to NULL if not wanted.
-@param z_array Pointer to an floating point array to store the z-axis data. Can be set to NULL if not wanted.
-@return UPM result.
-*/
-upm_result_t kx122_read_buffer_samples_raw(const kx122_context dev, uint len, float *x_array, float *y_array, float *z_array);
-
-/**
-Gets the specified amount of converted (m/s^2) acceleration samples from the buffer.
-
-Make sure the array size is atleast the amount of samples to be read.
-
-@param dev The device context.
-@param len The amount of samples to read from the buffer.
-@param x_array Pointer to an floating point array to store the x-axis data. Can be set to NULL if not wanted.
-@param y_array Pointer to an floating point array to store the y-axis data. Can be set to NULL if not wanted.
-@param z_array Pointer to an floating point array to store the z-axis data. Can be set to NULL if not wanted.
-@return UPM result.
-*/
-upm_result_t kx122_read_buffer_samples(const kx122_context dev, uint len, float *x_array, float *y_array, float *z_array);
-
-/**
-Clears the buffer, removing all existing samples from the buffer.
-
-@param dev The device context.
-@return UPM result.
-*/
-upm_result_t kx122_clear_buffer(const kx122_context dev);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/kx122/kx122.hpp b/src/kx122/kx122.hpp
deleted file mode 100644
index 5f08eb8..0000000
--- a/src/kx122/kx122.hpp
+++ /dev/null
@@ -1,513 +0,0 @@
-/*
-* The MIT License (MIT)
-*
-* Author: Samuli Rissanen <samuli.rissanen@hotmail.com>
-* Copyright (c) 2018 Rohm Semiconductor.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy of
-* this software and associated documentation files (the "Software"), to deal in
-* the Software without restriction, including without limitation the rights to
-* use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-* the Software, and to permit persons to whom the Software is furnished to do so,
-* subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in all
-* copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-* COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-#pragma once
-
-#include <vector>
-#include <mraa/gpio.hpp>
-
-#include "kx122.h"
-
-/**
- * @file kx122.hpp
- * @library kx122
- * @brief C++ API for the kx122 driver
- *
- * @include kx122.cxx
- */
-
-namespace upm{
-
-  class KX122{
-    public:
-
-      /**
-      KX122 constructor
-      Set addr to -1 if using SPI.
-      When using I2C, set chip_select_pin to -1
-
-      If no errors occur, the device gets initialized with default values and gets set to active state.
-
-      @param bus I2C or SPI bus to use.
-      @param addr I2C address of the sensor.
-      @param chip_select Chip select pin for SPI.
-      @param spi_bus_frequency Speed of the SPI communication bus in Hz.
-      @throws std::runtime_error on initialization failure.
-      */
-      KX122(int bus, int addr, int chip_select, int spi_bus_frequency = DEFAULT_SPI_FREQUENCY);
-
-      /**
-      KX122 destructor
-      */
-      ~KX122();
-
-      /**
-      Initializes the sensor with given sampling rate, resolution and acceleration range.
-      This gets called in the constructor, so it will not need to be called unless the device is reset.
-
-      Sensor is automatically set into standby mode during the initialization.
-      Sensor is set to active mode after initialization.
-
-      @param odr One of the KX122_ODR_T values.
-      @param res One of the KX122_RES_T values.
-      @param grange One of the KX122_RANGE_T values.
-      @throws std::runtime_error on failure.
-      */
-      void deviceInit(KX122_ODR_T odr, KX122_RES_T res, KX122_RANGE_T grange);
-
-      /**
-      Gets the length of one sample period depending on the sampling rate of the sensor.
-      @return Floating point value of the sampling period, or if error occurs returns -1.
-      */
-      float getSamplePeriod();
-
-      /**
-      Gets who am i value of the sensor.
-
-      @return Who am I value of the sensor.
-      @throws std::runtime_error on failure.
-      */
-      uint8_t getWhoAmI();
-
-      /**
-      Gets raw accelerometer data from the sensor.
-      @param x Pointer to a floating point variable to store the x-axis value. Can be set to NULL if not wanted.
-      @param y Pointer to a floating point variable to store the y-axis value. Can be set to NULL if not wanted.
-      @param z Pointer to a floating point variable to store the z-axis value. Can be set to NULL if not wanted.
-      @throws std::runtime_error on failure.
-      */
-      void getRawAccelerationData(float *x, float *y, float *z);
-
-      /**
-      Gets converted (m/s^2) accelerometer data from the sensor.
-
-      @param x Pointer to a floating point variable to store the x-axis value. Can be set to NULL if not wanted.
-      @param y Pointer to a floating point variable to store the y-axis value. Can be set to NULL if not wanted.
-      @param z Pointer to a floating point variable to store the z-axis value. Can be set to NULL if not wanted.
-      @throws std::runtime_error on failure.
-      */
-      void getAccelerationData(float *x, float *y, float *z);
-
-      /**
-      Gets converted (m/s^2) accelerometer data from the sensor.
-
-      @return Acceleration vector [X, Y, Z]
-      @throws std::runtime_error on failure.
-      */
-      std::vector<float> getAccelerationDataVector();
-
-      /**
-      Performs a sensor software reset. The software reset clears the RAM of the sensor and resets all registers
-      to pre-defined values.
-
-      You should call deviceInit() after the software reset.
-
-      See the datasheet for more details.
-
-      @throws std::runtime_error on failure.
-      */
-      void softwareReset();
-
-      /**
-      Enables sensor filter bypass.
-
-      Sensor needs to be in standby mode when enabling the filter bypass.
-
-      @throws std::runtime_error on failure.
-      */
-      void enableIIR();
-
-      /**
-      Disables sensor filter bypass.
-
-      Sensor needs to be in standby mode when enabling the filter bypass.
-
-      @throws std::runtime_error on failure.
-      */
-      void disableIIR();
-
-      /**
-      Performs a self-test of the sensor. The test applies an electrostatic force to the sensor,
-      simulating input acceleration. The test compares samples from all axis before and after
-      applying the electrostatic force to the sensor. If the amount of acceleration increases according
-      to the values defined in TABLE 1 of the datasheet, the test passes.
-
-      The function prints out the minimum, maximum and values calculated during the test
-      for each axis, and the result of the test for each axis.
-
-      See the datasheet for more information.
-
-      @throws std::runtime_error on failure.
-      */
-      void selfTest();
-
-      /**
-      Sets the sensor to the standby mode.
-
-      @throws std::runtime_error on failure.
-      */
-      void setSensorStandby();
-
-      /**
-      Sets the sensor to the active mode.
-
-      @throws std::runtime_error on failure.
-      */
-      void setSensorActive();
-
-      /**
-      Sets the ODR of the sensor.
-
-      Sensor needs to be in standby mode when setting the ODR.
-
-      @param odr One of the KX122_ODR_T values.
-      @throws std::runtime_error on failure.
-      */
-      void setODR(KX122_ODR_T odr);
-
-      /**
-      Sets the acceleration range of the sensor.
-
-      Sensor needs to be in standby mode when setting the acceleration range value.
-
-      @param grange One of the KX122_RANGE_T values.
-      @throws std::runtime_error on failure.
-      */
-      void setGrange(KX122_RANGE_T grange);
-
-      /**
-      Sets the resolution of the sensor. High resolution (16 bits) or low resolution (8 bits).
-
-      Sensor needs to be in standby mode when setting the sensor resolution.
-
-      When sensor is set to low resolution mode, the sensor runs in low power mode, which in turn
-      enables features such as averaging.(setAverage()).
-
-      @param res One of the KX122_RES_T values.
-      @throws std::runtime_error on failure.
-      */
-      void setResolution(KX122_RES_T res);
-
-      /**
-      Sets the low pass filter roll off
-
-      Sensor needs to be in standby mode when setting the filter roll off value.
-
-      @param lpro One of the LPRO_STATE_T values.
-      @throws std::runtime_error on failure.
-      */
-      void setBW(LPRO_STATE_T lpro);
-
-      /**
-      Set the amount of samples to be averaged in low power mode.
-
-      Sensor needs to be in standby mode when setting the average value.
-
-      @param avg One of the KX122_AVG_T values.
-      @throws std::runtime_error on failure.
-      */
-      void setAverage(KX122_AVG_T avg);
-
-      /**
-      Installs an interrupt handler to be executed when an interrupt is detected on the interrupt pin.
-
-      @param edge One of the mraa::Edge values. Interrupt trigger edge.
-      @param intp One of the KX122_INTERRUPT_PIN_T values. Specifies which interrupt pin you are setting.
-      @param pin The GPIO pin to use as the interrupt pin.
-      @param isr Pointer to the function to be called, when the interrupt occurs.
-      @param arg The arguments to be passed to the function.
-      @throws std::runtime_error on failure.
-      */
-      void installISR(mraa::Edge edge, KX122_INTERRUPT_PIN_T intp, int pin, void (*isr)(void*), void *arg);
-
-      /**
-      Uninstalls a previously installed interrupt handler.
-
-      @param intp One of the KX122_INTERRUPT_PIN_T values. Specifies which interrupt pin handler is uninstalled.
-      @throws std::runtime_error on failure.
-      */
-      void uninstallISR(KX122_INTERRUPT_PIN_T intp);
-
-      /**
-      Enables interrupts on the interrupt pin 1 of the sensor.
-
-      Pulse width = 50us (10us if data sampling rate > 1600Hz).
-      Using pulse mode.
-
-      Sensor needs to be in standby mode when enabling the interrupt.
-
-      See datasheet for more details.
-
-      @param polarity One of the KX122_INTERRUPT_POLARITY_T values. Select the polarity of the interrupt.
-      @throws std::runtime_error on failure.
-      */
-      void enableInterrupt1(KX122_INTERRUPT_POLARITY_T polarity);
-
-      /**
-      Enables interrupts on the interrupt pin 2 of the sensor.
-
-      Pulse width = 50us (10us if data sampling rate > 1600Hz).
-      Using pulse mode.
-
-      Sensor needs to be in standby mode when enabling the interrupt.
-
-      See datasheet for more details.
-
-      @param polarity One of the KX122_INTERRUPT_POLARITY_T values. Select the polarity of the interrupt.
-      @throws std::runtime_error on failure.
-      */
-      void enableInterrupt2(KX122_INTERRUPT_POLARITY_T polarity);
-
-      /**
-      Disables interrupts on the interrupt pin 1 of the sensor.
-
-      Sensor needs to be in standby mode when disabling the interrupt pin 1.
-
-      @throws std::runtime_error on failure.
-      */
-      void disableInterrupt1();
-
-      /**
-      Disables interrupts on the interrupt pin 2 of the sensor.
-
-      Sensor needs to be in standby mode when disabling the interrupt pin 2.
-
-      @throws std::runtime_error on failure.
-      */
-      void disableInterrupt2();
-
-      /**
-      Routes the interrupts to the interrupt pin 1 of the sensor.
-
-      Sensor needs to be in standby mode when routing the interrupts.
-
-      See datasheet for more details.
-
-      @param bits One or more of the KX122_INTERRUPT_T values. Combine with bitwise OR (|)
-      @throws std::runtime_error on failure.
-      */
-      void routeInterrupt1(uint8_t bits);
-
-      /**
-      Routes the interrupts to the interrupt pin 2 of the sensor.
-
-      Sensor needs to be in standby mode when routing the interrupts.
-
-      See datasheet for more details.
-
-      @param bits One or more of the KX122_INTERRUPT_T values. Combine with bitwise OR (|)
-      @throws std::runtime_error on failure.
-      */
-      void routeInterrupt2(uint8_t bits);
-
-      /**
-      Gets the status of the interrupts. (Has an interrupt occurred)
-
-      See datasheet for more details.
-
-      @return Return true if an interrupt event has occurred, returns false if no interrupts have occurred.
-      */
-      bool getInterruptStatus();
-
-      /**
-      Gets the source of the interrupt.
-
-      The value stored is one or more of the KX122_INTERRUPT_T values, depending on the interrupts
-      that have occurred.
-
-      If multiple interrupts have occurred, and you need to determine a specific interrupt,
-      you can use masking to get the state of the specific interrupt:
-      (int_source & KX122_DATA_READY_INT) == KX122_DATA_READY_INT)
-
-      See datasheet for more details.
-
-      @return Interrupt source value.
-      @throws std::runtime_error on failure.
-      */
-      uint8_t getInterruptSource();
-
-      /**
-      Clears latching interrupts (Wakeup, Data Ready).
-
-      See datasheet for more details.
-
-      @throws std::runtime_error on failure.
-      */
-      void clearInterrupt();
-
-      /**
-      Enables the data ready interrupt. Availability of new acceleration data is
-      reflected as an interrupt.
-
-      Sensor needs to be in standby mode when enabling the interrupt.
-
-      @throws std::runtime_error on failure.
-      */
-      void enableDataReadyInterrupt();
-
-      /**
-      Disables the data ready interrupt.
-
-      Sensor needs to be in standby mode when disabling the interrupt.
-
-      @throws std::runtime_error on failure.
-      */
-      void disableDataReadyInterrupt();
-
-      /**
-      Enables the buffer full interrupt.
-      Buffer can hold 681 sets of values (8 bit, low resolution mode) or
-      340 sets of values (16 bit, high resolution mode).
-
-      Sensor needs to be in standby mode when enabling the interrupt.
-
-      @throws std::runtime_error on failure.
-      */
-      void enableBufferFullInterrupt();
-
-      /**
-      Disables the buffer full interrupt.
-
-      Sensor needs to be in standby mode when disabling the interrupt.
-
-      @throws std::runtime_error on failure.
-      */
-      void disableBufferFullInterrupt();
-
-      /**
-      Enables the buffer.
-
-      Sensor needs to be in standby mode when enabling the buffer.
-
-      @throws std::runtime_error on failure.
-      */
-      void enableBuffer();
-
-      /**
-      Disables the buffer.
-
-      Sensor needs to be in standby mode when disabling the buffer.
-
-      @throws std::runtime_error on failure.
-      */
-      void disableBuffer();
-
-      /**
-      Initializes the buffer with the given sample watermark level, buffer resolution and buffer operating mode.
-      Buffer is enabled after the initialization.
-
-      Sensor is automatically set into standby mode during the buffer initialization.
-      Sensor is set to active mode after initialization.
-
-      See the other buffer functions for details about the different parameter values.
-
-      @param samples Amount of samples to trigger the watermark interrupt.
-      @param res One of the KX122_RES_T values.
-      @param mode One of the KX122_BUFFER_MODE_T values.
-      @throws std::runtime_error on failure.
-      */
-      void bufferInit(uint samples, KX122_RES_T res, KX122_BUFFER_MODE_T mode);
-
-      /**
-      Sets the buffer resolution.
-      Buffer resolution is independent of the sensor resolution.
-
-      Sensor needs to be in standby mode when setting the buffer resolution.
-
-      @throws std::runtime_error on failure.
-      */
-      void setBufferResolution(KX122_RES_T res);
-
-      /**
-      Sets the buffer watermark interrupt threshold.
-      When the buffer sample count reaches the watermark, watermark interrupt will be given.
-
-      In low resolution mode, maximum number of samples is 681. In high resolution, the maximum
-      number is 340.
-
-      See datasheet for more details.
-
-      Sensor needs to be in standby mode when setting the buffer threshold.
-
-      @param samples Amount of samples to trigger the watermark interrupt.
-      @throws std::runtime_error on failure.
-      */
-      void setBufferThreshold(uint samples);
-
-      /**
-      Sets the buffer operating mode.
-      The buffer can operate in FIFO,FILO or Stream mode.
-      The buffer gathers data, reports data and interacts with the status indicators
-      in a slightly different way depending on the operating mode.
-
-      See datasheet for more details.
-
-      Sensor needs to be in standby mode when setting the buffer mode.
-
-      @param mode One of the KX122_BUFFER_MODE_T values.
-      @throws std::runtime_error on failure.
-      */
-      void setBufferMode(KX122_BUFFER_MODE_T mode);
-
-      /**
-      Gets the current amount of samples in the buffer.
-
-      @return number of samples in the buffer.
-      @throws std::runtime_error on failure.
-      */
-      uint getBufferStatus();
-
-      /**
-      Gets the specified amount of raw acceleration samples from the buffer.
-
-      @param len The amount of samples to read from the buffer.
-      @return vector containing x, y & z-axis data
-      @throws std::runtime_error on failure.
-      */
-      std::vector<float> getRawBufferSamples(uint len);
-
-      /**
-      Gets the specified amount of converted (m/s^2) acceleration samples from the buffer.
-
-      @param len The amount of samples to read from the buffer.
-      @return vector containing x, y & z-axis data
-      @throws std::runtime_error on failure.
-      */
-      std::vector<float> getBufferSamples(uint len);
-
-      /**
-      Clears the buffer, removing all existing samples from the buffer.
-
-      @throws std::runtime_error on failure.
-      */
-      void clearBuffer();
-    private:
-      //Device context
-      kx122_context m_kx122;
-
-      /* Disable implicit copy and assignment operators */
-      KX122(const KX122&) = delete;
-      KX122 &operator=(const KX122&) = delete;
-  };
-}
diff --git a/src/kx122/kx122.i b/src/kx122/kx122.i
deleted file mode 100644
index 0c1d671..0000000
--- a/src/kx122/kx122.i
+++ /dev/null
@@ -1,20 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_kx122)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%include "std_vector.i"
-%template(floatVector) std::vector<float>;
-
-%apply float *OUTPUT {float *x, float *y, float *z};
-
-%{
-#include "kx122.hpp"
-%}
-%include "kx122.h"
-%include "kx122.hpp"
-/* END Common SWIG syntax */
diff --git a/src/kx122/kx122.json b/src/kx122/kx122.json
deleted file mode 100644
index 6e4d19e..0000000
--- a/src/kx122/kx122.json
+++ /dev/null
@@ -1,47 +0,0 @@
-{
-    "Library": "KX122",
-    "Description": "Kionix KX122 accelerometer sensor library",
-    "Sensor Class": {
-        "KX122": {
-            "Name": "Kionix KX122 tri-axis accelerometer sensor",
-            "Description": "This is the UPM Module for the Kionix KX122 accelerometer sensor.
-            The Kionix KX122 sensor is a multifunctional sensor that provides a multitude if different functionality
-            in addition to the basic accelerometer functionality. The sensor has 2 interrupt pins,
-            that can be used to detect various interrupts. The Sensor has an additional sample buffer that can be configured.",
-            "Categories": ["acceleration"],
-            "Connections": ["i2c,spi"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["Kionix"],
-            "Examples": {
-                "C++":["kx122.cxx"],
-                "C": ["kx122.c"]
-            },
-            "Specifications": {
-                "Supply Voltage (VDD)": {
-                    "unit": "V",
-                    "min": 1.71,
-                    "max": 3.6
-                },
-                "I/O Pads Supply Voltage (IO_VDD)": {
-                    "unit": "V",
-                    "min": 1.7,
-                    "max": 3.6
-                },
-                "Supply Current": {
-                    "unit": "uA",
-                    "min" : 0.9,
-                    "max" : 146
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                }
-            },
-            "Urls": {
-                "Product Pages": ["http://www.kionix.com/product/KX122-1037"],
-                "Datasheets": ["http://kionixfs.kionix.com/en/datasheet/KX122-1037%20Specifications%20Rev%205.0.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/kx122/kx122_registers.h b/src/kx122/kx122_registers.h
deleted file mode 100644
index 5789eeb..0000000
--- a/src/kx122/kx122_registers.h
+++ /dev/null
@@ -1,539 +0,0 @@
-/*
-The MIT License (MIT)
-Copyright (c) 2017 Kionix Inc.
-
-Permission is hereby granted, free of charge, to any person obtaining a
-copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sublicense, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice shall be included
-in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-#ifndef __KX122_REGISTERS_H__
-#define __KX122_REGISTERS_H__
-/* registers */
-// x- hp filter output
-#define KX122_XHP_L 0x00
-#define KX122_XHP_H 0x01
-// y- hp filter output
-#define KX122_YHP_L 0x02
-#define KX122_YHP_H 0x03
-// z- hpfilteroutput
-#define KX122_ZHP_L 0x04
-#define KX122_ZHP_H 0x05
-// output register x
-#define KX122_XOUT_L 0x06
-#define KX122_XOUT_H 0x07
-// output register y
-#define KX122_YOUT_L 0x08
-#define KX122_YOUT_H 0x09
-// output register z
-#define KX122_ZOUT_L 0x0A
-#define KX122_ZOUT_H 0x0B
-// communication selftest
-#define KX122_COTR 0x0C
-// WHO_AM_I
-#define KX122_WHO_AM_I 0x0F
-// current sixfacet posititions
-#define KX122_TSCP 0x10
-// previous six facet positions
-#define KX122_TSPP 0x11
-// This register indicates the triggering axis when a tap/double tap interrupt occurs.
-#define KX122_INS1 0x12
-// This register tells witch function caused an interrupt.
-#define KX122_INS2 0x13
-// This register reports the axis and direction of detected motion.
-#define KX122_INS3 0x14
-// This register reports the status of the interrupt.
-#define KX122_STATUS_REG 0x15
-#define KX122_INT_REL 0x17
-// Read/write control register that controls the main feature set.
-#define KX122_CNTL1 0x18
-// 2' control register
-#define KX122_CNTL2 0x19
-// 3' controlregister
-#define KX122_CNTL3 0x1A
-// This register is responsible for configuring ODR (output data rate) and filter settings
-#define KX122_ODCNTL 0x1B
-// This register controls the settings for the physical interrupt pin INT1
-#define KX122_INC1 0x1C
-// This register controls which axis and direction of detected motion can cause an interrupt.
-#define KX122_INC2 0x1D
-// This register controls which axis and direction of tap/double tap can cause an interrup
-#define KX122_INC3 0x1E
-// This register controls routing of an interrupt reporting to physical interrupt pin INT1
-#define KX122_INC4 0x1F
-// This register controls the settings for the physical interrupt pin INT2.
-#define KX122_INC5 0x20
-// This register controls routing of interrupt reporting to physical interrupt pin INT2
-#define KX122_INC6 0x21
-#define KX122_TILT_TIMER 0x22
-#define KX122_WUFC 0x23
-// This register is responsible for enableing/disabling reporting of Tap/Double Tap.
-#define KX122_TDTRC 0x24
-#define KX122_TDTC 0x25
-#define KX122_TTH 0x26
-#define KX122_TTL 0x27
-#define KX122_FTD 0x28
-#define KX122_STD 0x29
-#define KX122_TLT 0x2A
-#define KX122_TWS 0x2B
-#define KX122_FFTH 0x2C
-#define KX122_FFC 0x2D
-// Free Fall Control: This register contains the counter setting of the Free fall detection.
-#define KX122_FFCNTL 0x2E
-#define KX122_ATH 0x30
-#define KX122_TILT_ANGLE_LL 0x32
-#define KX122_TILT_ANGLE_HL 0x33
-// This register sets the Hysteresis that is placed in between the Screen Rotation states
-#define KX122_HYST_SET 0x34
-// Low Power Control sets the number of samples of accelerometer output to be average
-#define KX122_LP_CNTL 0x35
-// Read/write control register that controls the buffer sample threshold
-#define KX122_BUF_CNTL1 0x3A
-// Read/write control register that controls sample buffer operation
-#define KX122_BUF_CNTL2 0x3B
-// This register reports the status of the sample buffer
-#define KX122_BUF_STATUS_1 0x3C
-// This register reports the status of the sample buffer trigger function
-#define KX122_BUF_STATUS_2 0x3D
-#define KX122_BUF_CLEAR 0x3E
-#define KX122_BUF_READ 0x3F
-// When 0xCA is written to this register, the MEMS self-test function is enabled. Electrostatic-actuation of the accelerometer, results in a DC shift of the X, Y and Z axis outputs. Writing 0x00 to this register will return the accelerometer to normal operation
-#define KX122_SELF_TEST 0x60
-// WHO_AM_I
-#define KX112_WHO_AM_I 0x0F
-// WHO_AM_I
-#define KX123_WHO_AM_I 0x0F
-// WHO_AM_I
-#define KX124_WHO_AM_I 0x0F
-/* registers bits */
-// before set
-#define KX122_COTR_DCSTR_BEFORE (0x55 << 0)
-// after set
-#define KX122_COTR_DCSTR_AFTER (0xAA << 0)
-// WHO_AM_I -value for KX122
-#define KX122_WHO_AM_I_WIA_ID (0x1B << 0)
-// x-left
-#define KX122_TSCP_LE (0x01 << 5)
-// x+right
-#define KX122_TSCP_RI (0x01 << 4)
-// y-down
-#define KX122_TSCP_DO (0x01 << 3)
-// y+up
-#define KX122_TSCP_UP (0x01 << 2)
-// z-facedown
-#define KX122_TSCP_FD (0x01 << 1)
-// z+faceup
-#define KX122_TSCP_FU (0x01 << 0)
-// x-left
-#define KX122_TSPP_LE (0x01 << 5)
-// x+right
-#define KX122_TSPP_RI (0x01 << 4)
-// y-down
-#define KX122_TSPP_DO (0x01 << 3)
-// y+up
-#define KX122_TSPP_UP (0x01 << 2)
-// z-facedown
-#define KX122_TSPP_FD (0x01 << 1)
-// z+faceup
-#define KX122_TSPP_FU (0x01 << 0)
-// x-
-#define KX122_INS1_TLE (0x01 << 5)
-// x+
-#define KX122_INS1_TRI (0x01 << 4)
-// y-
-#define KX122_INS1_TDO (0x01 << 3)
-// y+
-#define KX122_INS1_TUP (0x01 << 2)
-// z-
-#define KX122_INS1_TFD (0x01 << 1)
-// z+
-#define KX122_INS1_TFU (0x01 << 0)
-// Free fall. This bit is cleared when the interrupt latch release register (INL) is read..
-#define KX122_INS2_FFS (0x01 << 7)
-// indicates buffer full interrupt. Automatically cleared when buffer is read.
-#define KX122_INS2_BFI (0x01 << 6)
-// Watermark interrupt, bit is set to one when FIFO has filled up to the value stored in the sample bits.This bit is automatically cleared when FIFO/FILO is read and the content returns to a value below the value stored in the sample bits.
-#define KX122_INS2_WMI (0x01 << 5)
-// indicates that new acceleration data (0x06h to 0x0Bh) is available. This bit is cleared when acceleration data is read or the interrupt release register INT_REL is read.
-#define KX122_INS2_DRDY (0x01 << 4)
-// no tap
-#define KX122_INS2_TDTS_NOTAP (0x00 << 2)
-// single tap event
-#define KX122_INS2_TDTS_SINGLE (0x01 << 2)
-// double tap event
-#define KX122_INS2_TDTS_DOUBLE (0x02 << 2)
-// do not exist
-#define KX122_INS2_TDTS_NA (0x03 << 2)
-// Status of Wake up. This bit is cleared when the interrupt release register INT_REL is read.
-#define KX122_INS2_WUFS (0x01 << 1)
-// Tilt Position status. This bit is cleared when the interrupt release register INT_REL is read.
-#define KX122_INS2_TPS (0x01 << 0)
-// x-
-#define KX122_INS3_XNWU (0x01 << 5)
-// x+
-#define KX122_INS3_XPWU (0x01 << 4)
-// y-
-#define KX122_INS3_YNWU (0x01 << 3)
-// y+
-#define KX122_INS3_YPWU (0x01 << 2)
-// z-
-#define KX122_INS3_ZNWU (0x01 << 1)
-// z+
-#define KX122_INS3_ZPWU (0x01 << 0)
-// INT reports the combined (OR) interrupt information of all features.
-#define KX122_STATUS_REG_INT (0x01 << 4)
-// controls the operating mode of the KX122.
-#define KX122_CNTL1_PC1 (0x01 << 7)
-// determines the performance mode of the KX122. The noise varies with ODR, RES and different LP_CNTL settings possibly reducing the effective resolution.
-#define KX122_CNTL1_RES (0x01 << 6)
-// enables the reporting of the availability of new acceleration data as an interrupt
-#define KX122_CNTL1_DRDYE (0x01 << 5)
-// 2g range
-#define KX122_CNTL1_GSEL_2G (0x00 << 3)
-// 4g range
-#define KX122_CNTL1_GSEL_4G (0x01 << 3)
-// 8g range
-#define KX122_CNTL1_GSEL_8G (0x02 << 3)
-// not valid settings
-#define KX122_CNTL1_GSEL_NA (0x03 << 3)
-// enables the Directional Tap function that will detect single and double tap events.
-#define KX122_CNTL1_TDTE (0x01 << 2)
-// enables the Wake Up (motion detect) function
-#define KX122_CNTL1_WUFE (0x01 << 1)
-// enables the Tilt Position function that will detect changes in device orientation.
-#define KX122_CNTL1_TPE (0x01 << 0)
-// initiates software reset, which performs the RAM reboot routine
-#define KX122_CNTL2_SRST (0x01 << 7)
-// command test control
-#define KX122_CNTL2_COTC (0x01 << 6)
-// x-
-#define KX122_CNTL2_LEM (0x01 << 5)
-// x+
-#define KX122_CNTL2_RIM (0x01 << 4)
-// y-
-#define KX122_CNTL2_DOM (0x01 << 3)
-// y+
-#define KX122_CNTL2_UPM (0x01 << 2)
-// z-
-#define KX122_CNTL2_FDM (0x01 << 1)
-// z+
-#define KX122_CNTL2_FUM (0x01 << 0)
-// 1.5Hz
-#define KX122_CNTL3_OTP_1P563 (0x00 << 6)
-// 6.25Hz
-#define KX122_CNTL3_OTP_6P25 (0x01 << 6)
-// 12.5Hz
-#define KX122_CNTL3_OTP_12P5 (0x02 << 6)
-// 50Hz
-#define KX122_CNTL3_OTP_50 (0x03 << 6)
-// 50Hz
-#define KX122_CNTL3_OTDT_50 (0x00 << 3)
-// 100Hz
-#define KX122_CNTL3_OTDT_100 (0x01 << 3)
-// 200Hz
-#define KX122_CNTL3_OTDT_200 (0x02 << 3)
-// 400Hz
-#define KX122_CNTL3_OTDT_400 (0x03 << 3)
-// 12.5Hz
-#define KX122_CNTL3_OTDT_12P5 (0x04 << 3)
-// 25Hz
-#define KX122_CNTL3_OTDT_25 (0x05 << 3)
-// 800Hz
-#define KX122_CNTL3_OTDT_800 (0x06 << 3)
-// 1600Hz
-#define KX122_CNTL3_OTDT_1600 (0x07 << 3)
-// 0.78Hz
-#define KX122_CNTL3_OWUF_0P781 (0x00 << 0)
-// 1.563Hz
-#define KX122_CNTL3_OWUF_1P563 (0x01 << 0)
-// 3.125Hz
-#define KX122_CNTL3_OWUF_3P125 (0x02 << 0)
-// 6.25Hz
-#define KX122_CNTL3_OWUF_6P25 (0x03 << 0)
-// 12.5Hz
-#define KX122_CNTL3_OWUF_12P5 (0x04 << 0)
-// 25Hz
-#define KX122_CNTL3_OWUF_25 (0x05 << 0)
-// 50Hz
-#define KX122_CNTL3_OWUF_50 (0x06 << 0)
-// 100Hz
-#define KX122_CNTL3_OWUF_100 (0x07 << 0)
-// filtering applied
-#define KX122_ODCNTL_IIR_BYPASS_APPLY (0x00 << 7)
-// filter bypassed
-#define KX122_ODCNTL_IIR_BYPASS_BYPASS (0x01 << 7)
-// filter corner frequency set to ODR/9
-#define KX122_ODCNTL_LPRO_ODR_9 (0x00 << 6)
-// filter corner frequency set to ODR/2
-#define KX122_ODCNTL_LPRO_ODR_2 (0x01 << 6)
-// 12.5Hz
-#define KX122_ODCNTL_OSA_12P5 (0x00 << 0)
-// 25Hz
-#define KX122_ODCNTL_OSA_25 (0x01 << 0)
-// 50Hz
-#define KX122_ODCNTL_OSA_50 (0x02 << 0)
-// 100Hz
-#define KX122_ODCNTL_OSA_100 (0x03 << 0)
-// 200Hz
-#define KX122_ODCNTL_OSA_200 (0x04 << 0)
-// 400Hz
-#define KX122_ODCNTL_OSA_400 (0x05 << 0)
-// 800Hz
-#define KX122_ODCNTL_OSA_800 (0x06 << 0)
-// 1600Hz
-#define KX122_ODCNTL_OSA_1600 (0x07 << 0)
-// 0.78Hz
-#define KX122_ODCNTL_OSA_0P781 (0x08 << 0)
-// 1.563Hz
-#define KX122_ODCNTL_OSA_1P563 (0x09 << 0)
-// 3.125Hz
-#define KX122_ODCNTL_OSA_3P125 (0x0A << 0)
-// 6.25Hz
-#define KX122_ODCNTL_OSA_6P25 (0x0B << 0)
-// 3200Hz
-#define KX122_ODCNTL_OSA_3200 (0x0C << 0)
-// 6400Hz
-#define KX122_ODCNTL_OSA_6400 (0x0D << 0)
-// 12800Hz
-#define KX122_ODCNTL_OSA_12800 (0x0E << 0)
-// 25600Hz
-#define KX122_ODCNTL_OSA_25600 (0x0F << 0)
-// pulse 50us, 10us 1600ODR and over
-#define KX122_INC1_PWSEL1_50US_10US (0x00 << 6)
-// 1*OSA period
-#define KX122_INC1_PWSEL1_1XOSA (0x01 << 6)
-// 2*OSA period
-#define KX122_INC1_PWSEL1_2XOSA (0x02 << 6)
-// 4*OSA period
-#define KX122_INC1_PWSEL1_4XOSA (0x03 << 6)
-// enables/disables the physical interrupt
-#define KX122_INC1_IEN1 (0x01 << 5)
-// sets the polarity of the physical interrupt pin
-#define KX122_INC1_IEA1 (0x01 << 4)
-// sets the response of the physical interrupt pin
-#define KX122_INC1_IEL1 (0x01 << 3)
-// sets the polarity of Self Test
-#define KX122_INC1_STPOL (0x01 << 1)
-// sets the 3-wire SPI interface
-#define KX122_INC1_SPI3E (0x01 << 0)
-// OR combination between selected directions
-#define KX122_INC2_AOI_OR (0x00 << 6)
-// AND combination between selected axes
-#define KX122_INC2_AOI_AND (0x01 << 6)
-// x negative (x-): 0 = disabled, 1 = enabled
-#define KX122_INC2_XNWUE (0x01 << 5)
-// x positive (x+): 0 = disabled, 1 = enabled
-#define KX122_INC2_XPWUE (0x01 << 4)
-// y negative (y-): 0 = disabled, 1 = enabled
-#define KX122_INC2_YNWUE (0x01 << 3)
-// y positive (y+): 0 = disabled, 1 = enabled
-#define KX122_INC2_YPWUE (0x01 << 2)
-// z negative (z-): 0 = disabled, 1 = enabled
-#define KX122_INC2_ZNWUE (0x01 << 1)
-// z positive (z+): 0 = disabled, 1 = enabled
-#define KX122_INC2_ZPWUE (0x01 << 0)
-// x negative (x-): 0 = disabled, 1 = enabled
-#define KX122_INC3_TLEM (0x01 << 5)
-// x positive (x+): 0 = disabled, 1 = enabled
-#define KX122_INC3_TRIM (0x01 << 4)
-// y negative (y-): 0 = disabled, 1 = enabled
-#define KX122_INC3_TDOM (0x01 << 3)
-// y positive (y+): 0 = disabled, 1 = enabled
-#define KX122_INC3_TUPM (0x01 << 2)
-// z negative (z-): 0 = disabled, 1 = enabled
-#define KX122_INC3_TFDM (0x01 << 1)
-// z positive (z+): 0 = disabled, 1 = enabled
-#define KX122_INC3_TFUM (0x01 << 0)
-// Free fall interrupt reported on physical interrupt INT1
-#define KX122_INC4_FFI1 (0x01 << 7)
-// Buffer full interrupt reported on physical interrupt pin INT1
-#define KX122_INC4_BFI1 (0x01 << 6)
-// Watermark interrupt reported on physical interrupt pin INT1
-#define KX122_INC4_WMI1 (0x01 << 5)
-// Data ready interrupt reported on physical interrupt pin INT1
-#define KX122_INC4_DRDYI1 (0x01 << 4)
-// Tap/Double Tap interrupt reported on physical interrupt pin INT1
-#define KX122_INC4_TDTI1 (0x01 << 2)
-// Wake-Up (motion detect) interrupt reported on physical interrupt pin INT1
-#define KX122_INC4_WUFI1 (0x01 << 1)
-// Tilt position interrupt reported on physical interrupt pin INT1
-#define KX122_INC4_TPI1 (0x01 << 0)
-// pulse 50us, 10us 1600ODR and over
-#define KX122_INC5_PWSEL2_50US_10US (0x00 << 6)
-// 1*OSA period
-#define KX122_INC5_PWSEL2_1XOSA (0x01 << 6)
-// 2*OSA period
-#define KX122_INC5_PWSEL2_2XOSA (0x02 << 6)
-// 4*OSA period
-#define KX122_INC5_PWSEL2_4XOSA (0x03 << 6)
-// enables/disables the physical interrupt
-#define KX122_INC5_IEN2 (0x01 << 5)
-// sets the polarity of the physical interrupt pin
-#define KX122_INC5_IEA2 (0x01 << 4)
-// sets the response of the physical interrupt pin
-#define KX122_INC5_IEL2 (0x01 << 3)
-// Interrupt source automatic clear at interup 2 trailing edge
-#define KX122_INC5_ACLR2 (0x01 << 1)
-// Interrupt source automatic clear at interup 1 trailing edge
-#define KX122_INC5_ACLR1 (0x01 << 0)
-// FFI2  Free fall interrupt reported on physical interrupt INT2
-#define KX122_INC6_FFI2 (0x01 << 7)
-// BFI2  Buffer full interrupt reported on physical interrupt pin INT2
-#define KX122_INC6_BFI2 (0x01 << 6)
-// WMI2 - Watermark interrupt reported on physical interrupt pin INT2
-#define KX122_INC6_WMI2 (0x01 << 5)
-// DRDYI2  Data ready interrupt reported on physical interrupt pin INT2
-#define KX122_INC6_DRDYI2 (0x01 << 4)
-// TDTI2 - Tap/Double Tap interrupt reported on physical interrupt pin INT2
-#define KX122_INC6_TDTI2 (0x01 << 2)
-// WUFI2  Wake-Up (motion detect) interrupt reported on physical interrupt pin INT2
-#define KX122_INC6_WUFI2 (0x01 << 1)
-// TPI2  Tilt position interrupt reported on physical interrupt pin INT2
-#define KX122_INC6_TPI2 (0x01 << 0)
-// enables/disables the double tap interrupt
-#define KX122_TDTRC_DTRE (0x01 << 1)
-// enables/disables single tap interrupt
-#define KX122_TDTRC_STRE (0x01 << 0)
-// Free fall engine enable
-#define KX122_FFCNTL_FFIE (0x01 << 7)
-// Free fall interrupt latch/un-latch control
-#define KX122_FFCNTL_ULMODE (0x01 << 6)
-// Debounce methodology control
-#define KX122_FFCNTL_DCRM (0x01 << 3)
-// 12.5Hz
-#define KX122_FFCNTL_OFFI_12P5 (0x00 << 0)
-// 25Hz
-#define KX122_FFCNTL_OFFI_25 (0x01 << 0)
-// 50Hz
-#define KX122_FFCNTL_OFFI_50 (0x02 << 0)
-// 100Hz
-#define KX122_FFCNTL_OFFI_100 (0x03 << 0)
-// 200Hz
-#define KX122_FFCNTL_OFFI_200 (0x04 << 0)
-// 400Hz
-#define KX122_FFCNTL_OFFI_400 (0x05 << 0)
-// 800Hz
-#define KX122_FFCNTL_OFFI_800 (0x06 << 0)
-// 1600Hz
-#define KX122_FFCNTL_OFFI_1600 (0x07 << 0)
-// No Averaging
-#define KX122_LP_CNTL_AVC_NO_AVG (0x00 << 4)
-// 2 Samples Averaged
-#define KX122_LP_CNTL_AVC_2_SAMPLE_AVG (0x01 << 4)
-// 4 Samples Averaged
-#define KX122_LP_CNTL_AVC_4_SAMPLE_AVG (0x02 << 4)
-// 8 Samples Averaged
-#define KX122_LP_CNTL_AVC_8_SAMPLE_AVG (0x03 << 4)
-// 16 Samples Averaged (default)
-#define KX122_LP_CNTL_AVC_16_SAMPLE_AVG (0x04 << 4)
-// 32 Samples Averaged
-#define KX122_LP_CNTL_AVC_32_SAMPLE_AVG (0x05 << 4)
-// 64 Samples Averaged
-#define KX122_LP_CNTL_AVC_64_SAMPLE_AVG (0x06 << 4)
-// 128 Samples Averaged
-#define KX122_LP_CNTL_AVC_128_SAMPLE_AVG (0x07 << 4)
-#define KX122_BUF_CNTL1_SMP_TH0_7 (0xFF << 0)
-// controls activation of the sample buffer
-#define KX122_BUF_CNTL2_BUFE (0x01 << 7)
-// determines the resolution of the acceleration data samples collected by the sample
-#define KX122_BUF_CNTL2_BRES (0x01 << 6)
-// buffer full interrupt enable bit
-#define KX122_BUF_CNTL2_BFIE (0x01 << 5)
-// watermark level bits 8 and 9
-#define KX122_BUF_CNTL2_SMP_TH8_9 (0x0C << 2)
-// The buffer collects 681 sets of 8-bit low resolution values or 339 sets of 16-bit high resolution values and then stops collecting data, collecting new data only when the buffer is not full
-#define KX122_BUF_CNTL2_BUF_M_FIFO (0x00 << 0)
-// The buffer holds the last 681 sets of 8-bit low resolution values or 339 sets of 16-bit high resolution values. Once the buffer is full, the oldest data is discarded to make room for newer data.
-#define KX122_BUF_CNTL2_BUF_M_STREAM (0x01 << 0)
-// When a trigger event occurs, the buffer holds the last data set of SMP[9:0] samples before the trigger event and then continues to collect data until full. New data is collected only when the buffer is not full.
-#define KX122_BUF_CNTL2_BUF_M_TRIGGER (0x02 << 0)
-// The buffer holds the last 681 sets of 8-bit low resolution values or 339 sets of 16-bit high resolution values. Once the buffer is full, the oldest data is discarded to make room for newer data. Reading from the buffer in this mode will return the most recent data first.
-#define KX122_BUF_CNTL2_BUF_M_FILO (0x03 << 0)
-#define KX122_BUF_STATUS_1_SMP_LEV0_7 (0xFF << 0)
-// reports the status of the buffers trigger function if this mode has been selected
-#define KX122_BUF_STATUS_2_BUF_TRIG (0x01 << 7)
-// level High mask
-#define KX122_BUF_STATUS_2_SMP_LEV8_10 (0x07 << 0)
-// MEMS Test OFF
-#define KX122_SELF_TEST_MEMS_TEST_OFF (0x00 << 0)
-// MEMS Test ON
-#define KX122_SELF_TEST_MEMS_TEST_ON (0xCA << 0)
-// WHO_AM_I -value for KX112
-#define KX112_WHO_AM_I_WIA_ID (0x22 << 0)
-// WHO_AM_I -value for KX123
-#define KX123_WHO_AM_I_WIA_ID (0x20 << 0)
-// WHO_AM_I -value for KX124
-#define KX124_WHO_AM_I_WIA_ID (0x28 << 0)
- /*registers bit masks */
-
-#define KX122_COTR_DCSTR_MASK 0xFF
-
-#define KX122_WHO_AM_I_WIA_MASK 0xFF
-// status of tap/double tap, bit is released when interrupt release register INT_REL is read.
-#define KX122_INS2_TDTS_MASK 0x0C
-// selects the acceleration range of the accelerometer outputs
-#define KX122_CNTL1_GSEL_MASK 0x18
-// sets the output data rate for the Tilt Position function
-#define KX122_CNTL3_OTP_MASK 0xC0
-// sets the output data rate for the Directional TapTM function
-#define KX122_CNTL3_OTDT_MASK 0x38
-// sets the output data rate for the general motion detection function and the high-pass filtered outputs
-#define KX122_CNTL3_OWUF_MASK 0x07
-// filter bypass mode
-#define KX122_ODCNTL_IIR_BYPASS_MASK 0x80
-// low-pass filter roll off control
-#define KX122_ODCNTL_LPRO_MASK 0x40
-// acceleration output data rate.
-#define KX122_ODCNTL_OSA_MASK 0x0F
-// Pulse interrupt 1 width configuration
-#define KX122_INC1_PWSEL1_MASK 0xC0
-// AND OR configuration for motion detection
-#define KX122_INC2_AOI_MASK 0x40
-#define KX122_INC2_WUE_MASK 0x3F
-#define KX122_INC3_TM_MASK 0x3F
-// Pulse interrupt 2 width configuration
-#define KX122_INC5_PWSEL2_MASK 0xC0
-// Output Data Rate at which the Free fall engine performs its function.
-#define KX122_FFCNTL_OFFI_MASK 0x07
-#define KX122_HYST_SET_HYST_MASK 0x3F
-// Averaging Filter Control
-#define KX122_LP_CNTL_AVC_MASK 0x70
-
-#define KX122_BUF_CNTL1_SMP_TH0_MASK 0xFF
-#define KX122_BUF_CNTL1_SMP_TH0_7_MASK 0xFF
-
-#define KX122_BUF_CNTL2_SMP_TH8_MASK 0x0C
-#define KX122_BUF_CNTL2_SMP_TH8_9_MASK 0x0C
-// selects the operating mode of the sample buffer
-#define KX122_BUF_CNTL2_BUF_M_MASK 0x03
-
-#define KX122_BUF_STATUS_1_SMP_LEV0_MASK 0xFF
-#define KX122_BUF_STATUS_1_SMP_LEV0_7_MASK 0xFF
-
-#define KX122_BUF_STATUS_2_SMP_LEV8_MASK 0x07
-#define KX122_BUF_STATUS_2_SMP_LEV8_10_MASK 0x07
-
-#define KX122_SELF_TEST_MEMS_TEST_MASK 0xFF
-
-#define KX112_WHO_AM_I_WIA_MASK 0xFF
-
-#define KX123_WHO_AM_I_WIA_MASK 0xFF
-
-#define KX124_WHO_AM_I_WIA_MASK 0xFF
-#endif
-
diff --git a/src/kxcjk1013/CMakeLists.txt b/src/kxcjk1013/CMakeLists.txt
deleted file mode 100644
index 30f0b28..0000000
--- a/src/kxcjk1013/CMakeLists.txt
+++ /dev/null
@@ -1,7 +0,0 @@
-if (MRAA_IIO_FOUND)
-    set (libname "kxcjk1013")
-    set (libdescription "Tri-axis Digital Accelerometer")
-    set (module_src ${libname}.cxx)
-    set (module_hpp ${libname}.hpp)
-    upm_module_init(mraa)
-endif (MRAA_IIO_FOUND)
diff --git a/src/kxcjk1013/kxcjk1013.cxx b/src/kxcjk1013/kxcjk1013.cxx
deleted file mode 100644
index 5d7f757..0000000
--- a/src/kxcjk1013/kxcjk1013.cxx
+++ /dev/null
@@ -1,202 +0,0 @@
-/*
- * Author: Lay, Kuan Loon <kuan.loon.lay@intel.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-#include <string.h>
-#include "kxcjk1013.hpp"
-
-#define NUMBER_OF_BITS_IN_BYTE 8
-
-using namespace upm;
-
-KXCJK1013::KXCJK1013(int device)
-{
-    float accel_scale;
-    char trigger[64];
-
-    if (!(m_iio = mraa_iio_init(device))) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_iio_init() failed, invalid device?");
-        return;
-    }
-    m_scale = 1;
-    m_iio_device_num = device;
-    sprintf(trigger, "hrtimer-kxcjk1013-hr-dev%d", device);
-
-    if (mraa_iio_create_trigger(m_iio, trigger) != MRAA_SUCCESS)
-        fprintf(stderr, "Create trigger %s failed\n", trigger);
-
-    if (mraa_iio_get_mount_matrix(m_iio, "in_mount_matrix", m_mount_matrix) == MRAA_SUCCESS)
-        m_mount_matrix_exist = true;
-    else
-        m_mount_matrix_exist = false;
-
-    if (mraa_iio_read_float(m_iio, "in_accel_scale", &accel_scale) == MRAA_SUCCESS)
-        m_scale = accel_scale;
-}
-
-KXCJK1013::~KXCJK1013()
-{
-    if (m_iio)
-        mraa_iio_close(m_iio);
-}
-
-void
-KXCJK1013::installISR(void (*isr)(char*, void*), void* arg)
-{
-    mraa_iio_trigger_buffer(m_iio, isr, arg);
-}
-
-int64_t
-KXCJK1013::getChannelValue(unsigned char* input, mraa_iio_channel* chan)
-{
-    uint64_t u64 = 0;
-    int i;
-    int storagebits = chan->bytes * NUMBER_OF_BITS_IN_BYTE;
-    int realbits = chan->bits_used;
-    int zeroed_bits = storagebits - realbits;
-    uint64_t sign_mask;
-    uint64_t value_mask;
-
-
-    if (!chan->lendian)
-        for (i = 0; i < storagebits / NUMBER_OF_BITS_IN_BYTE; i++)
-            u64 = (u64 << NUMBER_OF_BITS_IN_BYTE) | input[i];
-    else
-        for (i = storagebits / NUMBER_OF_BITS_IN_BYTE - 1; i >= 0; i--)
-            u64 = (u64 << 8) | input[i];
-
-    u64 = (u64 >> chan->shift) & (~0ULL >> zeroed_bits);
-
-    if (!chan->signedd)
-        return (int64_t) u64; /* We don't handle unsigned 64 bits int */
-
-    /* Signed integer */
-
-    switch (realbits) {
-        case 0 ... 1:
-            return 0;
-
-        case 8:
-            return (int64_t)(int8_t) u64;
-
-        case 16:
-            return (int64_t)(int16_t) u64;
-
-        case 32:
-            return (int64_t)(int32_t) u64;
-
-        case 64:
-            return (int64_t) u64;
-
-        default:
-            sign_mask = 1 << (realbits - 1);
-            value_mask = sign_mask - 1;
-
-            if (u64 & sign_mask)
-                return -((~u64 & value_mask) + 1); /* Negative value: return 2-complement */
-            else
-                return (int64_t) u64; /* Positive value */
-    }
-}
-
-bool
-KXCJK1013::enableBuffer(int length)
-{
-    mraa_iio_write_int(m_iio, "buffer/length", length);
-    // enable must be last step, else will have error in writing above config
-    mraa_iio_write_int(m_iio, "buffer/enable", 1);
-
-    return true;
-}
-
-bool
-KXCJK1013::disableBuffer()
-{
-    mraa_iio_write_int(m_iio, "buffer/enable", 0);
-
-    return true;
-}
-
-bool
-KXCJK1013::setScale(float scale)
-{
-    m_scale = scale;
-    mraa_iio_write_float(m_iio, "in_accel_scale", scale);
-
-    return true;
-}
-
-bool
-KXCJK1013::setSamplingFrequency(float sampling_frequency)
-{
-    mraa_iio_write_float(m_iio, "in_accel_sampling_frequency", sampling_frequency);
-
-    return true;
-}
-
-bool
-KXCJK1013::enable3AxisChannel()
-{
-    char trigger[64];
-    sprintf(trigger, "kxcjk1013-hr-dev%d", m_iio_device_num);
-
-    mraa_iio_write_string(m_iio, "trigger/current_trigger", trigger);
-    mraa_iio_write_int(m_iio, "scan_elements/in_accel_x_en", 1);
-    mraa_iio_write_int(m_iio, "scan_elements/in_accel_y_en", 1);
-    mraa_iio_write_int(m_iio, "scan_elements/in_accel_z_en", 1);
-
-    // need update channel data size after enable
-    mraa_iio_update_channels(m_iio);
-    return true;
-}
-
-void
-KXCJK1013::extract3Axis(char* data, float* x, float* y, float* z)
-{
-    mraa_iio_channel* channels = mraa_iio_get_channels(m_iio);
-    float tmp[3];
-    int iio_x, iio_y, iio_z;
-
-    iio_x = getChannelValue((unsigned char*) (data + channels[0].location), &channels[0]);
-    iio_y = getChannelValue((unsigned char*) (data + channels[1].location), &channels[1]);
-    iio_z = getChannelValue((unsigned char*) (data + channels[2].location), &channels[2]);
-
-    // Raw data is acceleration in direction. Units after application of scale are m/s^2
-    *x = (iio_x * m_scale);
-    *y = (iio_y * m_scale);
-    *z = (iio_z * m_scale);
-
-    if (m_mount_matrix_exist) {
-        tmp[0] = *x * m_mount_matrix[0] + *y * m_mount_matrix[1] + *z * m_mount_matrix[2];
-        tmp[1] = *x * m_mount_matrix[3] + *y * m_mount_matrix[4] + *z * m_mount_matrix[5];
-        tmp[2] = *x * m_mount_matrix[6] + *y * m_mount_matrix[7] + *z * m_mount_matrix[8];
-
-        *x = tmp[0];
-        *y = tmp[1];
-        *z = tmp[2];
-    }
-}
diff --git a/src/kxcjk1013/kxcjk1013.hpp b/src/kxcjk1013/kxcjk1013.hpp
deleted file mode 100644
index 0148354..0000000
--- a/src/kxcjk1013/kxcjk1013.hpp
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
- * Author: Lay, Kuan Loon <kuan.loon.lay@intel.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/iio.h>
-
-namespace upm
-{
-/**
- * @brief KXCJK1013 Tri-axis Digital Accelerometer
- * @defgroup kxcjk1013 libupm-kxcjk1013
- * @ingroup Kionix iio i2c tri-axis digital accelerometer
- */
-
-/**
- * @library kxcjk1013
- * @sensor kxcjk1013
- * @comname Tri-axis Digital Accelerometer
- * @type accelerometer
- * @man kionix
- * @con iio i2c
- * @web http://kionixfs.kionix.com/en/datasheet/KXCJK-1013%20Specifications%20Rev%202.pdf
- *
- * @brief KXCJK1013 Tri-axis Digital Accelerometer API
- *
- * The KXCJK is a tri-axis +/-2g, +/-4g or +/-8g silicon micromachined
- * accelerometer.
- *
- * @snippet kxcjk1013.cxx Interesting
- */
-
-class KXCJK1013
-{
-  public:
-    /**
-     * KXCJK1013 Tri-axis Digital Accelerometer
-     *
-     * @param device iio device number
-     */
-    KXCJK1013(int device);
-
-    /**
-     * KXCJK1013 destructor
-     */
-    ~KXCJK1013();
-
-    /**
-     * Installs an interrupt service routine (ISR) to be called when
-     * an interrupt occurs
-     *
-     * @param isr Pointer to a function to be called on interrupt
-     * @param arg Pointer to an object to be supplied as an
-     * argument to the ISR.
-     */
-    void installISR(void (*isr)(char*, void*), void* arg);
-
-    /**
-     * Extract the channel value based on channel type
-     * @param input Channel data
-     * @param chan MRAA iio-layer channel info
-     */
-    int64_t getChannelValue(unsigned char* input, mraa_iio_channel* chan);
-
-    /**
-     * Enable trigger buffer
-     * @param length buffer length in integer
-     */
-    bool enableBuffer(int length);
-
-    /**
-     * Disable trigger buffer
-     */
-    bool disableBuffer();
-
-    /**
-     * Set scale
-     * @param scale in float
-     * Available scales are 0.009582(2g), 0.019163(4g), and 0.038326(8g)
-     * Default scale is 0.019163
-     */
-    bool setScale(const float scale);
-
-    /**
-     * Set sampling frequency
-     * @param sampling_frequency sampling frequency in float
-     * Available sampling frequency are 0.781000, 1.563000, 3.125000, 6.250000, 12.500000, 25, 50,
-     * 100, 200, 400, 800, and 1600
-     * Default sampling frequency is 25
-     */
-    bool setSamplingFrequency(const float sampling_frequency);
-
-    /**
-     * Enable 3 axis scan element
-     */
-    bool enable3AxisChannel();
-
-    /**
-     * Process enabled channel buffer and return x, y, z axis
-     * @param data Enabled channel data, 6 bytes, each axis 2 bytes
-     * @param x X-Axis
-     * @param y Y-Axis
-     * @param z Z-Axis
-     */
-    void extract3Axis(char* data, float* x, float* y, float* z);
-
-  private:
-    mraa_iio_context m_iio;
-    int m_iio_device_num;
-    bool m_mount_matrix_exist; // is mount matrix exist
-    float m_mount_matrix[9];   // mount matrix
-    float m_scale;             // accelerometer data scale
-};
-}
diff --git a/src/kxcjk1013/kxcjk1013.json b/src/kxcjk1013/kxcjk1013.json
deleted file mode 100644
index 39b2c63..0000000
--- a/src/kxcjk1013/kxcjk1013.json
+++ /dev/null
@@ -1,39 +0,0 @@
-{
-    "Library": "kxcjk1013",
-    "Description": "KXCJK1013 Tri-axis Digital Accelerometer API",
-    "Sensor Class":
-    {
-        "KXCJK1013":
-        {
-            "Name": "Tri-axis Digital Accelerometer",
-            "Description": "he KXCJK is a tri-axis +/-2g, +/-4g or +/-8g silicon micromachined accelerometer.",
-            "Aliases": ["kxcjk1013"],
-            "Categories": ["accelerometer"],
-            "Connections": ["iio", "i2c"],
-            "Project Type": ["imu", "prototyping"],
-            "Manufacturers": ["kionix"],
-            "Kits": [],
-            "Examples":
-            {
-                "Java": [],
-                "Python": [],
-                "Node.js": [],
-                "C++": ["kxcjk1013.cxx"],
-                "C": []
-            },
-            "Specifications":
-            {
-                "Operating Voltage": {"unit": "V", "low": 1.71, "typ": 2.6, "high": 3.6},
-                "Operating Current": {"unit": "uA", "low": 0.9, "high": 135},
-                "Operating Temperature": {"unit": "degC", "low": -40, "high": 85}
-
-            },
-            "Urls" :
-            {
-                "Product Pages": [],
-                "Datasheets": ["http://kionixfs.kionix.com/en/datasheet/KXCJK-1013%20Specifications%20Rev%202.pdf"],
-                "Schematics": []
-            }
-        }
-    }
-}
diff --git a/src/kxtj3/CMakeLists.txt b/src/kxtj3/CMakeLists.txt
deleted file mode 100755
index 110418b..0000000
--- a/src/kxtj3/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-upm_mixed_module_init (NAME kxtj3
-    DESCRIPTION "Tri-Axis Accelerometer"
-    C_HDR kxtj3.h kxtj3_registers.h
-    C_SRC kxtj3.c
-    CPP_HDR kxtj3.hpp
-    CPP_SRC kxtj3.cxx
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/kxtj3/kxtj3.c b/src/kxtj3/kxtj3.c
deleted file mode 100755
index 54a3a8f..0000000
--- a/src/kxtj3/kxtj3.c
+++ /dev/null
@@ -1,1095 +0,0 @@
-/*
-* The MIT License (MIT)
-*
-* Author: Assam Boudjelthia
-* Copyright (c) 2018 Rohm Semiconductor.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy of
-* this software and associated documentation files (the "Software"), to deal in
-* the Software without restriction, including without limitation the rights to
-* use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-* the Software, and to permit persons to whom the Software is furnished to do so,
-* subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in all
-* copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-* COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-#include <unistd.h>
-#include <math.h>
-#include "kxtj3.h"
-#include "upm_utilities.h"
-
-#define SW_RESET_MAX_LOOP_COUNT 10
-#define SW_RESET_READ_WAIT_MICRO_S 50000
-
-#define SELF_TEST_SAMPLE_COUNT 10
-#define SELF_TEST_DIFFERENCE_THRESHOLD 0.5f
-
-#define DATA_BUFFER_LENGTH 6
-
-/**
- * @brief Acceleration steps in (g) for each range setting.
- * Used to calculate acceleration_scale to convert
- * raw data to readable acceleration data.
- */
-#define RANGE_2G_8BIT_STEP 0.016f
-#define RANGE_4G_8BIT_STEP 0.031f
-#define RANGE_8G_8BIT_STEP 0.0625f
-#define RANGE_16G_8BIT_STEP 0.125f
-
-#define RANGE_2G_12BIT_STEP 0.001f
-#define RANGE_4G_12BIT_STEP 0.002f
-#define RANGE_8G_12BIT_STEP 0.0039f
-#define RANGE_16G_12BIT_STEP 0.0078f
-
-#define RANGE_8G_14BIT_STEP 0.00098f
-#define RANGE_16G_14BIT_STEP 0.00195f
-#define EARTH_GRAVITY 9.81f
-
-/**
- * @brief Map of ODR register values to ODR in Hz
- * used to calculate sampling time in seconds
- */
-struct odr_map_t
-{
-    uint8_t odr_reg_bit;
-    float odr_in_Hz;
-};
-
-/**
- * @brief ODR register values maping with ODR in Hz
- */
-const struct odr_map_t odr_map_in_Hz[] = {
-    {KXTJ3_ODR_0P781, 0.781f},
-    {KXTJ3_ODR_1P563, 1.563f},
-    {KXTJ3_ODR_3P125, 3.125f},
-    {KXTJ3_ODR_6P25, 6.25f},
-    {KXTJ3_ODR_12P5, 12.5f},
-    {KXTJ3_ODR_25, 25.0f},
-    {KXTJ3_ODR_50, 50.0f},
-    {KXTJ3_ODR_100, 100.0f},
-    {KXTJ3_ODR_200, 200.0f},
-    {KXTJ3_ODR_400, 400.0f},
-    {KXTJ3_ODR_800, 800.0f},
-    {KXTJ3_ODR_1600, 1600.0f}};
-/**
- * @brief ODR register values maping with ODR in Hz for
- * wake-up function
- */
-const struct odr_map_t odr_map_in_Hz_wakeup[] = {
-    {KXTJ3_ODR_WAKEUP_0P781, 0.781f},
-    {KXTJ3_ODR_WAKEUP_1P563, 1.563f},
-    {KXTJ3_ODR_WAKEUP_3P125, 3.125f},
-    {KXTJ3_ODR_WAKEUP_6P25, 6.25f},
-    {KXTJ3_ODR_WAKEUP_12P5, 12.5f},
-    {KXTJ3_ODR_WAKEUP_25, 25.0f},
-    {KXTJ3_ODR_WAKEUP_50, 50.0f},
-    {KXTJ3_ODR_WAKEUP_100, 100.0f}};
-
-/**
- * @brief Coordinates structure
- */
-struct Coordinates
-{
-    float x, y, z;
-};
-
-/**
-@brief Inits the I2C connections and returns status of initialization
-
-@param dev The sensor context
-@param bus I2C bus number
-@param addr I2C addr of the sensor
-@return true if initialization successful or false for failure
-*/
-static bool kxtj3_check_mraa_i2c_connection(kxtj3_context dev, int bus, uint8_t addr);
-
-/**
-@brief Checks if the sensor WHO_AM_I value is correct
-
-@param dev The sensor context
-@return true if value correct, or false if mismatch
-*/
-static bool kxtj3_check_who_am_i(kxtj3_context dev);
-
-/**
-@brief Calculates the ODR sample time from an ODR register value
-
-@param odr One of KXTJ3_ODR_T values of ODR register configurations
-@return the float time value
-*/
-static float kxtj3_odr_val_to_sec(KXTJ3_ODR_T odr);
-
-/**
-@brief Calculates the ODR sample time from an ODR register value for wake-up function
-
-@param odr One of KXTJ3_ODR_WAKEUP_T values of ODR register configurations for wake-up
-@return the float time value
-*/
-static float kxtj3_odr_val_to_sec_wakeup(KXTJ3_ODR_WAKEUP_T odr);
-
-/**
-@brief Sets the sensor default values for ODR, resolution (with its scale),
-G range (both normal and wake-up modes)
-
-@param dev The sensor context
-*/
-static void kxtj3_set_default_values(const kxtj3_context dev);
-
-/**
-@brief Read the value of a provided register
-
-@param dev The sensor context
-@param reg The register address to read from
-@param data A pointer to variable for storing the value read
-@return A UPM result
-*/
-static upm_result_t kxtj3_read_register(const kxtj3_context dev, uint8_t reg, uint8_t *data);
-
-/**
-@brief Read the values starting from a provided register, of specific length
-
-@param dev The sensor context
-@param reg The register address to start reading from
-@param data A pointer to variable for storing the value read
-@param len The number of bytes to read
-@return A UPM result
-*/
-static upm_result_t kxtj3_read_registers(const kxtj3_context dev, uint8_t reg, uint8_t *data, int len);
-
-/**
-@brief Writes a value to a provided register
-
-@param dev The sensor context
-@param reg The register address to write to
-@param val byte of data to write
-@return A UPM result
-*/
-static upm_result_t kxtj3_write_register(const kxtj3_context dev, uint8_t reg, uint8_t val);
-
-/**
-@brief Sets a specific bit on in a provided register
-
-@param dev The sensor context
-@param reg register to write into
-@param bit_mask The bit to set, as a register mask
-@return A UPM result
-*/
-static upm_result_t kxtj3_set_bit_on(const kxtj3_context dev, uint8_t reg, uint8_t bit_mask);
-
-/**
-@brief Clear a specific bit (set off) in a provided register
-
-@param dev The sensor context
-@param reg register address to write into
-@param bit_mask The bit to set, as a register mask
-@return A UPM result
-*/
-static upm_result_t kxtj3_set_bit_off(const kxtj3_context dev, uint8_t reg, uint8_t bit_mask);
-
-/**
-@brief Sets a register value or its bits according to a provided mask
-
-@param dev The sensor context
-@param reg The register address to write to
-@param val byte data to write
-@param bit_mask The bits or register mask
-@return A UPM result
-*/
-static upm_result_t kxtj3_set_bits_with_mask(const kxtj3_context dev, uint8_t reg, uint8_t val, uint8_t bit_mask);
-
-/**
-@brief Checks whether a given G range setting uses 14-bit mode
-
-@param g_range One of KXTJ3_G_RANGE_T value for available acceleration settings
-@return true if range is 14-bit based, false otherwise
-*/
-static bool kxtj3_is_14_bit_range(KXTJ3_G_RANGE_T g_range_mode);
-
-/**
-@brief Maps the acceleration_scale (that is used to calculate the acceleration data in g unit)
-with the G range and resolution mode. Changes the acceleration_scale value in sensor context.
-
-@param dev The sensor context
-@param g_range The G range setting, one of KXTJ3_G_RANGE_T values
-*/
-static void kxtj3_map_g_range_to_resolution(kxtj3_context dev, KXTJ3_G_RANGE_T g_range);
-/**
-@brief Calculates the average of coordinates for a sample of data (SELF_TEST_SAMPLE_COUNT).
-This is used by the self-test functionality.
-
-@param dev The sensor context
-@return Coordinates struct that contains value of x, y and z
-*/
-static struct Coordinates kxtj3_get_sample_averaged_data(kxtj3_context dev);
-
-/**
-@brief Check whether the self-test acceleration data difference is within the permitted threshold (0.5g)
-
-@param before The Coordinates struct before the self-test
-@param during The Coordinates struct of the self-test
-@return true if difference is below threshold, false otherwise
-*/
-static bool kxtj3_check_self_test_difference(struct Coordinates before, struct Coordinates during);
-
-/**
-@brief Checks the digital communication register (DCST_RESP) register value with an expected value
-
-@param dev The sensor context
-@param expected_val The expected byte value of the register
-@return true if values match, false otherwise.
-*/
-static bool kxtj3_check_digital_communication_reg_value(kxtj3_context dev, uint8_t expected_val);
-
-/**
-@brief Gets the count value from a given time (in seconds) for the wake-up function.
-Used by the wake-up motion counter and non-activity counter before another wake-up functions.
-
-@param dev The sensor context
-@param time_sec Time in seconds to be converted
-@return the count value as a uint8_t
-*/
-static uint8_t kxtj3_get_wakeup_count_from_time_sec(kxtj3_context dev, float time_sec);
-
-/**
-@brief Gets the count value from a given acceleration threshold (in g) for the wake-up function.
-Used by wake-up threshold counter functionality.
-
-@param dev The sensor context
-@param g_threshold acceleration value in g to be converted
-@return the count value as a uint16_t (expected range up to 4096)
-*/
-static uint16_t kxtj3_get_wakeup_threshold_count_from_g(kxtj3_context dev, float g_threshold);
-
-// Register Read/Write helper functions
-static upm_result_t kxtj3_read_register(const kxtj3_context dev, uint8_t reg, uint8_t *data)
-{
-    int value = mraa_i2c_read_byte_data(dev->i2c, reg);
-    if (value == -1)
-    {
-        printf("%s: mraa_i2c_read_byte_data() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    *data = (uint8_t)value;
-    return UPM_SUCCESS;
-}
-
-static upm_result_t kxtj3_read_registers(const kxtj3_context dev, uint8_t reg, uint8_t *data, int len)
-{
-    if (mraa_i2c_read_bytes_data(dev->i2c, reg, data, len) != (int)len)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-static upm_result_t kxtj3_write_register(const kxtj3_context dev, uint8_t reg, uint8_t val)
-{
-    if (mraa_i2c_write_byte_data(dev->i2c, val, reg) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_i2c_write_byte_data() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-static upm_result_t kxtj3_set_bit_on(const kxtj3_context dev, uint8_t reg, uint8_t bit_mask)
-{
-    uint8_t reg_value;
-    if (kxtj3_read_register(dev, reg, &reg_value) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    reg_value |= bit_mask;
-    return kxtj3_write_register(dev, reg, reg_value);
-}
-
-static upm_result_t kxtj3_set_bit_off(const kxtj3_context dev, uint8_t reg, uint8_t bit_mask)
-{
-    uint8_t reg_value;
-    if (kxtj3_read_register(dev, reg, &reg_value) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    reg_value &= ~bit_mask;
-    return kxtj3_write_register(dev, reg, reg_value);
-}
-
-static upm_result_t kxtj3_set_bits_with_mask(const kxtj3_context dev, uint8_t reg, uint8_t val, uint8_t bit_mask)
-{
-    uint8_t reg_val;
-    if (kxtj3_read_register(dev, reg, &reg_val) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    reg_val &= ~bit_mask;
-    reg_val |= val;
-    return kxtj3_write_register(dev, reg, reg_val);
-}
-// End of register Read/Write helper functions
-
-static bool kxtj3_check_mraa_i2c_connection(kxtj3_context dev, int bus, uint8_t addr)
-{
-    if (mraa_init() != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed.\n", __FUNCTION__);
-        kxtj3_close(dev);
-        return false;
-    }
-
-    if (!(dev->i2c = mraa_i2c_init(bus)))
-    {
-        printf("%s: mraa_i2c_init() failed.\n", __FUNCTION__);
-        kxtj3_close(dev);
-        return false;
-    }
-
-    if (mraa_i2c_address(dev->i2c, addr))
-    {
-        printf("%s: mraa_i2c_address() failed.\n", __FUNCTION__);
-        kxtj3_close(dev);
-        return false;
-    }
-
-    return true;
-}
-
-static bool kxtj3_check_who_am_i(kxtj3_context dev)
-{
-    uint8_t who_am_i;
-    kxtj3_get_who_am_i(dev, &who_am_i);
-    if (who_am_i != KXTJ3_WHO_AM_I_WIA_ID)
-    {
-        printf("%s: Wrong WHO AM I received, expected: 0x%x | got: 0x%x\n", __FUNCTION__,
-               KXTJ3_WHO_AM_I_WIA_ID, who_am_i);
-        kxtj3_close(dev);
-        return false;
-    }
-    return true;
-}
-
-static float kxtj3_odr_val_to_sec(KXTJ3_ODR_T odr)
-{
-    for (size_t i = 0; i < (sizeof(odr_map_in_Hz) / sizeof(struct odr_map_t)); i++)
-        if (odr == odr_map_in_Hz[i].odr_reg_bit)
-            return (1 / odr_map_in_Hz[i].odr_in_Hz);
-
-    return -1;
-}
-
-static float kxtj3_odr_val_to_sec_wakeup(KXTJ3_ODR_WAKEUP_T odr)
-{
-    for (size_t i = 0; i < (sizeof(odr_map_in_Hz_wakeup) / sizeof(struct odr_map_t)); i++)
-        if (odr == odr_map_in_Hz_wakeup[i].odr_reg_bit)
-            return (1 / odr_map_in_Hz_wakeup[i].odr_in_Hz);
-
-    return -1;
-}
-
-static void kxtj3_set_default_values(const kxtj3_context dev)
-{
-    dev->g_range_mode = KXTJ3_RANGE_2G;
-    dev->acceleration_scale = RANGE_2G_8BIT_STEP;
-    dev->res_mode = LOW_RES;
-    dev->odr = KXTJ3_ODR_50;
-    dev->odr_in_sec = kxtj3_odr_val_to_sec(dev->odr);
-    dev->odr_wakeup = KXTJ3_ODR_WAKEUP_0P781;
-    dev->odr_in_sec_wakeup = kxtj3_odr_val_to_sec_wakeup(dev->odr_wakeup);
-}
-
-kxtj3_context kxtj3_init(int bus, uint8_t addr)
-{
-    kxtj3_context dev = (kxtj3_context)malloc(sizeof(struct _kxtj3_context));
-    if (!dev)
-        return NULL;
-
-    dev->i2c = NULL;
-    dev->interrupt_pin = NULL;
-
-    if (!kxtj3_check_mraa_i2c_connection(dev, bus, addr))
-        return NULL;
-
-    if (!kxtj3_check_who_am_i(dev))
-        return NULL;
-
-    kxtj3_set_default_values(dev);
-
-    kxtj3_set_odr_wakeup_function(dev, dev->odr_wakeup);
-    kxtj3_sensor_init(dev, dev->odr, dev->res_mode, dev->g_range_mode);
-
-    return dev;
-}
-
-upm_result_t kxtj3_sensor_init(const kxtj3_context dev, KXTJ3_ODR_T odr, KXTJ3_RESOLUTION_T res, KXTJ3_G_RANGE_T g_range)
-{
-    assert(dev != NULL);
-    if (kxtj3_set_sensor_standby(dev) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if (kxtj3_set_odr(dev, odr) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t g_range_with_res = 0;
-    if (res)
-        g_range_with_res |= KXTJ3_CTRL_REG1_RES;
-
-    g_range_with_res |= (g_range & KXTJ3_CTRL_REG1_GSEL_MASK);
-    if (kxtj3_set_bits_with_mask(dev, KXTJ3_CTRL_REG1, g_range_with_res,
-                                 KXTJ3_CTRL_REG1_RES | KXTJ3_CTRL_REG1_GSEL_MASK) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    dev->g_range_mode = g_range;
-    dev->res_mode = res;
-    kxtj3_map_g_range_to_resolution(dev, dev->g_range_mode);
-
-    if (kxtj3_set_sensor_active(dev) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t kxtj3_get_who_am_i(const kxtj3_context dev, uint8_t *data)
-{
-    assert(dev != NULL);
-    return kxtj3_read_register(dev, KXTJ3_WHO_AM_I, data);
-}
-
-void kxtj3_close(kxtj3_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->i2c)
-    {
-        mraa_i2c_stop(dev->i2c);
-    }
-
-    if (dev->interrupt_pin)
-        kxtj3_uninstall_isr(dev);
-
-    free(dev);
-}
-
-upm_result_t kxtj3_set_sensor_active(const kxtj3_context dev)
-{
-    assert(dev != NULL);
-    return kxtj3_set_bit_on(dev, KXTJ3_CTRL_REG1, KXTJ3_CTRL_REG1_PC);
-}
-
-upm_result_t kxtj3_set_sensor_standby(const kxtj3_context dev)
-{
-    assert(dev != NULL);
-    return kxtj3_set_bit_off(dev, KXTJ3_CTRL_REG1, KXTJ3_CTRL_REG1_PC);
-}
-
-static void kxtj3_map_g_range_to_resolution(kxtj3_context dev, KXTJ3_G_RANGE_T g_range)
-{
-    if (dev->res_mode == LOW_RES)
-        switch (g_range)
-        {
-        case KXTJ3_RANGE_2G:
-            dev->acceleration_scale = RANGE_2G_8BIT_STEP;
-            break;
-        case KXTJ3_RANGE_4G:
-            dev->acceleration_scale = RANGE_4G_8BIT_STEP;
-            break;
-        case KXTJ3_RANGE_8G:
-            dev->acceleration_scale = RANGE_8G_8BIT_STEP;
-            break;
-        case KXTJ3_RANGE_16G:
-        case KXTJ3_RANGE_16G_2:
-        case KXTJ3_RANGE_16G_3:
-            dev->acceleration_scale = RANGE_16G_8BIT_STEP;
-            break;
-
-        case KXTJ3_RANGE_8G_14:
-            kxtj3_set_resolution(dev, HIGH_RES);
-            dev->acceleration_scale = RANGE_8G_14BIT_STEP;
-            break;
-        case KXTJ3_RANGE_16G_14:
-            kxtj3_set_resolution(dev, HIGH_RES);
-            dev->acceleration_scale = RANGE_16G_14BIT_STEP;
-            break;
-        }
-    else
-        switch (g_range)
-        {
-        case KXTJ3_RANGE_2G:
-            dev->acceleration_scale = RANGE_2G_12BIT_STEP;
-            break;
-        case KXTJ3_RANGE_4G:
-            dev->acceleration_scale = RANGE_4G_12BIT_STEP;
-            break;
-        case KXTJ3_RANGE_8G:
-            dev->acceleration_scale = RANGE_8G_12BIT_STEP;
-            break;
-        case KXTJ3_RANGE_16G:
-        case KXTJ3_RANGE_16G_2:
-        case KXTJ3_RANGE_16G_3:
-            dev->acceleration_scale = RANGE_16G_12BIT_STEP;
-            break;
-
-        case KXTJ3_RANGE_8G_14:
-            dev->acceleration_scale = RANGE_8G_14BIT_STEP;
-            break;
-        case KXTJ3_RANGE_16G_14:
-            dev->acceleration_scale = RANGE_16G_14BIT_STEP;
-            break;
-        }
-}
-
-upm_result_t kxtj3_set_g_range(const kxtj3_context dev, KXTJ3_G_RANGE_T g_range)
-{
-    assert(dev != NULL);
-
-    if (kxtj3_set_bits_with_mask(dev, KXTJ3_CTRL_REG1, g_range, KXTJ3_CTRL_REG1_GSEL_MASK) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    dev->g_range_mode = g_range;
-    kxtj3_map_g_range_to_resolution(dev, g_range);
-    return UPM_SUCCESS;
-}
-
-upm_result_t kxtj3_set_resolution(const kxtj3_context dev, KXTJ3_RESOLUTION_T resolution)
-{
-    assert(dev != NULL);
-
-    if (resolution == HIGH_RES)
-    {
-        if (kxtj3_set_bit_on(dev, KXTJ3_CTRL_REG1, KXTJ3_CTRL_REG1_RES) != UPM_SUCCESS)
-            return UPM_ERROR_OPERATION_FAILED;
-    }
-    else
-    {
-        if (kxtj3_set_bit_off(dev, KXTJ3_CTRL_REG1, KXTJ3_CTRL_REG1_RES != UPM_SUCCESS))
-            return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    dev->res_mode = resolution;
-    kxtj3_map_g_range_to_resolution(dev, dev->g_range_mode);
-    return UPM_SUCCESS;
-}
-
-upm_result_t kxtj3_set_odr(const kxtj3_context dev, KXTJ3_ODR_T odr)
-{
-    assert(dev != NULL);
-    if (kxtj3_set_bits_with_mask(dev, KXTJ3_DATA_CTRL_REG, odr, KXTJ3_DATA_CTRL_REG_OSA_MASK) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    dev->odr = odr;
-    dev->odr_in_sec = kxtj3_odr_val_to_sec(odr);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t kxtj3_set_odr_wakeup_function(const kxtj3_context dev, KXTJ3_ODR_WAKEUP_T odr)
-{
-    assert(dev != NULL);
-    if (kxtj3_set_bits_with_mask(dev, KXTJ3_CTRL_REG2, odr, KXTJ3_CTRL_REG2_OWUF_MASK) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-    dev->odr_wakeup = odr;
-    dev->odr_in_sec_wakeup = kxtj3_odr_val_to_sec_wakeup(odr);
-
-    return UPM_SUCCESS;
-}
-
-static bool kxtj3_check_digital_communication_reg_value(kxtj3_context dev, uint8_t expected_val)
-{
-    uint8_t dcst_reg;
-    if (kxtj3_read_register(dev, KXTJ3_DCST_RESP, &dcst_reg) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if (dcst_reg != expected_val)
-        return false;
-
-    return true;
-}
-
-upm_result_t kxtj3_self_test_digital_communication(kxtj3_context dev)
-{
-    assert(dev != NULL);
-    if (!kxtj3_check_digital_communication_reg_value(dev, KXTJ3_DCST_RESP_DCSTR_BEFORE))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if (kxtj3_set_bit_on(dev, KXTJ3_CTRL_REG2, KXTJ3_CTRL_REG2_DCST) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if (!kxtj3_check_digital_communication_reg_value(dev, KXTJ3_DCST_RESP_DCSTR_AFTER))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if (!kxtj3_check_digital_communication_reg_value(dev, KXTJ3_DCST_RESP_DCSTR_BEFORE))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-static struct Coordinates kxtj3_get_sample_averaged_data(kxtj3_context dev)
-{
-    struct Coordinates coordinates_averaged_sample;
-    coordinates_averaged_sample.x = 0.0f;
-    coordinates_averaged_sample.y = 0.0f;
-    coordinates_averaged_sample.z = 0.0f;
-
-    float wait_time = kxtj3_get_acceleration_sampling_period(dev) * SECOND_IN_MICRO_S;
-    float x, y, z;
-    for (size_t i = 0; i < SELF_TEST_SAMPLE_COUNT; i++)
-    {
-        kxtj3_get_acceleration_data(dev, &x, &y, &z);
-        coordinates_averaged_sample.x += fabs((x / EARTH_GRAVITY));
-        coordinates_averaged_sample.y += fabs((y / EARTH_GRAVITY));
-        coordinates_averaged_sample.z += fabs((z / EARTH_GRAVITY));
-        upm_delay_us(wait_time);
-    }
-
-    coordinates_averaged_sample.x /= SELF_TEST_SAMPLE_COUNT;
-    coordinates_averaged_sample.y /= SELF_TEST_SAMPLE_COUNT;
-    coordinates_averaged_sample.z /= SELF_TEST_SAMPLE_COUNT;
-
-    return coordinates_averaged_sample;
-}
-
-static bool kxtj3_check_self_test_difference(struct Coordinates before, struct Coordinates during)
-{
-    struct Coordinates difference;
-    difference.x = fabs(before.x - during.x);
-    difference.y = fabs(before.y - during.y);
-    difference.z = fabs(before.z - during.z);
-
-    if (difference.x > SELF_TEST_DIFFERENCE_THRESHOLD)
-    {
-        printf("%s: X-asix FAILED, change on X difference: %.2f\n", __FUNCTION__, difference.x);
-        return false;
-    }
-
-    if (difference.y > SELF_TEST_DIFFERENCE_THRESHOLD)
-    {
-        printf("%s: Y-asix FAILED, change on Y difference: %.2f\n", __FUNCTION__, difference.y);
-        return false;
-    }
-
-    if (difference.z > SELF_TEST_DIFFERENCE_THRESHOLD)
-    {
-        printf("%s: Z-asix FAILED, change on Z difference: %.2f\n", __FUNCTION__, difference.z);
-        return false;
-    }
-
-    return true;
-}
-
-upm_result_t kxtj3_sensor_self_test(kxtj3_context dev)
-{
-    assert(dev != NULL);
-
-    struct Coordinates coordinates_before_test, coordinates_during_test;
-    coordinates_before_test = kxtj3_get_sample_averaged_data(dev);
-
-    uint8_t stpol_val;
-    kxtj3_read_register(dev, KXTJ3_INT_CTRL_REG1, &stpol_val);
-
-    kxtj3_set_sensor_standby(dev);
-    kxtj3_set_bit_on(dev, KXTJ3_INT_CTRL_REG1, KXTJ3_INT_CTRL_REG1_STPOL);
-    kxtj3_write_register(dev, KXTJ3_SELF_TEST, KXTJ3_SELF_TEST_MEMS_TEST_ENABLE);
-    kxtj3_set_bit_off(dev, KXTJ3_INT_CTRL_REG1, KXTJ3_INT_CTRL_REG1_STPOL);
-    kxtj3_set_sensor_active(dev);
-
-    coordinates_during_test = kxtj3_get_sample_averaged_data(dev);
-    kxtj3_write_register(dev, KXTJ3_SELF_TEST, KXTJ3_SELF_TEST_MEMS_TEST_DISABLE);
-
-    if (!kxtj3_check_self_test_difference(coordinates_before_test, coordinates_during_test))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    kxtj3_set_sensor_standby(dev);
-    if (kxtj3_self_test_digital_communication(dev) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-    return kxtj3_set_sensor_active(dev);
-}
-
-upm_result_t kxtj3_sensor_software_reset(const kxtj3_context dev)
-{
-    assert(dev != NULL);
-    if (kxtj3_set_bit_on(dev, KXTJ3_CTRL_REG2, KXTJ3_CTRL_REG2_SRST) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    uint8_t ctrl_reg2_data;
-    kxtj3_read_register(dev, KXTJ3_CTRL_REG2, &ctrl_reg2_data);
-
-    uint8_t srst_counter = 0;
-    while ((ctrl_reg2_data & KXTJ3_CTRL_REG2_SRST) != 0x00 && srst_counter < SW_RESET_MAX_LOOP_COUNT)
-    {
-        upm_delay_us(SW_RESET_READ_WAIT_MICRO_S);
-        kxtj3_read_register(dev, KXTJ3_CTRL_REG2, &ctrl_reg2_data);
-        srst_counter++;
-    }
-
-    if (srst_counter == SW_RESET_MAX_LOOP_COUNT)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-static bool kxtj3_is_14_bit_range(KXTJ3_G_RANGE_T g_range_mode)
-{
-    return g_range_mode == KXTJ3_RANGE_8G_14 || g_range_mode == KXTJ3_RANGE_16G_14;
-}
-
-upm_result_t kxtj3_get_acceleration_data_raw(const kxtj3_context dev, float *x, float *y, float *z)
-{
-    uint8_t buffer[DATA_BUFFER_LENGTH];
-    if (kxtj3_read_registers(dev, KXTJ3_XOUT_L, buffer, DATA_BUFFER_LENGTH) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if (dev->res_mode == HIGH_RES)
-    {
-        uint8_t shift_amount = 4;
-        if (kxtj3_is_14_bit_range(dev->g_range_mode))
-            shift_amount = 2;
-
-        if (x)
-            *x = (float)((int16_t)((buffer[1] << 8) | buffer[0]) >> shift_amount);
-        if (y)
-            *y = (float)((int16_t)((buffer[3] << 8) | buffer[2]) >> shift_amount);
-        if (z)
-            *z = (float)((int16_t)((buffer[5] << 8) | buffer[4]) >> shift_amount);
-    }
-    else
-    {
-        if (x)
-            *x = (float)(int8_t)buffer[1];
-        if (y)
-            *y = (float)(int8_t)buffer[3];
-        if (z)
-            *z = (float)(int8_t)buffer[5];
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t kxtj3_get_acceleration_data(const kxtj3_context dev, float *x, float *y, float *z)
-{
-    float x_raw, y_raw, z_raw;
-
-    if (kxtj3_get_acceleration_data_raw(dev, &x_raw, &y_raw, &z_raw) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if (x)
-        *x = (x_raw * dev->acceleration_scale) * EARTH_GRAVITY;
-    if (y)
-        *y = (y_raw * dev->acceleration_scale) * EARTH_GRAVITY;
-    if (z)
-        *z = (z_raw * dev->acceleration_scale) * EARTH_GRAVITY;
-
-    return UPM_SUCCESS;
-}
-
-float kxtj3_get_acceleration_sampling_period(kxtj3_context dev)
-{
-    return dev->odr_in_sec;
-}
-
-float kxtj3_get_wakeup_sampling_period(kxtj3_context dev)
-{
-    return dev->odr_in_sec_wakeup;
-}
-
-upm_result_t kxtj3_enable_data_ready_interrupt(const kxtj3_context dev)
-{
-    assert(dev != NULL);
-    return kxtj3_set_bit_on(dev, KXTJ3_CTRL_REG1, KXTJ3_CTRL_REG1_DRDYE);
-}
-
-upm_result_t kxtj3_disable_data_ready_interrupt(const kxtj3_context dev)
-{
-    assert(dev != NULL);
-    return kxtj3_set_bit_off(dev, KXTJ3_CTRL_REG1, KXTJ3_CTRL_REG1_DRDYE);
-}
-
-upm_result_t kxtj3_enable_wakeup_interrupt(const kxtj3_context dev)
-{
-    assert(dev != NULL);
-    return kxtj3_set_bit_on(dev, KXTJ3_CTRL_REG1, KXTJ3_CTRL_REG1_WUFE);
-}
-
-upm_result_t kxtj3_disable_wakeup_interrupt(const kxtj3_context dev)
-{
-    assert(dev != NULL);
-    return kxtj3_set_bit_off(dev, KXTJ3_CTRL_REG1, KXTJ3_CTRL_REG1_WUFE);
-}
-
-upm_result_t kxtj3_enable_interrupt_pin(const kxtj3_context dev, KXTJ3_INTERRUPT_POLARITY_T polarity,
-                                        KXTJ3_INTERRUPT_RESPONSE_T response_type)
-{
-    assert(dev != NULL);
-    uint8_t int_reg_value;
-    kxtj3_read_register(dev, KXTJ3_INT_CTRL_REG1, &int_reg_value);
-
-    if (polarity)
-        polarity = KXTJ3_INT_CTRL_REG1_IEA;
-    if (response_type)
-        response_type = KXTJ3_INT_CTRL_REG1_IEL;
-
-    int_reg_value &= ~(KXTJ3_INT_CTRL_REG1_IEA | KXTJ3_INT_CTRL_REG1_IEL);
-    int_reg_value |= (KXTJ3_INT_CTRL_REG1_IEN | polarity | response_type);
-
-    return kxtj3_write_register(dev, KXTJ3_INT_CTRL_REG1, int_reg_value);
-}
-
-upm_result_t kxtj3_disable_interrupt_pin(const kxtj3_context dev)
-{
-    assert(dev != NULL);
-    return kxtj3_set_bit_off(dev, KXTJ3_INT_CTRL_REG1, KXTJ3_INT_CTRL_REG1_IEN);
-}
-
-upm_result_t kxtj3_set_interrupt_polarity(const kxtj3_context dev, KXTJ3_INTERRUPT_POLARITY_T polarity)
-{
-    assert(dev != NULL);
-    if (polarity == ACTIVE_HIGH)
-        return kxtj3_set_bit_on(dev, KXTJ3_INT_CTRL_REG1, KXTJ3_INT_CTRL_REG1_IEA);
-
-    return kxtj3_set_bit_off(dev, KXTJ3_INT_CTRL_REG1, KXTJ3_INT_CTRL_REG1_IEA);
-}
-
-upm_result_t kxtj3_set_interrupt_response(const kxtj3_context dev, KXTJ3_INTERRUPT_RESPONSE_T response_type)
-{
-    assert(dev != NULL);
-    if (response_type == LATCH_UNTIL_CLEARED)
-        return kxtj3_set_bit_on(dev, KXTJ3_INT_CTRL_REG1, KXTJ3_INT_CTRL_REG1_IEL);
-
-    return kxtj3_set_bit_off(dev, KXTJ3_INT_CTRL_REG1, KXTJ3_INT_CTRL_REG1_IEL);
-}
-
-bool kxtj3_get_interrupt_status(const kxtj3_context dev)
-{
-    assert(dev != NULL);
-    uint8_t status_reg_value;
-    kxtj3_read_register(dev, KXTJ3_STATUS_REG, &status_reg_value);
-    if (!(status_reg_value & KXTJ3_STATUS_REG_INT))
-        return false;
-
-    return true;
-}
-
-upm_result_t kxtj3_read_interrupt_source1_reg(const kxtj3_context dev, uint8_t *reg_value)
-{
-    assert(dev != NULL);
-    return kxtj3_read_register(dev, KXTJ3_INT_SOURCE1, reg_value);
-}
-
-KXTJ3_INTERRUPT_SOURCE_T kxtj3_get_interrupt_source(const kxtj3_context dev)
-{
-    assert(dev != NULL);
-    if (kxtj3_get_interrupt_status(dev))
-    {
-        uint8_t int_source_reg;
-        kxtj3_read_interrupt_source1_reg(dev, &int_source_reg);
-
-        int_source_reg &= (KXTJ3_INT_SOURCE1_DRDY | KXTJ3_INT_SOURCE1_WUFS);
-        switch (int_source_reg)
-        {
-        case KXTJ3_INT_SOURCE1_DRDY:
-            return KXTJ3_DATA_READY_INTERRUPT;
-        case KXTJ3_INT_SOURCE1_WUFS:
-            return KXTJ3_WAKEUP_INTERRUPT;
-        case KXTJ3_INT_SOURCE1_DRDY | KXTJ3_INT_SOURCE1_WUFS:
-            return KXTJ3_DATA_READY_AND_WAKEUP_INT;
-        }
-    }
-    return NO_INTERRUPT;
-}
-
-upm_result_t kxtj3_install_isr(const kxtj3_context dev, mraa_gpio_edge_t edge, int pin, void (*isr)(void *), void *isr_args)
-{
-    assert(dev != NULL);
-    mraa_gpio_context isr_gpio = NULL;
-    if (!(isr_gpio = mraa_gpio_init(pin)))
-    {
-        printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    mraa_gpio_dir(isr_gpio, MRAA_GPIO_IN);
-
-    if (mraa_gpio_isr(isr_gpio, edge, isr, isr_args) != MRAA_SUCCESS)
-    {
-        mraa_gpio_close(isr_gpio);
-        printf("%s: mraa_gpio_isr() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    dev->interrupt_pin = isr_gpio;
-    return UPM_SUCCESS;
-}
-
-void kxtj3_uninstall_isr(const kxtj3_context dev)
-{
-    assert(dev != NULL);
-    mraa_gpio_isr_exit(dev->interrupt_pin);
-    mraa_gpio_close(dev->interrupt_pin);
-    dev->interrupt_pin = NULL;
-}
-
-upm_result_t kxtj3_clear_interrupt_information(kxtj3_context dev)
-{
-    assert(dev != NULL);
-    uint8_t int_rel_value;
-    return kxtj3_read_register(dev, KXTJ3_INT_REL, &int_rel_value);
-}
-
-upm_result_t kxtj3_enable_wakeup_single_axis_direction(kxtj3_context dev, KXTJ3_WAKEUP_SOURCE_T axis)
-{
-    assert(dev != NULL);
-    return kxtj3_set_bit_on(dev, KXTJ3_INT_CTRL_REG2, axis);
-}
-
-upm_result_t kxtj3_disable_wakeup_single_axis_direction(kxtj3_context dev, KXTJ3_WAKEUP_SOURCE_T axis)
-{
-    assert(dev != NULL);
-    return kxtj3_set_bit_off(dev, KXTJ3_INT_CTRL_REG2, axis);
-}
-
-kxtj3_wakeup_axes kxtj3_get_wakeup_axis_and_direction(kxtj3_context dev)
-{
-    assert(dev != NULL);
-
-    uint8_t int_source2_value;
-    kxtj3_read_register(dev, KXTJ3_INT_SOURCE2, &int_source2_value);
-
-    kxtj3_wakeup_axes wakeup_axis;
-    wakeup_axis.X_NEGATIVE = false;
-    wakeup_axis.X_POSITIVE = false;
-    wakeup_axis.Y_POSITIVE = false;
-    wakeup_axis.Y_NEGATIVE = false;
-    wakeup_axis.Z_POSITIVE = false;
-    wakeup_axis.Z_NEGATIVE = false;
-
-    if (int_source2_value & KXTJ3_INT_SOURCE2_XPWU)
-        wakeup_axis.X_POSITIVE = true;
-    else if (int_source2_value & KXTJ3_INT_SOURCE2_XNWU)
-        wakeup_axis.X_NEGATIVE = true;
-    if (int_source2_value & KXTJ3_INT_SOURCE2_YPWU)
-        wakeup_axis.Y_POSITIVE = true;
-    else if (int_source2_value & KXTJ3_INT_SOURCE2_YNWU)
-        wakeup_axis.Y_NEGATIVE = true;
-    if (int_source2_value & KXTJ3_INT_SOURCE2_ZPWU)
-        wakeup_axis.Z_POSITIVE = true;
-    else if (int_source2_value & KXTJ3_INT_SOURCE2_ZNWU)
-        wakeup_axis.Z_NEGATIVE = true;
-
-    return wakeup_axis;
-}
-
-upm_result_t kxtj3_enable_wakeup_latch(kxtj3_context dev)
-{
-    assert(dev != NULL);
-    return kxtj3_set_bit_off(dev, KXTJ3_INT_CTRL_REG2, KXTJ3_INT_CTRL_REG2_ULMODE);
-}
-
-upm_result_t kxtj3_disable_wakeup_latch(kxtj3_context dev)
-{
-    assert(dev != NULL);
-    return kxtj3_set_bit_on(dev, KXTJ3_INT_CTRL_REG2, KXTJ3_INT_CTRL_REG2_ULMODE);
-}
-
-upm_result_t kxtj3_set_wakeup_motion_counter(kxtj3_context dev, uint8_t count)
-{
-    assert(dev != NULL);
-    if (count == 0)
-        return UPM_ERROR_OPERATION_FAILED;
-    return kxtj3_write_register(dev, KXTJ3_WAKEUP_COUNTER, count);
-}
-
-static uint8_t kxtj3_get_wakeup_count_from_time_sec(kxtj3_context dev, float time_sec)
-{
-    return time_sec / dev->odr_in_sec_wakeup;
-}
-
-upm_result_t kxtj3_set_wakeup_motion_time(kxtj3_context dev, float desired_time)
-{
-    assert(dev != NULL);
-    uint8_t count = kxtj3_get_wakeup_count_from_time_sec(dev, desired_time);
-    return kxtj3_set_wakeup_motion_counter(dev, count);
-}
-
-upm_result_t kxtj3_get_wakeup_motion_time(kxtj3_context dev, float *out_time)
-{
-    assert(dev != NULL);
-    uint8_t motion_count;
-    if (kxtj3_read_register(dev, KXTJ3_WAKEUP_COUNTER, &motion_count) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    *out_time = (float)motion_count * dev->odr_in_sec_wakeup;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t kxtj3_set_wakeup_non_activity_counter(kxtj3_context dev, uint8_t count)
-{
-    assert(dev != NULL);
-    if (count == 0)
-        return UPM_ERROR_OPERATION_FAILED;
-    return kxtj3_write_register(dev, KXTJ3_NA_COUNTER, count);
-}
-
-upm_result_t kxtj3_set_wakeup_non_activity_time(kxtj3_context dev, float desired_time)
-{
-    assert(dev != NULL);
-    uint8_t count = kxtj3_get_wakeup_count_from_time_sec(dev, desired_time);
-    return kxtj3_set_wakeup_non_activity_counter(dev, count);
-}
-
-upm_result_t kxtj3_get_wakeup_non_activity_time(kxtj3_context dev, float *out_time)
-{
-    assert(dev != NULL);
-    uint8_t non_activity_reg_count;
-    if (kxtj3_read_register(dev, KXTJ3_NA_COUNTER, &non_activity_reg_count) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    *out_time = (float)non_activity_reg_count * dev->odr_in_sec_wakeup;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t kxtj3_set_wakeup_threshold_counter(kxtj3_context dev, uint16_t count)
-{
-    assert(dev != NULL);
-    if (count == 0)
-        return UPM_ERROR_OPERATION_FAILED;
-    if (kxtj3_write_register(dev, KXTJ3_WAKEUP_THRESHOLD_H, (uint8_t)(count >> 4)) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if (kxtj3_write_register(dev, KXTJ3_WAKEUP_THRESHOLD_L, (uint8_t)(count << 4)) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-static uint16_t kxtj3_get_wakeup_threshold_count_from_g(kxtj3_context dev, float g_threshold)
-{
-    return g_threshold * 256;
-}
-
-upm_result_t kxtj3_set_wakeup_threshold_g_value(kxtj3_context dev, float g_threshold)
-{
-    assert(dev != NULL);
-    uint16_t count = kxtj3_get_wakeup_threshold_count_from_g(dev, g_threshold);
-    return kxtj3_set_wakeup_threshold_counter(dev, count);
-}
-
-upm_result_t kxtj3_get_wakeup_threshold(kxtj3_context dev, float *out_threshold)
-{
-    assert(dev != NULL);
-    uint8_t reg_value_h, reg_value_l;
-    if (kxtj3_read_register(dev, KXTJ3_WAKEUP_THRESHOLD_H, &reg_value_h) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if (kxtj3_read_register(dev, KXTJ3_WAKEUP_THRESHOLD_L, &reg_value_l) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    *out_threshold = (float)((uint16_t)((reg_value_h << 8) | reg_value_l) >> 4) / 256;
-
-    return UPM_SUCCESS;
-}
diff --git a/src/kxtj3/kxtj3.cxx b/src/kxtj3/kxtj3.cxx
deleted file mode 100755
index 1afd3fe..0000000
--- a/src/kxtj3/kxtj3.cxx
+++ /dev/null
@@ -1,315 +0,0 @@
-/*
-* The MIT License (MIT)
-*
-* Author: Assam Boudjelthia
-* Copyright (c) 2018 Rohm Semiconductor.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy of
-* this software and associated documentation files (the "Software"), to deal in
-* the Software without restriction, including without limitation the rights to
-* use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-* the Software, and to permit persons to whom the Software is furnished to do so,
-* subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in all
-* copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-* COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-#include <iostream>
-#include <stdexcept>
-#include <string>
-
-#include "kxtj3.hpp"
-
-using namespace upm;
-
-KXTJ3::KXTJ3(int bus, uint8_t addr) : m_kxtj3(kxtj3_init(bus, addr))
-{
-    if (!m_kxtj3)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_init() failed");
-}
-
-KXTJ3::~KXTJ3()
-{
-    kxtj3_close(m_kxtj3);
-}
-
-void KXTJ3::SensorInit(KXTJ3_ODR_T odr, KXTJ3_RESOLUTION_T resolution, KXTJ3_G_RANGE_T g_range)
-{
-    if (kxtj3_sensor_init(m_kxtj3, odr, resolution, g_range) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_sensor_init() failed");
-}
-
-uint8_t KXTJ3::GetWhoAmI()
-{
-    uint8_t who_am_i;
-    if (kxtj3_get_who_am_i(m_kxtj3, &who_am_i) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_get_who_am_i() failed");
-
-    return who_am_i;
-}
-
-void KXTJ3::SensorActive()
-{
-    if (kxtj3_set_sensor_active(m_kxtj3) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_set_sensor_active() failed");
-}
-
-void KXTJ3::SensorStandby()
-{
-    if (kxtj3_set_sensor_standby(m_kxtj3) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_set_sensor_standby() failed");
-}
-
-void KXTJ3::SetGRange(KXTJ3_G_RANGE_T g_range)
-{
-    if (kxtj3_set_g_range(m_kxtj3, g_range) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_set_g_range() failed");
-}
-
-void KXTJ3::SetResolution(KXTJ3_RESOLUTION_T resolution)
-{
-    if (kxtj3_set_resolution(m_kxtj3, resolution) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_set_resolution() failed");
-}
-
-void KXTJ3::SetOdr(KXTJ3_ODR_T odr)
-{
-    if (kxtj3_set_odr(m_kxtj3, odr) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_set_odr() failed");
-}
-
-void KXTJ3::SetOdrForWakeup(KXTJ3_ODR_WAKEUP_T odr)
-{
-    if (kxtj3_set_odr_wakeup_function(m_kxtj3, odr) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_set_odr_wakeup_function() failed");
-}
-
-void KXTJ3::SelfTestDigitalCommunication()
-{
-    if (kxtj3_self_test_digital_communication(m_kxtj3) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_self_test_digital_communication() failed");
-}
-
-void KXTJ3::SensorSelfTest()
-{
-    if (kxtj3_sensor_self_test(m_kxtj3) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_sensor_self_test() failed");
-}
-
-void KXTJ3::SensorSoftwareReset()
-{
-    if (kxtj3_sensor_software_reset(m_kxtj3) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_sensor_software_reset() failed");
-}
-
-std::vector<float> KXTJ3::GetAccelerationRawVector()
-{
-    std::vector<float> xyz(3);
-    if (kxtj3_get_acceleration_data_raw(m_kxtj3, &xyz[0], &xyz[1], &xyz[2]) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_get_acceleration_data_raw() failed");
-
-    return xyz;
-}
-
-std::vector<float> KXTJ3::GetAccelerationVector()
-{
-    std::vector<float> xyz(3);
-    if (kxtj3_get_acceleration_data(m_kxtj3, &xyz[0], &xyz[1], &xyz[2]) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_get_acceleration_data() failed");
-
-    return xyz;
-}
-
-float KXTJ3::GetAccelerationSamplePeriod()
-{
-    return kxtj3_get_acceleration_sampling_period(m_kxtj3);
-}
-
-float KXTJ3::GetWakeUpSamplePeriod()
-{
-    return kxtj3_get_wakeup_sampling_period(m_kxtj3);
-}
-
-void KXTJ3::EnableDataReadyInterrupt()
-{
-    if (kxtj3_enable_data_ready_interrupt(m_kxtj3) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_enable_data_ready_interrupt() failed");
-}
-
-void KXTJ3::DisableDataReadyInterrupt()
-{
-    if (kxtj3_disable_data_ready_interrupt(m_kxtj3) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_disable_data_ready_interrupt() failed");
-}
-
-void KXTJ3::EnableWakeUpInterrupt()
-{
-    if (kxtj3_enable_wakeup_interrupt(m_kxtj3) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_enable_wakeup_interrupt() failed");
-}
-
-void KXTJ3::DisableWakeUpInterrupt()
-{
-    if (kxtj3_disable_wakeup_interrupt(m_kxtj3) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_disable_wakeup_interrupt() failed");
-}
-
-void KXTJ3::EnableInterruptPin(KXTJ3_INTERRUPT_POLARITY_T polarity, KXTJ3_INTERRUPT_RESPONSE_T response_type)
-{
-    if (kxtj3_enable_interrupt_pin(m_kxtj3, polarity, response_type) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_enable_interrupt_pin() failed");
-}
-
-void KXTJ3::DisableInterruptPin()
-{
-    if (kxtj3_disable_interrupt_pin(m_kxtj3) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_disable_interrupt_pin() failed");
-}
-
-void KXTJ3::SetInterruptPolarity(KXTJ3_INTERRUPT_POLARITY_T polarity)
-{
-    if (kxtj3_set_interrupt_polarity(m_kxtj3, polarity) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_set_interrupt_polarity() failed");
-}
-
-void KXTJ3::SetInerruptResponse(KXTJ3_INTERRUPT_RESPONSE_T response_type)
-{
-    if (kxtj3_set_interrupt_response(m_kxtj3, response_type) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_set_interrupt_response() failed");
-}
-
-bool KXTJ3::GetInterruptStatus()
-{
-    return kxtj3_get_interrupt_status(m_kxtj3);
-}
-
-uint8_t KXTJ3::ReadInterruptSource1()
-{
-    uint8_t reg_value;
-    if (kxtj3_read_interrupt_source1_reg(m_kxtj3, &reg_value) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_read_interrupt_source1_reg() failed");
-
-    return reg_value;
-}
-
-KXTJ3_INTERRUPT_SOURCE_T KXTJ3::GetInterruptSource()
-{
-    return kxtj3_get_interrupt_source(m_kxtj3);
-}
-
-void KXTJ3::InstallIsr(mraa_gpio_edge_t edge, int pin, void (*isr)(void *), void *isr_args)
-{
-    if (kxtj3_install_isr(m_kxtj3, edge, pin, isr, isr_args) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_install_isr() failed");
-}
-
-void KXTJ3::UninstallIsr()
-{
-    kxtj3_uninstall_isr(m_kxtj3);
-}
-
-void KXTJ3::ClearInterrupt()
-{
-    if (kxtj3_clear_interrupt_information(m_kxtj3) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_clear_interrupt_information() failed");
-}
-
-void KXTJ3::EnableWakeUpSingleAxisDirection(KXTJ3_WAKEUP_SOURCE_T axis)
-{
-    if (kxtj3_enable_wakeup_single_axis_direction(m_kxtj3, axis) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_enable_wakeup_single_axis_direction() failed");
-}
-
-void KXTJ3::DisableWakeUpSingleAxisDirection(KXTJ3_WAKEUP_SOURCE_T axis)
-{
-    if (kxtj3_disable_wakeup_single_axis_direction(m_kxtj3, axis) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_disable_wakeup_single_axis_direction() failed");
-}
-
-kxtj3_wakeup_axes KXTJ3::GetWakeUpAxisDirection()
-{
-    return kxtj3_get_wakeup_axis_and_direction(m_kxtj3);
-}
-
-void KXTJ3::EnableWakeUpLatch()
-{
-    if (kxtj3_enable_wakeup_latch(m_kxtj3) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_enable_wakeup_latch() failed");
-}
-
-void KXTJ3::DisableWakeUpLatch()
-{
-    if (kxtj3_disable_wakeup_latch(m_kxtj3) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_disable_wakeup_latch() failed");
-}
-
-void KXTJ3::SetWakeUpMotionCounter(uint8_t count)
-{
-    if (kxtj3_set_wakeup_motion_counter(m_kxtj3, count) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_set_wakeup_motion_counter() failed");
-}
-
-void KXTJ3::SetWakeUpMotionTime(float desired_time)
-{
-    if (kxtj3_set_wakeup_motion_time(m_kxtj3, desired_time) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_set_wakeup_motion_time() failed");
-}
-
-float KXTJ3::GetWakeUpMotionTime()
-{
-    float out_time;
-    if (kxtj3_get_wakeup_motion_time(m_kxtj3, &out_time) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_get_wakeup_motion_time() failed");
-
-    return out_time;
-}
-
-void KXTJ3::SetWakeUpNonActivityCounter(uint8_t count)
-{
-    if (kxtj3_set_wakeup_non_activity_counter(m_kxtj3, count) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_set_wakeup_non_activity_counter() failed");
-}
-
-void KXTJ3::SetWakeUpNonActivityTime(float desired_time)
-{
-    if (kxtj3_set_wakeup_non_activity_time(m_kxtj3, desired_time) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_set_wakeup_non_activity_time() failed");
-}
-
-float KXTJ3::GetWakeUpNonActivityTime()
-{
-    float out_time;
-    if (kxtj3_get_wakeup_non_activity_time(m_kxtj3, &out_time) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_get_wakeup_non_activity_time() failed");
-
-    return out_time;
-}
-
-void KXTJ3::SetWakeUpThresholdCounter(uint16_t count)
-{
-    if (kxtj3_set_wakeup_threshold_counter(m_kxtj3, count) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_set_wakeup_threshold_counter() failed");
-}
-
-void KXTJ3::SetWakeUpThresholdGRange(float g_threshold)
-{
-    if (kxtj3_set_wakeup_threshold_g_value(m_kxtj3, g_threshold) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_set_wakeup_threshold_g_value() failed");
-}
-
-float KXTJ3::GetWakeUpThresholdGRange()
-{
-    float out_threshold;
-    if (kxtj3_get_wakeup_threshold(m_kxtj3, &out_threshold) != UPM_SUCCESS)
-        throw std::runtime_error(std::string(__FUNCTION__) + "kxtj3_get_wakeup_threshold() failed");
-
-    return out_threshold;
-}
\ No newline at end of file
diff --git a/src/kxtj3/kxtj3.h b/src/kxtj3/kxtj3.h
deleted file mode 100755
index 58da74e..0000000
--- a/src/kxtj3/kxtj3.h
+++ /dev/null
@@ -1,746 +0,0 @@
-/*
-* The MIT License (MIT)
-*
-* Author: Assam Boudjelthia
-* Copyright (c) 2018 Rohm Semiconductor.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy of
-* this software and associated documentation files (the "Software"), to deal in
-* the Software without restriction, including without limitation the rights to
-* use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-* the Software, and to permit persons to whom the Software is furnished to do so,
-* subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in all
-* copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-* COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-#pragma once
-
-#ifdef __cplusplus
-extern "C"
-{
-#endif
-
-#include <assert.h>
-#include <unistd.h>
-
-#include <mraa/i2c.h>
-#include <mraa/gpio.h>
-#include <upm.h>
-
-#include "kxtj3_registers.h"
-
-  /**
- * @brief C API for the kxtj3 driver
- * @defgroup kxtj3 libupm-kxtj3
- * @ingroup Kionix i2c accelerometer
- *
- * @include kxtj3.c
- */
-
-  /**
- * @library kxtj3
- * @sensor kxtj3
- * @comname tri-axis accelerometer
- * @type accelerometer
- * @man Kionix
- * @con i2c
- *
- * @brief C API for the kxtj3 driver
- *
- * @image html kxtj3.png
- */
-
-#define SECOND_IN_MICRO_S 1000000
-
-  /**
- * @brief Resolution types
- */
-  typedef enum
-  {
-    LOW_RES,
-    HIGH_RES
-  } KXTJ3_RESOLUTION_T;
-
-  /**
- * @brief Interrupt polarity types
- */
-  typedef enum
-  {
-    ACTIVE_LOW,
-    ACTIVE_HIGH
-
-  } KXTJ3_INTERRUPT_POLARITY_T;
-
-  /**
- * @brief Interrupt response types
- */
-  typedef enum
-  {
-    LATCH_UNTIL_CLEARED,
-    TRANSMIT_ONE_PULSE
-  } KXTJ3_INTERRUPT_RESPONSE_T;
-
-  /**
- * @brief Interrupt sources
- */
-  typedef enum
-  {
-    NO_INTERRUPT,
-    KXTJ3_DATA_READY_INTERRUPT = KXTJ3_INT_SOURCE1_DRDY,
-    KXTJ3_WAKEUP_INTERRUPT = KXTJ3_INT_SOURCE1_WUFS,
-    KXTJ3_DATA_READY_AND_WAKEUP_INT = KXTJ3_INT_SOURCE1_DRDY | KXTJ3_INT_SOURCE1_WUFS
-  } KXTJ3_INTERRUPT_SOURCE_T;
-
-  /**
- * @brief Acceleration ranges
- */
-  typedef enum
-  {
-    KXTJ3_RANGE_2G = KXTJ3_CTRL_REG1_GSEL_2G,
-    KXTJ3_RANGE_4G = KXTJ3_CTRL_REG1_GSEL_4G,
-    KXTJ3_RANGE_8G = KXTJ3_CTRL_REG1_GSEL_8G,
-    KXTJ3_RANGE_8G_14 = KXTJ3_CTRL_REG1_GSEL_8G_14,
-    KXTJ3_RANGE_16G = KXTJ3_CTRL_REG1_GSEL_16G,
-    KXTJ3_RANGE_16G_2 = KXTJ3_CTRL_REG1_GSEL_16G2,
-    KXTJ3_RANGE_16G_3 = KXTJ3_CTRL_REG1_GSEL_16G3,
-    KXTJ3_RANGE_16G_14 = KXTJ3_CTRL_REG1_GSEL_16G_14
-  } KXTJ3_G_RANGE_T;
-
-  /**
- * @brief Output Data Rates for normal mode
- */
-  typedef enum
-  {
-    KXTJ3_ODR_0P781 = KXTJ3_DATA_CTRL_REG_OSA_0P781,
-    KXTJ3_ODR_1P563 = KXTJ3_DATA_CTRL_REG_OSA_1P563,
-    KXTJ3_ODR_3P125 = KXTJ3_DATA_CTRL_REG_OSA_3P125,
-    KXTJ3_ODR_6P25 = KXTJ3_DATA_CTRL_REG_OSA_6P25,
-    KXTJ3_ODR_12P5 = KXTJ3_DATA_CTRL_REG_OSA_12P5,
-    KXTJ3_ODR_25 = KXTJ3_DATA_CTRL_REG_OSA_25,
-    KXTJ3_ODR_50 = KXTJ3_DATA_CTRL_REG_OSA_50,
-    KXTJ3_ODR_100 = KXTJ3_DATA_CTRL_REG_OSA_100,
-    KXTJ3_ODR_200 = KXTJ3_DATA_CTRL_REG_OSA_200,
-    KXTJ3_ODR_400 = KXTJ3_DATA_CTRL_REG_OSA_400,
-    KXTJ3_ODR_800 = KXTJ3_DATA_CTRL_REG_OSA_800,
-    KXTJ3_ODR_1600 = KXTJ3_DATA_CTRL_REG_OSA_1600
-  } KXTJ3_ODR_T;
-
-  /**
- * @brief Output Data Rates for wake-up function
- */
-  typedef enum
-  {
-    KXTJ3_ODR_WAKEUP_0P781 = KXTJ3_CTRL_REG2_OWUF_0P781,
-    KXTJ3_ODR_WAKEUP_1P563 = KXTJ3_CTRL_REG2_OWUF_1P563,
-    KXTJ3_ODR_WAKEUP_3P125 = KXTJ3_CTRL_REG2_OWUF_3P125,
-    KXTJ3_ODR_WAKEUP_6P25 = KXTJ3_CTRL_REG2_OWUF_6P25,
-    KXTJ3_ODR_WAKEUP_12P5 = KXTJ3_CTRL_REG2_OWUF_12P5,
-    KXTJ3_ODR_WAKEUP_25 = KXTJ3_CTRL_REG2_OWUF_25,
-    KXTJ3_ODR_WAKEUP_50 = KXTJ3_CTRL_REG2_OWUF_50,
-    KXTJ3_ODR_WAKEUP_100 = KXTJ3_CTRL_REG2_OWUF_100
-  } KXTJ3_ODR_WAKEUP_T;
-
-  /**
- * @brief Wake-up source axis and direction
- */
-  typedef enum
-  {
-    X_NEGATIVE = KXTJ3_INT_CTRL_REG2_XNWU,
-    X_POSITIVE = KXTJ3_INT_CTRL_REG2_XPWU,
-    Y_NEGATIVE = KXTJ3_INT_CTRL_REG2_YNWU,
-    Y_POSITIVE = KXTJ3_INT_CTRL_REG2_YPWU,
-    Z_NEGATIVE = KXTJ3_INT_CTRL_REG2_ZNWU,
-    Z_POSITIVE = KXTJ3_INT_CTRL_REG2_ZPWU
-  } KXTJ3_WAKEUP_SOURCE_T;
-
-  /**
- * @brief Use it to get axis and direction for wake-up function
- */
-  typedef struct
-  {
-    bool X_NEGATIVE,
-        X_POSITIVE,
-        Y_NEGATIVE,
-        Y_POSITIVE,
-        Z_NEGATIVE,
-        Z_POSITIVE;
-  } kxtj3_wakeup_axes;
-
-  /**
- * @brief Sensor context
- */
-  typedef struct _kxtj3_context
-  {
-    mraa_i2c_context i2c;
-    KXTJ3_RESOLUTION_T res_mode;
-    KXTJ3_G_RANGE_T g_range_mode;
-    float acceleration_scale;
-    KXTJ3_ODR_T odr;
-    float odr_in_sec;
-    KXTJ3_ODR_WAKEUP_T odr_wakeup;
-    float odr_in_sec_wakeup;
-    mraa_gpio_context interrupt_pin;
-  } * kxtj3_context;
-
-  /**
-@brief KXTJ3 initialization. Sets sensor default values and put it to active state.
-
-@param bus I2C bus to use
-@param addr I2C address of the sensor
-@return The sensor context, or NULL if an error occurs
-*/
-  kxtj3_context kxtj3_init(int bus, uint8_t addr);
-
-  /**
-@brief Initializes the sensor with the given resolution and acceleration range
-
-This gets called during the kxtj3_init(), so it will not need to be called unless the sensor is reset
-
-Sensor is automatically set into standby mode during the initialization
-Sensor is set to active mode after initialization
-
-Be cautious not to set resolution to LOW_RES along with g_range as 14-bits modes
-
-@param dev The sensor context
-@param odr Output Data Rate, One of the KXTJ3_ODR_T values
-@param res Resolution mode, One of the KXTJ3_RESOLUTION_T values. LOW_RES valid only for ODR <= 200 Hz.
-@param g_range Acceleration range, One of the KXTJ3_G_RANGE_T values
-@return UPM result
-*/
-  upm_result_t kxtj3_sensor_init(const kxtj3_context dev, KXTJ3_ODR_T odr, KXTJ3_RESOLUTION_T res, KXTJ3_G_RANGE_T g_range);
-
-  /**
-@brief Gets "who am I" value of the sensor
-
-@param dev The sensor context
-@param data Pointer to a uint8_t variable to store the value
-@return UPM result
-*/
-  upm_result_t kxtj3_get_who_am_i(const kxtj3_context dev, uint8_t *data);
-
-  /**
-@brief KXTJ3 destructor
-Closes the I2C context, and removes interrupts
-Frees memory of the kxtj3_context
-
-@param dev The sensor context
-*/
-  void kxtj3_close(kxtj3_context dev);
-
-  /**
-@brief Sets the sensor to active mode
-
-@param dev The sensor context
-@return UPM result
-*/
-  upm_result_t kxtj3_set_sensor_active(const kxtj3_context dev);
-
-  /**
-@brief Sets the sensor to the standby mode
-
-@param dev The sensor context
-@return UPM result
-*/
-  upm_result_t kxtj3_set_sensor_standby(const kxtj3_context dev);
-
-  /**
-@brief Sets the acceleration range of the sensor
-
-Sensor needs to be in standby mode when setting the acceleration range value
-
-Be cautious not to set g_range to 14-bits modes with the resolution being on LOW_RES.
-If the acceleration range is not compatible with resolution mode, the resolution is set automatically
-to the compatible value.
-
-@param dev The sensor context
-@param g_range One of the KXTJ3_G_RANGE_T values
-@return UPM result
-*/
-  upm_result_t kxtj3_set_g_range(const kxtj3_context dev, KXTJ3_G_RANGE_T g_range);
-
-  /**
-@brief Sets the resolution of the sensor. High resolution (14 bits and 12 bits) or low resolution (8 bits).
-
-LOW_RES valid only for ODR <= 200 Hz
-
-Be cautious not to set resolution to LOW_RES with the G_RANG being on 14-bits modes.
-If the resolution mode is not compatible with acceleration range, the resolution is set automatically
-to the compatible value.
-
-Sensor needs to be in standby mode when setting the sensor resolution
-
-@param dev The sensor context
-@param resolution One of the KXTJ3_RESOLUTION_T values
-@return UPM result
-*/
-  upm_result_t kxtj3_set_resolution(const kxtj3_context dev, KXTJ3_RESOLUTION_T resolution);
-
-  /**
-@brief Sets the ODR of the sensor
-
-Sensor needs to be in standby mode when setting the ODR
-
-@param dev The sensor context
-@param odr One of the KXTJ3_ODR_T values
-@return UPM result
-*/
-  upm_result_t kxtj3_set_odr(const kxtj3_context dev, KXTJ3_ODR_T odr);
-
-  /**
-@brief Sets the ODR of the wakeup function of the sensor
-
-Sensor needs to be in standby mode when setting the ODR
-
-@param dev The sensor context
-@param odr One of the KXTJ3_ODR_WAKEUP_T values
-@return UPM result
-*/
-  upm_result_t kxtj3_set_odr_wakeup_function(const kxtj3_context dev, KXTJ3_ODR_WAKEUP_T odr);
-
-  /**
-@brief Performs a self-test for digital communication of the sensor. The test sets DCST bit in
-CTRL_REG2, then checks the DCST_RESP register for a 0xAA, after the register is read, its
-value is 0x55 and DCST bit is cleared.
-
-This function is called by kxtj3_sensor_self_test also
-
-Sensor must be in standby mode before performing this action
-
-@param dev The sensor context
-@return UPM result
-*/
-  upm_result_t kxtj3_self_test_digital_communication(kxtj3_context dev);
-
-  /**
-@brief Performs a self-test of the sensor. The test applies an electrostatic force to the sensor,
-simulating input acceleration. The test compares samples from all axis before and after
-applying the electrostatic force to the sensor. If the amount of acceleration increases according
-to the values defined in TABLE 1 of the datasheet (0.5 g), the test passes.
-
-The function prints out the values before and during test and the average difference for each axis
-
-See the datasheet for more information
-
-@param dev The sensor context
-@return UPM result
-*/
-  upm_result_t kxtj3_sensor_self_test(const kxtj3_context dev);
-
-  /**
-@brief Performs a sensor software reset. The software reset clears the RAM of the sensor and resets all registers
-to pre-defined values.
-
-You should call kxtj3_sensor_init() after the software reset
-
-See the datasheet for more details
-
-@param dev The sensor context
-@return UPM result
-*/
-  upm_result_t kxtj3_sensor_software_reset(const kxtj3_context dev);
-
-  /**
-@brief Gets raw accelerometer data from the sensor
-
-@param dev The sensor context
-@param x Pointer to a floating point variable to store the x-axis value. Set to NULL if not wanted.
-@param y Pointer to a floating point variable to store the y-axis value. Set to NULL if not wanted.
-@param z Pointer to a floating point variable to store the z-axis value. Set to NULL if not wanted.
-@return UPM result
-*/
-  upm_result_t kxtj3_get_acceleration_data_raw(const kxtj3_context dev, float *x, float *y, float *z);
-
-  /**
-@brief Gets converted (m/s^2) accelerometer data from the sensor
-
-@param dev The sensor context
-@param x Pointer to a floating point variable to store the x-axis value. Set to NULL if not wanted.
-@param y Pointer to a floating point variable to store the y-axis value. Set to NULL if not wanted.
-@param z Pointer to a floating point variable to store the z-axis value. Set to NULL if not wanted.
-*/
-  upm_result_t kxtj3_get_acceleration_data(const kxtj3_context dev, float *x, float *y, float *z);
-
-  /**
-@brief Gets the duration of one sample period (in seconds) for getting the acceleration data depending on
-the sampling rate of the sensor
-
-@param dev The sensor context
-@return Floating point value of the sampling period
-*/
-  float kxtj3_get_acceleration_sampling_period(kxtj3_context dev);
-
-  /**
-Gets the duration of one sample period (in seconds) for the wakeup function depending on
-the sampling rate of the sensor wakeup function
-
-@param dev The sensor context
-@return Floating point value of the sampling period
-*/
-  float kxtj3_get_wakeup_sampling_period(kxtj3_context dev);
-
-  /**
-@brief Enables the data ready interrupt. Availability of new acceleration data is
-reflected as an interrupt.
-
-Sensor must be in standby mode before performing this action
-
-@param dev The sensor context
-@return UPM result
- */
-  upm_result_t kxtj3_enable_data_ready_interrupt(const kxtj3_context dev);
-
-  /**
-@brief Disables the data ready interrupt
-
-Sensor must be in standby mode before performing this action
-
-@param dev The sensor context
-@return UPM result
-*/
-  upm_result_t kxtj3_disable_data_ready_interrupt(const kxtj3_context dev);
-
-  /**
-@brief Enables the wakeup function (motion detection)
-
-Sensor must be in standby mode before performing this action
-
-@param dev The sensor context
-@return UPM result
- */
-  upm_result_t kxtj3_enable_wakeup_interrupt(const kxtj3_context dev);
-
-  /**
-@brief Disables the wakeup function (motion detection)
-
-Sensor must be in standby mode before performing this action
-
-@param dev The sensor context
-@return UPM result
- */
-  upm_result_t kxtj3_disable_wakeup_interrupt(const kxtj3_context dev);
-
-  /**
-@brief Enables interrupts on the interrupt pin, sets polarity and response types
-
-Polarity ACTIVE_HIGH or ACTIVE_LOW
-
-Response either latch until cleared by reading INT_REL register, or transmit one pulse
-Pulse width of 0.03-0.05ms
-
-For Wakeup function, the response type is always latched unless set wakeup latch off
-
-Sensor needs to be in standby mode when enabling the interrupt
-
-See datasheet for more details
-
-@param dev The sensor context
-@param polarity Select the polarity of the interrupt. One of the KXTJ3_INTERRUPT_POLARITY_T values.
-@param response_type Select the response type of the interrupt. One of the KXTJ3_INTERRUPT_RESPONSE_T values.
-@return UPM result
-*/
-  upm_result_t kxtj3_enable_interrupt_pin(const kxtj3_context dev, KXTJ3_INTERRUPT_POLARITY_T polarity, KXTJ3_INTERRUPT_RESPONSE_T response_type);
-
-  /**
-@brief Disables interrupts on the interrupt pin of the sensor
-
-Sensor needs to be in standby mode when disabling the interrupt pin
-
-@param dev The sensor context
-@return UPM result
-*/
-  upm_result_t kxtj3_disable_interrupt_pin(const kxtj3_context dev);
-
-  /**
-@brief Sets the polarity of the interrupt pin
-
-Polarity ACTIVE_HIGH or ACTIVE_LOW
-
-Sensor must be in standby mode before performing this action
-
-@param dev The sensor context
-@param polarity Select the polarity of the interrupt. One of the KXTJ3_INTERRUPT_POLARITY_T values.
-@return UPM result
-*/
-  upm_result_t kxtj3_set_interrupt_polarity(const kxtj3_context dev, KXTJ3_INTERRUPT_POLARITY_T polarity);
-
-  /**
-@brief Sets the response type of the interrupt pin
-
-Response either latch until cleared by reading INT_REL register, or transmit one pulse
-Pulse width of 0.03-0.05ms
-
-For Wakeup function, the response type is always latched unless set wakeup latch off
-
-Sensor must be in standby mode before performing this action
-
-See datasheet for more details
-
-@param dev The sensor context
-@param response_type Select the response type of the interrupt. One of the KXTJ3_INTERRUPT_RESPONSE_T values.
-@return UPM result
-*/
-  upm_result_t kxtj3_set_interrupt_response(const kxtj3_context dev, KXTJ3_INTERRUPT_RESPONSE_T response_type);
-
-  /**
-@brief Gets the status of the interrupts. (Has an interrupt occurred).
-
-See datasheet for more details
-
-@param dev The sensor context
-@return Return true if an interrupt event has occurred (DRDY or WUFS is 1), returns false if no interrupts have occurred
-*/
-  bool kxtj3_get_interrupt_status(const kxtj3_context dev);
-
-  /**
-@brief Gets the source of the interrupt
-The value stored is one or more of the KXTJ3_INTERRUPT_SOURCE_T values
-
-See datasheet for more details
-
-@param dev The sensor context
-@param reg_value Pointer to a uint8_t variable to store the value
-@return UPM result
-*/
-  upm_result_t kxtj3_read_interrupt_source1_reg(const kxtj3_context dev, uint8_t *reg_value);
-
-  /**
-@brief Gets the source of the interrupt
-
-See datasheet for more details
-
-@param dev The sensor context
-@return One of the KXTJ3_INTERRUPT_SOURCE_T values/types
-*/
-  KXTJ3_INTERRUPT_SOURCE_T kxtj3_get_interrupt_source(const kxtj3_context dev);
-
-  /**
-@brief Installs an interrupt handler to be executed when an interrupt is detected on the interrupt pin
-
-@param dev The sensor context
-@param edge One of the mraa_gpio_edge_t values, Interrupt trigger edge
-@param pin The GPIO pin to use as the interrupt pin
-@param isr Pointer to the function to be called, when the interrupt occurs
-@param isr_args The arguments to be passed to the function
-@return UPM result
-*/
-  upm_result_t kxtj3_install_isr(const kxtj3_context dev, mraa_gpio_edge_t edge, int pin, void (*isr)(void *), void *isr_args);
-
-  /**
-@brief Uninstalls a previously installed interrupt handler for interrupt pin
-
-@param dev The sensor context
-@return UPM result
-*/
-  void kxtj3_uninstall_isr(const kxtj3_context dev);
-
-  /**
-@brief Clears latching interrupts information of Wakeup (with axis and direction information) and Data Ready
-
-See datasheet for more details
-
-@param dev The sensor context
-@return UPM result
-*/
-  upm_result_t kxtj3_clear_interrupt_information(kxtj3_context dev);
-
-  /**
-@brief Enables wakeup interrupt for the given axis (axis with direction)
-
-Sensor must be in standby mode before performing this action
-
-@param dev The sensor context
-@param axis The axis to enable, takes one of KXTJ3_WAKEUP_SOURCE_T value
-@return UPM result
- */
-  upm_result_t kxtj3_enable_wakeup_single_axis_direction(kxtj3_context dev, KXTJ3_WAKEUP_SOURCE_T axis);
-
-  /**
-@brief Disables wakeup interrupt for the given axis (axis with direction)
-
-Sensor must be in standby mode before performing this action
-
-@param dev The sensor context
-@param axis The axis to enable, takes one of KXTJ3_WAKEUP_SOURCE_T value
-@return UPM result
- */
-  upm_result_t kxtj3_disable_wakeup_single_axis_direction(kxtj3_context dev, KXTJ3_WAKEUP_SOURCE_T axis);
-
-  /**
-@brief Gets the source axis and direction of motion detection of the wakeup function interrupt
-
-See datasheet for more details
-
-@param dev The sensor context
-@return A kxtj3_wakeup_axes struct with values of true/false for a wakeup for each axis and its direction
-*/
-  kxtj3_wakeup_axes kxtj3_get_wakeup_axis_and_direction(kxtj3_context dev);
-
-  /**
-@brief Enables the Unlatched mode motion interrupt (ULMODE). This mode is always by default enabled.
-
-When this bit is set, the wakeup interrupt has to be cleared manually
-(cannot use interrupt response with pulse)
-
-Sensor must be in standby mode before performing this action
-
-@param dev The sensor context
-@return UPM result
-*/
-  upm_result_t kxtj3_enable_wakeup_latch(kxtj3_context dev);
-
-  /**
-@brief Disables the Unlatched mode motion interrupt (ULMODE). This mode is always by default enabled
-(cannot use interrupt response with pulse).
-
-The wakeup threshold is advised to not be very low to avoid interrupt being triggered in
-an almost continuous manner
-
-Sensor must be in standby mode before performing this action
-
-When this bit is cleared, and the interrupt response type is set to Pulse, then upon a wakeup event
-the wakeup interrupt signal will pulse and return low, but only once. Then, the interrupt
-output will not reset until data is read or interrupt cleared.
-
-@param dev The sensor context
-@return UPM result
-*/
-  upm_result_t kxtj3_disable_wakeup_latch(kxtj3_context dev);
-
-  /**
-@brief Sets the timer counter of motion before sending a wakeup interrupt
-
-The count is limited to values from 1 to 255
-
-Every count is calculated as (1 / Wakeup_ODR_FREQUENCY) where Wakeup_ODR_FREQUENCY
-is the current odr_in_Hz value from odr_map_in_Hz_wakeup value
-
-Sensor must be in standby mode before performing this action
-
-See datasheet for more details
-
-@param dev The sensor context
-@param count The timer count from 1 to 255
-@return UPM result
- */
-  upm_result_t kxtj3_set_wakeup_motion_counter(kxtj3_context dev, uint8_t count);
-
-  /**
-@brief Sets the timer of motion before sending a wakeup interrupt
-
-the desired time should be such that (0 < desired_time * wakeup_odr_frequency <= 255)
-
-Sensor must be in standby mode before performing this action
-
-See datasheet for more details
-
-@param dev The sensor context
-@param desired_time The desired time in seconds
-@return UPM result
- */
-  upm_result_t kxtj3_set_wakeup_motion_time(kxtj3_context dev, float desired_time);
-
-  /**
-@brief Gets the current count value of the timer of motion before sending a wakeup interrupt
-
-@param dev The sensor context
-@param out_time Pointer to a float variable to store the time value in seconds
-@return UPM result
- */
-  upm_result_t kxtj3_get_wakeup_motion_time(kxtj3_context dev, float *out_time);
-
-  /**
-@brief Sets the timer counter of non-activity before sending another wakeup interrupt
-
-The count is limited to values from 1 to 255
-
-Every count is calculated as (1 / Wakeup_ODR_FREQUENCY) where Wakeup_ODR_FREQUENCY
-is the current odr_in_Hz value from odr_map_in_Hz_wakeup value
-
-Sensor must be in standby mode before performing this action
-
-See datasheet for more details
-
-@param dev The sensor context
-@param count The timer count from 1 to 255
-@return UPM result
- */
-  upm_result_t kxtj3_set_wakeup_non_activity_counter(kxtj3_context dev, uint8_t count);
-
-  /**
-@brief Sets the timer of non-activity before sending another wakeup interrupt
-
-the desired time should be such that (0 < desired_time * wakeup_odr_frequency <= 255)
-
-Sensor must be in standby mode before performing this action
-
-See datasheet for more details
-
-@param dev The sensor context
-@param desired_time The desired time in seconds
-@return UPM result
- */
-  upm_result_t kxtj3_set_wakeup_non_activity_time(kxtj3_context dev, float desired_time);
-
-  /**
-@brief Gets the current count value of the timer of non-activity before sending another wakeup interrupt
-
-@param dev The sensor context
-@param out_time Pointer to a float variable to store the time value in seconds
-@return UPM result
- */
-  upm_result_t kxtj3_get_wakeup_non_activity_time(kxtj3_context dev, float *out_time);
-
-  /**
-@brief Sets the threshold counter for acceleration difference before sending a wakeup interrupt
-
-The count is limited to values from 1 to 4096, that it is 16g threshold with (3.9mg/count)
-It is advised to not set the threshold to a very low value which may cause bad behaviour
-in the wakeup interrupt
-
-Sensor must be in standby mode before performing this action
-
-See datasheet for more details
-
-@param dev The sensor context
-@param count The timer count from 1 to 4096, that it is 16g threshold with (3.9mg/count)
-@return UPM result
- */
-  upm_result_t kxtj3_set_wakeup_threshold_counter(kxtj3_context dev, uint16_t count);
-
-  /**
-@brief Sets the threshold g value for acceleration difference before sending a wakeup interrupt
-
-The count is limited to values up to 16g, with steps of 3.9mg. It is advised to not set
-the threshold to a very low value which may cause bad behaviour in the wakeup interrupt
-
-Sensor must be in standby mode before performing this action
-
-See datasheet for more details
-
-@param dev The sensor context
-@param g_threshold The acceleration threshold (in g) in g, from 3.9mg to 16g, steps of 3.9mg/count
-@return UPM result
- */
-  upm_result_t kxtj3_set_wakeup_threshold_g_value(kxtj3_context dev, float g_threshold);
-
-  /**
-@brief Gets the current threshold difference value before sending wakeup interrupt
-
-@param dev The sensor context
-@param out_threshold Pointer to a float variable to store the threshold value in g
-@return UPM result
- */
-  upm_result_t kxtj3_get_wakeup_threshold(kxtj3_context dev, float *out_threshold);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/kxtj3/kxtj3.hpp b/src/kxtj3/kxtj3.hpp
deleted file mode 100755
index 36e5356..0000000
--- a/src/kxtj3/kxtj3.hpp
+++ /dev/null
@@ -1,565 +0,0 @@
-/*
-* The MIT License (MIT)
-*
-* Author: Assam Boudjelthia
-* Copyright (c) 2018 Rohm Semiconductor.
-*
-* Permission is hereby granted, free of charge, to any person obtaining a copy of
-* this software and associated documentation files (the "Software"), to deal in
-* the Software without restriction, including without limitation the rights to
-* use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-* the Software, and to permit persons to whom the Software is furnished to do so,
-* subject to the following conditions:
-*
-* The above copyright notice and this permission notice shall be included in all
-* copies or substantial portions of the Software.
-*
-* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-* COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-#pragma once
-
-#include <vector>
-#include <mraa/gpio.hpp>
-
-#include "kxtj3.h"
-
-/**
- * @brief C API for the kxtj3 driver
- * @defgroup kxtj3 libupm-kxtj3
- * @ingroup Kionix i2c accelerometer
- *
- * @include kxtj3.cxx
- */
-
-/**
- * @library kxtj3
- * @sensor kxtj3
- * @comname tri-axis accelerometer
- * @type accelerometer
- * @man Kionix
- * @con i2c
- *
- * @brief C++ API for the kxtj3 driver
- *
- * @image html kxtj3.png
- */
-
-namespace upm
-{
-class KXTJ3
-{
-public:
-  /**
-   * @brief KXTJ3 constructor
-   *
-   * If no errors occur, the device is initialized with default values and set to active state
-   *
-   * @param bus I2C bus
-   * @param addr I2C address of the sensor
-   * @throws std::runtime_error on initialization failure
-    */
-  KXTJ3(int bus, uint8_t addr = 0x0f);
-
-  /**
-   * @brief KXTJ3 destructor
-   *
-   * Closes the I2C context, and removes interrupts
-   * Frees memory of the kxtj3_context
-   *
-   * @throws std::runtime_error on initialization failure
-    */
-  virtual ~KXTJ3();
-
-  /**
-   * @brief Initializes the sensor with given sampling rate, resolution and acceleration range.
-   * This gets called in the constructor, so it will not need to be called unless the device is reset.
-   *
-   * Sensor is set to standby mode during the initialization and back to active after initialization.
-   *
-   * @param odr One of the KXTJ3_ODR_T values
-   * @param resolution One of the KXTJ3_RESOLUTION_T values
-   * @param g_range One of the KXTJ3_G_RANGE_T values
-   * @throws std::runtime_error on failure
-    */
-  void SensorInit(KXTJ3_ODR_T odr, KXTJ3_RESOLUTION_T resolution, KXTJ3_G_RANGE_T g_range);
-
-  /**
-   * @brief Gets "who am I" value of the sensor
-   *
-   * @return Who am I value of the sensor
-   * @throws std::runtime_error on failure
-   */
-  uint8_t GetWhoAmI();
-
-  /**
-   * @brief Sets the sensor to active mode
-   *
-   * @throws std::runtime_error on failure
-    */
-  void SensorActive();
-
-  /**
-   * @brief Sets the sensor to standby mode
-
-   * @throws std::runtime_error on failure
-    */
-  void SensorStandby();
-
-  /**
-   * @brief Sets the acceleration range of the sensor
-   *
-   * Sensor needs to be in standby mode when setting the acceleration range value
-   *
-   * Be cautious not to set g_range to 14-bits modes with the resolution being on LOW_RES
-   *
-   * @param g_range One of the KXTJ3_G_RANGE_T values
-   * @throws std::runtime_error on failure
-   */
-  void SetGRange(KXTJ3_G_RANGE_T g_range);
-
-  /**
-   * @brief Sets the resolution of the sensor. High resolution (14 bits and 12 bits) or low resolution (8 bits).
-   *
-   * LOW_RES valid only for ODR <= 200 Hz
-   *
-   * Be cautious not to set resolution to LOW_RES with the G_RANG being on 14-bits modes
-   *
-   * Sensor needs to be in standby mode when setting the sensor resolution
-   *
-   * @param resolution One of the KXTJ3_RESOLUTION_T values
-   * @throws std::runtime_error on failure
-   */
-  void SetResolution(KXTJ3_RESOLUTION_T resolution);
-
-  /**
-   * @brief Sets the ODR of the sensor
-   *
-   * Sensor needs to be in standby mode when setting the ODR
-   *
-   * @param odr One of the KXTJ3_ODR_T values
-   * @throws std::runtime_error on failure
-   */
-  void SetOdr(KXTJ3_ODR_T odr);
-
-  /**
-   * @brief Sets the ODR of the wakeup function of the sensor
-   *
-   * Sensor needs to be in standby mode when setting the ODR
-   *
-   * @param odr One of the KXTJ3_ODR_WAKEUP_T values
-   * @throws std::runtime_error on failure
-   */
-  void SetOdrForWakeup(KXTJ3_ODR_WAKEUP_T odr);
-
-  /**
-   * @brief Performs a self-test for digital communication of the sensor. The test sets DCST bit in
-   * CTRL_REG2, then checks the DCST_RESP register for a 0xAA, after the register is read, its
-   * value is 0x55 and DCST bit is cleared.
-   *
-   * This method is called by SensorSelfTest also
-   *
-   * Sensor must be in standby mode before performing this action
-   *
-   * @throws std::runtime_error on failure
-   */
-  void SelfTestDigitalCommunication();
-
-  /**
-   * @brief Performs a self-test of the sensor. The test applies an electrostatic force to the sensor,
-   * simulating input acceleration. The test compares samples from all axis before and after
-   * applying the electrostatic force to the sensor. If the amount of acceleration increases according
-   * to the values defined in TABLE 1 of the datasheet (0.5 g), the test passes.
-   *
-   * The method prints out the values before and during test and the average difference for each axis
-   *
-   * See the datasheet for more information
-   *
-   * @throws std::runtime_error on failure
-   */
-  void SensorSelfTest();
-
-  /**
-   * @brief Performs a sensor software reset. The software reset clears the RAM of the sensor and resets all registers
-   * to pre-defined values.
-   *
-   * You should call kxtj3_sensor_init() after the software reset
-   *
-   * See the datasheet for more details
-   *
-   * @throws std::runtime_error on failure
-    */
-  void SensorSoftwareReset();
-
-  /**
-   * Gets raw acceleration data from the sensor.
-   *
-   * @return Acceleration vector [x, y, z]
-   * @throws std::runtime_error on failure.
-   */
-  std::vector<float> GetAccelerationRawVector();
-
-  /**
-   * Gets acceleration data in (m/s^2) from the sensor.
-   *
-   * @return Acceleration vector [x, y, z]
-   * @throws std::runtime_error on failure.
-   */
-  std::vector<float> GetAccelerationVector();
-
-  /**
-   * @brief Gets the duration of one sample period (in seconds) for getting the acceleration data depending on
-   * the sampling rate of the sensor
-   *
-   * @return Floating point value of the sampling period
-   * @throws std::runtime_error on failure
-   */
-  float GetAccelerationSamplePeriod();
-
-  /**
-   * @brief Gets the duration of one sample period (in seconds) for the wakeup function depending on
-   * the sampling rate of the sensor wakeup function
-   *
-   * @return Floating point value of the sampling period
-   * @throws std::runtime_error on failure
-   */
-  float GetWakeUpSamplePeriod();
-
-  /**
-   * @brief Enables the data ready interrupt. Availability of new acceleration data is
-   * reflected as an interrupt.
-   *
-   * Sensor must be in standby mode before performing this action
-   *
-   * @throws std::runtime_error on failure
-   */
-  void EnableDataReadyInterrupt();
-
-  /**
-   * @brief Disables the data ready interrupt
-   *
-   * Sensor must be in standby mode before performing this action
-   *
-   * @throws std::runtime_error on failure
-   */
-  void DisableDataReadyInterrupt();
-
-  /**
-   * @brief Enables the wakeup function (motion detection)
-   *
-   * Sensor must be in standby mode before performing this action
-   *
-   * @throws std::runtime_error on failure
-   */
-  void EnableWakeUpInterrupt();
-
-  /**
-   * @brief Disables the wakeup function (motion detection)
-   *
-   * Sensor must be in standby mode before performing this action
-   *
-   * @throws std::runtime_error on failure
-   */
-  void DisableWakeUpInterrupt();
-
-  /**
-   * @brief Enables interrupts on the interrupt pin, sets polarity and response types.
-   * Polarity ACTIVE_HIGH or ACTIVE_LOW.
-   * Response either latch until cleared by reading INT_REL register, or transmit one pulse
-   * Pulse width of 0.03-0.05ms.
-   *
-   * For Wakeup function, the response type is always latched unless set wakeup latch off
-   * Sensor needs to be in standby mode when enabling the interrupt
-   *
-   * See datasheet for more details
-   *
-   * @param polarity Select the polarity of the interrupt. One of the KXTJ3_INTERRUPT_POLARITY_T values.
-   * @param response_type Select the response type of the interrupt. One of the KXTJ3_INTERRUPT_RESPONSE_T values.
-   * @throws std::runtime_error on failure
-   */
-  void EnableInterruptPin(KXTJ3_INTERRUPT_POLARITY_T polarity, KXTJ3_INTERRUPT_RESPONSE_T response_type);
-
-  /**
-   * @brief Disables interrupts on the interrupt pin of the sensor
-   *
-   * Sensor needs to be in standby mode when disabling the interrupt pin
-   *
-   * @throws std::runtime_error on failure
-   */
-  void DisableInterruptPin();
-
-  /**
-   * @brief Sets the polarity of the interrupt pin
-   *
-   * Polarity ACTIVE_HIGH or ACTIVE_LOW
-   *
-   * Sensor must be in standby mode before performing this action
-   *
-   * @param polarity Select the polarity of the interrupt. One of the KXTJ3_INTERRUPT_POLARITY_T values.
-   * @throws std::runtime_error on failure
-   */
-  void SetInterruptPolarity(KXTJ3_INTERRUPT_POLARITY_T polarity);
-
-  /**
-   * @brief Sets the response type of the interrupt pin
-   *
-   * Response either latch until cleared by reading INT_REL register, or transmit one pulse
-   * Pulse width of 0.03-0.05ms
-   *
-   * For Wakeup function, the response type is always latched unless set wakeup latch off
-   *
-   * Sensor must be in standby mode before performing this action
-   *
-   * See datasheet for more details
-   *
-   * @param response_type Select the response type of the interrupt. One of the KXTJ3_INTERRUPT_RESPONSE_T values
-   * @throws std::runtime_error on failure
-   */
-  void SetInerruptResponse(KXTJ3_INTERRUPT_RESPONSE_T response_type);
-
-  /**
-   * @brief Gets the status of the interrupts. (Has an interrupt occurred)
-   *
-   * See datasheet for more details
-   *
-   * @return Return true if an interrupt event has occurred (DRDY or WUFS is 1),
-   * returns false if no interrupts have occurred
-   */
-  bool GetInterruptStatus();
-
-  /**
-   * @brief Gets the source of the interrupt
-   * The value stored is one or more of the KXTJ3_INTERRUPT_SOURCE_T values
-   *
-   * See datasheet for more details
-   *
-   * @return Value of the interrupt source register
-   * @throws std::runtime_error on failure
-   */
-  uint8_t ReadInterruptSource1();
-
-  /**
-   * @brief Gets the source of the interrupt
-   *
-   * See datasheet for more details
-   *
-   * @return One of the KXTJ3_INTERRUPT_SOURCE_T values/types
-   */
-  KXTJ3_INTERRUPT_SOURCE_T GetInterruptSource();
-
-  /**
-   * @brief Installs an interrupt handler to be executed when an interrupt is detected on the interrupt pin
-
-   * @param edge One of the mraa_gpio_edge_t values. Interrupt trigger edge.
-   * @param pin The GPIO pin to use as the interrupt pin
-   * @param isr Pointer to the method to be called, when the interrupt occurs
-   * @param isr_args The arguments to be passed to the method
-   * @return std::runtime_error on failure
-   */
-  void InstallIsr(mraa_gpio_edge_t edge, int pin, void (*isr)(void *), void *isr_args);
-
-  /**
-   * @brief Uninstalls a previously installed interrupt handler for interrupt pin
-   *
-   * @throws std::runtime_error on failure
-   */
-  void UninstallIsr();
-
-  /**
-   * @brief Clears latching interrupts information of Wakeup (with axis and direction information) and Data Ready
-   *
-   * See datasheet for more details
-   *
-   * @throws std::runtime_error on failure
-   */
-  void ClearInterrupt();
-
-  /**
-   * @brief Enables wakeup interrupt for the given axis (axis with direction)
-   *
-   * Sensor must be in standby mode before performing this action
-   *
-   * @param axis The axis to enable, takes one of KXTJ3_WAKEUP_SOURCE_T value
-   * @throws std::runtime_error on failure
-   */
-  void EnableWakeUpSingleAxisDirection(KXTJ3_WAKEUP_SOURCE_T axis);
-
-  /**
-   * @brief Disables wakeup interrupt for the given axis (axis with direction)
-   *
-   * Sensor must be in standby mode before performing this action
-   *
-   * @param axis The axis to enable, takes one of KXTJ3_WAKEUP_SOURCE_T value
-   * @throws std::runtime_error on failure
-   */
-  void DisableWakeUpSingleAxisDirection(KXTJ3_WAKEUP_SOURCE_T axis);
-
-  /**
-   * @brief Gets the source axis and direction of motion detection of the wakeup function interrupt
-   *
-   * See datasheet for more details
-   *
-   * @return A kxtj3_wakeup_axes struct with values of true/false
-   * for a wakeup for each axis and its direction
-   */
-  kxtj3_wakeup_axes GetWakeUpAxisDirection();
-
-  /**
-   * @brief Enables the Unlatched mode motion interrupt (ULMODE). This mode is always by default enabled.
-   *
-   * When this bit is set, the wakeup interrupt has to be cleared manually
-   * (cannot use interrupt response with pulse)
-   *
-   * Sensor must be in standby mode before performing this action
-   *
-   * @throws std::runtime_error on failure
-   */
-  void EnableWakeUpLatch();
-
-  /**
-   * @brief Disables the Unlatched mode motion interrupt (ULMODE). This mode is always by default enabled.
-   * (cannot use interrupt response with pulse)
-   *
-   * The wakeup threshold is advised to not be very low to avoid interrupt being triggered in
-   * an almost continuous manner
-   *
-   * Sensor must be in standby mode before performing this action
-   *
-   * When this bit is cleared, and the interrupt response type is set to Pulse, then upon a wakeup event
-   * the wakeup interrupt signal will pulse and return low, but only once. Then, the interrupt
-   * output will not reset until data is read or interrupt cleared.
-
-   * @throws std::runtime_error on failure
-   */
-  void DisableWakeUpLatch();
-
-  /**
-   * @brief Sets the timer counter of motion before sending a wakeup interrupt
-   *
-   * The count is limited to values from 1 to 255
-   *
-   * Every count is calculated as (1 / Wakeup_ODR_FREQUENCY) where Wakeup_ODR_FREQUENCY
-   * is the current odr_in_Hz value from odr_map_in_Hz_wakeup value
-   *
-   * Sensor must be in standby mode before performing this action
-   *
-   * See datasheet for more details
-   *
-   * @param count The timer count from 1 to 255
-   * @throws std::runtime_error on failure
-   */
-  void SetWakeUpMotionCounter(uint8_t count);
-
-  /**
-   * @brief Sets the timer of motion before sending a wakeup interrupt
-   *
-   * the desired time should be such that (0 < desired_time * wakeup_odr_frequency <= 255)
-   *
-   * Sensor must be in standby mode before performing this action
-   *
-   * See datasheet for more details
-   *
-   * @param desired_time The desired time in seconds
-   * @throws std::runtime_error on failure
-   */
-  void SetWakeUpMotionTime(float desired_time);
-
-  /**
-   * @brief Get the current count value of the timer of motion before sending a wakeup interrupt
-   *
-   * @return Time value in seconds
-   * @throws std::runtime_error on failure
-   */
-  float GetWakeUpMotionTime();
-
-  /**
-   * @brief Sets the timer counter of non-activity before sending another wakeup interrupt
-   *
-   * The count is limited to values from 1 to 255
-   *
-   * Every count is calculated as (1 / Wakeup_ODR_FREQUENCY) where Wakeup_ODR_FREQUENCY
-   * is the current odr_in_Hz value from odr_map_in_Hz_wakeup value
-   *
-   * Sensor must be in standby mode before performing this action
-   *
-   * See datasheet for more details
-   *
-   * @param count The timer count from 1 to 255
-   * @throws std::runtime_error on failure
-   */
-  void SetWakeUpNonActivityCounter(uint8_t count);
-
-  /**
-   * @brief Sets the timer of non-activity before sending another wakeup interrupt
-   *
-   * the desired time should be such that (0 < desired_time * wakeup_odr_frequency <= 255)
-   *
-   * Sensor must be in standby mode before performing this action
-   *
-   * See datasheet for more details
-   *
-   * @param desired_time The desired time in seconds
-   * @throws std::runtime_error on failure
-   */
-  void SetWakeUpNonActivityTime(float desired_time);
-
-  /**
-   * @brief Get the current count value of the timer of non-activity before sending another wakeup interrupt
-   *
-   * @return Time value in seconds
-   * @throws std::runtime_error on failure
-   */
-  float GetWakeUpNonActivityTime();
-
-  /**
-   * @brief Sets the threshold counter for acceleration difference before sending a wakeup interrupt
-   *
-   * The count is limited to values from 1 to 4096, that it is 16g threshold with (3.9mg/count)
-   * It is advised to not set the threshold to a very low value which may cause bad behaviour
-   * in the wakeup interrupt
-   *
-   * Sensor must be in standby mode before performing this action
-   *
-   * See datasheet for more details
-   *
-   * @param count The timer count from 1 to 4096, that it is 16g threshold with (3.9mg/count)
-   * @throws std::runtime_error on failure
-   */
-  void SetWakeUpThresholdCounter(uint16_t count);
-
-  /**
-   * @brief Sets the threshold g value for acceleration difference before sending a wakeup interrupt
-   *
-   * The count is limited to values up to 16g, with steps of 3.9mg. It is advised to not set
-   * the threshold to a very low value which may cause bad behaviour in the wakeup interrupt
-   *
-   * Sensor must be in standby mode before performing this action
-   *
-   * See datasheet for more details
-   *
-   * @param g_threshold The acceleration threshold (in g) in g, from 3.9mg to 16g, steps of 3.9mg/count.
-   * @throws std::runtime_error on failure
-   */
-  void SetWakeUpThresholdGRange(float g_threshold);
-
-  /**
-   * @brief Get the current threshold difference value before sending wakeup interrupt
-   *
-   * @return Threshold value in g
-   * @throws std::runtime_error on failure
-   */
-  float GetWakeUpThresholdGRange();
-
-private:
-  kxtj3_context m_kxtj3;
-
-  /* Disable implicit copy and assignment operators */
-  KXTJ3(const KXTJ3 &) = delete;
-  KXTJ3 &operator=(const KXTJ3 &) = delete;
-};
-} // namespace upm
diff --git a/src/kxtj3/kxtj3.i b/src/kxtj3/kxtj3.i
deleted file mode 100644
index 6f60f49..0000000
--- a/src/kxtj3/kxtj3.i
+++ /dev/null
@@ -1,20 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_kxtj3)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%include "std_vector.i"
-%template(floatVector) std::vector<float>;
-
-%apply float *OUTPUT {float *x, float *y, float *z};
-
-%{
-#include "kxtj3.hpp"
-%}
-%include "kxtj3.h"
-%include "kxtj3.hpp"
-/* END Common SWIG syntax */
diff --git a/src/kxtj3/kxtj3.json b/src/kxtj3/kxtj3.json
deleted file mode 100755
index 3010938..0000000
--- a/src/kxtj3/kxtj3.json
+++ /dev/null
@@ -1,72 +0,0 @@
-{
-    "Library": "KXTJ3",
-    "Description": "Kionix KXTJ3 tri-axis accelerometer sensor library",
-    "Sensor Class": {
-        "KXTJ3": {
-            "Name": "Kionix KXTJ3 tri-axis accelerometer sensor",
-            "Description": "This is the UPM Module for the Kionix KXTJ3 accelerometer sensor. The Kionix KXTJ3 sensor is a multifunctional sensor that provides multiple functionalities. The sensor provides an extended g-range up to +/- 16g, higher resolution embedded wake-up function down to 3.9mg, and a flexible interrupt circuitry. The KXTJ3 sense element offers lower noise performance, exceptional shock resiliency, stable performance over temperature, and virtually eliminates offset and sensitivity shifts from reflow.",
-            "Categories": [
-                "acceleration"
-            ],
-            "Connections": [
-                "i2c"
-            ],
-            "Project Type": [
-                "prototyping",
-                "commercial"
-            ],
-            "Manufacturers": [
-                "Kionix"
-            ],
-            "Image": "kxtj3.png",
-            "Examples": {
-                "C++": [
-                    "kxtj3.cxx"
-                ],
-                "C": [
-                    "kxtj3.c"
-                ],
-                "Java": [
-                    "KXTJ3_Example.java"
-                ],
-                "Python": [
-                    "kxtj3.py"
-                ],
-                "Node.js": [
-                    "kxtj3.js"
-                ]
-            },
-            "Specifications": {
-                "Supply Voltage (VDD)": {
-                    "unit": "V",
-                    "min": 1.71,
-                    "typical": 2.5,
-                    "max": 3.6
-                },
-                "I/O Pads Supply Voltage (IO_VDD)": {
-                    "unit": "V",
-                    "min": 1.7,
-                    "max": 3.6
-                },
-                "Supply Current": {
-                    "unit": "uA",
-                    "min": 0.9,
-                    "max": 155
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                }
-            },
-            "Urls": {
-                "Product Pages": [
-                    "http://www.kionix.com/product/KXTJ3-1057"
-                ],
-                "Datasheets": [
-                    "http://kionixfs.kionix.com/en/datasheet/KXTJ3-1057-Specifications-Rev-3.0.pdf"
-                ]
-            }
-        }
-    }
-}
diff --git a/src/kxtj3/kxtj3_registers.h b/src/kxtj3/kxtj3_registers.h
deleted file mode 100755
index ea2d444..0000000
--- a/src/kxtj3/kxtj3_registers.h
+++ /dev/null
@@ -1,204 +0,0 @@
-/*
-The MIT License (MIT)
-Copyright (c) 2017 Kionix Inc.
-
-Permission is hereby granted, free of charge, to any person obtaining a
-copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sublicense, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice shall be included
-in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-#ifndef __KXTJ3_REGISTERS_H__
-#define __KXTJ3_REGISTERS_H__
-/* registers */
-// output register x
-#define KXTJ3_XOUT_L 0x06
-#define KXTJ3_XOUT_H 0x07
-// output register y
-#define KXTJ3_YOUT_L 0x08
-#define KXTJ3_YOUT_H 0x09
-// output register z
-#define KXTJ3_ZOUT_L 0x0A
-#define KXTJ3_ZOUT_H 0x0B
-// This register can be used to verify proper integrated circuit functionality
-#define KXTJ3_DCST_RESP 0x0C
-// This register can be used for supplier recognition, as it can be factory written to a known byte value.
-#define KXTJ3_WHO_AM_I 0x0F
-// This register reports which function caused an interrupt.
-#define KXTJ3_INT_SOURCE1 0x16
-// This register reports the axis and direction of detected motion
-#define KXTJ3_INT_SOURCE2 0x17
-// This register reports the status of the interrupt
-#define KXTJ3_STATUS_REG 0x18
-#define KXTJ3_INT_REL 0x1A
-// Read/write control register that controls the main feature set
-#define KXTJ3_CTRL_REG1 0x1B
-// Read/write control register that provides more feature set control
-#define KXTJ3_CTRL_REG2 0x1D
-// This register controls the settings for the physical interrupt pin
-#define KXTJ3_INT_CTRL_REG1 0x1E
-// This register controls which axis and direction of detected motion can cause an interrupt
-#define KXTJ3_INT_CTRL_REG2 0x1F
-// Read/write control register that configures the acceleration outputs
-#define KXTJ3_DATA_CTRL_REG 0x21
-#define KXTJ3_WAKEUP_COUNTER 0x29
-#define KXTJ3_NA_COUNTER 0x2A
-// When 0xCA is written to this register, the MEMS self-test function is enabled
-#define KXTJ3_SELF_TEST 0x3A
-#define KXTJ3_WAKEUP_THRESHOLD_H 0x6A
-#define KXTJ3_WAKEUP_THRESHOLD_L 0x6B
-// This register can be used for supplier recognition, as it can be factory written to a known byte value.
-#define KXCJC_WHO_AM_I 0x0F
-/* registers bits */
-// before set
-#define KXTJ3_DCST_RESP_DCSTR_BEFORE (0x55 << 0)
-// after set
-#define KXTJ3_DCST_RESP_DCSTR_AFTER (0xAA << 0)
-// WHO_AM_I -value for KXTJ3
-#define KXTJ3_WHO_AM_I_WIA_ID (0x35 << 0)
-// indicates that new acceleration data
-#define KXTJ3_INT_SOURCE1_DRDY (0x01 << 4)
-// Wake up
-#define KXTJ3_INT_SOURCE1_WUFS (0x01 << 1)
-// x-
-#define KXTJ3_INT_SOURCE2_XNWU (0x01 << 5)
-// x+
-#define KXTJ3_INT_SOURCE2_XPWU (0x01 << 4)
-// y-
-#define KXTJ3_INT_SOURCE2_YNWU (0x01 << 3)
-// y+
-#define KXTJ3_INT_SOURCE2_YPWU (0x01 << 2)
-// z-
-#define KXTJ3_INT_SOURCE2_ZNWU (0x01 << 1)
-// z+
-#define KXTJ3_INT_SOURCE2_ZPWU (0x01 << 0)
-// reports the combined (OR) interrupt information of DRDY and WUFS in the interrupt source register
-#define KXTJ3_STATUS_REG_INT (0x01 << 4)
-// controls the operating mode of the KXTJ3
-#define KXTJ3_CTRL_REG1_PC (0x01 << 7)
-// determines the performance mode of the KXTJ3
-#define KXTJ3_CTRL_REG1_RES (0x01 << 6)
-// enables the reporting of the availability of new acceleration data as an interrupt
-#define KXTJ3_CTRL_REG1_DRDYE (0x01 << 5)
-// 2g range
-#define KXTJ3_CTRL_REG1_GSEL_2G (0x00 << 2)
-// 16g range
-#define KXTJ3_CTRL_REG1_GSEL_16G (0x01 << 2)
-// 4g range
-#define KXTJ3_CTRL_REG1_GSEL_4G (0x02 << 2)
-// 16g range
-#define KXTJ3_CTRL_REG1_GSEL_16G2 (0x03 << 2)
-// 8g range
-#define KXTJ3_CTRL_REG1_GSEL_8G (0x04 << 2)
-// 16g range
-#define KXTJ3_CTRL_REG1_GSEL_16G3 (0x05 << 2)
-// 8g range with 14b resolution
-#define KXTJ3_CTRL_REG1_GSEL_8G_14 (0x06 << 2)
-// 16g range with 14b resolution
-#define KXTJ3_CTRL_REG1_GSEL_16G_14 (0x07 << 2)
-// enables 14-bit mode if GSEL = '11'
-#define KXTJ3_CTRL_REG1_EN16G (0x01 << 2)
-// enables the Wake Up (motion detect) function.
-#define KXTJ3_CTRL_REG1_WUFE (0x01 << 1)
-// initiates software reset
-#define KXTJ3_CTRL_REG2_SRST (0x01 << 7)
-// initiates the digital communication self-test function.
-#define KXTJ3_CTRL_REG2_DCST (0x01 << 4)
-// 0.78Hz
-#define KXTJ3_CTRL_REG2_OWUF_0P781 (0x00 << 0)
-// 1.563Hz
-#define KXTJ3_CTRL_REG2_OWUF_1P563 (0x01 << 0)
-// 3.125Hz
-#define KXTJ3_CTRL_REG2_OWUF_3P125 (0x02 << 0)
-// 6.25Hz
-#define KXTJ3_CTRL_REG2_OWUF_6P25 (0x03 << 0)
-// 12.5Hz
-#define KXTJ3_CTRL_REG2_OWUF_12P5 (0x04 << 0)
-// 25Hz
-#define KXTJ3_CTRL_REG2_OWUF_25 (0x05 << 0)
-// 50Hz
-#define KXTJ3_CTRL_REG2_OWUF_50 (0x06 << 0)
-// 100Hz
-#define KXTJ3_CTRL_REG2_OWUF_100 (0x07 << 0)
-// enables/disables the physical interrupt pin
-#define KXTJ3_INT_CTRL_REG1_IEN (0x01 << 5)
-// sets the polarity of the physical interrupt pin
-#define KXTJ3_INT_CTRL_REG1_IEA (0x01 << 4)
-// sets the response of the physical interrupt pin
-#define KXTJ3_INT_CTRL_REG1_IEL (0x01 << 3)
-// selftest polarity
-#define KXTJ3_INT_CTRL_REG1_STPOL (0x01 << 1)
-// Unlatched mode motion  interrupt; 0=disabled,1=enabled
-#define KXTJ3_INT_CTRL_REG2_ULMODE (0x01 << 7)
-// x-
-#define KXTJ3_INT_CTRL_REG2_XNWU (0x01 << 5)
-// x+
-#define KXTJ3_INT_CTRL_REG2_XPWU (0x01 << 4)
-// y-
-#define KXTJ3_INT_CTRL_REG2_YNWU (0x01 << 3)
-// y+
-#define KXTJ3_INT_CTRL_REG2_YPWU (0x01 << 2)
-// z-
-#define KXTJ3_INT_CTRL_REG2_ZNWU (0x01 << 1)
-// z+
-#define KXTJ3_INT_CTRL_REG2_ZPWU (0x01 << 0)
-// 12.5Hz
-#define KXTJ3_DATA_CTRL_REG_OSA_12P5 (0x00 << 0)
-// 25Hz
-#define KXTJ3_DATA_CTRL_REG_OSA_25 (0x01 << 0)
-// 50Hz
-#define KXTJ3_DATA_CTRL_REG_OSA_50 (0x02 << 0)
-// 100Hz
-#define KXTJ3_DATA_CTRL_REG_OSA_100 (0x03 << 0)
-// 200Hz
-#define KXTJ3_DATA_CTRL_REG_OSA_200 (0x04 << 0)
-// 400Hz
-#define KXTJ3_DATA_CTRL_REG_OSA_400 (0x05 << 0)
-// 800Hz
-#define KXTJ3_DATA_CTRL_REG_OSA_800 (0x06 << 0)
-// 1600Hz
-#define KXTJ3_DATA_CTRL_REG_OSA_1600 (0x07 << 0)
-// 0.78Hz
-#define KXTJ3_DATA_CTRL_REG_OSA_0P781 (0x08 << 0)
-// 1.563Hz
-#define KXTJ3_DATA_CTRL_REG_OSA_1P563 (0x09 << 0)
-// 3.125Hz
-#define KXTJ3_DATA_CTRL_REG_OSA_3P125 (0x0A << 0)
-// 6.25Hz
-#define KXTJ3_DATA_CTRL_REG_OSA_6P25 (0x0B << 0)
-// charge on
-#define KXTJ3_SELF_TEST_MEMS_TEST_ENABLE (0xCA << 0)
-// charge off
-#define KXTJ3_SELF_TEST_MEMS_TEST_DISABLE (0x00 << 0)
-// WHO_AM_I -value for KXCJC
-#define KXCJC_WHO_AM_I_WIA_ID (0x36 << 0)
-/*registers bit masks */
-
-#define KXTJ3_DCST_RESP_DCSTR_MASK 0xFF
-
-#define KXTJ3_WHO_AM_I_WIA_MASK 0xFF
-// selects the acceleration range of the accelerometer outputs
-#define KXTJ3_CTRL_REG1_GSEL_MASK 0x1C
-// sets the Output Data Rate for the Wake Up function
-#define KXTJ3_CTRL_REG2_OWUF_MASK 0x07
-// sets the output data rate (ODR)
-#define KXTJ3_DATA_CTRL_REG_OSA_MASK 0x0F
-
-#define KXTJ3_SELF_TEST_MEMS_TEST_MASK 0xFF
-
-#define KXCJC_WHO_AM_I_WIA_MASK 0xFF
-#endif
diff --git a/src/l298/CMakeLists.txt b/src/l298/CMakeLists.txt
deleted file mode 100644
index e3bab60..0000000
--- a/src/l298/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "l298")
-set (libdescription "Dual H-bridge Motor Driver")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/l298/l298.cxx b/src/l298/l298.cxx
deleted file mode 100644
index 288eb96..0000000
--- a/src/l298/l298.cxx
+++ /dev/null
@@ -1,348 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "l298.hpp"
-
-using namespace upm;
-using namespace std;
-
-// constructor for the DC motor(s) mode
-L298::L298(int pwmA, int dir1, int dir2)
-{
-  // No stepper in this mode
-  m_stepper = false;
-
-  // disable until complete
-  m_motor = false;
-
-  if ( !(m_pwm = mraa_pwm_init(pwmA)) )
-    {
-      throw std::invalid_argument(std::string(__FUNCTION__) +
-                                  ": mraa_pwm_init() failed, invalid pin?");
-      return;
-    }
-
-  if ( !(m_dir1 = mraa_gpio_init(dir1)) )
-    {
-      throw std::invalid_argument(std::string(__FUNCTION__) +
-                                  ": mraa_gpio_init(dir1) failed, invalid pin?");
-      mraa_pwm_close(m_pwm);
-      return;
-    }
-  mraa_gpio_dir(m_dir1, MRAA_GPIO_OUT);
-
-  if ( !(m_dir2 = mraa_gpio_init(dir2)) )
-    {
-      throw std::invalid_argument(std::string(__FUNCTION__) +
-                                  ": mraa_gpio_init(dir2) failed, invalid pin?");
-      mraa_pwm_close(m_pwm);
-      mraa_gpio_close(m_dir1);
-      return;
-    }
-  mraa_gpio_dir(m_dir2, MRAA_GPIO_OUT);
-
-  setPeriodMS(L298_DEFAULT_PWM_PERIOD);
-  setDirection(DIR_NONE);
-  setSpeed(0);
-  m_motor = true;
-}
-
-// constructor for the stepper mode
-L298::L298(int stepsPerRev, int en, int i1, int i2, int i3, int i4)
-{
-  // no DC motors in this mode
-  m_motor = false;
-
-  // disable until complete
-  m_stepper = false;
-
-  m_stepsPerRev = stepsPerRev;
-  m_currentStep = 0;
-  m_stepDelay = 0;
-  m_stepDirection = 1;          // default is forward
-
-  // init the gpio's we will need
-  if ( !(m_stepEnable = mraa_gpio_init(en)) )
-    {
-      throw std::invalid_argument(std::string(__FUNCTION__) +
-                                  ": mraa_gpio_init(en) failed, invalid pin?");
-      return;
-    }
-  mraa_gpio_dir(m_stepEnable, MRAA_GPIO_OUT);
-
-  if ( !(m_stepI1 = mraa_gpio_init(i1)) )
-    {
-      throw std::invalid_argument(std::string(__FUNCTION__) +
-                                  ": mraa_gpio_init(i1) failed, invalid pin?");
-      return;
-    }
-  mraa_gpio_dir(m_stepI1, MRAA_GPIO_OUT);
-
-  if ( !(m_stepI2 = mraa_gpio_init(i2)) )
-    {
-      throw std::invalid_argument(std::string(__FUNCTION__) +
-                                  ": mraa_gpio_init(i2) failed, invalid pin?");
-      mraa_gpio_close(m_stepI1);
-      return;
-    }
-  mraa_gpio_dir(m_stepI2, MRAA_GPIO_OUT);
-
-  if ( !(m_stepI3 = mraa_gpio_init(i3)) )
-    {
-      throw std::invalid_argument(std::string(__FUNCTION__) +
-                                  ": mraa_gpio_init(i3) failed, invalid pin?");
-      mraa_gpio_close(m_stepI1);
-      mraa_gpio_close(m_stepI2);
-      return;
-    }
-  mraa_gpio_dir(m_stepI3, MRAA_GPIO_OUT);
-
-  if ( !(m_stepI4 = mraa_gpio_init(i4)) )
-    {
-      throw std::invalid_argument(std::string(__FUNCTION__) +
-                                  ": mraa_gpio_init(i4) failed, invalid pin?");
-      mraa_gpio_close(m_stepI1);
-      mraa_gpio_close(m_stepI2);
-      mraa_gpio_close(m_stepI3);
-      
-      return;
-    }
-  mraa_gpio_dir(m_stepI4, MRAA_GPIO_OUT);
-
-  m_stepper = true;
-}
-
-
-void L298::initClock()
-{
-  gettimeofday(&m_startTime, NULL);
-}
-
-uint32_t L298::getMillis()
-{
-  struct timeval elapsed, now;
-  uint32_t elapse;
-
-  // get current time
-  gettimeofday(&now, NULL);
-
-  // compute the delta since m_startTime
-  if( (elapsed.tv_usec = now.tv_usec - m_startTime.tv_usec) < 0 )
-    {
-      elapsed.tv_usec += 1000000;
-      elapsed.tv_sec = now.tv_sec - m_startTime.tv_sec - 1;
-    }
-  else
-    {
-      elapsed.tv_sec = now.tv_sec - m_startTime.tv_sec;
-    }
-
-  elapse = (uint32_t)((elapsed.tv_sec * 1000) + (elapsed.tv_usec / 1000));
-
-  // never return 0
-  if (elapse == 0)
-    elapse = 1;
-
-  return elapse;
-}
-
-
-L298::~L298()
-{
-  if (m_stepper)
-    {
-      enable(false);
-      mraa_gpio_close(m_stepEnable);
-      mraa_gpio_close(m_stepI1);
-      mraa_gpio_close(m_stepI2);
-      mraa_gpio_close(m_stepI3);
-      mraa_gpio_close(m_stepI4);
-    }
-
-  if (m_motor)
-    {
-      setDirection(DIR_NONE);
-      setSpeed(0);
-      enable(false);
-      mraa_pwm_close(m_pwm);
-      mraa_gpio_close(m_dir1);
-      mraa_gpio_close(m_dir2);
-    }
-}
-
-void L298::setPeriodMS(int ms)
-{
-  if (m_motor)
-    {
-      if (mraa_pwm_period_ms(m_pwm, ms) != MRAA_SUCCESS)
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_pwm_period_ms() failed");
-    }
-}
-
-void L298::enable(bool enable)
-{
-  if (m_motor)
-    {
-      mraa_pwm_enable(m_pwm, ((enable) ? 1 : 0));
-    }
-
-  if (m_stepper)
-    {
-      mraa_gpio_write(m_stepEnable, ((enable) ? 1 : 0));
-    }
-}
-
-void L298::setSpeed(int speed)
-{
-  if (m_motor)
-    {
-      if (speed < 0)
-        speed = 0;
-
-      if (speed > 100)
-        speed = 100;
-
-      float percent = float(speed) / 100.0;
-
-      if (m_motor)
-        {
-          mraa_pwm_write(m_pwm, percent);
-        }
-    }
-
-  if (m_stepper)
-    {
-      // prevent a possible divide by 0
-      if (!speed)
-         speed = 1;
-      m_stepDelay = 60 * 1000 / m_stepsPerRev / speed;
-    }
-}
-
-void L298::setDirection(L298_DIRECTION_T dir)
-{
-  if (m_motor)
-    {
-      if (dir & 0x01)
-        mraa_gpio_write(m_dir1, 1);
-      else
-        mraa_gpio_write(m_dir1, 0);
-
-      if (dir & 0x02)
-        mraa_gpio_write(m_dir2, 1);
-      else
-        mraa_gpio_write(m_dir2, 0);
-    }
-
-  if (m_stepper)
-    {
-      switch (dir)
-        {
-        case DIR_CW:
-          m_stepDirection = 1;
-          break;
-        case DIR_CCW:
-          m_stepDirection = -1;
-          break;
-        default:                // default to 1 if DIR_NONE specified
-          m_stepDirection = 1;
-          break;
-        }
-    }
-
-
-}
-
-void L298::stepperStep()
-{
-  int step = m_currentStep % 4;
-
-  //   Step I0 I1 I2 I3
-  //     1  1  0  1  0
-  //     2  0  1  1  0
-  //     3  0  1  0  1
-  //     4  1  0  0  1
-
-  switch (step)
-    {
-    case 0:    // 1010
-      mraa_gpio_write(m_stepI1, 1);
-      mraa_gpio_write(m_stepI2, 0);
-      mraa_gpio_write(m_stepI3, 1);
-      mraa_gpio_write(m_stepI4, 0);
-      break;
-    case 1:    // 0110
-      mraa_gpio_write(m_stepI1, 0);
-      mraa_gpio_write(m_stepI2, 1);
-      mraa_gpio_write(m_stepI3, 1);
-      mraa_gpio_write(m_stepI4, 0);
-      break;
-    case 2:    //0101
-      mraa_gpio_write(m_stepI1, 0);
-      mraa_gpio_write(m_stepI2, 1);
-      mraa_gpio_write(m_stepI3, 0);
-      mraa_gpio_write(m_stepI4, 1);
-      break;
-    case 3:    //1001
-      mraa_gpio_write(m_stepI1, 1);
-      mraa_gpio_write(m_stepI2, 0);
-      mraa_gpio_write(m_stepI3, 0);
-      mraa_gpio_write(m_stepI4, 1);
-      break;
-    }
-}
-
-void L298::stepperSteps(unsigned int steps)
-{
-  while (steps > 0)
-    {
-      if (getMillis() >= m_stepDelay)
-        {
-          // reset the clock
-          initClock();
-
-          m_currentStep += m_stepDirection;
-
-          if (m_stepDirection == 1)
-            {
-              if (m_currentStep >= m_stepsPerRev)
-                m_currentStep = 0;
-            }
-          else
-            {
-              if (m_currentStep <= 0)
-                m_currentStep = m_stepsPerRev;
-            }
-
-          steps--;
-          stepperStep();
-          // cerr << "STEPNUM: " << m_currentStep << endl;
-        }
-    }
-}
diff --git a/src/l298/l298.hpp b/src/l298/l298.hpp
deleted file mode 100644
index dbada71..0000000
--- a/src/l298/l298.hpp
+++ /dev/null
@@ -1,194 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <stdint.h>
-#include <sys/time.h>
-
-#include <mraa/gpio.h>
-#include <mraa/pwm.h>
-
-// in milliseconds
-#define L298_DEFAULT_PWM_PERIOD 4
-
-namespace upm {
-  /**
-   * @brief L298 Dual H-Bridge Motor Driver
-   * @defgroup l298 libupm-l298
-   * @ingroup seeed sparkfun gpio pwm motor
-   */
-
-  /**
-   * @library l298
-   * @sensor l298
-   * @comname Dual H-bridge Motor Driver
-   * @type motor
-   * @man seeed sparkfun
-   * @web https://www.sparkfun.com/products/9670
-   * @con gpio pwm
-   *
-   * @brief API for the L298 Dual H-Bridge Motor Driver
-   *
-   * It was developed using the RobotBase Dual H-Bridge module.
-   *
-   * This module can support 2 DC motors, or one 2-phase stepper motor.
-   * It requires 3 pins per DC motor (or H-bridge), or 4 pins for
-   * the stepper motor (uses both H-bridges). 
-   *
-   * @image html l298.jpg
-   * <br><em>L298 Dual H-Bridge Motor Driver image provided by SparkFun* under
-   * <a href=https://creativecommons.org/licenses/by/2.0/>
-   * CC BY 2.0</a>.</em> 
-   *
-   * Example driving a DC motor
-   * @snippet l298.cxx Interesting
-   * Example driving a stepper motor
-   * @snippet l298-stepper.cxx Interesting
-   */
-  class L298 {
-  public:
-
-    /**
-     * Enum to specify the direction of a motor
-     */
-    typedef enum {
-      DIR_NONE = 0x00,
-      DIR_CW   = 0x01,
-      DIR_CCW  = 0x02
-    } L298_DIRECTION_T;
-
-    /**
-     * L298 constructor for DC motor(s) connected.  
-     *
-     * @param pwm Digital pin to use for a DC motor - must be PWM-capable
-     * @param dir1 Digital pin to use for motor direction pin 1
-     * @param dir2 Digital pin to use for motor direction pin 2
-     */
-    L298(int pwm, int dir1, int dir2);
-
-    /**
-     * L298 constructor for a 4-wire stepper motor
-     *
-     * @param stepsPerRev Number of steps per full revolution
-     * @param en Enables the pin
-     * @param i1 Digital pin to use for stepper input 1
-     * @param i2 Digital pin to use for stepper input 2
-     * @param i3 Digital pin to use for stepper input 3
-     * @param i4 Digital pin to use for stepper input 4
-     */
-    L298(int stepsPerRev, int en, int i1, int i2, int i3, int i4);
-
-    /**
-     * L298 destructor
-     */
-    ~L298();
-
-    /**
-     * Returns the number of milliseconds elapsed since initClock()
-     * was last called.
-     *
-     * @return Elapsed milliseconds
-     */
-    uint32_t getMillis();
-
-    /**
-     * Resets the clock
-     *
-     */
-    void initClock();
-
-    /**
-     * Sets the period in milliseconds
-     *
-     * @param ms Period in milliseconds
-     */
-    void setPeriodMS(int ms);
-
-    /**
-     * Enables the PWM output for a motor
-     *
-     * @param enable Enables the PWM output if true, disables if false
-     */
-    void enable(bool enable);
-
-    /**
-     * Sets the speed of a DC or stepper motor. For a DC motor, values
-     * can range from 0 (off) to 100 (full speed). For a stepper
-     * motor, specify the desired RPM.
-     *
-     * @param speed Speed to set the motor to
-     */
-    void setSpeed(int speed);
-
-    /**
-     * Sets the direction of the motor, clockwise or counterclockwise
-     *
-     * @param dir Direction to set the motor to
-     */
-    void setDirection(L298_DIRECTION_T dir);
-
-    /**
-     * Steps the stepper motor a specified number of steps
-     *
-     * @param steps Number of steps to move the stepper motor
-     */
-    void stepperSteps(unsigned int steps);
-
-  private:
-    // DC motor mode enabled
-    bool m_motor;
-    // stepper mode enabled
-    bool m_stepper;
-
-    struct timeval m_startTime;
-
-    // DC motor
-    mraa_pwm_context m_pwm;
-    mraa_gpio_context m_dir1;
-    mraa_gpio_context m_dir2;
-
-    // stepper (4-wire)
-    mraa_gpio_context m_stepEnable;
-    mraa_gpio_context m_stepI1;
-    mraa_gpio_context m_stepI2;
-    mraa_gpio_context m_stepI3;
-    mraa_gpio_context m_stepI4;
-
-    // steps per revolution
-    int m_stepsPerRev;
-    int m_currentStep;
-    uint32_t m_stepDelay;
-
-    /**
-     * Steps the motor one tick
-     *
-     */
-    void stepperStep();
-
-    // step direction: - 1 = forward, -1 = backward
-    int m_stepDirection;
-  };
-}
-
-
diff --git a/src/l298/l298.json b/src/l298/l298.json
deleted file mode 100644
index e99e487..0000000
--- a/src/l298/l298.json
+++ /dev/null
@@ -1,38 +0,0 @@
-{
-    "Library": "l298",
-    "Description": "API for the L298 Dual H-Bridge Motor Driver",
-    "Sensor Class":
-    {
-        "L298":
-        {
-            "Name": "Dual H-bridge Motor Driver",
-            "Description": "It was developed using the RobotBase Dual H-Bridge module. This module can support 2 DC motors, or one 2-phase stepper motor. It requires 3 pins per DC motor (or H-bridge), or 4 pins for the stepper motor (uses both H-bridges).",
-            "Aliases": ["l298"],
-            "Categories": ["motors"],
-            "Connections": ["gpio", "pwm"],
-            "Project Type": ["robotics", "prototyping"],
-            "Manufacturers": ["seeed", "sparkfun"],
-            "Kits": [],
-            "Image": "l298.jpg",
-            "Examples":
-            {
-                "Java": [],
-                "Python": ["l298.py", "l298-stepper.py"],
-                "Node.js": ["l298.js", "l298-stepper.js"],
-                "C++": ["l298.cxx", "l298-stepper.cxx"],
-                "C": []
-            },
-            "Specifications":
-            {
-                "Motor Supply Voltage": {"unit": "V", "low": 6, "high": 35},
-                "Motor Supply Current": {"unit": "A", "typ": 2}
-            },
-            "Urls" :
-            {
-                "Product Pages": ["https://www.sparkfun.com/products/9670"],
-                "Datasheets": [],
-                "Schematics": []
-            }
-        }
-    }
-}
diff --git a/src/l3gd20/CMakeLists.txt b/src/l3gd20/CMakeLists.txt
deleted file mode 100644
index a91a1f1..0000000
--- a/src/l3gd20/CMakeLists.txt
+++ /dev/null
@@ -1,7 +0,0 @@
-if (MRAA_IIO_FOUND)
-    set (libname "l3gd20")
-    set (libdescription "Tri-axis Digital Gyroscope")
-    set (module_src ${libname}.cxx)
-    set (module_hpp ${libname}.hpp)
-    upm_module_init(mraa)
-endif (MRAA_IIO_FOUND)
diff --git a/src/l3gd20/l3gd20.cxx b/src/l3gd20/l3gd20.cxx
deleted file mode 100644
index 091a790..0000000
--- a/src/l3gd20/l3gd20.cxx
+++ /dev/null
@@ -1,709 +0,0 @@
-/*
- * Author: Lay, Kuan Loon <kuan.loon.lay@intel.com>
- *         Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-#include <string.h>
-#include <math.h>
-#include "l3gd20.hpp"
-
-#define NUMBER_OF_BITS_IN_BYTE 8
-#define GYRO_MIN_SAMPLES 5 /* Drop first few gyro samples after enable */
-#define GYRO_MAX_ERR 0.05
-#define GYRO_DS_SIZE 100
-
-#define GYRO_DENOISE_MAX_SAMPLES 5
-#define GYRO_DENOISE_NUM_FIELDS 3
-
-using namespace upm;
-using namespace std;
-
-static float c2f(float c)
-{
-  return (c * (9.0 / 5.0) + 32.0);
-}
-
-L3GD20::L3GD20(int device) :
-  m_i2c(0)
-{
-    float gyro_scale;
-    char trigger[64];
-
-    if (!(m_iio = mraa_iio_init(device))) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_iio_init() failed, invalid device?");
-        return;
-    }
-
-    m_scale = 1;
-    m_iio_device_num = device;
-    sprintf(trigger, "hrtimer-l3gd20-hr-dev%d", device);
-
-    if (mraa_iio_create_trigger(m_iio, trigger) != MRAA_SUCCESS)
-        fprintf(stderr, "Create trigger %s failed\n", trigger);
-
-    if (mraa_iio_get_mount_matrix(m_iio, "in_mount_matrix", m_mount_matrix) == MRAA_SUCCESS)
-        m_mount_matrix_exist = true;
-    else
-        m_mount_matrix_exist = false;
-
-    if (mraa_iio_read_float(m_iio, "in_anglvel_x_scale", &gyro_scale) == MRAA_SUCCESS)
-        m_scale = gyro_scale;
-
-    m_event_count = 0;
-
-    // initial calibrate data
-    initCalibrate();
-
-    // initial denoise data
-    m_filter.buff =
-    (float*) calloc(GYRO_DENOISE_MAX_SAMPLES, sizeof(float) * GYRO_DENOISE_NUM_FIELDS);
-    if (m_filter.buff == NULL) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_iio_init() failed, calloc denoise data");
-        return;
-    }
-    m_filter.sample_size = GYRO_DENOISE_MAX_SAMPLES;
-    m_filter.count = 0;
-    m_filter.idx = 0;
-}
-
-L3GD20::L3GD20(int bus, int addr)
-{
-  m_i2c = new mraa::I2c(bus);
-
-  if (m_i2c->address(addr) != mraa::SUCCESS)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": I2c.address() failed");
-    }
-
-  m_scale = 1.0;
-  m_iio_device_num = 0;
-
-  m_gyrScale = 1.0;
-  m_gyrX = 0.0;
-  m_gyrY = 0.0;
-  m_gyrZ = 0.0;
-  m_temperature = 0.0;
-
-  m_mount_matrix_exist = false;
-  m_event_count = 0;
-
-  // initial calibrate data
-  initCalibrate();
-
-  // initial denoise data
-  m_filter.buff =
-    (float*) calloc(GYRO_DENOISE_MAX_SAMPLES,
-                    sizeof(float) * GYRO_DENOISE_NUM_FIELDS);
-
-  if (m_filter.buff == NULL)
-    {
-      throw std::bad_alloc();
-      return;
-    }
-
-  m_filter.sample_size = GYRO_DENOISE_MAX_SAMPLES;
-  m_filter.count = 0;
-  m_filter.idx = 0;
-
-  // check ChipID
-
-  uint8_t cid = getChipID();
-  if (!(cid == L3GD20_DEFAULT_CHIP_ID || cid == L3GD20H_DEFAULT_CHIP_ID))
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": Invalid Chip ID: expected "
-                               + to_string(L3GD20_DEFAULT_CHIP_ID)
-                               + " or "
-                               + to_string(L3GD20H_DEFAULT_CHIP_ID)
-                               + ", got "
-                               + to_string(int(cid)));
-      return;
-    }
-
-  // set a normal power mode (with all axes enabled)
-  setPowerMode(POWER_NORMAL);
-
-  // enable block update mode
-  enableBDU(true);
-
-  // Set range to 250 degrees/sec/
-  setRange(FS_250);
-
-  // Set ODR to 95Hz, 25Hz cut-off
-  setODR(ODR_CUTOFF_95_25);
-}
-
-L3GD20::~L3GD20()
-{
-    if (m_filter.buff) {
-        free(m_filter.buff);
-        m_filter.buff = NULL;
-    }
-    if (m_iio)
-        mraa_iio_close(m_iio);
-}
-
-uint8_t L3GD20::readReg(uint8_t reg)
-{
-  return m_i2c->readReg(reg);
-}
-
-int L3GD20::readRegs(uint8_t reg, uint8_t *buffer, int len)
-{
-  // For multi-byte reads, the reg must have the MSb set
-  return m_i2c->readBytesReg(reg | 0x80, buffer, len);
-}
-
-void L3GD20::writeReg(uint8_t reg, uint8_t val)
-{
-  if (m_i2c->writeReg(reg, val) != mraa::SUCCESS)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__)
-                               + ": I2c.writeReg() failed");
-    }
-}
-
-uint8_t L3GD20::getChipID()
-{
-  return readReg(REG_WHO_AM_I);
-}
-
-void L3GD20::setPowerMode(POWER_MODES_T mode)
-{
-  uint8_t reg = readReg(REG_CTRL_REG1);
-
-  // setting the power modes involves setting certain combinations of
-  // the PD, and the X, Y, and Zen bitfields.
-
-  switch(mode)
-    {
-    case POWER_DOWN:
-      // clear PD
-      reg &= ~(CTRL_REG1_PD);
-      break;
-
-    case POWER_SLEEP:
-      // set PD, clear X, Y, and Zen.
-      reg |= CTRL_REG1_PD;
-      reg &= ~(CTRL_REG1_YEN | CTRL_REG1_XEN | CTRL_REG1_ZEN);
-      break;
-
-    case POWER_NORMAL:
-      // set PD, X, Y, and Zen.
-      reg |= (CTRL_REG1_PD | CTRL_REG1_YEN | CTRL_REG1_XEN | CTRL_REG1_ZEN);
-      break;
-    }
-
-  writeReg(REG_CTRL_REG1, reg);
-}
-
-void L3GD20::setRange(FS_T range)
-{
-  switch(range)
-    {
-    case FS_250:
-      m_gyrScale = 8.75; // milli-degrees
-      break;
-
-    case FS_500:
-      m_gyrScale = 17.50;
-      break;
-
-    case FS_2000:
-      m_gyrScale = 70.0;
-      break;
-    }
-
-  uint8_t reg = readReg(REG_CTRL_REG4) & ~(_CTRL_REG4_RESERVED_BITS);
-  // mask off current FS
-  reg &= ~(_CTRL_REG4_FS_MASK << _CTRL_REG4_FS_SHIFT);
-  // add our new FS
-  reg |= (range << _CTRL_REG4_FS_SHIFT);
-
-  writeReg(REG_CTRL_REG4, reg);
-}
-
-void L3GD20::enableBDU(bool enable)
-{
-  uint8_t reg = readReg(REG_CTRL_REG4) & ~(_CTRL_REG4_RESERVED_BITS);
-
-  if (enable)
-    reg |= CTRL_REG4_BDU;
-  else
-    reg &= ~CTRL_REG4_BDU;
-
-  writeReg(REG_CTRL_REG4, reg);
-}
-
-void L3GD20::getGyroscope(float *x, float *y, float *z)
-{
-  if (x)
-    *x = m_gyrX;
-
-  if (y)
-    *y = m_gyrY;
-
-  if (z)
-    *z = m_gyrZ;
-}
-
-void L3GD20::update()
-{
-  int bufLen = 6;
-  uint8_t buf[bufLen];
-
-  if (readRegs(REG_OUT_X_L, buf, bufLen) != bufLen)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__)
-                               + ": readRegs() failed to read "
-                               + to_string(bufLen)
-                               + " bytes");
-    }
-
-  int16_t val;
-
-  // The calibration and denoise algorithms depend on the use of
-  // radians rather than degrees, so we convert to radians here.
-
-  val = int16_t(buf[1] << 8 | buf[0]);
-  m_gyrX = ((float(val) * m_gyrScale) / 1000.0) * (M_PI/180.0);
-  m_gyrX = m_gyrX - m_cal_data.bias_x;
-
-  // y
-  val = int16_t(buf[3] << 8 | buf[2]);
-  m_gyrY = ((float(val) * m_gyrScale) / 1000.0) * (M_PI/180.0);
-  m_gyrY = m_gyrY - m_cal_data.bias_y;
-
-  // z
-  val = int16_t(buf[5] << 8 | buf[4]);
-  m_gyrZ = ((float(val) * m_gyrScale) / 1000.0) * (M_PI/180.0);
-  m_gyrZ = m_gyrZ - m_cal_data.bias_z;
-
-  if (m_calibrated == false)
-    m_calibrated = gyroCollect(m_gyrX, m_gyrY, m_gyrZ);
-
-  if (m_event_count++ >= GYRO_MIN_SAMPLES)
-    {
-      gyroDenoiseMedian(&m_gyrX, &m_gyrY, &m_gyrZ);
-      clampGyroReadingsToZero(&m_gyrX, &m_gyrY, &m_gyrZ);
-    }
-
-  // get the temperature...
-  uint8_t temp = readReg(REG_OUT_TEMPERATURE);
-  m_temperature = (float)temp;
-}
-
-float L3GD20::getTemperature(bool fahrenheit)
-{
-  if (fahrenheit)
-    return c2f(m_temperature);
-  else
-    return m_temperature;
-}
-
-void L3GD20::setODR(ODR_CUTOFF_T odr)
-{
-  uint8_t reg = readReg(REG_CTRL_REG1);
-
-  reg &= ~(_CTRL_REG1_ODR_CUTOFF_MASK << _CTRL_REG1_ODR_CUTOFF_SHIFT);
-  reg |= (odr << _CTRL_REG1_ODR_CUTOFF_SHIFT);
-
-  writeReg(REG_CTRL_REG1, reg);
-}
-
-uint8_t L3GD20::getStatusBits()
-{
-  return readReg(REG_STATUS_REG);
-}
-
-
-void
-L3GD20::installISR(void (*isr)(char*, void*), void* arg)
-{
-    mraa_iio_trigger_buffer(m_iio, isr, arg);
-}
-
-int64_t
-L3GD20::getChannelValue(unsigned char* input, mraa_iio_channel* chan)
-{
-    uint64_t u64 = 0;
-    int i;
-    int storagebits = chan->bytes * NUMBER_OF_BITS_IN_BYTE;
-    int realbits = chan->bits_used;
-    int zeroed_bits = storagebits - realbits;
-    uint64_t sign_mask;
-    uint64_t value_mask;
-
-    if (!chan->lendian)
-        for (i = 0; i < storagebits / NUMBER_OF_BITS_IN_BYTE; i++)
-            u64 = (u64 << 8) | input[i];
-    else
-        for (i = storagebits / NUMBER_OF_BITS_IN_BYTE - 1; i >= 0; i--)
-            u64 = (u64 << 8) | input[i];
-
-    u64 = (u64 >> chan->shift) & (~0ULL >> zeroed_bits);
-
-    if (!chan->signedd)
-        return (int64_t) u64; /* We don't handle unsigned 64 bits int */
-
-    /* Signed integer */
-
-    switch (realbits) {
-        case 0 ... 1:
-            return 0;
-
-        case 8:
-            return (int64_t)(int8_t) u64;
-
-        case 16:
-            return (int64_t)(int16_t) u64;
-
-        case 32:
-            return (int64_t)(int32_t) u64;
-
-        case 64:
-            return (int64_t) u64;
-
-        default:
-            sign_mask = 1 << (realbits - 1);
-            value_mask = sign_mask - 1;
-
-            if (u64 & sign_mask)
-                return -((~u64 & value_mask) + 1); /* Negative value: return 2-complement */
-            else
-                return (int64_t) u64; /* Positive value */
-    }
-}
-
-bool
-L3GD20::enableBuffer(int length)
-{
-    mraa_iio_write_int(m_iio, "buffer/length", length);
-    // enable must be last step, else will have error in writing above config
-    mraa_iio_write_int(m_iio, "buffer/enable", 1);
-    return true;
-}
-
-bool
-L3GD20::disableBuffer()
-{
-    mraa_iio_write_int(m_iio, "buffer/enable", 0);
-    return true;
-}
-
-bool
-L3GD20::setScale(float scale)
-{
-    m_scale = scale;
-
-    mraa_iio_write_float(m_iio, "in_anglvel_x_scale", scale);
-    mraa_iio_write_float(m_iio, "in_anglvel_y_scale", scale);
-    mraa_iio_write_float(m_iio, "in_anglvel_z_scale", scale);
-    return true;
-}
-
-bool
-L3GD20::setSamplingFrequency(float sampling_frequency)
-{
-    mraa_iio_write_float(m_iio, "sampling_frequency", sampling_frequency);
-    return true;
-}
-
-bool
-L3GD20::enable3AxisChannel()
-{
-    char trigger[64];
-    sprintf(trigger, "l3gd20-hr-dev%d", m_iio_device_num);
-
-    mraa_iio_write_string(m_iio, "trigger/current_trigger", trigger);
-    mraa_iio_write_int(m_iio, "scan_elements/in_anglvel_x_en", 1);
-    mraa_iio_write_int(m_iio, "scan_elements/in_anglvel_y_en", 1);
-    mraa_iio_write_int(m_iio, "scan_elements/in_anglvel_z_en", 1);
-
-    // need update channel data size after enable
-    mraa_iio_update_channels(m_iio);
-    return true;
-}
-
-bool
-L3GD20::extract3Axis(char* data, float* x, float* y, float* z)
-{
-    mraa_iio_channel* channels = mraa_iio_get_channels(m_iio);
-    float tmp[3];
-    int iio_x, iio_y, iio_z;
-
-    m_event_count++;
-
-    if (m_event_count < GYRO_MIN_SAMPLES) {
-        /* drop the sample */
-        return false;
-    }
-
-    iio_x = getChannelValue((unsigned char*) (data + channels[0].location), &channels[0]);
-    iio_y = getChannelValue((unsigned char*) (data + channels[1].location), &channels[1]);
-    iio_z = getChannelValue((unsigned char*) (data + channels[2].location), &channels[2]);
-
-    // Raw data is x, y, z axis angular velocity. Units after application of scale are radians per
-    // second
-    *x = (iio_x * m_scale);
-    *y = (iio_y * m_scale);
-    *z = (iio_z * m_scale);
-
-    if (m_mount_matrix_exist) {
-        tmp[0] = *x * m_mount_matrix[0] + *y * m_mount_matrix[1] + *z * m_mount_matrix[2];
-        tmp[1] = *x * m_mount_matrix[3] + *y * m_mount_matrix[4] + *z * m_mount_matrix[5];
-        tmp[2] = *x * m_mount_matrix[6] + *y * m_mount_matrix[7] + *z * m_mount_matrix[8];
-
-        *x = tmp[0];
-        *y = tmp[1];
-        *z = tmp[2];
-    }
-
-    /* Attempt gyroscope calibration if we have not reached this state */
-    if (m_calibrated == false)
-        m_calibrated = gyroCollect(*x, *y, *z);
-
-    *x = *x - m_cal_data.bias_x;
-    *y = *y - m_cal_data.bias_y;
-    *z = *z - m_cal_data.bias_z;
-
-
-    gyroDenoiseMedian(x, y, z);
-    clampGyroReadingsToZero(x, y, z);
-
-    return true;
-}
-
-void
-L3GD20::initCalibrate()
-{
-    m_calibrated = false;
-    m_cal_data.count = 0;
-    m_cal_data.bias_x = m_cal_data.bias_y = m_cal_data.bias_z = 0;
-    m_cal_data.min_x = m_cal_data.min_y = m_cal_data.min_z = 1.0;
-    m_cal_data.max_x = m_cal_data.max_y = m_cal_data.max_z = -1.0;
-}
-
-bool
-L3GD20::getCalibratedStatus()
-{
-    return m_calibrated;
-}
-
-void
-L3GD20::getCalibratedData(float* bias_x, float* bias_y, float* bias_z)
-{
-    *bias_x = m_cal_data.bias_x;
-    *bias_y = m_cal_data.bias_y;
-    *bias_z = m_cal_data.bias_z;
-}
-
-void
-L3GD20::loadCalibratedData(float bias_x, float bias_y, float bias_z)
-{
-    m_calibrated = true;
-    m_cal_data.bias_x = bias_x;
-    m_cal_data.bias_y = bias_y;
-    m_cal_data.bias_z = bias_z;
-}
-
-bool
-L3GD20::gyroCollect(float x, float y, float z)
-{
-    /* Analyze gyroscope data */
-
-    if (fabs(x) >= 1 || fabs(y) >= 1 || fabs(z) >= 1) {
-        /* We're supposed to be standing still ; start over */
-        m_cal_data.count = 0;
-        m_cal_data.bias_x = m_cal_data.bias_y = m_cal_data.bias_z = 0;
-        m_cal_data.min_x = m_cal_data.min_y = m_cal_data.min_z = 1.0;
-        m_cal_data.max_x = m_cal_data.max_y = m_cal_data.max_z = -1.0;
-
-        return false; /* Uncalibrated */
-    }
-
-    /* Thanks to https://github.com/01org/android-iio-sensors-hal for calibration algorithm */
-    if (m_cal_data.count < GYRO_DS_SIZE) {
-        if (x < m_cal_data.min_x)
-            m_cal_data.min_x = x;
-
-        if (y < m_cal_data.min_y)
-            m_cal_data.min_y = y;
-
-        if (z < m_cal_data.min_z)
-            m_cal_data.min_z = z;
-
-        if (x > m_cal_data.max_x)
-            m_cal_data.max_x = x;
-
-        if (y > m_cal_data.max_y)
-            m_cal_data.max_y = y;
-
-        if (z > m_cal_data.max_z)
-            m_cal_data.max_z = z;
-
-        if (fabs(m_cal_data.max_x - m_cal_data.min_x) <= GYRO_MAX_ERR &&
-            fabs(m_cal_data.max_y - m_cal_data.min_y) <= GYRO_MAX_ERR &&
-            fabs(m_cal_data.max_z - m_cal_data.min_z) <= GYRO_MAX_ERR)
-            m_cal_data.count++; /* One more conformant sample */
-        else {
-            /* Out of spec sample ; start over */
-            m_calibrated = false;
-            m_cal_data.count = 0;
-            m_cal_data.bias_x = m_cal_data.bias_y = m_cal_data.bias_z = 0;
-            m_cal_data.min_x = m_cal_data.min_y = m_cal_data.min_z = 1.0;
-            m_cal_data.max_x = m_cal_data.max_y = m_cal_data.max_z = -1.0;
-        }
-
-        return false; /* Still uncalibrated */
-    }
-
-    /* We got enough stable samples to estimate gyroscope bias */
-    m_cal_data.bias_x = (m_cal_data.max_x + m_cal_data.min_x) / 2;
-    m_cal_data.bias_y = (m_cal_data.max_y + m_cal_data.min_y) / 2;
-    m_cal_data.bias_z = (m_cal_data.max_z + m_cal_data.min_z) / 2;
-
-    return true; /* Calibrated! */
-}
-
-void
-L3GD20::gyroDenoiseMedian(float* x, float* y, float* z)
-{
-    /* Thanks to https://github.com/01org/android-iio-sensors-hal for denoise algorithm */
-    unsigned int offset;
-
-    /* If we are at event count 1 reset the indices */
-    if (m_event_count == 1) {
-        m_filter.count = 0;
-        m_filter.idx = 0;
-    }
-
-    if (m_filter.count < m_filter.sample_size)
-        m_filter.count++;
-
-    offset = 0;
-    m_filter.buff[offset + m_filter.idx] = *x;
-    *x = median(m_filter.buff + offset, m_filter.count);
-
-    offset = m_filter.sample_size * 1;
-    m_filter.buff[offset + m_filter.idx] = *y;
-    *y = median(m_filter.buff + offset, m_filter.count);
-
-    offset = m_filter.sample_size * 2;
-    m_filter.buff[offset + m_filter.idx] = *z;
-    *z = median(m_filter.buff + offset, m_filter.count);
-
-    m_filter.idx = (m_filter.idx + 1) % m_filter.sample_size;
-}
-
-float
-L3GD20::median(float* queue, unsigned int size)
-{
-    /* http://en.wikipedia.org/wiki/Quickselect */
-
-    unsigned int left = 0;
-    unsigned int right = size - 1;
-    unsigned int pivot_index;
-    unsigned int median_index = (right / 2);
-    float temp[size];
-
-    memcpy(temp, queue, size * sizeof(float));
-
-    /* If the list has only one element return it */
-    if (left == right)
-        return temp[left];
-
-    while (left < right) {
-        pivot_index = (left + right) / 2;
-        pivot_index = partition(temp, left, right, pivot_index);
-        if (pivot_index == median_index)
-            return temp[median_index];
-        else if (pivot_index > median_index)
-            right = pivot_index - 1;
-        else
-            left = pivot_index + 1;
-    }
-
-    return temp[left];
-}
-
-unsigned int
-L3GD20::partition(float* list, unsigned int left, unsigned int right, unsigned int pivot_index)
-{
-    unsigned int i;
-    unsigned int store_index = left;
-    float aux;
-    float pivot_value = list[pivot_index];
-
-    /* Swap list[pivotIndex] and list[right] */
-    aux = list[pivot_index];
-    list[pivot_index] = list[right];
-    list[right] = aux;
-
-    for (i = left; i < right; i++) {
-        if (list[i] < pivot_value) {
-            /* Swap list[store_index] and list[i] */
-            aux = list[store_index];
-            list[store_index] = list[i];
-            list[i] = aux;
-            store_index++;
-        }
-    }
-
-    /* Swap list[right] and list[store_index] */
-    aux = list[right];
-    list[right] = list[store_index];
-    list[store_index] = aux;
-    return store_index;
-}
-
-void
-L3GD20::clampGyroReadingsToZero(float* x, float* y, float* z)
-{
-    float near_zero;
-
-    /* If we're calibrated, don't filter out as much */
-    if (m_calibrated)
-        near_zero = 0.02; /* rad/s */
-    else
-        near_zero = 0.1;
-
-    /* If motion on all axes is small enough */
-    if (fabs(*x) < near_zero && fabs(*y) < near_zero && fabs(*z) < near_zero) {
-        /*
-         * Report that we're not moving at all... but not exactly zero as composite sensors
-         * (orientation, rotation vector) don't
-         * seem to react very well to it.
-         */
-
-        *x *= 0.000001;
-        *y *= 0.000001;
-        *z *= 0.000001;
-    }
-}
diff --git a/src/l3gd20/l3gd20.hpp b/src/l3gd20/l3gd20.hpp
deleted file mode 100644
index ef90e9a..0000000
--- a/src/l3gd20/l3gd20.hpp
+++ /dev/null
@@ -1,712 +0,0 @@
-/*
- * Author: Lay, Kuan Loon <kuan.loon.lay@intel.com>
- *         Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * Thanks to https://github.com/01org/android-iio-sensors-hal for gyroscope
- * calibration and denoise algorithm.
- */
-#pragma once
-
-#include <string>
-#include <mraa/iio.h>
-#include <mraa/i2c.hpp>
-
-#define L3GD20_DEFAULT_I2C_BUS                      0
-// if SDO tied to GND
-#define L3GD20_DEFAULT_I2C_ADDR                     0x6a
-#define L3GD20_DEFAULT_CHIP_ID                      0xd4
-// the 'H' variant uses a different chip id
-#define L3GD20H_DEFAULT_CHIP_ID                     0xd7
-
-namespace upm
-{
-/**
- * @brief L3GD20 Tri-axis Digital Gyroscope
- * @defgroup l3gd20 libupm-l3gd20
- * @ingroup stmicro iio i2c tri-axis digital gyroscope
- */
-
-/**
- * @library l3gd20
- * @sensor l3gd20
- * @comname Tri-axis Digital Gyroscope
- * @type gyroscope
- * @man stmicro
- * @con iio i2c
- * @web http://www.st.com/en/mems-and-sensors/l3gd20.html
- *
- * @brief L3GD20 Tri-axis Digital Gyroscope API
- *
- * The L3GD20 The L3GD20 is a low-power three-axis angular rate
- * sensor.  This driver supports IIO and I2C modes.  Some methods will
- * only work in one mode or the other.  See the documentation on the
- * methods to determine whether a given method is operation in a given
- * mode.  Both the I2C and IIO mechanisms make use of the calibration and
- * denoise algorithms.
- *
- * For I2C mode, not all capabilities of the device are supported, but
- * a complete register map and low level read/write methods are
- * provided to add any missing functionality.
- *
- * Example using IIO
- * @snippet l3gd20.cxx Interesting
- * Example using I2C
- * @snippet l3gd20-i2c.cxx Interesting
- */
-
-class L3GD20
-{
-  public:
-    typedef struct {
-        float bias_x, bias_y, bias_z;
-        int count;
-        float min_x, min_y, min_z;
-        float max_x, max_y, max_z;
-    } gyro_cal_t;
-
-    typedef struct {
-        float* buff;
-        unsigned int idx;
-        unsigned int count;
-        unsigned int sample_size;
-    } filter_median_t;
-
-    // NOTE: Reserved registers must not be written into or permanent
-    // device damage can result.  Reading from them may return
-    // indeterminate values.  Registers containing reserved bitfields
-    // must be written as 0.  Reading reserved bitfields may return
-    // indeterminate values.
-
-    /**
-     * L3GD20 registers (i2c)
-     */
-    typedef enum {
-      // 0x00-0x0e reserved
-
-      REG_WHO_AM_I                            = 0x0f,
-
-      // 0x10-0x1f reserved
-
-      REG_CTRL_REG1                           = 0x20,
-      REG_CTRL_REG2                           = 0x21,
-      REG_CTRL_REG3                           = 0x22,
-      REG_CTRL_REG4                           = 0x23,
-      REG_CTRL_REG5                           = 0x24,
-
-      REG_REFERENCE                           = 0x25,
-
-      REG_OUT_TEMPERATURE                     = 0x26,
-
-      REG_STATUS_REG                          = 0x27,
-
-      // output registers (also for FIFO output)
-      REG_OUT_X_L                             = 0x28,
-      REG_OUT_X_H                             = 0x29,
-
-      REG_OUT_Y_L                             = 0x2a,
-      REG_OUT_Y_H                             = 0x2b,
-
-      REG_OUT_Z_L                             = 0x2c,
-      REG_OUT_Z_H                             = 0x2d,
-
-      REG_FIFO_CTRL_REG                       = 0x2e,
-      REG_FIFO_SRC_REG                        = 0x2f,
-
-      REG_INT1_CFG                            = 0x30,
-      REG_INT1_SRC                            = 0x31,
-
-      REG_INT1_TSH_XH                         = 0x32,
-      REG_INT1_TSH_XL                         = 0x33,
-
-      REG_INT1_TSH_YH                         = 0x34,
-      REG_INT1_TSH_YL                         = 0x35,
-
-      REG_INT1_TSH_ZH                         = 0x36,
-      REG_INT1_TSH_ZL                         = 0x37,
-      REG_INT1_DURATION                       = 0x38
-    } L3GD20_REGS_T;
-
-    /**
-     * CTRL_REG1 bits
-     */
-    typedef enum {
-      CTRL_REG1_YEN                           = 0x01,
-      CTRL_REG1_XEN                           = 0x02,
-      CTRL_REG1_ZEN                           = 0x04,
-      CTRL_REG1_PD                            = 0x08,
-
-      CTRL_REG1_BW0                           = 0x10, // bandwidth
-      CTRL_REG1_BW1                           = 0x20,
-      _CTRL_REG1_BW_MASK                      = 3,
-      _CTRL_REG1_BW_SHIFT                     = 4,
-
-      CTRL_REG1_DR0                           = 0x40, // data rate
-      CTRL_REG1_DR1                           = 0x80,
-      _CTRL_REG1_DR_MASK                      = 3,
-      _CTRL_REG1_DR_SHIFT                     = 6,
-
-      // together the BW and DR modes represent an output data rate
-      // (ODR) and a filter cut-off.  So here, we will create a 'fake'
-      // bitfield that can be used directly with the ODR_CUTOFF enum
-      _CTRL_REG1_ODR_CUTOFF0                  = 0x10,
-      _CTRL_REG1_ODR_CUTOFF1                  = 0x20,
-      _CTRL_REG1_ODR_CUTOFF2                  = 0x40,
-      _CTRL_REG1_ODR_CUTOFF3                  = 0x80,
-      _CTRL_REG1_ODR_CUTOFF_MASK              = 15,
-      _CTRL_REG1_ODR_CUTOFF_SHIFT             = 4
-
-    } CTRL_REG1_BITS_T;
-
-    /**
-     * CTRL_REG1_ODR_CUTOFF values
-     */
-    typedef enum {
-      ODR_CUTOFF_95_12_5                      = 0, // ODR 95Hz, CO 12.5
-      ODR_CUTOFF_95_25                        = 1, // ODR 95Hz, CO 25
-      // 2 and 3 same as 1
-
-      ODR_CUTOFF_190_12_5                     = 4,
-      ODR_CUTOFF_190_25                       = 5,
-      ODR_CUTOFF_190_50                       = 6,
-      ODR_CUTOFF_190_70                       = 7,
-
-      ODR_CUTOFF_380_20                       = 8,
-      ODR_CUTOFF_380_25                       = 9,
-      ODR_CUTOFF_380_50                       = 10,
-      ODR_CUTOFF_380_100                      = 11,
-
-      ODR_CUTOFF_760_30                       = 12,
-      ODR_CUTOFF_760_35                       = 13,
-      ODR_CUTOFF_760_50                       = 14,
-      ODR_CUTOFF_760_100                      = 15
-    } ODR_CUTOFF_T;
-
-    /**
-     * CTRL_REG1 power modes. Power is controlled via the PD, Zen,
-     * Yen, and Xen bitfields.
-     */
-    typedef enum {
-      POWER_DOWN,
-      POWER_SLEEP,
-      POWER_NORMAL
-    } POWER_MODES_T;
-
-    /**
-     * CTRL_REG2 bits
-     */
-    typedef enum {
-      _CTRL_REG2_RESERVED_BITS                = 0x40 | 0x80,
-
-      CTRL_REG2_HPCF0                         = 0x01, // highpass filter cutoff
-      CTRL_REG2_HPCF1                         = 0x02,
-      CTRL_REG2_HPCF2                         = 0x04,
-      CTRL_REG2_HPCF3                         = 0x08,
-      _CTRL_REG2_HPCF_MASK                    = 15,
-      _CTRL_REG2_HPCF_SHIFT                   = 0,
-
-      CTRL_REG2_HPM0                          = 0x10, // highpass filter mode
-      CTRL_REG2_HPM1                          = 0x20,
-      _CTRL_REG2_HPM_MASK                     = 3,
-      _CTRL_REG2_HPM_SHIFT                    = 4
-
-      // 0x40-0x80 reserved
-    } CTRL_REG2_BITS_T;
-
-
-    /**
-     * CTRL_REG2_HPCF values (see table 26 in the datasheet)
-     */
-    typedef enum {
-      HPCF_7_2                                = 0, // 7.2Hz CO (w/ ODR@95Hz)
-      HPCF_3_5                                = 1,
-      HPCF_1_8                                = 2,
-      HPCF_0_9                                = 3,
-      HPCF_0_45                               = 4,
-      HPCF_0_18                               = 5,
-      HPCF_0_09                               = 6,
-      HPCF_0_045                              = 7,
-      HPCF_0_018                              = 8,
-      HPCF_0_009                              = 9
-    } HPCF_T;
-
-    /**
-     * CTRL_REG2_HPM values
-     */
-    typedef enum {
-      HPM_NORMAL_RESET_FILTER                 = 0,
-      HPM_REFERENCE_SIGNAL                    = 1,
-      HPM_NORMAL                              = 2,
-      HPM_AUTORESET_ON_INT                    = 3
-    } HPM_T;
-
-    /**
-     * CTRL_REG3 bits
-     */
-    typedef enum {
-      CTRL_REG3_I2_EMPTY                      = 0x01,
-      CTRL_REG3_I2_ORUN                       = 0x02,
-      CTRL_REG3_I2_WTM                        = 0x04,
-      CTRL_REG3_I2_DRDY                       = 0x08,
-      CTRL_REG3_PP_OD                         = 0x10,
-      CTRL_REG3_H_LACTIVE                     = 0x20,
-      CTRL_REG3_I1_BOOT                       = 0x40,
-      CTRL_REG3_I1_INT1                       = 0x80
-    } CTRL_REG3_BITS_T;
-
-    /**
-     * CTRL_REG4 bits
-     */
-    typedef enum {
-      _CTRL_REG4_RESERVED_BITS                = 0x02 | 0x04 | 0x08,
-
-      CTRL_REG4_SIM                           = 0x01, // SPI 3 or 4 wire
-      // 0x02-0x08 reserved
-
-      CTRL_REG4_FS0                           = 0x10, // full scale select
-      CTRL_REG4_FS1                           = 0x20,
-      _CTRL_REG4_FS_MASK                      = 3,
-      _CTRL_REG4_FS_SHIFT                     = 4,
-
-      CTRL_REG4_BLE                           = 0x40, // endian selection
-      CTRL_REG4_BDU                           = 0x80  // block updating
-    } CTRL_REG4_BITS_T;
-
-    /**
-     * CTRL_REG4_FS values
-     */
-    typedef enum {
-      FS_250                                  = 0, // 250 deg/s
-      FS_500                                  = 1,
-      FS_2000                                 = 2
-    } FS_T;
-
-    /**
-     * CTRL_REG5 bits
-     */
-    typedef enum {
-      _CTRL_REG5_RESERVED_BITS                = 0x20,
-
-      CTRL_REG5_OUT_SEL0                      = 0x01,
-      CTRL_REG5_OUT_SEL1                      = 0x02,
-      _CTRL_REG5_OUT_SEL_MASK                 = 3,
-      _CTRL_REG5_OUT_SEL_SHIFT                = 0,
-
-      CTRL_REG5_INT1_SEL0                     = 0x04,
-      CTRL_REG5_INT1_SEL1                     = 0x08,
-      _CTRL_REG5_INT1_SEL_MASK                = 3,
-      _CTRL_REG5_INT1_SEL_SHIFT               = 2,
-
-      CTRL_REG5_HPEN                          = 0x10,
-
-      // 0x20 reserved
-      CTRL_REG5_FIFO_EN                       = 0x40,
-      CTRL_REG5_BOOT                          = 0x80
-    } CTRL_REG5_BITS_T;
-
-    /**
-     * STATUS_REG bits
-     */
-    typedef enum {
-      STATUS_REG_XDA                          = 0x01, // axis data avail
-      STATUS_REG_YDA                          = 0x02,
-      STATUS_REG_ZDA                          = 0x04,
-      STATUS_REG_ZYXDA                        = 0x08,
-
-      STATUS_REG_XOR                          = 0x10, // axis data overrun
-      STATUS_REG_YOR                          = 0x20,
-      STATUS_REG_ZOR                          = 0x40,
-      STATUS_REG_ZYXOR                        = 0x80
-    } STATUS_REG_BITS_T;
-
-    /**
-     * FIFO_CTRL_REG bits
-     */
-    typedef enum {
-      FIFO_CTRL_REG_WTM0                      = 0x01, // FIFO watermark
-      FIFO_CTRL_REG_WTM1                      = 0x02,
-      FIFO_CTRL_REG_WTM2                      = 0x04,
-      FIFO_CTRL_REG_WTM3                      = 0x08,
-      FIFO_CTRL_REG_WTM4                      = 0x10,
-      _FIFO_CTRL_REG_WTM_MASK                 = 31,
-      _FIFO_CTRL_REG_WTM_SHIFT                = 0,
-
-      FIFO_CTRL_REG_FM0                       = 0x20, // FIFO mode
-      FIFO_CTRL_REG_FM1                       = 0x40,
-      FIFO_CTRL_REG_FM2                       = 0x80,
-      _FIFO_CTRL_REG_FM_MASK                  = 7,
-      _FIFO_CTRL_REG_FM_SHIFT                 = 5
-    } FIFO_CTRL_REG_BITS_T;
-
-    /**
-     * FIFO_CTRL_REG_FM (FIFO mode) values
-     */
-    typedef enum {
-      FIFO_MODE_BYPASS                        = 0,
-      FIFO_MODE_FIFO                          = 1,
-      FIFO_MODE_STREAM                        = 2,
-      FIFO_MODE_STREAM_TO_FIFO                = 3,
-      FIFO_MODE_BYPASS_TO_STREAM              = 4
-    } FIFO_MODE_T;
-
-
-    /**
-     * FIFO_SRC_REG bits
-     */
-    typedef enum {
-      FIFO_SRC_REG_FSS0                       = 0x01, // FIFO stored data level
-      FIFO_SRC_REG_FSS1                       = 0x02,
-      FIFO_SRC_REG_FSS2                       = 0x04,
-      FIFO_SRC_REG_FSS3                       = 0x08,
-      FIFO_SRC_REG_FSS4                       = 0x10,
-      _FIFO_SRC_REG_FSS_MASK                  = 31,
-      _FIFO_SRC_REG_FSS_SHIFT                 = 0,
-
-      FIFO_SRC_REG_EMPTY                      = 0x20,
-      FIFO_SRC_REG_OVRN                       = 0x40,
-      FIFO_SRC_REG_WTM                        = 0x80
-    } FIFO_SRC_BITS_T;
-
-    /**
-     * INT1_CFG bits
-     */
-    typedef enum {
-      INT1_CFG_XLIE                           = 0x01, // low intr en
-      INT1_CFG_XHIE                           = 0x02, // high intr en
-
-      INT1_CFG_YLIE                           = 0x04,
-      INT1_CFG_YHIE                           = 0x08,
-
-      INT1_CFG_ZLIE                           = 0x10,
-      INT1_CFG_ZHIE                           = 0x20,
-
-      INT1_CFG_LIR                            = 0x40,
-      INT1_CFG_AND_OR                         = 0x80
-    } INT1_CFG_BITS_T;
-
-    /**
-     * INT1_SRC bits
-     */
-    typedef enum {
-      _INT1_SRC_RESERVED_BITS                 = 0x80,
-
-      INT1_SRC_XL                             = 0x01, // X low intr
-      INT1_SRC_XH                             = 0x02, // X high intr
-
-      INT1_SRC_YL                             = 0x04,
-      INT1_SRC_YH                             = 0x08,
-
-      INT1_SRC_ZL                             = 0x10,
-      INT1_SRC_ZH                             = 0x20,
-
-      INT1_SRC_IA                             = 0x40 // intr active
-
-      // 0x80 reserved
-    } INT1_SRC_BITS_T;
-
-    /**
-     * INT1_DURATION bits
-     */
-    typedef enum {
-      INT1_DURATION_D0                        = 0x01,
-      INT1_DURATION_D1                        = 0x02,
-      INT1_DURATION_D2                        = 0x04,
-      INT1_DURATION_D3                        = 0x08,
-      INT1_DURATION_D4                        = 0x10,
-      INT1_DURATION_D5                        = 0x20,
-      INT1_DURATION_D6                        = 0x40,
-
-      INT1_DURATION_WAIT                      = 0x80
-    } INT1_DURATION_BITS_T;
-
-
-    /**
-     * L3GD20 Tri-axis Digital Gyroscope Contructor for IIO operation
-     *
-     * @param device iio device number
-     */
-    L3GD20(int device);
-
-    /**
-     * L3GD20 Tri-axis Digital Gyroscope Contructor for I2C operation
-     *
-     * @param bus i2c bus
-     * @param addr I2C address
-     */
-    L3GD20(int bus, int addr);
-
-    /**
-     * L3GD20 destructor
-     */
-    ~L3GD20();
-
-    /**
-     * Return the chip ID.  I2C only.
-     *
-     * @return The chip ID (L3GD20_DEFAULT_CHIP_ID).
-     */
-    uint8_t getChipID();
-
-    /**
-     * Return gyroscope data in radians per second.  update() must
-     * have been called prior to calling this method.  I2C only.
-     *
-     * @param x Pointer to a floating point value that will have the
-     * current x component placed into it.
-     * @param y Pointer to a floating point value that will have the
-     * current y component placed into it.
-     * @param z Pointer to a floating point value that will have the
-     * current z component placed into it.
-     */
-    void getGyroscope(float *x, float *y, float *z);
-
-    /**
-     * Set the power mode of the device.  I2C only.
-     *
-     * @param mode One of the POWER_MODES_T values.
-     */
-    void setPowerMode(POWER_MODES_T mode);
-
-    /**
-     * Set the gyroscope detection scaling range.  This device
-     * supports 250, 500 and 2000 degree/s ranges.  I2C only.
-     *
-     * @param range One of the FS_T values.
-     */
-    void setRange(FS_T range);
-
-    /**
-     * Update the internal stored values from sensor data.  This
-     * method must be called before querying any data
-     * (getTemperature() and getGyroscope()).  I2C only.
-     */
-    void update();
-
-    /**
-     * Return the current measured temperature.  Note, this is not
-     * ambient temperature.  update() must have been called prior to
-     * calling this method.  I2C only.
-     *
-     * @param fahrenheit true to return data in Fahrenheit, false for
-     * Celicus.  Celsius is the default.
-     * @return The temperature in degrees Celsius or Fahrenheit.
-     */
-   float getTemperature(bool fahrenheit=false);
-
-    /**
-     * Set the output data rate and cut off frequency of the device.
-     * I2C only.
-     *
-     * @param odr One of the ODR_CUTOFF_T values.
-     */
-    void setODR(ODR_CUTOFF_T odr);
-
-    /**
-     * Enable or disable Block Data Update.  When enabled, this
-     * ensures that LSB's or MSB's of a given axis are not being
-     * updated while the other is being read.  This is enabled by
-     * default.  I2C only.
-     *
-     * @param enable true to enable, false to disable
-     */
-    void enableBDU(bool enable);
-
-    /**
-     * Return the bitfields of the Status register.  This register
-     * provides information on the status of data gathering.  I2C
-     * only.
-     *
-     * @return The contents of the REG_STATUS_REG register.
-     */
-    uint8_t getStatusBits();
-
-    /**
-     * Installs an interrupt service routine (ISR) to be called when
-     * an interrupt occurs.  IIO only.
-     *
-     * @param isr Pointer to a function to be called on interrupt
-     * @param arg Pointer to an object to be supplied as an
-     * argument to the ISR.
-     */
-    void installISR(void (*isr)(char*, void*), void* arg);
-
-    /**
-     * Extract the channel value based on channel type. IIO only.
-     *
-     * @param input Channel data
-     * @param chan MRAA iio-layer channel info
-     */
-    int64_t getChannelValue(unsigned char* input, mraa_iio_channel* chan);
-
-    /**
-     * Enable trigger buffer.  IIO only.
-     *
-     * @param length buffer length in integer
-     */
-    bool enableBuffer(int length);
-
-    /**
-     * Disable trigger buffer.   IIO only.
-     */
-    bool disableBuffer();
-
-    /**
-     * Set scale.  IIO only.  For I2C operation, use setRange() with
-     * the appropriate FS_T value.
-     *
-     * @param scale in float
-     * Available scales are 0.000153(250dps), 0.000305(500dps), and
-     * 0.001222(2000dps) Default scale is 0.000153
-     */
-    bool setScale(const float scale);
-
-    /**
-     * Set sampling frequency.  IIO only.  For I2C operation, use the
-     * setODR() method with the appropriate ODR_CUTOFF_T value.
-     *
-     * @param sampling_frequency sampling frequency in float
-     * Available sampling frequency are 95, 190, 380, and 760
-     * Default sampling frequency is 95
-     */
-    bool setSamplingFrequency(const float sampling_frequency);
-
-    /**
-     * Enable 3 axis scan element.  IIO only.
-     */
-    bool enable3AxisChannel();
-
-    /**
-     * Process enabled channel buffer and return x, y, z axis. IIO only.
-     * @param data Enabled channel data, 6 bytes, each axis 2 bytes
-     * @param x X-Axis
-     * @param y Y-Axis
-     * @param z Z-Axis
-     */
-    bool extract3Axis(char* data, float* x, float* y, float* z);
-
-    /**
-     * Reset calibration data and start collect calibration data again
-     */
-    void initCalibrate();
-
-    /**
-     * Get calibrated status, return true if calibrate successfully
-     */
-    bool getCalibratedStatus();
-
-    /**
-     * Get calibrated data
-     */
-    void getCalibratedData(float* bias_x, float* bias_y, float* bias_z);
-
-    /**
-     * Load calibrated data
-     */
-    void loadCalibratedData(float bias_x, float bias_y, float bias_z);
-
-    /**
-     * Read a register. I2C mode only.
-     *
-     * @param reg The register to read.
-     * @return The value of the register.
-     */
-    uint8_t readReg(uint8_t reg);
-
-    /**
-     * Read contiguous registers into a buffer. I2C mode only.
-     *
-     * @param buffer The buffer to store the results.
-     * @param len The number of registers to read.
-     * @return The number of bytes read.
-     */
-    int readRegs(uint8_t reg, uint8_t *buffer, int len);
-
-    /**
-     * Write to a register.  I2C mode only.
-     *
-     * @param reg The register to write to.
-     * @param val The value to write.
-     */
-    void writeReg(uint8_t reg, uint8_t val);
-
-    /**
-     * Calibrate gyro
-     * @param x X-Axis
-     * @param y Y-Axis
-     * @param z Z-Axis
-     */
-    bool gyroCollect(float x, float y, float z);
-
-    /**
-     * Denoise gyro
-     * @param x X-Axis
-     * @param y Y-Axis
-     * @param z Z-Axis
-     */
-    void gyroDenoiseMedian(float* x, float* y, float* z);
-
-    /**
-     * median algorithm
-     * @param queue
-     * @param size
-     */
-    float median(float* queue, unsigned int size);
-
-    /**
-     * partition algorithm
-     * @param list
-     * @param left
-     * @param right
-     * @param pivot_index
-     */
-    unsigned int
-    partition(float* list, unsigned int left, unsigned int right, unsigned int pivot_index);
-
-    /**
-     * Clamp Gyro Readings to Zero
-     * @param x X-Axis
-     * @param y Y-Axis
-     * @param z Z-Axis
-     */
-    void clampGyroReadingsToZero(float* x, float* y, float* z);
-
-  protected:
-    mraa::I2c *m_i2c;
-    float m_gyrScale;
-    float m_gyrX;
-    float m_gyrY;
-    float m_gyrZ;
-    float m_temperature;
-
-  private:
-    mraa_iio_context m_iio;
-
-    int m_iio_device_num;
-    bool m_mount_matrix_exist; // is mount matrix exist
-    float m_mount_matrix[9];   // mount matrix
-    float m_scale;             // gyroscope data scale
-    int m_event_count;         // sample data arrive
-    bool m_calibrated;         // calibrate state
-    gyro_cal_t m_cal_data;     // calibrate data
-    filter_median_t m_filter;  // filter data
-};
-}
diff --git a/src/l3gd20/l3gd20.json b/src/l3gd20/l3gd20.json
deleted file mode 100644
index baa1115..0000000
--- a/src/l3gd20/l3gd20.json
+++ /dev/null
@@ -1,39 +0,0 @@
-{
-    "Library": "l3gd20",
-    "Description": "L3GD20 Tri-axis Digital Gyroscope API",
-    "Sensor Class":
-    {
-        "L3GD20":
-        {
-            "Name": "L3GD20 Tri-axis Digital Gyroscope",
-            "Description": "The L3GD20 The L3GD20 is a low-power three-axis angular rate sensor. This driver supports IIO and I2C modes. Some methods will only work in one mode or the other. See the documentation on the methods to determine whether a given method is operation in a given mode. Both the I2C and IIO mechanisms make use of the calibration and denoise algorithms. For I2C mode, not all capabilities of the device are supported, but a complete register map and low level read/write methods are provided to add any missing functionality.",
-            "Aliases": ["l3gd20"],
-            "Categories": ["gyroscope"],
-            "Connections": ["iio", "i2c"],
-            "Project Type": ["IMU", "prototyping"],
-            "Manufacturers": ["stmicro"],
-            "Kits": [],
-            "Examples":
-            {
-                "Java": [],
-                "Python": [],
-                "Node.js": [],
-                "C++": ["l3gd20.cxx", "l3gd20-i2c.cxx"],
-                "C": []
-            },
-            "Specifications":
-            {
-                "Operating Voltage": {"unit": "V", "low": 2.4, "high": 3.6},
-                "Operating Current": {"unit": "mA", "typ": 6.1},
-                "Operating Temperature": {"unit": "degC", "low": -40, "high": 85}
-
-            },
-            "Urls" :
-            {
-                "Product Pages": ["http://www.st.com/en/mems-and-sensors/l3gd20.html"],
-                "Datasheets": ["http://www.st.com/resource/en/datasheet/l3gd20.pdf"],
-                "Schematics": []
-            }
-        }
-    }
-}
diff --git a/src/lcd/CMakeLists.txt b/src/lcd/CMakeLists.txt
deleted file mode 100644
index efe4cdb..0000000
--- a/src/lcd/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "lcd")
-set (libdescription "OLED Display Library")
-set (module_src lcd.cxx ssd1308.cxx eboled.cxx ssd1327.cxx ssd1306.cxx)
-set (module_hpp lcd.hpp ssd1308.hpp eboled.hpp ssd1327.hpp ssd.hpp ssd1306.hpp)
-upm_module_init(mraa)
diff --git a/src/lcd/eboled.cxx b/src/lcd/eboled.cxx
deleted file mode 100644
index cf56147..0000000
--- a/src/lcd/eboled.cxx
+++ /dev/null
@@ -1,567 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Author: Tyler Gibson <tgibson@microsoft.com>
- * Copyright (c) 2015 Microsoft Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#include <unistd.h>
-#include <iostream>
-
-#include "eboled.hpp"
-
-using namespace upm;
-using namespace std;
-
-static uint16_t screenBuffer[BUFFER_SIZE];
-
-EBOLED::EBOLED(int spi, int CD, int reset) :
-  m_spi(spi), m_gpioCD(CD), m_gpioRST(reset)
-{
-  m_name = "EBOLED";
-  m_textColor = COLOR_WHITE;
-  m_textWrap = 0;
-  m_textSize = 1;
-  m_cursorX = 0;
-  m_cursorY = 0;
-
-  m_gpioCD.dir(mraa::DIR_OUT);
-  m_gpioRST.dir(mraa::DIR_OUT);
-
-  //1000000 is standard.
-  m_spi.frequency(10000000);
-
-  // reset the device
-  m_gpioRST.write(1);
-  usleep(5000);
-  m_gpioRST.write(0);
-  usleep(10000);
-  m_gpioRST.write(1);
-
-  command(CMD_DISPLAYOFF);
-
-  command(CMD_SETDISPLAYCLOCKDIV);
-  command(0x80);
-
-  command(CMD_SETMULTIPLEX);
-  command(0x2f);
-
-  command(CMD_SETDISPLAYOFFSET);
-  command(0x0);                 // no offset
-
-  command(CMD_SETSTARTLINE | 0x0); // line #0
-
-  command(CMD_CHARGEPUMP);      // enable charge pump
-  command(0x14);
-
-  command(CMD_NORMALDISPLAY);
-  command(CMD_DISPLAYALLONRESUME);
-
-  command(CMD_SEGREMAP | 0x1);  // reverse mapping (SEG0==COL127)
-  command(CMD_COMSCANDEC);
-
-  command(CMD_SETCOMPINS);      // custom COM PIN mapping
-  command(0x12);
-
-  command(CMD_SETCONTRAST);
-  command(0x8f);
-
-  command(CMD_SETPRECHARGE);
-  command(0xf1);
-
-  command(CMD_SETVCOMDESELECT);
-  command(0x40);
-
-  command(CMD_DISPLAYON);
-
-  usleep(4500);
-
-  setAddressingMode(HORIZONTAL);
-
-  //Set Page Address range, required for horizontal addressing mode.
-  command(CMD_SETPAGEADDRESS); // triple-byte cmd
-  command(0x00); //Initial page address
-  command(0x05); //Final page address
-
-  //Set Column Address range, required for horizontal addressing mode.
-  command(CMD_SETCOLUMNADDRESS); // triple-byte cmd
-  command(0x20); // this display has a horizontal offset of 20 columns
-  command(0x5f); // 64 columns wide - 0 based 63 offset
-}
-
-EBOLED::~EBOLED()
-{
-  clear();
-}
-
-mraa::Result EBOLED::refresh()
-{
-  mraa::Result error = mraa::SUCCESS;;
-
-  m_gpioCD.write(1);            // data mode
-  for(int i=0; i<BUFFER_SIZE; i++)
-  {
-    error = data(screenBuffer[i]);
-    if(error != mraa::SUCCESS)
-      return error;
-  }
-
-  return error;
-}
-
-mraa::Result EBOLED::write (std::string msg)
-{
-  int len = msg.length();
-  uint8_t temp_cursorX = m_cursorX;
-  for (int idx = 0; idx < len; idx++)
-  {
-    if (msg[idx] == '\n')
-    {
-      m_cursorY += m_textSize * 9;
-      temp_cursorX = m_cursorX;
-    }
-    else if (msg[idx] == '\r')
-    {
-      // skip em
-    }
-    else
-    {
-      drawChar(temp_cursorX, m_cursorY, msg[idx], m_textColor, m_textSize);
-      temp_cursorX += m_textSize * 6;
-
-      //textColor used to avoid wrapping if COLOR_BLACK is set.
-      if (m_textWrap && (m_textColor > OLED_WIDTH - temp_cursorX - 6))
-      {
-        m_cursorY += m_textSize * 9;
-        temp_cursorX = m_cursorX;
-      }
-    }
-  }
-  return mraa::SUCCESS;;
-}
-
-mraa::Result EBOLED::setCursor (int row, int column) {
-  m_cursorX = column;
-  m_cursorY = row;
-  return mraa::SUCCESS;;
-}
-
-void EBOLED::setTextColor (uint8_t textColor) {
-  m_textColor   = textColor;
-}
-
-void EBOLED::setTextSize (uint8_t size) {
-  m_textSize = (size > 0) ? size : 1;
-}
-
-void EBOLED::setTextWrap (uint8_t wrap) {
-  m_textWrap = wrap;
-}
-
-void EBOLED::drawChar (uint8_t x, uint8_t y, uint8_t data, uint8_t color, uint8_t size) {
-  if( (x >= OLED_WIDTH)            || // Clip right
-      (y >= OLED_HEIGHT)           || // Clip bottom
-      ((x + 6 * size - 1) < 0)  || // Clip left
-      ((y + 8 * size - 1) < 0))    // Clip top
-  return;
-
-  if (data < 0x20 || data > 0x7F) {
-    data = 0x20; // space
-  }
-
-  for (int8_t i=0; i<6; i++ ) {
-    uint8_t line;
-    if (i == 6)
-      line = 0x0;
-    else
-    {
-      //32 offset to align standard ASCII range to index
-      line = BasicFont[data - 32][i+1];
-      for (int8_t j = 0; j<8; j++)
-      {
-        if (line & 0x1)
-        {
-          if (size == 1) // default size
-            drawPixel(x+i, y+j, color);
-          else
-            drawRectangleFilled(x+(i*size), y+(j*size), size, size, color); // big size
-        }
-        line >>= 1;
-      }
-    }
-  }
-}
-
-mraa::Result EBOLED::clear()
-{
-  mraa::Result error = mraa::SUCCESS;;
-
-  m_gpioCD.write(1);            // data mode
-  for(int i=0; i<BUFFER_SIZE; i++)
-  {
-    error = data(0x0000);
-    if(error != mraa::SUCCESS)
-      return error;
-  }
-
-  return mraa::SUCCESS;;
-}
-
-mraa::Result EBOLED::home()
-{
-  return setCursor(0, 0);
-}
-
-void EBOLED::drawPixel(int8_t x, int8_t y, uint8_t color)
-{
-  if(x<0 || x>=OLED_WIDTH || y<0 || y>=OLED_HEIGHT)
-    return;
-
-  /* Screenbuffer is uint16 array, but pages are 8bit high so each buffer
-   * index is two columns.  This means the index is based on x/2 and
-   * OLED_WIDTH/2 = VERT_COLUMNS.
-   *
-   * Then to set the appropriate bit, we need to shift based on the y
-   * offset in relation to the page and then adjust for high/low based
-   * on the x position.
-  */
-
-  switch(color)
-  {
-    case COLOR_XOR:
-      screenBuffer[(x/2) + ((y/8) * VERT_COLUMNS)] ^= (1<<(y%8+(x%2 * 8)));
-      return;
-    case COLOR_WHITE:
-      screenBuffer[(x/2) + ((y/8) * VERT_COLUMNS)] |= (1<<(y%8+(x%2 * 8)));
-      return;
-    case COLOR_BLACK:
-      screenBuffer[(x/2) + ((y/8) * VERT_COLUMNS)] &= ~(1<<(y%8+(x%2 * 8)));
-      return;
-  }
-}
-
-void EBOLED::drawLine(int8_t x0, int8_t y0, int8_t x1, int8_t y1, uint8_t color)
-{
-  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
-
-  if (steep) {
-    swap(x0, y0);
-    swap(x1, y1);
-  }
-
-  if (x0 > x1) {
-    swap(x0, x1);
-    swap(y0, y1);
-  }
-
-  int16_t dx, dy;
-  dx = x1 - x0;
-  dy = abs (y1 - y0);
-
-  int16_t err = dx / 2;
-  int16_t ystep;
-
-  if (y0 < y1) {
-    ystep = 1;
-  } else {
-    ystep = -1;
-  }
-
-  for (; x0 <= x1; x0++) {
-    if (steep) {
-      drawPixel(y0, x0, color);
-    } else {
-      drawPixel(x0, y0, color);
-    }
-    err -= dy;
-    if (err < 0) {
-      y0 += ystep;
-      err += dx;
-    }
-  }
-}
-
-void EBOLED::drawLineHorizontal(int8_t x, int8_t y, uint8_t width, uint8_t color)
-{
-  drawLine(x, y, x+width-1, y, color);
-}
-
-void EBOLED::drawLineVertical(int8_t x, int8_t y, uint8_t height, uint8_t color)
-{
-  drawLine(x, y, x, y+height-1, color);
-}
-
-void EBOLED::drawRectangle(int8_t x, int8_t y, uint8_t width, uint8_t height, uint8_t color)
-{
-  drawLineHorizontal(x, y, width, color);
-  drawLineHorizontal(x, y+height-1, color);
-
-  uint8_t innerHeight = height - 2;
-  if(innerHeight > 0)
-  {
-    drawLineVertical(x, y+1, innerHeight, color);
-    drawLineVertical(x+width-1, y+1, innerHeight, color);
-  }
-}
-
-void EBOLED::drawRoundedRectangle(int8_t x, int8_t y, int8_t width, int8_t height, int16_t radius, uint8_t color) {
-  // smarter version
-  drawLineHorizontal(x+radius  , y         , width-2*radius,  color); // Top
-  drawLineHorizontal(x+radius  , y+height-1, width-2*radius,  color); // Bottom
-  drawLineVertical(  x         , y+radius  , height-2*radius, color); // Left
-  drawLineVertical(  x+width-1 , y+radius  , height-2*radius, color); // Right
-  // draw four corners
-  drawRoundCorners(x+radius        , y+radius         , radius, 1, color);
-  drawRoundCorners(x+width-radius-1, y+radius         , radius, 2, color);
-  drawRoundCorners(x+width-radius-1, y+height-radius-1, radius, 4, color);
-  drawRoundCorners(x+radius        , y+height-radius-1, radius, 8, color);
-}
-
-void EBOLED::drawRectangleFilled(int8_t x, int8_t y, uint8_t width, uint8_t height, uint8_t color)
-{
-  for (uint8_t i=x; i<x+width; i++) {
-    drawLineVertical(i, y, height, color);
-  }
-}
-
-void EBOLED::drawTriangle(int8_t x0, int8_t y0, int8_t x1, int8_t y1, int8_t x2, int8_t y2, uint8_t color)
-{
-  drawLine(x0, y0, x1, y1, color);
-  drawLine(x1, y1, x2, y2, color);
-  drawLine(x2, y2, x0, y0, color);
-}
-
-void EBOLED::drawTriangleFilled ( int8_t x0, int8_t y0, int8_t x1, int8_t y1, int8_t x2, int8_t y2, uint8_t color) {
-
-  int16_t a, b, y, last;
-
-  // Sort coordinates by Y order (y2 >= y1 >= y0)
-  if (y0 > y1) {
-    swap(y0, y1); swap(x0, x1);
-  }
-  if (y1 > y2) {
-    swap(y2, y1); swap(x2, x1);
-  }
-  if (y0 > y1) {
-    swap(y0, y1); swap(x0, x1);
-  }
-
-  if(y0 == y2) { // Handle awkward all-on-same-line case as its own thing
-    a = b = x0;
-    if(x1 < a)      a = x1;
-    else if(x1 > b) b = x1;
-    if(x2 < a)      a = x2;
-    else if(x2 > b) b = x2;
-    drawLineHorizontal(a, y0, b-a+1, color);
-    return;
-  }
-
-  int16_t
-    dx01 = x1 - x0,
-    dy01 = y1 - y0,
-    dx02 = x2 - x0,
-    dy02 = y2 - y0,
-    dx12 = x2 - x1,
-    dy12 = y2 - y1;
-  int32_t
-    sa   = 0,
-    sb   = 0;
-
-  // For upper part of triangle, find scanline crossings for segments
-  // 0-1 and 0-2.  If y1=y2 (flat-bottomed triangle), the scanline y1
-  // is included here (and second loop will be skipped, avoiding a /0
-  // error there), otherwise scanline y1 is skipped here and handled
-  // in the second loop...which also avoids a /0 error here if y0=y1
-  // (flat-topped triangle).
-  if(y1 == y2) last = y1;   // Include y1 scanline
-  else         last = y1-1; // Skip it
-
-  for(y=y0; y<=last; y++) {
-    a   = x0 + sa / dy01;
-    b   = x0 + sb / dy02;
-    sa += dx01;
-    sb += dx02;
-    /* longhand:
-    a = x0 + (x1 - x0) * (y - y0) / (y1 - y0);
-    b = x0 + (x2 - x0) * (y - y0) / (y2 - y0);
-    */
-    if(a > b) swap(a,b);
-    drawLineHorizontal(a, y, b-a+1, color);
-  }
-
-  // For lower part of triangle, find scanline crossings for segments
-  // 0-2 and 1-2.  This loop is skipped if y1=y2.
-  sa = dx12 * (y - y1);
-  sb = dx02 * (y - y0);
-  for(; y<=y2; y++) {
-    a   = x1 + sa / dy12;
-    b   = x0 + sb / dy02;
-    sa += dx12;
-    sb += dx02;
-    /* longhand:
-    a = x1 + (x2 - x1) * (y - y1) / (y2 - y1);
-    b = x0 + (x2 - x0) * (y - y0) / (y2 - y0);
-    */
-    if(a > b) swap(a,b);
-    drawLineHorizontal(a, y, b-a+1, color);
-  }
-}
-
-void EBOLED::drawCircle(int16_t x0, int16_t y0, int16_t radius, uint8_t color)
-{
-  int16_t f = 1 - radius;
-  int16_t ddF_x = 1;
-  int16_t ddF_y = -2 * radius;
-  int16_t x = 0;
-  int16_t y = radius;
-
-  drawPixel(x0  , y0+radius, color);
-  drawPixel(x0  , y0-radius, color);
-  drawPixel(x0+radius, y0  , color);
-  drawPixel(x0-radius, y0  , color);
-
-  while (x<y)
-  {
-    if (f >= 0)
-    {
-      y--;
-      ddF_y += 2;
-      f += ddF_y;
-    }
-    x++;
-
-    ddF_x += 2;
-    f += ddF_x;
-
-    drawPixel(x0 + x, y0 + y, color);
-    drawPixel(x0 - x, y0 + y, color);
-    drawPixel(x0 + x, y0 - y, color);
-    drawPixel(x0 - x, y0 - y, color);
-    drawPixel(x0 + y, y0 + x, color);
-    drawPixel(x0 - y, y0 + x, color);
-    drawPixel(x0 + y, y0 - x, color);
-    drawPixel(x0 - y, y0 - x, color);
-  }
-}
-
-void EBOLED::drawRoundCorners( int8_t x0, int8_t y0, int16_t radius, uint8_t cornername, uint8_t color) {
-  int16_t f     = 1 - radius;
-  int16_t ddF_x = 1;
-  int16_t ddF_y = -2 * radius;
-  int16_t x     = 0;
-  int16_t y     = radius;
-
-  while (x<y) {
-    if (f >= 0) {
-      y--;
-      ddF_y += 2;
-      f     += ddF_y;
-    }
-    x++;
-    ddF_x += 2;
-    f     += ddF_x;
-    if (cornername & 0x4) {
-      drawPixel(x0 + x, y0 + y, color);
-      drawPixel(x0 + y, y0 + x, color);
-    }
-    if (cornername & 0x2) {
-      drawPixel(x0 + x, y0 - y, color);
-      drawPixel(x0 + y, y0 - x, color);
-    }
-    if (cornername & 0x8) {
-      drawPixel(x0 - y, y0 + x, color);
-      drawPixel(x0 - x, y0 + y, color);
-    }
-    if (cornername & 0x1) {
-      drawPixel(x0 - y, y0 - x, color);
-      drawPixel(x0 - x, y0 - y, color);
-    }
-  }
-}
-
-void EBOLED::drawCircleFilled(int8_t x0, int8_t y0, int16_t radius, uint8_t color) {
-  drawLineVertical(x0, y0-radius, 2*radius+1, color);
-  drawRoundedCornersFilled(x0, y0, radius, 3, 0, color);
-}
-
-void EBOLED::drawRoundedCornersFilled(int8_t x0, int8_t y0, int16_t radius, uint8_t cornername, int16_t delta, uint8_t color) {
-
-  int16_t f     = 1 - radius;
-  int16_t ddF_x = 1;
-  int16_t ddF_y = -2 * radius;
-  int16_t x     = 0;
-  int16_t y     = radius;
-
-  while (x<y) {
-    if (f >= 0) {
-      y--;
-      ddF_y += 2;
-      f     += ddF_y;
-    }
-    x++;
-    ddF_x += 2;
-    f     += ddF_x;
-
-    if (cornername & 0x1) {
-      drawLineVertical(x0+x, y0-y, 2*y+1+delta, color);
-      drawLineVertical(x0+y, y0-x, 2*x+1+delta, color);
-    }
-    if (cornername & 0x2) {
-      drawLineVertical(x0-x, y0-y, 2*y+1+delta, color);
-      drawLineVertical(x0-y, y0-x, 2*x+1+delta, color);
-    }
-  }
-}
-
-void EBOLED::fillScreen(uint8_t color)
-{
-  drawRectangleFilled(0, 0, OLED_WIDTH-1, OLED_HEIGHT-1, color);
-}
-
-mraa::Result EBOLED::setAddressingMode(displayAddressingMode mode)
-{
-  mraa::Result rv;
-
-  rv = command(CMD_MEMORYADDRMODE);
-  rv = command(mode);
-
-  return rv;
-}
-
-mraa::Result EBOLED::command(uint8_t cmd)
-{
-  m_gpioCD.write(0);            // command mode
-  m_spi.writeByte(cmd);
-  return mraa::SUCCESS;
-}
-
-mraa::Result EBOLED::data(uint16_t data)
-{
-  m_spi.writeWord(data);
-  return mraa::SUCCESS;
-}
-
-void EBOLED::clearScreenBuffer()
-{
-  for(int i=0; i<BUFFER_SIZE;i++)
-    screenBuffer[i] = 0x0000;
-}
diff --git a/src/lcd/eboled.hpp b/src/lcd/eboled.hpp
deleted file mode 100644
index 0dab4b8..0000000
--- a/src/lcd/eboled.hpp
+++ /dev/null
@@ -1,375 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Author: Tyler Gibson <tgibson@microsoft.com>
- * Copyright (c) 2015 Microsoft Corporation.
- *
- * Credits to Adafruit.
- * Based on Adafruit ST7735 library, see original license in license.txt file.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/spi.hpp>
-
-#include <mraa/gpio.hpp>
-
-#include "lcd.hpp"
-#include "ssd.hpp"
-
-#define EBOLED_DEFAULT_SPI_BUS 0
-#define EBOLED_DEFAULT_CD      36
-#define EBOLED_DEFAULT_RESET   48
-
-#define swap(a, b) { uint8_t t = a; a = b; b = t; }
-
-namespace upm
-{
-  const uint8_t COLOR_WHITE     = 0x01;
-  const uint8_t COLOR_BLACK     = 0x00;
-  const uint8_t COLOR_XOR       = 0x02;
-  const uint8_t OLED_WIDTH      = 0x40; // 64 pixels
-  const uint8_t VERT_COLUMNS    = 0x20; // half width for hi/lo 16bit writes.
-  const uint8_t OLED_HEIGHT     = 0x30; // 48 pixels
-  const int     BUFFER_SIZE     = 192;
-
-  /**
-   * @library lcd
-   * @sensor eboled
-   * @comname SparkFun Block for Intel Edison - OLED
-   * @altname ssd1306
-   * @type display
-   * @man sparkfun
-   * @web https://www.sparkfun.com/products/13035
-   * @con spi
-   *
-   * @brief API for EBOLED spi controlled OLED display
-   *
-   * The EBOLED is an ssd1306 with some modifications to work as an
-   * Edison Block.  It is a 64x48 pixel OLED display that connects
-   * directly to an edison via it's 80-pin connector.  Edison Blocks
-   * are stackable modules created by Sparkfun.
-   *
-   * This block has some buttons on it that can be accessed using
-   * standard GPIO -- this driver only concerns itself with the
-   * display.
-   *
-   * @image html eboled.jpg
-   * <br><em>OLED Sensor image provided by SparkFun* under
-   * <a href=https://creativecommons.org/licenses/by/2.0/>
-   * CC BY 2.0</a>.</em>
-   *
-   * @snippet lcd-eboled.cxx Interesting
-   */
-  class EBOLED : public LCD
-  {
-    // SSD commands
-    typedef enum {
-      CMD_SETLOWCOLUMN          = 0x00,
-      CMD_EXTERNALVCC           = 0x01,
-      CMD_SWITCHCAPVCC          = 0x02,
-      CMD_SETHIGHCOLUMN         = 0x10,
-      CMD_MEMORYADDRMODE        = 0x20,
-      CMD_SETCOLUMNADDRESS      = 0x21,
-      CMD_SETPAGEADDRESS        = 0x22,
-      CMD_SETSTARTLINE          = 0x40, // 0x40 - 0x7f
-      CMD_SETCONTRAST           = 0x81,
-      CMD_CHARGEPUMP            = 0x8d,
-      CMD_SEGREMAP              = 0xa0,
-      CMD_DISPLAYALLONRESUME    = 0xa4,
-      CMD_DISPLAYALLON          = 0xa5,
-      CMD_NORMALDISPLAY         = 0xa6,
-      CMD_INVERTDISPLAY         = 0xa7,
-      CMD_SETMULTIPLEX          = 0xa8,
-      CMD_DISPLAYOFF            = 0xae,
-      CMD_DISPLAYON             = 0xaf,
-      CMD_SETPAGESTARTADDR      = 0xb0, // 0xb0-0xb7
-      CMD_COMSCANINC            = 0xc0,
-      CMD_COMSCANDEC            = 0xc8,
-      CMD_SETDISPLAYOFFSET      = 0xd3,
-      CMD_SETDISPLAYCLOCKDIV    = 0xd5,
-      CMD_SETPRECHARGE          = 0xd9,
-      CMD_SETCOMPINS            = 0xda,
-      CMD_SETVCOMDESELECT       = 0xdb
-    } SSD_CMDS_T;
-
-  public:
-    /**
-     * EBOLED Constructor.  Note that you will not have any choice as
-     * to the pins used, so they are all set to default values.
-     *
-     * @param spi spi bus to use
-     * @param CD Command/Data select pin
-     * @param reset reset pin
-     */
-    EBOLED(int spi=EBOLED_DEFAULT_SPI_BUS, int CD=EBOLED_DEFAULT_CD,
-           int reset=EBOLED_DEFAULT_RESET);
-
-    /**
-     * EBOLED Destructor
-     */
-    ~EBOLED();
-
-    /**
-     * Draw the buffer to screen.
-     *
-     * @return result of operation
-     */
-    mraa::Result refresh();
-
-    /**
-     * Write a string to LCD
-     *
-     * @param msg the std::string to write to display, note only ascii
-     * chars are supported
-     * @return result of operation
-     */
-    mraa::Result write(std::string msg);
-
-    /**
-     * Set cursor to a coordinate
-     *
-     * @param row Axis on the vertical scale. This device supports 6 rows.
-     * @param column Axis on the horizontal scale This device supports 64 columns
-     *
-     * @return result of operation
-     */
-    mraa::Result setCursor (int row, int column);
-
-    /**
-      * Sets a text color for a message
-      *
-      * @param textColor Font color: COLOR_WHITE, COLOR_BLACK or COLOR_XOR
-      */
-    void setTextColor (uint8_t textColor);
-
-    /**
-      * Sets the size of the font
-      *
-      * @param size Font size
-      */
-    void setTextSize (uint8_t size);
-
-    /**
-      * Wraps a printed message
-      *
-      * @param wrap True (1) or false (0)
-      */
-    void setTextWrap (uint8_t wrap);
-
-    /**
-      * Write a single character to the screen.
-      *
-      * @param x Axis on the horizontal scale
-      * @param y Axis on the vertical scale
-      * @param data Character to write
-      * @param color Character color
-      * @param size Size of the font
-      */
-    void drawChar (uint8_t x, uint8_t y, uint8_t data, uint8_t color, uint8_t size);
-
-    /**
-     * Clear display
-     *
-     * @return result of operation
-     */
-    mraa::Result clear();
-
-    void clearScreenBuffer();
-
-    /**
-     * Return to coordinate 0,0
-     *
-     * @return result of operation
-     */
-    mraa::Result home();
-
-    /**
-     * Write a single pixel to the screen buffer.
-     * Can do an specific color write or toggle (xor) a pixel.
-     *
-     * @param x the x position of the pixel
-     * @param y the y position of the pixel
-     * @param color pixel is COLOR_WHITE, COLOR_BLACK or COLOR_XOR
-     */
-    void drawPixel (int8_t x, int8_t y, uint8_t color=COLOR_WHITE);
-
-    /**
-     * Draw a line to the screen buffer.
-     *
-     * @param x0 the x position of the beginning of the line
-     * @param y0 the y position of the beginning of the line
-     * @param x1 the x position of the end of the line
-     * @param y1 the y position of the end of the line
-     * @param color line is COLOR_WHITE, COLOR_BLACK or COLOR_XOR
-     */
-    void drawLine (int8_t x0, int8_t y0, int8_t x1, int8_t y1, uint8_t color = COLOR_WHITE);
-
-    /**
-     * Draw a horizontal line to the screen buffer.
-     *
-     * @param x the x position of the beginning of the line
-     * @param y the y position of the beginning of the line
-     * @param width is the horizontal length of the line
-     * @param color line is COLOR_WHITE, COLOR_BLACK or COLOR_XOR
-     */
-    void drawLineHorizontal (int8_t x, int8_t y, uint8_t width, uint8_t color = COLOR_WHITE);
-
-    /**
-     * Draw a vertical line to the screen buffer.
-     *
-     * @param x the x position of the beginning of the line
-     * @param y the y position of the beginning of the line
-     * @param height is the vertical length of the line
-     * @param color line is COLOR_WHITE, COLOR_BLACK or COLOR_XOR
-     */
-    void drawLineVertical (int8_t x, int8_t y, uint8_t height, uint8_t color = COLOR_WHITE);
-
-    /**
-     * Draw a rectangle to the screen buffer.
-     *
-     * @param x the left edge
-     * @param y the top edge
-     * @param width sets the right edge
-     * @param height bottom edge
-     * @param color outline is COLOR_WHITE, COLOR_BLACK or COLOR_XOR
-     */
-    void drawRectangle (int8_t x, int8_t y, uint8_t width, uint8_t height, uint8_t color = COLOR_WHITE);
-
-    /**
-     * Draw a rectangle with rounded corners to the screen buffer.
-     *
-     * @param x the left edge
-     * @param y the top edge
-     * @param width sets the right edge
-     * @param height bottom edge
-     * @param radius of the rounded corners
-     * @param color outline is COLOR_WHITE, COLOR_BLACK or COLOR_XOR
-     */
-    void drawRoundedRectangle(int8_t x, int8_t y, int8_t width, int8_t height, int16_t radius, uint8_t color);
-
-    /**
-     * Draw a filled rectangle to the screen buffer.
-     *
-     * @param x the left edge
-     * @param y the top edge
-     * @param width sets the right edge
-     * @param height bottom edge
-     * @param color fill color is COLOR_WHITE, COLOR_BLACK or COLOR_XOR
-     */
-    void drawRectangleFilled (int8_t x, int8_t y, uint8_t width, uint8_t height, uint8_t color = COLOR_WHITE);
-
-    /**
-     * Draw a triangle to the screen buffer.
-     *
-     * @param x0 the x coordinate of the first corner
-     * @param y0 the y coordinate of the first corner
-     * @param x1 the x coordinate of the second corner
-     * @param y1 the y coordinate of the second corner
-     * @param x2 the x coordinate of the third corner
-     * @param y2 the y coordinate of the third corner
-     * @param color outline is COLOR_WHITE, COLOR_BLACK or COLOR_XOR
-     */
-    void drawTriangle (int8_t x0, int8_t y0, int8_t x1, int8_t y1, int8_t x2, int8_t y2, uint8_t color = COLOR_WHITE);
-
-    /**
-     * Draw a filled triangle to the screen buffer.
-     *
-     * @param x0 the x coordinate of the first corner
-     * @param y0 the y coordinate of the first corner
-     * @param x1 the x coordinate of the second corner
-     * @param y1 the y coordinate of the second corner
-     * @param x2 the x coordinate of the third corner
-     * @param y2 the y coordinate of the third corner
-     * @param color fill color is COLOR_WHITE, COLOR_BLACK or COLOR_XOR
-     */
-    void drawTriangleFilled ( int8_t x0, int8_t y0, int8_t x1, int8_t y1, int8_t x2, int8_t y2, uint8_t color);
-
-    /**
-     * Draw a circle to the screen buffer.
-     *
-     * @param x0 the x coordinate of the circle's center
-     * @param y0 the y coordinate of the circle's center
-     * @param radius the radius of the circle
-     * @param color outline is COLOR_WHITE, COLOR_BLACK or COLOR_XOR
-     */
-    void drawCircle (int16_t x0, int16_t y0, int16_t radius, uint8_t color = COLOR_WHITE);
-
-    /**
-     * Draw a quarter circle arc to the screen buffer.
-     *
-     * @param x0 the x coordinate of the arc's center
-     * @param y0 the y coordinate of the arc's center
-     * @param radius the radius of the arc
-     * @param cornername denotes which of the 4 quarters to draw - 1,2,4,8
-     * @param color outline is COLOR_WHITE, COLOR_BLACK or COLOR_XOR
-     */
-    void drawRoundCorners( int8_t x0, int8_t y0, int16_t radius, uint8_t cornername, uint8_t color);
-
-    /**
-     * Draw a filled circle to the screen buffer.
-     *
-     * @param x0 the x coordinate of the circle's center
-     * @param y0 the y coordinate of the circle's center
-     * @param radius the radius of the circle
-     * @param color outline is COLOR_WHITE, COLOR_BLACK or COLOR_XOR
-     */
-    void drawCircleFilled(int8_t x0, int8_t y0, int16_t radius, uint8_t color);
-
-    /**
-     * Draw a quarter pie to the screen buffer.
-     *
-     * @param x0 the x coordinate of the arc's center
-     * @param y0 the y coordinate of the arc's center
-     * @param radius the radius of the arc
-     * @param cornername denotes which of the 4 quarters to draw - 1,2,4,8
-     * @param color fill color is COLOR_WHITE, COLOR_BLACK or COLOR_XOR
-     */
-    void drawRoundedCornersFilled(int8_t x0, int8_t y0, int16_t radius, uint8_t cornername, int16_t delta, uint8_t color);
-
-    /**
-     * Fill the screen buffer with specified color.
-     *
-     * @param color fill color is COLOR_WHITE, COLOR_BLACK or COLOR_XOR
-     */
-    void fillScreen (uint8_t color=COLOR_WHITE);
-
-
-  protected:
-    mraa::Result command(uint8_t cmd);
-    mraa::Result data(uint16_t data);
-    mraa::Result writeChar(uint8_t value);
-    mraa::Result setAddressingMode(displayAddressingMode mode);
-
-  private:
-    mraa::Spi m_spi;
-    mraa::Gpio m_gpioCD;        // command(0)/data(1)
-    mraa::Gpio m_gpioRST;       // reset pin
-
-    uint8_t m_cursorX;
-    uint8_t m_cursorY;
-    uint8_t m_textSize;
-    uint8_t m_textColor;
-    uint8_t m_textWrap;
-  };
-}
diff --git a/src/lcd/hd44780_bits.hpp b/src/lcd/hd44780_bits.hpp
deleted file mode 100644
index e3f60c4..0000000
--- a/src/lcd/hd44780_bits.hpp
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-// This file contains bit definitions for the HD44780 and compatible
-// LCD controllers.  They are used by most drivers in this (LCD)
-// library, though the SSD controllers only seem to make use of the
-// LCD_DATA and LCD_CMD values.
-//
-// Those values (DATA, CMD) are specific to the implementation of the
-// i2C expander in use, so may not be appropriate for inclusion into
-// this file.  But for now, we will leave them here.
-
-#include <stdint.h>
-
-namespace upm
-{
-// commands
-  const uint8_t LCD_CLEARDISPLAY = 0x01;
-  const uint8_t LCD_RETURNHOME = 0x02;
-  const uint8_t LCD_ENTRYMODESET = 0x04;
-  const uint8_t LCD_DISPLAYCONTROL = 0x08;
-  const uint8_t LCD_CURSORSHIFT = 0x10;
-  const uint8_t LCD_FUNCTIONSET = 0x20;
-
-  const uint8_t LCD_BACKLIGHT = 0x08;
-  const uint8_t LCD_NOBACKLIGHT = 0x00;
-  
-  // flags for display entry mode
-  const uint8_t LCD_ENTRYRIGHT = 0x00;
-  const uint8_t LCD_ENTRYLEFT = 0x02;
-  const uint8_t LCD_ENTRYSHIFTINCREMENT = 0x01;
-  const uint8_t LCD_ENTRYSHIFTDECREMENT = 0x00;
-  
-  // flags for display on/off control
-  const uint8_t LCD_DISPLAYON = 0x04;
-  const uint8_t LCD_DISPLAYOFF = 0x00;
-  const uint8_t LCD_CURSORON = 0x02;
-  const uint8_t LCD_CURSOROFF = 0x00;
-  const uint8_t LCD_BLINKON = 0x01;
-  const uint8_t LCD_BLINKOFF = 0x00;
-  
-  // flags for display/cursor shift
-  const uint8_t LCD_DISPLAYMOVE = 0x08;
-  const uint8_t LCD_MOVERIGHT = 0x04;
-  const uint8_t LCD_MOVELEFT = 0x00;
-  
-  // flags for function set
-  const uint8_t LCD_8BITMODE = 0x10;
-  const uint8_t LCD_4BITMODE = 0x00;
-  const uint8_t LCD_2LINE = 0x08;
-  const uint8_t LCD_1LINE = 0x00;
-  const uint8_t LCD_5x10DOTS = 0x04;
-  const uint8_t LCD_5x8DOTS = 0x00;
-  
-  // flags for CGRAM
-  const uint8_t LCD_SETCGRAMADDR = 0x40;
-  
-  // may be implementation specific
-  const uint8_t LCD_EN = 0x04; // Enable bit
-  const uint8_t LCD_RW = 0x02; // Read/Write bit
-  const uint8_t LCD_RS = 0x01; // Register select bit
-  const uint8_t LCD_DATA = 0x40;
-  const uint8_t LCD_CMD = 0x80;
-}
diff --git a/src/lcd/lcd.cxx b/src/lcd/lcd.cxx
deleted file mode 100644
index 21b3a12..0000000
--- a/src/lcd/lcd.cxx
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <unistd.h>
-
-#include "lcd.hpp"
-
-using namespace upm;
-
-LCD::LCD()
-{
-  m_name = "LCD";
-}
-
-LCD::~LCD()
-{
-}
-
-mraa::Result
-LCD::write(int row, int column, std::string msg)
-{
-    setCursor(row, column);
-    return write(msg);
-}
-
-std::string
-LCD::name()
-{
-    return m_name;
-}
diff --git a/src/lcd/lcd.hpp b/src/lcd/lcd.hpp
deleted file mode 100644
index 6950def..0000000
--- a/src/lcd/lcd.hpp
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa.h>
-#include <mraa/types.hpp>
-
-namespace upm
-{
-/**
- * @brief I2C LCD Displays Library
- * @defgroup lcd libupm-lcd
- * @ingroup dfrobot sainsmart seeed sparkfun adafruit i2c gpio display gsk
- */
-class LCD
-{
-  public:
-    LCD();
-    virtual ~LCD();
-    mraa::Result write(int x, int y, std::string msg);
-
-    virtual mraa::Result write(std::string msg) = 0;
-    virtual mraa::Result setCursor(int row, int column) = 0;
-    virtual mraa::Result clear() = 0;
-    virtual mraa::Result home() = 0;
-
-    std::string name();
-
-  protected:
-    std::string m_name;
-};
-}
diff --git a/src/lcd/lcd.i b/src/lcd/lcd.i
deleted file mode 100644
index bac9e71..0000000
--- a/src/lcd/lcd.i
+++ /dev/null
@@ -1,56 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "arrays_java.i";
-
-%apply signed char[] {uint8_t []};
-%ignore BasicFont;
-
-%typemap(jni) (uint8_t *data, int bytes) "jbyteArray";
-%typemap(jtype) (uint8_t *data, int bytes) "byte[]";
-%typemap(jstype) (uint8_t *data, int bytes) "byte[]";
-
-%typemap(javain) (uint8_t *data, int bytes) "$javainput";
-
-%typemap(in) (uint8_t *data, int bytes) {
-        $1 = (uint8_t *) JCALL2(GetByteArrayElements, jenv, $input, NULL);
-        $2 = JCALL1(GetArrayLength, jenv, $input);
-}
-
-%typemap(freearg) (uint8_t *data, int bytes) {
-        JCALL3(ReleaseByteArrayElements, jenv, $input, (jbyte *)$1, 0);
-}
-
-JAVA_JNI_LOADLIBRARY(javaupm_i2clcd)
-#endif
-/* END Java syntax */
-
-/* BEGIN Javascript syntax  ------------------------------------------------- */
-#ifdef SWIGJAVASCRIPT
-%include "../carrays_uint8_t.i"
-#endif
-/* END Javascript syntax */
-
-/* BEGIN Python syntax  ----------------------------------------------------- */
-#ifdef SWIGPYTHON
-%include "../carrays_uint8_t.i"
-#endif
-/* END Python syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "lcd.hpp"
-#include "eboled.hpp"
-#include "ssd1306.hpp"
-#include "ssd1308.hpp"
-#include "ssd1327.hpp"
-%}
-
-%include "lcd.hpp"
-%include "eboled.hpp"
-%include "ssd1306.hpp"
-%include "ssd1308.hpp"
-%include "ssd1327.hpp"
-%include "ssd.hpp"
-/* END Common SWIG syntax */
diff --git a/src/lcd/lcd_private.hpp b/src/lcd/lcd_private.hpp
deleted file mode 100644
index b09ae5b..0000000
--- a/src/lcd/lcd_private.hpp
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Author: Wouter van Verre <wouter.van.verre@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#define UPM_CHECK_MRAA_SUCCESS(ret, msg)                                         \
-    if ((ret) != mraa::SUCCESS) {                                                 \
-        throw std::runtime_error(std::string(__PRETTY_FUNCTION__) + ": " + msg); \
-    }
-
-#define UPM_GOTO_ON_MRAA_FAIL(ret, target) \
-    if ((ret) != mraa::SUCCESS) {           \
-        goto target;                       \
-    }
diff --git a/src/lcd/license.txt b/src/lcd/license.txt
deleted file mode 100644
index 7492e93..0000000
--- a/src/lcd/license.txt
+++ /dev/null
@@ -1,24 +0,0 @@
-Software License Agreement (BSD License)
-
-Copyright (c) 2012 Adafruit Industries.  All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-- Redistributions of source code must retain the above copyright notice,
-  this list of conditions and the following disclaimer.
-- Redistributions in binary form must reproduce the above copyright notice,
-  this list of conditions and the following disclaimer in the documentation
-  and/or other materials provided with the distribution.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
diff --git a/src/lcd/ssd.hpp b/src/lcd/ssd.hpp
deleted file mode 100644
index 860bb15..0000000
--- a/src/lcd/ssd.hpp
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
- * Author: Brendan Le Foll <brendan.le.foll@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-namespace upm
-{
-const uint8_t DISPLAY_CMD_OFF = 0xAE;
-const uint8_t DISPLAY_CMD_ON = 0xAF;
-
-const uint8_t BASE_LOW_COLUMN_ADDR = 0x00;
-const uint8_t BASE_HIGH_COLUMN_ADDR = 0x10;
-const uint8_t BASE_PAGE_START_ADDR = 0xB0;
-const uint8_t DISPLAY_CMD_MEM_ADDR_MODE = 0x20;
-
-const uint8_t BasicFont[][8] = { { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x00, 0x07, 0x00, 0x07, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x14, 0x7F, 0x14, 0x7F, 0x14, 0x00, 0x00 },
-                                 { 0x00, 0x24, 0x2A, 0x7F, 0x2A, 0x12, 0x00, 0x00 },
-                                 { 0x00, 0x23, 0x13, 0x08, 0x64, 0x62, 0x00, 0x00 },
-                                 { 0x00, 0x36, 0x49, 0x55, 0x22, 0x50, 0x00, 0x00 },
-                                 { 0x00, 0x00, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x1C, 0x22, 0x41, 0x00, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x41, 0x22, 0x1C, 0x00, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x08, 0x2A, 0x1C, 0x2A, 0x08, 0x00, 0x00 },
-                                 { 0x00, 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, 0x00 },
-                                 { 0x00, 0xA0, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00 },
-                                 { 0x00, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x20, 0x10, 0x08, 0x04, 0x02, 0x00, 0x00 },
-                                 { 0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00, 0x00 },
-                                 { 0x00, 0x00, 0x42, 0x7F, 0x40, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x62, 0x51, 0x49, 0x49, 0x46, 0x00, 0x00 },
-                                 { 0x00, 0x22, 0x41, 0x49, 0x49, 0x36, 0x00, 0x00 },
-                                 { 0x00, 0x18, 0x14, 0x12, 0x7F, 0x10, 0x00, 0x00 },
-                                 { 0x00, 0x27, 0x45, 0x45, 0x45, 0x39, 0x00, 0x00 },
-                                 { 0x00, 0x3C, 0x4A, 0x49, 0x49, 0x30, 0x00, 0x00 },
-                                 { 0x00, 0x01, 0x71, 0x09, 0x05, 0x03, 0x00, 0x00 },
-                                 { 0x00, 0x36, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00 },
-                                 { 0x00, 0x06, 0x49, 0x49, 0x29, 0x1E, 0x00, 0x00 },
-                                 { 0x00, 0x00, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x00, 0xAC, 0x6C, 0x00, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x14, 0x14, 0x14, 0x14, 0x14, 0x00, 0x00 },
-                                 { 0x00, 0x41, 0x22, 0x14, 0x08, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x02, 0x01, 0x51, 0x09, 0x06, 0x00, 0x00 },
-                                 { 0x00, 0x32, 0x49, 0x79, 0x41, 0x3E, 0x00, 0x00 },
-                                 { 0x00, 0x7E, 0x09, 0x09, 0x09, 0x7E, 0x00, 0x00 },
-                                 { 0x00, 0x7F, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00 },
-                                 { 0x00, 0x3E, 0x41, 0x41, 0x41, 0x22, 0x00, 0x00 },
-                                 { 0x00, 0x7F, 0x41, 0x41, 0x22, 0x1C, 0x00, 0x00 },
-                                 { 0x00, 0x7F, 0x49, 0x49, 0x49, 0x41, 0x00, 0x00 },
-                                 { 0x00, 0x7F, 0x09, 0x09, 0x09, 0x01, 0x00, 0x00 },
-                                 { 0x00, 0x3E, 0x41, 0x41, 0x51, 0x72, 0x00, 0x00 },
-                                 { 0x00, 0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00, 0x00 },
-                                 { 0x00, 0x41, 0x7F, 0x41, 0x00, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x20, 0x40, 0x41, 0x3F, 0x01, 0x00, 0x00 },
-                                 { 0x00, 0x7F, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00 },
-                                 { 0x00, 0x7F, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00 },
-                                 { 0x00, 0x7F, 0x02, 0x0C, 0x02, 0x7F, 0x00, 0x00 },
-                                 { 0x00, 0x7F, 0x04, 0x08, 0x10, 0x7F, 0x00, 0x00 },
-                                 { 0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00, 0x00 },
-                                 { 0x00, 0x7F, 0x09, 0x09, 0x09, 0x06, 0x00, 0x00 },
-                                 { 0x00, 0x3E, 0x41, 0x51, 0x21, 0x5E, 0x00, 0x00 },
-                                 { 0x00, 0x7F, 0x09, 0x19, 0x29, 0x46, 0x00, 0x00 },
-                                 { 0x00, 0x26, 0x49, 0x49, 0x49, 0x32, 0x00, 0x00 },
-                                 { 0x00, 0x01, 0x01, 0x7F, 0x01, 0x01, 0x00, 0x00 },
-                                 { 0x00, 0x3F, 0x40, 0x40, 0x40, 0x3F, 0x00, 0x00 },
-                                 { 0x00, 0x1F, 0x20, 0x40, 0x20, 0x1F, 0x00, 0x00 },
-                                 { 0x00, 0x3F, 0x40, 0x38, 0x40, 0x3F, 0x00, 0x00 },
-                                 { 0x00, 0x63, 0x14, 0x08, 0x14, 0x63, 0x00, 0x00 },
-                                 { 0x00, 0x03, 0x04, 0x78, 0x04, 0x03, 0x00, 0x00 },
-                                 { 0x00, 0x61, 0x51, 0x49, 0x45, 0x43, 0x00, 0x00 },
-                                 { 0x00, 0x7F, 0x41, 0x41, 0x00, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00, 0x00 },
-                                 { 0x00, 0x41, 0x41, 0x7F, 0x00, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x04, 0x02, 0x01, 0x02, 0x04, 0x00, 0x00 },
-                                 { 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00 },
-                                 { 0x00, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x20, 0x54, 0x54, 0x54, 0x78, 0x00, 0x00 },
-                                 { 0x00, 0x7F, 0x48, 0x44, 0x44, 0x38, 0x00, 0x00 },
-                                 { 0x00, 0x38, 0x44, 0x44, 0x28, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x38, 0x44, 0x44, 0x48, 0x7F, 0x00, 0x00 },
-                                 { 0x00, 0x38, 0x54, 0x54, 0x54, 0x18, 0x00, 0x00 },
-                                 { 0x00, 0x08, 0x7E, 0x09, 0x02, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x18, 0xA4, 0xA4, 0xA4, 0x7C, 0x00, 0x00 },
-                                 { 0x00, 0x7F, 0x08, 0x04, 0x04, 0x78, 0x00, 0x00 },
-                                 { 0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x80, 0x84, 0x7D, 0x00, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x7F, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x41, 0x7F, 0x40, 0x00, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x7C, 0x04, 0x18, 0x04, 0x78, 0x00, 0x00 },
-                                 { 0x00, 0x7C, 0x08, 0x04, 0x7C, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x38, 0x44, 0x44, 0x38, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0xFC, 0x24, 0x24, 0x18, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x18, 0x24, 0x24, 0xFC, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x00, 0x7C, 0x08, 0x04, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x48, 0x54, 0x54, 0x24, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x04, 0x7F, 0x44, 0x00, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x3C, 0x40, 0x40, 0x7C, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x1C, 0x20, 0x40, 0x20, 0x1C, 0x00, 0x00 },
-                                 { 0x00, 0x3C, 0x40, 0x30, 0x40, 0x3C, 0x00, 0x00 },
-                                 { 0x00, 0x44, 0x28, 0x10, 0x28, 0x44, 0x00, 0x00 },
-                                 { 0x00, 0x1C, 0xA0, 0xA0, 0x7C, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x44, 0x64, 0x54, 0x4C, 0x44, 0x00, 0x00 },
-                                 { 0x00, 0x08, 0x36, 0x41, 0x00, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x41, 0x36, 0x08, 0x00, 0x00, 0x00, 0x00 },
-                                 { 0x00, 0x02, 0x01, 0x01, 0x02, 0x01, 0x00, 0x00 },
-                                 { 0x00, 0x02, 0x05, 0x05, 0x02, 0x00, 0x00, 0x00 } };
-
-typedef enum { HORIZONTAL = 0, VERTICAL = 1, PAGE = 2 } displayAddressingMode;
-}
diff --git a/src/lcd/ssd1306.cxx b/src/lcd/ssd1306.cxx
deleted file mode 100644
index d007ec1..0000000
--- a/src/lcd/ssd1306.cxx
+++ /dev/null
@@ -1,312 +0,0 @@
-/*
- * Author: Marc Graham <marc@m2ag.net>
- * Copyright (c) 2015 Intel Corporation
- *
- * Adapted from ssd1308 library.
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string>
-#include <unistd.h>
-#include <syslog.h>
-
-#include "hd44780_bits.hpp"
-#include "ssd1306.hpp"
-
-using namespace upm;
-
-SSD1306::SSD1306(int bus_in, int addr_in) : m_i2c_lcd_control(bus_in)
-{
-    int vccstate = SSD1306_SWITCHCAPVCC;
-    _vccstate = vccstate;
-
-    int LCD_CMD = 0x00;
-
-    m_lcd_control_address = addr_in;
-    m_name = "SSD1306";
-
-    mraa::Result error = m_i2c_lcd_control.address(m_lcd_control_address);
-    
-    if (error != mraa::SUCCESS) {
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                ": mraa_i2c_address() failed");
-        return;
-    }
-    
-    error = m_i2c_lcd_control.frequency(mraa::I2C_FAST);
-    
-    if (error != mraa::SUCCESS) {
-        syslog(LOG_WARNING, "%s: mraa_i2c_frequency(MRAA_I2C_FAST) failed, using default speed", std::string(__FUNCTION__).c_str());
-    }
-
-    m_i2c_lcd_control.writeReg(LCD_CMD, DISPLAY_CMD_OFF); // display off
-    usleep(4500);
-    //ADD 1306 stuff
-    // Init sequence for 128x64 OLED module                 // 0xAE
-    m_i2c_lcd_control.writeReg(LCD_CMD, SSD1306_SETDISPLAYCLOCKDIV);            // 0xD5
-    m_i2c_lcd_control.writeReg(LCD_CMD, 0x80);                                  // the suggested ratio 0x80
-    m_i2c_lcd_control.writeReg(LCD_CMD, SSD1306_SETMULTIPLEX);                  // 0xA8
-    m_i2c_lcd_control.writeReg(LCD_CMD, 0x3F);
-    m_i2c_lcd_control.writeReg(LCD_CMD, SSD1306_SETDISPLAYOFFSET);              // 0xD3
-    m_i2c_lcd_control.writeReg(LCD_CMD, 0x0);                                   // no offset
-    m_i2c_lcd_control.writeReg(LCD_CMD, SSD1306_SETSTARTLINE | 0x0);            // line #0
-    m_i2c_lcd_control.writeReg(LCD_CMD, SSD1306_CHARGEPUMP);                    // 0x8D
-    if (vccstate == SSD1306_EXTERNALVCC) {
-        m_i2c_lcd_control.writeReg(LCD_CMD, 0x10);
-    } else {
-        m_i2c_lcd_control.writeReg(LCD_CMD,0x14);
-    }
-    m_i2c_lcd_control.writeReg(LCD_CMD, SSD1306_MEMORYMODE);                    // 0x20
-    m_i2c_lcd_control.writeReg(LCD_CMD, 0x00);                                  // 0x0 act like ks0108
-    m_i2c_lcd_control.writeReg(LCD_CMD, SSD1306_SEGREMAP | 0x1);
-    m_i2c_lcd_control.writeReg(LCD_CMD, SSD1306_COMSCANDEC);
-    m_i2c_lcd_control.writeReg(LCD_CMD, SSD1306_SETCOMPINS);                    // 0xDA
-    m_i2c_lcd_control.writeReg(LCD_CMD, 0x12);
-    m_i2c_lcd_control.writeReg(LCD_CMD, SSD1306_SETCONTRAST);                   // 0x81
-    if (vccstate == SSD1306_EXTERNALVCC) {
-        m_i2c_lcd_control.writeReg(LCD_CMD, 0x9F);
-    } else {
-        m_i2c_lcd_control.writeReg(LCD_CMD, 0xCF);
-    }
-    m_i2c_lcd_control.writeReg(LCD_CMD, SSD1306_SETPRECHARGE);                  // 0xd9
-    if (vccstate == SSD1306_EXTERNALVCC) {
-      m_i2c_lcd_control.writeReg(LCD_CMD, 0x22);
-    } else {
-      m_i2c_lcd_control.writeReg(LCD_CMD,0xF1);
-    }
-    m_i2c_lcd_control.writeReg(LCD_CMD, SSD1306_SETVCOMDETECT);                 // 0xDB
-    m_i2c_lcd_control.writeReg(LCD_CMD, 0x40);
-    m_i2c_lcd_control.writeReg(LCD_CMD, SSD1306_DISPLAYALLON_RESUME);           // 0xA4
-    m_i2c_lcd_control.writeReg(LCD_CMD, DISPLAY_CMD_SET_NORMAL_1306);                 // 0xA6
-
-    //END 1306 Stuff
-    m_i2c_lcd_control.writeReg(LCD_CMD, DISPLAY_CMD_ON); // display on
-    usleep(4500);
-    setNormalDisplay(); // set to normal display '1' is ON
-
-    clear();
-    setAddressingMode(PAGE);
-}
-
-SSD1306::~SSD1306()
-{
-}
-
-mraa::Result
-SSD1306::draw(uint8_t* data, int bytes)
-{
-    mraa::Result error = mraa::SUCCESS;
-
-    setAddressingMode(HORIZONTAL);
-    for (int idx = 0; idx < bytes; idx++) {
-        m_i2c_lcd_control.writeReg(LCD_DATA, data[idx]);
-    }
-
-    return error;
-}
-
-/*
- * **************
- *  virtual area
- * **************
- */
-mraa::Result
-SSD1306::write(std::string msg)
-{
-    mraa::Result error = mraa::SUCCESS;
-
-    setAddressingMode(PAGE);
-    for (std::string::size_type i = 0; i < msg.size(); ++i) {
-        writeChar(msg[i]);
-    }
-
-    return error;
-}
-
-mraa::Result
-SSD1306::setCursor(int row, int column)
-{
-    mraa::Result error = mraa::SUCCESS;
-
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, BASE_PAGE_START_ADDR + row); // set page address
-    error = m_i2c_lcd_control.writeReg(LCD_CMD,
-                                       BASE_LOW_COLUMN_ADDR + (8 * column & 0x0F)); // set column
-                                                                                    // lower address
-    error = m_i2c_lcd_control.writeReg(LCD_CMD,
-                                       BASE_HIGH_COLUMN_ADDR +
-                                       ((8 * column >> 4) & 0x0F)); // set column higher address
-
-    return error;
-}
-
-mraa::Result
-SSD1306::clear()
-{
-    mraa::Result error = mraa::SUCCESS;
-    uint8_t columnIdx, rowIdx;
-
-    m_i2c_lcd_control.writeReg(LCD_CMD, DISPLAY_CMD_OFF); // display off
-    for (rowIdx = 0; rowIdx < 8; rowIdx++) {
-        setCursor(rowIdx, 0);
-
-        // clear all columns
-        for (columnIdx = 0; columnIdx < 16; columnIdx++) {
-            writeChar(' ');
-        }
-    }
-    m_i2c_lcd_control.writeReg(LCD_CMD, DISPLAY_CMD_ON); // display on
-    home();
-
-    return error;
-}
-
-mraa::Result
-SSD1306::home()
-{
-    return setCursor(0, 0);
-}
-
-/*
- * **************
- *  private area
- * **************
- */
-mraa::Result
-SSD1306::writeChar(uint8_t value)
-{
-    mraa::Result rv;
-    if (value < 0x20 || value > 0x7F) {
-        value = 0x20; // space
-    }
-
-    for (uint8_t idx = 0; idx < 8; idx++) {
-        rv = m_i2c_lcd_control.writeReg(LCD_DATA, BasicFont[value - 32][idx]);
-    }
-
-    return rv;
-}
-
-mraa::Result
-SSD1306::setNormalDisplay()
-{
-    return m_i2c_lcd_control.writeReg(LCD_CMD,
-                                      DISPLAY_CMD_SET_NORMAL_1306); // set to normal display '1' is
-                                                                    // ON
-}
-
-mraa::Result
-SSD1306::setAddressingMode(displayAddressingMode mode)
-{
-    mraa::Result rv;
-    rv =m_i2c_lcd_control.writeReg(LCD_CMD, DISPLAY_CMD_MEM_ADDR_MODE); // set addressing mode
-    rv =m_i2c_lcd_control.writeReg(LCD_CMD, mode);                      // set page addressing mode
-    return rv;
-}
-
-
-mraa::Result
-SSD1306::invert(bool i)
-{
-    mraa::Result rv;
-    if(i){
-        rv = m_i2c_lcd_control.writeReg(LCD_CMD,  DISPLAY_CMD_SET_INVERT_1306);
-    } else {
-        rv = m_i2c_lcd_control.writeReg(LCD_CMD,  DISPLAY_CMD_SET_NORMAL_1306);
-    }
-    return rv;
-}
-
-
-void SSD1306::startscrollright(uint8_t start, uint8_t stop){
-    m_i2c_lcd_control.writeReg(LCD_CMD,SSD1306_RIGHT_HORIZONTAL_SCROLL);
-    m_i2c_lcd_control.writeReg(LCD_CMD,0X00);
-    m_i2c_lcd_control.writeReg(LCD_CMD,start);
-    m_i2c_lcd_control.writeReg(LCD_CMD,0X00);
-    m_i2c_lcd_control.writeReg(LCD_CMD,stop);
-    m_i2c_lcd_control.writeReg(LCD_CMD,0X00);
-    m_i2c_lcd_control.writeReg(LCD_CMD,0XFF);
-    m_i2c_lcd_control.writeReg(LCD_CMD,SSD1306_ACTIVATE_SCROLL);
-}
-
-
-void SSD1306::startscrollleft(uint8_t start, uint8_t stop){
-    m_i2c_lcd_control.writeReg(LCD_CMD,SSD1306_LEFT_HORIZONTAL_SCROLL);
-    m_i2c_lcd_control.writeReg(LCD_CMD,0X00);
-    m_i2c_lcd_control.writeReg(LCD_CMD,start);
-    m_i2c_lcd_control.writeReg(LCD_CMD,0X00);
-    m_i2c_lcd_control.writeReg(LCD_CMD,stop);
-    m_i2c_lcd_control.writeReg(LCD_CMD,0X00);
-    m_i2c_lcd_control.writeReg(LCD_CMD,0XFF);
-    m_i2c_lcd_control.writeReg(LCD_CMD,SSD1306_ACTIVATE_SCROLL);
-}
-
-void SSD1306::startscrolldiagright(uint8_t start, uint8_t stop){
-    m_i2c_lcd_control.writeReg(LCD_CMD, SSD1306_SET_VERTICAL_SCROLL_AREA);
-    m_i2c_lcd_control.writeReg(LCD_CMD, 0X00);
-    m_i2c_lcd_control.writeReg(LCD_CMD, SSD1306_LCDHEIGHT);
-    m_i2c_lcd_control.writeReg(LCD_CMD, SSD1306_VERTICAL_AND_RIGHT_HORIZONTAL_SCROLL);
-    m_i2c_lcd_control.writeReg(LCD_CMD, 0X00);
-    m_i2c_lcd_control.writeReg(LCD_CMD, start);
-    m_i2c_lcd_control.writeReg(LCD_CMD, 0X00);
-    m_i2c_lcd_control.writeReg(LCD_CMD, stop);
-    m_i2c_lcd_control.writeReg(LCD_CMD, 0X01);
-    m_i2c_lcd_control.writeReg(LCD_CMD, SSD1306_ACTIVATE_SCROLL);
-}
-
-void SSD1306::startscrolldiagleft(uint8_t start, uint8_t stop){
-    m_i2c_lcd_control.writeReg(LCD_CMD, SSD1306_SET_VERTICAL_SCROLL_AREA);
-    m_i2c_lcd_control.writeReg(LCD_CMD, 0X00);
-    m_i2c_lcd_control.writeReg(LCD_CMD, SSD1306_LCDHEIGHT);
-    m_i2c_lcd_control.writeReg(LCD_CMD, SSD1306_VERTICAL_AND_LEFT_HORIZONTAL_SCROLL);
-    m_i2c_lcd_control.writeReg(LCD_CMD, 0X00);
-    m_i2c_lcd_control.writeReg(LCD_CMD, start);
-    m_i2c_lcd_control.writeReg(LCD_CMD, 0X00);
-    m_i2c_lcd_control.writeReg(LCD_CMD, stop);
-    m_i2c_lcd_control.writeReg(LCD_CMD, 0X01);
-    m_i2c_lcd_control.writeReg(LCD_CMD, SSD1306_ACTIVATE_SCROLL);
-}
-
-void SSD1306::stopscroll(void){
-    m_i2c_lcd_control.writeReg(LCD_CMD,SSD1306_DEACTIVATE_SCROLL);
-}
-
-// Dim the display
-// dim = true: display is dimmed
-// dim = false: display is normal
-void SSD1306::dim(bool dim) {
-    uint8_t contrast;
-
-    if (dim) {
-    contrast = 0; // Dimmed display
-    } else {
-    if (_vccstate == SSD1306_EXTERNALVCC) {
-      contrast = 0x9F;
-    } else {
-      contrast = 0xCF;
-    }
-    }
-    // the range of contrast to too small to be really useful
-    // it is useful to dim the display
-    m_i2c_lcd_control.writeReg(LCD_CMD,SSD1306_SETCONTRAST);
-    m_i2c_lcd_control.writeReg(LCD_CMD,contrast);
-}
diff --git a/src/lcd/ssd1306.hpp b/src/lcd/ssd1306.hpp
deleted file mode 100644
index aff1071..0000000
--- a/src/lcd/ssd1306.hpp
+++ /dev/null
@@ -1,230 +0,0 @@
-/*
- * Author: Marc Graham <marc@m2ag.net>
- * Copyright (c) 2015 Intel Corporation
- *
- * Adapted from ssd1308 library.
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <string>
-#include <mraa/i2c.hpp>
-#include "lcd.hpp"
-#include "ssd.hpp"
-
-namespace upm
-{
-const uint8_t  DISPLAY_CMD_SET_NORMAL_1306 = 0xA6;
-const uint8_t  SSD1306_SETCONTRAST = 0x81;
-const uint8_t  SSD1306_DISPLAYALLON_RESUME =0xA4;
-const uint8_t  SSD1306_DISPLAYALLON = 0xA5;
-const uint8_t  DISPLAY_CMD_SET_INVERT_1306 = 0xA7;
-
-const uint8_t  SSD1306_SETDISPLAYOFFSET =0xD3;
-const uint8_t  SSD1306_SETCOMPINS = 0xDA;
-
-const uint8_t  SSD1306_SETVCOMDETECT = 0xDB;
-
-const uint8_t  SSD1306_SETDISPLAYCLOCKDIV = 0xD5;
-const uint8_t  SSD1306_SETPRECHARGE = 0xD9;
-
-const uint8_t  SSD1306_SETMULTIPLEX = 0xA8;
-
-const uint8_t  SSD1306_SETLOWCOLUM = 0x00;
-const uint8_t  SSD1306_SETHIGHCOLUMN = 0x10;
-
-const uint8_t  SSD1306_SETSTARTLINE = 0x40;
-
-const uint8_t  SSD1306_MEMORYMODE = 0x20;
-const uint8_t  SSD1306_COLUMNADDR = 0x21;
-const uint8_t  SSD1306_PAGEADDR = 0x22;
-
-const uint8_t  SSD1306_COMSCANINC = 0xC0;
-const uint8_t  SSD1306_COMSCANDEC = 0xC8;
-
-const uint8_t  SSD1306_SEGREMAP = 0xA0;
-
-const uint8_t  SSD1306_CHARGEPUMP = 0x8D;
-
-const uint8_t  SSD1306_EXTERNALVCC = 0x1;
-const uint8_t  SSD1306_SWITCHCAPVCC = 0x2;
-
-// Scrolling const uint8_t s
-const uint8_t  SSD1306_ACTIVATE_SCROLL = 0x2F;
-const uint8_t  SSD1306_DEACTIVATE_SCROLL = 0x2E;
-const uint8_t  SSD1306_SET_VERTICAL_SCROLL_AREA = 0xA3;
-const uint8_t  SSD1306_RIGHT_HORIZONTAL_SCROLL = 0x26;
-const uint8_t  SSD1306_LEFT_HORIZONTAL_SCROLL = 0x27;
-const uint8_t  SSD1306_VERTICAL_AND_RIGHT_HORIZONTAL_SCROLL = 0x29;
-const uint8_t  SSD1306_VERTICAL_AND_LEFT_HORIZONTAL_SCROLL = 0x2A;
-
-const uint8_t  SSD1306_BLACK = 0;
-const uint8_t  SSD1306_WHITE = 1;
-const uint8_t  SSD1306_LCDWIDTH = 128;
-const uint8_t  SSD1306_LCDHEIGHT = 64;
-
-/**
- * @library lcd
- * @sensor ssd1306
- * @comname OLED Display
- * @altname Adafruit SSD1306 OLED Display 0.96"
- * @type display
- * @man adafruit
- * @web https://www.adafruit.com/datasheets/SSD1306.pdf
- * @web http://www.farnell.com/datasheets/609753.pdf
- * @con i2c
- *
- * @brief API for SSD1306 I2C-controlled OLED displays
- *
- * SSD1306 is a 128x64 dot-matrix OLED/PLED segment driver with a
- * controller. This device is available from many suppliers for a
- * very low cost. This implementation was tested using a generic
- * SSD1306 device from eBay.
- *
- * @image html ssd1306.jpeg
- * @snippet lcd-ssd1306-oled.cxx Interesting
- */
-class SSD1306 : public LCD
-{
-  public:
-    /**
-     * SSD1306 constructor; calls libmraa initialisation functions
-     *
-     * @param bus I2C bus to use
-     * @param address Slave address the LCD is registered on
-     */
-    SSD1306(int bus, int address = 0x3C);
-    /**
-     * SSD1306 destructor
-     */
-    ~SSD1306();
-    /**
-     * Draws an image; see examples/python/make_oled_pic.py for an
-     * explanation of how pixels are mapped to bytes
-     *
-     * @param data Buffer to read
-     * @param bytes Number of bytes to read from the pointer
-     * @return Result of the operation
-     */
-    mraa::Result draw(uint8_t* data, int bytes);
-    /**
-     * Writes a string to the LCD
-     *
-     * @param msg std::string to write to the display; note: only ASCII
-     * characters are supported
-     * @return Result of the operation
-     */
-    mraa::Result write(std::string msg);
-    /**
-     * Sets the cursor to specified coordinates
-     *
-     * @param row Row to set the cursor to
-     * @param column Column to set the cursor to
-     * @return Result of the operation
-     */
-    mraa::Result setCursor(int row, int column);
-    /**
-     * Clears the display of all characters
-     *
-     * @return Result of the operation
-     */
-    mraa::Result clear();
-    /**
-     * Returns to the original coordinates (0,0)
-     *
-     * @return Result of the operation
-     */
-    mraa::Result home();
-    /**
-     * Inverts the display
-     *
-     * @param i true to invert, false for normal display
-     * @return Result of the operation
-     */
-    mraa::Result invert(bool i);
-    /**
-     *  Activate a scroll to the right for rows start through stop
-     *  The display is 16 rows tall. To scroll the whole display, run:
-     *  display.scrollright(0x00, 0x0F)
-     *
-     * @param start First row to scroll
-     * @param stop  Last row to scroll
-     * @return void
-     */
-    void startscrollright(uint8_t start, uint8_t stop);
-    /**
-     *  Activate a scroll to the left for rows start through stop
-     *  The display is 16 rows tall. To scroll the whole display, run:
-     *  display.startscrollright(0x00, 0x0F)
-     *
-     * @param start First row to scroll
-     * @param stop  Last row to scroll
-     * @return void
-     */
-    void startscrollleft(uint8_t start, uint8_t stop);
-    /**
-     *  Activate a scroll to the upper right for rows start through stop
-     *  The display is 16 rows tall. To scroll the whole display, run:
-     *  display.startscrollleft(0x00, 0x0F)
-     *
-     * @param start First row to scroll
-     * @param stop  Last row to scroll
-     * @return void
-     */
-    void startscrolldiagright(uint8_t start, uint8_t stop);
-    /**
-     *  Activate a scroll to the upper left for rows start through stop
-     *  The display is 16 rows tall. To scroll the whole display, run:
-     *  display.startscrolldiaagright(0x00, 0x0F)
-     *
-     * @param start First row to scroll
-     * @param stop  Last row to scroll
-     * @return void
-     */
-    void startscrolldiagleft(uint8_t start, uint8_t stop);
-    /**
-     * Stops display scrolling.
-     *
-     * @return void
-     */
-    void stopscroll(void);
-    /**
-     * Dims display
-     *
-     * @param dim True to dim display, false for max intensity
-     * @return Result of last operation
-     */
-    void dim(bool dim);
-
-  private:
-    mraa::Result writeChar(uint8_t value);
-    mraa::Result setNormalDisplay();
-    mraa::Result setAddressingMode(displayAddressingMode mode);
-
-    int m_lcd_control_address;
-    mraa::I2c m_i2c_lcd_control;
-
-    int _vccstate;
-};
-}
diff --git a/src/lcd/ssd1308.cxx b/src/lcd/ssd1308.cxx
deleted file mode 100644
index c4a3507..0000000
--- a/src/lcd/ssd1308.cxx
+++ /dev/null
@@ -1,166 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <stdexcept>
-#include <string>
-#include <unistd.h>
-
-#include "hd44780_bits.hpp"
-#include "ssd1308.hpp"
-
-using namespace upm;
-
-SSD1308::SSD1308(int bus_in, int addr_in) : m_i2c_lcd_control(bus_in)
-{
-    m_lcd_control_address = addr_in;
-    m_name = "SSD1308";
-
-    mraa::Result error = m_i2c_lcd_control.address(m_lcd_control_address);
-    if (error != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": I2c.address() failed");
-        return;
-    }
-
-    m_i2c_lcd_control.writeReg(LCD_CMD, DISPLAY_CMD_OFF); // display off
-    usleep(4500);
-    m_i2c_lcd_control.writeReg(LCD_CMD, DISPLAY_CMD_ON); // display on
-    usleep(4500);
-    setNormalDisplay(); // set to normal display '1' is ON
-
-    clear();
-    setAddressingMode(PAGE);
-}
-
-SSD1308::~SSD1308()
-{
-}
-
-mraa::Result
-SSD1308::draw(uint8_t* data, int bytes)
-{
-    mraa::Result error = mraa::SUCCESS;
-
-    setAddressingMode(HORIZONTAL);
-    for (int idx = 0; idx < bytes; idx++) {
-        m_i2c_lcd_control.writeReg(LCD_DATA, data[idx]);
-    }
-
-    return error;
-}
-
-/*
- * **************
- *  virtual area
- * **************
- */
-mraa::Result
-SSD1308::write(std::string msg)
-{
-    setAddressingMode(PAGE);
-    for (std::string::size_type i = 0; i < msg.size(); ++i) {
-        writeChar(msg[i]);
-    }
-
-    return mraa::SUCCESS;
-}
-
-mraa::Result
-SSD1308::setCursor(int row, int column)
-{
-    mraa::Result error = mraa::SUCCESS;
-
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, BASE_PAGE_START_ADDR + row); // set page address
-    error = m_i2c_lcd_control.writeReg(LCD_CMD,
-                                       BASE_LOW_COLUMN_ADDR + (8 * column & 0x0F)); // set column
-                                                                                    // lower address
-    error = m_i2c_lcd_control.writeReg(LCD_CMD,
-                                       BASE_HIGH_COLUMN_ADDR +
-                                       ((8 * column >> 4) & 0x0F)); // set column higher address
-
-    return error;
-}
-
-mraa::Result
-SSD1308::clear()
-{
-    uint8_t columnIdx, rowIdx;
-
-    m_i2c_lcd_control.writeReg(LCD_CMD, DISPLAY_CMD_OFF); // display off
-    for (rowIdx = 0; rowIdx < 8; rowIdx++) {
-        setCursor(rowIdx, 0);
-
-        // clear all columns
-        for (columnIdx = 0; columnIdx < 16; columnIdx++) {
-            writeChar(' ');
-        }
-    }
-    m_i2c_lcd_control.writeReg(LCD_CMD, DISPLAY_CMD_ON); // display on
-    home();
-
-    return mraa::SUCCESS;
-}
-
-mraa::Result
-SSD1308::home()
-{
-    return setCursor(0, 0);
-}
-
-/*
- * **************
- *  private area
- * **************
- */
-mraa::Result
-SSD1308::writeChar(uint8_t value)
-{
-    mraa::Result rv;
-    if (value < 0x20 || value > 0x7F) {
-        value = 0x20; // space
-    }
-
-    for (uint8_t idx = 0; idx < 8; idx++) {
-        rv = m_i2c_lcd_control.writeReg(LCD_DATA, BasicFont[value - 32][idx]);
-    }
-
-    return rv;
-}
-
-mraa::Result
-SSD1308::setNormalDisplay()
-{
-    return m_i2c_lcd_control.writeReg(LCD_CMD,
-                                      DISPLAY_CMD_SET_NORMAL_1308); // set to normal display '1' is
-                                                                    // ON
-}
-
-mraa::Result
-SSD1308::setAddressingMode(displayAddressingMode mode)
-{
-    mraa::Result rv;
-    rv =m_i2c_lcd_control.writeReg(LCD_CMD, DISPLAY_CMD_MEM_ADDR_MODE); // set addressing mode
-    rv =m_i2c_lcd_control.writeReg(LCD_CMD, mode);                      // set page addressing mode
-    return rv;
-}
diff --git a/src/lcd/ssd1308.hpp b/src/lcd/ssd1308.hpp
deleted file mode 100644
index b60b505..0000000
--- a/src/lcd/ssd1308.hpp
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <string>
-#include <mraa/i2c.hpp>
-#include "lcd.hpp"
-#include "ssd.hpp"
-
-namespace upm
-{
-const uint8_t DISPLAY_CMD_SET_NORMAL_1308 = 0xA6;
-
-/**
- * @library lcd
- * @sensor ssd1308
- * @comname OLED Display
- * @altname Grove OLED Display 0.96"
- * @type display
- * @man seeed adafruit
- * @web http://wiki.seeed.cc/Grove-OLED_Display_0.96inch/
- * @web http://www.seeedstudio.com/wiki/Grove_-_OLED_Display_0.96%22
- * @con i2c
- *
- * @brief API for SSD1308 I2C-controlled OLED displays
- *
- * SSD1308 is a 128x64 dot-matrix OLED/PLED segment driver with a
- * controller. This implementation was tested using the Grove LED 128*64
- * Display module, which is an OLED monochrome display.
- *
- * @image html ssd1308.jpeg
- * @snippet lcd-ssd1308-oled.cxx Interesting
- */
-class SSD1308 : public LCD
-{
-  public:
-    /**
-     * SSD1308 constructor; calls libmraa initialisation functions
-     *
-     * @param bus I2C bus to use
-     * @param address Slave address the LCD is registered on
-     */
-    SSD1308(int bus, int address = 0x3C);
-    /**
-     * SSD1308 destructor
-     */
-    ~SSD1308();
-    /**
-     * Draws an image; see examples/python/make_oled_pic.py for an
-     * explanation of how pixels are mapped to bytes
-     *
-     * @param data Buffer to read
-     * @param bytes Number of bytes to read from the pointer
-     * @return Result of the operation
-     */
-    mraa::Result draw(uint8_t* data, int bytes);
-    /**
-     * Writes a string to the LCD
-     *
-     * @param msg std::string to write to the display; note: only ASCII
-     * characters are supported
-     * @return Result of the operation
-     */
-    mraa::Result write(std::string msg);
-    /**
-     * Sets the cursor to specified coordinates
-     *
-     * @param row Row to set the cursor to
-     * @param column Column to set the cursor to
-     * @return Result of the operation
-     */
-    mraa::Result setCursor(int row, int column);
-    /**
-     * Clears the display of all characters
-     *
-     * @return Result of the operation
-     */
-    mraa::Result clear();
-    /**
-     * Returns to the original coordinates (0,0)
-     *
-     * @return Result of the operation
-     */
-    mraa::Result home();
-
-  private:
-    mraa::Result writeChar(uint8_t value);
-    mraa::Result setNormalDisplay();
-    mraa::Result setAddressingMode(displayAddressingMode mode);
-
-    int m_lcd_control_address;
-    mraa::I2c m_i2c_lcd_control;
-};
-}
diff --git a/src/lcd/ssd1327.cxx b/src/lcd/ssd1327.cxx
deleted file mode 100644
index 1fa332f..0000000
--- a/src/lcd/ssd1327.cxx
+++ /dev/null
@@ -1,318 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <stdexcept>
-#include <string>
-#include <unistd.h>
-
-#include "hd44780_bits.hpp"
-#include "ssd1327.hpp"
-
-using namespace upm;
-
-#define INIT_SLEEP 50000
-#define CMD_SLEEP 10000
-
-SSD1327::SSD1327(int bus_in, int addr_in) : m_i2c_lcd_control(bus_in)
-{
-    mraa::Result error = mraa::SUCCESS;
-
-    m_lcd_control_address = addr_in;
-    m_name = "SSD1327";
-
-    error = m_i2c_lcd_control.address(m_lcd_control_address);
-    if (error != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": I2c.address() failed");
-        return;
-    }
-
-    usleep(INIT_SLEEP);
-    m_i2c_lcd_control.writeReg(LCD_CMD, 0xFD); // Unlock OLED driver IC MCU
-                                               // interface from entering command.
-                                               // i.e: Accept commands
-    usleep(INIT_SLEEP);
-    m_i2c_lcd_control.writeReg(LCD_CMD, 0x12);
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0xAE); // Set display off
-    usleep(INIT_SLEEP);
-    m_i2c_lcd_control.writeReg(LCD_CMD, 0xA8); // set multiplex ratio
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0x5F); // 96
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0xA1); // set display start line
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0x00); //
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0xA2); // set display offset
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0x60);
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0xA0); // set remap
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0x46);
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0xAB); // set vdd internal
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0x01); //
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0x81); // set contrasr
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0x53); // 100 nit
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0xB1); // Set Phase Length
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0X51); //
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0xB3); // Set Display Clock Divide Ratio/Oscillator
-                                                       // Frequency
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0x01); //
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0xB9); //
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0xBC); // set pre_charge
-                                                       // voltage/VCOMH
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0x08); // (0x08);
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0xBE); // set VCOMH
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0X07); // (0x07);
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0xB6); // Set second pre-charge
-                                                       // period
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0x01); //
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0xD5); // enable second precharge and enternal vsl
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0X62); // (0x62);
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0xA4); // Set Normal Display Mode
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0x2E); // Deactivate Scroll
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0xAF); // Switch on display
-    usleep(INIT_SLEEP);
-
-    // Row Address
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0x75); // Set Row Address
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0x00); // Start 0
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0x5f); // End 95
-    usleep(INIT_SLEEP);
-
-    // Column Address
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0x15); // Set Column Address
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0x08); // Start from 8th Column of
-                                                       // driver IC. This is 0th
-                                                       // Column for OLED
-    usleep(INIT_SLEEP);
-    error = m_i2c_lcd_control.writeReg(LCD_CMD, 0x37); // End at  (8 + 47)th
-                                                       // column. Each Column has 2
-                                                       // pixels(segments)
-    usleep(INIT_SLEEP);
-
-    clear();
-    setNormalDisplay();
-    setVerticalMode();
-}
-
-SSD1327::~SSD1327()
-{
-}
-
-mraa::Result
-SSD1327::draw(uint8_t* data, int bytes)
-{
-    mraa::Result error = mraa::SUCCESS;
-
-    setHorizontalMode();
-    for (int row = 0; row < bytes; row++) {
-        for (uint8_t col = 0; col < 8; col += 2) {
-            uint8_t value = 0x0;
-
-            uint8_t bitOne = (data[row] << col) & 0x80;
-            uint8_t bitTwo = (data[row] << (col + 1)) & 0x80;
-
-            value |= (bitOne) ? grayHigh : 0x00;
-            value |= (bitTwo) ? grayLow : 0x00;
-
-            m_i2c_lcd_control.writeReg(LCD_DATA, value);
-            usleep(CMD_SLEEP - 2000);
-        }
-    }
-
-    return error;
-}
-
-/*
- * **************
- *  virtual area
- * **************
- */
-mraa::Result
-SSD1327::write(std::string msg)
-{
-    mraa::Result error = mraa::SUCCESS;
-
-    setVerticalMode();
-    for (std::string::size_type i = 0; i < msg.size(); ++i) {
-        writeChar(msg[i]);
-    }
-
-    return error;
-}
-
-mraa::Result
-SSD1327::setCursor(int row, int column)
-{
-    mraa::Result error = mraa::SUCCESS;
-
-    // Column Address
-    m_i2c_lcd_control.writeReg(LCD_CMD, 0x15); /* Set Column Address */
-    usleep(CMD_SLEEP);
-    m_i2c_lcd_control.writeReg(LCD_CMD, 0x08 + (column * 4)); /* Start Column:
-                                                                                  Start from 8 */
-    usleep(CMD_SLEEP);
-    m_i2c_lcd_control.writeReg(LCD_CMD, 0x37); /* End Column */
-    usleep(CMD_SLEEP);
-    // Row Address
-    m_i2c_lcd_control.writeReg(LCD_CMD, 0x75); /* Set Row Address */
-    usleep(CMD_SLEEP);
-    m_i2c_lcd_control.writeReg(LCD_CMD, 0x00 + (row * 8)); /* Start Row*/
-    usleep(CMD_SLEEP);
-    m_i2c_lcd_control.writeReg(LCD_CMD, 0x07 + (row * 8)); /* End Row*/
-    usleep(CMD_SLEEP);
-
-    return error;
-}
-
-mraa::Result
-SSD1327::clear()
-{
-    uint8_t columnIdx, rowIdx;
-
-    for (rowIdx = 0; rowIdx < 12; rowIdx++) {
-        // clear all columns
-        for (columnIdx = 0; columnIdx < 12; columnIdx++) {
-            writeChar(' ');
-        }
-    }
-
-    return mraa::SUCCESS;
-}
-
-mraa::Result
-SSD1327::home()
-{
-    return setCursor(0, 0);
-}
-
-void
-SSD1327::setGrayLevel(uint8_t level)
-{
-    grayHigh = (level << 4) & 0xF0;
-    grayLow = level & 0x0F;
-}
-
-/*
- * **************
- *  private area
- * **************
- */
-mraa::Result
-SSD1327::writeChar(uint8_t value)
-{
-    mraa::Result rv = mraa::SUCCESS;
-    if (value < 0x20 || value > 0x7F) {
-        value = 0x20; // space
-    }
-
-    for (uint8_t row = 0; row < 8; row = row + 2) {
-        for (uint8_t col = 0; col < 8; col++) {
-            uint8_t data = 0x0;
-
-            uint8_t bitOne = ((BasicFont[value - 32][row]) >> col) & 0x1;
-            uint8_t bitTwo = ((BasicFont[value - 32][row + 1]) >> col) & 0x1;
-
-            data |= (bitOne) ? grayHigh : 0x00;
-            data |= (bitTwo) ? grayLow : 0x00;
-
-            rv = m_i2c_lcd_control.writeReg(LCD_DATA, data);
-            usleep(CMD_SLEEP - 2000);
-        }
-    }
-    return rv;
-}
-
-mraa::Result
-SSD1327::setNormalDisplay()
-{
-    return m_i2c_lcd_control.writeReg(LCD_CMD,
-                                      DISPLAY_CMD_SET_NORMAL); // set to normal display '1' is ON
-}
-
-mraa::Result
-SSD1327::setHorizontalMode()
-{
-    mraa::Result rv = mraa::SUCCESS;
-    rv = m_i2c_lcd_control.writeReg(LCD_CMD, 0xA0); // remap to
-    usleep(CMD_SLEEP);
-    rv = m_i2c_lcd_control.writeReg(LCD_CMD, 0x42); // horizontal mode
-    usleep(CMD_SLEEP);
-
-    // Row Address
-    rv = m_i2c_lcd_control.writeReg(LCD_CMD, 0x75); // Set Row Address
-    usleep(CMD_SLEEP);
-    rv = m_i2c_lcd_control.writeReg(LCD_CMD, 0x00); // Start 0
-    usleep(CMD_SLEEP);
-    rv = m_i2c_lcd_control.writeReg(LCD_CMD, 0x5f); // End 95
-    usleep(CMD_SLEEP);
-
-    // Column Address
-    rv = m_i2c_lcd_control.writeReg(LCD_CMD, 0x15); // Set Column Address
-    usleep(CMD_SLEEP);
-    rv = m_i2c_lcd_control.writeReg(LCD_CMD, 0x08); // Start from 8th Column of driver
-                                               // IC. This is 0th Column for OLED
-    usleep(CMD_SLEEP);
-    rv = m_i2c_lcd_control.writeReg(LCD_CMD, 0x37); // End at  (8 + 47)th column. Each
-                                               // Column has 2 pixels(or segments)
-    usleep(CMD_SLEEP);
-    return rv;
-}
-
-mraa::Result
-SSD1327::setVerticalMode()
-{
-    mraa::Result rv = mraa::SUCCESS;
-    rv = m_i2c_lcd_control.writeReg(LCD_CMD, 0xA0); // remap to
-    usleep(CMD_SLEEP);
-    rv = m_i2c_lcd_control.writeReg(LCD_CMD, 0x46); // Vertical mode
-    usleep(CMD_SLEEP);
-    return rv;
-}
diff --git a/src/lcd/ssd1327.hpp b/src/lcd/ssd1327.hpp
deleted file mode 100644
index 5f18be6..0000000
--- a/src/lcd/ssd1327.hpp
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <string>
-#include <mraa/i2c.hpp>
-#include "lcd.hpp"
-#include "ssd.hpp"
-
-namespace upm
-{
-const uint8_t DISPLAY_CMD_SET_NORMAL = 0xA4;
-
-/**
- * @library lcd
- * @sensor ssd1327
- * @comname OLED Display
- * @altname Grove OLED Display 1.12"
- * @type display
- * @man seeed adafruit
- * @web http://wiki.seeed.cc/Grove-OLED_Display_1.12inch/
- * @con i2c
- *
- * @brief API for SSD1327 I2C-controlled OLED displays
- *
- * SSD1327 is a 96x96 dot-matrix OLED/PLED segment driver with a controller.
- * This implementation was tested using the Grove LED 96*96 Display module,
- * which is an OLED monochrome display.
- *
- * @image html ssd1327.jpeg
- * @snippet lcd-ssd1327-oled.cxx Interesting
- */
-class SSD1327 : public LCD
-{
-  public:
-    /**
-     * SSD1327 constructor; calls libmraa initialisation functions
-     *
-     * @param bus I2C bus to use
-     * @param address Slave address the LCD is registered on
-     */
-    SSD1327(int bus, int address = 0x3C);
-    /**
-     * SSD1327 destructor
-     */
-    ~SSD1327();
-    /**
-     * Draws an image; see examples/python/make_oled_pic.py for an
-     * explanation of how pixels are mapped to bytes
-     *
-     * @param data Buffer to read
-     * @param bytes Number of bytes to read from the pointer
-     * @return Result of the operation
-     */
-    mraa::Result draw(uint8_t* data, int bytes);
-    /**
-     * Sets the gray level for the LCD panel
-     *
-     * @param level level from 0 to 255
-     * @return Result of the operation
-     */
-    void setGrayLevel(uint8_t level);
-    /**
-     * Writes a string to the LCD
-     *
-     * @param msg std::string to write to the display; note: only ASCII
-     * characters are supported
-     * @return Result of the operation
-     */
-    mraa::Result write(std::string msg);
-    /**
-     * Sets the cursor to specified coordinates
-     *
-     * @param row Row to set the cursor to
-     * @param column Column to set the cursor to
-     * @return Result of the operation
-     */
-    mraa::Result setCursor(int row, int column);
-    /**
-     * Clears the display of all characters
-     *
-     * @return Result of the operation
-     */
-    mraa::Result clear();
-    /**
-     * Returns to the original coordinates (0,0)
-     *
-     * @return Result of the operation
-     */
-    mraa::Result home();
-
-  private:
-    mraa::Result writeChar(uint8_t value);
-    mraa::Result setNormalDisplay();
-    mraa::Result setHorizontalMode();
-    mraa::Result setVerticalMode();
-
-    uint8_t grayHigh;
-    uint8_t grayLow;
-
-    int m_lcd_control_address;
-    mraa::I2c m_i2c_lcd_control;
-};
-}
diff --git a/src/lcdks/CMakeLists.txt b/src/lcdks/CMakeLists.txt
deleted file mode 100644
index dd1e081..0000000
--- a/src/lcdks/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-upm_mixed_module_init (NAME lcdks
-    DESCRIPTION "LCD Display Driver for LCD Keypad Shield devices based on the LCM1602"
-    C_HDR lcdks.h
-    C_SRC lcdks.c
-    CPP_HDR lcdks.hpp
-    CPP_SRC lcdks.cxx
-    CPP_WRAPS_C
-    REQUIRES mraa lcm1602)
diff --git a/src/lcdks/lcdks.c b/src/lcdks/lcdks.c
deleted file mode 100644
index 0a1f532..0000000
--- a/src/lcdks/lcdks.c
+++ /dev/null
@@ -1,217 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Based on UPM C++ drivers originally developed by:
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <assert.h>
-#include <string.h>
-
-#include <upm_utilities.h>
-
-#include "lcdks.h"
-
-lcdks_context lcdks_init(int rs, int enable,
-                         int d0, int d1, int d2, int d3,
-                         int keypad, int backlight)
-{
-    lcdks_context dev =
-        (lcdks_context)malloc(sizeof(struct _lcdks_context));
-
-    if (!dev)
-        return NULL;
-
-    memset((void *)dev, 0, sizeof(struct _lcdks_context));
-
-    // make sure MRAA is initialized
-    if (mraa_init() != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed.\n", __FUNCTION__);
-        lcdks_close(dev);
-        return NULL;
-    }
-
-    // initialize the lcm1602 context
-    if (!(dev->lcm1602 = lcm1602_gpio_init(rs, enable, d0, d1, d2, d3, 16, 2)))
-    {
-        printf("%s: lcm1602_init failed.\n", __FUNCTION__);
-        lcdks_close(dev);
-        return NULL;
-    }
-
-    // analog keypad
-    if (!(dev->aio = mraa_aio_init(keypad)))
-    {
-        printf("%s: mraa_aio_init() failed.\n", __FUNCTION__);
-        lcdks_close(dev);
-
-        return NULL;
-    }
-
-    // optional backlight control pin
-    if (backlight >= 0)
-    {
-        if (!(dev->gpio = mraa_gpio_init(backlight)))
-        {
-            printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
-            lcdks_close(dev);
-
-            return NULL;
-        }
-
-        mraa_gpio_dir(dev->gpio, MRAA_GPIO_OUT);
-    }
-
-    // just in case...
-    lcdks_backlight_on(dev, true);
-
-    return dev;
-}
-
-void lcdks_close(lcdks_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->gpio)
-        mraa_gpio_close(dev->gpio);
-    if (dev->aio)
-        mraa_aio_close(dev->aio);
-    if (dev->lcm1602)
-        lcm1602_close(dev->lcm1602);
-
-    free(dev);
-}
-
-upm_result_t lcdks_write(const lcdks_context dev, char *buffer,
-                         int len)
-{
-    assert(dev != NULL);
-
-    return lcm1602_write(dev->lcm1602, buffer, len);
-}
-
-upm_result_t lcdks_set_cursor(const lcdks_context dev, unsigned int row,
-                              unsigned int column)
-{
-    assert(dev != NULL);
-
-    return lcm1602_set_cursor(dev->lcm1602, row, column);
-}
-
-upm_result_t lcdks_clear(const lcdks_context dev)
-{
-    assert(dev != NULL);
-
-    return lcm1602_clear(dev->lcm1602);
-}
-
-upm_result_t lcdks_home(const lcdks_context dev)
-{
-    assert(dev != NULL);
-
-    return lcm1602_home(dev->lcm1602);
-}
-
-upm_result_t lcdks_create_char(const lcdks_context dev,
-                                 unsigned int slot,
-                                 char *data)
-{
-    assert(dev != NULL);
-
-    return lcm1602_create_char(dev->lcm1602, slot, data);
-}
-
-upm_result_t lcdks_display_on(const lcdks_context dev, bool on)
-{
-    assert(dev != NULL);
-
-    return lcm1602_display_on(dev->lcm1602, on);
-}
-
-upm_result_t lcdks_cursor_on(const lcdks_context dev, bool on)
-{
-    assert(dev != NULL);
-
-    return lcm1602_cursor_on(dev->lcm1602, on);
-}
-
-upm_result_t lcdks_cursor_blink_on(const lcdks_context dev, bool on)
-{
-    assert(dev != NULL);
-
-    return lcm1602_cursor_blink_on(dev->lcm1602, on);
-}
-
-upm_result_t lcdks_backlight_on(const lcdks_context dev, bool on)
-{
-    assert(dev != NULL);
-
-    if (dev->gpio)
-    {
-        if (on)
-            mraa_gpio_write(dev->gpio, 1);
-        else
-            mraa_gpio_write(dev->gpio, 0);
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t lcdks_scroll_display_left(const lcdks_context dev)
-{
-    assert(dev != NULL);
-
-    return lcm1602_scroll_display_left(dev->lcm1602);
-}
-
-upm_result_t lcdks_scroll_display_right(const lcdks_context dev)
-{
-    assert(dev != NULL);
-
-    return lcm1602_scroll_display_right(dev->lcm1602);
-}
-
-upm_result_t lcdks_entry_left_to_right(const lcdks_context dev, bool on)
-{
-    assert(dev != NULL);
-
-    return lcm1602_entry_left_to_right(dev->lcm1602, on);
-}
-
-upm_result_t lcdks_autoscroll_on(const lcdks_context dev, bool on)
-{
-    assert(dev != NULL);
-
-    return lcm1602_autoscroll_on(dev->lcm1602, on);
-}
-
-float lcdks_get_key_value(const lcdks_context dev)
-{
-    assert(dev != NULL);
-
-    return mraa_aio_read_float(dev->aio);
-}
diff --git a/src/lcdks/lcdks.cxx b/src/lcdks/lcdks.cxx
deleted file mode 100644
index a4b582a..0000000
--- a/src/lcdks/lcdks.cxx
+++ /dev/null
@@ -1,160 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Based on UPM C++ drivers originally developed by:
- * Author: Daniel Mosquera
- * Copyright (c) 2013 Daniel Mosquera
- *
- * Author: Thomas Ingleby <thomas.c.ingleby@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Contributions: Sergey Kiselev <sergey.kiselev@intel.com>
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string>
-#include <stdexcept>
-#include <unistd.h>
-
-#include "lcdks.hpp"
-
-using namespace upm;
-
-LCDKS::LCDKS(int rs, int enable,
-             int d0, int d1, int d2, int d3,
-             int keypad, int backlight) :
-    m_lcdks(lcdks_init(rs, enable, d0, d1, d2, d3, keypad, backlight))
-
-{
-    if (!m_lcdks)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": lcdks_init failed");
-}
-
-LCDKS::~LCDKS()
-{
-    lcdks_close(m_lcdks);
-}
-
-upm_result_t LCDKS::write(std::string msg)
-{
-    return lcdks_write(m_lcdks, (char *)msg.data(), msg.size());
-}
-
-upm_result_t LCDKS::setCursor(int row, int column)
-{
-    return lcdks_set_cursor(m_lcdks, row, column);
-}
-
-upm_result_t LCDKS::clear()
-{
-    return lcdks_clear(m_lcdks);
-}
-
-upm_result_t LCDKS::home()
-{
-    return lcdks_home(m_lcdks);
-}
-
-upm_result_t LCDKS::createChar(uint8_t charSlot,
-                                   std::vector<uint8_t> charData)
-{
-    return lcdks_create_char(m_lcdks, charSlot,
-                             (char *)charData.data());
-}
-
-upm_result_t LCDKS::displayOn()
-{
-    return lcdks_display_on(m_lcdks, true);
-}
-
-upm_result_t LCDKS::displayOff()
-{
-    return lcdks_display_on(m_lcdks, false);
-}
-
-upm_result_t LCDKS::cursorOn()
-{
-    return lcdks_cursor_on(m_lcdks, true);
-}
-
-upm_result_t LCDKS::cursorOff()
-{
-    return lcdks_cursor_on(m_lcdks, false);
-}
-
-upm_result_t LCDKS::cursorBlinkOn()
-{
-    return lcdks_cursor_blink_on(m_lcdks, true);
-}
-
-upm_result_t LCDKS::cursorBlinkOff()
-{
-    return lcdks_cursor_blink_on(m_lcdks, false);
-}
-
-upm_result_t LCDKS::backlightOn()
-{
-    return lcdks_backlight_on(m_lcdks, true);
-}
-
-upm_result_t LCDKS::backlightOff()
-{
-    return lcdks_backlight_on(m_lcdks, false);
-}
-
-upm_result_t LCDKS::scrollDisplayLeft()
-{
-    return lcdks_scroll_display_left(m_lcdks);
-}
-
-upm_result_t LCDKS::scrollDisplayRight()
-{
-    return lcdks_scroll_display_right(m_lcdks);
-}
-
-upm_result_t LCDKS::entryLeftToRight()
-{
-    return lcdks_entry_left_to_right(m_lcdks, true);
-}
-
-upm_result_t LCDKS::entryRightToLeft()
-{
-    return lcdks_entry_left_to_right(m_lcdks, false);
-}
-
-upm_result_t LCDKS::autoscrollOn()
-{
-    return lcdks_autoscroll_on(m_lcdks, true);
-}
-
-upm_result_t LCDKS::autoscrollOff()
-{
-    return lcdks_autoscroll_on(m_lcdks, false);
-}
-
-float LCDKS::getKeyValue()
-{
-    return lcdks_get_key_value(m_lcdks);
-}
diff --git a/src/lcdks/lcdks.h b/src/lcdks/lcdks.h
deleted file mode 100644
index 37f1a88..0000000
--- a/src/lcdks/lcdks.h
+++ /dev/null
@@ -1,235 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Based on UPM C++ drivers originally developed by:
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <unistd.h>
-#include <stdlib.h>
-#include <stdio.h>
-
-#include <mraa/gpio.h>
-#include <mraa/aio.h>
-
-#include <upm.h>
-#include "lcm1602.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-    /**
-     * @file lcdks.h
-     * @library lcdks
-     * @brief C API for the LCDKS (LCD Keypad Shield) display family
-     *
-     * @include lcdks.c
-     */
-
-    /**
-     * Device context
-     */
-    typedef struct _lcdks_context {
-        // LCM1602 context - does most of the work
-        lcm1602_context lcm1602;
-        // aio context for keypad
-        mraa_aio_context aio;
-        // optional GPIO context for backlight pin
-        mraa_gpio_context gpio;
-    } *lcdks_context;
-
-    /**
-     * LCDKS initialization
-     *
-     * As this is a shield, you will not likely have any choice over
-     * the pins that are used.  For this reason, we provide defaults
-     * for all of them -- of course they can be changed if your device
-     * is different.
-     *
-     * @param rs Register select pin.
-     * @param enable Enable pin.
-     * @param d0 Data 0 pin.
-     * @param d1 Data 1 pin.
-     * @param d2 Data 2 pin.
-     * @param d3 Data 3 pin.
-     * @param keypad Analog pin of the keypad.
-     * @param backlight Optional GPIO backlight pin.  Specify -1 if
-     * not in use or not supported on your device.
-     * @return LCDKS context, or NULL if an error occurs.
-     */
-    lcdks_context lcdks_init(int rs, int enable,
-                             int d0, int d1, int d2, int d3,
-                             int keypad, int backlight);
-
-    /**
-     * LCDKS close.
-     *
-     * @param dev The device context.
-     */
-    void lcdks_close(lcdks_context dev);
-
-    /**
-     * Writes a string to the LCD.
-     *
-     * @param dev The device context.
-     * @param buffer Character buffer containing characters to write to
-     * the display; note: only ASCII characters are supported
-     * @param len The number of characters to write.
-     * @return UPM result.
-     */
-    upm_result_t lcdks_write(const lcdks_context dev, char *buffer,
-                                 int len);
-
-    /**
-     * Sets the cursor to specified coordinates
-     *
-     * @param dev The device context.
-     * @param row Row to set the cursor to.
-     * @param column Column to set the cursor to.
-     * @return UPM result.
-     */
-    upm_result_t lcdks_set_cursor(const lcdks_context dev,
-                                      unsigned int row, unsigned int column);
-
-    /**
-     * Clears the display of all characters.
-     *
-     * @param dev The device context.
-     * @return UPM result.
-     */
-    upm_result_t lcdks_clear(const lcdks_context dev);
-
-    /**
-     * Returns to the home coordinates (0,0).
-     *
-     * @param dev The device context.
-     * @return UPM result.
-     */
-    upm_result_t lcdks_home(const lcdks_context dev);
-
-    /**
-     * Create a custom character.
-     *
-     * @param dev The device context.
-     * @param slot The character slot to write, only 8 are available.
-     * @param data The character data (8 bytes) making up the character.
-     * @return UPM result.
-     */
-    upm_result_t lcdks_create_char(const lcdks_context dev,
-                                       unsigned int slot,
-                                       char *data);
-
-    /**
-     * Turn the display on.
-     *
-     * @param dev The device context.
-     * @param on true to turn display on, false otherwise.
-     * @return UPM result.
-     */
-    upm_result_t lcdks_display_on(const lcdks_context dev, bool on);
-
-    /**
-     * Turn the cursor on.
-     *
-     * @param dev The device context.
-     * @param on true to turn cursor on, false otherwise.
-     * @return UPM result.
-     */
-    upm_result_t lcdks_cursor_on(const lcdks_context dev, bool on);
-
-    /**
-     * Turn cursor blink on.
-     *
-     * @param dev The device context.
-     * @param on true to turn cursor blink on, false otherwise.
-     * @return UPM result.
-     */
-    upm_result_t lcdks_cursor_blink_on(const lcdks_context dev,
-                                           bool on);
-
-    /**
-     * Turn backlight on.
-     *
-     * @param dev The device context.
-     * @param on true to turn backlight on, false otherwise.
-     * @return UPM result.
-     */
-    upm_result_t lcdks_backlight_on(const lcdks_context dev, bool on);
-
-    /**
-     * Scroll the display left, without changing the character RAM.
-     *
-     * @param dev The device context.
-     * @return UPM result.
-     */
-    upm_result_t lcdks_scroll_display_left(const lcdks_context dev);
-
-    /**
-     * Scroll the display right, without changing the character RAM.
-     *
-     * @param dev The device context.
-     * @return UPM result.
-     */
-    upm_result_t lcdks_scroll_display_right(const lcdks_context dev);
-
-    /**
-     * Set the entry mode so that characters are added left to right.
-     *
-     * @param dev The device context.
-     * @param on true to add characters left to right, false for right
-     * to left.
-     * @return UPM result.
-     */
-    upm_result_t lcdks_entry_left_to_right(const lcdks_context dev,
-                                               bool on);
-
-    /**
-     * Right justify text entered from the cursor.
-     *
-     * @param dev The device context.
-     * @param on true right justify text, false to left justify text.
-     * @return UPM result.
-     */
-    upm_result_t lcdks_autoscroll_on(const lcdks_context dev, bool on);
-
-    /**
-     * Returns the floating point representation of the key that is
-     * being pushed.  Each key produces a different value between 0.0
-     * and 1.0, and only one key can be read at a time.
-     *
-     * @param dev The device context.
-     * @return the floating point value representing a key
-     */
-    float lcdks_get_key_value(const lcdks_context dev);
-
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/lcdks/lcdks.hpp b/src/lcdks/lcdks.hpp
deleted file mode 100644
index 0b71e10..0000000
--- a/src/lcdks/lcdks.hpp
+++ /dev/null
@@ -1,275 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Based on UPM C++ drivers originally developed by:
- * Author: Daniel Mosquera
- * Copyright (c) 2013 Daniel Mosquera
- *
- * Author: Thomas Ingleby <thomas.c.ingleby@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Contributions: Sergey Kiselev <sergey.kiselev@intel.com>
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <string>
-#include <vector>
-#include "lcdks.h"
-
-namespace upm
-{
-    /**
-     * @brief LCD Keypad Shield
-     * @defgroup lcdks libupm-lcdks
-     * @ingroup dfrobot sainsmart display
-     */
-
-    /**
-     * @library lcdks
-     * @sensor lcdks
-     * @comname LCD Keypad Shield
-     * @type display
-     * @man sainsmart dfrobot sparkfun
-     * @web http://www.sainsmart.com/sainsmart-1602-lcd-keypad-shield-for-arduino-duemilanove-uno-mega2560-mega1280.html
-     * @web http://www.dfrobot.com/index.php?route=product/product&product_id=51
-     * @web https://www.sparkfun.com/products/13293
-     * @con gpio analog
-     *
-     * @brief API for the generic LCD Keypad Shield
-     *
-     * The LCD Keypad Shield uses 7 digital outputs and 1 analog input
-     * (for the keypad). The outputs are used to drive an attached
-     * LCM1602 LCD controller. This driver should be compatible with
-     * the similar LCD keypad shields from Sainsmart, DFRobot and
-     * Sparkfun.
-     *
-     * @image html keypadlcd.jpg
-     * @snippet lcdks.cxx Interesting
-     */
-
-    class LCDKS
-    {
-    public:
-        /**
-         * LCDKS constructor
-         *
-         * As this is a shield, you will not likely have any choice over
-         * the pins that are used.  For this reason, we provide defaults
-         * for all of them -- of course they can be changed if your device
-         * is different.
-         *
-         * @param rs Register select pin.
-         * @param enable Enable pin.
-         * @param d0 Data 0 pin.
-         * @param d1 Data 1 pin.
-         * @param d2 Data 2 pin.
-         * @param d3 Data 3 pin.
-         * @param keypad Analog pin of the keypad.
-         * @param backlight Optional GPIO backlight pin.  Specify -1 if
-         * not in use or not supported on your device.
-         * @throws std::runtime_error on initialization error.
-         */
-        LCDKS(int rs=8, int enable=9,
-              int d0=4, int d1=5, int d2=6, int d3=7,
-              int keypad=0, int backlight=-1);
-        /**
-         * LCDKS destructor
-         */
-        ~LCDKS();
-
-        /**
-         * Writes a string to the LCD
-         *
-         * @param msg std::string to write to the display; note: only ASCII
-         * characters are supported
-         * @return Result of the operation
-         */
-        upm_result_t write(std::string msg);
-
-        /**
-         * Sets the cursor to specified coordinates
-         *
-         * @param row Row to set the cursor to
-         * @param column Column to set the cursor to
-         * @return Result of the operation
-         */
-        upm_result_t setCursor(int row, int column);
-
-        /**
-         * Clears the display of all characters
-         *
-         * @return Result of the operation
-         */
-        upm_result_t clear();
-
-        /**
-         * Returns to the original coordinates (0,0)
-         *
-         * @return Result of the operation
-         */
-        upm_result_t home();
-
-        /**
-         * Create a custom character
-         *
-         * @param charSlot the character slot to write, only 8 are available
-         * @param charData A vector containing 8 bytes making up the character
-         * @return Result of operation
-         */
-        upm_result_t createChar(uint8_t charSlot,
-                                std::vector<uint8_t> charData);
-
-        /**
-         * Turn the display on
-         *
-         * @return Result of operation
-         */
-        upm_result_t displayOn();
-
-        /**
-         * Turn the display off
-         *
-         * @return Result of operation
-         */
-        upm_result_t displayOff();
-
-        /**
-         * Turn the cursor on
-         *
-         * @return Result of operation
-         */
-        upm_result_t cursorOn();
-
-        /**
-         * Turn the cursor off
-         *
-         * @return Result of operation
-         */
-        upm_result_t cursorOff();
-
-        /**
-         * Turn cursor blink on
-         *
-         * @return Result of operation
-         */
-        upm_result_t cursorBlinkOn();
-
-        /**
-         * Turn cursor blink off
-         *
-         * @return Result of operation
-         */
-        upm_result_t cursorBlinkOff();
-
-        /**
-         * Turn backlight on
-         *
-         * @return Result of operation
-         */
-        upm_result_t backlightOn();
-
-        /**
-         * Turn backlight off
-         *
-         * @return Result of operation
-         */
-        upm_result_t backlightOff();
-
-        /**
-         * Scroll the display left, without changing the character RAM
-         *
-         * @return Result of operation
-         */
-        upm_result_t scrollDisplayLeft();
-
-        /**
-         * Scroll the display right, without changing the character RAM
-         *
-         * @return Result of operation
-         */
-        upm_result_t scrollDisplayRight();
-
-        /**
-         * set the entry mode so that characters are added left to right
-         *
-         * @return Result of operation
-         */
-        upm_result_t entryLeftToRight();
-
-        /**
-         * set the entry mode so that characters are added right to left
-         *
-         * @return Result of operation
-         */
-        upm_result_t entryRightToLeft();
-
-        /**
-         * Right justify text entered from the cursor
-         *
-         * @return Result of operation
-         */
-        upm_result_t autoscrollOn();
-
-        /**
-         * Left justify text entered from the cursor
-         *
-         * @return Result of operation
-         */
-        upm_result_t autoscrollOff();
-
-        /**
-         * Returns the floating point representation of the key that is
-         * being pushed.  Each key produces a different value between 0.0
-         * and 1.0, and only one key can be read at a time.
-         *
-         * @return The floating point value representing a key.
-         */
-        float getKeyValue();
-
-        /**
-         * Returns the floating point representation of the key that is
-         * being pushed.  Each key produces a different value between 0.0
-         * and 1.0, and only one key can be read at a time.
-         *
-         * @deprecated This function is deprecated. Use getKeyValue() instead.
-         * @return The floating point value representing a key.
-         */
-        float getRawKeyValue()
-        {
-            return getKeyValue();
-        }
-
-
-    protected:
-        lcdks_context m_lcdks;
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        LCDKS(const LCDKS&) = delete;
-        LCDKS &operator=(const LCDKS&) = delete;
-
-    };
-}
diff --git a/src/lcdks/lcdks.i b/src/lcdks/lcdks.i
deleted file mode 100644
index 19ea3ce..0000000
--- a/src/lcdks/lcdks.i
+++ /dev/null
@@ -1,29 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "std_vector.i"
-%template(byteVector) std::vector<uint8_t>;
-
-JAVA_JNI_LOADLIBRARY(javaupm_lcdks)
-#endif
-/* END Java syntax */
-
-/* BEGIN Javascript syntax  ------------------------------------------------- */
-#ifdef SWIGJAVASCRIPT
-%include "../upm_vectortypes.i"
-#endif
-/* END Javascript syntax */
-
-/* BEGIN Python syntax  ----------------------------------------------------- */
-#ifdef SWIGPYTHON
-%include "../upm_vectortypes.i"
-#endif
-/* END Python syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "lcdks.hpp"
-%}
-%include "lcdks.hpp"
-/* END Common SWIG syntax */
diff --git a/src/lcdks/lcdks.json b/src/lcdks/lcdks.json
deleted file mode 100644
index f480edc..0000000
--- a/src/lcdks/lcdks.json
+++ /dev/null
@@ -1,36 +0,0 @@
-{
-    "Library": "lcdks",
-    "Description": "API for the generic LCD Keypad Shield",
-    "Sensor Class":
-    {
-        "LCDKS":
-        {
-            "Name": "LCD Keypad Shield",
-            "Description": "The LCD Keypad Shield uses 7 digital outputs and 1 analog input (for the keypad). The outputs are used to drive an attached LCM1602 LCD controller. This driver should be compatible with the similar LCD keypad shields from Sainsmart, DFRobot and Sparkfun.",
-            "Aliases": ["lcdks"],
-            "Categories": ["userinput"],
-            "Connections": ["gpio", "analog"],
-            "Project Type": ["control", "prototyping"],
-            "Manufacturers": ["sainsmart", "dfrobot", "sparkfun"],
-            "Kits": [],
-            "Examples":
-            {
-                "Java": [],
-                "Python": ["lcdks.py"],
-                "Node.js": ["lcdks.js"],
-                "C++": ["lcdks.cxx"],
-                "C": []
-            },
-            "Specifications":
-            {
-                "Operating Voltage": {"unit": "V", "typ": 5}
-            },
-            "Urls" :
-            {
-                "Product Pages": ["https://www.sparkfun.com/products/13293", "http://www.sainsmart.com/sainsmart-1602-lcd-keypad-shield-for-arduino-duemilanove-uno-mega2560-mega1280.html", "http://www.dfrobot.com/index.php?route=product/product&product_id=51"],
-                "Datasheets": ["http://linksprite.com/wiki/index.php5?title=16_X_2_LCD_Keypad_Shield_for_Arduino_V2"],
-                "Schematics": ["https://cdn.sparkfun.com/datasheets/Dev/Arduino/Shields/16X2_LCD_shield.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/lcm1602/CMakeLists.txt b/src/lcm1602/CMakeLists.txt
deleted file mode 100644
index 8bb3cba..0000000
--- a/src/lcm1602/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-upm_mixed_module_init (NAME lcm1602
-    DESCRIPTION "LCD Display Driver for the LCM1602 Controller for HD44780-based Displays"
-    C_HDR lcm1602.h
-    C_SRC lcm1602.c
-    CPP_HDR lcm1602.hpp
-    CPP_SRC lcm1602.cxx
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/lcm1602/hd44780_bits.h b/src/lcm1602/hd44780_bits.h
deleted file mode 100644
index 846c401..0000000
--- a/src/lcm1602/hd44780_bits.h
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-// This file contains bit definitions for the HD44780 and compatible
-// LCD controllers.  It is used primarily my the lcm1602 driver and
-// it's derivatives.
-//
-// Those values (DATA, CMD) are specific to the implementation of the
-// i2C expander in use, so may not be appropriate for inclusion into
-// this file.  But for now, we will leave them here.
-
-#include <stdint.h>
-
-// commands
-const uint8_t HD44780_CLEARDISPLAY = 0x01;
-const uint8_t HD44780_RETURNHOME = 0x02;
-const uint8_t HD44780_ENTRYMODESET = 0x04;
-const uint8_t HD44780_DISPLAYCONTROL = 0x08;
-const uint8_t HD44780_CURSORSHIFT = 0x10;
-const uint8_t HD44780_FUNCTIONSET = 0x20;
-
-// flags for display entry mode
-const uint8_t HD44780_ENTRYRIGHT = 0x00;
-const uint8_t HD44780_ENTRYLEFT = 0x02;
-const uint8_t HD44780_ENTRYSHIFTINCREMENT = 0x01;
-const uint8_t HD44780_ENTRYSHIFTDECREMENT = 0x00;
-
-// flags for display on/off control
-const uint8_t HD44780_DISPLAYON = 0x04;
-const uint8_t HD44780_DISPLAYOFF = 0x00;
-const uint8_t HD44780_CURSORON = 0x02;
-const uint8_t HD44780_CURSOROFF = 0x00;
-const uint8_t HD44780_BLINKON = 0x01;
-const uint8_t HD44780_BLINKOFF = 0x00;
-
-// flags for display/cursor shift
-const uint8_t HD44780_DISPLAYMOVE = 0x08;
-const uint8_t HD44780_MOVERIGHT = 0x04;
-const uint8_t HD44780_MOVELEFT = 0x00;
-
-// flags for function set
-const uint8_t HD44780_8BITMODE = 0x10;
-const uint8_t HD44780_4BITMODE = 0x00;
-const uint8_t HD44780_2LINE = 0x08;
-const uint8_t HD44780_1LINE = 0x00;
-const uint8_t HD44780_5x10DOTS = 0x04;
-const uint8_t HD44780_5x8DOTS = 0x00;
-
-// flags for CGRAM
-const uint8_t HD44780_SETCGRAMADDR = 0x40;
-
-// may be implementation specific
-const uint8_t HD44780_EN = 0x04; // Enable bit
-const uint8_t HD44780_RW = 0x02; // Read/Write bit
-const uint8_t HD44780_RS = 0x01; // Register select bit
-const uint8_t HD44780_DATA = 0x40;
-const uint8_t HD44780_CMD = 0x80;
-
-const uint8_t HD44780_BACKLIGHT = 0x08;
-const uint8_t HD44780_NOBACKLIGHT = 0x00;
diff --git a/src/lcm1602/lcm1602.c b/src/lcm1602/lcm1602.c
deleted file mode 100644
index a8f4dc4..0000000
--- a/src/lcm1602/lcm1602.c
+++ /dev/null
@@ -1,640 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Based on UPM C++ drivers originally developed by:
- * Author: Daniel Mosquera
- * Copyright (c) 2013 Daniel Mosquera
- *
- * Author: Thomas Ingleby <thomas.c.ingleby@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Contributions: Sergey Kiselev <sergey.kiselev@intel.com>
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <assert.h>
-#include <string.h>
-
-#include <upm_utilities.h>
-
-#include "lcm1602.h"
-#include "hd44780_bits.h"
-
-// forward declarations
-static upm_result_t send(const lcm1602_context dev, uint8_t value, int mode);
-static upm_result_t write4bits(const lcm1602_context dev, uint8_t value);
-static upm_result_t expandWrite(const lcm1602_context dev, uint8_t value);
-static upm_result_t pulseEnable(const lcm1602_context dev, uint8_t value);
-
-lcm1602_context lcm1602_i2c_init(int bus, int address, bool is_expander,
-                                 uint8_t num_columns, uint8_t num_rows)
-{
-    lcm1602_context dev =
-        (lcm1602_context)malloc(sizeof(struct _lcm1602_context));
-
-    if (!dev)
-        return NULL;
-
-    memset((void *)dev, 0, sizeof(struct _lcm1602_context));
-
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        lcm1602_close(dev);
-        return NULL;
-    }
-
-    // initialize the MRAA context
-
-    if (!(dev->i2c = mraa_i2c_init(bus)))
-    {
-        printf("%s: mraa_i2c_init failed.\n", __FUNCTION__);
-        lcm1602_close(dev);
-
-        return NULL;
-    }
-
-    // now check the address...
-    if (mraa_i2c_address(dev->i2c, address) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_i2c_address failed.\n", __FUNCTION__);
-
-        lcm1602_close(dev);
-
-        return NULL;
-    }
-
-    dev->isI2C = true;
-    dev->backlight = HD44780_BACKLIGHT;
-    dev->columns = num_columns;
-    dev->rows = num_rows;
-
-    // if we are not dealing with an expander we will only initialize
-    // the I2C context and bail, leaving it up to the caller to handle
-    // further communications (like JHD1313M1)
-
-    if (!is_expander)
-        return dev;
-
-    upm_delay_us(50000);
-    lcm1602_backlight_on(dev, true);
-    upm_delay_us(100000);
-
-    // try to put us into 4 bit mode
-    write4bits(dev, 0x03 << 4);
-    upm_delay_us(4500);
-
-    write4bits(dev, 0x30);
-    upm_delay_us(4500);
-
-    write4bits(dev,0x30);
-    upm_delay_us(150);
-
-    // Put us into 4 bit mode, for realz yo.
-    write4bits(dev, 0x20);
-
-    // Set number of lines
-    lcm1602_command(dev, HD44780_FUNCTIONSET | 0x0f);
-
-    // default display control
-    dev->displayControl = HD44780_DISPLAYON | HD44780_CURSOROFF
-        | HD44780_BLINKOFF;
-
-    lcm1602_command(dev, HD44780_DISPLAYCONTROL | dev->displayControl);
-    upm_delay_us(2000);
-    lcm1602_clear(dev);
-
-    // Set entry mode.
-    dev->entryDisplayMode = HD44780_ENTRYLEFT | HD44780_ENTRYSHIFTDECREMENT;
-    lcm1602_command(dev, HD44780_ENTRYMODESET | dev->entryDisplayMode);
-
-    lcm1602_home(dev);
-
-    return dev;
-}
-
-lcm1602_context lcm1602_gpio_init(int rs, int enable,
-                                  int d0, int d1, int d2,
-                                  int d3, uint8_t num_columns,
-                                  uint8_t num_rows)
-{
-    lcm1602_context dev =
-        (lcm1602_context)malloc(sizeof(struct _lcm1602_context));
-
-    if (!dev)
-        return NULL;
-
-    memset((void *)dev, 0, sizeof(struct _lcm1602_context));
-
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        lcm1602_close(dev);
-        return NULL;
-    }
-
-    // initialize the MRAA contexts
-
-    if (!(dev->gpioRS = mraa_gpio_init(rs)))
-    {
-        printf("%s: mraa_gpio_init(rs) failed.\n", __FUNCTION__);
-        lcm1602_close(dev);
-        return NULL;
-    }
-    mraa_gpio_dir(dev->gpioRS, MRAA_GPIO_OUT);
-
-    if (!(dev->gpioEN = mraa_gpio_init(enable)))
-    {
-        printf("%s: mraa_gpio_init(enable) failed.\n", __FUNCTION__);
-        lcm1602_close(dev);
-        return NULL;
-    }
-    mraa_gpio_dir(dev->gpioEN, MRAA_GPIO_OUT);
-
-    if (!(dev->gpioD0 = mraa_gpio_init(d0)))
-    {
-        printf("%s: mraa_gpio_init(d0) failed.\n", __FUNCTION__);
-        lcm1602_close(dev);
-        return NULL;
-    }
-    mraa_gpio_dir(dev->gpioD0, MRAA_GPIO_OUT);
-
-    if (!(dev->gpioD1 = mraa_gpio_init(d1)))
-    {
-        printf("%s: mraa_gpio_init(d1) failed.\n", __FUNCTION__);
-        lcm1602_close(dev);
-        return NULL;
-    }
-    mraa_gpio_dir(dev->gpioD1, MRAA_GPIO_OUT);
-
-    if (!(dev->gpioD2 = mraa_gpio_init(d2)))
-    {
-        printf("%s: mraa_gpio_init(d2) failed.\n", __FUNCTION__);
-        lcm1602_close(dev);
-        return NULL;
-    }
-    mraa_gpio_dir(dev->gpioD2, MRAA_GPIO_OUT);
-
-    if (!(dev->gpioD3 = mraa_gpio_init(d3)))
-    {
-        printf("%s: mraa_gpio_init(d3) failed.\n", __FUNCTION__);
-        lcm1602_close(dev);
-        return NULL;
-    }
-    mraa_gpio_dir(dev->gpioD3, MRAA_GPIO_OUT);
-
-    dev->isI2C = false;
-    // no backlight for GPIO
-    dev->backlight = 0;
-    dev->columns = num_columns;
-    dev->rows = num_rows;
-
-    // set RS and Enable low to begin issuing commands
-    mraa_gpio_write(dev->gpioRS, 0);
-    mraa_gpio_write(dev->gpioEN, 0);
-
-    // wait to stabilize
-    upm_delay_us(100000);
-
-    // set 4bit mode
-
-    // These steps are adapted from the HD44780 datasheet, figure 24
-
-    // try 1
-    write4bits(dev, 0x03);
-    upm_delay_us(4500);
-
-    // try 2
-    write4bits(dev, 0x03);
-    upm_delay_us(4500);
-
-    // try 3
-    write4bits(dev, 0x03);
-    upm_delay_us(150);
-
-    // Finally, put into 4 bit mode
-    write4bits(dev, 0x02);
-
-    // Set number of lines
-    lcm1602_command(dev, HD44780_FUNCTIONSET | HD44780_2LINE | HD44780_4BITMODE
-                    | HD44780_5x8DOTS);
-
-
-    dev->displayControl = HD44780_DISPLAYON | HD44780_CURSOROFF
-        | HD44780_BLINKOFF;
-    lcm1602_command(dev, HD44780_DISPLAYCONTROL | dev->displayControl);
-    upm_delay_us(2000);
-    lcm1602_clear(dev);
-
-    // Set entry mode.
-    dev->entryDisplayMode = HD44780_ENTRYLEFT | HD44780_ENTRYSHIFTDECREMENT;
-    lcm1602_command(dev, HD44780_ENTRYMODESET | dev->entryDisplayMode);
-
-    lcm1602_home(dev);
-
-    return dev;
-}
-
-void lcm1602_close(lcm1602_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->i2c)
-        mraa_i2c_stop(dev->i2c);
-
-    if (dev->gpioRS)
-        mraa_gpio_close(dev->gpioRS);
-    if (dev->gpioEN)
-        mraa_gpio_close(dev->gpioEN);
-    if (dev->gpioD0)
-        mraa_gpio_close(dev->gpioD0);
-    if (dev->gpioD1)
-        mraa_gpio_close(dev->gpioD1);
-    if (dev->gpioD2)
-        mraa_gpio_close(dev->gpioD2);
-    if (dev->gpioD3)
-        mraa_gpio_close(dev->gpioD3);
-
-    free(dev);
-}
-
-upm_result_t lcm1602_write(const lcm1602_context dev, char *buffer,
-                           int len)
-{
-    assert(dev != NULL);
-
-    upm_result_t error = UPM_SUCCESS;
-
-    int i;
-    for (i=0; i<len; ++i)
-        error = lcm1602_data(dev, buffer[i]);
-
-    return error;
-}
-
-upm_result_t lcm1602_set_cursor(const lcm1602_context dev, unsigned int row,
-                                unsigned int column)
-{
-    assert(dev != NULL);
-
-    column = column % dev->columns;
-    uint8_t offset = column;
-
-    switch (dev->rows)
-    {
-    case 1:
-        // Single row displays with more than 8 columns usually have their
-        // DDRAM split in two halves. The first half starts at address 00.
-        // The second half starts at address 40. E.g. 16x2 DDRAM mapping:
-        // 00 01 02 03 04 05 06 07 40 41 42 43 44 45 46 47
-        if (dev->columns > 8)
-        {
-            offset = (column % (dev->columns / 2)) +
-                (column / (dev->columns / 2)) * 0x40;
-        }
-        break;
-
-    case 2:
-        // this should work for any display with two rows
-        // DDRAM mapping:
-        // 00 .. 27
-        // 40 .. 67
-        offset += row * 0x40;
-        break;
-
-    case 4:
-        if (dev->columns == 16)
-        {
-            // 16x4 display
-            // DDRAM mapping:
-            // 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
-            // 40 41 42 43 43 45 46 47 48 49 4A 4B 4C 4D 4E 4F
-            // 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F
-            // 50 51 52 53 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F
-            int row_addr[] = { 0x00, 0x40, 0x10, 0x50 };
-            offset += row_addr[row];
-        }
-        else
-        {
-            // 20x4 display
-            // DDRAM mapping:
-            // 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13
-            // 40 41 42 43 43 45 46 47 48 49 4A 4B 4C 4D 4E 4F 50 51 52 53
-            // 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F 20 21 22 23 24 25 26 27
-            // 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F 60 61 62 63 64 65 66 67
-            int row_addr[] = { 0x00, 0x40, 0x14, 0x54 };
-            offset += row_addr[row];
-        }
-        break;
-    }
-
-    return lcm1602_command(dev, HD44780_CMD | offset);
-}
-
-upm_result_t lcm1602_clear(const lcm1602_context dev)
-{
-    assert(dev != NULL);
-
-    upm_result_t ret;
-    ret = lcm1602_command(dev, HD44780_CLEARDISPLAY);
-    upm_delay_us(2000); // this command takes awhile
-    return ret;
-}
-
-upm_result_t lcm1602_home(const lcm1602_context dev)
-{
-    assert(dev != NULL);
-
-    upm_result_t ret;
-    ret = lcm1602_command(dev, HD44780_RETURNHOME);
-    upm_delay_us(2000); // this command takes awhile
-    return ret;
-}
-
-upm_result_t lcm1602_create_char(const lcm1602_context dev,
-                                 unsigned int slot,
-                                 char *data)
-{
-    assert(dev != NULL);
-
-    upm_result_t error = UPM_SUCCESS;
-
-    slot &= 0x07; // only have 8 positions we can set
-
-    error = lcm1602_command(dev, HD44780_SETCGRAMADDR | (slot << 3));
-
-    if (error == UPM_SUCCESS)
-    {
-        int i;
-        for (i = 0; i < 8; i++) {
-            error = lcm1602_data(dev, data[i]);
-        }
-    }
-
-    return error;
-}
-
-upm_result_t lcm1602_display_on(const lcm1602_context dev, bool on)
-{
-    assert(dev != NULL);
-
-    if (on)
-        dev->displayControl |= HD44780_DISPLAYON;
-    else
-        dev->displayControl &= ~HD44780_DISPLAYON;
-
-    return lcm1602_command(dev, HD44780_DISPLAYCONTROL | dev->displayControl);
-}
-
-upm_result_t lcm1602_cursor_on(const lcm1602_context dev, bool on)
-{
-    assert(dev != NULL);
-
-    if (on)
-        dev->displayControl |= HD44780_CURSORON;
-    else
-        dev->displayControl &= ~HD44780_CURSORON;
-
-    return lcm1602_command(dev, HD44780_DISPLAYCONTROL | dev->displayControl);
-}
-
-upm_result_t lcm1602_cursor_blink_on(const lcm1602_context dev, bool on)
-{
-    assert(dev != NULL);
-
-    if (on)
-        dev->displayControl |= HD44780_BLINKON;
-    else
-        dev->displayControl &= ~HD44780_BLINKON;
-
-    return lcm1602_command(dev, HD44780_DISPLAYCONTROL | dev->displayControl);
-}
-
-upm_result_t lcm1602_backlight_on(const lcm1602_context dev, bool on)
-{
-    assert(dev != NULL);
-
-    if (on)
-        dev->backlight = HD44780_BACKLIGHT;
-    else
-        dev->backlight = HD44780_NOBACKLIGHT;
-
-    return expandWrite(dev, dev->backlight);
-}
-
-upm_result_t lcm1602_scroll_display_left(const lcm1602_context dev)
-{
-    assert(dev != NULL);
-
-    return lcm1602_command(dev, HD44780_CURSORSHIFT | HD44780_DISPLAYMOVE
-                           | HD44780_MOVELEFT);
-}
-
-upm_result_t lcm1602_scroll_display_right(const lcm1602_context dev)
-{
-    assert(dev != NULL);
-
-    return lcm1602_command(dev, HD44780_CURSORSHIFT | HD44780_DISPLAYMOVE
-                           | HD44780_MOVERIGHT);
-}
-
-upm_result_t lcm1602_entry_left_to_right(const lcm1602_context dev, bool on)
-{
-    assert(dev != NULL);
-
-    if (on)
-        dev->entryDisplayMode |= HD44780_ENTRYLEFT;
-    else
-        dev->entryDisplayMode &= ~HD44780_ENTRYLEFT;
-
-    return lcm1602_command(dev, HD44780_ENTRYMODESET | dev->entryDisplayMode);
-}
-
-upm_result_t lcm1602_autoscroll_on(const lcm1602_context dev, bool on)
-{
-    assert(dev != NULL);
-
-    if (on)
-        dev->entryDisplayMode |= HD44780_ENTRYSHIFTINCREMENT;
-    else
-        dev->entryDisplayMode &= ~HD44780_ENTRYSHIFTINCREMENT;
-
-    return lcm1602_command(dev, HD44780_ENTRYMODESET | dev->entryDisplayMode);
-}
-
-upm_result_t lcm1602_command(const lcm1602_context dev, uint8_t cmd)
-{
-    assert(dev != NULL);
-
-    return send(dev, cmd, 0);
-}
-
-upm_result_t lcm1602_data(const lcm1602_context dev, uint8_t cmd)
-{
-    assert(dev != NULL);
-    return send(dev, cmd, HD44780_RS); // 1
-}
-
-
-// static declarations
-static upm_result_t send(const lcm1602_context dev, uint8_t value,
-                         int mode)
-{
-    assert(dev != NULL);
-
-    uint8_t h;
-    uint8_t l;
-
-    upm_result_t rv = UPM_SUCCESS;
-
-    if (dev->isI2C)
-    {
-        h = value & 0xf0;
-        l = (value << 4) & 0xf0;
-        if (write4bits(dev, h | mode))
-            rv = UPM_ERROR_OPERATION_FAILED;
-        if (write4bits(dev, l | mode))
-            rv = UPM_ERROR_OPERATION_FAILED;
-
-        return rv;
-    }
-
-    // else, gpio (4 bit)
-
-    // register select
-    if (mraa_gpio_write(dev->gpioRS, mode))
-    {
-        printf("%s: mraa_gpio_write() failed\n", __FUNCTION__);
-        rv = UPM_ERROR_OPERATION_FAILED;
-    }
-
-    h = value >> 4;
-    l = value & 0x0f;
-
-    if (write4bits(dev, h))
-        rv = UPM_ERROR_OPERATION_FAILED;
-    if (write4bits(dev, l))
-        rv = UPM_ERROR_OPERATION_FAILED;
-
-    return rv;
-}
-
-static upm_result_t write4bits(const lcm1602_context dev,
-                               uint8_t value)
-{
-    assert(dev != NULL);
-
-    upm_result_t rv = UPM_SUCCESS;
-
-    if (dev->isI2C)
-    {
-        if (expandWrite(dev, value))
-            rv = UPM_ERROR_OPERATION_FAILED;
-        if (pulseEnable(dev, value))
-            rv = UPM_ERROR_OPERATION_FAILED;
-
-        return rv;
-    }
-
-    // else gpio
-    mraa_result_t mrv = MRAA_SUCCESS;
-    mrv = mraa_gpio_write(dev->gpioD0, ((value >> 0) & 0x01) );
-    mrv = mraa_gpio_write(dev->gpioD1, ((value >> 1) & 0x01) );
-    mrv = mraa_gpio_write(dev->gpioD2, ((value >> 2) & 0x01) );
-    mrv = mraa_gpio_write(dev->gpioD3, ((value >> 3) & 0x01) );
-
-    if (mrv)
-    {
-        printf("%s: mraa_gpio_write() failed\n", __FUNCTION__);
-        rv = UPM_ERROR_OPERATION_FAILED;
-    }
-
-    if (pulseEnable(dev, value)) // value is ignored here for gpio
-    {
-        printf("%s: pulseEnable() failed\n", __FUNCTION__);
-        rv = UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return rv;
-}
-
-static upm_result_t expandWrite(const lcm1602_context dev,
-                               uint8_t value)
-{
-    assert(dev != NULL);
-
-    // invalid for gpio
-    if (!dev->isI2C)
-        return UPM_ERROR_NO_RESOURCES;
-
-    uint8_t buffer = value | dev->backlight;
-
-    if (mraa_i2c_write_byte(dev->i2c, buffer))
-    {
-        printf("%s: mraa_i2c_write_byte() failed\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-static upm_result_t pulseEnable(const lcm1602_context dev,
-                                uint8_t value)
-{
-    assert(dev != NULL);
-
-    upm_result_t rv = UPM_SUCCESS;
-
-    if (dev->isI2C)
-    {
-        if (expandWrite(dev, value | HD44780_EN))
-            rv = UPM_ERROR_OPERATION_FAILED;
-        upm_delay_us(1);
-
-        if (expandWrite(dev, value & ~HD44780_EN))
-            rv = UPM_ERROR_OPERATION_FAILED;
-
-        upm_delay_us(50);
-        return rv;
-    }
-
-    // else gpio
-
-    mraa_result_t mrv = MRAA_SUCCESS;
-    mrv = mraa_gpio_write(dev->gpioEN, 1);
-    upm_delay_us(1); // must be > 450ns
-    mrv = mraa_gpio_write(dev->gpioEN, 0);
-    upm_delay_us(100); // must be >37us
-
-    if (mrv)
-    {
-        printf("%s: mraa_gpio_write() failed\n", __FUNCTION__);
-        rv = UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return rv;
-}
diff --git a/src/lcm1602/lcm1602.cxx b/src/lcm1602/lcm1602.cxx
deleted file mode 100644
index 26a94af..0000000
--- a/src/lcm1602/lcm1602.cxx
+++ /dev/null
@@ -1,172 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Based on UPM C++ drivers originally developed by:
- * Author: Daniel Mosquera
- * Copyright (c) 2013 Daniel Mosquera
- *
- * Author: Thomas Ingleby <thomas.c.ingleby@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Contributions: Sergey Kiselev <sergey.kiselev@intel.com>
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string>
-#include <stdexcept>
-#include <unistd.h>
-
-#include "lcm1602.hpp"
-
-using namespace upm;
-
-Lcm1602::Lcm1602(int bus_in, int addr_in, bool isExpander,
-                 uint8_t numColumns, uint8_t numRows) :
-    m_lcm1602(lcm1602_i2c_init(bus_in, addr_in, isExpander, numColumns,
-                               numRows))
-{
-    if (!m_lcm1602)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": lcm1602_i2c_init failed");
-}
-
-Lcm1602::Lcm1602(int rs,  int enable, int d0,
-                 int d1, int d2, int d3,
-                 uint8_t numColumns, uint8_t numRows) :
-    m_lcm1602(lcm1602_gpio_init(rs, enable, d0, d1, d2, d3, numColumns,
-                                numRows))
-{
-    if (!m_lcm1602)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": lcm1602_gpio_init failed");
-}
-
-Lcm1602::~Lcm1602()
-{
-    lcm1602_close(m_lcm1602);
-}
-
-upm_result_t Lcm1602::write(std::string msg)
-{
-    return lcm1602_write(m_lcm1602, (char *)msg.data(), msg.size());
-}
-
-upm_result_t Lcm1602::setCursor(int row, int column)
-{
-    return lcm1602_set_cursor(m_lcm1602, row, column);
-}
-
-upm_result_t Lcm1602::clear()
-{
-    return lcm1602_clear(m_lcm1602);
-}
-
-upm_result_t Lcm1602::home()
-{
-    return lcm1602_home(m_lcm1602);
-}
-
-upm_result_t Lcm1602::createChar(uint8_t charSlot,
-                                 std::vector<uint8_t> charData)
-{
-    return lcm1602_create_char(m_lcm1602, charSlot, (char *)charData.data());
-}
-
-upm_result_t Lcm1602::displayOn()
-{
-    return lcm1602_display_on(m_lcm1602, true);
-}
-
-upm_result_t Lcm1602::displayOff()
-{
-    return lcm1602_display_on(m_lcm1602, false);
-}
-
-upm_result_t Lcm1602::cursorOn()
-{
-    return lcm1602_cursor_on(m_lcm1602, true);
-}
-
-upm_result_t Lcm1602::cursorOff()
-{
-    return lcm1602_cursor_on(m_lcm1602, false);
-}
-
-upm_result_t Lcm1602::cursorBlinkOn()
-{
-    return lcm1602_cursor_blink_on(m_lcm1602, true);
-}
-
-upm_result_t Lcm1602::cursorBlinkOff()
-{
-    return lcm1602_cursor_blink_on(m_lcm1602, false);
-}
-
-upm_result_t Lcm1602::backlightOn()
-{
-    return lcm1602_backlight_on(m_lcm1602, true);
-}
-
-upm_result_t Lcm1602::backlightOff()
-{
-    return lcm1602_backlight_on(m_lcm1602, false);
-}
-
-upm_result_t Lcm1602::scrollDisplayLeft()
-{
-    return lcm1602_scroll_display_left(m_lcm1602);
-}
-
-upm_result_t Lcm1602::scrollDisplayRight()
-{
-    return lcm1602_scroll_display_right(m_lcm1602);
-}
-
-upm_result_t Lcm1602::entryLeftToRight()
-{
-    return lcm1602_entry_left_to_right(m_lcm1602, true);
-}
-
-upm_result_t Lcm1602::entryRightToLeft()
-{
-    return lcm1602_entry_left_to_right(m_lcm1602, false);
-}
-
-upm_result_t Lcm1602::autoscrollOn()
-{
-    return lcm1602_autoscroll_on(m_lcm1602, true);
-}
-
-upm_result_t Lcm1602::autoscrollOff()
-{
-    return lcm1602_autoscroll_on(m_lcm1602, false);
-}
-
-upm_result_t Lcm1602::command(uint8_t cmd)
-{
-    return lcm1602_command(m_lcm1602, cmd);
-}
-
-upm_result_t Lcm1602::data(uint8_t data)
-{
-    return lcm1602_data(m_lcm1602, data);
-}
diff --git a/src/lcm1602/lcm1602.h b/src/lcm1602/lcm1602.h
deleted file mode 100644
index 14741ae..0000000
--- a/src/lcm1602/lcm1602.h
+++ /dev/null
@@ -1,278 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Based on UPM C++ drivers originally developed by:
- * Author: Daniel Mosquera
- * Copyright (c) 2013 Daniel Mosquera
- *
- * Author: Thomas Ingleby <thomas.c.ingleby@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Contributions: Sergey Kiselev <sergey.kiselev@intel.com>
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <upm.h>
-
-#include <mraa/i2c.h>
-#include <mraa/gpio.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-    /**
-     * @file lcm1602.h
-     * @library lcm1602
-     * @brief C API for the LCM1602 family of LCD displays
-     *
-     * @include lcm1602.c
-     */
-
-    /**
-     * Device context
-     */
-    typedef struct _lcm1602_context {
-        // A large number of GPIOs
-        mraa_gpio_context        gpioRS;
-        mraa_gpio_context        gpioEN;
-        mraa_gpio_context        gpioD0;
-        mraa_gpio_context        gpioD1;
-        mraa_gpio_context        gpioD2;
-        mraa_gpio_context        gpioD3;
-
-        // I2C command control
-        mraa_i2c_context         i2c;
-
-        // what interface are we using?
-        bool                     isI2C;
-
-        // configuration
-        unsigned int             columns;
-        unsigned int             rows;
-
-        // display command
-        uint8_t                  displayControl;
-        uint8_t                  entryDisplayMode;
-        uint8_t                  backlight;
-    } *lcm1602_context;
-
-    /**
-     * LCM1602 I2C initialization.  This is used for those devices
-     * using an I2C expander, or other I2C interface.  If you are
-     * using an expander, you must specify true for the is_expander
-     * argument.  If not, then the caller of this function is
-     * responsible for any transfers to the I2C device.  Internally,
-     * only direct access to an I2C expander is supported.
-     *
-     * @param bus I2C bus to use.
-     * @param address I2C address the LCD is configured for.
-     * @param is_expander True if we are dealing with an I2C expander,
-     * false otherwise.
-     * @param num_columns Number of columns the display has.
-     * @param num_rows Number of rows the display has.
-     * @return Device Ccontext, or NULL on error.
-     */
-    lcm1602_context lcm1602_i2c_init(int bus, int address, bool is_expander,
-                                     uint8_t num_columns, uint8_t num_rows);
-
-    /**
-     * LCM1602 GPIO (parallel) initialization, used for GPIO based
-     * HD44780 controllers supporting RS, Enable, and 4 data pins in
-     * 4-bit mode.
-     *
-     * @param rs Register select pin
-     * @param enable Enable pin
-     * @param d0 Data 0 pin
-     * @param d1 Data 1 pin
-     * @param d2 Data 2 pin
-     * @param d3 Data 3 pin
-     * @param num_columns Number of columns the display has. Default 16.
-     * @param num_rows Number of rows the display has. Default 2.
-     * @return Device Ccontext, or NULL on error.
-     */
-    lcm1602_context lcm1602_gpio_init(int rs, int enable,
-                                      int d0, int d1, int d2,
-                                      int d3, uint8_t num_columns,
-                                      uint8_t num_rows);
-
-    /**
-     * LCM1602 close.
-     *
-     * @param dev The device context.
-     */
-    void lcm1602_close(lcm1602_context dev);
-
-    /**
-     * Writes a string to the LCD.
-     *
-     * @param dev The device context.
-     * @param buffer Character buffer containing characters to write to
-     * the display; note: only ASCII characters are supported
-     * @param len The number of characters to write.
-     * @return UPM result.
-     */
-    upm_result_t lcm1602_write(const lcm1602_context dev, char *buffer,
-                               int len);
-
-    /**
-     * Sets the cursor to specified coordinates
-     *
-     * @param dev The device context.
-     * @param row Row to set the cursor to.
-     * @param column Column to set the cursor to.
-     * @return UPM result.
-     */
-    upm_result_t lcm1602_set_cursor(const lcm1602_context dev,
-                                    unsigned int row, unsigned int column);
-
-    /**
-     * Clears the display of all characters.
-     *
-     * @param dev The device context.
-     * @return UPM result.
-     */
-    upm_result_t lcm1602_clear(const lcm1602_context dev);
-
-    /**
-     * Returns to the home coordinates (0,0).
-     *
-     * @param dev The device context.
-     * @return UPM result.
-     */
-    upm_result_t lcm1602_home(const lcm1602_context dev);
-
-    /**
-     * Create a custom character.
-     *
-     * @param dev The device context.
-     * @param slot The character slot to write, only 8 are available.
-     * @param data The character data (8 bytes) making up the character.
-     * @return UPM result.
-     */
-    upm_result_t lcm1602_create_char(const lcm1602_context dev,
-                                     unsigned int slot,
-                                     char *data);
-
-    /**
-     * Turn the display on.
-     *
-     * @param dev The device context.
-     * @param on true to turn display on, false otherwise.
-     * @return UPM result.
-     */
-    upm_result_t lcm1602_display_on(const lcm1602_context dev, bool on);
-
-    /**
-     * Turn the cursor on.
-     *
-     * @param dev The device context.
-     * @param on true to turn cursor on, false otherwise.
-     * @return UPM result.
-     */
-    upm_result_t lcm1602_cursor_on(const lcm1602_context dev, bool on);
-
-    /**
-     * Turn cursor blink on.
-     *
-     * @param dev The device context.
-     * @param on true to turn cursor blink on, false otherwise.
-     * @return UPM result.
-     */
-    upm_result_t lcm1602_cursor_blink_on(const lcm1602_context dev, bool on);
-
-    /**
-     * Turn backlight on.
-     *
-     * @param dev The device context.
-     * @param on true to turn backlight on, false otherwise.
-     * @return UPM result.
-     */
-    upm_result_t lcm1602_backlight_on(const lcm1602_context dev, bool on);
-
-    /**
-     * Scroll the display left, without changing the character RAM.
-     *
-     * @param dev The device context.
-     * @return UPM result.
-     */
-    upm_result_t lcm1602_scroll_display_left(const lcm1602_context dev);
-
-    /**
-     * Scroll the display right, without changing the character RAM.
-     *
-     * @param dev The device context.
-     * @return UPM result.
-     */
-    upm_result_t lcm1602_scroll_display_right(const lcm1602_context dev);
-
-    /**
-     * Set the entry mode so that characters are added left to right.
-     *
-     * @param dev The device context.
-     * @param on true to add characters left to right, false for right
-     * to left.
-     * @return UPM result.
-     */
-    upm_result_t lcm1602_entry_left_to_right(const lcm1602_context dev,
-                                             bool on);
-
-    /**
-     * Right justify text entered from the cursor.
-     *
-     * @param dev The device context.
-     * @param on true right justify text, false to left justify text.
-     * @return UPM result.
-     */
-    upm_result_t lcm1602_autoscroll_on(const lcm1602_context dev, bool on);
-
-    /**
-     * Send a command byte to the controller.  This is a low level
-     * command and should not be used unless you know what you are
-     * doing.
-     *
-     * @param dev The device context.
-     * @param cmd The command byte to send.
-     * @return UPM result.
-     */
-    upm_result_t lcm1602_command(const lcm1602_context dev, uint8_t cmd);
-
-    /**
-     * Send a data byte to the controller.  This is a low level
-     * command and should not be used unless you know what you are
-     * doing.
-     *
-     * @param dev The device context.
-     * @param data The data byte to send.
-     * @return UPM result.
-     */
-    upm_result_t lcm1602_data(const lcm1602_context dev, uint8_t data);
-
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/lcm1602/lcm1602.hpp b/src/lcm1602/lcm1602.hpp
deleted file mode 100644
index a7f178f..0000000
--- a/src/lcm1602/lcm1602.hpp
+++ /dev/null
@@ -1,263 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Based on UPM C++ drivers originally developed by:
- * Author: Daniel Mosquera
- * Copyright (c) 2013 Daniel Mosquera
- *
- * Author: Thomas Ingleby <thomas.c.ingleby@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Contributions: Sergey Kiselev <sergey.kiselev@intel.com>
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <string>
-#include <vector>
-#include "lcm1602.h"
-
-namespace upm
-{
-/**
- * @brief LCM1602 Display Controller
- * @defgroup lcm1602 libupm-lcm1602
- * @ingroup dfrobot sainsmart seeed sparkfun adafruit i2c gpio display
- */
-
-/**
- * @library lcm1602
- * @sensor lcm1602
- * @comname LCD Display Driver for the LCM1602 Controller for HD44780-based Displays
- * @type display
- * @man adafruit sparkfun seeed
- * @web https://www.adafruit.com/datasheets/TC1602A-01T.pdf
- * @con i2c gpio
- *
- * @brief API for the LCM1602 I2C controller for HD44780-based displays
- *
- * This supports all sizes of HD44780 displays, from 16x2 to 4x20. The
- * controller has no idea of the actual display hardware, so it lets you write
- * farther than you can see. These displays with such controllers are available
- * from various manufacturers with different I2C addresses. Adafruit*
- * TC1602A-01T seems to be a well-documented example. The driver also supports
- * parallel GPIO connections directly to the HD44780 in case you are not using
- * an I2C expander/backpack.
- *
- * @image html lcm1602.jpeg
- * Example for LCM1602 displays that use the I2C bus
- * @snippet lcm1602-i2c.cxx Interesting
- * Code sample for GPIO based LCM1602 displays
- * @snippet lcm1602-parallel.cxx Interesting
- */
-    class Lcm1602
-    {
-    public:
-        /**
-         * Lcm1602 constructor; calls libmraa initialisation functions
-         *
-         * @param bus I2C bus to use. Default 0 (autodetect).
-         * @param address Slave address the LCD is registered on. Default 0x27
-         * @param isExpander True if we are dealing with an I2C expander,
-         * false otherwise. Default is true.
-         * @param numColumns Number of columns the display has. Default 16.
-         * @param numRows Number of rows the display has. Default 2.
-         */
-        Lcm1602(int bus = 0, int address = 0x27, bool isExpander=true,
-                uint8_t numColumns = 16, uint8_t numRows = 2);
-
-        /**
-         * Lcm1602 alternate constructor, used for GPIO based HD44780
-         * controllers supporting RS, Enable, and 4 data pins in 4-bit
-         * mode.
-         *
-         * @param rs Register select pin
-         * @param enable Enable pin
-         * @param d0 Data 0 pin
-         * @param d1 Data 1 pin
-         * @param d2 Data 2 pin
-         * @param d3 Data 3 pin
-         * @param numColumns Number of columns the display has. Default 16.
-         * @param numRows Number of rows the display has. Default 2.
-         */
-        Lcm1602(int rs,  int enable,
-                int d0, int d1, int d2, int d3,
-                uint8_t numColumns = 16, uint8_t numRows = 2);
-
-        /**
-         * Lcm1602 destructor
-         */
-        ~Lcm1602();
-
-        /**
-         * Writes a string to the LCD
-         *
-         * @param msg std::string to write to the display; note: only ASCII
-         * characters are supported
-         * @return Result of the operation
-         */
-        upm_result_t write(std::string msg);
-
-        /**
-         * Sets the cursor to specified coordinates
-         *
-         * @param row Row to set the cursor to
-         * @param column Column to set the cursor to
-         * @return Result of the operation
-         */
-        upm_result_t setCursor(int row, int column);
-
-        /**
-         * Clears the display of all characters
-         *
-         * @return Result of the operation
-         */
-        upm_result_t clear();
-
-        /**
-         * Returns to the original coordinates (0,0)
-         *
-         * @return Result of the operation
-         */
-        upm_result_t home();
-
-        /**
-         * Create a custom character
-         *
-         * @param charSlot the character slot to write, only 8 are available
-         * @param charData A vector containing 8 bytes making up the character
-         * @return Result of operation
-         */
-        upm_result_t createChar(uint8_t charSlot,
-                                std::vector<uint8_t> charData);
-
-        /**
-         * Turn the display on
-         *
-         * @return Result of operation
-         */
-        upm_result_t displayOn();
-
-        /**
-         * Turn the display off
-         *
-         * @return Result of operation
-         */
-        upm_result_t displayOff();
-
-        /**
-         * Turn the cursor on
-         *
-         * @return Result of operation
-         */
-        upm_result_t cursorOn();
-
-        /**
-         * Turn the cursor off
-         *
-         * @return Result of operation
-         */
-        upm_result_t cursorOff();
-
-        /**
-         * Turn cursor blink on
-         *
-         * @return Result of operation
-         */
-        upm_result_t cursorBlinkOn();
-
-        /**
-         * Turn cursor blink off
-         *
-         * @return Result of operation
-         */
-        upm_result_t cursorBlinkOff();
-
-        /**
-        * Turn backlight on
-        *
-        * @return Result of operation
-        */
-        upm_result_t backlightOn();
-
-        /**
-         * Turn backlight off
-         *
-         * @return Result of operation
-         */
-        upm_result_t backlightOff();
-
-        /**
-         * Scroll the display left, without changing the character RAM
-         *
-         * @return Result of operation
-         */
-        upm_result_t scrollDisplayLeft();
-
-        /**
-         * Scroll the display right, without changing the character RAM
-         *
-         * @return Result of operation
-         */
-        upm_result_t scrollDisplayRight();
-
-        /**
-         * set the entry mode so that characters are added left to right
-         *
-         * @return Result of operation
-         */
-        upm_result_t entryLeftToRight();
-
-        /**
-         * set the entry mode so that characters are added right to left
-         *
-         * @return Result of operation
-         */
-        upm_result_t entryRightToLeft();
-
-        /**
-         * Right justify text entered from the cursor
-         *
-         * @return Result of operation
-         */
-        upm_result_t autoscrollOn();
-
-        /**
-         * Left justify text entered from the cursor
-         *
-         * @return Result of operation
-         */
-        upm_result_t autoscrollOff();
-
-
-    protected:
-        lcm1602_context m_lcm1602;
-        upm_result_t command(uint8_t cmd);
-        upm_result_t data(uint8_t data);
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        Lcm1602(const Lcm1602&) = delete;
-        Lcm1602 &operator=(const Lcm1602&) = delete;
-    };
-}
diff --git a/src/lcm1602/lcm1602.i b/src/lcm1602/lcm1602.i
deleted file mode 100644
index 4312490..0000000
--- a/src/lcm1602/lcm1602.i
+++ /dev/null
@@ -1,29 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "std_vector.i"
-%template(byteVector) std::vector<uint8_t>;
-
-JAVA_JNI_LOADLIBRARY(javaupm_lcm1602)
-#endif
-/* END Java syntax */
-
-/* BEGIN Javascript syntax  ------------------------------------------------- */
-#ifdef SWIGJAVASCRIPT
-%include "../upm_vectortypes.i"
-#endif
-/* END Javascript syntax */
-
-/* BEGIN Python syntax  ----------------------------------------------------- */
-#ifdef SWIGPYTHON
-%include "../upm_vectortypes.i"
-#endif
-/* END Python syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "lcm1602.hpp"
-%}
-%include "lcm1602.hpp"
-/* END Common SWIG syntax */
diff --git a/src/lcm1602/lcm1602.json b/src/lcm1602/lcm1602.json
deleted file mode 100644
index ddb01bb..0000000
--- a/src/lcm1602/lcm1602.json
+++ /dev/null
@@ -1,37 +0,0 @@
-{
-    "Library": "lcm1602",
-    "Description": "API for the LCM1602 I2C controller for HD44780-based displays",
-    "Sensor Class":
-    {
-        "Lcm1602":
-        {
-            "Name": "LCD Display Driver for the LCM1602 Controller for HD44780-based Displays",
-            "Description": "UPM module for the  ear-clip heart rate sensor. It is used to measure your heart rate.",
-            "Aliases": ["lcm1602"],
-            "Categories": ["display"],
-            "Connections": ["gpio"],
-            "Project Type": ["display", "prototyping"],
-            "Manufacturers": ["adafruit", "sparkfun", "seeed"],
-            "Kits": [],
-            "Examples":
-            {
-                "Java": ["Lcm1602_i2c_Example.java", "Lcm1602_parallel_Example.java"],
-                "Python": [],
-                "Node.js": [],
-                "C++": ["lcm1602-i2c.cxx", "lcm1602-parallel.cxx"],
-                "C": ["lcm1602-i2c.c", "lcm1602-parallel.c"]
-            },
-            "Specifications":
-            {
-                "Operating Voltage": {"unit": "V", "low": 4.8, "typ": 5, "high": 5.2},
-                "Operating Current": {"unit": "mA", "max": 150}
-            },
-            "Urls" :
-            {
-                "Product Pages": [],
-                "Datasheets": ["https://www.adafruit.com/datasheets/TC1602A-01T.pdf"],
-                "Schematics": []
-            }
-        }
-    }
-}
diff --git a/src/ldt0028/CMakeLists.txt b/src/ldt0028/CMakeLists.txt
deleted file mode 100644
index a077f77..0000000
--- a/src/ldt0028/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-upm_mixed_module_init (NAME ldt0028
-    DESCRIPTION "Piezo Vibration Sensor"
-    C_HDR ldt0028.h
-    C_SRC ldt0028.c
-    CPP_HDR ldt0028.hpp
-    CPP_SRC ldt0028.cxx
-    FTI_SRC ldt0028_fti.c
-    REQUIRES mraa)
diff --git a/src/ldt0028/ldt0028.c b/src/ldt0028/ldt0028.c
deleted file mode 100644
index 8757d0b..0000000
--- a/src/ldt0028/ldt0028.c
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- * Author: Noel Eck <noel.eck@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string.h>
-#include <stdlib.h>
-
-#include "ldt0028.h"
-
-ldt0028_context ldt0028_init(int16_t pin)
-{
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        return NULL;
-    }
-
-    ldt0028_context dev = (ldt0028_context) malloc(sizeof(struct _ldt0028_context));
-
-    if (dev == NULL)
-      return NULL;
-
-    /* Init aio pin */
-    dev->aio = mraa_aio_init(pin);
-
-    if (dev->aio == NULL) {
-        free(dev);
-        return NULL;
-    }
-
-    /* Set the ADC ref, scale, and offset defaults */
-    dev->m_aRef = 5.0;
-    dev->m_scale = 1.0;
-    dev->m_offset = 0.0;
-
-    return dev;
-}
-
-void ldt0028_close(ldt0028_context dev)
-{
-    mraa_aio_close(dev->aio);
-    free(dev);
-}
-
-upm_result_t ldt0028_set_aref(const ldt0028_context dev, float aref)
-{
-    dev->m_aRef = aref;
-    return UPM_SUCCESS;
-}
-
-upm_result_t ldt0028_set_scale(const ldt0028_context dev, float scale)
-{
-    dev->m_scale = scale;
-    return UPM_SUCCESS;
-}
-
-upm_result_t ldt0028_set_offset(const ldt0028_context dev, float offset)
-{
-    dev->m_offset = offset;
-    return UPM_SUCCESS;
-}
-
-float ldt0028_get_aref(const ldt0028_context dev)
-{
-    return dev->m_aRef;
-}
-
-float ldt0028_get_scale(const ldt0028_context dev)
-{
-    return dev->m_scale;
-}
-
-float ldt0028_get_offset(const ldt0028_context dev)
-{
-    return dev->m_offset;
-}
-
-upm_result_t ldt0028_get_normalized(const ldt0028_context dev, float *value)
-{
-    *value = mraa_aio_read_float(dev->aio);
-    if (*value < 0)
-        return UPM_ERROR_OPERATION_FAILED;
-    return UPM_SUCCESS;
-}
-
-upm_result_t ldt0028_get_raw_volts(const ldt0028_context dev, float *value)
-{
-    *value = mraa_aio_read_float(dev->aio);
-    if (*value < 0)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    /* Scale by the ADC reference voltage */
-    *value *= dev->m_aRef;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t ldt0028_get_volts(const ldt0028_context dev, float *value)
-{
-    *value = mraa_aio_read_float(dev->aio);
-    if (*value < 0)
-        return UPM_ERROR_OPERATION_FAILED;
-
-     /* Apply raw scale */
-    *value *= dev->m_scale;
-
-     /* Scale to aRef */
-    *value *= dev->m_aRef;
-
-    /* Apply the offset in volts */
-    *value += dev->m_offset;
-
-    return UPM_SUCCESS;
-}
diff --git a/src/ldt0028/ldt0028.cxx b/src/ldt0028/ldt0028.cxx
deleted file mode 100644
index 19e712f..0000000
--- a/src/ldt0028/ldt0028.cxx
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Author: Sarah Knepper <sarah.knepper@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string>
-#include <stdexcept>
-
-#include "ldt0028.hpp"
-
-using namespace upm;
-
-LDT0028::LDT0028(unsigned int pin) {
-    // initialize analog input
-    if ( !(m_pin = mraa_aio_init(pin)) ) 
-      {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_aio_init() failed, invalid pin?");
-        return;
-      }
-    m_name = "ldt0-028";
-}
-
-LDT0028::~LDT0028() {
-    // close analog input
-    mraa_aio_close(m_pin);
-}
-
-std::string LDT0028::name() {
-    return m_name;
-}
-
-int LDT0028::getSample() {
-    return mraa_aio_read(m_pin);
-}
diff --git a/src/ldt0028/ldt0028.h b/src/ldt0028/ldt0028.h
deleted file mode 100644
index 10fd057..0000000
--- a/src/ldt0028/ldt0028.h
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
- * Author: Noel Eck <noel.eck@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include "upm.h"
-#include "mraa/aio.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @file ldt0028.h
- * @library ldt0028
- * @brief C API for the LDT0-028 Piezo Vibration Sensor
- *
- * @include ldt0028.c
- */
-
-/**
- * driver context
- */
-typedef struct _ldt0028_context {
-    /* mraa aio pin context */
-    mraa_aio_context aio;
-    /* Analog voltage reference */
-    float m_aRef;
-    /* Scale */
-    float m_scale;
-    /* Offset in sensor units */
-    float m_offset;
-} *ldt0028_context;
-
-/**
- * Initialize analog sensor
- * @param pin Analog pin
- * @return sensor context
- */
-ldt0028_context ldt0028_init(int16_t pin);
-
-/**
- * Analog sensor destructor
- * @param sensor context pointer
- */
-void ldt0028_close(ldt0028_context dev);
-
-/**
- * Set ADC reference voltage
- * @param dev sensor context pointer
- * @param aref ADC reference voltage
- * @return Function result code
- */
-upm_result_t ldt0028_set_aref(const ldt0028_context dev, float aref);
-
-/**
- * Set sensor scale.  This scale is applied to the return value:
- *     counts = counts * scale
- * @param dev sensor context pointer
- * @param scale count scale value used
- * @return Function result code
- */
-upm_result_t ldt0028_set_scale(const ldt0028_context dev, float scale);
-
-/**
- * Set sensor offset.  This offset is applied to the return value:
- *     value = value + offset
- * @param dev sensor context pointer
- * @param offset count offset value used
- * @return Function result code
- */
-upm_result_t ldt0028_set_offset(const ldt0028_context dev, float offset);
-
-/**
- * Get sensor aref
- * @param dev sensor context pointer
- * @return Sensor ADC reference voltage
- */
-float ldt0028_get_aref(const ldt0028_context dev);
-
-/**
- * Get sensor scale
- * @param dev sensor context pointer
- * @return Sensor scale
- */
-float ldt0028_get_scale(const ldt0028_context dev);
-
-/**
- * Get sensor offset
- * @param dev sensor context pointer
- * @return Sensor offset
- */
-float ldt0028_get_offset(const ldt0028_context dev);
-
-/**
- * Read normalized value for sensor
- * @param dev sensor context pointer
- * @param *value Normalized value (0.0 -> 1.0)
- * @return Function result code
- */
-upm_result_t ldt0028_get_normalized(const ldt0028_context dev, float *value);
-
-/**
- * Read raw voltage from the sensor
- * @param dev sensor context pointer
- * @param *value Raw sensor voltage
- * @return Function result code
- */
-upm_result_t ldt0028_get_raw_volts(const ldt0028_context dev, float *value);
-
-/**
- * Read scaled/offset voltage from the sensor
- * @param dev sensor context pointer
- * @param *value Adjusted sensor voltage
- * @return Function result code
- */
-upm_result_t ldt0028_get_volts(const ldt0028_context dev, float *value);
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/ldt0028/ldt0028.hpp b/src/ldt0028/ldt0028.hpp
deleted file mode 100644
index 8cfe28f..0000000
--- a/src/ldt0028/ldt0028.hpp
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Author: Sarah Knepper <sarah.knepper@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/aio.h>
-
-namespace upm {
-
-/**
- * @brief LDT0-028 Piezo Vibration Sensor
- * @defgroup ldt0028 libupm-ldt0028
- * @ingroup seeed analog flexfor
- */
-
-/**
- * @library ldt0028
- * @sensor ldt0028
- * @comname Piezo Vibration Sensor
- * @altname Grove Piezo Vibration Sensor
- * @type flexfor
- * @man seeed
- * @con analog
- * @web http://wiki.seeed.cc/Grove-Piezo_Vibration_Sensor/
- *
- * @brief API for LDT0-028 PZT film-based sensors,
- * such as a Grove Piezo Vibration sensor
- *
- * This module defines the LDT0-028 interface for libupm-ldt0028
- *
- * @image html ldt0028.jpg
- * @snippet ldt0028.cxx Interesting
- */
-class LDT0028 {
-    public:
-        /**
-         * LDT0028 constructor
-         *
-         * @param pin AIO pin where the sensor is connected
-         */
-        LDT0028(unsigned int pin);
-
-        /**
-         * LDT0028 destructor
-         */
-        ~LDT0028();
-
-        /**
-         * Returns the name of this sensor
-         *
-         * @return Name of this sensor
-         */
-        std::string name();
-
-        /**
-         * Returns one sample from this sensor
-         *
-         * @return One value from this sensor
-         */
-        int getSample();
-
-    protected:
-        std::string         m_name; //!< name of this sensor
-        mraa_aio_context    m_pin;  //!< AIO pin
-};
-
-}
diff --git a/src/ldt0028/ldt0028.json b/src/ldt0028/ldt0028.json
deleted file mode 100644
index b70dccc..0000000
--- a/src/ldt0028/ldt0028.json
+++ /dev/null
@@ -1,37 +0,0 @@
-{
-    "Library": "ldt0028",
-    "Description": "API for LDT0-028 PZT Film-Based Sensors",
-    "Sensor Class":
-    {
-        "LDT0028":
-        {
-            "Name": "Piezo Vibration Sensor",
-            "Description": "This module defines the LDT0-028 interface for libupm-ldt0028",
-            "Aliases": ["ldt0028"],
-            "Categories": ["vibration"],
-            "Connections": ["analog"],
-            "Project Type": ["industrial", "prototyping"],
-            "Manufacturers": ["seeed"],
-            "Kits": [],
-            "Image": "ldt0028.jpg",
-            "Examples":
-            {
-                "Java": ["LDT0028_Example.java"],
-                "Python": ["ldt0028.py"],
-                "Node.js": ["ldt0028.js"],
-                "C++": ["ldt0028.cxx"],
-                "C": ["ldt0028.c"]
-            },
-            "Specifications":
-            {
-                "Operating Voltage": {"unit": "V", "low": 3.3, "high": 5}
-            },
-            "Urls" :
-            {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-Piezo-Vibration-Sensor-p-1411.html"],
-                "Datasheets": ["http://wiki.seeed.cc/Grove-Piezo_Vibration_Sensor/", "https://raw.githubusercontent.com/SeeedDocument/Grove-Piezo_Vibration_Sensor/master/res/Piezo_Vibration_Sensor.pdf"],
-                "Schematics": []
-            }
-        }
-    }
-}
diff --git a/src/ldt0028/ldt0028_fti.c b/src/ldt0028/ldt0028_fti.c
deleted file mode 100644
index 635b3c7..0000000
--- a/src/ldt0028/ldt0028_fti.c
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Author:  Sisinty Sasmita Patra <sisinty.s.patra@intel.com>
- *
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "ldt0028.h"
-#include "upm_fti.h"
-
-/** 
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_ldt0028_name[] = "LDT0028";
-const char upm_ldt0028_description[] = "Grove Piezo Vibration Sensor";
-const upm_protocol_t upm_ldt0028_protocol[] = {UPM_ANALOG};
-const upm_sensor_t upm_ldt0028_category[] = {UPM_VIBRATION};
-
-// forward declarations
-const void* upm_ldt0028_get_ft(upm_sensor_t sensor_type);
-const void* upm_ldt0028_get_ft(upm_sensor_t sensor_type);
-const upm_sensor_descriptor_t upm_ldt0028_get_descriptor();
-void* upm_ldt0028_init_name();
-void upm_ldt0028_close(void* dev);
-upm_result_t upm_ldt0028_get_value(void* dev, float* vibval);
-
-const upm_sensor_descriptor_t upm_ldt0028_get_descriptor() {
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_ldt0028_name;
-    usd.description = upm_ldt0028_description;
-    usd.protocol_size = 1;
-    usd.protocol = upm_ldt0028_protocol;
-    usd.category_size = 1;
-    usd.category = upm_ldt0028_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = &upm_ldt0028_init_name,
-    .upm_sensor_close = &upm_ldt0028_close,
-    .upm_sensor_get_descriptor = &upm_ldt0028_get_descriptor
-};
-
-static const upm_vibration_ft vft =
-{
-    .upm_vibration_get_value = upm_ldt0028_get_value
-};
-
-const void* upm_ldt0028_get_ft(upm_sensor_t sensor_type) {
-    if(sensor_type == UPM_SENSOR) {
-        return &ft;
-    }
-
-    if(sensor_type == UPM_VIBRATION) {
-        return &vft;
-    }
-    return NULL;
-}
-
-void* upm_ldt0028_init_name(){
-    return NULL;
-}
-
-void upm_ldt0028_close(void* dev)
-{
-    ldt0028_close((ldt0028_context)dev);
-}
-
-upm_result_t upm_ldt0028_get_value(void* dev, float* vibval)
-{
-    return ldt0028_get_volts((ldt0028_context)dev, vibval);
-}
diff --git a/src/led/CMakeLists.txt b/src/led/CMakeLists.txt
deleted file mode 100644
index b627ec3..0000000
--- a/src/led/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME led
-    DESCRIPTION "Light-emitting Diode (LED)"
-    C_HDR led.h
-    C_SRC led.c
-    CPP_HDR led.hpp
-    CPP_SRC led.cxx
-    FTI_SRC led_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa)
diff --git a/src/led/led.c b/src/led/led.c
deleted file mode 100644
index 2f39e9f..0000000
--- a/src/led/led.c
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- * Author: Brendan Le Foll <brendan.le.foll@intel.com>
- * Contributions: Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- * Contributions: Sarah Knepper <sarah.knepper@intel.com>
- *                Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#include "led.h"
-#include "upm_types.h"
-
-led_context led_init(int pin){
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        return NULL;
-    }
-
-    led_context dev =
-      (led_context)malloc(sizeof(struct _led_context));
-
-    if (!dev)
-        return NULL;
-
-    dev->name = NULL;
-    dev->gpioled = NULL;
-
-    dev->led_pin = pin;
-    dev->gpio = mraa_gpio_init(dev->led_pin);
-
-    if (mraa_gpio_dir(dev->gpio, MRAA_GPIO_OUT) != MRAA_SUCCESS) {
-        printf("%s: Unable to set pin %d as output.\n", __FUNCTION__, pin);
-        free(dev);
-        return NULL;
-    }
-
-    return dev;
-}
-
-led_context led_init_str(const char* name){
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        return NULL;
-    }
-
-    led_context dev =
-      (led_context)malloc(sizeof(struct _led_context));
-
-    if (!dev)
-        return NULL;
-
-    dev->led_pin = -1;
-    dev->gpio = NULL;
-
-    dev->name = name;
-    dev->gpioled = mraa_led_init(name);
-
-    if (!dev->gpioled) {
-        printf("%s: Unable to initialize gpioled device (%s).\n", __FUNCTION__, dev->name);
-        free(dev);
-        return NULL;
-    }
-
-    dev->max_brightness = mraa_led_read_max_brightness(dev->gpioled);
-
-    return dev;
-}
-
-void led_close(led_context dev){
-    if (dev->gpio) {
-        mraa_gpio_close(dev->gpio);
-    }
-    if (dev->gpioled) {
-        mraa_led_close(dev->gpioled);
-    }
-    free(dev);
-}
-
-upm_result_t led_on(led_context dev){
-    if (dev->gpio) {
-        // using gpio pin
-        if (mraa_gpio_write(dev->gpio, 1) != MRAA_SUCCESS)
-            return UPM_ERROR_OPERATION_FAILED;
-    } else {
-        // using gpioled device
-        if (mraa_led_set_brightness(dev->gpioled, dev->max_brightness) != MRAA_SUCCESS)
-            return UPM_ERROR_OPERATION_FAILED;
-    }
-    return UPM_SUCCESS;
-}
-
-upm_result_t led_off(led_context dev){
-    if (dev->gpio) {
-        // using gpio pin
-        if (mraa_gpio_write(dev->gpio, 0) != MRAA_SUCCESS)
-            return UPM_ERROR_OPERATION_FAILED;
-    } else {
-        // using gpioled device
-        if (mraa_led_set_brightness(dev->gpioled, 0) != MRAA_SUCCESS)
-            return UPM_ERROR_OPERATION_FAILED;
-    }
-    return UPM_SUCCESS;
-}
diff --git a/src/led/led.cxx b/src/led/led.cxx
deleted file mode 100644
index ee088dd..0000000
--- a/src/led/led.cxx
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Authors: Brendan Le Foll <brendan.le.foll@intel.com>
- *          Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- *          Sarah Knepper <sarah.knepper@intel.com>
- * Copyright (c) 2014 - 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "led.hpp"
-
-using namespace std;
-using namespace upm;
-
-Led::Led(int pin)
-{
-    if ( !(m_led = led_init(pin)) ) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_gpio_init() failed, invalid pin?");
-        return;
-    }
-}
-
-Led::Led(std::string name)
-{
-    if ( !(m_led = led_init_str(name.c_str())) ) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_led_init() failed, invalid led name?");
-        return;
-    }
-}
-
-Led::~Led()
-{
-    led_close(m_led);
-}
-
-upm_result_t Led::write(int value)
-{
-    if (value >= 1) {
-        return led_on(m_led);
-    }
-    return led_off(m_led);
-}
-
-upm_result_t Led::on()
-{
-    return write(1);
-}
-
-upm_result_t Led::off()
-{
-    return write(0);
-}
diff --git a/src/led/led.h b/src/led/led.h
deleted file mode 100644
index 1caa214..0000000
--- a/src/led/led.h
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * Author: Brendan Le Foll <brendan.le.foll@intel.com>
- * Contributions: Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- *                Sarah Knepper <sarah.knepper@intel.com>
- *                Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#ifndef LED_LED_H_
-#define LED_LED_H_
-
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-#include <stdint.h>
-#include "upm.h"
-#include "mraa/gpio.h"
-#include "mraa/led.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @file led.h
- * @library led
- * @brief C API for LEDs
- *
- * @include led.c
- */
-
-/**
- * device context
- */
-typedef struct _led_context {
-    mraa_gpio_context        gpio;
-    mraa_led_context         gpioled;
-    int                      led_pin;
-    const char*              name;
-    int                      max_brightness;
-} *led_context;
-
-/**
- * LED Initialization function
- *
- * @param pin GPIO pin to use
- * @return The sensor context
- */
-led_context led_init(int pin);
-
-/**
- * LED Initialization function
- *
- * @param name Linux gpioled device to use
- * @return The sensor context
- */
-led_context led_init_str(const char* name);
-
-/**
- * LED Initialization function
- *
- * @param The sensor context
- */
-void led_close(led_context dev);
-
-/**
- * Function to turn LED on
- *
- * @param The sensor context
- * @return upm_result_t UPM success/error code
- */
-upm_result_t led_on(led_context dev);
-
-/**
- * Function to turn LED off
- *
- * @param The sensor context
- * @return upm_result_t UPM success/error code
- */
-upm_result_t led_off(led_context dev);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LED_LED_H_ */
diff --git a/src/led/led.hpp b/src/led/led.hpp
deleted file mode 100644
index 2947b00..0000000
--- a/src/led/led.hpp
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * Authors: Brendan Le Foll <brendan.le.foll@intel.com>
- *          Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- *          Sarah Knepper <sarah.knepper@intel.com>
- * Copyright (c) 2014 - 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <string>
-#include "led.h"
-
-namespace upm {
-/**
- * @brief LED Library
- * @defgroup ledlib libupm-led
- * @ingroup seeed gpio led gsk
- */
-
-/**
- * @library ledlib
- * @sensor led
- * @comname Light-emitting Diode (LED)
- * @altname Grove LED
- * @type led
- * @man seeed
- * @con gpio
- * @kit gsk
- *
- * @brief API for the LED
- *
- * UPM module for the LED (or other similar light-emitting diodes).
- * An LED is a p-n junction semiconductor which emits light in
- * response to voltage. The longer wire of an LED connects
- * to the positive seat (anode); the shorter wire connects to the
- * negative seat (cathode). The flat side of the bulb corresponds
- * to the cathode, while the rounded side corresponds to the anode.
- *
- * @image html led.jpg
- * @snippet led.cxx Interesting
- */
-class Led {
-    public:
-        /**
-         * LED constructor
-         *
-         * @param pin Pin to use
-         */
-        Led(int pin);
-        /**
-         * LED constructor
-         *
-         * @param name Linux gpioled device name
-         */
-        Led(std::string name);
-        /**
-         * LED destructor
-         */
-        ~Led();
-        /**
-         * Turns the LED on or off, depending on the value.
-         * If the value is positive (greater than or equal
-         * to 1), the LED is turned on.  Otherwise, for 0
-         * or negative values, the LED is turned off.
-         *
-         * @param value Tells the LED to turn on (for values >=1)
-         * or off (for values <1)
-         *
-         * @return 0 if successful, non-zero otherwise
-         */
-        upm_result_t write(int value);
-        /**
-         * Turns the LED off
-         *
-         * @return 0 if successful, non-zero otherwise
-         */
-        upm_result_t off();
-        /**
-         * Turns the LED on
-         *
-         * @return 0 if successful, non-zero otherwise
-         */
-        upm_result_t on();
-        std::string name()
-        {
-            return "LED Sensor";
-        }
-    private:
-        led_context m_led;
-};
-}
diff --git a/src/led/led.i b/src/led/led.i
deleted file mode 100644
index bed31ac..0000000
--- a/src/led/led.i
+++ /dev/null
@@ -1,16 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%apply int {mraa::Edge}
-
-JAVA_JNI_LOADLIBRARY(javaupm_led)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "led.hpp"
-%}
-%include "led.hpp"
-/* END Common SWIG syntax */
diff --git a/src/led/led.json b/src/led/led.json
deleted file mode 100644
index 13706ed..0000000
--- a/src/led/led.json
+++ /dev/null
@@ -1,32 +0,0 @@
-{
-    "Library": "led",
-    "Description": "LED library",
-    "Sensor Class":
-    {
-        "Led":
-        {
-            "Name": "Light-emitting Diode (LED)",
-            "Description": "UPM module for the LED (or other similar light-emitting diodes). An LED is a p-n junction semiconductor which emits light in response to voltage. The longer wire of an LED connects to the positive seat (anode); the shorter wire connects to the negative seat (cathode). The flat side of the bulb corresponds to the cathode, while the rounded side corresponds to the anode.",
-            "Aliases": ["Grove - LED"],
-            "Categories": ["led"],
-            "Connections": ["gpio"],
-            "Project Type": ["prototyping", "industrial"],
-            "Manufacturers": ["seeed", "dfrobot", "sparkfun", "adafruit", "generic"],
-            "Kits": ["gsk"],
-            "Image": "led.jpg",
-            "Examples":
-            {
-                "Java": ["LED_Example.java"],
-                "Python": ["led.py"],
-                "Node.js": ["led.js"],
-                "C++": ["led.cxx"],
-                "C": ["led.c"]
-            },
-            "Urls" :
-            {
-                "Product Pages": ["http://wiki.seeed.cc/Grove-LED_Socket_Kit/"],
-                "Schematics": ["https://github.com/SeeedDocument/Grove-LED_Socket_Kit/raw/master/res/Grove-LED_v1.3_Schematics.zip"]
-            }
-        }
-    }
-}
diff --git a/src/led/led_fti.c b/src/led/led_fti.c
deleted file mode 100644
index 2aab897..0000000
--- a/src/led/led_fti.c
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Author: Brendan Le Foll <brendan.le.foll@intel.com>
- * Contributions: Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- * Contributions: Sarah Knepper <sarah.knepper@intel.com>
- *                Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#include "led.h"
-#include "upm_fti.h"
-
-/** 
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_led_name[] = "LED";
-const char upm_led_description[] = "LED";
-const upm_protocol_t upm_led_protocol[] = {UPM_GPIO};
-const upm_sensor_t upm_led_category[] = {UPM_LED};
-
-// forward declarations
-const upm_sensor_descriptor_t upm_led_get_descriptor();
-const void* upm_led_get_ft(upm_sensor_t sensor_type);
-void* upm_led_init_name();
-void upm_led_close(void* dev);
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = &upm_led_init_name,
-    .upm_sensor_close = &upm_led_close,
-    .upm_sensor_get_descriptor = &upm_led_get_descriptor
-};
-
-const void* upm_led_get_ft(upm_sensor_t sensor_type){
-    if(sensor_type == UPM_SENSOR){
-        return &ft;
-    }
-    return NULL;
-}
-
-const upm_sensor_descriptor_t upm_led_get_descriptor(){
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_led_name;
-    usd.description = upm_led_description;
-    usd.protocol_size = 1;
-    usd.protocol = upm_led_protocol;
-    usd.category_size = 1;
-    usd.category = upm_led_category;
-    return usd;
-}
-
-void* upm_led_init_name(){
-    return NULL;
-}
-
-void upm_led_close(void* dev) {
-    led_close((led_context)dev);
-}
diff --git a/src/lidarlitev3/CMakeLists.txt b/src/lidarlitev3/CMakeLists.txt
deleted file mode 100644
index 08d92aa..0000000
--- a/src/lidarlitev3/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-upm_mixed_module_init (NAME lidarlitev3
-    DESCRIPTION "Optical Distance Measurement Sensor"
-    CPP_HDR lidarlitev3.hpp
-    CPP_SRC lidarlitev3.cxx
-    REQUIRES mraa)
diff --git a/src/lidarlitev3/lidarlitev3.cxx b/src/lidarlitev3/lidarlitev3.cxx
deleted file mode 100644
index a615d42..0000000
--- a/src/lidarlitev3/lidarlitev3.cxx
+++ /dev/null
@@ -1,134 +0,0 @@
-/*
- * Author: Saloni Jain <saloni.jain@tcs.com>
- * Author: Niti Rohilla <niti.rohilla@tcs.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-#include <unistd.h>
-#include <stdlib.h>
-
-#include "lidarlitev3.hpp"
-
-using namespace upm;
-
-LIDARLITEV3::LIDARLITEV3 (int bus, int devAddr) : m_i2ControlCtx(bus) {
-    m_name = "LIDARLITEV3";
-
-    m_controlAddr = devAddr;
-    m_bus = bus;
-
-    mraa::Result ret = m_i2ControlCtx.address(m_controlAddr);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_address() failed");
-    }
-}
-
-int
-LIDARLITEV3::getDistance () {
-
-    if(i2cWriteReg(ACQ_COMMAND, 0x04) < 0)
-        return -1;
-
-    return read(0x8f,true);
-}
-
-uint16_t
-LIDARLITEV3::read(int reg, bool monitorBusyFlag) {
-    int busyFlag = 0; // busyFlag monitors when the device is done with a measurement
-    int busyCounter = 0; // busyCounter counts number of times busy flag is checked, for timeout
-    uint8_t data;
-    uint16_t distance;
-
-    if(monitorBusyFlag) {
-        busyFlag = 1; // Begin read immediately if not monitoring busy flag
-    }
-
-    while(busyFlag != 0) { // Loop until device is not busy
-        // Read status register to check busy flag
-        data = i2cReadReg_8 (0x01); // Read register 0x01
-        busyFlag = data & 1; // Assign the LSB of the status register to busyFlag
-
-        busyCounter++; // Increment busyCounter for timeout
-
-        // Handle timeout condition, exit while loop and goto bailout
-        if(busyCounter > 9999) {
-            goto timeout;
-        }
-    }
-
-    if (busyFlag == 0) {
-        // Read bytes to obtain 16-bit measured distance in centimeters
-        distance = i2cReadReg_16(0x8f);
-    }
-
-    // timeout reports error
-    if(busyCounter > 9999) {
-        timeout:
-        busyCounter = 0;
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": Read timeout");
-    }
-    return distance;
-}
-
-uint16_t
-LIDARLITEV3::i2cReadReg_16 (int reg) {
-    uint16_t data;
-
-    m_i2ControlCtx.writeByte(reg);
-
-    m_i2ControlCtx.read((uint8_t *)&data, 0x2);
-
-    uint8_t high = (data & 0xFF00) >> 8;
-    data = (data << 8) & 0xFF00;
-    data |= high;
-
-    return data;
-}
-
-uint8_t
-LIDARLITEV3::i2cReadReg_8 (int reg) {
-    uint8_t data;
-
-    m_i2ControlCtx.writeByte(reg);
-
-    m_i2ControlCtx.read(&data, 0x1);
-
-    return data;
-}
-
-mraa::Result
-LIDARLITEV3::i2cWriteReg (uint8_t reg, uint8_t value) {
-    mraa::Result error = mraa::SUCCESS;
-
-    uint8_t data[2] = { reg, value };
-    error = m_i2ControlCtx.write (data, 2);
-    if ( error != mraa::SUCCESS)
-      throw std::invalid_argument(std::string(__FUNCTION__) +
-                                  ": mraa_i2c_write() failed");
-
-    return error;
-}
diff --git a/src/lidarlitev3/lidarlitev3.hpp b/src/lidarlitev3/lidarlitev3.hpp
deleted file mode 100644
index 7772e71..0000000
--- a/src/lidarlitev3/lidarlitev3.hpp
+++ /dev/null
@@ -1,162 +0,0 @@
-/*
- * Author: Saloni Jain <saloni.jain@tcs.com>
- * Author: Niti Rohilla <niti.rohilla@tcs.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/i2c.hpp>
-
-#define ADDR                  0x62 // device address
-
-// registers address
-#define ACQ_COMMAND           0x00 // Device Command
-#define STATUS                0x01 // System Status
-#define SIG_COUNT_VAL         0x02 // Maximum Acquisition Count
-#define ACQ_CONFIG_REG        0x04 // Acquisition Mode Control
-#define VELOCITY              0x09 // Velocity measurement output
-#define PEAK_CORR             0x0C // Peak value in correlation record
-#define NOISE_PEAK            0x0D // Correaltion record noise floor
-#define SIGNAL_STRENGTH       0x0E // Received signal strength
-#define FULL_DELAY_HIGH       0x0F // Distance measurement high byte
-#define FULL_DELAY_LOW        0x10 // Distance measurement low byte
-#define OUTER_LOOP_COUNT      0x11 // Burst measurement count conttrol
-#define REF_COUNT_VAL         0x12 // Reference acquisition count
-#define LAST_DELAY_HIGH       0x14 // Previous distance measurement high byte
-#define LAST_DELAY_LOW        0x15 // Previous distance measurement low byte
-#define UNIT_ID_HIGH          0x16 // Serial number high byte
-#define UNIT_ID_LOW           0x17 // Serial number low byte
-#define I2C_ID_HIGH           0x18 // Write serial number high byte for I2C address unclock
-#define I2C_ID_LOW            0x19 // Write serial number low byte for I2X address unlock
-#define I2C_SEC_ADDR          0x1A // Write new I2C address after unlock
-#define THRESHOLD_BYPASS      0x1C // Peak detection threshold bypass
-#define I2C_CONFIG            0x1E // Default address response control
-#define COMMAND               0x40 // State command
-#define MEASURE_DELAY         0x45 // Delay between automatic measurements
-#define PEAK_BCK              0x4C // Second largest peak value on correlation record
-#define CORR_DATA             0x52 // Correlation record data lo byte
-#define CORR_DATA_SIGN        0x53 // Correlation record data high byte
-#define ACQ_SETTINGS          0x5D // Correaltion record memory bank select
-#define POWER_CONTROL         0x65 // Power state control
-
-#define HIGH               1
-#define LOW                0
-
-namespace upm {
-
-/**
- * @brief LIDARLITEV3 Optical Distance Measurement Sensor
- * @defgroup lidarlitev3 libupm-lidarlitev3
- * @ingroup garmin i2c light
- */
-/**
- * @library lidarlightv3
- * @sensor lidarlightv3
- * @comname Optical Distance Measurement Sensor
- * @type light
- * @man garmin
- * @con i2c
- * @web https://www.sparkfun.com/products/14032
- *
- * @brief API for the LIDARLITEV3 Optical Distance Measurement Sensor
- *
- * It is a compact, high-performance optical distance measurement
- * sensor from Garmin.
- * [LIDARLITEV3 Datasheet]
- * http://static.garmin.com/pumac/LIDAR_Lite_v3_Operation_Manual_and_Technical_Specifications.pdf
- *
- * @snippet lidarlitev3.cxx Interesting
- */
-class LIDARLITEV3 {
-    public:
-        /**
-         * Instantiates an LIDARLITEV3 object
-         *
-         * @param bus Number of the used bus
-         * @param devAddr Address of the used I2C device: 0x62
-         */
-        LIDARLITEV3 (int bus, int devAddr=ADDR);
-
-        /**
-         * LIDARLITEV3 object destructor; basically, it closes the I2C connection.
-         *
-         *~LIDARLITEV3 ();
-         * no need for the destructor - the I2c connection will be closed when
-         * m_i2ControlCtx variable will be out of context
-         **/
-
-        /**
-         * Returns distance measurement on success
-         * Retruns -1 on failure.
-         */
-        int getDistance ();
-
-        /**
-         * Read
-         * Perform I2C read from device.
-         *
-         * @param reg register address to read from.
-         * @param monitorBusyFlag if true, the routine will repeatedly read the status
-         *                         register until the busy flag (LSB) is 0.
-         */
-        uint16_t read(int reg, bool monitorBusyFlag);
-
-        /**
-         * Returns the name of the component
-         */
-        std::string name()
-        {
-            return m_name;
-        }
-
-        /**
-         * Reads a one-byte register
-         *
-         * @param reg Address of the register
-         */
-        uint8_t i2cReadReg_8 (int reg);
-
-        /**
-         * Reads a two-byte register
-         *
-         * @param reg Address of the register
-         */
-        uint16_t i2cReadReg_16 (int reg);
-
-        /**
-         * Writes to a one-byte register
-         *
-         * @param reg Address of the register
-         * @param value Byte to be written
-         */
-        mraa::Result i2cWriteReg (uint8_t reg, uint8_t value);
-
-    private:
-        std::string m_name;
-
-        int m_controlAddr;
-        int m_bus;
-        mraa::I2c m_i2ControlCtx;
-};
-
-}
diff --git a/src/lidarlitev3/lidarlitev3.i b/src/lidarlitev3/lidarlitev3.i
deleted file mode 100644
index 176f0bc..0000000
--- a/src/lidarlitev3/lidarlitev3.i
+++ /dev/null
@@ -1,14 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_lidarlitev3)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "lidarlitev3.hpp"
-%}
-%include "lidarlitev3.hpp"
-/* END Common SWIG syntax */
diff --git a/src/lidarlitev3/lidarlitev3.json b/src/lidarlitev3/lidarlitev3.json
deleted file mode 100644
index 63b9aeb..0000000
--- a/src/lidarlitev3/lidarlitev3.json
+++ /dev/null
@@ -1,38 +0,0 @@
-{
-    "Library": "lidarlitev3",
-    "Description": "API for the LIDARLITEV3 Optical Distance Measurement Sensor",
-    "Sensor Class":
-    {
-        "LIDARLITEV3":
-        {
-            "Name": "Optical Distance Measurement Sensor",
-            "Description": "It is a compact, high-performance optical distance measurement sensor from Garmin.",
-            "Aliases": ["lidarlitev3"],
-            "Categories": ["distance"],
-            "Connections": ["i2c", "pwm"],
-            "Project Type": ["robotics", "prototyping"],
-            "Manufacturers": ["garmin"],
-            "Kits": [],
-            "Image": "lidarlitev3.jpg",
-            "Examples":
-            {
-                "Java": [],
-                "Python": [],
-                "Node.js": [],
-                "C++": ["lidarlitev3.cxx"],
-                "C": []
-            },
-            "Specifications":
-            {
-                "Operating Voltage": {"unit": "V", "typ": 5},
-                "Operating Current": {"unit": "mA", "low": 105, "high": 130}
-            },
-            "Urls" :
-            {
-                "Product Pages": ["https://www.sparkfun.com/products/14032"],
-                "Datasheets": ["http://static.garmin.com/pumac/LIDAR_Lite_v3_Operation_Manual_and_Technical_Specifications.pdf"],
-                "Schematics": []
-            }
-        }
-    }
-}
diff --git a/src/light/CMakeLists.txt b/src/light/CMakeLists.txt
deleted file mode 100644
index b7c5c7f..0000000
--- a/src/light/CMakeLists.txt
+++ /dev/null
@@ -1,10 +0,0 @@
-upm_mixed_module_init (NAME light
-    DESCRIPTION "Analog Light Sensor"
-    C_HDR light.h
-    C_SRC light.c
-    CPP_HDR light.hpp
-    CPP_SRC light.cxx
-    FTI_SRC light_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa m)
-target_link_libraries(light-c m)
diff --git a/src/light/light.c b/src/light/light.c
deleted file mode 100644
index fe78278..0000000
--- a/src/light/light.c
+++ /dev/null
@@ -1,140 +0,0 @@
-/*
- * Author: Noel Eck <noel.eck@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string.h>
-#include <stdlib.h>
-#include <math.h>
-
-#include "light.h"
-
-light_context light_init(int16_t pin)
-{
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        return NULL;
-    }
-
-    light_context dev = (light_context) malloc(sizeof(struct _light_context));
-
-    if (dev == NULL)
-      return NULL;
-
-    /* Init aio pin */
-    dev->aio = mraa_aio_init(pin);
-
-    if (dev->aio == NULL) {
-        free(dev);
-        return NULL;
-    }
-
-    /* Set the ADC ref, scale, and offset defaults */
-    dev->m_aRef = 5.0;
-    dev->m_scale = 1.0;
-    dev->m_offset = 0.0;
-
-    return dev;
-}
-
-void light_close(light_context dev)
-{
-    mraa_aio_close(dev->aio);
-    free(dev);
-}
-
-upm_result_t light_set_aref(const light_context dev, float aref)
-{
-    dev->m_aRef = aref;
-    return UPM_SUCCESS;
-}
-
-upm_result_t light_set_scale(const light_context dev, float scale)
-{
-    dev->m_scale = scale;
-    return UPM_SUCCESS;
-}
-
-upm_result_t light_set_offset(const light_context dev, float offset)
-{
-    dev->m_offset = offset;
-    return UPM_SUCCESS;
-}
-
-float light_get_aref(const light_context dev)
-{
-    return dev->m_aRef;
-}
-
-float light_get_scale(const light_context dev)
-{
-    return dev->m_scale;
-}
-
-float light_get_offset(const light_context dev)
-{
-    return dev->m_offset;
-}
-
-upm_result_t light_get_normalized(const light_context dev, float *value)
-{
-    *value = mraa_aio_read_float(dev->aio);
-    if (*value < 0)
-        return UPM_ERROR_OPERATION_FAILED;
-    return UPM_SUCCESS;
-}
-
-upm_result_t light_get_raw_volts(const light_context dev, float *value)
-{
-    *value = mraa_aio_read_float(dev->aio);
-    if (*value < 0)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    /* Scale by the ADC reference voltage */
-    *value *= dev->m_aRef;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t light_get_lux(const light_context dev, float *value)
-{
-    *value = mraa_aio_read(dev->aio);
-    if (*value < 0)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    /* Get max adc value range 1023, 2047, 4095, etc... */
-    float max_adc = (1 << mraa_aio_get_bit(dev->aio)) - 1;
-
-    /* Convert the value to lux */
-    *value = 10000.0/pow(((max_adc - *value) * 10.0 / *value)*15.0,4.0/3.0);
-
-     /* Apply scale */
-    *value *= dev->m_scale;
-
-    /* Apply the offset in lux */
-    *value += dev->m_offset;
-
-    return UPM_SUCCESS;
-}
diff --git a/src/light/light.cxx b/src/light/light.cxx
deleted file mode 100644
index 5fe2318..0000000
--- a/src/light/light.cxx
+++ /dev/null
@@ -1,119 +0,0 @@
-/*
- * Authors: Brendan Le Foll <brendan.le.foll@intel.com>
- *          Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- *          Sarah Knepper <sarah.knepper@intel.com>
- *          Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014 - 2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "light.hpp"
-
-using namespace upm;
-
-Light::Light(unsigned int pin) :
-    m_light(light_init(pin))
-{
-    if ( !m_light )
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": light_init() failed.");
-}
-
-Light::~Light()
-{
-    light_close(m_light);
-}
-
-int Light::value()
-{
-    float value;
-
-    if (light_get_lux(m_light, &value))
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": light_get_normalized() failed.");
-
-    return (int)roundf(value);
-}
-
-float Light::raw_value()
-{
-    // This is a hack.  Deprecated.  Should be removed ASAP.
-   int value =  mraa_aio_read(m_light->aio);
-   if (value < 0)
-       throw std::runtime_error(std::string(__FUNCTION__) +
-                                ": mraa_aio_read() failed.");
-
-   return (float)value; // ?? why a float?
-}
-
-void Light::setAref(float aref)
-{
-    light_set_aref(m_light, aref);
-}
-
-void Light::setScale(float scale)
-{
-    light_set_scale(m_light, scale);
-}
-
-void Light::setOffset(float offset)
-{
-    light_set_aref(m_light, offset);
-}
-
-float Light::getAref()
-{
-    return light_get_aref(m_light);
-}
-
-float Light::getScale()
-{
-    return light_get_scale(m_light);
-}
-
-float Light::getOffset()
-{
-    return light_get_offset(m_light);
-}
-
-float Light::getNormalized()
-{
-    float value;
-
-    if (light_get_normalized(m_light, &value))
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": light_get_normalized() failed.");
-    return value;
-}
-
-float Light::getRawVolts()
-{
-    float value;
-
-    if (light_get_raw_volts(m_light, &value))
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": light_get_raw_volts() failed.");
-    return value;
-}
diff --git a/src/light/light.h b/src/light/light.h
deleted file mode 100644
index eb51684..0000000
--- a/src/light/light.h
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
- * Author: Noel Eck <noel.eck@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include "upm.h"
-#include "mraa/aio.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @file light.h
- * @library light
- * @brief C API for Analog Light (Photocell) Sensors
- *
- * @include light.c
- */
-
-/**
- * driver context
- */
-typedef struct _light_context {
-    /* mraa aio pin context */
-    mraa_aio_context aio;
-    /* Analog voltage reference */
-    float m_aRef;
-    /* Scale */
-    float m_scale;
-    /* Offset in sensor units */
-    float m_offset;
-} *light_context;
-
-/**
- * Initialize analog sensor
- * @param pin Analog pin
- * @return sensor context
- */
-light_context light_init(int16_t pin);
-
-/**
- * Analog sensor destructor
- * @param sensor context pointer
- */
-void light_close(light_context dev);
-
-/**
- * Set ADC reference voltage
- * @param dev sensor context pointer
- * @param aref ADC reference voltage
- * @return Function result code
- */
-upm_result_t light_set_aref(const light_context dev, float aref);
-
-/**
- * Set sensor scale.  This scale is applied to the return value:
- *     counts = counts * scale
- * @param dev sensor context pointer
- * @param scale count scale value used
- * @return Function result code
- */
-upm_result_t light_set_scale(const light_context dev, float scale);
-
-/**
- * Set sensor offset.  This offset is applied to the return value:
- *     value = value + offset
- * @param dev sensor context pointer
- * @param offset count offset value used
- * @return Function result code
- */
-upm_result_t light_set_offset(const light_context dev, float offset);
-
-/**
- * Get sensor aref
- * @param dev sensor context pointer
- * @return Sensor ADC reference voltage
- */
-float light_get_aref(const light_context dev);
-
-/**
- * Get sensor scale
- * @param dev sensor context pointer
- * @return Sensor scale
- */
-float light_get_scale(const light_context dev);
-
-/**
- * Get sensor offset
- * @param dev sensor context pointer
- * @return Sensor offset
- */
-float light_get_offset(const light_context dev);
-
-/**
- * Read normalized value for sensor
- * @param dev sensor context pointer
- * @param *value Normalized value (0.0 -> 1.0)
- * @return Function result code
- */
-upm_result_t light_get_normalized(const light_context dev, float *value);
-
-/**
- * Read raw voltage from the sensor
- * @param dev sensor context pointer
- * @param *value Raw sensor voltage
- * @return Function result code
- */
-upm_result_t light_get_raw_volts(const light_context dev, float *value);
-
-/**
- * Read scaled/offset light value in lux
- * @param dev sensor context pointer
- * @param *value Adjusted sensor value in lux
- * @return Function result code
- */
-upm_result_t light_get_lux(const light_context dev, float *value);
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/light/light.hpp b/src/light/light.hpp
deleted file mode 100644
index bcaef82..0000000
--- a/src/light/light.hpp
+++ /dev/null
@@ -1,179 +0,0 @@
-/*
- * Authors: Brendan Le Foll <brendan.le.foll@intel.com>
- *          Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- *          Sarah Knepper <sarah.knepper@intel.com>
- *          Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014 - 2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <string>
-
-#include "light.h"
-
-namespace upm {
-    /**
-     * @brief Analog Light Sensors Library
-     * @defgroup alight libupm-light
-     * @ingroup seeed analog light gsk
-     */
-
-    /**
-     * @library alight
-     * @sensor light
-     * @comname Analog Light Sensor
-     * @type light
-     * @man seeed
-     * @con analog
-     * @kit gsk
-     *
-     * @brief API for the  Light Sensor
-     *
-     * The light sensor detects the intensity of the ambient light.
-     * As the light intensity of the environment increases, the resistance
-     * of the sensor decreases. This means the raw value from the
-     * analog pin is larger in bright light and smaller in the dark.
-     * A very approximate lux value can also be returned.
-     *
-     * @image html light.jpg
-     * @snippet light.cxx Interesting
-     */
-    class Light {
-    public:
-        /**
-         * Analog light sensor constructor
-         *
-         * @param pin Analog pin to use
-         * @throws std::runtime_error on initialization error
-         */
-        Light(unsigned int pin);
-
-        /**
-         * Light destructor
-         */
-        ~Light();
-
-        /**
-         * Gets the raw value from the AIO pin
-         *
-         * @deprecated This function is deprecated use
-         * getNormalized() instead.
-         * @return Raw value from the ADC
-         * @throws std::runtime_error on error
-         */
-        float raw_value();
-
-        /**
-         * Gets an approximate light value in lux from the sensor
-         *
-         * @return Approximate light reading in lux
-         * @throws std::runtime_error on error
-         */
-        int value();
-
-        /**
-         * Set ADC reference voltage
-         *
-         * @param aref ADC reference voltage
-         */
-        void setAref(float aref);
-
-        /**
-         * Set sensor scale.  This scale is applied to the return value:
-         *     counts = counts * scale
-         *
-         * @param scale count scale value used
-         */
-        void setScale(float scale);
-
-        /**
-         * Set sensor offset.  This offset is applied to the return value:
-         *     value = value + offset
-         *
-         * @param offset count offset value used
-         * @return Function result code
-         */
-        void setOffset(float offset);
-
-        /**
-         * Get sensor aref
-         *
-         * @param dev sensor context pointer
-         * @return Sensor ADC reference voltage
-         */
-        float getAref();
-
-        /**
-         * Get sensor scale
-         *
-         * @param dev sensor context pointer
-         * @return Sensor scale
-         */
-        float getScale();
-
-        /**
-         * Get sensor offset
-         *
-         * @param dev sensor context pointer
-         * @return Sensor offset
-         */
-        float getOffset();
-
-        /**
-         * Read normalized value for sensor
-         *
-         * @param dev sensor context pointer
-         * @param *value Normalized value (0.0 -> 1.0)
-         * @return Function result code
-         * @throws std::runtime_error on error
-         */
-        float getNormalized();
-
-        /**
-         * Read raw voltage from the sensor
-         *
-         * @param dev sensor context pointer
-         * @param *value Raw sensor voltage
-         * @return Function result code
-         * @throws std::runtime_error on error
-         */
-        float getRawVolts();
-
-        /* Sensor name
-         *
-         * @return Sensor name
-         */
-        std::string name()
-        {
-            return std::string("Light Sensor");
-        }
-
-    protected:
-        light_context m_light;
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        Light(const Light&) = delete;
-        Light &operator=(const Light&) = delete;
-    };
-}
diff --git a/src/light/light.json b/src/light/light.json
deleted file mode 100644
index 16d9354..0000000
--- a/src/light/light.json
+++ /dev/null
@@ -1,40 +0,0 @@
-{
-    "Library": "light",
-    "Description": "API for the Light Sensor",
-    "Sensor Class":
-    {
-        "Light":
-        {
-            "Name": "Analog Light Sensor",
-            "Description": "The light sensor detects the intensity of the ambient light. As the light intensity of the environment increases, the resistance of the sensor decreases. This means the raw value from the analog pin is larger in bright light and smaller in the dark. A very approximate lux value can also be returned.",
-            "Aliases": ["light"],
-            "Categories": ["light"],
-            "Connections": ["analog"],
-            "Project Type": ["environmental", "security", "prototyping"],
-            "Manufacturers": ["seeed"],
-            "Kits": ["gsk"],
-            "Image": "light.jpg",
-            "Examples":
-            {
-                "Java": ["Light_Example.java"],
-                "Python": ["light.py"],
-                "Node.js": ["light.js"],
-                "C++": ["light.cxx"],
-                "C": ["light.c"]
-            },
-            "Specifications":
-            {
-                "Operating Voltage": {"unit": "V", "low": 3, "high": 5},
-                "Operating Current": {"unit": "mA", "low": 0.5, "high": 3},
-                "Response Time": {"unit": "ms", "low": 20, "high": 30}
-
-            },
-            "Urls" :
-            {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-Light-Sensor-p-746.html"],
-                "Datasheets": ["http://wiki.seeed.cc/Grove-Light_Sensor/", "https://github.com/SeeedDocument/Grove_Light_Sensor/raw/master/res/LS06-M%CE%A65_datasheet.pdf"],
-                "Schematics": []
-            }
-        }
-    }
-}
diff --git a/src/light/light_fti.c b/src/light/light_fti.c
deleted file mode 100644
index d2ff7e8..0000000
--- a/src/light/light_fti.c
+++ /dev/null
@@ -1,119 +0,0 @@
-/*
- * Author: Noel Eck <noel.eck@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string.h>
-#include <stdlib.h>
-
-#include "light.h"
-#include "upm_fti.h"
-#include "fti/upm_sensor.h"
-#include "fti/upm_raw.h"
-
-/** 
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_light_name[] = "LIGHT";
-const char upm_light_description[] = "Analog light sensor";
-const upm_protocol_t upm_light_protocol[] = {UPM_ANALOG};
-const upm_sensor_t upm_light_category[] = {UPM_RAW};
-
-// forward declarations
-const void* upm_light_get_ft(upm_sensor_t sensor_type);
-void* upm_light_init_str(const char* protocol, const char* params);
-void upm_light_close(void* dev);
-const upm_sensor_descriptor_t upm_light_get_descriptor();
-upm_result_t upm_light_set_offset(const void* dev, float offset);
-upm_result_t upm_light_set_scale(const void* dev, float scale);
-upm_result_t upm_light_get_value(const void* dev, float *value);
-
-/* This sensor implementes 2 function tables */
-/* 1. Generic base function table */
-static const upm_sensor_ft ft_gen =
-{
-    .upm_sensor_init_name = &upm_light_init_str,
-    .upm_sensor_close = &upm_light_close,
-    .upm_sensor_get_descriptor = &upm_light_get_descriptor
-};
-
-/* 2. RAW function table */
-static const upm_raw_ft ft_raw =
-{
-    .upm_raw_set_offset = &upm_light_set_offset,
-    .upm_raw_set_scale = &upm_light_set_scale,
-    .upm_raw_get_value = &upm_light_get_value
-};
-
-const void* upm_light_get_ft(upm_sensor_t sensor_type)
-{
-    switch(sensor_type)
-    {
-        case UPM_SENSOR:
-            return &ft_gen;
-        case UPM_RAW:
-            return &ft_raw;
-        default:
-            return NULL;
-    }
-}
-
-void* upm_light_init_str(const char* protocol, const char* params)
-{
-    fprintf(stderr, "String initialization - not implemented, using ain0: %s\n", __FILENAME__);
-    return light_init(0);
-}
-
-void upm_light_close(void* dev)
-{
-    light_close((light_context)dev);
-}
-
-const upm_sensor_descriptor_t upm_light_get_descriptor()
-{
-    /* Fill in the descriptor */
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_light_name;
-    usd.description = upm_light_description;
-    usd.protocol_size = 1;
-    usd.protocol = upm_light_protocol;
-    usd.category_size = 1;
-    usd.category = upm_light_category;
-
-    return usd;
-}
-
-upm_result_t upm_light_set_offset(const void* dev, float offset)
-{
-    return light_set_offset((light_context)dev, offset);
-}
-
-upm_result_t upm_light_set_scale(const void* dev, float scale)
-{
-    return light_set_scale((light_context)dev, scale);
-}
-
-upm_result_t upm_light_get_value(const void* dev, float *value)
-{
-    return light_get_lux((light_context)dev, value);
-}
diff --git a/src/linefinder/CMakeLists.txt b/src/linefinder/CMakeLists.txt
deleted file mode 100644
index 193728f..0000000
--- a/src/linefinder/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME linefinder
-    DESCRIPTION "Infrared (IR) Based Line Finder"
-    C_HDR linefinder.h
-    C_SRC linefinder.c
-    CPP_HDR linefinder.hpp
-    CPP_SRC linefinder.cxx
-    FTI_SRC linefinder_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa)
diff --git a/src/linefinder/linefinder.c b/src/linefinder/linefinder.c
deleted file mode 100644
index 18e5f08..0000000
--- a/src/linefinder/linefinder.c
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <assert.h>
-
-#include "linefinder.h"
-
-linefinder_context linefinder_init(int pin)
-{
-    linefinder_context dev =
-        (linefinder_context)malloc(sizeof(struct _linefinder_context));
-
-    if (!dev)
-        return NULL;
-
-    dev->gpio = NULL;
-
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        linefinder_close(dev);
-        return NULL;
-    }
-
-    // MRAA contexts...
-    if ( !(dev->gpio = mraa_gpio_init(pin)) )
-    {
-        printf("%s: mraa_gpio_init() failed\n",
-               __FUNCTION__);
-        linefinder_close(dev);
-        return NULL;
-    }
-
-    mraa_gpio_dir(dev->gpio, MRAA_GPIO_IN);
-
-    return dev;
-}
-
-void linefinder_close(linefinder_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->gpio)
-        mraa_gpio_close(dev->gpio);
-
-    free(dev);
-}
-
-bool linefinder_white_detected(const linefinder_context dev)
-{
-    assert(dev != NULL);
-
-    return (!mraa_gpio_read(dev->gpio) ? true : false);
-}
-
-bool linefinder_black_detected(const linefinder_context dev)
-{
-    assert(dev != NULL);
-
-    return (mraa_gpio_read(dev->gpio) ? true : false);
-}
diff --git a/src/linefinder/linefinder.cxx b/src/linefinder/linefinder.cxx
deleted file mode 100644
index 9c93b92..0000000
--- a/src/linefinder/linefinder.cxx
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014-2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "linefinder.hpp"
-
-using namespace upm;
-using namespace std;
-
-LineFinder::LineFinder(int pin) :
-    m_linefinder(linefinder_init(pin))
-{
-  if (!m_linefinder)
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": linefinder_init() failed");
-}
-
-LineFinder::~LineFinder()
-{
-    linefinder_close(m_linefinder);
-}
-
-bool LineFinder::whiteDetected()
-{
-    return linefinder_white_detected(m_linefinder);
-}
-
-bool LineFinder::blackDetected()
-{
-    return linefinder_black_detected(m_linefinder);
-}
diff --git a/src/linefinder/linefinder.h b/src/linefinder/linefinder.h
deleted file mode 100644
index 098671b..0000000
--- a/src/linefinder/linefinder.h
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <upm.h>
-
-#include <mraa/gpio.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    /**
-     * Device context
-     */
-    typedef struct _linefinder_context {
-        mraa_gpio_context gpio;
-    } *linefinder_context;
-
-    /**
-     *  Line Finder inititialization
-     *
-     * @param pin Digital pin to use
-     * @return device context
-     */
-    linefinder_context linefinder_init(int pin);
-
-    /**
-     * LineFinder close
-     *
-     * @param Device context
-     */
-    void linefinder_close(linefinder_context dev);
-
-    /**
-     * Determines whether white has been detected
-     *
-     * @param Device context
-     * @return True if white is detected
-     */
-    bool linefinder_white_detected(const linefinder_context dev);
-
-    /**
-     * Determines whether black has been detected
-     *
-     * @param Device context
-     * @return True if black is detected
-     */
-    bool linefinder_black_detected(const linefinder_context dev);
-
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/linefinder/linefinder.hpp b/src/linefinder/linefinder.hpp
deleted file mode 100644
index 4ad4d21..0000000
--- a/src/linefinder/linefinder.hpp
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014-2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <linefinder.h>
-
-namespace upm {
-    /**
-     * @brief Line Finder Sensor
-     * @defgroup linefinder libupm-linefinder
-     * @ingroup seeed dfrobot gpio color robok
-     */
-
-    /**
-     * @library linefinder
-     * @sensor linefinder
-     * @comname Infrared (IR) Based Line Finder
-     * @altname Grove Line Finder, DFRobot Line Tracking sensor
-     * @type color
-     * @man seeed dfrobot
-     * @con gpio
-     * @kit robok
-     *
-     * @brief API for the  Line Finder Sensor
-     *
-     * UPM module for the Line Finder sensor. It outputs a
-     * digital signal indicating whether it is detecting black on a
-     * white background, or white on a black background.
-     *
-     * @image html linefinder.jpg
-     * @snippet linefinder.cxx Interesting
-     */
-    class LineFinder {
-    public:
-        /**
-         *  Line Finder digital sensor constructor
-         *
-         * @param pin Digital pin to use
-         */
-        LineFinder(int pin);
-
-        /**
-         * LineFinder destructor
-         */
-        ~LineFinder();
-
-        /**
-         * Determines whether white has been detected
-         *
-         * @return True if white is detected
-         */
-        bool whiteDetected();
-
-        /**
-         * Determines whether black has been detected
-         *
-         * @return True if black is detected
-         */
-        bool blackDetected();
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        LineFinder(const LineFinder&) = delete;
-        LineFinder &operator=(const LineFinder&) = delete;
-
-        linefinder_context m_linefinder;
-    };
-}
-
-
diff --git a/src/linefinder/linefinder.json b/src/linefinder/linefinder.json
deleted file mode 100644
index e113a14..0000000
--- a/src/linefinder/linefinder.json
+++ /dev/null
@@ -1,40 +0,0 @@
-{
-    "Library": "linefinder",
-    "Description": "Grove Line Finder Sensor Library",
-    "Sensor Class":
-    {
-        "LineFinder":
-        {
-            "Name": "Infrared (IR) Based Line Finder",
-            "Description": "UPM module for the Line Finder sensor. It outputs a digital signal indicating whether it is detecting black on a white background, or white on a black background.",
-            "Aliases": ["linefinder"],
-            "Categories": ["linefinder"],
-            "Connections": ["gpio"],
-            "Project Type": ["robotics", "prototyping"],
-            "Manufacturers": ["seeed", "dfrobot"],
-            "Kits": ["robok"],
-            "Image": "linefinder.jpg",
-            "Examples":
-            {
-                "Java": ["LineFinder_Example.java"],
-                "Python": ["linefinder.py"],
-                "Node.js": ["linefinder.js"],
-                "C++": ["linefinder.cxx"],
-                "C": ["linefinder.c"]
-            },
-            "Specifications":
-            {
-                "Operating Voltage": {"unit": "V", "low": 2.7, "high": 5.5},
-                "Operating Current": {"unit": "uA", "typ": 210},
-                "Operating Temperature": {"unit": "degC", "low": -40, "high": 125}
-
-            },
-            "Urls" :
-            {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-Line-Finder-v1.1-p-2712.html"],
-                "Datasheets": ["file:///C:/Users/Malachai/Downloads/Lmv358.pdf", "http://wiki.seeed.cc/Grove-Line_Finder/"],
-                "Schematics": ["https://easyeda.com/Seeed/Grove_Line_Finder_v1_1-dfc99c72325e41ff93a451882fd2e143"]
-            }
-        }
-    }
-}
diff --git a/src/linefinder/linefinder_fti.c b/src/linefinder/linefinder_fti.c
deleted file mode 100644
index 10878a1..0000000
--- a/src/linefinder/linefinder_fti.c
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "linefinder.h"
-#include <upm_fti.h>
-
-/**
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_linefinder_name[] = "LINEFINDER";
-const char upm_linefinder_description[] = "Line Finder";
-const upm_protocol_t upm_linefinder_protocol[] = {UPM_GPIO};
-const upm_sensor_t upm_linefinder_category[] = {UPM_BINARY};
-
-// forward declarations
-const void* upm_linefinder_get_ft(upm_sensor_t sensor_type);
-void* upm_linefinder_init_name();
-void upm_linefinder_close(void *dev);
-upm_result_t upm_linefinder_black_detected(void *dev, bool *value);
-
-const upm_sensor_descriptor_t upm_linefinder_get_descriptor()
-{
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_linefinder_name;
-    usd.description = upm_linefinder_description;
-    usd.protocol_size = 1;
-    usd.protocol = upm_linefinder_protocol;
-    usd.category_size = 1;
-    usd.category = upm_linefinder_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-  .upm_sensor_init_name = upm_linefinder_init_name,
-  .upm_sensor_close = upm_linefinder_close,
-};
-
-static const upm_binary_ft bft =
-{
-  .upm_binary_get_value = upm_linefinder_black_detected,
-};
-
-const void* upm_linefinder_get_ft(upm_sensor_t sensor_type)
-{
-  switch(sensor_type)
-    {
-    case UPM_SENSOR:
-      return &ft;
-    case UPM_BINARY:
-      return &bft;
-    default:
-      return NULL;
-    }
-}
-
-void *upm_linefinder_init_name()
-{
-  return NULL;
-}
-
-void upm_linefinder_close(void *dev)
-{
-  linefinder_close((linefinder_context)dev);
-}
-
-upm_result_t upm_linefinder_black_detected(void *dev, bool *value)
-{
-  *value = linefinder_black_detected((linefinder_context)dev);
-
-  return UPM_SUCCESS;
-}
diff --git a/src/lis2ds12/CMakeLists.txt b/src/lis2ds12/CMakeLists.txt
deleted file mode 100644
index 324e052..0000000
--- a/src/lis2ds12/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME lis2ds12
-    DESCRIPTION "3-Axis Digital Accelerometer"
-    C_HDR lis2ds12.h lis2ds12_defs.h
-    C_SRC lis2ds12.c
-    CPP_HDR lis2ds12.hpp
-    CPP_SRC lis2ds12.cxx
-    FTI_SRC lis2ds12_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/lis2ds12/lis2ds12.c b/src/lis2ds12/lis2ds12.c
deleted file mode 100644
index 26cd0ff..0000000
--- a/src/lis2ds12/lis2ds12.c
+++ /dev/null
@@ -1,624 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <assert.h>
-
-#include "upm_utilities.h"
-#include "lis2ds12.h"
-
-// macro for converting a uint8_t low/high pair into a float
-#define INT16_TO_FLOAT(h, l) \
-    (float)( (int16_t)( (l) | ((h) << 8) ) )
-
-// some useful macros to save on typing and text wrapping
-#undef _SHIFT
-#define _SHIFT(x) (_LIS2DS12_##x##_SHIFT)
-
-#undef _MASK
-#define _MASK(x) (_LIS2DS12_##x##_MASK)
-
-#undef _SHIFTMASK
-#define _SHIFTMASK(x) (_MASK(x) << _SHIFT(x))
-
-// SPI CS on and off functions
-static void _csOn(const lis2ds12_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->gpioCS)
-        mraa_gpio_write(dev->gpioCS, 0);
-}
-
-static void _csOff(const lis2ds12_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->gpioCS)
-        mraa_gpio_write(dev->gpioCS, 1);
-}
-
-// init
-lis2ds12_context lis2ds12_init(int bus, int addr, int cs)
-{
-    lis2ds12_context dev =
-        (lis2ds12_context)malloc(sizeof(struct _lis2ds12_context));
-
-    if (!dev)
-        return NULL;
-
-    // zero out context
-    memset((void *)dev, 0, sizeof(struct _lis2ds12_context));
-
-    // make sure MRAA is initialized
-    if (mraa_init() != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed.\n", __FUNCTION__);
-        lis2ds12_close(dev);
-        return NULL;
-    }
-
-    if (addr < 0)
-    {
-        // SPI
-        if (!(dev->spi = mraa_spi_init(bus)))
-        {
-            printf("%s: mraa_spi_init() failed.\n", __FUNCTION__);
-            lis2ds12_close(dev);
-            return NULL;
-        }
-
-        // Only create cs context if we are actually using a valid pin.
-        // A hardware controlled pin should specify cs as -1.
-        if (cs >= 0)
-        {
-            if (!(dev->gpioCS = mraa_gpio_init(cs)))
-            {
-                printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
-                lis2ds12_close(dev);
-                return NULL;
-            }
-            mraa_gpio_dir(dev->gpioCS, MRAA_GPIO_OUT);
-        }
-
-        mraa_spi_mode(dev->spi, MRAA_SPI_MODE0);
-        if (mraa_spi_frequency(dev->spi, 5000000))
-        {
-            printf("%s: mraa_spi_frequency() failed.\n", __FUNCTION__);
-            lis2ds12_close(dev);
-            return NULL;
-        }
-    }
-    else
-    {
-        // I2C
-        if (!(dev->i2c = mraa_i2c_init(bus)))
-        {
-            printf("%s: mraa_i2c_init() failed.\n", __FUNCTION__);
-            lis2ds12_close(dev);
-            return NULL;
-        }
-
-        if (mraa_i2c_address(dev->i2c, addr))
-        {
-            printf("%s: mraa_i2c_address() failed.\n", __FUNCTION__);
-            lis2ds12_close(dev);
-            return NULL;
-        }
-    }
-
-    // check the chip id
-
-    uint8_t chipID = lis2ds12_get_chip_id(dev);
-    if (chipID != LIS2DS12_CHIPID)
-    {
-        printf("%s: invalid chip id: %02x.  Expected %02x\n",
-               __FUNCTION__, chipID, LIS2DS12_CHIPID);
-        lis2ds12_close(dev);
-        return NULL;
-    }
-
-    // reset
-    if (lis2ds12_reset(dev))
-    {
-        printf("%s: lis2ds12_reset() failed.\n", __FUNCTION__);
-        lis2ds12_close(dev);
-        return NULL;
-    }
-
-    // call devinit with default options
-    if (lis2ds12_devinit(dev, LIS2DS12_ODR_100HZ, LIS2DS12_FS_2G))
-    {
-        printf("%s: lis2ds12_devinit() failed.\n", __FUNCTION__);
-        lis2ds12_close(dev);
-        return NULL;
-    }
-
-    return dev;
-}
-
-void lis2ds12_close(lis2ds12_context dev)
-{
-    assert(dev != NULL);
-
-    lis2ds12_uninstall_isr(dev, LIS2DS12_INTERRUPT_INT1);
-    lis2ds12_uninstall_isr(dev, LIS2DS12_INTERRUPT_INT2);
-
-    if (dev->i2c)
-        mraa_i2c_stop(dev->i2c);
-    if (dev->spi)
-        mraa_spi_stop(dev->spi);
-    if (dev->gpioCS)
-        mraa_gpio_close(dev->gpioCS);
-
-    free(dev);
-}
-
-upm_result_t lis2ds12_devinit(const lis2ds12_context dev,
-                              LIS2DS12_ODR_T odr,
-                              LIS2DS12_FS_T fs)
-{
-    assert(dev != NULL);
-
-    // enable register auto-increment
-    uint8_t reg = lis2ds12_read_reg(dev, LIS2DS12_REG_CTRL2);
-    reg |= LIS2DS12_CTRL2_IF_ADD_INC;
-
-    if (lis2ds12_write_reg(dev, LIS2DS12_REG_CTRL2, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    // set our ODR and FS.  Disable output high-pass filter.
-    if (lis2ds12_set_odr(dev, odr)
-        || lis2ds12_set_full_scale(dev, fs)
-        || lis2ds12_enable_hp_filtering(dev, false))
-    {
-        printf("%s: failed to set configuration parameters.\n",
-               __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // settle
-    upm_delay_ms(50);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t lis2ds12_set_odr(const lis2ds12_context dev,
-                              LIS2DS12_ODR_T odr)
-{
-    assert(dev != NULL);
-
-    bool hf_mode = false;
-    uint8_t reg = lis2ds12_read_reg(dev, LIS2DS12_REG_CTRL1);
-
-    // mask out ODR bits
-    reg &= ~_SHIFTMASK(CTRL1_ODR);
-
-    // we encoded an extra bit in LIS2DS12_ODR_T indicating an HF
-    // mode.  Check for it here.
-    if ((int)odr > (int)_MASK(CTRL1_ODR))
-        hf_mode = true;
-
-    // mask it off and set it
-    odr &= _MASK(CTRL1_ODR);
-    reg |= (odr << _SHIFT(CTRL1_ODR));
-
-    // set the HF bit appropriately
-    if (hf_mode)
-        reg |= LIS2DS12_CTRL1_HF_ODR;
-    else
-        reg &= ~LIS2DS12_CTRL1_HF_ODR;
-
-    // we always set the BDU (Block Data Update) bit
-    reg |= LIS2DS12_CTRL1_BDU;
-
-    if (lis2ds12_write_reg(dev, LIS2DS12_REG_CTRL1, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t lis2ds12_set_full_scale(const lis2ds12_context dev,
-                                     LIS2DS12_FS_T fs)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = lis2ds12_read_reg(dev, LIS2DS12_REG_CTRL1);
-
-    // mask out FS bits, add our own
-    reg &= ~_SHIFTMASK(CTRL1_FS);
-    reg |= (fs << _SHIFT(CTRL1_FS));
-
-    if (lis2ds12_write_reg(dev, LIS2DS12_REG_CTRL1, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    // assumes a 16b resolution
-    switch(fs)
-    {
-    case LIS2DS12_FS_2G:
-        dev->accScale = 0.061;
-        break;
-
-    case LIS2DS12_FS_4G:
-        dev->accScale = 0.122;
-        break;
-
-    case LIS2DS12_FS_8G:
-        dev->accScale = 0.244;
-        break;
-
-    case LIS2DS12_FS_16G:
-        dev->accScale = 0.488;
-        break;
-
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t lis2ds12_update(const lis2ds12_context dev)
-{
-    assert(dev != NULL);
-
-    int bufLen = 6; // max
-    uint8_t buf[bufLen];
-
-    if (lis2ds12_read_regs(dev, LIS2DS12_REG_OUT_X_L, buf, bufLen) != bufLen)
-    {
-        printf("%s: lis2ds12_read_regs() failed to read %d bytes\n",
-               __FUNCTION__, bufLen);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // x                       msb     lsb
-    dev->accX = INT16_TO_FLOAT(buf[1], buf[0]);
-
-    // y
-    dev->accY = INT16_TO_FLOAT(buf[3], buf[2]);
-
-    // z
-    dev->accZ = INT16_TO_FLOAT(buf[5], buf[4]);
-
-    // get the temperature...
-
-    int8_t temp = 0;
-    temp = (int8_t)lis2ds12_read_reg(dev, LIS2DS12_REG_OUT_T);
-
-    // 1K/LSB, 25C center point
-    dev->temperature = ((float)temp / 256.0) + 25.0;
-
-    return UPM_SUCCESS;
-}
-
-uint8_t lis2ds12_read_reg(const lis2ds12_context dev, uint8_t reg)
-{
-    assert(dev != NULL);
-
-    if (dev->spi)
-    {
-        reg |= 0x80; // needed for read
-        uint8_t pkt[2] = {reg, 0};
-
-        _csOn(dev);
-        if (mraa_spi_transfer_buf(dev->spi, pkt, pkt, 2))
-        {
-            _csOff(dev);
-            printf("%s: mraa_spi_transfer_buf() failed.\n", __FUNCTION__);
-            return 0xff;
-        }
-        _csOff(dev);
-
-        return pkt[1];
-    }
-    else
-        return (uint8_t)mraa_i2c_read_byte_data(dev->i2c, reg);
-}
-
-int lis2ds12_read_regs(const lis2ds12_context dev, uint8_t reg,
-                       uint8_t *buffer, int len)
-{
-    assert(dev != NULL);
-
-    if (dev->spi)
-    {
-        reg |= 0x80; // needed for read
-
-        uint8_t sbuf[len + 1];
-        memset((char *)sbuf, 0, len + 1);
-        sbuf[0] = reg;
-
-        _csOn(dev);
-        if (mraa_spi_transfer_buf(dev->spi, sbuf, sbuf, len + 1))
-        {
-            _csOff(dev);
-            printf("%s: mraa_spi_transfer_buf() failed.\n", __FUNCTION__);
-            return -1;
-        }
-        _csOff(dev);
-
-        // now copy it into user buffer
-        for (int i=0; i<len; i++)
-            buffer[i] = sbuf[i + 1];
-    }
-    else
-    {
-        if (mraa_i2c_read_bytes_data(dev->i2c, reg, buffer, len) != len)
-            return -1;
-    }
-
-    return len;
-}
-
-upm_result_t lis2ds12_write_reg(const lis2ds12_context dev,
-                                uint8_t reg, uint8_t val)
-{
-    assert(dev != NULL);
-
-    if (dev->spi)
-    {
-        reg &= 0x7f; // mask off 0x80 for writing
-        uint8_t pkt[2] = {reg, val};
-
-        _csOn(dev);
-        if (mraa_spi_transfer_buf(dev->spi, pkt, NULL, 2))
-        {
-            _csOff(dev);
-            printf("%s: mraa_spi_transfer_buf() failed.",
-                   __FUNCTION__);
-
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-        _csOff(dev);
-    }
-    else
-    {
-        if (mraa_i2c_write_byte_data(dev->i2c, val, reg))
-        {
-            printf("%s: mraa_i2c_write_byte_data() failed.",
-                   __FUNCTION__);
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-    }
-
-    return UPM_SUCCESS;
-}
-
-uint8_t lis2ds12_get_chip_id(const lis2ds12_context dev)
-{
-    assert(dev != NULL);
-
-    return lis2ds12_read_reg(dev, LIS2DS12_REG_WHO_AM_I);
-}
-
-void lis2ds12_get_accelerometer(const lis2ds12_context dev,
-                                float *x, float *y, float *z)
-{
-    assert(dev != NULL);
-
-    float scale = dev->accScale / 1000.0;
-
-    if (x)
-        *x = dev->accX * scale;
-
-    if (y)
-        *y = dev->accY * scale;
-
-    if (z)
-        *z = dev->accZ * scale;
-}
-
-float lis2ds12_get_temperature(const lis2ds12_context dev)
-{
-    assert(dev != NULL);
-
-    return dev->temperature;
-}
-
-upm_result_t lis2ds12_reset(const lis2ds12_context dev)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = lis2ds12_read_reg(dev, LIS2DS12_REG_CTRL2);
-
-    reg |= LIS2DS12_CTRL2_SOFT_RESET;
-
-    if (lis2ds12_write_reg(dev, LIS2DS12_REG_CTRL2, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    upm_delay_ms(100);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t lis2ds12_enable_hp_filtering(const lis2ds12_context dev,
-                                          bool filter)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = lis2ds12_read_reg(dev, LIS2DS12_REG_CTRL2);
-
-    if (filter)
-        reg |= LIS2DS12_CTRL2_FDS_SLOPE;
-    else
-        reg &= ~LIS2DS12_CTRL2_FDS_SLOPE;
-
-    if (lis2ds12_write_reg(dev, LIS2DS12_REG_CTRL2, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t lis2ds12_enable_interrupt_latching(const lis2ds12_context dev,
-                                                bool latch)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = lis2ds12_read_reg(dev, LIS2DS12_REG_CTRL3);
-
-    if (latch)
-        reg |= LIS2DS12_CTRL3_LIR;
-    else
-        reg &= ~LIS2DS12_CTRL3_LIR;
-
-    if (lis2ds12_write_reg(dev, LIS2DS12_REG_CTRL3, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t lis2ds12_set_interrupt_active_high(const lis2ds12_context dev,
-                                                bool high)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = lis2ds12_read_reg(dev, LIS2DS12_REG_CTRL3);
-
-    if (high)
-        reg &= ~LIS2DS12_CTRL3_H_LACTIVE;
-    else
-        reg |= LIS2DS12_CTRL3_H_LACTIVE;
-
-    if (lis2ds12_write_reg(dev, LIS2DS12_REG_CTRL3, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t lis2ds12_set_interrupt_push_pull(const lis2ds12_context dev,
-                                              bool pp)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = lis2ds12_read_reg(dev, LIS2DS12_REG_CTRL3);
-
-    if (pp)
-        reg &= ~LIS2DS12_CTRL3_PP_OD;
-    else
-        reg |= LIS2DS12_CTRL3_PP_OD;
-
-    if (lis2ds12_write_reg(dev, LIS2DS12_REG_CTRL3, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t lis2ds12_set_int1_config(const lis2ds12_context dev,
-                                      uint8_t cfg)
-{
-    assert(dev != NULL);
-
-    if (lis2ds12_write_reg(dev, LIS2DS12_REG_CTRL4, cfg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t lis2ds12_set_int2_config(const lis2ds12_context dev,
-                                      uint8_t cfg)
-{
-    assert(dev != NULL);
-
-    if (lis2ds12_write_reg(dev, LIS2DS12_REG_CTRL5, cfg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-uint8_t lis2ds12_get_status(const lis2ds12_context dev)
-{
-    assert(dev != NULL);
-
-    return lis2ds12_read_reg(dev, LIS2DS12_REG_STATUS);
-}
-
-upm_result_t lis2ds12_install_isr(const lis2ds12_context dev,
-                                  LIS2DS12_INTERRUPT_PINS_T intr, int gpio,
-                                  mraa_gpio_edge_t level,
-                                  void (*isr)(void *), void *arg)
-{
-    assert(dev != NULL);
-
-    // delete any existing ISR and GPIO context for this interrupt
-    lis2ds12_uninstall_isr(dev, intr);
-
-    mraa_gpio_context gpio_isr = NULL;
-
-    // create gpio context
-    if (!(gpio_isr = mraa_gpio_init(gpio)))
-    {
-        printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    mraa_gpio_dir(gpio_isr, MRAA_GPIO_IN);
-
-    if (mraa_gpio_isr(gpio_isr, level, isr, arg))
-    {
-        mraa_gpio_close(gpio_isr);
-        printf("%s: mraa_gpio_isr() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    switch (intr)
-    {
-    case LIS2DS12_INTERRUPT_INT1:
-        dev->gpioINT1 = gpio_isr;
-        break;
-
-    case LIS2DS12_INTERRUPT_INT2:
-        dev->gpioINT2 = gpio_isr;
-        break;
-    }
-
-    return UPM_SUCCESS;
-}
-
-void lis2ds12_uninstall_isr(const lis2ds12_context dev,
-                            LIS2DS12_INTERRUPT_PINS_T intr)
-{
-    assert(dev != NULL);
-
-    switch (intr)
-    {
-    case LIS2DS12_INTERRUPT_INT1:
-        if (dev->gpioINT1)
-        {
-            mraa_gpio_isr_exit(dev->gpioINT1);
-            mraa_gpio_close(dev->gpioINT1);
-            dev->gpioINT1 = NULL;
-        }
-        break;
-
-    case LIS2DS12_INTERRUPT_INT2:
-        if (dev->gpioINT2)
-        {
-            mraa_gpio_isr_exit(dev->gpioINT2);
-            mraa_gpio_close(dev->gpioINT2);
-            dev->gpioINT2 = NULL;
-        }
-        break;
-    }
-}
diff --git a/src/lis2ds12/lis2ds12.cxx b/src/lis2ds12/lis2ds12.cxx
deleted file mode 100644
index 086df55..0000000
--- a/src/lis2ds12/lis2ds12.cxx
+++ /dev/null
@@ -1,201 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016-2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <iostream>
-#include <stdexcept>
-#include <string>
-
-#include "lis2ds12.hpp"
-
-using namespace upm;
-using namespace std;
-
-// conversion from Celsius to Fahrenheit
-
-static float c2f(float c)
-{
-    return (c * (9.0 / 5.0) + 32.0);
-}
-
-LIS2DS12::LIS2DS12(int bus, int addr, int cs) :
-    m_lis2ds12(lis2ds12_init(bus, addr, cs))
-{
-    if (!m_lis2ds12)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lis2ds12_init() failed");
-}
-
-LIS2DS12::~LIS2DS12()
-{
-    lis2ds12_close(m_lis2ds12);
-}
-
-void LIS2DS12::init(LIS2DS12_ODR_T odr, LIS2DS12_FS_T fs)
-{
-    if (lis2ds12_devinit(m_lis2ds12, odr, fs))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lis2ds12_devinit() failed");
-}
-
-void LIS2DS12::update()
-{
-    if (lis2ds12_update(m_lis2ds12))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lis2ds12_update() failed");
-}
-
-uint8_t LIS2DS12::readReg(uint8_t reg)
-{
-    return lis2ds12_read_reg(m_lis2ds12, reg);
-}
-
-int LIS2DS12::readRegs(uint8_t reg, uint8_t *buffer, int len)
-{
-    int rv = lis2ds12_read_regs(m_lis2ds12, reg, buffer, len);
-    if (rv != len)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lis2ds12_read_regs() failed");
-
-    return rv;
-}
-
-void LIS2DS12::writeReg(uint8_t reg, uint8_t val)
-{
-    if (lis2ds12_write_reg(m_lis2ds12, reg, val))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lis2ds12_write_reg() failed");
-}
-
-uint8_t LIS2DS12::getChipID()
-{
-    return lis2ds12_get_chip_id(m_lis2ds12);
-}
-
-void LIS2DS12::getAccelerometer(float *x, float *y, float *z)
-{
-    lis2ds12_get_accelerometer(m_lis2ds12, x, y, z);
-}
-
-std::vector<float> LIS2DS12::getAccelerometer()
-{
-    float v[3];
-
-    getAccelerometer(&v[0], &v[1], &v[2]);
-    return std::vector<float>(v, v+3);
-}
-
-float LIS2DS12::getTemperature(bool fahrenheit)
-{
-    float temperature = lis2ds12_get_temperature(m_lis2ds12);
-    if (fahrenheit)
-        return c2f(temperature);
-    else
-        return temperature;
-}
-
-void LIS2DS12::reset()
-{
-    if (lis2ds12_reset(m_lis2ds12))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lis2ds12_reset() failed");
-}
-
-void LIS2DS12::setODR(LIS2DS12_ODR_T odr)
-{
-    if (lis2ds12_set_odr(m_lis2ds12, odr))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lis2ds12_set_odr() failed");
-}
-
-void LIS2DS12::setFullScale(LIS2DS12_FS_T fs)
-{
-    if (lis2ds12_set_full_scale(m_lis2ds12, fs))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lis2ds12_set_full_scale() failed");
-}
-
-void LIS2DS12::enableHPFiltering(bool filter)
-{
-    if (lis2ds12_enable_hp_filtering(m_lis2ds12, filter))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lis2ds12_enable_hp_filtering() failed");
-}
-
-void LIS2DS12::enableInterruptLatching(bool latch)
-{
-    if (lis2ds12_enable_interrupt_latching(m_lis2ds12, latch))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lis2ds12_enable_interrupt_latching() failed");
-}
-
-void LIS2DS12::setInterruptActiveHigh(bool high)
-{
-    if (lis2ds12_set_interrupt_active_high(m_lis2ds12, high))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lis2ds12_set_interrupt_active_high() failed");
-}
-
-void LIS2DS12::setInterruptPushPull(bool pp)
-{
-    if (lis2ds12_set_interrupt_push_pull(m_lis2ds12, pp))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lis2ds12_set_interrupt_push_pull() failed");
-}
-
-void LIS2DS12::setInt1Config(uint8_t cfg)
-{
-    if (lis2ds12_set_int1_config(m_lis2ds12, cfg))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lis2ds12_set_int1_config() failed");
-}
-
-void LIS2DS12::setInt2Config(uint8_t cfg)
-{
-    if (lis2ds12_set_int2_config(m_lis2ds12, cfg))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lis2ds12_set_int2_config() failed");
-}
-
-uint8_t LIS2DS12::getStatus()
-{
-    return lis2ds12_get_status(m_lis2ds12);
-}
-
-void LIS2DS12::installISR(LIS2DS12_INTERRUPT_PINS_T intr, int gpio,
-                          mraa::Edge level,
-                          void (*isr)(void *), void *arg)
-{
-    if (lis2ds12_install_isr(m_lis2ds12, intr, gpio,
-                             (mraa_gpio_edge_t)level, isr, arg))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lis2ds12_install_isr() failed");
-}
-
-void LIS2DS12::uninstallISR(LIS2DS12_INTERRUPT_PINS_T intr)
-{
-    lis2ds12_uninstall_isr(m_lis2ds12, intr);
-}
diff --git a/src/lis2ds12/lis2ds12.h b/src/lis2ds12/lis2ds12.h
deleted file mode 100644
index aa827aa..0000000
--- a/src/lis2ds12/lis2ds12.h
+++ /dev/null
@@ -1,323 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <unistd.h>
-#include <string.h>
-
-#include <mraa/i2c.h>
-#include <mraa/spi.h>
-#include <mraa/gpio.h>
-
-#include "upm.h"
-
-#include "lis2ds12_defs.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    /**
-     * @file lis2ds12.h
-     * @library lis2ds12
-     * @brief C API for the lis2ds12 driver
-     *
-     * @include lis2ds12.c
-     */
-
-    /**
-     * Device context
-     */
-    typedef struct _lis2ds12_context {
-        mraa_i2c_context i2c;
-        mraa_spi_context spi;
-
-        mraa_gpio_context gpioCS; // SPI CS pin
-        mraa_gpio_context gpioINT1;  // intr 1
-        mraa_gpio_context gpioINT2;  // intr 2
-
-        // temperature
-        float temperature;
-
-        // uncompensated acc data
-        float accX;
-        float accY;
-        float accZ;
-
-        // acc scaling
-        float accScale;
-    } *lis2ds12_context;
-
-    /**
-     * LIS2DS12 initialization.
-     *
-     * This device can support both I2C and SPI. For SPI, set the addr
-     * to -1, and specify a positive integer representing the Chip
-     * Select (CS) pin for the cs argument.  If you are using a
-     * hardware CS pin (like Intel Edison with Arduino breakout), then
-     * you can connect the proper pin to the hardware CS pin on your
-     * MCU and supply -1 for cs.
-     *
-     * @param bus I2C or SPI bus to use
-     * @param addr The address for this device, or -1 for SPI
-     * @param cs The gpio pin to use for the SPI Chip Select.  Use -1 for
-     * I2C or for SPI with a hardware controlled pin.
-     * @return The device context, or NULL on error
-     */
-    lis2ds12_context lis2ds12_init(int bus, int addr, int cs);
-
-    /**
-     * LIS2DS12 Destructor
-     *
-     * @param dev The device context
-     */
-    void lis2ds12_close(lis2ds12_context dev);
-
-    /**
-     * Update the internal stored values from sensor data
-     *
-     * @param dev The device context
-     * @return UPM result
-     */
-    upm_result_t lis2ds12_update(const lis2ds12_context dev);
-
-    /**
-     * Return the chip ID
-     *
-     * @param dev The device context
-     * @return The chip ID (LIS2DS12_CHIPID)
-     */
-    uint8_t lis2ds12_get_chip_id(const lis2ds12_context dev);
-
-    /**
-     * Initialize the device and start operation.  This function is
-     * called from lis2ds12_init(), so it will not need to be called by
-     * a user unless the device is reset.
-     *
-     * @param dev The device context
-     * @param odr One of the LIS2DS12_ODR_T values
-     * @param fs One of the LIS2DS12_FS_T values
-     * @return UPM result
-     */
-    upm_result_t lis2ds12_devinit(const lis2ds12_context dev,
-                                  LIS2DS12_ODR_T odr,
-                                  LIS2DS12_FS_T fs);
-
-    /**
-     * Set the output data rate (ODR) of the device
-     *
-     * @param dev The device context
-     * @param odr One of the LIS2DS12_ODR_T values
-     * @return UPM result
-     */
-    upm_result_t lis2ds12_set_odr(const lis2ds12_context dev,
-                                  LIS2DS12_ODR_T odr);
-
-    /**
-     * Set the full scale (FS) of the device.  This device supports a
-     * full scale of 2, 4, 8, and 16G.
-     *
-     * @param dev The device context
-     * @param fs One of the LIS2DS12_FS_T values
-     * @return UPM result
-     */
-    upm_result_t lis2ds12_set_full_scale(const lis2ds12_context dev,
-                                         LIS2DS12_FS_T fs);
-
-    /**
-     * Return accelerometer data gravities (g).  lis2ds12_update()
-     * must have been called prior to calling this method.
-     *
-     * @param dev The device context
-     * @param x Pointer to a floating point value that will have the
-     * current x component placed into it
-     * @param y Pointer to a floating point value that will have the
-     * current y component placed into it
-     * @param z Pointer to a floating point value that will have the
-     * current z component placed into it
-     */
-    void lis2ds12_get_accelerometer(const lis2ds12_context dev,
-                                    float *x, float *y, float *z);
-
-    /**
-     * Return the current measured temperature.  Note, this is not
-     * ambient temperature.  lis2ds12_update() must have been called
-     * prior to calling this method.
-     *
-     * @param dev The device context
-     * @return The temperature in degrees Celsius
-     */
-    float lis2ds12_get_temperature(const lis2ds12_context dev);
-
-    /**
-     * Reset the device as if during a power on reset.  All configured
-     * values are lost when this happens.  You should call
-     * lis2ds12_devinit() afterwards, or at least perform the same
-     * initialization lis2ds12_devinit() does before continuing.
-     *
-     * @param dev The device context
-     * @return UPM result
-     */
-    upm_result_t lis2ds12_reset(const lis2ds12_context dev);
-
-    /**
-     * Enable high pass filtering of the accelerometer axis data.
-     * lis2ds12_devinit() disables this by default.  See the datasheet
-     * for details.
-     *
-     * @param dev The device context
-     * @param filter true to enable filtering, false to disable
-     * @return UPM result
-     */
-    upm_result_t lis2ds12_enable_hp_filtering(const lis2ds12_context dev,
-                                              bool filter);
-
-    /**
-     * Enable or disable interrupt latching.  If latching is disabled,
-     * pulsed is enabled.  See the datasheet for details.
-     *
-     * @param dev The device context
-     * @param latch true to enable latching, false to disable
-     * @return UPM result
-     */
-    upm_result_t lis2ds12_enable_interrupt_latching(const lis2ds12_context dev,
-                                                    bool latch);
-
-    /**
-     * Indicate whether the interrupt should be active high (default)
-     * or active low.  See the datasheet for details.
-     *
-     * @param dev The device context
-     * @param high true for active high, false for active low
-     * @return UPM result
-     */
-    upm_result_t lis2ds12_set_interrupt_active_high(const lis2ds12_context dev,
-                                                    bool high);
-
-    /**
-     * Indicate whether interrupts are push-pull (default) or open
-     * drain.  See the datasheet for details.
-     *
-     * @param dev The device context
-     * @param pp true for push-pull, false for open-drain
-     * @return UPM result
-     */
-    upm_result_t lis2ds12_set_interrupt_push_pull(const lis2ds12_context dev,
-                                                  bool pp);
-
-    /**
-     * Set interrupt 1 configuration.  See the datasheet for details.
-     *
-     * @param dev The device context
-     * @param cfg A bitmask of values from LIS2DS12_CTRL4_BITS_T
-     * @return UPM result
-     */
-    upm_result_t lis2ds12_set_int1_config(const lis2ds12_context dev,
-                                          uint8_t cfg);
-
-    /**
-     * Set interrupt 2 configuration.  See the datasheet for details.
-     *
-     * @param dev The device context
-     * @param cfg A bitmask of values from LIS2DS12_CTRL5_BITS_T
-     * @return UPM result
-     */
-    upm_result_t lis2ds12_set_int2_config(const lis2ds12_context dev,
-                                          uint8_t cfg);
-
-    /**
-     * Return the contents of the status register
-     *
-     * @param dev The device context
-     * @return A bitmask of values from LIS2DS12_STATUS_BITS_T
-     */
-    uint8_t lis2ds12_get_status(const lis2ds12_context dev);
-
-    /**
-     * Install an interrupt handler
-     *
-     * @param dev The device context
-     * @param intr One of the LIS2DS12_INTERRUPT_PINS_T values
-     * specifying which interrupt pin you are installing
-     * @param gpio GPIO pin to use as interrupt pin
-     * @param level The interrupt trigger level (one of mraa_gpio_edge_t
-     * values).  Make sure that you have configured the interrupt pin
-     * properly for whatever level you choose.
-     * @param isr The interrupt handler, accepting a void * argument
-     * @param arg The argument to pass the the interrupt handler
-     * @return UPM result
-     */
-    upm_result_t lis2ds12_install_isr(const lis2ds12_context dev,
-                                      LIS2DS12_INTERRUPT_PINS_T intr, int gpio,
-                                      mraa_gpio_edge_t level,
-                                      void (*isr)(void *), void *arg);
-
-    /**
-     * Uninstall a previously installed interrupt handler
-     *
-     * @param dev The device context
-     * @param intr One of the LIS2DS12_INTERRUPT_PINS_T values
-     * specifying which interrupt pin you are removing
-     */
-    void lis2ds12_uninstall_isr(const lis2ds12_context dev,
-                                LIS2DS12_INTERRUPT_PINS_T intr);
-
-    /**
-     * Read a register
-     *
-     * @param dev The device context
-     * @param reg The register to read
-     * @return The value of the register
-     */
-    uint8_t lis2ds12_read_reg(const lis2ds12_context dev, uint8_t reg);
-
-    /**
-     * Read contiguous registers into a buffer
-     *
-     * @param dev The device context
-     * @param reg The register to start the read from
-     * @param buffer The buffer to store the results
-     * @param len The number of registers to read
-     * @return The number of bytes read, or -1 on error
-     */
-    int lis2ds12_read_regs(const lis2ds12_context dev, uint8_t reg,
-                           uint8_t *buffer, int len);
-
-    /**
-     * Write to a register
-     *
-     * @param dev The device context
-     * @param reg The register to write to
-     * @param val The value to write
-     * @return UPM result
-     */
-    upm_result_t lis2ds12_write_reg(const lis2ds12_context dev,
-                                    uint8_t reg, uint8_t val);
-
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/lis2ds12/lis2ds12.hpp b/src/lis2ds12/lis2ds12.hpp
deleted file mode 100644
index 4534695..0000000
--- a/src/lis2ds12/lis2ds12.hpp
+++ /dev/null
@@ -1,312 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016-2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <vector>
-
-#include <mraa/gpio.hpp>
-#include "lis2ds12.h"
-
-namespace upm {
-
-    /**
-     * @brief LIS2DS12 3-axis Accelerometer
-     * @defgroup lis2ds12 libupm-lis2ds12
-     * @ingroup i2c spi gpio stmicro accelerometer
-     */
-
-    /**
-     * @library lis2ds12
-     * @sensor lis2ds12
-     * @comname Digital 3-axis Accelerometer
-     * @type accelerometer
-     * @man stmicro
-     * @con i2c spi gpio
-     * @web http://www.st.com/en/mems-and-sensors/lis2ds12.html
-     *
-     * @brief API for the LIS2DS12 3-axis Accelerometer
-     *
-     * The LIS2DS12 is an ultra-low-power high performance three-axis
-     * linear accelerometer belonging to the "pico" family which
-     * leverages on the robust and mature manufacturing processes
-     * already used for the production of micromachined
-     * accelerometers.
-     *
-     * The LIS2DS12 has user-selectable full scales of
-     * 2g/4g/8g/16g and is capable of measuring accelerations with
-     * output data rates from 1 Hz to 6400 Hz.
-
-     * Not all functionality of this chip has been implemented in this
-     * driver, however all the pieces are present to add any desired
-     * functionality.  This driver supports both I2C (default) and SPI
-     * operation.
-     *
-     * This device requires 1.8v operation.
-     *
-     * @snippet lis2ds12.cxx Interesting
-     */
-
-    class LIS2DS12 {
-    public:
-
-        /**
-         * LIS2DS12 constructor.
-         *
-         * This device can support both I2C and SPI. For SPI, set the addr
-         * to -1, and specify a positive integer representing the Chip
-         * Select (CS) pin for the cs argument.  If you are using a
-         * hardware CS pin (like edison with arduino breakout), then you
-         * can connect the proper pin to the hardware CS pin on your MCU
-         * and supply -1 for cs.  The default operating mode is I2C.
-         *
-         * @param bus I2C or SPI bus to use
-         * @param addr The address for this device.  -1 for SPI
-         * @param cs The gpio pin to use for the SPI Chip Select.  -1 for
-         * I2C or for SPI with a hardware controlled pin.
-         * @throws std::runtime_error on initialization failure
-         */
-        LIS2DS12(int bus=LIS2DS12_DEFAULT_I2C_BUS,
-                 int addr=LIS2DS12_DEFAULT_I2C_ADDR,
-                 int cs=-1);
-
-        /**
-         * LIS2DS12 destructor
-         */
-        virtual ~LIS2DS12();
-
-        /**
-         * Update the internal stored values from sensor data
-         *
-         * @throws std::runtime_error on failure
-         */
-        void update();
-
-        /**
-         * Return the chip ID
-         *
-         * @return The chip ID
-         */
-        uint8_t getChipID();
-
-        /**
-         * Return accelerometer data in gravities.  update() must have
-         * been called prior to calling this method.
-         *
-         * @param x Pointer to a floating point value that will have the
-         * current x component placed into it
-         * @param y Pointer to a floating point value that will have the
-         * current y component placed into it
-         * @param z Pointer to a floating point value that will have the
-         * current z component placed into it
-         */
-        void getAccelerometer(float *x, float *y, float *z);
-
-        /**
-         * Return accelerometer data in gravities in the form of a
-         * floating point vector.  update() must have been called
-         * prior to calling this method.
-         *
-         * @return A floating point vector containing x, y, and z in
-         * that order
-         */
-        std::vector<float> getAccelerometer();
-
-        /**
-         * Return the current measured temperature.  Note, this is not
-         * ambient temperature.  update() must have been called prior to
-         * calling this method.
-         *
-         * @param fahrenheit true to return data in Fahrenheit, false for
-         * Celicus.  Celsius is the default.
-         * @return The temperature in degrees Celsius or Fahrenheit
-         */
-        float getTemperature(bool fahrenheit=false);
-
-        /**
-         * Initialize the device and start operation.  This function is
-         * called from the constructor so will not typically need to be
-         * called by a user unless the device is reset.
-         *
-         * @param odr One of the LIS2DS12_ODR_T values.  The default is
-         * LIS2DS12_ODR_100HZ
-         * @param fs One of the LIS2DS12_FS_T values.  The default is
-         * LIS2DS12_FS_2G
-         * @throws std::runtime_error on failure
-         */
-        void init(LIS2DS12_ODR_T odr=LIS2DS12_ODR_100HZ,
-                  LIS2DS12_FS_T fs=LIS2DS12_FS_2G);
-
-        /**
-         * Reset the device as if during a power on reset.  All configured
-         * values are lost when this happens.  You should call init()
-         * afterwards, or at least perform the same initialization init()
-         * does before continuing.
-         *
-         * @throws std::runtime_error on failure
-         */
-        void reset();
-
-        /**
-         * Set the output data rate (ODR) of the device
-         *
-         * @param odr One of the LIS2DS12_ODR_T values
-         * @throws std::runtime_error on failure
-         */
-        void setODR(LIS2DS12_ODR_T odr);
-
-        /**
-         * Set the full scale (FS) of the device.  This device supports a
-         * full scale of 2, 4, 8, and 16G.
-         *
-         * @param fs One of the LIS2DS12_FS_T values
-         * @throws std::runtime_error on failure
-         */
-        void setFullScale(LIS2DS12_FS_T fs);
-
-        /**
-         * Enable high pass filtering of the accelerometer axis data.
-         * init() disables this by default.  See the datasheet for
-         * details.
-         *
-         * @param filter true to enable filtering, false to disable
-         * @throws std::runtime_error on failure
-         */
-        void enableHPFiltering(bool filter);
-
-        /**
-         * Enable or disable interrupt latching.  If latching is disabled,
-         * pulsed is enabled.  See the datasheet for details.
-         *
-         * @param latch true to enable latching, false to disable
-         * @throws std::runtime_error on failure
-         */
-        void enableInterruptLatching(bool latch);
-
-        /**
-         * Indicate whether the interrupt should be active high (default)
-         * or active low.  See the datasheet for details.
-         *
-         * @param high true for active high, false for active low
-         * @throws std::runtime_error on failure
-         */
-        void setInterruptActiveHigh(bool high);
-
-        /**
-         * Indicate whether interrupts are push-pull (default) or open
-         * drain.  See the datasheet for details.
-         *
-         * @param pp true for push-pull, false for open-drain
-         * @throws std::runtime_error on failure
-         */
-        void setInterruptPushPull(bool pp);
-
-        /**
-         * Set interrupt 1 configuration.  See the datasheet for details.
-         *
-         * @param cfg A bitmask of values from LIS2DS12_CTRL4_BITS_T
-         * @throws std::runtime_error on failure
-         */
-        void setInt1Config(uint8_t cfg);
-
-        /**
-         * Set interrupt 2 configuration.  See the datasheet for details.
-         *
-         * @param cfg A bitmask of values from LIS2DS12_CTRL5_BITS_T
-         * @throws std::runtime_error on failure
-         */
-        void setInt2Config(uint8_t cfg);
-
-        /**
-         * Return the contents of the status register
-         *
-         * @return A bitmask of values from LIS2DS12_STATUS_BITS_T
-         */
-        uint8_t getStatus();
-
-        /**
-         * install an interrupt handler
-         *
-         * @param intr One of the LIS2DS12_INTERRUPT_PINS_T values
-         * specifying which interrupt pin you are installing
-         * @param gpio GPIO pin to use as interrupt pin
-         * @param level The interrupt trigger level (one of mraa::Edge
-         * values).  Make sure that you have configured the interrupt pin
-         * properly for whatever level you choose.
-         * @param isr The interrupt handler, accepting a void * argument
-         * @param arg The argument to pass the the interrupt handler
-         * @throws std::runtime_error on failure
-         */
-        void installISR(LIS2DS12_INTERRUPT_PINS_T intr, int gpio,
-                        mraa::Edge level,
-                        void (*isr)(void *), void *arg);
-
-        /**
-         * uninstall a previously installed interrupt handler
-         *
-         * @param intr One of the LIS2DS12_INTERRUPT_PINS_T values
-         * specifying which interrupt pin you are removing
-         */
-        void uninstallISR(LIS2DS12_INTERRUPT_PINS_T intr);
-
-        /**
-         * Read a register
-         *
-         * @param reg The register to read
-         * @return The value of the register
-         */
-        uint8_t readReg(uint8_t reg);
-
-        /**
-         * Read contiguous registers into a buffer
-         *
-         * @param reg The register to start the read from
-         * @param buffer The buffer to store the results
-         * @param len The number of registers to read
-         * @return The number of bytes read
-         * @throws std::runtime_error on failure
-         */
-        int readRegs(uint8_t reg, uint8_t *buffer, int len);
-
-        /**
-         * Write to a register
-         *
-         * @param reg The register to write to
-         * @param val The value to write
-         * @throws std::runtime_error on failure
-         */
-        void writeReg(uint8_t reg, uint8_t val);
-
-    protected:
-        lis2ds12_context m_lis2ds12;
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        LIS2DS12(const LIS2DS12&) = delete;
-        LIS2DS12 &operator=(const LIS2DS12&) = delete;
-        
-    };
-}
diff --git a/src/lis2ds12/lis2ds12.i b/src/lis2ds12/lis2ds12.i
deleted file mode 100644
index 0693f94..0000000
--- a/src/lis2ds12/lis2ds12.i
+++ /dev/null
@@ -1,23 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%ignore getAccelerometer(float *, float *, float *);
-#%ignore installISR(LIS2DS12_INTERRUPT_PINS_T , int ,  mraa::Edge, void *, void *);
-
-%define INTERRUPT LIS2DS12_INTERRUPT_PINS_T
-%enddef
-JAVA_ADD_INSTALLISR_INTERRUPT(upm::LIS2DS12)
-
-JAVA_JNI_LOADLIBRARY(javaupm_lis2ds12)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%include "../upm_vectortypes.i"
-%{
-#include "lis2ds12.hpp"
-%}
-%include "lis2ds12_defs.h"
-%include "lis2ds12.hpp"
-/* END Common SWIG syntax */
diff --git a/src/lis2ds12/lis2ds12.json b/src/lis2ds12/lis2ds12.json
deleted file mode 100644
index 9fc4b80..0000000
--- a/src/lis2ds12/lis2ds12.json
+++ /dev/null
@@ -1,38 +0,0 @@
-{
-    "Library": "lis2ds12",
-    "Description": "API for the LIS2DS12 3-axis Accelerometer",
-    "Sensor Class":
-    {
-        "LIS2DS12":
-        {
-            "Name": "Digital 3-axis Accelerometer",
-            "Description": "The LIS2DS12 is an ultra-low-power high performance three-axis linear accelerometer belonging to the \"pico\" family which leverages on the robust and mature manufacturing processes already used for the production of micromachined accelerometers. The LIS2DS12 has user-selectable full scales of 2g/4g/8g/16g and is capable of measuring accelerations with output data rates from 1 Hz to 6400 Hz. Not all functionality of this chip has been implemented in this driver, however all the pieces are present to add any desired functionality.  This driver supports both I2C (default) and SPI operation.",
-            "Aliases": ["lis2ds12"],
-            "Categories": ["accelerometer"],
-            "Connections": ["i2c", "spi", "gpio"],
-            "Project Type": ["imu", "prototyping"],
-            "Manufacturers": ["stmicro"],
-            "Kits": [],
-            "Examples":
-            {
-                "Java": ["LIS2DS12_Example.java"],
-                "Python": ["lis2ds12.py"],
-                "Node.js": ["lis2ds12.js"],
-                "C++": ["lis2ds12.cxx"],
-                "C": ["lis2ds12.c"]
-            },
-            "Specifications":
-            {
-                "Operating Voltage": {"unit": "V", "low": 1.62, "high": 1.98},
-                "Operating Current": {"unit": "uA", "low": 0.7, "high": 150},
-                "Operating Temperature": {"unit": "degC", "low": -40, "high": 85}
-            },
-            "Urls" :
-            {
-                "Product Pages": ["http://www.st.com/en/mems-and-sensors/lis2ds12.html"],
-                "Datasheets": ["http://www.st.com/content/ccc/resource/technical/document/datasheet/ce/32/55/ac/e1/87/46/84/DM00177048.pdf/files/DM00177048.pdf/jcr:content/translations/en.DM00177048.pdf"],
-                "Schematics": []
-            }
-        }
-    }
-}
diff --git a/src/lis2ds12/lis2ds12_defs.h b/src/lis2ds12/lis2ds12_defs.h
deleted file mode 100644
index 22e27f6..0000000
--- a/src/lis2ds12/lis2ds12_defs.h
+++ /dev/null
@@ -1,561 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define LIS2DS12_DEFAULT_I2C_BUS 0
-#define LIS2DS12_DEFAULT_SPI_BUS 0
-#define LIS2DS12_DEFAULT_I2C_ADDR 0x1e
-
-
-#define LIS2DS12_CHIPID 0x43
-
-    // NOTE: Reserved registers must not be written into or permanent
-    // damage can result.  Reading from them may return indeterminate
-    // values.  Registers containing reserved bitfields must be
-    // written as 0.
-
-    /**
-     * LIS2DS12 registers
-     */
-    typedef enum {
-        // 0x00-0x05 reserved
-
-        LIS2DS12_REG_SENSORHUB1_REG               = 0x06,
-        LIS2DS12_REG_SENSORHUB2_REG               = 0x07,
-        LIS2DS12_REG_SENSORHUB3_REG               = 0x08,
-        LIS2DS12_REG_SENSORHUB4_REG               = 0x09,
-        LIS2DS12_REG_SENSORHUB5_REG               = 0x0a,
-        LIS2DS12_REG_SENSORHUB6_REG               = 0x0b,
-
-        LIS2DS12_REG_MODULE_8BIT                  = 0x0c,
-
-        // 0x0d-0x0e reserved
-
-        LIS2DS12_REG_WHO_AM_I                     = 0x0f,
-
-        // 0x10-0x1f reserved
-
-        LIS2DS12_REG_CTRL1                        = 0x20,
-        LIS2DS12_REG_CTRL2                        = 0x21,
-        LIS2DS12_REG_CTRL3                        = 0x22,
-        LIS2DS12_REG_CTRL4                        = 0x23,
-        LIS2DS12_REG_CTRL5                        = 0x24,
-
-        LIS2DS12_REG_FIFO_CTRL                    = 0x25,
-
-        LIS2DS12_REG_OUT_T                        = 0x26,
-
-        LIS2DS12_REG_STATUS                       = 0x27,
-
-        LIS2DS12_REG_OUT_X_L                      = 0x28,
-        LIS2DS12_REG_OUT_X_H                      = 0x29,
-        LIS2DS12_REG_OUT_Y_L                      = 0x2a,
-        LIS2DS12_REG_OUT_Y_H                      = 0x2b,
-        LIS2DS12_REG_OUT_Z_L                      = 0x2c,
-        LIS2DS12_REG_OUT_Z_H                      = 0x2d,
-
-        LIS2DS12_REG_FIFO_THS                     = 0x2e,
-        LIS2DS12_REG_FIFO_SRC                     = 0x2f,
-        LIS2DS12_REG_FIFO_SAMPLES                 = 0x30,
-
-        LIS2DS12_REG_TAP_6D_THS                   = 0x31,
-        LIS2DS12_REG_INT_DUR                      = 0x32,
-
-        LIS2DS12_REG_WAKE_UP_THS                  = 0x33,
-        LIS2DS12_REG_WAKE_UP_DUR                  = 0x34,
-
-        LIS2DS12_REG_FREE_FALL                    = 0x35,
-
-        LIS2DS12_REG_STATUS_DUP                   = 0x36,
-
-        LIS2DS12_REG_WAKE_UP_SRC                  = 0x37,
-
-        LIS2DS12_REG_TAP_SRC                      = 0x38,
-        LIS2DS12_REG_6D_SRC                       = 0x39,
-
-        LIS2DS12_REG_STEP_COUNTER_MINTHS          = 0x3a,
-        LIS2DS12_REG_STEP_COUNTER_L               = 0x3b,
-        LIS2DS12_REG_STEP_COUNTER_H               = 0x3c,
-
-        LIS2DS12_REG_FUNC_CK_GATE                 = 0x3d,
-        LIS2DS12_REG_FUNC_SRC                     = 0x3e,
-        LIS2DS12_REG_FUNC_CTRL                    = 0x3f,
-    } LIS2DS12_REGS_T;
-
-    /**
-     * REG_CTRL1 bits
-     */
-    typedef enum {
-        LIS2DS12_CTRL1_BDU                        = 0x01,
-        LIS2DS12_CTRL1_HF_ODR                     = 0x02,
-
-        LIS2DS12_CTRL1_FS0                        = 0x04,
-        LIS2DS12_CTRL1_FS1                        = 0x08,
-        _LIS2DS12_CTRL1_FS_MASK                   = 3,
-        _LIS2DS12_CTRL1_FS_SHIFT                  = 2,
-
-        LIS2DS12_CTRL1_ODR0                       = 0x10,
-        LIS2DS12_CTRL1_ODR1                       = 0x20,
-        LIS2DS12_CTRL1_ODR2                       = 0x40,
-        LIS2DS12_CTRL1_ODR3                       = 0x80,
-        _LIS2DS12_CTRL1_ODR_MASK                  = 15,
-        _LIS2DS12_CTRL1_ODR_SHIFT                 = 4,
-    } LIS2DS12_CTRL1_BITS_T;
-
-    /**
-     * CTRL1_FS (full scale) values
-     */
-    typedef enum {
-        LIS2DS12_FS_2G                            = 0,
-        // odd ordering in the DS...
-        LIS2DS12_FS_16G                           = 1,
-        LIS2DS12_FS_4G                            = 2,
-        LIS2DS12_FS_8G                            = 3,
-    } LIS2DS12_FS_T;
-
-    /**
-     * CTRL1_ODR (Output Data Rate) values
-     */
-    typedef enum {
-        LIS2DS12_ODR_POWER_DOWN                   = 0,
-
-        // high resolution modes (14 bit resolution)
-
-        LIS2DS12_ODR_12_5HZ                       = 1,
-        LIS2DS12_ODR_25HZ                         = 2,
-        LIS2DS12_ODR_50HZ                         = 3,
-        LIS2DS12_ODR_100HZ                        = 4,
-
-        // The following items (5, 6, 7) have a dual meaning depending
-        // on whether the HF_ODR bit is set, but they use the same
-        // overlapping ODR values for the ODR bitfield.  Since the
-        // bitfield is only 4 bits wide, we add a "virtual" 5th bit to
-        // indicate the HF versions.  This is then screened out in the
-        // code and will set the HF bit according to what is selected
-        // here.
-
-        // CTRL1_HF_ODR == 0 (14 bit resolution)
-        LIS2DS12_ODR_200HZ                        = 5,
-        LIS2DS12_ODR_400HZ                        = 6,
-        LIS2DS12_ODR_800HZ                        = 7,
-
-        // CTRL1_HF_ODR == 1 (12bit resolution). Add 'virtual' bit 5
-        // value (16) for these HF modes, which we will detect and
-        // screen out in the driver.  This simplifies the ODR API.
-        LIS2DS12_ODR_1600HZ                       = (16 + 5),
-        LIS2DS12_ODR_3200HZ                       = (16 + 6),
-        LIS2DS12_ODR_6400HZ                       = (16 + 7),
-
-        // low power modes (10 bit resolution)
-        LIS2DS12_ODR_LP_1HZ                       = 8,
-        LIS2DS12_ODR_LP_12_5HZ                    = 9,
-        LIS2DS12_ODR_LP_25HZ                      = 10,
-        LIS2DS12_ODR_LP_50HZ                      = 11,
-        LIS2DS12_ODR_LP_100HZ                     = 12,
-        LIS2DS12_ODR_LP_200HZ                     = 13,
-        LIS2DS12_ODR_LP_400HZ                     = 14,
-        LIS2DS12_ODR_LP_800HZ                     = 15,
-    } LIS2DS12_ODR_T;
-
-    /**
-     * REG_CTRL2 bits
-     */
-    typedef enum {
-        LIS2DS12_CTRL2_SIM                        = 0x01, // SPI 3 wire enable
-        LIS2DS12_CTRL2_I2C_DISABLE                = 0x02,
-        LIS2DS12_CTRL2_IF_ADD_INC                 = 0x04, // auto-increment
-        LIS2DS12_CTRL2_FDS_SLOPE                  = 0x08,
-        LIS2DS12_CTRL2_FUNC_CFG_ENABLE            = 0x10,
-
-        // 0x20 reserved
-
-        LIS2DS12_CTRL2_SOFT_RESET                 = 0x40,
-        LIS2DS12_CTRL2_BOOT                       = 0x80,
-    } LIS2DS12_CTRL2_BITS_T;
-
-    /**
-     * REG_CTRL3 bits
-     */
-    typedef enum {
-        LIS2DS12_CTRL3_PP_OD                      = 0x01, //push-pull/open-drain
-        LIS2DS12_CTRL3_H_LACTIVE                  = 0x02,
-        LIS2DS12_CTRL3_LIR                        = 0x04,
-        LIS2DS12_CTRL3_TAP_Z_EN                   = 0x08,
-        LIS2DS12_CTRL3_TAP_Y_EN                   = 0x10,
-        LIS2DS12_CTRL3_TAP_X_EN                   = 0x20,
-
-        LIS2DS12_CTRL3_ST0                        = 0x40,
-        LIS2DS12_CTRL3_ST1                        = 0x80,
-        _LIS2DS12_CTRL3_ST_MASK                   = 3,
-        _LIS2DS12_CTRL3_ST_SHIFT                  = 6,
-    } LIS2DS12_CTRL3_BITS_T;
-
-    /**
-     * CTRL3_ST (Self Test) values
-     */
-    typedef enum {
-        LIS2DS12_ST_NORMAL                        = 0,
-        LIS2DS12_ST_POS_SIGN                      = 1,
-        LIS2DS12_ST_NEG_SIGN                      = 2
-    } LIS2DS12_ST_T;
-
-    /**
-     * REG_CTRL4 bits
-     */
-    typedef enum {
-        LIS2DS12_CTRL4_INT1_DRDY                  = 0x01,
-        LIS2DS12_CTRL4_INT1_FTH                   = 0x02,
-        LIS2DS12_CTRL4_INT1_6D                    = 0x04,
-        LIS2DS12_CTRL4_INT1_TAP                   = 0x08,
-        LIS2DS12_CTRL4_INT1_FF                    = 0x10,
-        LIS2DS12_CTRL4_INT1_WU                    = 0x20,
-        LIS2DS12_CTRL4_INT1_S_TAP                 = 0x40,
-        LIS2DS12_CTRL4_INT1_MASTER_DRDY           = 0x80,
-    } LIS2DS12_CTRL4_BITS_T;
-
-    /**
-     * REG_CTRL5 bits
-     */
-    typedef enum {
-        LIS2DS12_CTRL5_INT2_DRDY                  = 0x01,
-        LIS2DS12_CTRL5_INT2_FTH                   = 0x02,
-        LIS2DS12_CTRL5_INT2_STEP_DET              = 0x04,
-        LIS2DS12_CTRL5_INT2_SIG_MOT               = 0x08,
-        LIS2DS12_CTRL5_INT2_TILT                  = 0x10,
-        LIS2DS12_CTRL5_INT2_ON_INT1               = 0x20,
-        LIS2DS12_CTRL5_INT2_BOOT                  = 0x40,
-        LIS2DS12_CTRL5_INT2_DRDY_PULSED           = 0x80,
-    } LIS2DS12_CTRL5_BITS_T;
-
-    /**
-     * REG_FIFO_CTRL bits
-     */
-    typedef enum {
-        LIS2DS12_FIFO_CTRL_IF_CS_PU_DIS           = 0x01,
-
-        // 0x02-0x04 reserved
-
-        LIS2DS12_FIFO_CTRL_MODULE_TO_FIFO         = 0x08,
-        LIS2DS12_FIFO_CTRL_INT2_STEP_COUNT_OV     = 0x10,
-
-        LIS2DS12_FIFO_CTRL_FMODE0                 = 0x20,
-        LIS2DS12_FIFO_CTRL_FMODE1                 = 0x40,
-        LIS2DS12_FIFO_CTRL_FMODE2                 = 0x80,
-        _LIS2DS12_FIFO_CTRL_FMODE_MASK            = 7,
-        _LIS2DS12_FIFO_CTRL_FMODE_SHIFT           = 5,
-    } LIS2DS12_FIFO_CTRL_BITS_T;
-
-    /**
-     * FIFO_CTRL_FMODE (FIFO mode) values
-     */
-    typedef enum {
-        LIS2DS12_FMODE_BYPASS                     = 0,
-        LIS2DS12_FMODE_FIFO                       = 1,
-        // 2 reserved
-        LIS2DS12_FMODE_CONT_TO_FIFO               = 3,
-        LIS2DS12_FMODE_BYPASS_TO_CONT             = 4,
-        // 5 reserved
-        LIS2DS12_FMODE_CONT                       = 6,
-        // 7 reserved
-    } LIS2DS12_FMODE_T;
-
-    /**
-     * REG_STATUS bits
-     */
-    typedef enum {
-        LIS2DS12_STATUS_DRDY                      = 0x01,
-        LIS2DS12_STATUS_FF_IA                     = 0x02,
-        LIS2DS12_STATUS_6D_IA                     = 0x04,
-        LIS2DS12_STATUS_SINGLE_TAP                = 0x08,
-        LIS2DS12_STATUS_DOUBLE_TAP                = 0x10,
-        LIS2DS12_STATUS_SLEEP_STATE               = 0x20,
-        LIS2DS12_STATUS_WU_IA                     = 0x40,
-        LIS2DS12_STATUS_FIFO_THS                  = 0x80,
-    } LIS2DS12_STATUS_BITS_T;
-
-    /**
-     * REG_FIFO_SRC bits
-     */
-    typedef enum {
-        // 0x01-0x10 reserved
-        LIS2DS12_FIFO_SRC_DIFF8                   = 0x20,
-        LIS2DS12_FIFO_SRC_FIFO_OVR                = 0x40,
-        LIS2DS12_FIFO_SRC_FTH                     = 0x80,
-    } LIS2DS12_FIFO_SRC_BITS_T;
-
-    /**
-     * REG_TAP_6D_THS bits
-     */
-    typedef enum {
-        LIS2DS12_TAP_6D_THS_TAP_THS0              = 0x01,
-        LIS2DS12_TAP_6D_THS_TAP_THS1              = 0x02,
-        LIS2DS12_TAP_6D_THS_TAP_THS2              = 0x04,
-        LIS2DS12_TAP_6D_THS_TAP_THS3              = 0x08,
-        LIS2DS12_TAP_6D_THS_TAP_THS4              = 0x10,
-        _LIS2DS12_TAP_6D_THS_TAP_THS_MASK         = 31,
-        _LIS2DS12_TAP_6D_THS_TAP_THS_SHIFT        = 0,
-
-        LIS2DS12_TAP_6D_THS_6D_THS0               = 0x20,
-        LIS2DS12_TAP_6D_THS_6D_THS1               = 0x40,
-        _LIS2DS12_TAP_6D_THS_6D_THS_MASK          = 3,
-        _LIS2DS12_TAP_6D_THS_6D_THS_SHIFT         = 5,
-
-        LIS2DS12_TAP_6D_THS_6D_4D_EN              = 0x80,
-
-    } LIS2DS12_TAP_6D_THS_BITS_T;
-
-    /**
-     * TAP_6D_THS_6D_THS values
-     */
-    typedef enum {
-        LIS2DS12_6D_THS_6                         = 0, // 80 degrees
-        LIS2DS12_6D_THS_11                        = 1, // 70 degrees
-        LIS2DS12_6D_THS_16                        = 2, // 60 degrees
-        LIS2DS12_6D_THS_21                        = 3, // 50 degrees
-    } LIS2DS12_6D_THS_T;
-
-    /**
-     * REG_INT_DUR bits
-     */
-    typedef enum {
-        LIS2DS12_INT_DUR_SHOCK0                   = 0x01,
-        LIS2DS12_INT_DUR_SHOCK1                   = 0x02,
-        _LIS2DS12_INT_DUR_SHOCK_MASK              = 3,
-        _LIS2DS12_INT_DUR_SHOCK_SHIFT             = 0,
-
-        LIS2DS12_INT_DUR_QUIET0                   = 0x04,
-        LIS2DS12_INT_DUR_QUIET1                   = 0x08,
-        _LIS2DS12_INT_DUR_QUIET_MASK              = 3,
-        _LIS2DS12_INT_DUR_QUIET_SHIFT             = 2,
-
-        LIS2DS12_INT_DUR_LAT0                     = 0x10,
-        LIS2DS12_INT_DUR_LAT1                     = 0x20,
-        LIS2DS12_INT_DUR_LAT2                     = 0x40,
-        LIS2DS12_INT_DUR_LAT3                     = 0x80,
-        _LIS2DS12_INT_DUR_LAT_MASK                = 15,
-        _LIS2DS12_INT_DUR_LAT_SHIFT               = 4,
-
-    } LIS2DS12_INT_DUR_BITS_T;
-
-    /**
-     * REG_WAKE_UP_THS bits
-     */
-    typedef enum {
-        LIS2DS12_WAKE_UP_THS_WU_THS0              = 0x01,
-        LIS2DS12_WAKE_UP_THS_WU_THS1              = 0x02,
-        LIS2DS12_WAKE_UP_THS_WU_THS2              = 0x04,
-        LIS2DS12_WAKE_UP_THS_WU_THS3              = 0x08,
-        LIS2DS12_WAKE_UP_THS_WU_THS4              = 0x10,
-        LIS2DS12_WAKE_UP_THS_WU_THS5              = 0x20,
-        _LIS2DS12_WAKE_UP_THS_WU_THS_MASK         = 63,
-        _LIS2DS12_WAKE_UP_THS_WU_THS_SHIFT        = 0,
-
-        LIS2DS12_WAKE_UP_THS_SLEEP_ON             = 0x40,
-        LIS2DS12_WAKE_UP_THS_SINGLE_DOUBLE_TAP    = 0x80,
-    } LIS2DS12_WAKE_UP_THS_BITS_T;
-
-    /**
-     * REG_WAKE_UP_DUR bits
-     */
-    typedef enum {
-        LIS2DS12_WAKE_UP_DUR_SLEEP_DUR0           = 0x01,
-        LIS2DS12_WAKE_UP_DUR_SLEEP_DUR1           = 0x02,
-        LIS2DS12_WAKE_UP_DUR_SLEEP_DUR2           = 0x04,
-        LIS2DS12_WAKE_UP_DUR_SLEEP_DUR3           = 0x08,
-        _LIS2DS12_WAKE_UP_DUR_SLEEP_DUR_MASK      = 15,
-        _LIS2DS12_WAKE_UP_DUR_SLEEP_DUR_SHIFT     = 0,
-
-        LIS2DS12_WAKE_UP_DUR_INT1_FSS7            = 0x10,
-
-        LIS2DS12_WAKE_UP_DUR_WU_DUR0              = 0x20,
-        LIS2DS12_WAKE_UP_DUR_WU_DUR1              = 0x40,
-        _LIS2DS12_WAKE_UP_DUR_WU_DUR_MASK         = 3,
-        _LIS2DS12_WAKE_UP_DUR_WU_DUR_SHIFT        = 5,
-
-        LIS2DS12_WAKE_UP_DUR_FF_DUR5              = 0x80,
-    } LIS2DS12_WAKE_UP_DUR_BITS_T;
-
-    /**
-     * REG_FREE_FALL bits
-     */
-    typedef enum {
-        LIS2DS12_FREE_FALL_FF_THS0                = 0x01,
-        LIS2DS12_FREE_FALL_FF_THS1                = 0x02,
-        LIS2DS12_FREE_FALL_FF_THS2                = 0x04,
-        _LIS2DS12_FREE_FALL_FF_THS_MASK           = 7,
-        _LIS2DS12_FREE_FALL_FF_THS_SHIFT          = 0,
-
-        LIS2DS12_FREE_FALL_FF_DUR0                = 0x08,
-        LIS2DS12_FREE_FALL_FF_DUR1                = 0x10,
-        LIS2DS12_FREE_FALL_FF_DUR2                = 0x20,
-        LIS2DS12_FREE_FALL_FF_DUR3                = 0x40,
-        LIS2DS12_FREE_FALL_FF_DUR4                = 0x80,
-        _LIS2DS12_FREE_FALL_FF_MASK               = 31,
-        _LIS2DS12_FREE_FALL_FF_SHIFT              = 3,
-    } LIS2DS12_FREE_FALL_BITS_T;
-
-    /**
-     * REG_STATUS_DUP bits
-     */
-    typedef enum {
-        LIS2DS12_STATUS_DUP_DRDY                  = 0x01,
-        LIS2DS12_STATUS_DUP_FF_IA                 = 0x02,
-        LIS2DS12_STATUS_DUP_6D_IA                 = 0x04,
-        LIS2DS12_STATUS_DUP_SINGLE_TAP            = 0x08,
-        LIS2DS12_STATUS_DUP_DOUBLE_TAP            = 0x10,
-        LIS2DS12_STATUS_DUP_SLEEP_STATE           = 0x20,
-        LIS2DS12_STATUS_DUP_WU_IA                 = 0x40,
-        LIS2DS12_STATUS_DUP_OVR                   = 0x80,
-    } LIS2DS12_STATUS_DUP_BITS_T;
-
-    /**
-     * REG_WAKE_UP_SRC bits
-     */
-    typedef enum {
-        LIS2DS12_WAKE_UP_SRC_Z_WU                 = 0x01,
-        LIS2DS12_WAKE_UP_SRC_Y_WU                 = 0x02,
-        LIS2DS12_WAKE_UP_SRC_X_WU                 = 0x04,
-
-        LIS2DS12_WAKE_UP_SRC_WU_IA                = 0x08,
-        LIS2DS12_WAKE_UP_SRC_SLEEP_STATE_IA       = 0x10,
-        LIS2DS12_WAKE_UP_SRC_FF_IA                = 0x20,
-
-        // 0x40-0x80 reserved
-    } LIS2DS12_WAKE_UP_SRC_BITS_T;
-
-    /**
-     * REG_TAP_SRC bits
-     */
-    typedef enum {
-        LIS2DS12_TAP_SRC_Z_TAP                    = 0x01,
-        LIS2DS12_TAP_SRC_Y_TAP                    = 0x02,
-        LIS2DS12_TAP_SRC_X_TAP                    = 0x04,
-        LIS2DS12_TAP_SRC_TAP_SIGN                 = 0x08,
-        LIS2DS12_TAP_SRC_DOUBLE_TAP               = 0x10,
-        LIS2DS12_TAP_SRC_SINGLE_TAP               = 0x20,
-        LIS2DS12_TAP_SRC_TAP_IA                   = 0x40,
-
-        // 0x80 reserved
-    } LIS2DS12_TAP_SRC_BITS_T;
-
-    /**
-     * REG_6D_SRC bits
-     */
-    typedef enum {
-        LIS2DS12_6D_SRC_XL                        = 0x01,
-        LIS2DS12_6D_SRC_XH                        = 0x02,
-        LIS2DS12_6D_SRC_YL                        = 0x04,
-        LIS2DS12_6D_SRC_YH                        = 0x08,
-        LIS2DS12_6D_SRC_ZL                        = 0x10,
-        LIS2DS12_6D_SRC_ZH                        = 0x20,
-
-        LIS2DS12_6D_IA                            = 0x40,
-
-        // 0x80 reserved
-    } LIS2DS12_6D_SRC_BITS_T;
-
-    /**
-     * REG_STEP_COUNTER_MINTHS bits
-     */
-    typedef enum {
-        LIS2DS12_STEP_COUNTER_MINTHS_SC_MTHS0     = 0x01,
-        LIS2DS12_STEP_COUNTER_MINTHS_SC_MTHS1     = 0x02,
-        LIS2DS12_STEP_COUNTER_MINTHS_SC_MTHS2     = 0x04,
-        LIS2DS12_STEP_COUNTER_MINTHS_SC_MTHS3     = 0x08,
-        LIS2DS12_STEP_COUNTER_MINTHS_SC_MTHS4     = 0x10,
-        LIS2DS12_STEP_COUNTER_MINTHS_SC_MTHS5     = 0x20,
-        _LIS2DS12_STEP_COUNTER_MINTHS_SC_MTHS5_MASK = 63,
-        _LIS2DS12_STEP_COUNTER_MINTHS_SC_MTHS5_SHIFT = 0,
-
-        LIS2DS12_STEP_COUNTER_MINTHS_PEDO4G       = 0x40,
-        LIS2DS12_STEP_COUNTER_MINTHS_RST_NSTEP    = 0x80,
-    } LIS2DS12_STEP_COUNTER_MINTHS_BITS_T;
-
-    /**
-     * REG_FUNC_CK_GATE bits
-     */
-    typedef enum {
-        LIS2DS12_FUNC_CK_GATE_CK_GATE_FUNC        = 0x01,
-        LIS2DS12_FUNC_CK_GATE_STEP_DETECT         = 0x02,
-        LIS2DS12_FUNC_CK_GATE_RST_PEDO            = 0x04,
-        LIS2DS12_FUNC_CK_GATE_RST_SIGN_MOT        = 0x08,
-        LIS2DS12_FUNC_CK_GATE_SIG_MOT_DETECT      = 0x10,
-
-        LIS2DS12_FUNC_CK_GATE_FS_SRC0             = 0x20,
-        LIS2DS12_FUNC_CK_GATE_FS_SRC1             = 0x40,
-        _LIS2DS12_FUNC_CK_GATE_FS_SRC_MASK        = 3,
-        _LIS2DS12_FUNC_CK_GATE_FS_SRC_SHIFT       = 5,
-
-        LIS2DS12_FUNC_CK_GATE_TILT_INT            = 0x80,
-    } LIS2DS12_FUNC_CK_GATE_BITS_T;
-
-    /**
-     * FUNC_CK_GATE_FS_SRC values
-     */
-    typedef enum {
-        LIS2DS12_FS_SRC_NO_SCALE                  = 0,
-        LIS2DS12_FS_SRC_2G                        = 1,
-        LIS2DS12_FS_SRC_4G                        = 2,
-    } LIS2DS12_FS_SRC_T;
-
-    /**
-     * REG_FUNC_SRC bits
-     */
-    typedef enum {
-        LIS2DS12_FUNC_SRC_SENSORHUB_END_OP        = 0x01,
-        LIS2DS12_FUNC_SRC_MODULE_READY            = 0x02,
-        LIS2DS12_FUNC_SRC_RST_TILT                = 0x04,
-
-        // 0x08-0x80 reserved
-    } LIS2DS12_FUNC_SRC_BITS_T;
-
-    /**
-     * REG_FUNC_CTRL bits
-     */
-    typedef enum {
-        LIS2DS12_FUNC_CTRL_STEP_CNT_ON            = 0x01,
-        LIS2DS12_FUNC_CTRL_SIGN_MOT_ON            = 0x02,
-        LIS2DS12_FUNC_CTRL_MASTER_ON              = 0x04,
-        LIS2DS12_FUNC_CTRL_TUD_EN                 = 0x08,
-        LIS2DS12_FUNC_CTRL_TILT_ON                = 0x10,
-        LIS2DS12_FUNC_CTRL_MODULE_ON              = 0x20,
-
-        // 0x40-0x80 reserved
-    } LIS2DS12_FUNC_CTRL_BITS_T;
-
-    // interrupt selection for installISR() and uninstallISR()
-    typedef enum {
-        LIS2DS12_INTERRUPT_INT1,
-        LIS2DS12_INTERRUPT_INT2
-    } LIS2DS12_INTERRUPT_PINS_T;
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/lis2ds12/lis2ds12_fti.c b/src/lis2ds12/lis2ds12_fti.c
deleted file mode 100644
index 6373f1e..0000000
--- a/src/lis2ds12/lis2ds12_fti.c
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "lis2ds12.h"
-#include "upm_fti.h"
-
-/**
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_lis2ds12_name[] = "LIS2DS12";
-const char upm_lis2ds12_description[] = "Triple Axis Digital Accelerometer";
-const upm_protocol_t upm_lis2ds12_protocol[] = {UPM_I2C, UPM_SPI, UPM_GPIO};
-const upm_sensor_t upm_lis2ds12_category[] = {UPM_ACCELEROMETER};
-
-// forward declarations
-const void *upm_lis2ds12_get_ft(upm_sensor_t sensor_type);
-void *upm_lis2ds12_init_name();
-void upm_lis2ds12_close(void *dev);
-upm_result_t upm_lis2ds12_get_value(void *dev, float *value,
-                                    upm_acceleration_u unit);
-
-const upm_sensor_descriptor_t upm_lis2ds12_get_descriptor()
-{
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_lis2ds12_name;
-    usd.description = upm_lis2ds12_description;
-    usd.protocol_size = 3;
-    usd.protocol = upm_lis2ds12_protocol;
-    usd.category_size = 1;
-    usd.category = upm_lis2ds12_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = upm_lis2ds12_init_name,
-    .upm_sensor_close = upm_lis2ds12_close,
-};
-
-static const upm_acceleration_ft aft =
-{
-    .upm_acceleration_get_value = upm_lis2ds12_get_value
-};
-
-const void *upm_lis2ds12_get_ft(upm_sensor_t sensor_type)
-{
-    switch(sensor_type)
-    {
-    case UPM_SENSOR:
-        return &ft;
-
-    case UPM_ACCELEROMETER:
-        return &aft;
-
-    default:
-        return NULL;
-    }
-}
-
-void *upm_lis2ds12_init_name()
-{
-    return NULL;
-}
-
-
-void upm_lis2ds12_close(void *dev)
-{
-    lis2ds12_close((lis2ds12_context)dev);
-}
-
-upm_result_t upm_lis2ds12_get_value(void *dev, float *value,
-                                    upm_acceleration_u unit)
-{
-    if (lis2ds12_update((lis2ds12_context)dev))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    // no conversion facility in place yet, so we don't do anything
-    // with units
-
-    float x, y, z;
-
-    lis2ds12_get_accelerometer(dev, &x, &y, &z);
-
-    value[0] = x;
-    value[1] = y;
-    value[2] = z;
-
-    return UPM_SUCCESS;
-}
diff --git a/src/lis3dh/CMakeLists.txt b/src/lis3dh/CMakeLists.txt
deleted file mode 100644
index 67fac43..0000000
--- a/src/lis3dh/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME lis3dh
-    DESCRIPTION "3-Axis Digital Accelerometer"
-    C_HDR lis3dh.h lis3dh_defs.h
-    C_SRC lis3dh.c
-    CPP_HDR lis3dh.hpp
-    CPP_SRC lis3dh.cxx
-    FTI_SRC lis3dh_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/lis3dh/lis3dh.c b/src/lis3dh/lis3dh.c
deleted file mode 100644
index d276c6d..0000000
--- a/src/lis3dh/lis3dh.c
+++ /dev/null
@@ -1,809 +0,0 @@
-/*
- * Author: Alex Tereschenko <alext.mkrs@gmail.com>
- * Copyright (c) 2018 Alex Tereschenko.
- *
- * Based on LIS2DS12 module by
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <assert.h>
-#include <unistd.h>
-
-#include "lis3dh.h"
-#include "upm_utilities.h"
-
-// Macro for converting a uint8_t low/high pair into a float
-#define INT16_TO_FLOAT(h, l) (float) ((int16_t)((l) | ((h) << 8)))
-
-// Some useful macros to save on typing and text wrapping
-#undef _SHIFT
-#define _SHIFT(x) (_LIS3DH_##x##_SHIFT)
-
-#undef _MASK
-#define _MASK(x) (_LIS3DH_##x##_MASK)
-
-#undef _SHIFTMASK
-#define _SHIFTMASK(x) (_MASK(x) << _SHIFT(x))
-
-// SPI CS on and off functions
-static void
-_csOn(const lis3dh_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->gpioCS) {
-        mraa_gpio_write(dev->gpioCS, 0);
-    }
-}
-
-static void
-_csOff(const lis3dh_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->gpioCS) {
-        mraa_gpio_write(dev->gpioCS, 1);
-    }
-}
-
-// Init
-lis3dh_context
-lis3dh_init(int bus, int addr, int cs)
-{
-    lis3dh_context dev = (lis3dh_context) malloc(sizeof(struct _lis3dh_context));
-
-    if (!dev) {
-        return NULL;
-    }
-
-    // Zero out context
-    memset((void*) dev, 0, sizeof(struct _lis3dh_context));
-
-    // Make sure MRAA is initialized
-    if (mraa_init() != MRAA_SUCCESS) {
-        printf("%s: mraa_init() failed\n", __FUNCTION__);
-        lis3dh_close(dev);
-        return NULL;
-    }
-
-    if (addr < 0) {
-        // SPI
-        if (!(dev->spi = mraa_spi_init(bus))) {
-            printf("%s: mraa_spi_init() for bus %d failed\n", __FUNCTION__, bus);
-            lis3dh_close(dev);
-            return NULL;
-        }
-
-        // Only create CS context if we are actually using a valid pin.
-        // A hardware controlled pin should specify CS as -1.
-        if (cs >= 0) {
-            if (!(dev->gpioCS = mraa_gpio_init(cs))) {
-                printf("%s: mraa_gpio_init() for CS pin %d failed\n", __FUNCTION__, cs);
-                lis3dh_close(dev);
-                return NULL;
-            }
-            mraa_gpio_dir(dev->gpioCS, MRAA_GPIO_OUT);
-        }
-
-        mraa_spi_mode(dev->spi, MRAA_SPI_MODE0);
-        if (mraa_spi_frequency(dev->spi, 5000000)) {
-            printf("%s: mraa_spi_frequency() failed\n", __FUNCTION__);
-            lis3dh_close(dev);
-            return NULL;
-        }
-    } else {
-        // I2C
-        if (!(dev->i2c = mraa_i2c_init(bus))) {
-            printf("%s: mraa_i2c_init() for bus %d failed\n", __FUNCTION__, bus);
-            lis3dh_close(dev);
-            return NULL;
-        }
-
-        if (mraa_i2c_address(dev->i2c, addr)) {
-            printf("%s: mraa_i2c_address() for address 0x%x failed\n", __FUNCTION__, addr);
-            lis3dh_close(dev);
-            return NULL;
-        }
-    }
-
-    // Check the chip id
-    uint8_t chipID = lis3dh_get_chip_id(dev);
-    if (chipID != LIS3DH_CHIPID) {
-        printf("%s: invalid chip id: %02x, expected %02x\n", __FUNCTION__, chipID, LIS3DH_CHIPID);
-        lis3dh_close(dev);
-        return NULL;
-    }
-
-    // Call devinit with default options
-    if (lis3dh_devinit(dev, LIS3DH_ODR_100HZ, LIS3DH_FS_2G, true)) {
-        printf("%s: lis3dh_devinit() failed\n", __FUNCTION__);
-        lis3dh_close(dev);
-        return NULL;
-    }
-
-    return dev;
-}
-
-void
-lis3dh_close(lis3dh_context dev)
-{
-    assert(dev != NULL);
-
-    lis3dh_uninstall_isr(dev, LIS3DH_INTERRUPT_INT1);
-    lis3dh_uninstall_isr(dev, LIS3DH_INTERRUPT_INT2);
-
-    if (dev->i2c) {
-        mraa_i2c_stop(dev->i2c);
-    }
-
-    if (dev->spi) {
-        mraa_spi_stop(dev->spi);
-    }
-
-    if (dev->gpioCS) {
-        mraa_gpio_close(dev->gpioCS);
-    }
-
-    free(dev);
-}
-
-upm_result_t
-lis3dh_devinit(const lis3dh_context dev, LIS3DH_ODR_T odr, LIS3DH_FS_T fs, bool high_res)
-{
-    assert(dev != NULL);
-
-    // Set high resolution mode, ODR and FS using passed values.
-    // Also unconditionally enable X, Y and Z axes, temperature sensor (and ADC),
-    // BDU mode as well as disable output high-pass filter.
-    if (lis3dh_enable_lp_mode(dev, false) ||
-        lis3dh_enable_hr_mode(dev, high_res) ||
-        lis3dh_enable_axes(dev, true, true, true) ||
-        lis3dh_enable_bdu_mode(dev, true) ||
-        lis3dh_set_odr(dev, odr) ||
-        lis3dh_set_full_scale(dev, fs) ||
-        lis3dh_enable_hp_filtering(dev, false) ||
-        lis3dh_enable_temperature(dev, true)) {
-
-        printf("%s: failed to set configuration parameters\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // Settle
-    upm_delay_ms(50);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t
-lis3dh_enable_axes(const lis3dh_context dev,
-                   bool x_axis_enable,
-                   bool y_axis_enable,
-                   bool z_axis_enable)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = lis3dh_read_reg(dev, LIS3DH_REG_CTRL_REG1);
-
-    // X axis
-    if (x_axis_enable) {
-        reg |= LIS3DH_CTRL_REG1_XEN;
-    } else {
-        reg &= ~LIS3DH_CTRL_REG1_XEN;
-    }
-
-    // Y axis
-    if (y_axis_enable) {
-        reg |= LIS3DH_CTRL_REG1_YEN;
-    } else {
-        reg &= ~LIS3DH_CTRL_REG1_YEN;
-    }
-
-    // Z axis
-    if (z_axis_enable) {
-        reg |= LIS3DH_CTRL_REG1_ZEN;
-    } else {
-        reg &= ~LIS3DH_CTRL_REG1_ZEN;
-    }
-
-    if (lis3dh_write_reg(dev, LIS3DH_REG_CTRL_REG1, reg)) {
-        printf("%s: failed to enable axes\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t
-lis3dh_enable_bdu_mode(const lis3dh_context dev, bool bdu_enable)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = lis3dh_read_reg(dev, LIS3DH_REG_CTRL_REG4);
-
-    if (bdu_enable) {
-        reg |= LIS3DH_CTRL_REG4_BDU;
-    } else {
-        reg &= ~LIS3DH_CTRL_REG4_BDU;
-    }
-
-    if (lis3dh_write_reg(dev, LIS3DH_REG_CTRL_REG4, reg)) {
-        printf("%s: failed to set BDU mode\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t
-lis3dh_enable_lp_mode(const lis3dh_context dev, bool lp_enable)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = lis3dh_read_reg(dev, LIS3DH_REG_CTRL_REG1);
-
-    if (lp_enable) {
-        // Check whether high resolution mode is enabled - enabling both LP and HR is not allowed
-        uint8_t tmp_reg = lis3dh_read_reg(dev, LIS3DH_REG_CTRL_REG4);
-        if (tmp_reg & LIS3DH_CTRL_REG4_HR) {
-            printf("%s: can't enable low power mode, high resolution mode is already enabled\n",
-                   __FUNCTION__);
-            return UPM_ERROR_INVALID_PARAMETER;
-        } else {
-            // We are good - enable low power mode
-            reg |= LIS3DH_CTRL_REG1_LPEN;
-            // Set temperatureFactor according to LP mode bit width (8b).
-            // This is needed to account for left alignment of the temperature data.
-            // We have to shift the data right (== divide by a factor in case of float)
-            // to eliminate "dead" bits.
-            dev->temperatureFactor = 256;
-        }
-    } else {
-        reg &= ~LIS3DH_CTRL_REG1_LPEN;
-        // Set temperatureFactor according to Normal mode bit width (10b)
-        dev->temperatureFactor = 64;
-    }
-
-    if (lis3dh_write_reg(dev, LIS3DH_REG_CTRL_REG1, reg)) {
-        printf("%s: failed to set low power mode\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t
-lis3dh_enable_hr_mode(const lis3dh_context dev, bool hr_enable)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = lis3dh_read_reg(dev, LIS3DH_REG_CTRL_REG4);
-
-    if (hr_enable) {
-        // Check whether low power mode is enabled - enabling both LP and HR is not allowed
-        uint8_t tmp_reg = lis3dh_read_reg(dev, LIS3DH_REG_CTRL_REG1);
-        if (tmp_reg & LIS3DH_CTRL_REG1_LPEN) {
-            printf("%s: can't enable high resolution mode, low power mode is already enabled\n",
-                   __FUNCTION__);
-            return UPM_ERROR_INVALID_PARAMETER;
-        } else {
-            // We are good - enable high resolution mode
-            reg |= LIS3DH_CTRL_REG4_HR;
-        }
-    } else {
-        reg &= ~LIS3DH_CTRL_REG4_HR;
-    }
-
-    // Set the temperature sensor scaling factor appropriately.
-    // Its max is 10 bit for both normal and HR modes.
-    dev->temperatureFactor = 64;
-
-    if (lis3dh_write_reg(dev, LIS3DH_REG_CTRL_REG4, reg)) {
-        printf("%s: failed to set high resolution mode\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t
-lis3dh_enable_normal_mode(const lis3dh_context dev)
-{
-    assert(dev != NULL);
-
-    // There's no special mode bit for Normal - just disable LP and HR
-    if (lis3dh_enable_lp_mode(dev, false) || lis3dh_enable_hr_mode(dev, false)) {
-        printf("%s: failed to enable normal mode\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t
-lis3dh_enable_hp_filtering(const lis3dh_context dev, bool filter)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = lis3dh_read_reg(dev, LIS3DH_REG_CTRL_REG2);
-
-    if (filter) {
-        reg |= LIS3DH_CTRL_REG2_FDS;
-    } else {
-        reg &= ~LIS3DH_CTRL_REG2_FDS;
-    }
-
-    if (lis3dh_write_reg(dev, LIS3DH_REG_CTRL_REG2, reg)) {
-        printf("%s: failed to set HP filter mode\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t
-lis3dh_enable_interrupt_latching(const lis3dh_context dev, bool int1_latch, bool int2_latch)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = lis3dh_read_reg(dev, LIS3DH_REG_CTRL_REG5);
-
-    if (int1_latch) {
-        reg |= LIS3DH_CTRL_REG5_LIR_INT1;
-    } else {
-        reg &= ~LIS3DH_CTRL_REG5_LIR_INT1;
-    }
-
-    if (int2_latch) {
-        reg |= LIS3DH_CTRL_REG5_LIR_INT2;
-    } else {
-        reg &= ~LIS3DH_CTRL_REG5_LIR_INT2;
-    }
-
-    if (lis3dh_write_reg(dev, LIS3DH_REG_CTRL_REG5, reg)) {
-        printf("%s: failed to set interrupt latching mode\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t
-lis3dh_enable_adc(const lis3dh_context dev, bool adc_enable)
-{
-    assert(dev != NULL);
-
-    // BDU mode is a prerequisite
-    if (adc_enable && lis3dh_enable_bdu_mode(dev, true)) {
-        printf("%s: failed to enable BDU mode - a prerequisite for enabling ADC\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    uint8_t reg = lis3dh_read_reg(dev, LIS3DH_REG_TEMP_CFG_REG);
-
-    if (adc_enable) {
-        reg |= LIS3DH_TEMP_CFG_REG_ADC_EN;
-    } else {
-        reg &= ~LIS3DH_TEMP_CFG_REG_ADC_EN;
-    }
-
-    if (lis3dh_write_reg(dev, LIS3DH_REG_TEMP_CFG_REG, reg)) {
-        printf("%s: failed to set ADC mode\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t
-lis3dh_enable_temperature(const lis3dh_context dev, bool temperature_enable)
-{
-    assert(dev != NULL);
-
-    // ADC must be enabled for temperature readings to work
-    if (temperature_enable && lis3dh_enable_adc(dev, true)) {
-        printf("%s: failed to enable ADC - a prerequisite for enabling temperature sensor\n",
-               __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    uint8_t reg = lis3dh_read_reg(dev, LIS3DH_REG_TEMP_CFG_REG);
-
-    if (temperature_enable) {
-        reg |= LIS3DH_TEMP_CFG_REG_TEMP_EN;
-    } else {
-        reg &= ~LIS3DH_TEMP_CFG_REG_TEMP_EN;
-    }
-
-    if (lis3dh_write_reg(dev, LIS3DH_REG_TEMP_CFG_REG, reg)) {
-        printf("%s: failed to set temperature sensor mode\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t
-lis3dh_set_odr(const lis3dh_context dev, LIS3DH_ODR_T odr)
-{
-    assert(dev != NULL);
-
-    bool lp_mode = false;
-    uint8_t reg = lis3dh_read_reg(dev, LIS3DH_REG_CTRL_REG1);
-
-    // Zero out ODR bits
-    reg &= ~_SHIFTMASK(CTRL_REG1_ODR);
-
-    // We encoded an extra bit in LIS3DH_ODR_T indicating an LP mode. Check for it here.
-    if ((int) odr > (int) _MASK(CTRL_REG1_ODR)) {
-        lp_mode = true;
-    }
-
-    // Mask it off and set it
-    odr &= _MASK(CTRL_REG1_ODR);
-    reg |= (odr << _SHIFT(CTRL_REG1_ODR));
-
-    // Set the LPEN bit appropriately
-    lis3dh_enable_lp_mode(dev, lp_mode);
-
-    // Commit our changes
-    if (lis3dh_write_reg(dev, LIS3DH_REG_CTRL_REG1, reg)) {
-        printf("%s: failed to set ODR configuration\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t
-lis3dh_set_full_scale(const lis3dh_context dev, LIS3DH_FS_T fs)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = lis3dh_read_reg(dev, LIS3DH_REG_CTRL_REG4);
-
-    // Mask out FS bits, add our own
-    reg &= ~_SHIFTMASK(CTRL_REG4_FS);
-    reg |= (fs << _SHIFT(CTRL_REG4_FS));
-
-    if (lis3dh_write_reg(dev, LIS3DH_REG_CTRL_REG4, reg)) {
-        printf("%s: failed to set FS configuration\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // Basic sensitivity in g/LSB, calculated for a full 16b resolution.
-    switch (fs) {
-        case LIS3DH_FS_2G:
-            // (2*2) / 2^16
-            dev->accScale = 0.000061;
-            break;
-
-        case LIS3DH_FS_4G:
-            // (4*2) / 2^16
-            dev->accScale = 0.000122;
-            break;
-
-        case LIS3DH_FS_8G:
-            // (8*2) / 2^16
-            dev->accScale = 0.000244;
-            break;
-
-        case LIS3DH_FS_16G:
-            // (16*2) / 2^16
-            dev->accScale = 0.000488;
-            break;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t
-lis3dh_set_interrupt_active_high(const lis3dh_context dev, bool high)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = lis3dh_read_reg(dev, LIS3DH_REG_CTRL_REG6);
-
-    if (high) {
-        reg &= ~LIS3DH_CTRL_REG6_INT_POLARITY;
-    } else {
-        reg |= LIS3DH_CTRL_REG6_INT_POLARITY;
-    }
-
-    if (lis3dh_write_reg(dev, LIS3DH_REG_CTRL_REG6, reg)) {
-        printf("%s: failed to set interrupt polarity mode\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t
-lis3dh_set_int1_config(const lis3dh_context dev, uint8_t cfg)
-{
-    assert(dev != NULL);
-
-    if (lis3dh_write_reg(dev, LIS3DH_REG_CTRL_REG3, cfg)) {
-        printf("%s: failed to set interrupt 1 configuration\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t
-lis3dh_set_int2_config(const lis3dh_context dev, uint8_t cfg)
-{
-    assert(dev != NULL);
-
-    if (lis3dh_write_reg(dev, LIS3DH_REG_CTRL_REG6, cfg)) {
-        printf("%s: failed to set interrupt 2 configuration\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-uint8_t
-lis3dh_read_reg(const lis3dh_context dev, uint8_t reg)
-{
-    assert(dev != NULL);
-
-    if (dev->spi) {
-        // Needed for read
-        reg |= 0x80;
-        uint8_t pkt[2] = { reg, 0 };
-
-        _csOn(dev);
-        if (mraa_spi_transfer_buf(dev->spi, pkt, pkt, 2)) {
-            _csOff(dev);
-            printf("%s: mraa_spi_transfer_buf() failed\n", __FUNCTION__);
-            return 0xFF;
-        }
-        _csOff(dev);
-
-        return pkt[1];
-    } else {
-        return (uint8_t) mraa_i2c_read_byte_data(dev->i2c, reg);
-    }
-}
-
-int
-lis3dh_read_regs(const lis3dh_context dev, uint8_t reg, uint8_t* buffer, int len)
-{
-    assert(dev != NULL);
-
-    if (dev->spi) {
-        // Needed for read with address autoincrement
-        reg |= 0xC0;
-
-        uint8_t sbuf[len + 1];
-        memset((char*) sbuf, 0, len + 1);
-        sbuf[0] = reg;
-
-        _csOn(dev);
-        if (mraa_spi_transfer_buf(dev->spi, sbuf, sbuf, len + 1)) {
-            _csOff(dev);
-            printf("%s: mraa_spi_transfer_buf() failed\n", __FUNCTION__);
-            return -1;
-        }
-        _csOff(dev);
-
-        // Now copy it into user buffer
-        for (int i = 0; i < len; i++) {
-            buffer[i] = sbuf[i + 1];
-        }
-    } else {
-        // Needed for read with address autoincrement
-        reg |= 0x80;
-        if (mraa_i2c_read_bytes_data(dev->i2c, reg, buffer, len) != len) {
-            return -1;
-        }
-    }
-
-    return len;
-}
-
-upm_result_t
-lis3dh_write_reg(const lis3dh_context dev, uint8_t reg, uint8_t val)
-{
-    assert(dev != NULL);
-
-    if (dev->spi) {
-        // Mask off 0x80 for writing
-        reg &= 0x7F;
-        uint8_t pkt[2] = { reg, val };
-
-        _csOn(dev);
-        if (mraa_spi_transfer_buf(dev->spi, pkt, NULL, 2)) {
-            _csOff(dev);
-            printf("%s: mraa_spi_transfer_buf() failed.", __FUNCTION__);
-
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-        _csOff(dev);
-    } else {
-        if (mraa_i2c_write_byte_data(dev->i2c, val, reg)) {
-            printf("%s: mraa_i2c_write_byte_data() failed.", __FUNCTION__);
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t
-lis3dh_update(const lis3dh_context dev)
-{
-    assert(dev != NULL);
-
-    // Max axes data length, 2 bytes per axis * 3 axes
-    const int bufLen = 6;
-    // Max temperature data length
-    const int temperatureBufLen = 2;
-    // We reuse the same array when reading acceleration and then temperature data
-    uint8_t buf[bufLen];
-
-    if (lis3dh_read_regs(dev, LIS3DH_REG_OUT_X_L, buf, bufLen) != bufLen) {
-        printf("%s: lis3dh_read_regs() failed to read %d bytes of axes data\n", __FUNCTION__, bufLen);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // X                       MSB     LSB
-    dev->accX = INT16_TO_FLOAT(buf[1], buf[0]);
-
-    // Y
-    dev->accY = INT16_TO_FLOAT(buf[3], buf[2]);
-
-    // Z
-    dev->accZ = INT16_TO_FLOAT(buf[5], buf[4]);
-
-    // Get the temperature
-    if (lis3dh_read_regs(dev, LIS3DH_REG_OUT_ADC3_L, buf, temperatureBufLen) != temperatureBufLen) {
-        printf("%s: lis3dh_read_regs() failed to read %d bytes of temperature data\n",
-               __FUNCTION__,
-               temperatureBufLen);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    dev->temperature = INT16_TO_FLOAT(buf[1], buf[0]);
-
-    return UPM_SUCCESS;
-}
-
-uint8_t
-lis3dh_get_chip_id(const lis3dh_context dev)
-{
-    assert(dev != NULL);
-
-    return lis3dh_read_reg(dev, LIS3DH_REG_WHO_AM_I);
-}
-
-void
-lis3dh_get_accelerometer(const lis3dh_context dev, float* x, float* y, float* z)
-{
-    assert(dev != NULL);
-
-    if (x) {
-        *x = dev->accX * dev->accScale;
-    }
-
-    if (y) {
-        *y = dev->accY * dev->accScale;
-    }
-
-    if (z) {
-        *z = dev->accZ * dev->accScale;
-    }
-}
-
-float
-lis3dh_get_temperature(const lis3dh_context dev)
-{
-    assert(dev != NULL);
-
-    return (dev->temperature / dev->temperatureFactor);
-}
-
-uint8_t
-lis3dh_get_status(const lis3dh_context dev)
-{
-    assert(dev != NULL);
-
-    return lis3dh_read_reg(dev, LIS3DH_REG_STATUS_REG);
-}
-
-uint8_t
-lis3dh_get_status_aux(const lis3dh_context dev)
-{
-    assert(dev != NULL);
-
-    return lis3dh_read_reg(dev, LIS3DH_REG_STATUS_REG_AUX);
-}
-
-upm_result_t
-lis3dh_install_isr(const lis3dh_context dev,
-                   LIS3DH_INTERRUPT_PINS_T intr,
-                   int gpio,
-                   mraa_gpio_edge_t level,
-                   void (*isr)(void*),
-                   void* arg)
-{
-    assert(dev != NULL);
-
-    // Delete any existing ISR and GPIO context for this interrupt
-    lis3dh_uninstall_isr(dev, intr);
-
-    mraa_gpio_context gpio_isr = NULL;
-
-    // Create GPIO context
-    if (!(gpio_isr = mraa_gpio_init(gpio))) {
-        printf("%s: mraa_gpio_init() failed\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    mraa_gpio_dir(gpio_isr, MRAA_GPIO_IN);
-
-    if (mraa_gpio_isr(gpio_isr, level, isr, arg)) {
-        mraa_gpio_close(gpio_isr);
-        printf("%s: mraa_gpio_isr() failed\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    switch (intr) {
-        case LIS3DH_INTERRUPT_INT1:
-            dev->gpioINT1 = gpio_isr;
-            break;
-
-        case LIS3DH_INTERRUPT_INT2:
-            dev->gpioINT2 = gpio_isr;
-            break;
-    }
-
-    return UPM_SUCCESS;
-}
-
-void
-lis3dh_uninstall_isr(const lis3dh_context dev, LIS3DH_INTERRUPT_PINS_T intr)
-{
-    assert(dev != NULL);
-
-    switch (intr) {
-        case LIS3DH_INTERRUPT_INT1:
-            if (dev->gpioINT1) {
-                mraa_gpio_isr_exit(dev->gpioINT1);
-                mraa_gpio_close(dev->gpioINT1);
-                dev->gpioINT1 = NULL;
-            }
-            break;
-
-        case LIS3DH_INTERRUPT_INT2:
-            if (dev->gpioINT2) {
-                mraa_gpio_isr_exit(dev->gpioINT2);
-                mraa_gpio_close(dev->gpioINT2);
-                dev->gpioINT2 = NULL;
-            }
-            break;
-    }
-}
diff --git a/src/lis3dh/lis3dh.cxx b/src/lis3dh/lis3dh.cxx
deleted file mode 100644
index 64049ce..0000000
--- a/src/lis3dh/lis3dh.cxx
+++ /dev/null
@@ -1,276 +0,0 @@
-/*
- * Author: Alex Tereschenko <alext.mkrs@gmail.com>
- * Copyright (c) 2018 Alex Tereschenko.
- *
- * Based on LIS2DS12 module by
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <stdexcept>
-#include <string>
-#include <unistd.h>
-
-#include "lis3dh.hpp"
-
-using namespace upm;
-using namespace std;
-
-// conversion from Celsius to Fahrenheit
-
-static float
-c2f(float c)
-{
-    return (c * (9.0 / 5.0) + 32.0);
-}
-
-LIS3DH::LIS3DH(int bus, int addr, int cs) : m_lis3dh(lis3dh_init(bus, addr, cs))
-{
-    if (!m_lis3dh) {
-        throw std::runtime_error(string(__FUNCTION__) + ": lis3dh_init() failed");
-    }
-}
-
-LIS3DH::~LIS3DH()
-{
-    lis3dh_close(m_lis3dh);
-}
-
-void
-LIS3DH::init(LIS3DH_ODR_T odr, LIS3DH_FS_T fs, bool high_res)
-{
-    if (lis3dh_devinit(m_lis3dh, odr, fs, high_res)) {
-        throw std::runtime_error(string(__FUNCTION__) + ": lis3dh_devinit() failed");
-    }
-}
-
-void
-LIS3DH::enableAxes(bool x_axis_enable, bool y_axis_enable, bool z_axis_enable)
-{
-    if (lis3dh_enable_axes(m_lis3dh, x_axis_enable, y_axis_enable, z_axis_enable)) {
-        throw std::runtime_error(string(__FUNCTION__) + ": lis3dh_enable_axes() failed");
-    }
-}
-
-void
-LIS3DH::enableBDUMode(bool bdu_enable)
-{
-    if (lis3dh_enable_bdu_mode(m_lis3dh, bdu_enable)) {
-        throw std::runtime_error(string(__FUNCTION__) + ": lis3dh_enable_bdu_mode() failed");
-    }
-}
-
-void
-LIS3DH::enableLPMode(bool lp_enable)
-{
-    if (lis3dh_enable_lp_mode(m_lis3dh, lp_enable)) {
-        throw std::runtime_error(string(__FUNCTION__) + ": lis3dh_enable_lp_mode() failed");
-    }
-}
-
-void
-LIS3DH::enableHRMode(bool hr_enable)
-{
-    if (lis3dh_enable_hr_mode(m_lis3dh, hr_enable)) {
-        throw std::runtime_error(string(__FUNCTION__) + ": lis3dh_enable_hr_mode() failed");
-    }
-}
-
-void
-LIS3DH::enableNormalMode()
-{
-    if (lis3dh_enable_normal_mode(m_lis3dh)) {
-        throw std::runtime_error(string(__FUNCTION__) + ": lis3dh_enable_normal_mode() failed");
-    }
-}
-
-void
-LIS3DH::enableHPFiltering(bool filter)
-{
-    if (lis3dh_enable_hp_filtering(m_lis3dh, filter)) {
-        throw std::runtime_error(string(__FUNCTION__) + ": lis3dh_enable_hp_filtering() failed");
-    }
-}
-
-void
-LIS3DH::enableInterruptLatching(bool int1_latch, bool int2_latch)
-{
-    if (lis3dh_enable_interrupt_latching(m_lis3dh, int1_latch, int2_latch)) {
-        throw std::runtime_error(string(__FUNCTION__) +
-                                 ": lis3dh_enable_interrupt_latching() failed");
-    }
-}
-
-void
-LIS3DH::enableADC(bool adc_enable)
-{
-    if (lis3dh_enable_adc(m_lis3dh, adc_enable)) {
-        throw std::runtime_error(string(__FUNCTION__) + ": lis3dh_enable_adc() failed");
-    }
-}
-
-void
-LIS3DH::enableTemperature(bool temperature_enable)
-{
-    if (lis3dh_enable_temperature(m_lis3dh, temperature_enable)) {
-        throw std::runtime_error(string(__FUNCTION__) + ": lis3dh_enable_temperature() failed");
-    }
-}
-
-void
-LIS3DH::setODR(LIS3DH_ODR_T odr)
-{
-    if (lis3dh_set_odr(m_lis3dh, odr)) {
-        throw std::runtime_error(string(__FUNCTION__) + ": lis3dh_set_odr() failed");
-    }
-}
-
-void
-LIS3DH::setFullScale(LIS3DH_FS_T fs)
-{
-    if (lis3dh_set_full_scale(m_lis3dh, fs)) {
-        throw std::runtime_error(string(__FUNCTION__) + ": lis3dh_set_full_scale() failed");
-    }
-}
-
-void
-LIS3DH::setInterruptActiveHigh(bool high)
-{
-    if (lis3dh_set_interrupt_active_high(m_lis3dh, high)) {
-        throw std::runtime_error(string(__FUNCTION__) +
-                                 ": lis3dh_set_interrupt_active_high() failed");
-    }
-}
-
-void
-LIS3DH::setInt1Config(uint8_t cfg)
-{
-    if (lis3dh_set_int1_config(m_lis3dh, cfg)) {
-        throw std::runtime_error(string(__FUNCTION__) + ": lis3dh_set_int1_config() failed");
-    }
-}
-
-void
-LIS3DH::setInt2Config(uint8_t cfg)
-{
-    if (lis3dh_set_int2_config(m_lis3dh, cfg)) {
-        throw std::runtime_error(string(__FUNCTION__) + ": lis3dh_set_int2_config() failed");
-    }
-}
-
-uint8_t
-LIS3DH::readReg(uint8_t reg)
-{
-    return lis3dh_read_reg(m_lis3dh, reg);
-}
-
-int
-LIS3DH::readRegs(uint8_t reg, uint8_t* buffer, int len)
-{
-    int rv = lis3dh_read_regs(m_lis3dh, reg, buffer, len);
-    if (rv != len) {
-        throw std::runtime_error(string(__FUNCTION__) + ": lis3dh_read_regs() failed");
-    }
-
-    return rv;
-}
-
-void
-LIS3DH::writeReg(uint8_t reg, uint8_t val)
-{
-    if (lis3dh_write_reg(m_lis3dh, reg, val)) {
-        throw std::runtime_error(string(__FUNCTION__) + ": lis3dh_write_reg() failed");
-    }
-}
-
-void
-LIS3DH::update()
-{
-    if (lis3dh_update(m_lis3dh)) {
-        throw std::runtime_error(string(__FUNCTION__) + ": lis3dh_update() failed");
-    }
-}
-
-uint8_t
-LIS3DH::getChipID()
-{
-    return lis3dh_get_chip_id(m_lis3dh);
-}
-
-void
-LIS3DH::getAccelerometer(float* x, float* y, float* z)
-{
-    lis3dh_get_accelerometer(m_lis3dh, x, y, z);
-}
-
-std::vector<float>
-LIS3DH::getAccelerometer()
-{
-    float v[3];
-
-    getAccelerometer(&v[0], &v[1], &v[2]);
-    return std::vector<float>(v, v + 3);
-}
-
-float
-LIS3DH::getTemperature(bool fahrenheit)
-{
-    float temperature = lis3dh_get_temperature(m_lis3dh);
-    if (fahrenheit) {
-        return c2f(temperature);
-    } else {
-        return temperature;
-    }
-}
-
-uint8_t
-LIS3DH::getStatus()
-{
-    return lis3dh_get_status(m_lis3dh);
-}
-
-uint8_t
-LIS3DH::getStatusAux()
-{
-    return lis3dh_get_status_aux(m_lis3dh);
-}
-
-void
-LIS3DH::installISR(LIS3DH_INTERRUPT_PINS_T intr,
-                   int gpio,
-                   mraa::Edge level,
-                   void (*isr)(void*),
-                   void* arg)
-{
-    if (lis3dh_install_isr(m_lis3dh, intr, gpio, (mraa_gpio_edge_t) level, isr, arg)) {
-        throw std::runtime_error(string(__FUNCTION__) + ": lis3dh_install_isr() failed");
-    }
-}
-
-void
-LIS3DH::uninstallISR(LIS3DH_INTERRUPT_PINS_T intr)
-{
-    lis3dh_uninstall_isr(m_lis3dh, intr);
-}
diff --git a/src/lis3dh/lis3dh.h b/src/lis3dh/lis3dh.h
deleted file mode 100644
index 7db3b33..0000000
--- a/src/lis3dh/lis3dh.h
+++ /dev/null
@@ -1,382 +0,0 @@
-/*
- * Author: Alex Tereschenko <alext.mkrs@gmail.com>
- * Copyright (c) 2018 Alex Tereschenko.
- *
- * Based on LIS2DS12 module by
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string.h>
-#include <unistd.h>
-
-#include <mraa/gpio.h>
-#include <mraa/i2c.h>
-#include <mraa/spi.h>
-
-#include "upm.h"
-
-#include "lis3dh_defs.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @file lis3dh.h
- * @library lis3dh
- * @brief C API for the lis3dh driver
- *
- * @include lis3dh.c
- */
-
-/**
- * Device context
- */
-typedef struct _lis3dh_context {
-    mraa_i2c_context i2c;
-    mraa_spi_context spi;
-
-    mraa_gpio_context gpioCS;   // SPI CS pin
-    mraa_gpio_context gpioINT1; // Interrupt 1
-    mraa_gpio_context gpioINT2; // Interrupt 2
-
-    // Uncompensated temperature data
-    float temperature;
-
-    // Temperature scaling factor. It accounts for storing 8b or 10b actual
-    // data in 16b register pair.
-    float temperatureFactor;
-
-    // Uncompensated acceleration data
-    float accX;
-    float accY;
-    float accZ;
-
-    // Acceleration scaling - used to calculate actual acceleration,
-    // depending on sensor working mode (low power/normal/high resolution)
-    float accScale;
-} * lis3dh_context;
-
-/**
- * LIS3DH initialization.
- *
- * This device can support both I2C and SPI. For SPI, set the addr
- * to -1, and specify a positive integer representing the Chip
- * Select (CS) pin for the cs argument. If you are using a
- * hardware CS pin (like Intel Edison with Arduino breakout), then
- * you can connect the proper pin to the hardware CS pin on your
- * MCU and supply -1 for cs.
- *
- * @param bus I2C or SPI bus to use
- * @param addr The address for this device, or -1 for SPI
- * @param cs The gpio pin to use for the SPI Chip Select. Use -1 for
- * I2C or for SPI with a hardware controlled pin.
- * @return The device context, or NULL on error
- */
-lis3dh_context lis3dh_init(int bus, int addr, int cs);
-
-/**
- * LIS3DH Destructor
- *
- * @param dev The device context
- */
-void lis3dh_close(lis3dh_context dev);
-
-/**
- * Initialize the device and start operation. This function is
- * called from lis3dh_init(), so it will not need to be called by
- * a user unless the device is reset.
- *
- * @param dev The device context
- * @param odr One of the LIS3DH_ODR_T values
- * @param fs One of the LIS3DH_FS_T values
- * @param high_res true to enable high resolution mode, false to disable
- * @return UPM result
- */
-upm_result_t
-lis3dh_devinit(const lis3dh_context dev, LIS3DH_ODR_T odr, LIS3DH_FS_T fs, bool high_res);
-
-/**
- * Enable or disable specific axes.
- *
- * @param dev The device context
- * @param x_axis_enable true to enable X axis, false to disable
- * @param y_axis_enable true to enable Y axis, false to disable
- * @param z_axis_enable true to enable Z axis, false to disable
- * @return UPM result
- */
-upm_result_t lis3dh_enable_axes(const lis3dh_context dev,
-                                bool x_axis_enable,
-                                bool y_axis_enable,
-                                bool z_axis_enable);
-
-/**
- * Enable or disable Block Data Update (BDU) mode.
- *
- * @param dev The device context
- * @param bdu_enable true to enable BDU mode, false to disable
- * @return UPM result
- */
-upm_result_t lis3dh_enable_bdu_mode(const lis3dh_context dev, bool bdu_enable);
-
-/**
- * Enable or disable Low Power (LP) mode. Checks if mutually exclusive
- * High Resolution (HR) mode is enabled and bails out if yes.
- *
- * @param dev The device context
- * @param lp_enable true to enable LP mode, false to disable
- * @return UPM result
- */
-upm_result_t lis3dh_enable_lp_mode(const lis3dh_context dev, bool lp_enable);
-
-/**
- * Enable or disable High Resolution (HR) mode. Checks if mutually exclusive
- * Low Power (LP) mode is enabled and bails out if yes.
- *
- * @param dev The device context
- * @param hr_enable true to enable HR mode, false to disable
- * @return UPM result
- */
-upm_result_t lis3dh_enable_hr_mode(const lis3dh_context dev, bool hr_enable);
-
-/**
- * Enable Normal mode by explicitly disabling LP and HR ones.
- * Note that there's no "disable" part as it's generally unknown, which mode
- * we were in previously. To get out of Normal mode, just enable HR or LP one.
- *
- * @param dev The device context
- * @return UPM result
- */
-upm_result_t lis3dh_enable_normal_mode(const lis3dh_context dev);
-
-/**
- * Enable high pass filtering of the accelerometer axis data.
- * lis3dh_devinit() disables this by default. See the datasheet
- * for details.
- *
- * @param dev The device context
- * @param filter true to enable filtering, false to disable
- * @return UPM result
- */
-upm_result_t lis3dh_enable_hp_filtering(const lis3dh_context dev, bool filter);
-
-/**
- * Enable or disable built-in Analog-to-Digital Converter (ADC).
- *
- * @param dev The device context
- * @param adc_enable true to enable ADC, false to disable
- * @return UPM result
- */
-upm_result_t lis3dh_enable_adc(const lis3dh_context dev, bool adc_enable);
-
-/**
- * Enable or disable built-in temperature sensor. It depends on ADC being
- * enabled, so we enable it unconditionally. See datasheet for details.
- *
- * @param dev The device context
- * @param temperature_enable true to enable temp sensor, false to disable
- * @return UPM result
- */
-upm_result_t lis3dh_enable_temperature(const lis3dh_context dev, bool temperature_enable);
-
-/**
- * Enable or disable interrupt latching for INT1 and INT2.
- * See the datasheet for details.
- *
- * @param dev The device context
- * @param int1_latch true to enable latching for INT1, false to disable
- * @param int2_latch true to enable latching for INT2, false to disable
- * @return UPM result
- */
-upm_result_t
-lis3dh_enable_interrupt_latching(const lis3dh_context dev, bool int1_latch, bool int2_latch);
-
-/**
- * Set the output data rate (ODR) of the device
- *
- * @param dev The device context
- * @param odr One of the LIS3DH_ODR_T values
- * @return UPM result
- */
-upm_result_t lis3dh_set_odr(const lis3dh_context dev, LIS3DH_ODR_T odr);
-
-/**
- * Set the full scale (FS) of the device. This device supports a
- * full scale of 2, 4, 8, and 16G.
- *
- * @param dev The device context
- * @param fs One of the LIS3DH_FS_T values
- * @return UPM result
- */
-upm_result_t lis3dh_set_full_scale(const lis3dh_context dev, LIS3DH_FS_T fs);
-
-/**
- * Indicate whether INT1 and INT2 interrupts should be active high (default)
- * or active low. See the datasheet for details.
- *
- * @param dev The device context
- * @param high true for active high, false for active low
- * @return UPM result
- */
-upm_result_t lis3dh_set_interrupt_active_high(const lis3dh_context dev, bool high);
-
-/**
- * Set interrupt 1 configuration. See the datasheet for details.
- *
- * @param dev The device context
- * @param cfg A bitmask of values from LIS3DH_CTRL_REG3_BITS_T
- * @return UPM result
- */
-upm_result_t lis3dh_set_int1_config(const lis3dh_context dev, uint8_t cfg);
-
-/**
- * Set interrupt 2 configuration. See the datasheet for details.
- *
- * @param dev The device context
- * @param cfg A bitmask of values from LIS3DH_CTRL_REG6_BITS_T
- * @return UPM result
- */
-upm_result_t lis3dh_set_int2_config(const lis3dh_context dev, uint8_t cfg);
-
-/**
- * Read a register
- *
- * @param dev The device context
- * @param reg The register to read
- * @return The value of the register
- */
-uint8_t lis3dh_read_reg(const lis3dh_context dev, uint8_t reg);
-
-/**
- * Read contiguous registers into a buffer
- *
- * @param dev The device context
- * @param reg The register to start the read from
- * @param buffer The buffer to store the results
- * @param len The number of registers to read
- * @return The number of bytes read, or -1 on error
- */
-int lis3dh_read_regs(const lis3dh_context dev, uint8_t reg, uint8_t* buffer, int len);
-
-/**
- * Write to a register
- *
- * @param dev The device context
- * @param reg The register to write to
- * @param val The value to write
- * @return UPM result
- */
-upm_result_t lis3dh_write_reg(const lis3dh_context dev, uint8_t reg, uint8_t val);
-
-/**
- * Update the internal stored values from sensor data
- *
- * @param dev The device context
- * @return UPM result
- */
-upm_result_t lis3dh_update(const lis3dh_context dev);
-
-/**
- * Return the chip ID
- *
- * @param dev The device context
- * @return The chip ID (LIS3DH_CHIPID)
- */
-uint8_t lis3dh_get_chip_id(const lis3dh_context dev);
-
-/**
- * Return accelerometer data gravities (g). lis3dh_update()
- * must have been called prior to calling this method.
- *
- * @param dev The device context
- * @param x Pointer to a floating point value that will have the
- * current x component placed into it
- * @param y Pointer to a floating point value that will have the
- * current y component placed into it
- * @param z Pointer to a floating point value that will have the
- * current z component placed into it
- */
-void lis3dh_get_accelerometer(const lis3dh_context dev, float* x, float* y, float* z);
-
-/**
- * Return the current measured temperature. Note, this is not
- * ambient temperature. lis3dh_update() must have been called
- * prior to calling this method.
- *
- * @param dev The device context
- * @return The temperature in degrees Celsius
- */
-float lis3dh_get_temperature(const lis3dh_context dev);
-
-/**
- * Return the contents of the status register
- *
- * @param dev The device context
- * @return A bitmask of values from LIS3DH_STATUS_REG_BITS_T
- */
-uint8_t lis3dh_get_status(const lis3dh_context dev);
-
-/**
- * Return the contents of the status aux register
- *
- * @param dev The device context
- * @return A bitmask of values from LIS3DH_STATUS_REG_AUX_BITS_T
- */
-uint8_t lis3dh_get_status_aux(const lis3dh_context dev);
-
-/**
- * Install an interrupt handler
- *
- * @param dev The device context
- * @param intr One of the LIS3DH_INTERRUPT_PINS_T values
- * specifying which interrupt pin you are installing
- * @param gpio GPIO pin to use as interrupt pin
- * @param level The interrupt trigger level (one of mraa_gpio_edge_t
- * values). Make sure that you have configured the interrupt pin
- * properly for whatever level you choose.
- * @param isr The interrupt handler, accepting a void * argument
- * @param arg The argument to pass the the interrupt handler
- * @return UPM result
- */
-upm_result_t lis3dh_install_isr(const lis3dh_context dev,
-                                LIS3DH_INTERRUPT_PINS_T intr,
-                                int gpio,
-                                mraa_gpio_edge_t level,
-                                void (*isr)(void*),
-                                void* arg);
-
-/**
- * Uninstall a previously installed interrupt handler
- *
- * @param dev The device context
- * @param intr One of the LIS3DH_INTERRUPT_PINS_T values
- * specifying which interrupt pin you are removing
- */
-void lis3dh_uninstall_isr(const lis3dh_context dev, LIS3DH_INTERRUPT_PINS_T intr);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/lis3dh/lis3dh.hpp b/src/lis3dh/lis3dh.hpp
deleted file mode 100644
index 4e31158..0000000
--- a/src/lis3dh/lis3dh.hpp
+++ /dev/null
@@ -1,368 +0,0 @@
-/*
- * Author: Alex Tereschenko <alext.mkrs@gmail.com>
- * Copyright (c) 2018 Alex Tereschenko.
- *
- * Based on LIS2DS12 module by
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <vector>
-
-#include "lis3dh.h"
-#include <mraa/gpio.hpp>
-
-namespace upm
-{
-/**
- * @brief LIS3DH 3-axis Accelerometer
- * @defgroup lis3dh libupm-lis3dh
- * @ingroup i2c spi gpio stmicro accelerometer
- */
-
-/**
- * @library lis3dh
- * @sensor lis3dh
- * @comname Digital 3-axis Accelerometer
- * @type accelerometer
- * @man stmicro
- * @con i2c spi gpio
- * @web http://www.st.com/en/mems-and-sensors/lis3dh.html
- *
- * @brief API for the LIS3DH 3-axis Accelerometer
- *
- * The LIS3DH is an ultra-low-power high performance three-axis
- * linear accelerometer belonging to the "nano" family which
- * leverages on the robust and mature manufacturing processes
- * already used for the production of micromachined
- * accelerometers.
- *
- * The LIS3DH has user-selectable full scales of
- * 2g/4g/8g/16g and is capable of measuring accelerations with
- * output data rates from 1 Hz to 5300 Hz.
-
- * Not all functionality of this chip has been implemented in this
- * driver, however all the pieces are present to add any desired
- * functionality. This driver supports both I2C (default) and SPI
- * operation.
- *
- * @snippet lis3dh.cxx Interesting
- */
-
-class LIS3DH
-{
-  public:
-    /**
-     * LIS3DH constructor.
-     *
-     * This device can support both I2C and SPI. For SPI, set the addr
-     * to -1, and specify a positive integer representing the Chip
-     * Select (CS) pin for the cs argument. If you are using a
-     * hardware CS pin (like edison with arduino breakout), then you
-     * can connect the proper pin to the hardware CS pin on your MCU
-     * and supply -1 for cs. The default operating mode is I2C.
-     *
-     * @param bus I2C or SPI bus to use
-     * @param addr The address for this device. -1 for SPI
-     * @param cs The gpio pin to use for the SPI Chip Select. -1 for
-     * I2C or for SPI with a hardware controlled pin.
-     * @throws std::runtime_error on initialization failure
-     */
-    LIS3DH(int bus = LIS3DH_DEFAULT_I2C_BUS, int addr = LIS3DH_DEFAULT_I2C_ADDR, int cs = -1);
-
-    /**
-     * LIS3DH destructor
-     */
-    virtual ~LIS3DH();
-
-    /**
-     * Initialize the device and start operation. This function is
-     * called from the constructor so will not typically need to be
-     * called by a user unless the device is reset.
-     *
-     * @param odr One of the LIS3DH_ODR_T values. The default is
-     * LIS3DH_ODR_100HZ
-     * @param fs One of the LIS3DH_FS_T values. The default is
-     * LIS3DH_FS_2G
-     * @param high_res true to enable high resolution mode,
-     * false to disable. The default is true.
-     * @throws std::runtime_error on failure
-     */
-    void
-    init(LIS3DH_ODR_T odr = LIS3DH_ODR_100HZ, LIS3DH_FS_T fs = LIS3DH_FS_2G, bool high_res = true);
-
-    /**
-     * Enable or disable specific axes.
-     * init() enables all three by default.
-     *
-     * @param x_axis_enable true to enable X axis, false to disable
-     * @param y_axis_enable true to enable Y axis, false to disable
-     * @param z_axis_enable true to enable Z axis, false to disable
-     * @throws std::runtime_error on failure
-     */
-    void enableAxes(bool x_axis_enable, bool y_axis_enable, bool z_axis_enable);
-
-    /**
-     * Enable or disable Block Data Update (BDU) mode.
-     *
-     * @param bdu_enable true to enable BDU mode, false to disable
-     * @throws std::runtime_error on failure
-     */
-    void enableBDUMode(bool bdu_enable);
-
-    /**
-     * Enable or disable Low Power (LP) mode. Checks if mutually exclusive
-     * High Resolution (HR) mode is enabled and bails out if yes.
-     *
-     * @param lp_enable true to enable LP mode, false to disable
-     * @throws std::runtime_error on failure
-     */
-    void enableLPMode(bool lp_enable);
-
-    /**
-     * Enable or disable High Resolution (HR) mode. Checks if mutually exclusive
-     * Low Power (LP) mode is enabled and bails out if yes.
-     *
-     * @param hr_enable true to enable HR mode, false to disable
-     * @throws std::runtime_error on failure
-     */
-    void enableHRMode(bool hr_enable);
-
-    /**
-     * Enable Normal mode by explicitly disabling LP and HR ones.
-     * Note that there's no "disable" part as it's generally unknown, which mode
-     * we were in previously. To get out of Normal mode, just enable HR or LP one.
-     *
-     * @throws std::runtime_error on failure
-     */
-    void enableNormalMode();
-
-    /**
-     * Enable high pass filtering of the accelerometer axis data.
-     * init() disables this by default. See the datasheet for
-     * details.
-     *
-     * @param filter true to enable filtering, false to disable
-     * @throws std::runtime_error on failure
-     */
-    void enableHPFiltering(bool filter);
-
-    /**
-     * Enable or disable interrupt latching for INT1 and INT2.
-     * See the datasheet for details.
-     *
-     * @param int1_latch true to enable latching for INT1, false to disable
-     * @param int2_latch true to enable latching for INT2, false to disable
-     * @throws std::runtime_error on failure
-     */
-    void enableInterruptLatching(bool int1_latch, bool int2_latch);
-
-    /**
-     * Enable or disable built-in Analog-to-Digital Converter (ADC).
-     *
-     * @param adc_enable true to enable ADC, false to disable
-     * @throws std::runtime_error on failure
-     */
-    void enableADC(bool adc_enable);
-
-    /**
-     * Enable or disable built-in temperature sensor. It depends on ADC being
-     * enabled, so we enable it unconditionally. See datasheet for details.
-     *
-     * @param temperature_enable true to enable temp sensor, false to disable
-     * @throws std::runtime_error on failure
-     */
-    void enableTemperature(bool temperature_enable);
-
-    /**
-     * Set the output data rate (ODR) of the device
-     *
-     * @param odr One of the LIS3DH_ODR_T values
-     * @throws std::runtime_error on failure
-     */
-    void setODR(LIS3DH_ODR_T odr);
-
-    /**
-     * Set the full scale (FS) of the device. This device supports a
-     * full scale of 2, 4, 8 and 16G.
-     *
-     * @param fs One of the LIS3DH_FS_T values
-     * @throws std::runtime_error on failure
-     */
-    void setFullScale(LIS3DH_FS_T fs);
-
-    /**
-     * Indicate whether INT1 and INT2 interrupts should be active high (default)
-     * or active low. See the datasheet for details.
-     *
-     * @param high true for active high, false for active low
-     * @throws std::runtime_error on failure
-     */
-    void setInterruptActiveHigh(bool high);
-
-    /**
-     * Set interrupt 1 configuration. See the datasheet for details.
-     *
-     * @param cfg A bitmask of values from LIS3DH_CTRL_REG3_BITS_T
-     * @throws std::runtime_error on failure
-     */
-    void setInt1Config(uint8_t cfg);
-
-    /**
-     * Set interrupt 2 configuration. See the datasheet for details.
-     *
-     * @param cfg A bitmask of values from LIS3DH_CTRL_REG6_BITS_T
-     * @throws std::runtime_error on failure
-     */
-    void setInt2Config(uint8_t cfg);
-
-    /**
-     * Read a register
-     *
-     * @param reg The register to read
-     * @return The value of the register
-     */
-    uint8_t readReg(uint8_t reg);
-
-    /**
-     * Read contiguous registers into a buffer
-     *
-     * @param reg The register to start the read from
-     * @param buffer The buffer to store the results
-     * @param len The number of registers to read
-     * @return The number of bytes read
-     * @throws std::runtime_error on failure
-     */
-    int readRegs(uint8_t reg, uint8_t* buffer, int len);
-
-    /**
-     * Write to a register
-     *
-     * @param reg The register to write to
-     * @param val The value to write
-     * @throws std::runtime_error on failure
-     */
-    void writeReg(uint8_t reg, uint8_t val);
-
-    /**
-     * Update the internal stored values from sensor data
-     *
-     * @throws std::runtime_error on failure
-     */
-    void update();
-
-    /**
-     * Return the chip ID
-     *
-     * @return The chip ID
-     */
-    uint8_t getChipID();
-
-    /**
-     * Return accelerometer data in gravities. update() must have
-     * been called prior to calling this method.
-     *
-     * @param x Pointer to a floating point value that will have the
-     * current x component placed into it
-     * @param y Pointer to a floating point value that will have the
-     * current y component placed into it
-     * @param z Pointer to a floating point value that will have the
-     * current z component placed into it
-     */
-    void getAccelerometer(float* x, float* y, float* z);
-
-    /**
-     * Return accelerometer data in gravities in the form of a
-     * floating point vector. update() must have been called
-     * prior to calling this method.
-     *
-     * @return A floating point vector containing x, y and z in
-     * that order
-     */
-    std::vector<float> getAccelerometer();
-
-    /**
-     * Return the current measured temperature. Note, this is not
-     * ambient temperature. update() must have been called prior to
-     * calling this method.
-     *
-     * @param fahrenheit true to return data in Fahrenheit, false for
-     * Celicus. Celsius is the default.
-     * @return The temperature in degrees Celsius or Fahrenheit
-     */
-    float getTemperature(bool fahrenheit = false);
-
-    /**
-     * Return the contents of the status register
-     *
-     * @return A bitmask of values from LIS3DH_STATUS_REG_BITS_T
-     */
-    uint8_t getStatus();
-
-    /**
-     * Return the contents of the status aux register
-     *
-     * @return A bitmask of values from LIS3DH_STATUS_REG_AUX_BITS_T
-     */
-    uint8_t getStatusAux();
-
-    /**
-     * Install an interrupt handler
-     *
-     * @param intr One of the LIS3DH_INTERRUPT_PINS_T values
-     * specifying which interrupt pin you are installing
-     * @param gpio GPIO pin to use as interrupt pin
-     * @param level The interrupt trigger level (one of mraa::Edge
-     * values). Make sure that you have configured the interrupt pin
-     * properly for whatever level you choose.
-     * @param isr The interrupt handler, accepting a void * argument
-     * @param arg The argument to pass the the interrupt handler
-     * @throws std::runtime_error on failure
-     */
-    void installISR(LIS3DH_INTERRUPT_PINS_T intr,
-                    int gpio,
-                    mraa::Edge level,
-                    void (*isr)(void*),
-                    void* arg);
-
-    /**
-     * Uninstall a previously installed interrupt handler
-     *
-     * @param intr One of the LIS3DH_INTERRUPT_PINS_T values,
-     * specifying which interrupt pin you are removing
-     */
-    void uninstallISR(LIS3DH_INTERRUPT_PINS_T intr);
-
-  protected:
-    lis3dh_context m_lis3dh;
-
-  private:
-    // Disable implicit copy and assignment operators
-    LIS3DH(const LIS3DH&) = delete;
-    LIS3DH& operator=(const LIS3DH&) = delete;
-
-};
-}
diff --git a/src/lis3dh/lis3dh.i b/src/lis3dh/lis3dh.i
deleted file mode 100644
index f1daea8..0000000
--- a/src/lis3dh/lis3dh.i
+++ /dev/null
@@ -1,26 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "../upm_vectortypes.i"
-
-%ignore getAccelerometer(float *, float *, float *);
-%ignore installISR(LIS3DH_INTERRUPT_PINS_T , int , mraa::Edge , void *, void* );
-
-%define INTERRUPT LIS3DH_INTERRUPT_PINS_T
-%enddef
-
-JAVA_ADD_INSTALLISR_INTERRUPT(upm::LIS3DH)
-JAVA_JNI_LOADLIBRARY(javaupm_lis3dh)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%include "../upm_vectortypes.i"
-%{
-#include "lis3dh_defs.h"
-#include "lis3dh.hpp"
-%}
-%include "lis3dh_defs.h"
-%include "lis3dh.hpp"
-/* END Common SWIG syntax */
diff --git a/src/lis3dh/lis3dh.json b/src/lis3dh/lis3dh.json
deleted file mode 100644
index 3eec107..0000000
--- a/src/lis3dh/lis3dh.json
+++ /dev/null
@@ -1,38 +0,0 @@
-{
-    "Library": "lis3dh",
-    "Description": "API for the LIS3DH 3-axis Accelerometer",
-    "Sensor Class":
-    {
-        "lis3dh":
-        {
-            "Name": "Digital 3-axis Accelerometer",
-            "Description": "The LIS3DH is an ultra-low-power high performance three-axis linear accelerometer belonging to the \"nano\" family which leverages the robust and mature manufacturing processes already used for the production of micromachined accelerometers. The LIS3DH has user-selectable full scales of 2g/4g/8g/16g and is capable of measuring accelerations with output data rates from 1 Hz to 5300 Hz. Not all functionality of this chip has been implemented in this driver, however all the pieces are present to add any desired functionality. This driver supports both I2C (default) and SPI operation.",
-            "Aliases": ["lis3dh"],
-            "Categories": ["accelerometer"],
-            "Connections": ["i2c", "spi", "gpio"],
-            "Project Type": ["imu", "prototyping"],
-            "Manufacturers": ["stmicro"],
-            "Kits": [],
-            "Examples":
-            {
-                "Java": ["LIS3DH_Example.java"],
-                "Python": ["lis3dh.py"],
-                "Node.js": ["lis3dh.js"],
-                "C++": ["lis3dh.cxx"],
-                "C": ["lis3dh.c"]
-            },
-            "Specifications":
-            {
-                "Operating Voltage": {"unit": "V", "low": 1.71, "high": 3.6},
-                "Operating Current": {"unit": "uA", "low": 0.5, "high": 11},
-                "Operating Temperature": {"unit": "degC", "low": -40, "high": 85}
-            },
-            "Urls" :
-            {
-                "Product Pages": ["http://www.st.com/en/mems-and-sensors/lis3dh.html"],
-                "Datasheets": ["http://www.st.com/resource/en/datasheet/lis3dh.pdf"],
-                "Schematics": []
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/lis3dh/lis3dh_defs.h b/src/lis3dh/lis3dh_defs.h
deleted file mode 100644
index 81a54b1..0000000
--- a/src/lis3dh/lis3dh_defs.h
+++ /dev/null
@@ -1,505 +0,0 @@
-/*
- * Author: Alex Tereschenko <alext.mkrs@gmail.com>
- * Copyright (c) 2018 Alex Tereschenko.
- *
- * Based on LIS2DS12 module by
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define LIS3DH_DEFAULT_I2C_BUS 0
-#define LIS3DH_DEFAULT_SPI_BUS 0
-#define LIS3DH_DEFAULT_I2C_ADDR 0x18
-
-#define LIS3DH_CHIPID 0x33
-
-// NOTE: Reserved registers must not be written into or permanent
-// damage can result. Reading from them may return indeterminate
-// values. Registers containing reserved bitfields must be
-// written as 0, except for CTRL_REG0 - see datasheet for that one.
-
-/**
- * LIS3DH registers
- */
-typedef enum {
-    // 0x00-0x06 reserved
-
-    LIS3DH_REG_STATUS_REG_AUX = 0x07,
-
-    LIS3DH_REG_OUT_ADC1_L = 0x08,
-    LIS3DH_REG_OUT_ADC1_H = 0x09,
-    LIS3DH_REG_OUT_ADC2_L = 0x0A,
-    LIS3DH_REG_OUT_ADC2_H = 0x0B,
-    LIS3DH_REG_OUT_ADC3_L = 0x0C,
-    LIS3DH_REG_OUT_ADC3_H = 0x0D,
-
-    // 0x0E reserved
-
-    LIS3DH_REG_WHO_AM_I = 0x0F,
-
-    // 0x10-0x1D reserved
-
-    LIS3DH_REG_CTRL_REG0 = 0x1E,
-    LIS3DH_REG_TEMP_CFG_REG = 0x1F,
-    LIS3DH_REG_CTRL_REG1 = 0x20,
-    LIS3DH_REG_CTRL_REG2 = 0x21,
-    LIS3DH_REG_CTRL_REG3 = 0x22,
-    LIS3DH_REG_CTRL_REG4 = 0x23,
-    LIS3DH_REG_CTRL_REG5 = 0x24,
-    LIS3DH_REG_CTRL_REG6 = 0x25,
-
-    LIS3DH_REG_REFERENCE = 0x26,
-
-    LIS3DH_REG_STATUS_REG = 0x27,
-
-    LIS3DH_REG_OUT_X_L = 0x28,
-    LIS3DH_REG_OUT_X_H = 0x29,
-    LIS3DH_REG_OUT_Y_L = 0x2A,
-    LIS3DH_REG_OUT_Y_H = 0x2B,
-    LIS3DH_REG_OUT_Z_L = 0x2C,
-    LIS3DH_REG_OUT_Z_H = 0x2D,
-
-    LIS3DH_REG_FIFO_CTRL_REG = 0x2E,
-    LIS3DH_REG_FIFO_SRC_REG = 0x2F,
-
-    LIS3DH_REG_INT1_CFG = 0x30,
-    LIS3DH_REG_INT1_SRC = 0x31,
-    LIS3DH_REG_INT1_THS = 0x32,
-    LIS3DH_REG_INT1_DURATION = 0x33,
-
-    LIS3DH_REG_INT2_CFG = 0x34,
-    LIS3DH_REG_INT2_SRC = 0x35,
-    LIS3DH_REG_INT2_THS = 0x36,
-    LIS3DH_REG_INT2_DURATION = 0x37,
-
-    LIS3DH_REG_CLICK_CFG = 0x38,
-    LIS3DH_REG_CLICK_SRC = 0x39,
-    LIS3DH_REG_CLICK_THS = 0x3A,
-
-    LIS3DH_REG_TIME_LIMIT = 0x3B,
-    LIS3DH_REG_TIME_LATENCY = 0x3C,
-    LIS3DH_REG_TIME_WINDOW = 0x3D,
-
-    LIS3DH_REG_ACT_THS = 0x3E,
-    LIS3DH_REG_ACT_DUR = 0x3F,
-} LIS3DH_REGS_T;
-
-/**
- * REG_STATUS_REG_AUX bits
- */
-typedef enum {
-    LIS3DH_STATUS_REG_AUX_1DA = 0x01,
-    LIS3DH_STATUS_REG_AUX_2DA = 0x02,
-    LIS3DH_STATUS_REG_AUX_3DA = 0x04,
-    LIS3DH_STATUS_REG_AUX_321DA = 0x08,
-
-    LIS3DH_STATUS_REG_AUX_1OR = 0x10,
-    LIS3DH_STATUS_REG_AUX_2OR = 0x20,
-    LIS3DH_STATUS_REG_AUX_3OR = 0x40,
-    LIS3DH_STATUS_REG_AUX_321OR = 0x80,
-} LIS3DH_STATUS_REG_AUX_BITS_T;
-
-/**
- * REG_CTRL_REG0 bits
- */
-typedef enum {
-    // 0x01-0x40 reserved
-
-    LIS3DH_CTRL_REG0_SDO_PU_DISC = 0x80,
-} LIS3DH_CTRL_REG0_BITS_T;
-
-/**
- * REG_TEMP_CFG_REG bits
- */
-typedef enum {
-    // 0x01-0x20 reserved
-
-    LIS3DH_TEMP_CFG_REG_TEMP_EN = 0x40,
-    LIS3DH_TEMP_CFG_REG_ADC_EN = 0x80,
-} LIS3DH_TEMP_CFG_REG_BITS_T;
-
-/**
- * REG_CTRL_REG1 bits
- */
-typedef enum {
-    LIS3DH_CTRL_REG1_XEN = 0x01,
-    LIS3DH_CTRL_REG1_YEN = 0x02,
-    LIS3DH_CTRL_REG1_ZEN = 0x04,
-    LIS3DH_CTRL_REG1_LPEN = 0x08,
-
-    LIS3DH_CTRL_REG1_ODR0 = 0x10,
-    LIS3DH_CTRL_REG1_ODR1 = 0x20,
-    LIS3DH_CTRL_REG1_ODR2 = 0x40,
-    LIS3DH_CTRL_REG1_ODR3 = 0x80,
-    _LIS3DH_CTRL_REG1_ODR_MASK = 0xF,
-    _LIS3DH_CTRL_REG1_ODR_SHIFT = 4,
-} LIS3DH_CTRL_REG1_BITS_T;
-
-/**
- * CTRL_REG1_ODR (Output Data Rate) values
- */
-typedef enum {
-    LIS3DH_ODR_POWER_DOWN = 0x0, // 0b0000
-
-    // These are allowed in all modes (high resolution/normal/low power)
-    LIS3DH_ODR_1HZ = 0x1,   // 0b0001
-    LIS3DH_ODR_10HZ = 0x2,  // 0b0010
-    LIS3DH_ODR_25HZ = 0x3,  // 0b0011
-    LIS3DH_ODR_50HZ = 0x4,  // 0b0100
-    LIS3DH_ODR_100HZ = 0x5, // 0b0101
-    LIS3DH_ODR_200HZ = 0x6, // 0b0110
-    LIS3DH_ODR_400HZ = 0x7, // 0b0111
-
-    // The following two items have a dual meaning depending
-    // on whether the LPEN bit is set, but they use the same
-    // overlapping ODR values for the ODR bitfield. Since the
-    // bitfield is only 4 bits wide, we add a "virtual" 5th bit to
-    // indicate the LP versions. This is then screened out in the
-    // code and will set the LPEN bit according to what is selected
-    // here.
-
-    // CTRL_REG1_LPEN == 0 (high resolution/normal mode)
-    LIS3DH_ODR_1344HZ = 0x9, // 0b1001
-
-    // CTRL_REG1_LPEN == 1 (low power mode). Add 'virtual' bit 5
-    // value (0x10) for these LP modes, which we will detect and
-    // screen out in the driver. This simplifies the ODR API.
-    LIS3DH_ODR_5376HZ = (0x10 + 0x9), // 0b1001
-
-    // Low power-only mode, requires LPEN == 1, so add the virtual bit
-    LIS3DH_ODR_LP_1600HZ = (0x10 + 0x8), // 0b1000
-} LIS3DH_ODR_T;
-
-/**
- * REG_CTRL_REG2 bits
- */
-typedef enum {
-    LIS3DH_CTRL_REG2_HP_IA1 = 0x01,
-    LIS3DH_CTRL_REG2_HP_IA2 = 0x02,
-    LIS3DH_CTRL_REG2_HPCLICK = 0x04,
-    LIS3DH_CTRL_REG2_FDS = 0x08,
-
-    LIS3DH_CTRL_REG2_HPCF0 = 0x10,
-    LIS3DH_CTRL_REG2_HPCF1 = 0x20,
-    _LIS3DH_CTRL_REG2_HPCF_MASK = 0x3, // 0b11
-    _LIS3DH_CTRL_REG2_HPCF_SHIFT = 4,
-
-    LIS3DH_CTRL_REG2_HPM0 = 0x40,
-    LIS3DH_CTRL_REG2_HPM1 = 0x80,
-    _LIS3DH_CTRL_REG2_HPM_MASK = 0x3, // 0b11
-    _LIS3DH_CTRL_REG2_HPM_SHIFT = 6,
-} LIS3DH_CTRL_REG2_BITS_T;
-
-/**
- * CTRL_REG2_HPM (High-pass filter mode) values
- */
-typedef enum {
-    LIS3DH_HPM_NORMAL_RST_REF_READ = 0x0, // 0b00, Normal mode (reset by reading REFERENCE)
-    LIS3DH_HPM_REF_SIGNAL = 0x1,          // 0b01, Reference signal for filtering
-    LIS3DH_HPM_NORMAL = 0x2,              // 0b10, Normal mode
-    LIS3DH_HPM_AUTORST = 0x3,             // 0b11, Autoreset on interrupt event
-} LIS3DH_HPM_T;
-
-/**
- * REG_CTRL_REG3 bits
- */
-typedef enum {
-    // 0x01 reserved
-
-    LIS3DH_CTRL_REG3_I1_OVERRUN = 0x02,
-    LIS3DH_CTRL_REG3_I1_WTM = 0x04,
-    LIS3DH_CTRL_REG3_I1_321DA = 0x08,
-    LIS3DH_CTRL_REG3_I1_ZYXDA = 0x10,
-    LIS3DH_CTRL_REG3_I1_IA2 = 0x20,
-    LIS3DH_CTRL_REG3_I1_IA1 = 0x40,
-    LIS3DH_CTRL_REG3_I1_CLICK = 0x80,
-} LIS3DH_CTRL_REG3_BITS_T;
-
-/**
- * REG_CTRL_REG4 bits
- */
-typedef enum {
-    LIS3DH_CTRL_REG4_SIM = 0x01,
-
-    LIS3DH_CTRL_REG4_ST0 = 0x02,
-    LIS3DH_CTRL_REG4_ST1 = 0x04,
-    _LIS3DH_CTRL_REG4_ST_MASK = 0x3, // 0b11
-    _LIS3DH_CTRL_REG4_ST_SHIFT = 1,
-
-    LIS3DH_CTRL_REG4_HR = 0x08,
-
-    LIS3DH_CTRL_REG4_FS0 = 0x10,
-    LIS3DH_CTRL_REG4_FS1 = 0x20,
-    _LIS3DH_CTRL_REG4_FS_MASK = 0x3, // 0b11
-    _LIS3DH_CTRL_REG4_FS_SHIFT = 4,
-
-    LIS3DH_CTRL_REG4_BLE = 0x40,
-    LIS3DH_CTRL_REG4_BDU = 0x80,
-} LIS3DH_CTRL_REG4_BITS_T;
-
-/**
- * CTRL_REG4_ST (Self Test) values
- */
-typedef enum {
-    LIS3DH_ST_NORMAL = 0x0, // 0b00
-    LIS3DH_ST_ST0 = 0x1,    // 0b01
-    LIS3DH_ST_ST1 = 0x2,    // 0b10
-} LIS3DH_ST_T;
-
-/**
- * CTRL_REG4_FS (Full Scale) values
- */
-typedef enum {
-    LIS3DH_FS_2G = 0x0,  // 0b00
-    LIS3DH_FS_4G = 0x1,  // 0b01
-    LIS3DH_FS_8G = 0x2,  // 0b10
-    LIS3DH_FS_16G = 0x3, // 0b11
-} LIS3DH_FS_T;
-
-/**
- * REG_CTRL_REG5 bits
- */
-typedef enum {
-    LIS3DH_CTRL_REG5_D4D_INT2 = 0x01,
-    LIS3DH_CTRL_REG5_LIR_INT2 = 0x02,
-    LIS3DH_CTRL_REG5_D4D_INT1 = 0x04,
-    LIS3DH_CTRL_REG5_LIR_INT1 = 0x08,
-
-    // 0x10-0x20 reserved
-
-    LIS3DH_CTRL_REG5_FIFO_EN = 0x40,
-    LIS3DH_CTRL_REG5_BOOT = 0x80,
-} LIS3DH_CTRL_REG5_BITS_T;
-
-/**
- * REG_CTRL_REG6 bits
- */
-typedef enum {
-    // 0x01 reserved
-
-    LIS3DH_CTRL_REG6_INT_POLARITY = 0x02,
-
-    // 0x04 reserved
-
-    LIS3DH_CTRL_REG6_I2_ACT = 0x08,
-    LIS3DH_CTRL_REG6_I2_BOOT = 0x10,
-    LIS3DH_CTRL_REG6_I2_IA2 = 0x20,
-    LIS3DH_CTRL_REG6_I2_IA1 = 0x40,
-    LIS3DH_CTRL_REG6_I2_CLICK = 0x80,
-} LIS3DH_CTRL_REG6_BITS_T;
-
-/**
- * REG_STATUS_REG bits
- */
-typedef enum {
-    LIS3DH_STATUS_REG_XDA = 0x01,
-    LIS3DH_STATUS_REG_YDA = 0x02,
-    LIS3DH_STATUS_REG_ZDA = 0x04,
-    LIS3DH_STATUS_REG_ZYXDA = 0x08,
-
-    LIS3DH_STATUS_REG_XOR = 0x10,
-    LIS3DH_STATUS_REG_YOR = 0x20,
-    LIS3DH_STATUS_REG_ZOR = 0x40,
-    LIS3DH_STATUS_REG_ZYXOR = 0x80,
-} LIS3DH_STATUS_REG_BITS_T;
-
-/**
- * REG_FIFO_CTRL_REG bits
- */
-typedef enum {
-    LIS3DH_FIFO_CTRL_REG_FTH0 = 0x01,
-    LIS3DH_FIFO_CTRL_REG_FTH1 = 0x02,
-    LIS3DH_FIFO_CTRL_REG_FTH2 = 0x04,
-    LIS3DH_FIFO_CTRL_REG_FTH3 = 0x08,
-    LIS3DH_FIFO_CTRL_REG_FTH4 = 0x10,
-    _LIS3DH_FIFO_CTRL_REG_FTH_MASK = 0x1F, // 0b11111
-    _LIS3DH_FIFO_CTRL_REG_FTH_SHIFT = 0,
-
-    LIS3DH_FIFO_CTRL_REG_TR = 0x20,
-
-    LIS3DH_FIFO_CTRL_REG_FM0 = 0x40,
-    LIS3DH_FIFO_CTRL_REG_FM1 = 0x80,
-    _LIS3DH_FIFO_CTRL_REG_FM_MASK = 0x3, // 0b11
-    _LIS3DH_FIFO_CTRL_REG_FM_SHIFT = 6,
-} LIS3DH_FIFO_CTRL_REG_BITS_T;
-
-/**
- * FIFO_CTRL_REG_FM (FIFO Mode) values
- */
-typedef enum {
-    LIS3DH_FM_BYPASS = 0x0,         // 0b00
-    LIS3DH_FM_FIFO = 0x1,           // 0b01
-    LIS3DH_FM_STREAM = 0x2,         // 0b10
-    LIS3DH_FM_STREAM_TO_FIFO = 0x3, // 0b11
-} LIS3DH_FM_T;
-
-/**
- * REG_FIFO_SRC_REG bits
- */
-typedef enum {
-    LIS3DH_FIFO_SRC_REG_FSS0 = 0x01,
-    LIS3DH_FIFO_SRC_REG_FSS1 = 0x02,
-    LIS3DH_FIFO_SRC_REG_FSS2 = 0x04,
-    LIS3DH_FIFO_SRC_REG_FSS3 = 0x08,
-    LIS3DH_FIFO_SRC_REG_FSS4 = 0x10,
-    _LIS3DH_FIFO_SRC_REG_FSS_MASK = 0x1F, // 0b11111
-    _LIS3DH_FIFO_SRC_REG_FSS_SHIFT = 0,
-
-    LIS3DH_FIFO_SRC_REG_EMPTY = 0x20,
-    LIS3DH_FIFO_SRC_REG_OVRN_FIFO = 0x40,
-    LIS3DH_FIFO_SRC_REG_WTM = 0x80,
-} LIS3DH_FIFO_SRC_REG_BITS_T;
-
-/**
- * REG_INT1_CFG bits
- */
-typedef enum {
-    LIS3DH_INT1_CFG_XLIE = 0x01,
-    LIS3DH_INT1_CFG_XHIE = 0x02,
-
-    LIS3DH_INT1_CFG_YLIE = 0x04,
-    LIS3DH_INT1_CFG_YHIE = 0x08,
-
-    LIS3DH_INT1_CFG_ZLIE = 0x10,
-    LIS3DH_INT1_CFG_ZHIE = 0x20,
-
-    LIS3DH_INT1_CFG_6D = 0x40,
-    LIS3DH_INT1_CFG_AOI = 0x80,
-} LIS3DH_INT1_CFG_BITS_T;
-
-/**
- * REG_INT1_SRC bits
- */
-typedef enum {
-    LIS3DH_INT1_SRC_XL = 0x01,
-    LIS3DH_INT1_SRC_XH = 0x02,
-
-    LIS3DH_INT1_SRC_YL = 0x04,
-    LIS3DH_INT1_SRC_YH = 0x08,
-
-    LIS3DH_INT1_SRC_ZL = 0x10,
-    LIS3DH_INT1_SRC_ZH = 0x20,
-
-    LIS3DH_INT1_SRC_IA = 0x40,
-
-    // 0x80 reserved
-} LIS3DH_INT1_SRC_BITS_T;
-
-/**
- * REG_INT2_CFG bits
- */
-typedef enum {
-    LIS3DH_INT2_CFG_XLIE = 0x01,
-    LIS3DH_INT2_CFG_XHIE = 0x02,
-
-    LIS3DH_INT2_CFG_YLIE = 0x04,
-    LIS3DH_INT2_CFG_YHIE = 0x08,
-
-    LIS3DH_INT2_CFG_ZLIE = 0x10,
-    LIS3DH_INT2_CFG_ZHIE = 0x20,
-
-    LIS3DH_INT2_CFG_6D = 0x40,
-    LIS3DH_INT2_CFG_AOI = 0x80,
-} LIS3DH_INT2_CFG_BITS_T;
-
-/**
- * REG_INT2_SRC bits
- */
-typedef enum {
-    LIS3DH_INT2_SRC_XL = 0x01,
-    LIS3DH_INT2_SRC_XH = 0x02,
-
-    LIS3DH_INT2_SRC_YL = 0x04,
-    LIS3DH_INT2_SRC_YH = 0x08,
-
-    LIS3DH_INT2_SRC_ZL = 0x10,
-    LIS3DH_INT2_SRC_ZH = 0x20,
-
-    LIS3DH_INT2_SRC_IA = 0x40,
-
-    // 0x80 reserved
-} LIS3DH_INT2_SRC_BITS_T;
-
-/**
- * REG_CLICK_CFG bits
- */
-typedef enum {
-    LIS3DH_CLICK_CFG_XS = 0x01,
-    LIS3DH_CLICK_CFG_XD = 0x02,
-
-    LIS3DH_CLICK_CFG_YS = 0x04,
-    LIS3DH_CLICK_CFG_YD = 0x08,
-
-    LIS3DH_CLICK_CFG_ZS = 0x10,
-    LIS3DH_CLICK_CFG_ZD = 0x20,
-
-    // 0x40-0x80 reserved
-} LIS3DH_CLICK_CFG_BITS_T;
-
-/**
- * REG_CLICK_SRC bits
- */
-typedef enum {
-    LIS3DH_CLICK_SRC_X = 0x01,
-    LIS3DH_CLICK_SRC_Y = 0x02,
-    LIS3DH_CLICK_SRC_Z = 0x04,
-
-    LIS3DH_CLICK_SRC_SIGN = 0x08,
-
-    LIS3DH_CLICK_SRC_SCLICK = 0x10,
-    LIS3DH_CLICK_SRC_DCLICK = 0x20,
-
-    LIS3DH_CLICK_SRC_IA = 0x40,
-
-    // 0x80 reserved
-} LIS3DH_CLICK_SRC_BITS_T;
-
-/**
- * REG_CLICK_THS bits
- */
-typedef enum {
-    LIS3DH_CLICK_THS_THS0 = 0x01,
-    LIS3DH_CLICK_THS_THS1 = 0x02,
-    LIS3DH_CLICK_THS_THS2 = 0x04,
-    LIS3DH_CLICK_THS_THS3 = 0x08,
-    LIS3DH_CLICK_THS_THS4 = 0x10,
-    LIS3DH_CLICK_THS_THS5 = 0x20,
-    LIS3DH_CLICK_THS_THS6 = 0x40,
-    _LIS3DH_CLICK_THS_THS_MASK = 0x7F, // 0b1111111
-    _LIS3DH_CLICK_THS_THS_SHIFT = 0,
-
-    LIS3DH_CLICK_THS_LIR_CLICK = 0x80,
-} LIS3DH_CLICK_THS_BITS_T;
-
-// Interrupt selection for installISR() and uninstallISR()
-typedef enum { LIS3DH_INTERRUPT_INT1, LIS3DH_INTERRUPT_INT2 } LIS3DH_INTERRUPT_PINS_T;
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/lis3dh/lis3dh_fti.c b/src/lis3dh/lis3dh_fti.c
deleted file mode 100644
index cb96c8b..0000000
--- a/src/lis3dh/lis3dh_fti.c
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Author: Alex Tereschenko <alext.mkrs@gmail.com>
- * Copyright (c) 2018 Alex Tereschenko.
- *
- * Based on LIS2DS12 module by
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "lis3dh.h"
-#include "upm_fti.h"
-
-/**
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_lis3dh_name[] = "LIS3DH";
-const char upm_lis3dh_description[] = "Triple Axis Digital Accelerometer";
-const upm_protocol_t upm_lis3dh_protocol[] = { UPM_I2C, UPM_SPI, UPM_GPIO };
-const upm_sensor_t upm_lis3dh_category[] = { UPM_ACCELEROMETER };
-
-// Forward declarations
-const void* upm_lis3dh_get_ft(upm_sensor_t sensor_type);
-void* upm_lis3dh_init_name();
-void upm_lis3dh_close(void* dev);
-upm_result_t upm_lis3dh_get_value(void* dev, float* value, upm_acceleration_u unit);
-
-const upm_sensor_descriptor_t
-upm_lis3dh_get_descriptor()
-{
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_lis3dh_name;
-    usd.description = upm_lis3dh_description;
-    usd.protocol_size = 3;
-    usd.protocol = upm_lis3dh_protocol;
-    usd.category_size = 1;
-    usd.category = upm_lis3dh_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft = {
-    .upm_sensor_init_name = upm_lis3dh_init_name,
-    .upm_sensor_close = upm_lis3dh_close,
-};
-
-static const upm_acceleration_ft aft = {.upm_acceleration_get_value = upm_lis3dh_get_value };
-
-const void*
-upm_lis3dh_get_ft(upm_sensor_t sensor_type)
-{
-    switch (sensor_type) {
-        case UPM_SENSOR:
-            return &ft;
-
-        case UPM_ACCELEROMETER:
-            return &aft;
-
-        default:
-            return NULL;
-    }
-}
-
-void*
-upm_lis3dh_init_name()
-{
-    return NULL;
-}
-
-
-void
-upm_lis3dh_close(void* dev)
-{
-    lis3dh_close((lis3dh_context) dev);
-}
-
-upm_result_t
-upm_lis3dh_get_value(void* dev, float* value, upm_acceleration_u unit)
-{
-    if (lis3dh_update((lis3dh_context) dev)) {
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // No conversion facility in place yet, so we don't do anything
-    // with units
-
-    float x, y, z;
-
-    lis3dh_get_accelerometer(dev, &x, &y, &z);
-
-    value[0] = x;
-    value[1] = y;
-    value[2] = z;
-
-    return UPM_SUCCESS;
-}
diff --git a/src/lm35/CMakeLists.txt b/src/lm35/CMakeLists.txt
deleted file mode 100644
index 8c653e5..0000000
--- a/src/lm35/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME lm35
-    DESCRIPTION "Analog Temperature Sensor"
-    C_HDR lm35.h
-    C_SRC lm35.c
-    CPP_HDR lm35.hpp
-    CPP_SRC lm35.cxx
-    FTI_SRC lm35_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa)
diff --git a/src/lm35/lm35.c b/src/lm35/lm35.c
deleted file mode 100644
index ef9de1d..0000000
--- a/src/lm35/lm35.c
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <assert.h>
-#include <string.h>
-#include "lm35.h"
-
-lm35_context lm35_init(int pin, float aref)
-{
-    lm35_context dev =
-        (lm35_context)malloc(sizeof(struct _lm35_context));
-
-    if (!dev)
-        return NULL;
-
-    memset((void *)dev, 0, sizeof(struct _lm35_context));
-
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        lm35_close(dev);
-        return NULL;
-    }
-
-    // initialize the MRAA context
-
-    if (!(dev->aio = mraa_aio_init(pin)))
-    {
-        printf("%s: mraa_aio_init failed.\n", __FUNCTION__);
-        lm35_close(dev);
-
-        return NULL;
-    }
-
-    dev->ares = (float)((1 << mraa_aio_get_bit(dev->aio)) - 1);
-    dev->aref = aref;
-    dev->scale = 1.0;
-    dev->offset = 0.0;
-
-    return dev;
-}
-
-void lm35_close(lm35_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->aio)
-        mraa_aio_close(dev->aio);
-
-    free(dev);
-}
-
-upm_result_t lm35_get_temperature(const lm35_context dev, float *temperature)
-{
-    assert(dev != NULL);
-
-    int val = mraa_aio_read(dev->aio);
-    if (val < 0)
-    {
-        printf("%s: mraa_aio_read() failed\n", __FUNCTION__);
-        *temperature = 0.0;
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // convert to mV
-    float mV = ((float)val * (dev->aref / dev->ares) * 1000.0);
-
-    // 10mV/degree C
-    *temperature = mV / 10.0;
-    *temperature = *temperature * dev->scale + (dev->offset * dev->scale);
-    return UPM_SUCCESS;
-}
-
-void lm35_set_offset(const lm35_context dev, float offset)
-{
-    assert(dev != NULL);
-
-    dev->offset = offset;
-}
-
-void lm35_set_scale(const lm35_context dev, float scale)
-{
-    assert(dev != NULL);
-
-    dev->scale = scale;
-}
diff --git a/src/lm35/lm35.cxx b/src/lm35/lm35.cxx
deleted file mode 100644
index f54e4f3..0000000
--- a/src/lm35/lm35.cxx
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015-2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <stdexcept>
-#include "lm35.hpp"
-
-using namespace std;
-using namespace upm;
-
-LM35::LM35(int pin, float aref) :
-    m_lm35(lm35_init(pin, aref))
-{
-    if (!m_lm35)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lm35_init() failed");
-}
-
-LM35::~LM35()
-{
-    lm35_close(m_lm35);
-}
-
-float LM35::getTemperature()
-{
-    float temp;
-    upm_result_t rv = lm35_get_temperature(m_lm35, &temp);
-
-    if (rv)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lm35_get_temperature() failed");
-
-  return temp;
-}
-
-void LM35::setScale(float scale)
-{
-    lm35_set_scale(m_lm35, scale);
-}
-
-void LM35::setOffset(float offset)
-{
-    lm35_set_offset(m_lm35, offset);
-}
diff --git a/src/lm35/lm35.h b/src/lm35/lm35.h
deleted file mode 100644
index 0a1d984..0000000
--- a/src/lm35/lm35.h
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <upm.h>
-#include <mraa/aio.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    /**
-     * @file lm35.h
-     * @library lm35
-     * @brief C API for the LM35 Temperature Sensor
-     *
-     * @include lm35.c
-     */
-
-    /**
-     * device context
-     */
-    typedef struct _lm35_context
-    {
-        mraa_aio_context    aio;
-
-        // ADC reference voltage
-        float               aref;
-        // ADC resolution
-        float               ares;
-
-        // scale and offset
-        float               scale;
-        float               offset;
-    } *lm35_context;
-
-    /**
-     * LM35 initialization.
-     *
-     * @param pin Analog pin to use
-     * @param aref Analog reference voltage
-     */
-    lm35_context lm35_init(int pin, float aref);
-
-    /**
-     * LM35 close.
-     */
-    void lm35_close(lm35_context dev);
-
-    /**
-     * Returns the temperature in degrees Celsius
-     *
-     * @param temperature A pointer to a float that will contain the
-     * measured temperature.
-     * @return UPM status
-     */
-    upm_result_t lm35_get_temperature(const lm35_context dev,
-                                      float *temperature);
-
-    /**
-     * Set sensor offset.  This offset is applied to the return values
-     * before scaling.  Default is 0.0.
-     *
-     * @param dev sensor context pointer
-     * @param offset Offset to apply.
-     */
-    void lm35_set_offset(const lm35_context dev, float offset);
-
-    /**
-     * Set sensor scale.  This scale is applied to the return values
-     * before the offset is applied.  Default is 1.0.
-     *
-     * @param dev sensor context pointer
-     * @param scale Scale to apply.
-     */
-    void lm35_set_scale(const lm35_context dev, float scale);
-
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/lm35/lm35.hpp b/src/lm35/lm35.hpp
deleted file mode 100644
index a63733b..0000000
--- a/src/lm35/lm35.hpp
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015-2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <iostream>
-#include <string>
-#include "lm35.h"
-
-namespace upm {
-    /**
-     * @brief LM35 Linear Temperature Sensor
-     * @defgroup lm35 libupm-lm35
-     * @ingroup dfrobot analog temp
-     */
-
-    /**
-     * @library lm35
-     * @sensor lm35
-     * @comname Analog Temperature Sensor
-     * @altname LM35
-     * @type temp
-     * @man dfrobot
-     * @web http://www.dfrobot.com/index.php?route=product/product&product_id=76
-     * @con analog
-     *
-     * @brief API for the DFRobot LM35 Linear Temperature Sensor
-     *
-     * This sensor returns an analog voltage proportional to the
-     * temperature of the ambient environment.
-     *
-     * It has a range of 2C to 150C.
-     *
-     * This driver was developed using the DFRobot LM35 Linear
-     * Temperature Sensor
-     *
-     * @image html lm35.jpg
-     * @snippet lm35.cxx Interesting
-     */
-
-    class LM35 {
-    public:
-
-        /**
-         * LM35 constructor
-         *
-         * @param pin Analog pin to use
-         * @param aref Analog reference voltage; default is 5.0 V
-         */
-        LM35(int pin, float aref=5.0);
-
-        /**
-         * LM35 destructor
-         */
-        ~LM35();
-
-        /**
-         * Returns the temperature in degrees Celsius
-         *
-         * @return The Temperature in degrees Celsius
-         */
-        float getTemperature();
-
-        /**
-         * Set sensor scale.  This scale is applied to the return values
-         * before the offset is applied.  Default is 1.0.
-         *
-         * @param scale Scale to apply.
-         */
-        void setScale(float scale);
-
-        /**
-         * Set sensor offset.  This offset is applied to the return values
-         * before scaling.  Default is 0.0.
-         *
-         * @param offset Offset to apply.
-         */
-        void setOffset(float offset);
-
-    protected:
-        lm35_context m_lm35;
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        LM35(const LM35&) = delete;
-        LM35 &operator=(const LM35&) = delete;
-    };
-}
diff --git a/src/lm35/lm35.json b/src/lm35/lm35.json
deleted file mode 100644
index ece5c19..0000000
--- a/src/lm35/lm35.json
+++ /dev/null
@@ -1,38 +0,0 @@
-{
-    "Library": "lm35",
-    "Description": "API for the DFRobot LM35 Linear Temperature Sensor",
-    "Sensor Class":
-    {
-        "LM35":
-        {
-            "Name": "Analog Temperature Sensor",
-            "Description": "This sensor returns an analog voltage proportional to the temperature of the ambient environment. This driver was developed using the DFRobot LM35 Linear Temperature Sensor",
-            "Aliases": ["lm35"],
-            "Categories": ["temperature"],
-            "Connections": ["analog"],
-            "Project Type": ["environmental", "monitoring", "prototyping"],
-            "Manufacturers": ["dfrobot", "nationalsemiconductor"],
-            "Kits": [],
-            "Image": "lm35.jpg",
-            "Examples":
-            {
-                "Java": [],
-                "Python": ["lm35.py"],
-                "Node.js": ["lm35.js"],
-                "C++": ["lm35.cxx"],
-                "C": ["lm35.c"]
-            },
-            "Specifications":
-            {
-                "Operating Voltage": {"unit": "V", "low": 3.3, "high": 5},
-                "Measurement Range": {"unit": "degC", "low": 0, "high": 100}
-            },
-            "Urls" :
-            {
-                "Product Pages": ["https://www.dfrobot.com/product-76.html"],
-                "Datasheets": ["http://image.dfrobot.com/image/data/DFR0023/DFR0023_Datasheet.pdf"],
-                "Schematics": []
-            }
-        }
-    }
-}
diff --git a/src/lm35/lm35_fti.c b/src/lm35/lm35_fti.c
deleted file mode 100644
index a0b8305..0000000
--- a/src/lm35/lm35_fti.c
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "lm35.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-
-#include "upm_fti.h"
-#include "fti/upm_sensor.h"
-
-/**
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_lm35_name[] = "LM35";
-const char upm_lm35_description[] = "LM35 Analog Temperature Sensor";
-const upm_protocol_t upm_lm35_protocol[] = {UPM_ANALOG};
-const upm_sensor_t upm_lm35_category[] = {UPM_TEMPERATURE};
-
-// forward declarations
-const upm_sensor_descriptor_t upm_lm35_get_descriptor();
-const void* upm_lm35_get_ft(upm_sensor_t sensor_type);
-upm_result_t upm_lm35_get_value(void* dev, float* tempval,
-                                upm_temperature_u unit);
-void* upm_lm35_init_name();
-void upm_lm35_close(void* dev);
-upm_result_t upm_lm35_set_offset(void *dev, float offset);
-upm_result_t upm_lm35_set_scale(void *dev, float scale);
-
-const upm_sensor_descriptor_t upm_lm35_get_descriptor()
-{
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_lm35_name;
-    usd.description = upm_lm35_description;
-    usd.protocol_size = 1;
-    usd.protocol = upm_lm35_protocol;
-    usd.category_size = 1;
-    usd.category = upm_lm35_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = &upm_lm35_init_name,
-    .upm_sensor_close = &upm_lm35_close,
-    .upm_sensor_get_descriptor = &upm_lm35_get_descriptor
-};
-
-static const upm_temperature_ft tft =
-{
-    .upm_temperature_get_value = &upm_lm35_get_value,
-    .upm_temperature_set_scale = &upm_lm35_set_scale,
-    .upm_temperature_set_offset = &upm_lm35_set_offset,
-};
-
-const void* upm_lm35_get_ft(upm_sensor_t sensor_type)
-{
-    if (sensor_type == UPM_SENSOR)
-        return &ft;
-
-    if (sensor_type == UPM_TEMPERATURE)
-        return &tft;
-
-    return NULL;
-}
-
-void* upm_lm35_init_name()
-{
-    return NULL;
-}
-
-void upm_lm35_close(void* dev)
-{
-    lm35_close((lm35_context)dev);
-}
-
-upm_result_t upm_lm35_set_offset(void *dev, float offset)
-{
-    lm35_set_offset((lm35_context)dev, offset);
-    return UPM_SUCCESS;
-}
-upm_result_t upm_lm35_set_scale(void *dev, float scale)
-{
-    lm35_set_scale((lm35_context)dev, scale);
-    return UPM_SUCCESS;
-}
-
-upm_result_t upm_lm35_get_value(void* dev, float* tempval,
-                                 upm_temperature_u unit)
-{
-    float temp = 0.0;
-    upm_result_t rv = lm35_get_temperature((lm35_context)dev, &temp);
-
-    if (rv != UPM_SUCCESS)
-        return rv;
-
-    switch (unit)
-        {
-        case CELSIUS:
-            *tempval = temp;
-            return UPM_SUCCESS;
-
-        case KELVIN:
-            *tempval = temp + 273.15;
-            return UPM_SUCCESS;
-
-        case FAHRENHEIT:
-            *tempval = temp * (9.0/5.0) + 32.0;
-            return UPM_SUCCESS;
-        }
-
-    return UPM_ERROR_INVALID_PARAMETER;
-}
diff --git a/src/lol/CMakeLists.txt b/src/lol/CMakeLists.txt
deleted file mode 100644
index fabecd6..0000000
--- a/src/lol/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "lol")
-set (libdescription "Lots of LEDs (LoL) Array Rev A")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa ${CMAKE_THREAD_LIBS_INIT})
diff --git a/src/lol/lol.cxx b/src/lol/lol.cxx
deleted file mode 100644
index 3338426..0000000
--- a/src/lol/lol.cxx
+++ /dev/null
@@ -1,186 +0,0 @@
-/*
- * Author: Alexander Komarov <alexander.komarov@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-#include <unistd.h>
-#include <stdlib.h>
-#include <functional>
-#include <string.h>
-#include "lol.hpp"
-
-using namespace upm;
-
-static mraa_gpio_context *m_Ctx;
-static unsigned char *buffer;
-
-static int charlie_pairs [12][22] = {
-{3,124, 4,110, 5,96,  6,82,  7,68, 8,54, 9,40, 10,26, 11,12, -1,-1, -1,-1},
-{3,122, 4,108, 5,94,  6,80,  7,66, 8,52, 9,38, 10,24, 11,10, -1,-1, -1,-1},
-{3,120, 4,106, 5,92,  6,78,  7,64, 8,50, 9,36, 10,22, 11,8,  -1,-1, -1,-1},
-{0,125, 1,123, 2,121, 4,98,  5,84, 6,70, 7,56, 8,42,  9,28,  10,14, 11,0},
-{0,111, 1,109, 2,107, 3,112, 5,85, 6,71, 7,57, 8,43, 9,29,   10,15, 11,1},
-{0,97,  1,95,  2,93,  3,113, 4,99, 6,72, 7,58, 8,44, 9,30,   10,16, 11,2},
-{0,83,  1,81,  2,79,  3,114, 4,100,5,86, 7,59, 8,45, 9,31,   10,17, 11,3},
-{0,69,  1,67,  2,65,  3,115, 4,101,5,87, 6,73, 8,46, 9,32,   10,18, 11,4},
-{0,55,  1,53,  2,51,  3,116, 4,102,5,88, 6,74, 7,60, 9,33,   10,19, 11,5},
-{0,41,  1,39,  2,37,  3,117, 4,103,5,89, 6,75, 7,61, 8,47,   10,20, 11,6},
-{0,27,  1,25,  2,23,  3,118, 4,104,5,90, 6,76, 7,62, 8,48,   9,34,  11,7},
-{0,13,  1,11,  2,9,   3,119, 4,105,5,91, 6,77, 7,63, 8,49,   9,35,  10,21}
-};
-
-void clear_gpio(int gpio)
-{
-    mraa_gpio_mode(m_Ctx[gpio], MRAA_GPIO_HIZ);
-    mraa_gpio_dir(m_Ctx[gpio], MRAA_GPIO_IN);
-}
-
-void clear_prev_cycle(int cycle)
-{
-    int i;
-
-    // What is prev cycle?
-    cycle--;
-    if (cycle == -1)
-        cycle = 11;
-
-    // Disable all "1"'s
-    for (i = 0; i < 11; i++) {
-        if (charlie_pairs[cycle][i*2] == -1)
-            break;
-        if(buffer[charlie_pairs[cycle][i*2 + 1]])
-            clear_gpio(charlie_pairs[cycle][i*2]);
-    }
-
-// Disable "0"
-    clear_gpio(cycle);
-}
-
-void set_strong_one(int gpio)
-{
-    mraa_gpio_dir(m_Ctx[gpio], MRAA_GPIO_OUT);
-    mraa_gpio_mode(m_Ctx[gpio], MRAA_GPIO_STRONG);
-    mraa_gpio_write(m_Ctx[gpio], 1);
-}
-
-void set_strong_zero(int gpio)
-{
-    mraa_gpio_dir(m_Ctx[gpio], MRAA_GPIO_OUT);
-    mraa_gpio_mode(m_Ctx[gpio], MRAA_GPIO_STRONG);
-    mraa_gpio_write(m_Ctx[gpio], 0);
-}
-
-
-static void clear_gpios()
-{
-    int i;
-    for (i = 0; i < 12; i++)
-        clear_gpio(i);
-}
-
-void *do_draw(void *arg)
-{
-    clear_gpios();
-
-    while (1) {
-        int i, cur;
-        uint8_t cycle = 0;
-        // 12 Cycles of Matrix
-        for (cycle = 0; cycle < 12; cycle++)
-        {
-            if (cycle == 12) cycle = 0;
-
-            clear_prev_cycle(cycle);
-            // set strong/0 on current cycle line
-            set_strong_zero(cycle);
-
-            // draw ones from framebuffer
-            for (i = 0; i < 11; i++) {
-                cur = charlie_pairs[cycle][i*2];
-                if (cur == -1) break;
-
-                if (buffer[charlie_pairs[cycle][i*2 + 1]]) {
-                    set_strong_one(cur);
-//  printf("cycle %d %d %d %d\n", cycle, i, charlie_pairs[cycle][i*2 + 1],
-//           buffer[charlie_pairs[cycle][i*2 + 1]]);
-                }
-            }
-        }
-
-    }
-    return NULL;
-}
-
-LoL::LoL() {
-    int i = 0;
-    for (i = 0; i < 12; i++)
-      {
-        if ( !(m_LoLCtx[i] = mraa_gpio_init(i+2)) ) 
-          {
-            throw std::invalid_argument(std::string(__FUNCTION__) +
-                                        ": mraa_gpio_init() failed, invalid pin?");
-            return;
-          }
-
-      }
-
-    memset(framebuffer, 0, LOL_X*LOL_Y);
-
-    // I am optimistic and stupid - thread creation
-    // always works in my world
-    buffer = (unsigned char*)framebuffer;
-    m_Ctx = m_LoLCtx;
-    pthread_create (&drawer_thread, NULL, do_draw, NULL);
-}
-
-LoL::~LoL() {
-    int i = 0;
-    for (i = 0; i < 12; i++)
-        mraa_gpio_close(m_LoLCtx[i]);
-}
-
-unsigned char* LoL::getFramebuffer() {
-    return framebuffer;
-}
-
-void LoL::setPixel(int x, int y, bool pixel)
-{
-    if (x < 0 || y < 0 || x >= LOL_X || y >= LOL_Y)
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                ": pixel coordinates out of bounds");
-
-    framebuffer[x + LOL_X*y] = (pixel) ? 1 : 0;
-    return;
-}
-
-bool LoL::getPixel(int x, int y)
-{
-    if (x < 0 || y < 0 || x >= LOL_X || y >= LOL_Y)
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                ": pixel coordinates out of bounds");
-
-    return (framebuffer[x + LOL_X*y] == 0) ? false : true;
-}
-
diff --git a/src/lol/lol.hpp b/src/lol/lol.hpp
deleted file mode 100644
index c052aac..0000000
--- a/src/lol/lol.hpp
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- * Author: Alexander Komarov <alexander.komarov@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/gpio.h>
-#include <mraa/aio.h>
-#include <pthread.h>
-
-namespace upm {
-
-#define LOL_X 14
-#define LOL_Y 9
-
-/**
- * @brief Olimex LoL Shield
- * @defgroup lol libupm-lol
- * @ingroup adafruit gpio display
- */
-
-/**
- * @library lol
- * @sensor lol
- * @comname Lots of LEDs (LoL) Array Rev A
- * @type display
- * @man adafruit
- * @con gpio
- *
- * @brief API for the Olimex LoL array
- *
- * This module defines the LoL API and implementation for a simple framebuffer.
- *
- * @image html lolshield.jpg
- * @snippet lol.cxx Interesting
- */
-class LoL {
-    public:
-        /**
-         * Instantiates an LoL object
-         * singleton
-         */
-        LoL();
-
-        /**
-         * LoL object destructor
-         */
-        ~LoL();
-
-        /**
-         * Gets a framebuffer pointer
-         * @return 0 if successful
-         */
-        unsigned char *getFramebuffer();
-
-        /**
-         * Gets a pixel at specified coordinates
-         * @param x Coordinate x
-         * @param y Coordinate y
-         * @return true if the pixel is on, false if off
-         * @throws std::invalid_argument if pixel is out of bounds
-         */
-        bool getPixel(int x, int y);
-
-        /**
-         * Sets a pixel at specified coordinates
-         * @param x Coordinate x
-         * @param y Coordinate y
-         * @param pixel false is off, true is on
-         * @throws std::invalid_argument if pixel is out of bounds
-         */
-        void setPixel(int x, int y, bool pixel);
-
-    private:
-        mraa_gpio_context m_LoLCtx[14];
-        unsigned char framebuffer[LOL_X*LOL_Y];
-        pthread_t drawer_thread;
-};
-};
-
diff --git a/src/lol/lol.i b/src/lol/lol.i
deleted file mode 100644
index 419b2cb..0000000
--- a/src/lol/lol.i
+++ /dev/null
@@ -1,29 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "arrays_java.i";
-%typemap(jni) unsigned char* "jbyteArray";
-%typemap(jtype) unsigned char* "byte[]";
-%typemap(jstype) unsigned char* "byte[]";
-
-%typemap(javaout) unsigned char* {
- return $jnicall;
-}
-
-%typemap(out) unsigned char* {
-    $result = JCALL1(NewByteArray, jenv, LOL_X*LOL_Y);
-    JCALL4(SetByteArrayRegion, jenv, $result, 0, LOL_X*LOL_Y-1, reinterpret_cast<jbyte*>($1));
-    delete [] $1;
-}
-
-JAVA_JNI_LOADLIBRARY(javaupm_lol)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "lol.hpp"
-%}
-%include "lol.hpp"
-/* END Common SWIG syntax */
diff --git a/src/lol/lol.json b/src/lol/lol.json
deleted file mode 100644
index dd9253a..0000000
--- a/src/lol/lol.json
+++ /dev/null
@@ -1,32 +0,0 @@
-{
-    "Library": "lol",
-    "Description": "API for the Olimex LoL Array",
-    "Sensor Class":
-    {
-        "LoL":
-        {
-            "Name": "Lots of LEDs (LoL) Array Rev A",
-            "Description": "This module defines the LoL API and implementation for a simple framebuffer.",
-            "Aliases": ["lol"],
-            "Categories": ["display"],
-            "Connections": ["gpio"],
-            "Project Type": ["prototyping"],
-            "Manufacturers": ["olimex"],
-            "Kits": [],
-            "Examples":
-            {
-                "Java": ["LoL_Example.java", "LoL_example_Example.java"],
-                "Python": [],
-                "Node.js": [],
-                "C++": ["lol.cxx"],
-                "C": []
-            },
-            "Urls" :
-            {
-                "Product Pages": ["https://www.olimex.com/Products/Duino/Shields/SHIELD-LOL/"],
-                "Datasheets": [],
-                "Schematics": []
-            }
-        }
-    }
-}
diff --git a/src/loudness/CMakeLists.txt b/src/loudness/CMakeLists.txt
deleted file mode 100644
index 35e5e46..0000000
--- a/src/loudness/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME loudness
-    DESCRIPTION "Loudness Sensor"
-    C_HDR loudness.h
-    C_SRC loudness.c
-    CPP_SRC loudness.cxx
-    CPP_HDR loudness.hpp
-    FTI_SRC loudness_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa)
diff --git a/src/loudness/loudness.c b/src/loudness/loudness.c
deleted file mode 100644
index 4220c06..0000000
--- a/src/loudness/loudness.c
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#include "loudness.h"
-
-loudness_context loudness_init(int pin) {
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        return NULL;
-    }
-
-    loudness_context dev =
-      (loudness_context) malloc(sizeof(struct _loudness_context));
-
-    if (!dev)
-      return NULL;
-
-    dev->aio = mraa_aio_init(pin);
-
-    if (!dev->aio)
-      {
-        free(dev);
-        return NULL;
-      }
-
-    return dev;
-}
-
-void loudness_close(loudness_context dev) {
-    mraa_aio_close(dev->aio);
-    free(dev);
-}
-
-upm_result_t loudness_get_value(loudness_context dev, int* val) {
-    *val = mraa_aio_read(dev->aio);
-
-    return UPM_SUCCESS;
-}
diff --git a/src/loudness/loudness.cxx b/src/loudness/loudness.cxx
deleted file mode 100644
index 3aa381c..0000000
--- a/src/loudness/loudness.cxx
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-
-#include "loudness.hpp"
-
-using namespace std;
-using namespace upm;
-
-Loudness::Loudness(int pin, float aref) :
-  m_aio(pin)
-{
-  m_aRes = m_aio.getBit();
-  m_aref = aref;
-}
-
-Loudness::~Loudness()
-{
-}
-
-float Loudness::loudness()
-{
-  int val = m_aio.read();
-
-  return(val * (m_aref / float(1 << m_aRes)));
-}
diff --git a/src/loudness/loudness.h b/src/loudness/loudness.h
deleted file mode 100644
index bc294ad..0000000
--- a/src/loudness/loudness.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef LOUDNESS_LOUDNESS_H_
-#define LOUDNESS_LOUDNESS_H_
-
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-
-#include "upm.h"
-#include "mraa/aio.h"
-
-/**
- * @file loudness.h
- * @library loudness
- * @brief C API for the Analog Loudness Sensor
- *
- * @include loudness.c
- */
-
-/**
- * device context
- */
-typedef struct _loudness_context {
-    mraa_aio_context            aio;
-} *loudness_context;
-
-/**
- * Loudness Initialization function
- *
- * @param pin AIO pin to use
- * @return void* pointer to the sensor struct
- */
-loudness_context loudness_init(int pin);
-
-/**
- * Loudness destructor
- *
- * @param void* pointer to the sensor struct
- */
-void loudness_close(loudness_context dev);
-
-/**
- * Function gets the loudness raw value (currently)
- *
- * @param void* pointer to the sensor struct
- * @param int* pointer to store the loudness value.
- * @return upm_result_t UPM success/error code
- */
-upm_result_t loudness_get_value(loudness_context dev, int* val);
-
-#endif /* LOUDNESS_LOUDNESS_H_ */
diff --git a/src/loudness/loudness.hpp b/src/loudness/loudness.hpp
deleted file mode 100644
index 8fde58c..0000000
--- a/src/loudness/loudness.hpp
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <iostream>
-#include <string>
-#include <mraa/aio.hpp>
-
-namespace upm {
-  /**
-   * @brief Loudness Sensors Library
-   * @defgroup loudness libupm-loudness
-   * @ingroup dfrobot seeed analog sound
-   */
-
-  /**
-   * @library loudness
-   * @sensor loudness
-   * @comname Loudness Sensor
-   * @altname Grove loudness hyld9767
-   * @type sound
-   * @man dfrobot seeed
-   * @web http://www.dfrobot.com/index.php?route=product/product&product_id=83
-   * @con analog
-   *
-   * @brief API for the Loudness Sensor
-   *
-   * This sensor family returns an analog voltage proportional to the
-   * loudness of the ambient environment.  It's output does not
-   * correspond to a particular sound level in decibels.  The higher
-   * the output voltage, the louder the ambient noise level.
-   *
-   * This device uses an electret microphone for sound input.
-   *
-   * This driver was developed using the DFRobot Loudness Sensor V2
-   * and the Grove Loudness sensor.
-   *
-   * @image html groveloudness.jpg
-   * @snippet loudness.cxx Interesting
-   */
-
-  class Loudness {
-  public:
-
-    /**
-     * Loudness constructor
-     *
-     * @param pin Analog pin to use
-     * @param aref Analog reference voltage; default is 5.0 V
-     */
-    Loudness(int pin, float aref=5.0);
-
-    /**
-     * Loudness destructor
-     */
-    ~Loudness();
-
-    /**
-     * Returns the voltage detected on the analog pin
-     *
-     * @return The detected voltage
-     */
-    float loudness();
-
-  protected:
-    mraa::Aio m_aio;
-
-  private:
-    float m_aref;
-    // ADC resolution
-    int m_aRes;
-  };
-}
-
-
diff --git a/src/loudness/loudness.json b/src/loudness/loudness.json
deleted file mode 100644
index add1d2b..0000000
--- a/src/loudness/loudness.json
+++ /dev/null
@@ -1,39 +0,0 @@
-{
-    "Library": "loudness",
-    "Description": "API for the Loudness Sensor",
-    "Sensor Class":
-    {
-        "Loudness":
-        {
-            "Name": "Loudness Sensor",
-            "Description": "This sensor family returns an analog voltage proportional to the loudness of the ambient environment.  It's output does not correspond to a particular sound level in decibels.  The higher the output voltage, the louder the ambient noise level. This device uses an electret microphone for sound input. This driver was developed using the DFRobot Loudness Sensor V2 and the Grove Loudness sensor.",
-            "Aliases": ["loudness"],
-            "Categories": ["audio"],
-            "Connections": ["analog"],
-            "Project Type": ["noise control", "prototyping"],
-            "Manufacturers": ["seeed", "dfrobot"],
-            "Kits": [],
-            "Image": "loudness.jpg",
-            "Examples":
-            {
-                "Java": [],
-                "Python": ["loudness.py"],
-                "Node.js": ["loudness.js"],
-                "C++": ["loudness.cxx"],
-                "C": ["loudness.c"]
-            },
-            "Specifications":
-            {
-                "Operating Voltage": {"unit": "V", "low": 3.5, "high": 10},
-                "Measurement Range": {"unit": "Hz", "low": 50, "high": 2000}
-
-            },
-            "Urls" :
-            {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-Loudness-Sensor-p-1382.html"],
-                "Datasheets": ["http://wiki.seeed.cc/Grove-Loudness_Sensor/", "https://raw.githubusercontent.com/SeeedDocument/Grove-Loudness_Sensor/master/res/LM2904DR.pdf"],
-                "Schematics": ["https://raw.githubusercontent.com/SeeedDocument/Grove-Loudness_Sensor/master/res/Grove_loudness_sensor.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/loudness/loudness_fti.c b/src/loudness/loudness_fti.c
deleted file mode 100644
index 97be477..0000000
--- a/src/loudness/loudness_fti.c
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#include "loudness.h"
-#include "upm_fti.h"
-
-/**
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_loudness_name[] = "loudness";
-const char upm_loudness_description[] = " Loudness Sensor";
-const upm_protocol_t upm_loudness_protocol[] = {UPM_ANALOG};
-const upm_sensor_t upm_loudness_category[] = {UPM_AUDIO};
-
-// forward declarations
-const void* upm_loudness_get_ft(upm_sensor_t sensor_type);
-const upm_sensor_descriptor_t upm_loudness_get_descriptor();
-void* upm_loudness_init_name();
-void upm_loudness_close(void* dev);
-
-
-const upm_sensor_descriptor_t upm_loudness_get_descriptor(){
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_loudness_name;
-    usd.description = upm_loudness_description;
-    usd.protocol_size = 1;
-    usd.protocol = upm_loudness_protocol;
-    usd.category_size = 1;
-    usd.category = upm_loudness_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = &upm_loudness_init_name,
-    .upm_sensor_close = &upm_loudness_close,
-    .upm_sensor_get_descriptor = &upm_loudness_get_descriptor
-};
-
-const void* upm_loudness_get_ft(upm_sensor_t sensor_type){
-    if(sensor_type == UPM_SENSOR){
-        return &ft;
-    }
-    return NULL;
-}
-
-void* upm_loudness_init_name(){
-    return NULL;
-}
-
-void upm_loudness_close(void* dev){
-    loudness_close((loudness_context)dev);
-}
-
-upm_result_t upm_loudness_get_value(void* dev, int* val){
-    return loudness_get_value((loudness_context)dev, val);
-}
\ No newline at end of file
diff --git a/src/lp8860/CMakeLists.txt b/src/lp8860/CMakeLists.txt
deleted file mode 100644
index 2c1e4cf..0000000
--- a/src/lp8860/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "lp8860")
-set (libdescription "LED Lighting Controller")
-set (module_src ${libname}.cxx mraa-utils.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa interfaces)
diff --git a/src/lp8860/lp8860.cxx b/src/lp8860/lp8860.cxx
deleted file mode 100644
index da1ddeb..0000000
--- a/src/lp8860/lp8860.cxx
+++ /dev/null
@@ -1,280 +0,0 @@
-/*
- * Author: Henry Bruce <henry.bruce@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <unistd.h>
-#include <string.h>
-#include "lp8860.hpp"
-#include "mraa-utils.hpp"
-
-// Used to prevent silent failure in mraa_i2c_write()
-// Value come from I2C_SMBUS_I2C_BLOCK_MAX in i2c driver
-#define MAX_I2C_WRITE_SIZE 32
-
-#define LP8860_I2C_ADDR 0x2D
-
-#define LP8860_DISP_CL1_BRT_MSB		0x00
-#define LP8860_DISP_CL1_BRT_LSB		0x01
-#define LP8860_DISP_CL1_CURR_MSB	0x02
-#define LP8860_DISP_CL1_CURR_LSB	0x03
-#define LP8860_CL2_BRT_MSB		0x04
-#define LP8860_CL2_BRT_LSB		0x05
-#define LP8860_CL2_CURRENT		0x06
-#define LP8860_CL3_BRT_MSB		0x07
-#define LP8860_CL3_BRT_LSB		0x08
-#define LP8860_CL3_CURRENT		0x09
-#define LP8860_CL4_BRT_MSB		0x0a
-#define LP8860_CL4_BRT_LSB		0x0b
-#define LP8860_CL4_CURRENT		0x0c
-#define LP8860_CONFIG			0x0d
-#define LP8860_STATUS			0x0e
-#define LP8860_FAULT			0x0f
-#define LP8860_LED_FAULT		0x10
-#define LP8860_FAULT_CLEAR		0x11
-#define LP8860_ID			0x12
-#define LP8860_TEMP_MSB			0x13
-#define LP8860_TEMP_LSB			0x14
-#define LP8860_DISP_LED_CURR_MSB	0x15
-#define LP8860_DISP_LED_CURR_LSB	0x16
-#define LP8860_DISP_LED_PWM_MSB		0x17
-#define LP8860_DISP_LED_PWM_LSB		0x18
-#define LP8860_EEPROM_CNTRL		0x19
-#define LP8860_EEPROM_UNLOCK		0x1a
-
-#define LP8860_EEPROM_REG_0		0x60
-#define LP8860_EEPROM_REG_1		0x61
-#define LP8860_EEPROM_REG_2		0x62
-#define LP8860_EEPROM_REG_3		0x63
-#define LP8860_EEPROM_REG_4		0x64
-#define LP8860_EEPROM_REG_5		0x65
-#define LP8860_EEPROM_REG_6		0x66
-#define LP8860_EEPROM_REG_7		0x67
-#define LP8860_EEPROM_REG_8		0x68
-#define LP8860_EEPROM_REG_9		0x69
-#define LP8860_EEPROM_REG_10		0x6a
-#define LP8860_EEPROM_REG_11		0x6b
-#define LP8860_EEPROM_REG_12		0x6c
-#define LP8860_EEPROM_REG_13		0x6d
-#define LP8860_EEPROM_REG_14		0x6e
-#define LP8860_EEPROM_REG_15		0x6f
-#define LP8860_EEPROM_REG_16		0x70
-#define LP8860_EEPROM_REG_17		0x71
-#define LP8860_EEPROM_REG_18		0x72
-#define LP8860_EEPROM_REG_19		0x73
-#define LP8860_EEPROM_REG_20		0x74
-#define LP8860_EEPROM_REG_21		0x75
-#define LP8860_EEPROM_REG_22		0x76
-#define LP8860_EEPROM_REG_23		0x77
-#define LP8860_EEPROM_REG_24		0x78
-
-#define LP8860_LOCK_EEPROM		0x00
-#define LP8860_UNLOCK_EEPROM		0x01
-#define LP8860_LOAD_EEPROM		0x01
-#define LP8860_PROGRAM_EEPROM		0x02
-#define LP8860_EEPROM_CODE_1		0x08
-#define LP8860_EEPROM_CODE_2		0xba
-#define LP8860_EEPROM_CODE_3		0xef
-
-#define LP8860_CLEAR_FAULTS		0x01
-#define LP8860_INVALID_ID       0x00
-
-using namespace upm;
-
-LP8860::LP8860(int gpioPower, int i2cBus)
-{
-    status = mraa::ERROR_INVALID_RESOURCE;
-    mraa_set_log_level(7);
-    pinPower = gpioPower;
-    i2c = new mraa::I2c(i2cBus);
-    i2c->address(LP8860_I2C_ADDR);
-    if (isAvailable())
-        status = mraa::SUCCESS;
-   if (status != mraa::SUCCESS)
-      UPM_THROW("i2c config failed.");
-}
-
-LP8860::~LP8860()
-{
-    delete i2c;
-}
-
-
-bool LP8860::isAvailable()
-{
-    bool wasPowered = true;
-
-    // Check power state
-    if(!isPowered()) {
-        wasPowered = false;
-        MraaUtils::setGpio(pinPower, 1);
-    }
-
-    // Read ID register
-    // mraa_i2c_address(i2c, LP8860_I2C_ADDR);
-    uint8_t id = i2c->readReg(LP8860_ID);
-    // Turn off to save power if not required
-    if (!wasPowered)
-        MraaUtils::setGpio(pinPower, 0);
-
-    return id >= 0x10;
-}
-
-
-bool LP8860::isPowered()
-{
-    return MraaUtils::getGpio(pinPower);
-}
-
-
-void LP8860::setPowerOn()
-{
-    if (!isPowered())
-    {
-        MraaUtils::setGpio(pinPower, 1);
-        setBrightness(0);
-        loadEEPROM();
-        allowMaxCurrent();
-    }
-}
-
-
-void LP8860::setPowerOff()
-{
-    MraaUtils::setGpio(pinPower, 0);
-}
-
-
-int LP8860::getBrightness()
-{
-    uint8_t msb = i2cReadByte(LP8860_DISP_CL1_BRT_MSB);
-    uint8_t lsb = i2cReadByte(LP8860_DISP_CL1_BRT_LSB);
-    int percent = (100 * ((int)msb << 8 | lsb)) / 0xFFFF;
-    return percent;
-}
-
-
-void LP8860::setBrightness(int dutyPercent)
-{
-    int value = (0xFFFF * dutyPercent) / 100;
-    int msb = value >> 8;
-    int lsb = value & 0xFF;
-    i2cWriteByte(LP8860_DISP_CL1_BRT_MSB, msb);
-    i2cWriteByte(LP8860_DISP_CL1_BRT_LSB, lsb);
-    value = (0x1FFF * dutyPercent) / 100;
-    msb = value >> 8;
-    lsb = value & 0xFF;
-    i2cWriteByte(LP8860_CL2_BRT_MSB, msb);
-    i2cWriteByte(LP8860_CL2_BRT_LSB, lsb);
-    i2cWriteByte(LP8860_CL3_BRT_MSB, msb);
-    i2cWriteByte(LP8860_CL3_BRT_LSB, lsb);
-    i2cWriteByte(LP8860_CL4_BRT_MSB, msb);
-    i2cWriteByte(LP8860_CL4_BRT_LSB, lsb);
-}
-
-
-void LP8860::loadEEPROM()
-{
-    const int eepromTableSize = 0x19;
-    uint8_t eepromInitTable[] = {
-        0xEF, 0xFF, 0xDC, 0xAE, 0x5F, 0xE5, 0xF2, 0x77,
-        0x77, 0x71, 0x3F, 0xB7, 0x17, 0xEF, 0xB0, 0x87,
-        0xCF, 0x72, 0xC5, 0xDE, 0x35, 0x06, 0xDE, 0xFF,
-        0x3E
-    };
-
-    uint8_t* buf = new unsigned char[eepromTableSize + 1];
-
-    // Load EEPROM
-    // printf("Loading LP8860 EEPROM\n");
-    i2cWriteByte(LP8860_EEPROM_CNTRL, LP8860_LOAD_EEPROM);
-    usleep(100000);
-
-    // Check contents and program if not already done
-    i2cReadBuffer(LP8860_EEPROM_REG_0, buf, eepromTableSize);
-    if (memcmp(eepromInitTable, buf, eepromTableSize) != 0)
-    {
-        printf("LP8860 EEPROM not initialized - programming...\n");
-        // Unlock EEPROM
-        i2cWriteByte(LP8860_EEPROM_UNLOCK, LP8860_EEPROM_CODE_1);
-        i2cWriteByte(LP8860_EEPROM_UNLOCK, LP8860_EEPROM_CODE_2);
-        i2cWriteByte(LP8860_EEPROM_UNLOCK, LP8860_EEPROM_CODE_3);
-        i2cWriteBuffer(LP8860_EEPROM_REG_0, eepromInitTable, eepromTableSize);
-        i2cWriteByte(LP8860_EEPROM_CNTRL, LP8860_PROGRAM_EEPROM);
-        usleep(200000);
-        i2cWriteByte(LP8860_EEPROM_CNTRL, 0);
-        i2cWriteByte(LP8860_EEPROM_UNLOCK, LP8860_LOCK_EEPROM);
-    }
-}
-
-
-void LP8860::allowMaxCurrent()
-{
-    i2cWriteByte(LP8860_DISP_CL1_CURR_MSB, 0x0F);
-    i2cWriteByte(LP8860_DISP_CL1_CURR_LSB, 0xFF);
-    i2cWriteByte(LP8860_CL2_CURRENT, 0xFF);
-    i2cWriteByte(LP8860_CL3_CURRENT, 0xFF);
-    i2cWriteByte(LP8860_CL4_CURRENT, 0xFF);
-}
-
-
-void LP8860::i2cWriteByte(int reg, int value)
-{
-    status = i2c->writeReg(static_cast<uint8_t>(reg), static_cast<uint8_t>(value));
-    if (status != mraa::SUCCESS)
-        UPM_THROW("i2cWriteByte failed");
-}
-
-
-uint8_t LP8860::i2cReadByte(uint8_t reg)
-{
-    uint8_t value;
-    if (i2c->readBytesReg(reg, &value, 1) != 1)
-        UPM_THROW("i2cReadByte failed");
-    return value;
-}
-
-
-void LP8860::i2cWriteBuffer(int reg, uint8_t* buf, int length)
-{
-    if (length <= MAX_I2C_WRITE_SIZE)
-    {
-        uint8_t* writeBuf = new unsigned char[length + 1];
-        writeBuf[0] = reg;
-        memcpy(&writeBuf[1], buf, length);
-        status = i2c->write(writeBuf, length + 1);
-        delete[] writeBuf;
-    }
-    else
-        status = mraa::ERROR_INVALID_PARAMETER;
-    if (status != mraa::SUCCESS)
-        UPM_THROW("i2cWriteBuffer failed");
-}
-
-
-void LP8860::i2cReadBuffer(int reg, uint8_t* buf, int length)
-{
-    if (i2c->readBytesReg(reg, buf, length) != length)
-        UPM_THROW("i2cReadBuffer failed");
-}
-
diff --git a/src/lp8860/lp8860.hpp b/src/lp8860/lp8860.hpp
deleted file mode 100644
index 99dac61..0000000
--- a/src/lp8860/lp8860.hpp
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Author: Henry Bruce <henry.bruce@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "interfaces/iLightController.hpp"
-#include "mraa/i2c.hpp"
-
-namespace upm
-{
-/**
- * @brief LP8860 LED Lighting Controller
- * @defgroup lp8860 libupm-lp8860
- * @ingroup ti i2c light ilightcontroller
- */
-
-/**
- * @library lp8860
- * @sensor lp8860
- * @comname LED Lighting Controller
- * @altname LP8860
- * @type light
- * @man ti
- * @con i2c
- * @web http://www.ti.com/product/LP8860-Q1
- *
- * @brief API for LP8860 LED Lighting Controller
- *
- * The Texas Instrumements
- * [LP8860-Q1](http://www.ti.com/product/lp8860-q1)
- * Automotive Catalog Low-EMI, High-Performance 4-Channel LED Driver
- *
- * @snippet lp8860.cxx Interesting
- */
-class LP8860 : public upm::ILightController
-{
-public:
-   LP8860(int gpioPower, int i2cBus);
-   ~LP8860();
-   virtual const char* getModuleName() { return "lp8860"; }
-   bool isPowered();
-   void setPowerOn();
-   void setPowerOff();
-   int getBrightness();
-   void setBrightness(int dutyPercent);
-
-private:
-   /* Disable implicit copy and assignment operators */
-   LP8860(const LP8860&) = delete;
-   LP8860 &operator=(const LP8860&) = delete;
-
-   void i2cWriteByte(int reg, int value);
-   void i2cWriteBuffer(int reg, uint8_t* buf, int length);
-   uint8_t i2cReadByte(uint8_t reg);
-   void i2cReadBuffer(int reg, uint8_t* buf, int length);
-   void loadEEPROM();
-   void allowMaxCurrent();
-   bool isAvailable();
-
-   mraa::Result status;
-   mraa::I2c* i2c;
-   int pinPower;
-};
-
-
-}
-
diff --git a/src/lp8860/lp8860.i b/src/lp8860/lp8860.i
deleted file mode 100644
index 6b638ff..0000000
--- a/src/lp8860/lp8860.i
+++ /dev/null
@@ -1,17 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%typemap(javaimports) SWIGTYPE %{import upm_interfaces.*;%}
-%import "../interfaces/javaupm_iLightController.i"
-
-JAVA_JNI_LOADLIBRARY(javaupm_lp8860)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "lp8860.hpp"
-%}
-%include "lp8860.hpp"
-/* END Common SWIG syntax */
diff --git a/src/lp8860/lp8860.json b/src/lp8860/lp8860.json
deleted file mode 100644
index 48550bf..0000000
--- a/src/lp8860/lp8860.json
+++ /dev/null
@@ -1,42 +0,0 @@
-{
-    "Library": "lp8860",
-    "Description": "LED Light Controller Library",
-    "Sensor Class":
-    {
-        "LP8860":
-        {
-            "Name": "API for LP8860 LED Lighting Controller",
-            "Description": "The LP8860-Q1 is an automotive high-efficiency LED driver with boost controller. It has 4 high-precision current sinks that can be controlled by a PWM input signal, an SPI or I2C master, or both ",
-            "Aliases": ["lp8860"],
-            "Categories": ["light Controller"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping", "industrial"],
-            "Manufacturers": ["Texas Instruments"],
-            "Image": "",
-            "Examples":
-            {
-                "C++": ["lp8860.cxx"]
-            },
-            "Specifications":
-            {
-                "Vdd": {"unit": "v", "low" : 3, "high": 48},
-                "Iavg": {"unit": "mA", "low" : 1, "high": 150},
-                "Frequency Range": {"unit": "KHz", "low" : 100, "high": 2200},
-                "Temperature Range": {"unit": "C", "low" : -40, "high": 125}
-            },
-            "Platforms":
-            {
-                "Intel Joule Module":
-                {
-                    "Notes": ["Might need pull up resistors"]
-                }
-            },
-            "Urls" :
-            {
-                "Product Pages": ["http://www.ti.com/product/LP8860-Q1"],
-                "Datasheets": ["http://www.ti.com/lit/ds/symlink/lp8860-q1.pdf"],
-                "Schematics": ["http://www.ti.com/general/docs/datasheetdiagram.tsp?genericPartNumber=LP8860-Q1&diagramId=66853"]
-            }
-        }
-    }
-}
diff --git a/src/lp8860/mraa-utils.cxx b/src/lp8860/mraa-utils.cxx
deleted file mode 100644
index 4d23510..0000000
--- a/src/lp8860/mraa-utils.cxx
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Author: Henry Bruce <henry.bruce@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string>
-
-#include "mraa-utils.hpp"
-#include "mraa/gpio.hpp"
-
- #define UPM_THROW(msg) throw std::runtime_error(std::string(__FUNCTION__) + ": " + (msg))
-
-void MraaUtils::setGpio(int pin, int level)
-{
-/*
-   mraa_result_t status = MRAA_ERROR_NO_RESOURCES; 
-   mraa_gpio_context gpio = mraa_gpio_init(pin);
-   if (gpio != NULL) 
-   {
-      mraa_gpio_dir(gpio, MRAA_GPIO_OUT);
-      status = mraa_gpio_write(gpio, level);
-      mraa_gpio_close(gpio);
-   } 
-   return status;
-*/
-   mraa::Gpio gpio(pin);
-   gpio.dir(mraa::DIR_OUT);
-   if (gpio.write(level) != mraa::SUCCESS)
-      UPM_THROW("gpio write failed");
-}
-
-
-int MraaUtils::getGpio(int pin)
-{
-/*
-   mraa_result_t status = MRAA_ERROR_NO_RESOURCES; 
-   mraa_gpio_context gpio = mraa_gpio_init(pin);
-   if (gpio != NULL) 
-   {
-      status = mraa_gpio_dir(gpio, MRAA_GPIO_IN);
-      int value = mraa_gpio_read(gpio);
-      if (value != -1)
-         *level = value;
-      else
-         status = MRAA_ERROR_NO_RESOURCES; 
-      mraa_gpio_close(gpio);
-   }
-   return status;       
-*/
-   mraa::Gpio gpio(pin);
-   gpio.dir(mraa::DIR_IN);
-   return gpio.read();
-}
-
-
diff --git a/src/lp8860/mraa-utils.hpp b/src/lp8860/mraa-utils.hpp
deleted file mode 100644
index f9e6acc..0000000
--- a/src/lp8860/mraa-utils.hpp
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Author: Henry Bruce <henry.bruce@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include "mraa/types.h"
-
-class __attribute__ ((visibility("hidden"))) MraaUtils
-{
-public:
-   static void setGpio(int pin, int level);
-   static int getGpio(int pin);
-};
-
-
-
diff --git a/src/lpd8806/CMakeLists.txt b/src/lpd8806/CMakeLists.txt
deleted file mode 100644
index e55c229..0000000
--- a/src/lpd8806/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "lpd8806")
-set (libdescription "Digital RGB LED Strip Controller")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/lpd8806/lpd8806.cxx b/src/lpd8806/lpd8806.cxx
deleted file mode 100644
index 37573e3..0000000
--- a/src/lpd8806/lpd8806.cxx
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <unistd.h>
-#include <stdlib.h>
-#include <cstring>
-#include <stdexcept>
-
-#include "lpd8806.hpp"
-
-using namespace upm;
-
-LPD8806::LPD8806 (int bus, int csn, uint16_t pixelCount) :m_spi(bus), m_csnPinCtx(csn) {
-    mraa::Result error = mraa::SUCCESS;
-    m_name = "LPD8806";
-
-    m_pixels = NULL;
-
-    error = m_csnPinCtx.dir (mraa::DIR_OUT);
-    if (error != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) + 
-                                    ": GPIO failed to set direction");
-    }
-
-    CSOff ();
-
-    // set spi mode to mode2 (CPOL = 0, CPHA = 0)
-    m_spi.mode (mraa::SPI_MODE0);
-
-    CSOn ();
-    // issue initial latch/reset to strip:
-    for (uint16_t i = ((pixelCount + 31) / 32); i > 0; i--) {
-        m_spi.writeByte (0);
-    }
-    CSOff ();
-
-    m_pixelsCount = pixelCount;
-
-    uint8_t  latchBytes;
-    uint16_t dataBytes, totalBytes;
-
-    dataBytes  = m_pixelsCount * 3;
-    latchBytes = (m_pixelsCount + 31) / 32;
-    totalBytes = dataBytes + latchBytes;
-    if ((m_pixels = (uint8_t *) malloc(totalBytes))) {
-        memset ( m_pixels           , 0x80, dataBytes);  // Init to RGB 'off' state
-        memset (&m_pixels[dataBytes], 0   , latchBytes); // Clear latch bytes
-    }
-}
-
-LPD8806::~LPD8806() {
-    if (m_pixels) {
-        free(m_pixels);
-    }
-}
-
-void
-LPD8806::setPixelColor (uint16_t pixelOffset, uint8_t r, uint8_t g, uint8_t b) {
-    if (pixelOffset < m_pixelsCount) { // Arrays are 0-indexed, thus NOT '<='
-        uint8_t *ptr = &m_pixels[pixelOffset * 3];
-        *ptr++ = g | 0x80; // Strip color order is GRB,
-        *ptr++ = r | 0x80; // not the more common RGB,
-        *ptr++ = b | 0x80; // so the order here is intentional; don't "fix"
-    }
-}
-
-void
-LPD8806::show (void) {
-    uint8_t  *ptr   = m_pixels;
-    uint16_t byte   = (m_pixelsCount * 3) + ((m_pixelsCount + 31) / 32);
-    
-    while (byte--) {
-        m_spi.writeByte (*ptr++);
-    }
-}
-
-uint16_t
-LPD8806::getStripLength (void) {
-    return m_pixelsCount;
-}
-
-/*
- * **************
- *  private area
- * **************
- */
-
-mraa::Result
-LPD8806::CSOn () {
-    return m_csnPinCtx.write (HIGH);
-}
-
-mraa::Result
-LPD8806::CSOff () {
-    return m_csnPinCtx.write (LOW);
-}
diff --git a/src/lpd8806/lpd8806.hpp b/src/lpd8806/lpd8806.hpp
deleted file mode 100644
index f3df04d..0000000
--- a/src/lpd8806/lpd8806.hpp
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/aio.hpp>
-
-#include <mraa/gpio.hpp>
-
-#include <mraa/spi.hpp>
-
-#define HIGH                    1
-#define LOW                     0
-
-namespace upm {
-
-/**
- * @brief FastPixel LPD8806 LED Strip
- * @defgroup lpd8806 libupm-lpd8806
- * @ingroup adafruit spi led
- */
-
-/**
- * @library lpd8806
- * @sensor lpd8806
- * @comname Digital RGB LED Strip Controller
- * @type led
- * @man adafruit
- * @con spi
- * @web https://www.adafruit.com/product/306
- *
- * @brief API for the LPD8806 RGB LED Strip Controller
- *
- * FastPixel* LPD8806 is an RGB LED strip controller.
- *
- * @image html lpd8806.jpg
- * @snippet lpd8806.cxx Interesting
- */
-class LPD8806 {
-    public:
-
-        /**
-         * Instantiates an LPD8806 object
-         *
-         * @param bus SPI bus to use
-         * @param csn Chip select pin
-         * @param pixelCount Number of pixels in the strip
-         */
-        LPD8806 (int bus, int csn, uint16_t pixelCount);
-
-        /**
-         * LPD8806 object destructor; basically, it frees the allocated
-         * pixel buffer.
-         */
-        ~LPD8806 ();
-
-        /**
-         * @param pixelOffset Pixel offset in the strip of the pixel
-         * @param r Red LED
-         * @param g Green LED
-         * @param b Blue LED
-         */
-        void setPixelColor (uint16_t pixelOffset, uint8_t r, uint8_t g, uint8_t b);
-
-        /**
-         * Writes the data stored in the array of pixels to the chip
-         */
-        void show (void);
-
-        /**
-         * Returns the length of the LED strip
-         */
-        uint16_t getStripLength (void);
-
-        /**
-         * Returns the name of the component
-         */
-        std::string name()
-        {
-            return m_name;
-        }
-    private:
-        /* Disable implicit copy and assignment operators */
-        LPD8806(const LPD8806&) = delete;
-        LPD8806 &operator=(const LPD8806&) = delete;
-
-        std::string m_name;
-        mraa::Spi        m_spi;
-        mraa::Gpio       m_csnPinCtx;
-
-        uint8_t*                m_pixels;
-        uint8_t                 m_pixelsCount;
-
-        uint8_t readRegister (uint8_t reg);
-        void writeRegister (uint8_t reg, uint8_t data);
-
-        /**
-         * Sets the chip select pin to LOW
-         */
-        mraa::Result CSOn ();
-
-        /**
-         * Sets the chip select pin to HIGH
-         */
-        mraa::Result CSOff ();
-};
-
-}
diff --git a/src/lpd8806/lpd8806.json b/src/lpd8806/lpd8806.json
deleted file mode 100644
index 88cb442..0000000
--- a/src/lpd8806/lpd8806.json
+++ /dev/null
@@ -1,37 +0,0 @@
-{
-    "Library": "lpd8806",
-    "Description": "API for the LPD8806 RGB LED Strip Controller",
-    "Sensor Class":
-    {
-        "LPD8806":
-        {
-            "Name": "Digital RGB LED Strip Controller",
-            "Description": "FastPixel* LPD8806 is an RGB LED strip controller.",
-            "Aliases": ["lpd8806"],
-            "Categories": ["display"],
-            "Connections": ["spi"],
-            "Project Type": ["lighting", "rgb", "prototyping"],
-            "Manufacturers": ["adafruit"],
-            "Kits": [],
-            "Image": "lpd8806.jpg",
-            "Examples":
-            {
-                "Java": [],
-                "Python": [],
-                "Node.js": [],
-                "C++": ["lpd8806.cxx"],
-                "C": []
-            },
-            "Specifications":
-            {
-                "Operating Voltage": {"unit": "V", "max": 5}
-            },
-            "Urls" :
-            {
-                "Product Pages": ["https://www.adafruit.com/product/306"],
-                "Datasheets": ["https://cdn-learn.adafruit.com/downloads/pdf/digital-led-strip.pdf"],
-                "Schematics": []
-            }
-        }
-    }
-}
diff --git a/src/lsm303agr/CMakeLists.txt b/src/lsm303agr/CMakeLists.txt
deleted file mode 100644
index 240e3d3..0000000
--- a/src/lsm303agr/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME lsm303agr
-    DESCRIPTION "3-Axis eCompass Module"
-    C_HDR lsm303agr.h lsm303agr_defs.h
-    C_SRC lsm303agr.c
-    CPP_HDR lsm303agr.hpp
-    CPP_SRC lsm303agr.cxx
-    FTI_SRC lsm303agr_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/lsm303agr/lsm303agr.c b/src/lsm303agr/lsm303agr.c
deleted file mode 100644
index f155988..0000000
--- a/src/lsm303agr/lsm303agr.c
+++ /dev/null
@@ -1,792 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-
-#include <unistd.h>
-#include <assert.h>
-
-#include "upm_utilities.h"
-
-#include "lsm303agr.h"
-
-// some useful macros to save on typing and text wrapping
-#undef _SHIFT
-#define _SHIFT(x) (_LSM303AGR_##x##_SHIFT)
-
-#undef _MASK
-#define _MASK(x) (_LSM303AGR_##x##_MASK)
-
-#undef _SHIFTMASK
-#define _SHIFTMASK(x) (_MASK(x) << _SHIFT(x))
-
-
-// init
-lsm303agr_context lsm303agr_init(int bus, int acc_addr, int mag_addr)
-{
-    if (acc_addr <= 0 && mag_addr <= 0)
-    {
-        printf("%s: At least one device must be enabled\n", __FUNCTION__);
-        return NULL;
-    }
-
-    lsm303agr_context dev =
-        (lsm303agr_context)malloc(sizeof(struct _lsm303agr_context));
-
-    if (!dev)
-        return NULL;
-
-    // zero out context
-    memset((void *)dev, 0, sizeof(struct _lsm303agr_context));
-
-    // make sure MRAA is initialized
-    if (mraa_init() != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed.\n", __FUNCTION__);
-        lsm303agr_close(dev);
-        return NULL;
-    }
-
-    if (acc_addr > 0)
-    {
-        if (!(dev->i2cACC = mraa_i2c_init(bus)))
-        {
-            printf("%s: mraa_i2c_init(acc) failed.\n", __FUNCTION__);
-            lsm303agr_close(dev);
-            return NULL;
-        }
-
-        if (mraa_i2c_address(dev->i2cACC, acc_addr))
-        {
-            printf("%s: mraa_i2c_address(acc) failed.\n", __FUNCTION__);
-            lsm303agr_close(dev);
-            return NULL;
-        }
-
-        // check the chip id
-        uint8_t chipID = lsm303agr_read_reg(dev, LSM303AGR_REG_WHO_AM_I_A);
-
-        if (chipID != LSM303AGR_CHIPID_ACC)
-        {
-            printf("%s: invalid accelerometer chip id: %02x.  Expected %02x\n",
-                   __FUNCTION__, chipID, LSM303AGR_CHIPID_ACC);
-            lsm303agr_close(dev);
-            return NULL;
-        }
-    }
-
-    // technically we could use a single i2c context since it is bus
-    // specific, but then we would need to call i2c_address() every
-    // time we wanted to talk to a specific device.  In addition, we
-    // can use the i2c context pointer to determine if a subsystem
-    // (acc or mag) is actually enabled throughout this driver.
-    if (mag_addr > 0)
-    {
-        if (!(dev->i2cMAG = mraa_i2c_init(bus)))
-        {
-            printf("%s: mraa_i2c_init(mag) failed.\n", __FUNCTION__);
-            lsm303agr_close(dev);
-            return NULL;
-        }
-
-        if (mraa_i2c_address(dev->i2cMAG, mag_addr))
-        {
-            printf("%s: mraa_i2c_address(mag) failed.\n", __FUNCTION__);
-            lsm303agr_close(dev);
-            return NULL;
-        }
-
-        // check the chip id
-        uint8_t chipID = lsm303agr_read_reg(dev, LSM303AGR_REG_WHO_AM_I_M);
-
-        if (chipID != LSM303AGR_CHIPID_MAG)
-        {
-            printf("%s: invalid magnetometer chip id: %02x.  Expected %02x\n",
-                   __FUNCTION__, chipID, LSM303AGR_CHIPID_MAG);
-            lsm303agr_close(dev);
-            return NULL;
-        }
-    }
-
-    // call devinit with a default high resolution mode
-    if (lsm303agr_devinit(dev, LSM303AGR_POWER_HIGH_RESOLUTION))
-    {
-        printf("%s: lsm303agr_devinit() failed.\n", __FUNCTION__);
-        lsm303agr_close(dev);
-        return NULL;
-    }
-
-    return dev;
-}
-
-void lsm303agr_close(lsm303agr_context dev)
-{
-    assert(dev != NULL);
-
-    lsm303agr_uninstall_isr(dev, LSM303AGR_INTERRUPT_ACC_1);
-    lsm303agr_uninstall_isr(dev, LSM303AGR_INTERRUPT_ACC_2);
-    lsm303agr_uninstall_isr(dev, LSM303AGR_INTERRUPT_MAG);
-
-    if (dev->i2cACC)
-        mraa_i2c_stop(dev->i2cACC);
-    if (dev->i2cMAG)
-        mraa_i2c_stop(dev->i2cMAG);
-
-    free(dev);
-}
-
-upm_result_t lsm303agr_devinit(const lsm303agr_context dev,
-                               LSM303AGR_POWER_MODE_T mode)
-{
-    assert(dev != NULL);
-
-    // magnetometer
-    if (dev->i2cMAG)
-    {
-        // enable temp compensation and continuous mode
-        uint8_t reg = lsm303agr_read_reg(dev, LSM303AGR_REG_CFG_REG_A_M);
-
-        reg &= ~_SHIFTMASK(CFG_REG_A_M_MD);
-        reg |= LSM303AGR_CFG_REG_A_M_COMP_TEMP_EN;
-        reg |= (LSM303AGR_CFG_A_M_MD_CONTINUOUS
-                << _SHIFT(CFG_REG_A_M_MD));
-
-        if (lsm303agr_write_reg(dev, LSM303AGR_REG_CFG_REG_A_M, reg))
-        {
-            printf("%s: lsm303agr_write_reg() failed.\n", __FUNCTION__);
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-
-        // set MAG ODR to 10Hz by default
-        if (lsm303agr_set_mag_odr(dev, LSM303AGR_CFG_A_M_ODR_10HZ))
-        {
-            printf("%s: lsm303agr_set_mag_odr() failed.\n", __FUNCTION__);
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-
-        upm_delay_ms(10);
-    }
-
-    // accelerometer
-    if (dev->i2cACC)
-    {
-        // enable all axes
-        uint8_t reg = lsm303agr_read_reg(dev, LSM303AGR_REG_CTRL_REG1_A);
-
-        reg |= LSM303AGR_CTRL_REG1_A_XEN
-            | LSM303AGR_CTRL_REG1_A_YEN
-            | LSM303AGR_CTRL_REG1_A_ZEN;
-
-        if (lsm303agr_write_reg(dev, LSM303AGR_REG_CTRL_REG1_A, reg))
-        {
-            printf("%s: lsm303agr_write_reg() failed.\n", __FUNCTION__);
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-
-        // enable BDU
-        reg = lsm303agr_read_reg(dev, LSM303AGR_REG_CTRL_REG4_A);
-        reg |= LSM303AGR_CTRL_REG4_A_BDU;
-
-        if (lsm303agr_write_reg(dev, LSM303AGR_REG_CTRL_REG4_A, reg))
-        {
-            printf("%s: lsm303agr_write_reg() failed.\n", __FUNCTION__);
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-
-        // enable temperature measurement
-        reg = lsm303agr_read_reg(dev, LSM303AGR_REG_TEMP_CFG_REG_A);
-        reg &= ~_SHIFTMASK(TEMP_CFG_REG_A_TEMP_EN);
-        reg |= (LSM303AGR_TEMP_EN_ON
-                << _SHIFT(TEMP_CFG_REG_A_TEMP_EN));
-
-        if (lsm303agr_write_reg(dev, LSM303AGR_REG_TEMP_CFG_REG_A, reg))
-        {
-            printf("%s: lsm303agr_write_reg() failed.\n", __FUNCTION__);
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-
-        // set ACC ODR to 100Hz by default
-        if (lsm303agr_set_acc_odr(dev, LSM303AGR_A_ODR_100HZ))
-        {
-            printf("%s: lsm303agr_set_acc_odr() failed.\n", __FUNCTION__);
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-
-        // default to 2G sensitivity
-        if (lsm303agr_set_full_scale(dev, LSM303AGR_A_FS_2G))
-        {
-            printf("%s: lsm303agr_set_full_scale() failed.\n", __FUNCTION__);
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-
-        upm_delay_ms(10);
-    }
-
-    if (lsm303agr_set_power_mode(dev, mode))
-    {
-        printf("%s: lsm303agr_set_power_mode() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t lsm303agr_set_power_mode(const lsm303agr_context dev,
-                                      LSM303AGR_POWER_MODE_T mode)
-{
-    assert(dev != NULL);
-
-    // magnetometer
-    if (dev->i2cMAG)
-    {
-        uint8_t reg = lsm303agr_read_reg(dev, LSM303AGR_REG_CFG_REG_A_M);
-
-        // only low power or hires supported here
-        if (mode == LSM303AGR_POWER_LOW_POWER)
-            reg |= LSM303AGR_CFG_REG_A_M_LP;
-        else
-            reg &= ~LSM303AGR_CFG_REG_A_M_LP;
-
-        if (lsm303agr_write_reg(dev, LSM303AGR_REG_CFG_REG_A_M, reg))
-            return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // accelerometer
-    if (dev->i2cACC)
-    {
-        uint8_t reg1 = lsm303agr_read_reg(dev, LSM303AGR_REG_CTRL_REG1_A);
-        uint8_t reg4 = lsm303agr_read_reg(dev, LSM303AGR_REG_CTRL_REG4_A);
-
-        switch (mode)
-        {
-        case LSM303AGR_POWER_LOW_POWER:
-            reg1 |= LSM303AGR_CTRL_REG1_A_LPEN;
-            reg4 &= ~LSM303AGR_CTRL_REG4_A_HR;
-            break;
-
-        case LSM303AGR_POWER_NORMAL:
-            reg1 &= ~LSM303AGR_CTRL_REG1_A_LPEN;
-            reg4 &= ~LSM303AGR_CTRL_REG4_A_HR;
-            break;
-
-        case LSM303AGR_POWER_HIGH_RESOLUTION:
-            reg1 &= ~LSM303AGR_CTRL_REG1_A_LPEN;
-            reg4 |= LSM303AGR_CTRL_REG4_A_HR;
-            break;
-        }
-
-        if (lsm303agr_write_reg(dev, LSM303AGR_REG_CTRL_REG1_A, reg1))
-            return UPM_ERROR_OPERATION_FAILED;
-
-        if (lsm303agr_write_reg(dev, LSM303AGR_REG_CTRL_REG4_A, reg4))
-            return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // settle
-    upm_delay_ms(10);
-
-    dev->powerMode = mode;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t lsm303agr_set_full_scale(const lsm303agr_context dev,
-                                      LSM303AGR_A_FS_T fs)
-{
-    assert(dev != NULL);
-
-    // this only affects the accelerometer
-    if (dev->i2cACC)
-    {
-        uint8_t reg = lsm303agr_read_reg(dev, LSM303AGR_REG_CTRL_REG4_A);
-
-        reg &= ~_SHIFTMASK(CTRL_REG4_A_FS);
-        reg |= (fs << _SHIFT(CTRL_REG4_A_FS));
-
-        if (lsm303agr_write_reg(dev, LSM303AGR_REG_CTRL_REG4_A, reg))
-            return UPM_ERROR_OPERATION_FAILED;
-
-        upm_delay_ms(50);
-
-        // set our scaling factor depending on current power mode and
-        // FS
-        switch(dev->powerMode)
-        {
-        case LSM303AGR_POWER_LOW_POWER:
-            // 8b resolution
-            dev->accDivisor = 256.0;
-
-            switch (fs)
-            {
-            case LSM303AGR_A_FS_2G:
-                dev->accScale = 15.63;
-                break;
-
-            case LSM303AGR_A_FS_4G:
-                dev->accScale = 31.26;
-                break;
-
-            case LSM303AGR_A_FS_8G:
-                dev->accScale = 62.52;
-                break;
-
-            case LSM303AGR_A_FS_16G:
-                dev->accScale = 187.58;
-                break;
-            }
-            break;
-
-        case LSM303AGR_POWER_NORMAL:
-            // 10b resolution
-            dev->accDivisor = 64.0;
-
-            switch (fs)
-            {
-            case LSM303AGR_A_FS_2G:
-                dev->accScale = 3.9;
-                break;
-
-            case LSM303AGR_A_FS_4G:
-                dev->accScale = 7.82;
-                break;
-
-            case LSM303AGR_A_FS_8G:
-                dev->accScale = 15.63;
-                break;
-
-            case LSM303AGR_A_FS_16G:
-                dev->accScale = 46.9;
-                break;
-            }
-            break;
-
-        case LSM303AGR_POWER_HIGH_RESOLUTION:
-            // 12b resolution
-            dev->accDivisor = 16.0;
-
-            switch (fs)
-            {
-            case LSM303AGR_A_FS_2G:
-                dev->accScale = 0.98;
-                break;
-
-            case LSM303AGR_A_FS_4G:
-                dev->accScale = 1.95;
-                break;
-
-            case LSM303AGR_A_FS_8G:
-                dev->accScale = 3.9;
-                break;
-
-            case LSM303AGR_A_FS_16G:
-                dev->accScale = 11.72;
-                break;
-            }
-            break;
-        }
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t lsm303agr_update(const lsm303agr_context dev)
-{
-    assert(dev != NULL);
-
-    const int maxLen = 6;
-    uint8_t buf[maxLen];
-
-    if (dev->i2cACC)
-    {
-        // get the temperature first, only 2 bytes
-        if (lsm303agr_read_regs(dev, LSM303AGR_REG_OUT_TEMP_L_A, buf, 2) != 2)
-        {
-            printf("%s: lsm303agr_read_regs(temp) failed.\n", __FUNCTION__);
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-
-        dev->temperature = (float)((int16_t)(buf[0] | (buf[1] << 8)));
-
-        // next, acc data
-        if (lsm303agr_read_regs(dev, LSM303AGR_REG_OUT_X_L_A, buf,
-                                maxLen) != maxLen)
-        {
-            printf("%s: lsm303agr_read_regs(acc) failed.\n", __FUNCTION__);
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-
-        dev->accX = (float)((int16_t)(buf[0] | (buf[1] << 8)));
-        dev->accY = (float)((int16_t)(buf[2] | (buf[3] << 8)));
-        dev->accZ = (float)((int16_t)(buf[4] | (buf[5] << 8)));
-    }
-
-    if (dev->i2cMAG)
-    {
-        // now mag data
-        if (lsm303agr_read_regs(dev,LSM303AGR_REG_OUTX_L_REG_M, buf,
-                                maxLen) != maxLen)
-        {
-            printf("%s: lsm303agr_read_regs(mag) failed.\n", __FUNCTION__);
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-
-        dev->magX = (float)((int16_t)(buf[0] | (buf[1] << 8)));
-        dev->magY = (float)((int16_t)(buf[2] | (buf[3] << 8)));
-        dev->magZ = (float)((int16_t)(buf[4] | (buf[5] << 8)));
-    }
-
-    return UPM_SUCCESS;
-}
-
-uint8_t lsm303agr_read_reg(const lsm303agr_context dev, uint8_t reg)
-{
-    assert(dev != NULL);
-
-    mraa_i2c_context i2c = NULL;
-    if (reg <= LSM303AGR_MAX_ACC_ADDR)
-        i2c = dev->i2cACC;
-    else
-        i2c = dev->i2cMAG;
-
-    if (i2c)
-    {
-        int rv = mraa_i2c_read_byte_data(i2c, reg);
-        if (rv < 0)
-        {
-            printf("%s: mraa_i2c_read_byte_data() failed\n", __FUNCTION__);
-            return 0xff;
-        }
-        return (uint8_t)rv;
-    }
-    else // shouldn't happen, but...
-        return 0xff;
-}
-
-int lsm303agr_read_regs(const lsm303agr_context dev, uint8_t reg,
-                        uint8_t *buffer, int len)
-{
-    assert(dev != NULL);
-
-    mraa_i2c_context i2c = NULL;
-    if (reg <= LSM303AGR_MAX_ACC_ADDR)
-        i2c = dev->i2cACC;
-    else
-        i2c = dev->i2cMAG;
-
-    if (i2c)
-    {
-        reg |= 0x80; // enable auto-increment
-        if (mraa_i2c_read_bytes_data(i2c, reg, buffer, len) != len)
-            return -1;
-    }
-    else
-        return -1;
-
-    return len;
-}
-
-upm_result_t lsm303agr_write_reg(const lsm303agr_context dev,
-                                 uint8_t reg, uint8_t val)
-{
-    assert(dev != NULL);
-
-    mraa_i2c_context i2c = NULL;
-    if (reg <= LSM303AGR_MAX_ACC_ADDR)
-        i2c = dev->i2cACC;
-    else
-        i2c = dev->i2cMAG;
-
-    if (i2c)
-    {
-        if (mraa_i2c_write_byte_data(i2c, val, reg))
-        {
-            printf("%s: mraa_i2c_write_byte_data() failed.\n",
-                   __FUNCTION__);
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-    }
-    else
-        return UPM_ERROR_NO_RESOURCES;
-
-    return UPM_SUCCESS;
-}
-
-float lsm303agr_get_temperature(const lsm303agr_context dev)
-{
-    assert(dev != NULL);
-
-    // DS says 8 bits.  It is not clear in the DS how to compute this,
-    // but the following seems to produce a reasonably correct
-    // temperature.
-    return (dev->temperature / 256.0) + 25.0;
-}
-
-void lsm303agr_get_magnetometer(const lsm303agr_context dev,
-                                float *x, float *y, float *z)
-{
-    assert(dev != NULL);
-
-    // 1.5 comes from the datasheet.  Output is in milli-Gauss - we
-    // convert and return it in uT (SI micro-teslas) instead.
-    if (x)
-        *x = (dev->magX * 1.5) / 10.0;
-    if (y)
-        *y = (dev->magY * 1.5) / 10.0;
-    if (z)
-        *z = (dev->magZ * 1.5) / 10.0;
-}
-
-void lsm303agr_get_accelerometer(const lsm303agr_context dev,
-                                 float *x, float *y, float *z)
-{
-    assert(dev != NULL);
-
-    if (x)
-        *x = ((dev->accX / dev->accDivisor) * dev->accScale) / 1000.0;
-    if (y)
-        *y = ((dev->accY / dev->accDivisor) * dev->accScale) / 1000.0;
-    if (z)
-        *z = ((dev->accZ / dev->accDivisor) * dev->accScale) / 1000.0;
-}
-
-upm_result_t lsm303agr_set_acc_odr(const lsm303agr_context dev,
-                                   LSM303AGR_A_ODR_T odr)
-{
-    assert(dev != NULL);
-
-    if (!dev->i2cACC)
-        return UPM_ERROR_NO_RESOURCES;
-
-    uint8_t reg = lsm303agr_read_reg(dev, LSM303AGR_REG_CTRL_REG1_A);
-    reg &= ~_SHIFTMASK(CTRL_REG1_A_ODR);
-    reg |= (odr << _SHIFT(CTRL_REG1_A_ODR));
-
-    if (lsm303agr_write_reg(dev, LSM303AGR_REG_CTRL_REG1_A, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t lsm303agr_set_mag_odr(const lsm303agr_context dev,
-                                   LSM303AGR_CFG_A_M_ODR_T odr)
-{
-    assert(dev != NULL);
-
-    if (!dev->i2cMAG)
-        return UPM_ERROR_NO_RESOURCES;
-
-    uint8_t reg = lsm303agr_read_reg(dev, LSM303AGR_REG_CFG_REG_A_M);
-    reg &= ~_SHIFTMASK(CFG_REG_A_M_ODR);
-    reg |= (odr << _SHIFT(CFG_REG_A_M_ODR));
-
-    if (lsm303agr_write_reg(dev, LSM303AGR_REG_CFG_REG_A_M, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-uint8_t lsm303agr_get_acc_int1_config(const lsm303agr_context dev)
-{
-    assert(dev != NULL);
-
-    if (!dev->i2cACC)
-        return 0;
-
-    return lsm303agr_read_reg(dev, LSM303AGR_REG_INT1_CFG_A);
-}
-
-upm_result_t lsm303agr_set_acc_int1_config(const lsm303agr_context dev,
-                                                 uint8_t bits)
-{
-    assert(dev != NULL);
-
-    if (!dev->i2cACC)
-        return UPM_ERROR_NO_RESOURCES;
-
-    if (lsm303agr_write_reg(dev, LSM303AGR_REG_INT1_CFG_A, bits))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-uint8_t lsm303agr_get_acc_int2_config(const lsm303agr_context dev)
-{
-    assert(dev != NULL);
-
-    if (!dev->i2cACC)
-        return 0;
-
-    return lsm303agr_read_reg(dev, LSM303AGR_REG_INT2_CFG_A);
-}
-
-upm_result_t lsm303agr_set_acc_int2_config(const lsm303agr_context dev,
-                                           uint8_t bits)
-{
-    assert(dev != NULL);
-
-    if (!dev->i2cACC)
-        return UPM_ERROR_NO_RESOURCES;
-
-    if (lsm303agr_write_reg(dev, LSM303AGR_REG_INT2_CFG_A, bits))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-uint8_t lsm303agr_get_mag_int_config(const lsm303agr_context dev)
-{
-    assert(dev != NULL);
-
-    if (!dev->i2cMAG)
-        return 0;
-
-    return lsm303agr_read_reg(dev, LSM303AGR_REG_INT_CTRL_REG_M);
-}
-
-upm_result_t lsm303agr_set_mag_int_config(const lsm303agr_context dev,
-                                          uint8_t bits)
-{
-    assert(dev != NULL);
-
-    if (!dev->i2cMAG)
-        return UPM_ERROR_NO_RESOURCES;
-
-    if (lsm303agr_write_reg(dev, LSM303AGR_REG_INT_CTRL_REG_M, bits))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-uint8_t lsm303agr_get_acc_int1_src(const lsm303agr_context dev)
-{
-    assert(dev != NULL);
-
-    if (!dev->i2cACC)
-        return 0;
-
-    return lsm303agr_read_reg(dev, LSM303AGR_REG_INT1_SRC_A);
-}
-
-uint8_t lsm303agr_get_acc_int2_src(const lsm303agr_context dev)
-{
-    assert(dev != NULL);
-
-    if (!dev->i2cACC)
-        return 0;
-
-    return lsm303agr_read_reg(dev, LSM303AGR_REG_INT2_SRC_A);
-}
-
-uint8_t lsm303agr_get_mag_int_src(const lsm303agr_context dev)
-{
-    assert(dev != NULL);
-
-    if (!dev->i2cMAG)
-        return 0;
-
-    return lsm303agr_read_reg(dev, LSM303AGR_REG_INT_SRC_REG_M);
-}
-
-upm_result_t lsm303agr_install_isr(const lsm303agr_context dev,
-                                   LSM303AGR_INTERRUPT_PINS_T intr, int gpio,
-                                   mraa_gpio_edge_t level,
-                                   void (*isr)(void *), void *arg)
-{
-    assert(dev != NULL);
-
-    // delete any existing ISR and GPIO context for this interrupt
-    lsm303agr_uninstall_isr(dev, intr);
-
-    mraa_gpio_context gpio_isr = NULL;
-
-    // create gpio context
-    if (!(gpio_isr = mraa_gpio_init(gpio)))
-    {
-        printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    mraa_gpio_dir(gpio_isr, MRAA_GPIO_IN);
-
-    if (mraa_gpio_isr(gpio_isr, level, isr, arg))
-    {
-        mraa_gpio_close(gpio_isr);
-        printf("%s: mraa_gpio_isr() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    switch (intr)
-    {
-    case LSM303AGR_INTERRUPT_ACC_1:
-        dev->gpioACC1 = gpio_isr;
-        break;
-
-    case LSM303AGR_INTERRUPT_ACC_2:
-        dev->gpioACC2 = gpio_isr;
-        break;
-
-    case LSM303AGR_INTERRUPT_MAG:
-        dev->gpioMAG = gpio_isr;
-        break;
-    }
-
-    return UPM_SUCCESS;
-}
-
-void lsm303agr_uninstall_isr(const lsm303agr_context dev,
-                             LSM303AGR_INTERRUPT_PINS_T intr)
-{
-    assert(dev != NULL);
-
-    switch (intr)
-    {
-    case LSM303AGR_INTERRUPT_ACC_1:
-        if (dev->gpioACC1)
-        {
-            mraa_gpio_isr_exit(dev->gpioACC1);
-            mraa_gpio_close(dev->gpioACC1);
-            dev->gpioACC1 = NULL;
-        }
-        break;
-
-    case LSM303AGR_INTERRUPT_ACC_2:
-        if (dev->gpioACC2)
-        {
-            mraa_gpio_isr_exit(dev->gpioACC2);
-            mraa_gpio_close(dev->gpioACC2);
-            dev->gpioACC2 = NULL;
-        }
-        break;
-
-    case LSM303AGR_INTERRUPT_MAG:
-        if (dev->gpioMAG)
-        {
-            mraa_gpio_isr_exit(dev->gpioMAG);
-            mraa_gpio_close(dev->gpioMAG);
-            dev->gpioMAG = NULL;
-        }
-        break;
-    }
-}
diff --git a/src/lsm303agr/lsm303agr.cxx b/src/lsm303agr/lsm303agr.cxx
deleted file mode 100644
index 74b0cbd..0000000
--- a/src/lsm303agr/lsm303agr.cxx
+++ /dev/null
@@ -1,210 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <iostream>
-#include <stdexcept>
-#include <string.h>
-
-#include "lsm303agr.hpp"
-
-using namespace upm;
-using namespace std;
-
-LSM303AGR::LSM303AGR(int bus, int acc_addr, int mag_addr) :
-    m_lsm303agr(lsm303agr_init(bus, acc_addr, mag_addr))
-{
-    if (!m_lsm303agr)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm303agr_init() failed");
-}
-
-LSM303AGR::~LSM303AGR()
-{
-    lsm303agr_close(m_lsm303agr);
-}
-
-void LSM303AGR::init(LSM303AGR_POWER_MODE_T usage)
-{
-    if (lsm303agr_devinit(m_lsm303agr, usage))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm303agr_devinit() failed");
-}
-
-void LSM303AGR::update()
-{
-    if (lsm303agr_update(m_lsm303agr))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm303agr_update() failed");
-}
-
-uint8_t LSM303AGR::readReg(uint8_t reg)
-{
-    return lsm303agr_read_reg(m_lsm303agr, reg);
-}
-
-int LSM303AGR::readRegs(uint8_t reg, uint8_t *buffer, int len)
-{
-    int rv = lsm303agr_read_regs(m_lsm303agr, reg, buffer, len);
-    if (rv < 0)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm303agr_read_regs() failed");
-
-    return rv;
-}
-
-void LSM303AGR::writeReg(uint8_t reg, uint8_t val)
-{
-    if (lsm303agr_write_reg(m_lsm303agr, reg, val))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm303agr_write_reg() failed");
-}
-
-void LSM303AGR::getMagnetometer(float *x, float *y, float *z)
-{
-    lsm303agr_get_magnetometer(m_lsm303agr, x, y, z);
-}
-
-std::vector<float> LSM303AGR::getMagnetometer()
-{
-    float v[3];
-
-    getMagnetometer(&v[0], &v[1], &v[2]);
-    return std::vector<float>(v, v+3);
-}
-
-void LSM303AGR::getAccelerometer(float *x, float *y, float *z)
-{
-    lsm303agr_get_accelerometer(m_lsm303agr, x, y, z);
-}
-
-std::vector<float> LSM303AGR::getAccelerometer()
-{
-    float v[3];
-
-    getAccelerometer(&v[0], &v[1], &v[2]);
-    return std::vector<float>(v, v+3);
-}
-
-float LSM303AGR::getTemperature()
-{
-    return lsm303agr_get_temperature(m_lsm303agr);
-}
-
-void LSM303AGR::setFullScale(LSM303AGR_A_FS_T fs)
-{
-    if (lsm303agr_set_full_scale(m_lsm303agr, fs))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm303agr_set_full_scale() failed");
-}
-
-void LSM303AGR::setPowerMode(LSM303AGR_POWER_MODE_T mode)
-{
-    if (lsm303agr_set_power_mode(m_lsm303agr, mode))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm303agr_set_power_mode() failed");
-}
-
-void LSM303AGR::setAccelerometerODR(LSM303AGR_A_ODR_T odr)
-{
-    if (lsm303agr_set_acc_odr(m_lsm303agr, odr))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm303agr_set_acc_odr() failed");
-}
-
-void LSM303AGR::setMagnetometerODR(LSM303AGR_CFG_A_M_ODR_T odr)
-{
-    if (lsm303agr_set_mag_odr(m_lsm303agr, odr))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm303agr_set_mag_odr() failed");
-}
-
-uint8_t LSM303AGR::getAccelerometerInt1Config()
-{
-    return lsm303agr_get_acc_int1_config(m_lsm303agr);
-}
-
-uint8_t LSM303AGR::getAccelerometerInt2Config()
-{
-    return lsm303agr_get_acc_int2_config(m_lsm303agr);
-}
-
-void LSM303AGR::setAccelerometerInt1Config(uint8_t bits)
-{
-    if (lsm303agr_set_acc_int1_config(m_lsm303agr, bits))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm303agr_set_acc_int1_config() failed");
-}
-
-void LSM303AGR::setAccelerometerInt2Config(uint8_t bits)
-{
-    if (lsm303agr_set_acc_int2_config(m_lsm303agr, bits))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm303agr_set_acc_int2_config() failed");
-}
-
-uint8_t LSM303AGR::getMagnetometerIntConfig()
-{
-    return lsm303agr_get_mag_int_config(m_lsm303agr);
-}
-
-void LSM303AGR::setMagnetometerIntConfig(uint8_t bits)
-{
-    if (lsm303agr_set_mag_int_config(m_lsm303agr, bits))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm303agr_set_mag_int_config() failed");
-}
-
-uint8_t LSM303AGR::getAccelerometerInt1Src()
-{
-    return lsm303agr_get_acc_int1_src(m_lsm303agr);
-}
-
-uint8_t LSM303AGR::getAccelerometerInt2Src()
-{
-    return lsm303agr_get_acc_int2_src(m_lsm303agr);
-}
-
-uint8_t LSM303AGR::getMagnetometerIntSrc()
-{
-    return lsm303agr_get_mag_int_src(m_lsm303agr);
-}
-
-
-void LSM303AGR::installISR(LSM303AGR_INTERRUPT_PINS_T intr, int gpio,
-                           mraa::Edge level,
-                           void (*isr)(void *), void *arg)
-{
-    if (lsm303agr_install_isr(m_lsm303agr, intr, gpio, (mraa_gpio_edge_t)level,
-                              isr, arg))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm303agr_install_isr() failed");
-}
-
-void LSM303AGR::uninstallISR(LSM303AGR_INTERRUPT_PINS_T intr)
-{
-    lsm303agr_uninstall_isr(m_lsm303agr, intr);
-}
diff --git a/src/lsm303agr/lsm303agr.h b/src/lsm303agr/lsm303agr.h
deleted file mode 100644
index 24e1b3c..0000000
--- a/src/lsm303agr/lsm303agr.h
+++ /dev/null
@@ -1,382 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <unistd.h>
-#include <string.h>
-
-#include <mraa/i2c.h>
-#include <mraa/gpio.h>
-
-#include "upm.h"
-
-#include "lsm303agr_defs.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    /**
-     * @file lsm303agr.h
-     * @library lsm303agr
-     * @brief C API for the lsm303agr driver
-     *
-     * @include lsm303agr.c
-     */
-
-    /**
-     * Device context
-     */
-    typedef struct _lsm303agr_context {
-        mraa_i2c_context i2cACC; // accelerometer
-        mraa_i2c_context i2cMAG; // magnetometer
-        mraa_gpio_context gpioACC1; // acc intr
-        mraa_gpio_context gpioACC2; // acc intr
-        mraa_gpio_context gpioMAG;  // mag intr
-
-        // currently set power mode
-        LSM303AGR_POWER_MODE_T powerMode;
-
-        // uncompensated temperature in C
-        float temperature;
-
-        // accelerometer scaling, depends on full scale sensitivity and
-        // power mode
-        float accScale;
-        float accDivisor;
-
-        // uncompensated acc data
-        float accX;
-        float accY;
-        float accZ;
-
-        // uncompensated mag data
-        float magX;
-        float magY;
-        float magZ;
-    } *lsm303agr_context;
-
-
-    /**
-     * LSM303AGR initialization
-     *
-     * This driver can only support I2C. SPI requires support for
-     * 3-wire SPI which we cannot currently handle.  Only the basic
-     * capabilities of the device are supported, however there is a
-     * full register map defined (lsm303agr_defs.h), and with access
-     * to the bus read/write functions, any desired additional
-     * functionality can be implemented.
-     *
-     * @param bus I2C bus to use
-     * @param acc_addr The I2C address of the accelerometer.  Use -1
-     * if you do not wish to use the accelerometer.
-     * @param mag_addr The I2C address of the magnetometer.  Use -1
-     * if you do not wish to use the magnetometer.
-     * @return The device context, or NULL if an error occurred
-     */
-    lsm303agr_context lsm303agr_init(int bus, int acc_addr, int mag_addr);
-
-    /**
-     * LSM303AGR Destructor
-     *
-     * @param dev The device context
-     */
-    void lsm303agr_close(lsm303agr_context dev);
-
-    /**
-     * Update the internal stored values from sensor data
-     *
-     * @param dev The device context
-     * @return UPM result
-     */
-    upm_result_t lsm303agr_update(const lsm303agr_context dev);
-
-    /**
-     * Return magnetometer data in micro-Teslas (uT).  update() must
-     * have been called prior to calling this function.
-     *
-     * @param dev The device context
-     * @param x Pointer to a floating point value that will have the
-     * current x component placed into it
-     * @param y Pointer to a floating point value that will have the
-     * current y component placed into it
-     * @param z Pointer to a floating point value that will have the
-     * current z component placed into it
-     */
-    void lsm303agr_get_magnetometer(const lsm303agr_context dev,
-                                    float *x, float *y, float *z);
-
-    /**
-     * Return accelerometer data in gravities.  update() must have
-     * been called prior to calling this function.
-     *
-     * @param dev The device context
-     * @param x Pointer to a floating point value that will have the
-     * current x component placed into it
-     * @param y Pointer to a floating point value that will have the
-     * current y component placed into it
-     * @param z Pointer to a floating point value that will have the
-     * current z component placed into it
-     */
-    void lsm303agr_get_accelerometer(const lsm303agr_context dev,
-                                     float *x, float *y, float *z);
-
-    /**
-     * Return temperature data in degrees Celsius..  update() must
-     * have been called prior to calling this function.
-     *
-     * @param dev The device context
-     * @return Temperature in degrees Celsius
-     */
-    float lsm303agr_get_temperature(const lsm303agr_context dev);
-
-    /**
-     * Set the full scale (sensitivity) value for the accelerometer.
-     * This device supports 2G, 4G, 8G, and 16G full scale modes.
-     *
-     * @param dev The device context
-     * @param fs One of the LSM303AGR_A_FS_T values
-     * @return UPM result
-     */
-    upm_result_t lsm303agr_set_full_scale(const lsm303agr_context dev,
-                                          LSM303AGR_A_FS_T fs);
-
-    /**
-     * Initialize the device and start operation.  This function is
-     * called from the constructor so it will not typically need to be
-     * called by a user unless the device is reset.  It will
-     * initialize the accelerometer and magnetometer (if enabled) to
-     * certain default running modes.
-     *
-     * For the accelerometer, the full scale will be set to 2G, mode
-     * continuous, all axes enabled, BDU enabled, temperature
-     * measurement enabled, and an output data rate (ODR) of 100Hz
-     * with the power mode set at high resolution.
-     *
-     * For the magnetometer, temperature compensation will be enabled,
-     * mode continuous, and an output data rate of 10Hz with the power
-     * mode set at high resolution.
-     *
-     * @param dev The device context
-     * @param mode One of the LSM303AGR_POWER_MODE_T values.  This
-     * parameter is passed to a call to lsm303agr_set_power_mode() and
-     * will set the appropriate mode for both the accelerometer and
-     * magnetometer.  The default set by the constructor is
-     * LSM303AGR_POWER_HIGH_RESOLUTION.
-     * @return UPM result
-     */
-    upm_result_t lsm303agr_devinit(const lsm303agr_context dev,
-                                   LSM303AGR_POWER_MODE_T mode);
-
-    /**
-     * Set an operating power mode.  There are 3 modes available: low
-     * power, normal, and high resolution.
-     *
-     * @param dev The device context
-     * @param mode One of the LSM303AGR_POWER_MODE_T values.  The
-     * default set at initialization time is
-     * LSM303AGR_POWER_HIGH_RESOLUTION.
-     * @return UPM result
-     */
-    upm_result_t lsm303agr_set_power_mode(const lsm303agr_context dev,
-                                          LSM303AGR_POWER_MODE_T mode);
-
-    /**
-     * Set the accelerometer (acc) output data rate (odr)
-     *
-     * @param dev The device context
-     * @param odr One of the LSM303AGR_A_ODR_T values.  The default
-     * set at initialization time is LSM303AGR_A_ODR_100HZ.
-     * @return UPM result
-     */
-    upm_result_t lsm303agr_set_acc_odr(const lsm303agr_context dev,
-                                       LSM303AGR_A_ODR_T odr);
-
-    /**
-     * Set the magnetometer (mag) output data rate (odr)
-     *
-     * @param dev The device context
-     * @param odr One of the LSM303AGR_CFG_A_M_ODR_T values.  The default
-     * set at initialization time is LSM303AGR_CFG_A_M_ODR_10HZ.
-     * @return UPM result
-     */
-    upm_result_t lsm303agr_set_mag_odr(const lsm303agr_context dev,
-                                       LSM303AGR_CFG_A_M_ODR_T odr);
-
-    /**
-     * Return the accelerometer (acc) interrupt 1 config register.
-     * This register allows you to enable various interrupt
-     * conditions.  See the datasheet for details.
-     *
-     * @param dev The device context
-     * @return A bitmask of LSM303AGR_INT_CFG_A_BITS_T bits
-     */
-    uint8_t lsm303agr_get_acc_int1_config(const lsm303agr_context dev);
-
-    /**
-     * Return the accelerometer (acc) interrupt 2 config register.
-     * This register allows you to enable various interrupt
-     * conditions.  See the datasheet for details.
-     *
-     * @param dev The device context
-     * @return A bitmask of LSM303AGR_INT_CFG_A_BITS_T bits
-     */
-    uint8_t lsm303agr_get_acc_int2_config(const lsm303agr_context dev);
-
-    /**
-     * Set the accelerometer (acc) interrupt 1 config register.  See
-     * the datasheet for details.
-     *
-     * @param dev The device context
-     * @param bits A bitmask of LSM303AGR_INT_CFG_A_BITS_T bits
-     * @return UPM result
-     */
-    upm_result_t lsm303agr_set_acc_int1_config(const lsm303agr_context dev,
-                                               uint8_t bits);
-
-    /**
-     * Set the accelerometer (acc) interrupt 2 config register.  See
-     * the datasheet for details.
-     *
-     * @param dev The device context
-     * @param bits A bitmask of LSM303AGR_INT_CFG_A_BITS_T bits
-     * @return UPM result
-     */
-    upm_result_t lsm303agr_set_acc_int2_config(const lsm303agr_context dev,
-                                               uint8_t bits);
-
-    /**
-     * Return the magnetometer (mag) interrupt config register.  See
-     * the datasheet for details.
-     *
-     * @param dev The device context
-     * @return A bitmask of LSM303AGR_INT_CTRL_REG_M_BITS_T bits
-     */
-    uint8_t lsm303agr_get_mag_int_config(const lsm303agr_context dev);
-
-    /**
-     * Set the magnetometer (mag) interrupt config register.  See
-     * the datasheet for details.
-     *
-     * @param dev The device context
-     * @param bits A bitmask of LSM303AGR_INT_CTRL_REG_M_BITS_T bits
-     */
-    upm_result_t lsm303agr_set_mag_int_config(const lsm303agr_context dev,
-                                              uint8_t bits);
-
-    /**
-     * Return the accelerometer (acc) interrupt 1 source register.
-     * This register indicates which interrupts have been triggered.
-     * See the datasheet for details.
-     *
-     * @param dev The device context
-     * @return a bitmask of LSM303AGR_INT_SRC_A_BITS_T bits
-     */
-    uint8_t lsm303agr_get_acc_int1_src(const lsm303agr_context dev);
-
-    /**
-     * Return the accelerometer (acc) interrupt 2 source register.
-     * This register indicates which interrupts have been triggered.
-     * See the datasheet for details.
-     *
-     * @param dev The device context
-     * @return a bitmask of LSM303AGR_INT_SRC_A_BITS_T bits
-     */
-    uint8_t lsm303agr_get_acc_int2_src(const lsm303agr_context dev);
-
-    /**
-     * Return the magnetometer (mag) interrupt source register.
-     * This register indicates which interrupts have been triggered.
-     * See the datasheet for details.
-     *
-     * @param dev The device context
-     * @return a bitmask of LSM303AGR_INT_SRC_REG_M_BITS_T bits
-     */
-    uint8_t lsm303agr_get_mag_int_src(const lsm303agr_context dev);
-
-    /**
-     * Install an interrupt handler
-     *
-     * @param dev The device context
-     * @param intr One of the LSM303AGR_INTERRUPT_PINS_T values
-     * specifying which interrupt pin you are installing
-     * @param gpio GPIO pin to use as interrupt pin
-     * @param level The interrupt trigger level (one of the
-     * mraa_gpio_edge_t values).  Make sure that you have configured
-     * the interrupt pin properly for whatever level you choose.
-     * @param isr The interrupt handler, accepting a void * argument
-     * @param arg The argument to pass the the interrupt handler
-     * @return UPM result
-     */
-    upm_result_t lsm303agr_install_isr(const lsm303agr_context dev,
-                                       LSM303AGR_INTERRUPT_PINS_T intr,
-                                       int gpio, mraa_gpio_edge_t level,
-                                       void (*isr)(void *), void *arg);
-
-    /**
-     * Uninstall a previously installed interrupt handler
-     *
-     * @param dev The device context
-     * @param intr One of the LSM303AGR_INTERRUPT_PINS_T values
-     * specifying which interrupt pin you are removing
-     */
-    void lsm303agr_uninstall_isr(const lsm303agr_context dev,
-                                 LSM303AGR_INTERRUPT_PINS_T intr);
-
-    /**
-     * Read a register.
-     *
-     * @param dev The device context
-     * @param reg The register to read
-     * @return The value of the register
-     */
-    uint8_t lsm303agr_read_reg(const lsm303agr_context dev, uint8_t reg);
-
-    /**
-     * Read contiguous registers into a buffer
-     *
-     * @param dev The device context
-     * @param buffer The buffer to store the results
-     * @param len The number of registers to read
-     * @return The number of bytes read, or -1 on error
-     */
-    int lsm303agr_read_regs(const lsm303agr_context dev, uint8_t reg,
-                            uint8_t *buffer, int len);
-
-    /**
-     * Write to a register
-     *
-     * @param dev The device context
-     * @param reg The register to write to
-     * @param val The value to write
-     * @return UPM result
-     */
-    upm_result_t lsm303agr_write_reg(const lsm303agr_context dev,
-                                     uint8_t reg, uint8_t val);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/lsm303agr/lsm303agr.hpp b/src/lsm303agr/lsm303agr.hpp
deleted file mode 100644
index 35bd43a..0000000
--- a/src/lsm303agr/lsm303agr.hpp
+++ /dev/null
@@ -1,367 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <vector>
-
-#include <mraa/gpio.hpp>
-#include "lsm303agr.h"
-
-namespace upm {
-
-    /**
-     * @brief LSM303AGR Ultra-compact eCompass Module
-     * @defgroup lsm303agr libupm-lsm303agr
-     * @ingroup i2c gpio stmicro compass accelerometer
-     */
-
-    /**
-     * @library lsm303agr
-     * @sensor lsm303agr
-     * @comname Ultra-compact high-performance eCompass module
-     * @type compass
-     * @man stmicro
-     * @con i2c gpio
-     * @web http://www.st.com/en/mems-and-sensors/lsm303agr.html
-     *
-     * @brief API for the LSM303AGR 3-Axis Geomagnetic Sensor
-     *
-     * The LSM303AGR is an ultra-low-power high-performance
-     * system-in-package featuring a 3D digital linear acceleration
-     * sensor and a 3D digital magnetic sensor.  The LSM303AGR has
-     * linear acceleration full scales of 2g/4g/8g/16g and a
-     * magnetic field dynamic range of 50 Gauss.
-     *
-     * Not all functionality of this chip has been implemented in this
-     * driver, however all the pieces are present to add any desired
-     * functionality.  This driver supports only I2C operation.
-     *
-     * This device requires 3.3v operation.
-     *
-     * @snippet lsm303agr.cxx Interesting
-     */
-
-    class LSM303AGR {
-    public:
-        /**
-         * LSM303AGR constructor
-         *
-         * This driver can only support I2C. SPI requires support for
-         * 3-wire SPI which we cannot currently handle.  Only the
-         * basic capabilities of the device are supported, however
-         * there is a full register map defined (lsm303agr_defs.h),
-         * and with access to the bus read/write functions, any
-         * desired additional functionality can be implemented.
-         *
-         * @param bus I2C bus to use
-         * @param acc_addr The I2C address of the accelerometer.  Use -1
-         * if you do not wish to use the accelerometer.
-         * @param mag_addr The I2C address of the magnetometer.  Use -1
-         * if you do not wish to use the magnetometer.
-         * @return The device context, or NULL if an error occurred
-         * @throws std::runtime_error on failure.
-         */
-        LSM303AGR(int bus=LSM303AGR_DEFAULT_I2C_BUS,
-                  int acc_addr=LSM303AGR_DEFAULT_ACC_ADDR,
-                  int mag_addr=LSM303AGR_DEFAULT_MAG_ADDR);
-
-        /**
-         * LSM303AGR Destructor
-         */
-        ~LSM303AGR();
-
-        /**
-         * Update the internal stored values from sensor data.  This
-         * method must be called before querying the acceleration,
-         * magnetometer, or temperature.
-         *
-         * @throws std::runtime_error on failure
-         */
-        void update();
-
-        /**
-         * Return magnetometer data in micro-Teslas (uT).  update() must
-         * have been called prior to calling this method.
-         *
-         * @param x Pointer to a floating point value that will have the
-         * current x component placed into it
-         * @param y Pointer to a floating point value that will have the
-         * current y component placed into it
-         * @param z Pointer to a floating point value that will have the
-         * current z component placed into it
-         */
-        void getMagnetometer(float *x, float *y, float *z);
-
-        /**
-         * Return magnetometer data in micro-Teslas (uT) in the form
-         * of a floating point vector.  update() must have been called
-         * prior to calling this method.
-         *
-         * @return A floating point vector containing x, y, and z in
-         * that order
-         */
-        std::vector<float> getMagnetometer();
-
-        /**
-         * Return acceleration data in gravities.  update() must have
-         * been called prior to calling this method.
-         *
-         * @param x Pointer to a floating point value that will have the
-         * current x component placed into it
-         * @param y Pointer to a floating point value that will have the
-         * current y component placed into it
-         * @param z Pointer to a floating point value that will have the
-         * current z component placed into it
-         */
-        void getAccelerometer(float *x, float *y, float *z);
-
-        /**
-         * Return acceleration data in gravities in the form of a
-         * floating point vector.  update() must have been called
-         * prior to calling this method.
-         *
-         * @return A floating point vector containing x, y, and z in
-         * that order
-         */
-        std::vector<float> getAccelerometer();
-
-        /**
-         * Return temperature data in degrees Celsius.  NOTE: This is
-         * not the ambient room temperature.  update() must have been
-         * called prior to calling this method.
-         *
-         * @return Temperature in degrees Celsius
-         */
-        float getTemperature();
-
-        /**
-         * Initialize the device and start operation.  This function
-         * is called from the constructor so it will not typically
-         * need to be called by a user unless the device is reset.  It
-         * will initialize the accelerometer and magnetometer (if
-         * enabled) to certain default running modes.
-         *
-         * For the accelerometer, the full scale will be set to 2G,
-         * mode continuous, all axes enabled, BDU enabled, temperature
-         * measurement enabled, and an output data rate (ODR) of 100Hz
-         * with the power mode set at high resolution.
-         *
-         * For the magnetometer, temperature compensation will be
-         * enabled, mode continuous, and an output data rate of 10Hz
-         * with the power mode set at high resolution.
-         *
-         * @param usage One of the LSM303AGR_POWER_MODE_T values.  The
-         * default is LSM303AGR_POWER_HIGH_RESOLUTION.
-         * @throws std::runtime_error on failure
-         */
-        void init(LSM303AGR_POWER_MODE_T usage=LSM303AGR_POWER_HIGH_RESOLUTION);
-
-        /**
-         * Set the full scale (sensitivity) value for the accelerometer.
-         * This device supports 2G, 4G, 8G, and 16G full scale modes.
-         *
-         * @param fs One of the LSM303AGR_A_FS_T values
-         * @throws std::runtime_error on failure
-         */
-        void setFullScale(LSM303AGR_A_FS_T fs);
-
-        /**
-         * Set an operating power mode.  There are 3 modes available: low
-         * power, normal, and high resolution.
-         *
-         * @param mode One of the LSM303AGR_POWER_MODE_T values.  The
-         * default set at initialization time is
-         * LSM303AGR_POWER_HIGH_RESOLUTION.
-         * @throws std::runtime_error on failure
-         */
-        void setPowerMode(LSM303AGR_POWER_MODE_T mode);
-
-        /**
-         * Set the accelerometer output data rate (ODR)
-         *
-         * @param odr One of the LSM303AGR_A_ODR_T values.  The default
-         * set at initialization time is LSM303AGR_A_ODR_100HZ.
-         * @throws std::runtime_error on failure
-         */
-        void setAccelerometerODR(LSM303AGR_A_ODR_T odr);
-
-        /**
-         * Set the magnetometer output data rate (ODR)
-         *
-         * @param odr One of the LSM303AGR_CFG_A_M_ODR_T values.
-         * The default set at initialization time is
-         * LSM303AGR_CFG_A_M_ODR_10HZ.
-         * @throws std::runtime_error on failure
-         */
-        void setMagnetometerODR(LSM303AGR_CFG_A_M_ODR_T odr);
-
-        /**
-         * Return the accelerometer interrupt 1 config register.
-         * This register allows you to enable various interrupt
-         * conditions.  See the datasheet for details.
-         *
-         * @return A bitmask of LSM303AGR_INT_CFG_A_BITS_T bits
-         */
-        uint8_t getAccelerometerInt1Config();
-
-        /**
-         * Return the accelerometer interrupt 2 config register.
-         * This register allows you to enable various interrupt
-         * conditions.  See the datasheet for details.
-         *
-         * @return A bitmask of LSM303AGR_INT_CFG_A_BITS_T bits
-         */
-        uint8_t getAccelerometerInt2Config();
-
-        /**
-         * Set the accelerometer interrupt 1 config register.  See the
-         * datasheet for details.
-         *
-         * @param dev The device context
-         * @param bits A bitmask of LSM303AGR_INT_CFG_A_BITS_T bits
-         * @throws std::runtime_error on failure
-         */
-        void setAccelerometerInt1Config(uint8_t bits);
-
-        /**
-         * Set the accelerometer interrupt 2 config register.  See the
-         * datasheet for details.
-         *
-         * @param dev The device context
-         * @param bits A bitmask of LSM303AGR_INT_CFG_A_BITS_T bits
-         * @throws std::runtime_error on failure
-         */
-        void setAccelerometerInt2Config(uint8_t bits);
-
-        /**
-         * Return the magnetometer interrupt config register.  See the
-         * datasheet for details.
-         *
-         * @return A bitmask of LSM303AGR_INT_CTRL_REG_M_BITS_T bits
-         */
-        uint8_t getMagnetometerIntConfig();
-
-        /**
-         * Set the magnetometer (mag) interrupt config register.  See
-         * the datasheet for details.
-         *
-         * @param bits A bitmask of LSM303AGR_INT_CTRL_REG_M_BITS_T bits
-         * @throws std::runtime_error on failure
-         */
-        void setMagnetometerIntConfig(uint8_t bits);
-
-        /**
-         * Return the accelerometer interrupt 1 source register.  This
-         * register indicates which interrupts have been triggered.
-         * See the datasheet for details.
-         *
-         * @return a bitmask of LSM303AGR_INT_SRC_A_BITS_T bits
-         */
-        uint8_t getAccelerometerInt1Src();
-
-        /**
-         * Return the accelerometer interrupt 2 source register.  This
-         * register indicates which interrupts have been triggered.
-         * See the datasheet for details.
-         *
-         * @return a bitmask of LSM303AGR_INT_SRC_A_BITS_T bits
-         */
-        uint8_t getAccelerometerInt2Src();
-
-        /**
-         * Return the magnetometer (mag) interrupt source register.
-         * This register indicates which interrupts have been triggered.
-         * See the datasheet for details.
-         *
-         * @param dev The device context
-         * @return a bitmask of LSM303AGR_INT_SRC_REG_M_BITS_T bits
-         */
-        uint8_t getMagnetometerIntSrc();
-
-        /**
-         * Install an interrupt handler
-         *
-         * @param intr One of the LSM303AGR_INTERRUPT_PINS_T values
-         * specifying which interrupt pin you are installing
-         * @param gpio GPIO pin to use as interrupt pin
-         * @param level The interrupt trigger level (one of mraa::Edge
-         * values).  Make sure that you have configured the interrupt pin
-         * properly for whatever level you choose.
-         * @param isr The interrupt handler, accepting a void * argument
-         * @param arg The argument to pass the the interrupt handler
-         * @throws std::runtime_error on failure
-         */
-        void installISR(LSM303AGR_INTERRUPT_PINS_T intr, int gpio,
-                        mraa::Edge level,
-                        void (*isr)(void *), void *arg);
-
-        /**
-         * Uninstall a previously installed interrupt handler
-         *
-         * @param intr One of the LSM303AGR_INTERRUPT_PINS_T values
-         * specifying which interrupt pin you are removing
-         */
-        void uninstallISR(LSM303AGR_INTERRUPT_PINS_T intr);
-
-    protected:
-        // our underlying device context
-        lsm303agr_context m_lsm303agr;
-
-        /**
-         * Read a register
-         *
-         * @param reg The register to read
-         * @return The value of the register
-         */
-        uint8_t readReg(uint8_t reg);
-
-        /**
-         * Read contiguous registers into a buffer
-         *
-         * @param buffer The buffer to store the results
-         * @param len The number of registers to read
-         * @return The number of bytes read
-         * @throws std::runtime_error on failure
-         */
-        int readRegs(uint8_t reg, uint8_t *buffer, int len);
-
-        /**
-         * Write to a register
-         *
-         * @param reg The register to write to
-         * @param val The value to write
-         * @throws std::runtime_error on failure
-         */
-        void writeReg(uint8_t reg, uint8_t val);
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        LSM303AGR(const LSM303AGR&) = delete;
-        LSM303AGR &operator=(const LSM303AGR&) = delete;
-
-    };
-}
diff --git a/src/lsm303agr/lsm303agr.i b/src/lsm303agr/lsm303agr.i
deleted file mode 100644
index b685bb5..0000000
--- a/src/lsm303agr/lsm303agr.i
+++ /dev/null
@@ -1,53 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "../upm_javastdvector.i"
-
-%ignore getMagnetometer(float *, float *, float *);
-%ignore getAccelerometer(float *, float *, float *);
-%ignore installISR(LSM303AGR_INTERRUPT_PINS_T , int ,  mraa::Edge , void *, void *);
-
-%typemap(javaimports) SWIGTYPE %{
-import java.util.AbstractList;
-import java.lang.Float;
-%}
-
-%typemap(javaout) SWIGTYPE {
-    return new $&javaclassname($jnicall, true);
-}
-%typemap(javaout) std::vector<float> {
-    return (AbstractList<Float>)(new $&javaclassname($jnicall, true));
-}
-%typemap(jstype) std::vector<float> "AbstractList<Float>"
-
-%template(floatVector) std::vector<float>;
-
-%define INTERRUPT LSM303AGR_INTERRUPT_PINS_T
-%enddef
-
-JAVA_ADD_INSTALLISR_INTERRUPT(upm::LSM303AGR)
-JAVA_JNI_LOADLIBRARY(javaupm_lsm303agr)
-#endif
-/* END Java syntax */
-
-/* BEGIN Javascript syntax  ------------------------------------------------- */
-#ifdef SWIGJAVASCRIPT
-%include "../upm_vectortypes.i"
-#endif
-/* END Javascript syntax */
-
-/* BEGIN Python syntax  ----------------------------------------------------- */
-#ifdef SWIGPYTHON
-%include "../upm_vectortypes.i"
-#endif
-/* END Python syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "lsm303agr_defs.h"
-#include "lsm303agr.hpp"
-%}
-%include "lsm303agr_defs.h"
-%include "lsm303agr.hpp"
-/* END Common SWIG syntax */
diff --git a/src/lsm303agr/lsm303agr.json b/src/lsm303agr/lsm303agr.json
deleted file mode 100644
index 6557bbd..0000000
--- a/src/lsm303agr/lsm303agr.json
+++ /dev/null
@@ -1,37 +0,0 @@
-{
-    "Library": "lsm303agr",
-    "Description": "API for the LSM303AGR 3-Axis Geomagnetic Sensor",
-    "Sensor Class":
-    {
-        "LSM303AGR":
-        {
-            "Name": "Ultra-Compact High-Performance eCompass Module",
-            "Description": "The LSM303AGR is an ultra-low-power high-performance system-in-package featuring a 3D digital linear acceleration sensor and a 3D digital magnetic sensor.  The LSM303AGR has linear acceleration full scales of 2g/4g/8g/16g and a magnetic field dynamic range of 50 Gauss. Not all functionality of this chip has been implemented in this driver, however all the pieces are present to add any desired functionality.  This driver supports only I2C operation.",
-            "Aliases": ["lsm303agr"],
-            "Categories": ["magnetometer"],
-            "Connections": ["i2c"],
-            "Project Type": ["imu", "prototyping"],
-            "Manufacturers": ["stmicro"],
-            "Kits": [],
-            "Examples":
-            {
-                "Java": ["LSM303AGR_Example.java"],
-                "Python": ["lsm303agr.py"],
-                "Node.js": ["lsm303agr.js"],
-                "C++": ["lsm303agr.cxx"],
-                "C": ["lsm303agr.c"]
-            },
-            "Specifications":
-            {
-                "Operating Voltage": {"unit": "V", "low": 1.71, "high": 3.6},
-                "Operating Current": {"unit": "uA", "low": 2, "high": 200}
-            },
-            "Urls" :
-            {
-                "Product Pages": ["http://www.st.com/en/mems-and-sensors/lsm303agr.html"],
-                "Datasheets": ["http://www.st.com/content/ccc/resource/technical/document/datasheet/74/c4/19/54/62/c5/46/13/DM00177685.pdf/files/DM00177685.pdf/jcr:content/translations/en.DM00177685.pdf"],
-                "Schematics": []
-            }
-        }
-    }
-}
diff --git a/src/lsm303agr/lsm303agr_defs.h b/src/lsm303agr/lsm303agr_defs.h
deleted file mode 100644
index a8d9c1d..0000000
--- a/src/lsm303agr/lsm303agr_defs.h
+++ /dev/null
@@ -1,675 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-#define LSM303AGR_DEFAULT_I2C_BUS 0
-#define LSM303AGR_DEFAULT_ACC_ADDR 0x19
-#define LSM303AGR_DEFAULT_MAG_ADDR 0x1e
-
-// from the WHO_AM_I_* registers
-#define LSM303AGR_CHIPID_ACC 0x33
-#define LSM303AGR_CHIPID_MAG 0x40
-
-// This device has 2 I2C addresses - one for the accelerometer (ACC)
-// and one for the magnetometer (MAG). But, it uses a single register
-// map.  The MAG registers start at 0x40, while the ACC registers
-// start at 0 and go to 0x3f.  We define the cutoff point here so the
-// register access functions can "automatically" choose the correct
-// i2c context (MAG or ACC) to use depending on what register is
-// being accessed.
-
-#define LSM303AGR_MAX_ACC_ADDR 0x3f
-
-
-    // NOTE: Reserved registers must not be written into or permanent
-    // damage to the device can result.  Reading from them may return
-    // indeterminate values.  Registers containing reserved bitfields
-    // must be written as 0.
-
-    /**
-     * LSM303AGR registers
-     */
-    typedef enum {
-
-        // accelerometer registers
-
-        // 0x00-0x06 reserved
-
-        LSM303AGR_REG_STATUS_REG_AUX_A             = 0x07,
-
-        // 0x08-0x0b reserved
-
-        LSM303AGR_REG_OUT_TEMP_L_A                 = 0x0c,
-        LSM303AGR_REG_OUT_TEMP_H_A                 = 0x0d,
-
-        LSM303AGR_REG_INT_COUNTER_REG_A            = 0x0e,
-
-        LSM303AGR_REG_WHO_AM_I_A                   = 0x0f,
-
-        // 0x10-0x1e reserved
-
-        LSM303AGR_REG_TEMP_CFG_REG_A               = 0x1f,
-
-        LSM303AGR_REG_CTRL_REG1_A                  = 0x20,
-        LSM303AGR_REG_CTRL_REG2_A                  = 0x21,
-        LSM303AGR_REG_CTRL_REG3_A                  = 0x22,
-        LSM303AGR_REG_CTRL_REG4_A                  = 0x23,
-        LSM303AGR_REG_CTRL_REG5_A                  = 0x24,
-        LSM303AGR_REG_CTRL_REG6_A                  = 0x25,
-
-        LSM303AGR_REG_REFERENCE                    = 0x26,
-
-        LSM303AGR_REG_STATUS_REG_A                 = 0x27,
-
-        LSM303AGR_REG_OUT_X_L_A                    = 0x28,
-        LSM303AGR_REG_OUT_X_H_A                    = 0x29,
-        LSM303AGR_REG_OUT_Y_L_A                    = 0x2a,
-        LSM303AGR_REG_OUT_Y_H_A                    = 0x2b,
-        LSM303AGR_REG_OUT_Z_L_A                    = 0x2c,
-        LSM303AGR_REG_OUT_Z_H_A                    = 0x2d,
-
-        LSM303AGR_REG_FIFO_CTRL_REG_A              = 0x2e,
-        LSM303AGR_REG_FIFO_SRC_REG_A               = 0x2f,
-
-        LSM303AGR_REG_INT1_CFG_A                   = 0x30,
-        LSM303AGR_REG_INT1_SRC_A                   = 0x31,
-        LSM303AGR_REG_INT1_THS_A                   = 0x32,
-        LSM303AGR_REG_INT1_DUR_A                   = 0x33,
-
-        LSM303AGR_REG_INT2_CFG_A                   = 0x34,
-        LSM303AGR_REG_INT2_SRC_A                   = 0x35,
-        LSM303AGR_REG_INT2_THS_A                   = 0x36,
-        LSM303AGR_REG_INT2_DUR_A                   = 0x37,
-
-        LSM303AGR_REG_CLICK_CFG_A                  = 0x38,
-        LSM303AGR_REG_CLICK_SRC_A                  = 0x39,
-        LSM303AGR_REG_CLICK_THS_A                  = 0x3a,
-
-        LSM303AGR_REG_TIME_LIMIT                   = 0x3b,
-        LSM303AGR_REG_TIME_LATENCY_A               = 0x3c,
-        LSM303AGR_REG_TIME_WINDOW_A                = 0x3d,
-
-        LSM303AGR_REG_ACT_THS_A                    = 0x3e,
-        LSM303AGR_REG_ACT_DUR_A                    = 0x3f,
-
-        // magnetometer registers
-
-        // 0x40-0x44 reserved
-
-        LSM303AGR_REG_OFFSET_X_REG_L_M             = 0x45,
-        LSM303AGR_REG_OFFSET_X_REG_H_M             = 0x46,
-        LSM303AGR_REG_OFFSET_Y_REG_L_M             = 0x47,
-        LSM303AGR_REG_OFFSET_Y_REG_H_M             = 0x48,
-        LSM303AGR_REG_OFFSET_Z_REG_L_M             = 0x49,
-        LSM303AGR_REG_OFFSET_Z_REG_H_M             = 0x4a,
-
-        // 0x4b-0x4d reserved
-
-        LSM303AGR_REG_WHO_AM_I_M                   = 0x4f,
-
-        // 0x50-0x5f reserved
-
-        LSM303AGR_REG_CFG_REG_A_M                  = 0x60,
-        LSM303AGR_REG_CFG_REG_B_M                  = 0x61,
-        LSM303AGR_REG_CFG_REG_C_M                  = 0x62,
-
-        LSM303AGR_REG_INT_CTRL_REG_M               = 0x63,
-        LSM303AGR_REG_INT_SRC_REG_M                = 0x64,
-        LSM303AGR_REG_INT_THS_L_REG_M              = 0x65,
-        LSM303AGR_REG_INT_THS_H_REG_M              = 0x66,
-
-        LSM303AGR_REG_STATUS_REG_M                 = 0x67,
-
-        LSM303AGR_REG_OUTX_L_REG_M                 = 0x68,
-        LSM303AGR_REG_OUTX_H_REG_M                 = 0x69,
-        LSM303AGR_REG_OUTY_L_REG_M                 = 0x6a,
-        LSM303AGR_REG_OUTY_H_REG_M                 = 0x6b,
-        LSM303AGR_REG_OUTZ_L_REG_M                 = 0x6c,
-        LSM303AGR_REG_OUTZ_H_REG_M                 = 0x6d
-
-        // 0x6e-0x6f reserved
-    } LSM303AGR_REGS_T;
-
-    // Accelerometer registers
-
-    /**
-     * STATUS_REG_AUX_A bits
-     */
-    typedef enum {
-        // 0x01-0x02 reserved
-
-        LSM303AGR_STATUS_REG_AUX_A_TDA             = 0x04, // temp data avail
-
-        // 0x08-0x20 reserved
-
-        LSM303AGR_STATUS_REG_AUX_A_TOR             = 0x40, // temp data overrun
-
-        // 0x80 reserved
-    } LSM303AGR_STATUS_REG_AUX_A_BITS_T;
-
-    /**
-     * TEMP_CFG_REG_A bits
-     */
-    typedef enum {
-        // 0x01-0x20 reserved
-
-        LSM303AGR_TEMP_CFG_REG_A_TEMP_EN0         = 0x40,
-        LSM303AGR_TEMP_CFG_REG_A_TEMP_EN1         = 0x80,
-        _LSM303AGR_TEMP_CFG_REG_A_TEMP_EN_MASK    = 3,
-        _LSM303AGR_TEMP_CFG_REG_A_TEMP_EN_SHIFT   = 6,
-    } LSM303AGR_TEMP_CFG_REG_A_BITS_T;
-
-    /**
-     * TEMP_CFG_REG_A_TEMP_EN values
-     */
-    typedef enum {
-        LSM303AGR_TEMP_EN_OFF                     = 0,
-        LSM303AGR_TEMP_EN_ON                      = 3,
-    } LSM303AGR_TEMP_EN_T;
-
-    /**
-     * CTRL_REG1_A bits
-     */
-    typedef enum {
-        LSM303AGR_CTRL_REG1_A_XEN                 = 0x01, // axis enables
-        LSM303AGR_CTRL_REG1_A_YEN                 = 0x02,
-        LSM303AGR_CTRL_REG1_A_ZEN                 = 0x04,
-        LSM303AGR_CTRL_REG1_A_LPEN                = 0x08, // low power enable
-
-        LSM303AGR_CTRL_REG1_A_ODR0                = 0x10, // output data rate
-        LSM303AGR_CTRL_REG1_A_ODR1                = 0x20,
-        LSM303AGR_CTRL_REG1_A_ODR2                = 0x40,
-        LSM303AGR_CTRL_REG1_A_ODR3                = 0x80,
-        _LSM303AGR_CTRL_REG1_A_ODR_MASK           = 15,
-        _LSM303AGR_CTRL_REG1_A_ODR_SHIFT          = 4,
-    } LSM303AGR_CTRL_REG1_A_BITS_T;
-
-    /**
-     * CTRL_REG1_A_ODR values (and power mode)
-     */
-    typedef enum {
-        LSM303AGR_A_ODR_POWER_DOWN                = 0,
-        LSM303AGR_A_ODR_1HZ                       = 1, // 1Hz, HR/Normal/LP
-        LSM303AGR_A_ODR_10HZ                      = 2,
-        LSM303AGR_A_ODR_25HZ                      = 3,
-        LSM303AGR_A_ODR_50HZ                      = 4,
-        LSM303AGR_A_ODR_100HZ                     = 5,
-        LSM303AGR_A_ODR_200HZ                     = 6,
-        LSM303AGR_A_ODR_400HZ                     = 7,
-        LSM303AGR_A_ODR_1_620KHZ                  = 8, // 1.620kHz, low power
-        LSM303AGR_A_ODR_1_344KHZ                  = 9, // 1.344kHZ
-                                                       // HR/Normal,
-                                                       // 5.376kHZ low
-                                                       // power
-    } LSM303AGR_A_ODR_T;
-
-    /**
-     * CTRL_REG2_A bits
-     */
-    typedef enum {
-        LSM303AGR_CTRL_REG2_A_HPIS1               = 0x01,
-        LSM303AGR_CTRL_REG2_A_HPIS2               = 0x02,
-        LSM303AGR_CTRL_REG2_A_HPCLICK             = 0x04,
-        LSM303AGR_CTRL_REG2_A_FDS                 = 0x08,
-        LSM303AGR_CTRL_REG2_A_HPCF1               = 0x10,
-        LSM303AGR_CTRL_REG2_A_HPCF2               = 0x20,
-
-        LSM303AGR_CTRL_REG2_A_HPM0                = 0x40,
-        LSM303AGR_CTRL_REG2_A_HPM1                = 0x80,
-        _LSM303AGR_CTRL_REG2_A_HPM_MASK           = 3,
-        _LSM303AGR_CTRL_REG2_A_HPM_SHIFT          = 6,
-    } LSM303AGR_CTRL_REG2_A_BITS_T;
-
-    /**
-     * CTRL_REG2_A_HPM values
-     */
-    typedef enum {
-        LSM303AGR_A_HPM_NORMAL                    = 0,
-        LSM303AGR_A_HPM_REF                       = 1,
-        LSM303AGR_A_HPM_NORMAL2                   = 2,
-        LSM303AGR_A_HPM_AUTORESET                 = 3,
-    } LSM303AGR_A_HPM_T;
-
-    /**
-     * CTRL_REG3_A bits
-     */
-    typedef enum {
-        // 0x01 reserved
-
-        LSM303AGR_CTRL_REG3_A_I1_OVERRUN          = 0x02,
-        LSM303AGR_CTRL_REG3_A_I1_WTM              = 0x04,
-        LSM303AGR_CTRL_REG3_A_I1_DRDY2            = 0x08,
-        LSM303AGR_CTRL_REG3_A_I1_DRDY1            = 0x10,
-        LSM303AGR_CTRL_REG3_A_I1_AOI2             = 0x20,
-        LSM303AGR_CTRL_REG3_A_I1_AOI1             = 0x40,
-        LSM303AGR_CTRL_REG3_A_I1_CLICK            = 0x80,
-    } LSM303AGR_CTRL_REG3_A_BITS_T;
-
-    /**
-     * CTRL_REG4_A bits
-     */
-    typedef enum {
-        LSM303AGR_CTRL_REG4_A_SPI_ENABLE          = 0x01, // 3-wire
-                                                          // spi (no
-                                                          // supported!)
-        LSM303AGR_CTRL_REG4_A_ST0                 = 0x02,
-        LSM303AGR_CTRL_REG4_A_ST1                 = 0x04,
-        _LSM303AGR_CTRL_REG4_A_ST_MASK            = 3,
-        _LSM303AGR_CTRL_REG4_A_ST_SHIFT           = 1,
-
-        LSM303AGR_CTRL_REG4_A_HR                  = 0x08, // high res
-
-        LSM303AGR_CTRL_REG4_A_FS0                 = 0x10, // FS selection
-        LSM303AGR_CTRL_REG4_A_FS1                 = 0x20,
-        _LSM303AGR_CTRL_REG4_A_FS_MASK            = 3,
-        _LSM303AGR_CTRL_REG4_A_FS_SHIFT           = 4,
-
-        LSM303AGR_CTRL_REG4_A_BLE                 = 0x40,
-        LSM303AGR_CTRL_REG4_A_BDU                 = 0x80, // block update
-    } LSM303AGR_CTRL_REG4_A_BITS_T;
-
-    /**
-     * CTRL_REG4_A_ST values (self-test)
-     */
-    typedef enum {
-        LSM303AGR_A_ST_NORMAL                     = 0,
-        LSM303AGR_A_ST_0                          = 1,
-        LSM303AGR_A_ST_1                          = 2,
-    } LSM303AGR_A_ST_T;
-
-    /**
-     * CTRL_REG4_A_FS values (full-scale)
-     */
-    typedef enum {
-        LSM303AGR_A_FS_2G                         = 0, // 2G
-        LSM303AGR_A_FS_4G                         = 1,
-        LSM303AGR_A_FS_8G                         = 2,
-        LSM303AGR_A_FS_16G                        = 3, // 16G
-    } LSM303AGR_A_FS_T;
-
-    /**
-     * CTRL_REG5_A bits
-     */
-    typedef enum {
-        LSM303AGR_CTRL_REG5_A_D4D_INT2            = 0x01,
-        LSM303AGR_CTRL_REG5_A_LIR_INT2            = 0x02,
-        LSM303AGR_CTRL_REG5_A_D4D_INT1            = 0x04,
-        LSM303AGR_CTRL_REG5_A_LIR_INT1            = 0x08,
-
-        // 0x10-0x20 reserved
-
-        LSM303AGR_CTRL_REG5_A_FIFO_EN             = 0x40,
-        LSM303AGR_CTRL_REG5_A_BOOT                = 0x80,
-    } LSM303AGR_CTRL_REG5_A_BITS_T;
-
-    /**
-     * CTRL_REG6_A bits
-     */
-    typedef enum {
-        // 0x01 reserved
-
-        LSM303AGR_CTRL_REG6_A_H_LACTIVE           = 0x02,
-
-        // 0x04 reserved
-
-        LSM303AGR_CTRL_REG6_A_P2_ACT              = 0x08,
-        LSM303AGR_CTRL_REG6_A_BOOT_I2             = 0x10,
-        LSM303AGR_CTRL_REG6_A_I2_INT2             = 0x20,
-        LSM303AGR_CTRL_REG6_A_I2_INT1             = 0x40,
-        LSM303AGR_CTRL_REG6_A_I2_CLICK_EN         = 0x80,
-    } LSM303AGR_CTRL_REG6_A_BITS_T;
-
-    /**
-     * STATUS_REG_A bits
-     */
-    typedef enum {
-        LSM303AGR_STATUS_REG_A_XDA                = 0x01,
-        LSM303AGR_STATUS_REG_A_YDA                = 0x02,
-        LSM303AGR_STATUS_REG_A_ZDA                = 0x04,
-        LSM303AGR_STATUS_REG_A_ZYXDA              = 0x08,
-        LSM303AGR_STATUS_REG_A_XOR                = 0x10,
-        LSM303AGR_STATUS_REG_A_YOR                = 0x20,
-        LSM303AGR_STATUS_REG_A_ZOR                = 0x40,
-        LSM303AGR_STATUS_REG_A_ZYXOR              = 0x80,
-    } LSM303AGR_STATUS_REG_A_BITS_T;
-
-    /**
-     * FIFO_CTRL_REG_A bits
-     */
-    typedef enum {
-        LSM303AGR_FIFO_CTRL_REG_A_FTH0            = 0x01, // fifo threshold
-        LSM303AGR_FIFO_CTRL_REG_A_FTH1            = 0x02,
-        LSM303AGR_FIFO_CTRL_REG_A_FTH2            = 0x04,
-        LSM303AGR_FIFO_CTRL_REG_A_FTH3            = 0x08,
-        LSM303AGR_FIFO_CTRL_REG_A_FTH4            = 0x10,
-        _LSM303AGR_FIFO_CTRL_REG_A_FTH_MASK       = 31,
-        _LSM303AGR_FIFO_CTRL_REG_A_FTH_SHIF       = 0,
-
-        LSM303AGR_FIFO_CTRL_REG_A_TR              = 0x20, // trigger select
-
-        LSM303AGR_FIFO_CTRL_REG_A_FM0             = 0x40, // fifo mode
-        LSM303AGR_FIFO_CTRL_REG_A_FM1             = 0x80,
-        _LSM303AGR_FIFO_CTRL_REG_A_FM_MASK        = 3,
-        _LSM303AGR_FIFO_CTRL_REG_A_FM_SHIFT       = 6,
-    } LSM303AGR_FIFO_CTRL_REG_A_BITS_T;
-
-    /**
-     * FIFO_CTRL_REG_A_FM values (fifo mode)
-     */
-    typedef enum {
-        LSM303AGR_A_FM_BYPASS                     = 0,
-        LSM303AGR_A_FM_FIFO                       = 1,
-        LSM303AGR_A_FM_STREAM                     = 2,
-        LSM303AGR_A_FM_STREAM_TO_FIFO             = 3,
-    } LSM303AGR_A_FM_T;
-
-    /**
-     * FIFO_SRC_REG_A bits
-     */
-    typedef enum {
-        LSM303AGR_FIFO_SRC_REG_A_FSS0             = 0x01, // fifo unread samples
-        LSM303AGR_FIFO_SRC_REG_A_FSS1             = 0x02,
-        LSM303AGR_FIFO_SRC_REG_A_FSS2             = 0x04,
-        LSM303AGR_FIFO_SRC_REG_A_FSS3             = 0x08,
-        LSM303AGR_FIFO_SRC_REG_A_FSS4             = 0x10,
-        _LSM303AGR_FIFO_SRC_REG_A_FSS_MASK        = 31,
-        _LSM303AGR_FIFO_SRC_REG_A_FSS_SHIFT       = 0,
-
-        LSM303AGR_FIFO_SRC_REG_A_EMPTY            = 0x20,
-        LSM303AGR_FIFO_SRC_REG_A_OVRN_FIFO        = 0x40,
-        LSM303AGR_FIFO_SRC_REG_A_WTM              = 0x80,
-    } LSM303AGR_FIFO_SRC_REG_A_BITS_T;
-
-    /**
-     * INT_CFG_A bits.  This definition is used for INT1 and INT2.
-     */
-    typedef enum {
-        LSM303AGR_INT_CFG_A_XLIE                  = 0x01,
-        LSM303AGR_INT_CFG_A_XHIE                  = 0x02,
-        LSM303AGR_INT_CFG_A_YLIE                  = 0x04,
-        LSM303AGR_INT_CFG_A_YHIE                  = 0x08,
-        LSM303AGR_INT_CFG_A_ZLIE                  = 0x10,
-        LSM303AGR_INT_CFG_A_ZHIE                  = 0x20,
-        LSM303AGR_INT_CFG_A_6D                    = 0x40,
-        LSM303AGR_INT_CFG_A_AOI                   = 0x80,
-    } LSM303AGR_INT_CFG_A_BITS_T;
-
-    /**
-     * INT_SRC_A bits.  This definition is used for INT1 and INT2.
-     */
-    typedef enum {
-        LSM303AGR_INT_SRC_A_XL                    = 0x01,
-        LSM303AGR_INT_SRC_A_XH                    = 0x02,
-        LSM303AGR_INT_SRC_A_YL                    = 0x04,
-        LSM303AGR_INT_SRC_A_YH                    = 0x08,
-        LSM303AGR_INT_SRC_A_ZL                    = 0x10,
-        LSM303AGR_INT_SRC_A_ZH                    = 0x20,
-        LSM303AGR_INT_SRC_A_IA                    = 0x40,
-
-        // 0x80 reserved
-    } LSM303AGR_INT_SRC_A_BITS_T;
-
-    /**
-     * INT_THS_A bits.  This definition is used for INT1 and INT2.
-     */
-    typedef enum {
-        LSM303AGR_INT_THS0                       = 0x01,
-        LSM303AGR_INT_THS1                       = 0x02,
-        LSM303AGR_INT_THS2                       = 0x04,
-        LSM303AGR_INT_THS3                       = 0x08,
-        LSM303AGR_INT_THS4                       = 0x10,
-        LSM303AGR_INT_THS5                       = 0x20,
-        LSM303AGR_INT_THS6                       = 0x40,
-        _LSM303AGR_INT_THS_MASK                  = 127,
-        _LSM303AGR_INT_THS_SHIFT                 = 0,
-
-        // 0x80 reserved
-    } LSM303AGR_INT_THS_BITS_T;
-
-    /**
-     * INT_DUR_A bits.  This definition is used for INT1 and INT2.
-     */
-    typedef enum {
-        LSM303AGR_INT_DUR0                       = 0x01,
-        LSM303AGR_INT_DUR1                       = 0x02,
-        LSM303AGR_INT_DUR2                       = 0x04,
-        LSM303AGR_INT_DUR3                       = 0x08,
-        LSM303AGR_INT_DUR4                       = 0x10,
-        LSM303AGR_INT_DUR5                       = 0x20,
-        LSM303AGR_INT_DUR6                       = 0x40,
-        _LSM303AGR_INT_DUR_MASK                  = 127,
-        _LSM303AGR_INT_DUR_SHIFT                 = 0,
-
-        // 0x80 reserved
-    } LSM303AGR_INT_DUR_BITS_T;
-
-    /**
-     * CLICK_CFG_A bits
-     */
-    typedef enum {
-        LSM303AGR_CLICK_CFG_A_XS                 = 0x01,
-        LSM303AGR_CLICK_CFG_A_XD                 = 0x02,
-        LSM303AGR_CLICK_CFG_A_YS                 = 0x04,
-        LSM303AGR_CLICK_CFG_A_YD                 = 0x08,
-        LSM303AGR_CLICK_CFG_A_ZS                 = 0x10,
-        LSM303AGR_CLICK_CFG_A_ZD                 = 0x20,
-
-        // 0x40-0x80 reserved
-    } LSM303AGR_CLICK_CFG_A_BITS_T;
-
-    /**
-     * CLICK_SRC_A bits
-     */
-    typedef enum {
-        LSM303AGR_CLICK_SRC_A_X                  = 0x01,
-        LSM303AGR_CLICK_SRC_A_Y                  = 0x02,
-        LSM303AGR_CLICK_SRC_A_Z                  = 0x04,
-        LSM303AGR_CLICK_SRC_A_SIGN               = 0x08,
-        LSM303AGR_CLICK_SRC_A_SCLICK             = 0x10,
-        LSM303AGR_CLICK_SRC_A_DCLICK             = 0x20,
-        LSM303AGR_CLICK_SRC_A_IA                 = 0x40,
-
-        // 0x80 reserved
-    } LSM303AGR_CLICK_SRC_A_BITS_T;
-
-    /**
-     * CLICK_THS_A bits
-     */
-    typedef enum {
-        LSM303AGR_CLICK_A_THS0                   = 0x01,
-        LSM303AGR_CLICK_A_THS1                   = 0x02,
-        LSM303AGR_CLICK_A_THS2                   = 0x04,
-        LSM303AGR_CLICK_A_THS3                   = 0x08,
-        LSM303AGR_CLICK_A_THS4                   = 0x10,
-        LSM303AGR_CLICK_A_THS5                   = 0x20,
-        LSM303AGR_CLICK_A_THS6                   = 0x40,
-        _LSM303AGR_CLICK_A_THS_MASK              = 127,
-        _LSM303AGR_CLICK_A_THS_SHIFT             = 0,
-
-        // 0x80 reserved
-    } LSM303AGR_CLICK_THS_A_BITS_T;
-
-    /**
-     * TIME_LIMIT_A bits
-     */
-    typedef enum {
-        LSM303AGR_TIME_LIMIT_A_TLI0              = 0x01,
-        LSM303AGR_TIME_LIMIT_A_TLI1              = 0x02,
-        LSM303AGR_TIME_LIMIT_A_TLI2              = 0x04,
-        LSM303AGR_TIME_LIMIT_A_TLI3              = 0x08,
-        LSM303AGR_TIME_LIMIT_A_TLI4              = 0x10,
-        LSM303AGR_TIME_LIMIT_A_TLI5              = 0x20,
-        LSM303AGR_TIME_LIMIT_A_TLI6              = 0x40,
-        _LSM303AGR_TIME_LIMIT_A_TLI_MASK         = 127,
-        _LSM303AGR_TIME_LIMIT_A_TLI_SHIFT        = 0,
-
-        // 0x80 reserved
-    } LSM303AGR_TIME_LIMIT_A_BITS_T;
-
-    // Magnetometer registers
-
-    /**
-     * CFG_REG_A_M bits
-     */
-    typedef enum {
-        LSM303AGR_CFG_REG_A_M_MD0                = 0x01, // mode select
-        LSM303AGR_CFG_REG_A_M_MD1                = 0x02,
-        _LSM303AGR_CFG_REG_A_M_MD_MASK           = 3,
-        _LSM303AGR_CFG_REG_A_M_MD_SHIFT          = 0,
-
-        LSM303AGR_CFG_REG_A_M_ODR0               = 0x04, // output data rate
-        LSM303AGR_CFG_REG_A_M_ODR1               = 0x08,
-        _LSM303AGR_CFG_REG_A_M_ODR_MASK          = 3,
-        _LSM303AGR_CFG_REG_A_M_ODR_SHIFT         = 2,
-
-        LSM303AGR_CFG_REG_A_M_LP                 = 0x10, // low power/hi res
-        LSM303AGR_CFG_REG_A_M_SOFT_RESET         = 0x20,
-        LSM303AGR_CFG_REG_A_M_REBOOT             = 0x40,
-        LSM303AGR_CFG_REG_A_M_COMP_TEMP_EN       = 0x80, // temp compensation
-    } LSM303AGR_CFG_REG_A_M_BITS_T;
-
-    /**
-     * CFG_REG_A_M_MD values
-     */
-    typedef enum {
-        LSM303AGR_CFG_A_M_MD_CONTINUOUS          = 0,
-        LSM303AGR_CFG_A_M_MD_SINGLE              = 1,
-        LSM303AGR_CFG_A_M_MD_IDLE                = 2,
-    } LSM303AGR_CFG_A_M_MD_T;
-
-    /**
-     * CFG_REG_A_M_ODR values
-     */
-    typedef enum {
-        LSM303AGR_CFG_A_M_ODR_10HZ               = 0,
-        LSM303AGR_CFG_A_M_ODR_20HZ               = 1,
-        LSM303AGR_CFG_A_M_ODR_50HZ               = 2,
-        LSM303AGR_CFG_A_M_ODR_100HZ              = 3,
-    } LSM303AGR_CFG_A_M_ODR_T;
-
-    /**
-     * CFG_REG_B_M bits
-     */
-    typedef enum {
-        LSM303AGR_CFG_REG_B_M_LPF                = 0x01,
-        LSM303AGR_CFG_REG_B_M_OFF_CANC           = 0x02,
-        LSM303AGR_CFG_REG_B_M_SET_FREQ           = 0x04,
-        LSM303AGR_CFG_REG_B_M_INT_ON_DATA_OFF    = 0x08,
-        LSM303AGR_CFG_REG_B_M_OFF_CANC_ONE_SHOT  = 0x10,
-
-        // 0x20-0x80 reserved
-    } LSM303AGR_CFG_REG_B_M_BITS_T;
-
-    /**
-     * CFG_REG_C_M bits
-     */
-    typedef enum {
-        LSM303AGR_CFG_REG_C_M_INT_MAG             = 0x01,
-        LSM303AGR_CFG_REG_C_M_SELF_TEST           = 0x02,
-
-        // 0x04 reserved and MUST be 0 for correct operation
-
-        LSM303AGR_CFG_REG_C_M_BLE                 = 0x08,
-        LSM303AGR_CFG_REG_C_M_BDU                 = 0x10,
-        LSM303AGR_CFG_REG_C_M_I2C_DIS             = 0x20, // don't do it...
-        LSM303AGR_CFG_REG_C_M_INT_MAG_PIN         = 0x40,
-
-        // 0x80 reserved
-    } LSM303AGR_CFG_REG_C_M_BITS_T;
-
-    /**
-     * INT_CTRL_REG_M bits
-     */
-    typedef enum {
-        LSM303AGR_INT_CTRL_REG_M_IEN              = 0x01,
-        LSM303AGR_INT_CTRL_REG_M_IEL              = 0x02,
-        LSM303AGR_INT_CTRL_REG_M_IEA              = 0x04,
-
-        // 0x08-0x10 reserved and MUST be 0 for correct operation
-
-        LSM303AGR_INT_CTRL_REG_M_ZIEN             = 0x20,
-        LSM303AGR_INT_CTRL_REG_M_YIEN             = 0x40,
-        LSM303AGR_INT_CTRL_REG_M_XIEN             = 0x80,
-    } LSM303AGR_INT_CTRL_REG_M_BITS_T;
-
-    /**
-     * INT_SRC_REG_M bits
-     */
-    typedef enum {
-        LSM303AGR_INT_SRC_REG_M_MROI              = 0x02,
-        LSM303AGR_INT_SRC_REG_M_N_TH_S_Z          = 0x04,
-        LSM303AGR_INT_SRC_REG_M_N_TH_S_Y          = 0x08,
-        LSM303AGR_INT_SRC_REG_M_N_TH_S_X          = 0x10,
-        LSM303AGR_INT_SRC_REG_M_P_TH_S_Z          = 0x20,
-        LSM303AGR_INT_SRC_REG_M_P_TH_S_Y          = 0x40,
-        LSM303AGR_INT_SRC_REG_M_P_TH_S_X          = 0x80,
-    } LSM303AGR_INT_SRC_REG_M_BITS_T;
-
-    /**
-     * STATUS_REG_M bits
-     */
-    typedef enum {
-        LSM303AGR_STATUS_REG_M_XDA                = 0x01,
-        LSM303AGR_STATUS_REG_M_YDA                = 0x02,
-        LSM303AGR_STATUS_REG_M_ZDA                = 0x04,
-        LSM303AGR_STATUS_REG_M_ZYXDA              = 0x08,
-        LSM303AGR_STATUS_REG_M_XOR                = 0x10,
-        LSM303AGR_STATUS_REG_M_YOR                = 0x20,
-        LSM303AGR_STATUS_REG_M_ZOR                = 0x40,
-        LSM303AGR_STATUS_REG_M_ZYXOR              = 0x80,
-    } LSM303AGR_STATUS_REG_M_BITS_T;
-
-    // The following enums are used for driver functionality.
-
-    /**
-     * INTERRUPT_PINS_T values.  There are 3 interrupt pins available;
-     * two for the accelerometer, and one for the magnetometer.
-     */
-    typedef enum {
-        LSM303AGR_INTERRUPT_ACC_1                 = 0, // ACC intr 1
-        LSM303AGR_INTERRUPT_ACC_2                 = 1, // ACC intr 2
-        LSM303AGR_INTERRUPT_MAG                   = 2, // MAG intr
-    } LSM303AGR_INTERRUPT_PINS_T;
-
-    /**
-     * LSM303AGR_POWER_MODE_T values.  These set the basic operating
-     * power modes to one of low power, normal, and high resolution.
-     */
-    typedef enum {
-        LSM303AGR_POWER_LOW_POWER                 = 0,
-        LSM303AGR_POWER_NORMAL                    = 1,
-        LSM303AGR_POWER_HIGH_RESOLUTION           = 2,
-    } LSM303AGR_POWER_MODE_T;
-
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/lsm303agr/lsm303agr_fti.c b/src/lsm303agr/lsm303agr_fti.c
deleted file mode 100644
index 0406360..0000000
--- a/src/lsm303agr/lsm303agr_fti.c
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "lsm303agr.h"
-#include "upm_fti.h"
-
-/**
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_lsm303agr_name[] = "LSM303AGR";
-const char upm_lsm303agr_description[] =
-    "3D Accelerometer and 3D Magnetometer";
-const upm_protocol_t upm_lsm303agr_protocol[] = {UPM_I2C, UPM_GPIO};
-const upm_sensor_t upm_lsm303agr_category[] = {UPM_MAGNETOMETER,
-                                            UPM_ACCELEROMETER};
-
-// forward declarations
-const void* upm_lsm303agr_get_ft(upm_sensor_t sensor_type);
-void* upm_lsm303agr_init_name();
-void upm_lsm303agr_close(void *dev);
-upm_result_t upm_lsm303agr_get_acc_value(void *dev, float *value,
-                                         upm_acceleration_u unit);
-upm_result_t upm_lsm303agr_get_mag_value(void *dev, float *value);
-
-const upm_sensor_descriptor_t upm_lsm303agr_get_descriptor()
-{
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_lsm303agr_name;
-    usd.description = upm_lsm303agr_description;
-    usd.protocol_size = 2;
-    usd.protocol = upm_lsm303agr_protocol;
-    usd.category_size = 2;
-    usd.category = upm_lsm303agr_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = &upm_lsm303agr_init_name,
-    .upm_sensor_close = &upm_lsm303agr_close,
-};
-
-static const upm_magnetometer_ft mft =
-{
-    .upm_magnetometer_get_value = &upm_lsm303agr_get_mag_value
-};
-
-static const upm_acceleration_ft aft =
-{
-    .upm_acceleration_get_value = &upm_lsm303agr_get_acc_value
-};
-
-const void* upm_lsm303agr_get_ft(upm_sensor_t sensor_type)
-{
-  switch(sensor_type)
-    {
-    case UPM_SENSOR:
-      return &ft;
-
-    case UPM_MAGNETOMETER:
-      return &mft;
-
-    case UPM_ACCELEROMETER:
-      return &aft;
-
-    default:
-      return NULL;
-    }
-}
-
-void* upm_lsm303agr_init_name()
-{
-    return NULL;
-}
-
-
-void upm_lsm303agr_close(void *dev)
-{
-    lsm303agr_close((lsm303agr_context)dev);
-}
-
-upm_result_t upm_lsm303agr_get_acc_value(void *dev, float *value,
-                                      upm_acceleration_u unit)
-{
-    if (lsm303agr_update((lsm303agr_context)dev))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    float x, y, z;
-
-    lsm303agr_get_magnetometer(dev, &x, &y, &z);
-
-    value[0] = x;
-    value[1] = y;
-    value[2] = z;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t upm_lsm303agr_get_mag_value(void *dev, float *value)
-{
-    if (lsm303agr_update((lsm303agr_context)dev))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    float x, y, z;
-
-    lsm303agr_get_accelerometer(dev, &x, &y, &z);
-
-    value[0] = x;
-    value[1] = y;
-    value[2] = z;
-
-    return UPM_SUCCESS;
-}
diff --git a/src/lsm303d/CMakeLists.txt b/src/lsm303d/CMakeLists.txt
deleted file mode 100644
index f434791..0000000
--- a/src/lsm303d/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-upm_mixed_module_init (NAME lsm303d
-    DESCRIPTION "3-Axis eCompass Module"
-    C_HDR lsm303d.h lsm303d_defs.h
-    C_SRC lsm303d.c
-    CPP_HDR lsm303d.hpp
-    CPP_SRC lsm303d.cxx
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/lsm303d/lsm303d.c b/src/lsm303d/lsm303d.c
deleted file mode 100644
index 24901bc..0000000
--- a/src/lsm303d/lsm303d.c
+++ /dev/null
@@ -1,417 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-
-#include <unistd.h>
-#include <assert.h>
-
-#include "upm_utilities.h"
-
-#include "lsm303d.h"
-
-
-// some useful macros to save on typing and text wrapping
-#undef _SHIFT
-#define _SHIFT(x) (_LSM303D_##x##_SHIFT)
-
-#undef _MASK
-#define _MASK(x) (_LSM303D_##x##_MASK)
-
-#undef _SHIFTMASK
-#define _SHIFTMASK(x) (_MASK(x) << _SHIFT(x))
-
-
-// init
-lsm303d_context lsm303d_init(int bus, int addr)
-{
-    lsm303d_context dev =
-        (lsm303d_context)malloc(sizeof(struct _lsm303d_context));
-
-    if (!dev)
-        return NULL;
-
-    // zero out context
-    memset((void *)dev, 0, sizeof(struct _lsm303d_context));
-
-    // make sure MRAA is initialized
-    if (mraa_init() != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed.\n", __FUNCTION__);
-        lsm303d_close(dev);
-        return NULL;
-    }
-
-    if (!(dev->i2c = mraa_i2c_init(bus)))
-    {
-        printf("%s: mraa_i2c_init() failed.\n", __FUNCTION__);
-        lsm303d_close(dev);
-        return NULL;
-    }
-
-    if (mraa_i2c_address(dev->i2c, addr))
-    {
-        printf("%s: mraa_i2c_address() failed.\n", __FUNCTION__);
-        lsm303d_close(dev);
-        return NULL;
-    }
-
-    // check the chip id
-    uint8_t chipID = lsm303d_read_reg(dev, LSM303D_REG_WHO_AM_I);
-
-    if (chipID != LSM303D_CHIPID)
-    {
-        printf("%s: invalid chip id: %02x.  Expected %02x\n",
-               __FUNCTION__, chipID, LSM303D_CHIPID);
-        lsm303d_close(dev);
-        return NULL;
-    }
-
-    // call devinit with a default high resolution mode
-    if (lsm303d_devinit(dev, LSM303D_M_RES_HIGH))
-    {
-        printf("%s: lsm303d_devinit() failed.\n", __FUNCTION__);
-        lsm303d_close(dev);
-        return NULL;
-    }
-
-    return dev;
-}
-
-void lsm303d_close(lsm303d_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->i2c)
-        mraa_i2c_stop(dev->i2c);
-
-    free(dev);
-}
-
-upm_result_t lsm303d_devinit(const lsm303d_context dev,
-                             LSM303D_M_RES_T res)
-{
-    assert(dev != NULL);
-
-    // enable all axes and BDU
-    uint8_t reg = lsm303d_read_reg(dev, LSM303D_REG_CTRL1);
-
-    reg |= LSM303D_CTRL1_AXEN
-        | LSM303D_CTRL1_AYEN
-        | LSM303D_CTRL1_AZEN
-        | LSM303D_CTRL1_BDU;
-
-    if (lsm303d_write_reg(dev, LSM303D_REG_CTRL1, reg))
-    {
-        printf("%s: lsm303d_write_reg() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // enable temperature measurement and set mag resolution
-    reg = lsm303d_read_reg(dev, LSM303D_REG_CTRL5);
-    reg &= ~_SHIFTMASK(CTRL5_MRES);
-    reg |= LSM303D_CTRL5_TEMP_EN
-        | (res << _SHIFT(CTRL5_MRES));
-
-    if (lsm303d_write_reg(dev, LSM303D_REG_CTRL5, reg))
-    {
-        printf("%s: lsm303d_write_reg() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // set magnetometer to continuous mode
-    reg = lsm303d_read_reg(dev, LSM303D_REG_CTRL7);
-    reg &= ~_SHIFTMASK(CTRL7_MD);
-    reg |= (LSM303D_MD_CONTINUOUS << _SHIFT(CTRL7_MD));
-
-    if (lsm303d_write_reg(dev, LSM303D_REG_CTRL7, reg))
-    {
-        printf("%s: lsm303d_write_reg() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // set ACC ODR to 100Hz by default
-    if (lsm303d_set_acc_odr(dev, LSM303D_AODR_100HZ))
-    {
-        printf("%s: lsm303d_set_acc_odr() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // set MAG ODR to 12.5Hz by default
-    if (lsm303d_set_mag_odr(dev, LSM303D_MODR_12_5HZ))
-    {
-        printf("%s: lsm303d_set_acc_odr() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // default to 2G acc sensitivity
-    if (lsm303d_set_acc_full_scale(dev, LSM303D_AFS_2G))
-    {
-        printf("%s: lsm303d_set_acc_full_scale() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // default to 2 Gauss mag sensitivity
-    if (lsm303d_set_mag_full_scale(dev, LSM303D_MFS_2))
-    {
-        printf("%s: lsm303d_set_acc_full_scale() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    upm_delay_ms(10);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t lsm303d_set_acc_full_scale(const lsm303d_context dev,
-                                        LSM303D_AFS_T fs)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = lsm303d_read_reg(dev, LSM303D_REG_CTRL2);
-
-    reg &= ~_SHIFTMASK(CTRL2_AFS);
-    reg |= (fs << _SHIFT(CTRL2_AFS));
-
-    if (lsm303d_write_reg(dev, LSM303D_REG_CTRL2, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    upm_delay_ms(50);
-
-    // set our scaling factor depending on current FS
-    switch(fs)
-    {
-    case LSM303D_AFS_2G:
-        dev->accScale = 0.061;
-        break;
-
-    case LSM303D_AFS_4G:
-        dev->accScale = 0.122;
-        break;
-
-    case LSM303D_AFS_6G:
-        dev->accScale = 0.183;
-        break;
-
-    case LSM303D_AFS_8G:
-        dev->accScale = 0.320;
-        break;
-
-    case LSM303D_AFS_16G:
-        dev->accScale = 0.732;
-        break;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t lsm303d_set_mag_full_scale(const lsm303d_context dev,
-                                        LSM303D_MFS_T fs)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = lsm303d_read_reg(dev, LSM303D_REG_CTRL6);
-
-    reg &= ~_SHIFTMASK(CTRL6_MFS);
-    reg |= (fs << _SHIFT(CTRL6_MFS));
-
-    if (lsm303d_write_reg(dev, LSM303D_REG_CTRL6, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    upm_delay_ms(50);
-
-    // set our scaling factor depending on current FS
-    switch(fs)
-    {
-    case LSM303D_MFS_2:
-        dev->magScale = 0.080;
-        break;
-
-    case LSM303D_MFS_4:
-        dev->magScale = 0.160;
-        break;
-
-    case LSM303D_MFS_8:
-        dev->magScale = 0.320;
-        break;
-
-    case LSM303D_MFS_12:
-        dev->magScale = 0.479;
-        break;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t lsm303d_update(const lsm303d_context dev)
-{
-    assert(dev != NULL);
-
-    const int maxLen = 6;
-    uint8_t buf[maxLen];
-
-    // get the temperature first, only 2 bytes
-    if (lsm303d_read_regs(dev, LSM303D_REG_TEMP_OUT_L, buf, 2) != 2)
-    {
-        printf("%s: lsm303d_read_regs(temp) failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    dev->temperature = (float)( (int16_t)(buf[0] | (buf[1] << 8)) << 4);
-
-    // next, acc data
-    if (lsm303d_read_regs(dev, LSM303D_REG_OUT_X_L_A, buf,
-                          maxLen) != maxLen)
-    {
-        printf("%s: lsm303d_read_regs(acc) failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    dev->accX = (float)((int16_t)(buf[0] | (buf[1] << 8)));
-    dev->accY = (float)((int16_t)(buf[2] | (buf[3] << 8)));
-    dev->accZ = (float)((int16_t)(buf[4] | (buf[5] << 8)));
-
-    // now mag data
-    if (lsm303d_read_regs(dev, LSM303D_REG_OUT_X_L_M, buf,
-                          maxLen) != maxLen)
-    {
-        printf("%s: lsm303d_read_regs(mag) failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    dev->magX = (float)((int16_t)(buf[0] | (buf[1] << 8)));
-    dev->magY = (float)((int16_t)(buf[2] | (buf[3] << 8)));
-    dev->magZ = (float)((int16_t)(buf[4] | (buf[5] << 8)));
-
-    return UPM_SUCCESS;
-}
-
-uint8_t lsm303d_read_reg(const lsm303d_context dev, uint8_t reg)
-{
-    assert(dev != NULL);
-
-    int rv = mraa_i2c_read_byte_data(dev->i2c, reg);
-    if (rv < 0)
-    {
-        printf("%s: mraa_i2c_read_byte_data() failed\n", __FUNCTION__);
-        return 0xff;
-    }
-
-    return (uint8_t)rv;
-}
-
-int lsm303d_read_regs(const lsm303d_context dev, uint8_t reg,
-                      uint8_t *buffer, int len)
-{
-    assert(dev != NULL);
-
-    reg |= 0x80; // enable auto-increment
-    if (mraa_i2c_read_bytes_data(dev->i2c, reg, buffer, len) != len)
-        return -1;
-
-    return len;
-}
-
-upm_result_t lsm303d_write_reg(const lsm303d_context dev,
-                               uint8_t reg, uint8_t val)
-{
-    assert(dev != NULL);
-
-    if (mraa_i2c_write_byte_data(dev->i2c, val, reg))
-    {
-        printf("%s: mraa_i2c_write_byte_data() failed.\n",
-               __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-float lsm303d_get_temperature(const lsm303d_context dev)
-{
-    assert(dev != NULL);
-
-    // It's not clear how to compute this from the datasheet, but this
-    // seems to give a reasonably accurate result.
-    return (dev->temperature / 128.0) + 25.0;
-}
-
-void lsm303d_get_magnetometer(const lsm303d_context dev,
-                              float *x, float *y, float *z)
-{
-    assert(dev != NULL);
-
-    // Output is in milli-Gauss - we convert and return it in uT (SI
-    // micro-teslas) instead.
-    if (x)
-        *x = (dev->magX * dev->magScale) / 10.0;
-    if (y)
-        *y = (dev->magY * dev->magScale) / 10.0;
-    if (z)
-        *z = (dev->magZ * dev->magScale) / 10.0;
-}
-
-void lsm303d_get_accelerometer(const lsm303d_context dev,
-                               float *x, float *y, float *z)
-{
-    assert(dev != NULL);
-
-    if (x)
-        *x = (dev->accX * dev->accScale) / 1000.0;
-    if (y)
-        *y = (dev->accY * dev->accScale) / 1000.0;
-    if (z)
-        *z = (dev->accZ * dev->accScale) / 1000.0;
-}
-
-upm_result_t lsm303d_set_acc_odr(const lsm303d_context dev,
-                                 LSM303D_AODR_T odr)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = lsm303d_read_reg(dev, LSM303D_REG_CTRL1);
-    reg &= ~_SHIFTMASK(CTRL1_AODR);
-    reg |= (odr << _SHIFT(CTRL1_AODR));
-
-    if (lsm303d_write_reg(dev, LSM303D_REG_CTRL1, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t lsm303d_set_mag_odr(const lsm303d_context dev,
-                                 LSM303D_MODR_T odr)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = lsm303d_read_reg(dev, LSM303D_REG_CTRL5);
-    reg &= ~_SHIFTMASK(CTRL5_MODR);
-    reg |= (odr << _SHIFT(CTRL5_MODR));
-
-    if (lsm303d_write_reg(dev, LSM303D_REG_CTRL5, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
diff --git a/src/lsm303d/lsm303d.cxx b/src/lsm303d/lsm303d.cxx
deleted file mode 100644
index 13639e5..0000000
--- a/src/lsm303d/lsm303d.cxx
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <iostream>
-#include <stdexcept>
-#include <string.h>
-
-#include "lsm303d.hpp"
-
-using namespace upm;
-using namespace std;
-
-LSM303D::LSM303D(int bus, int addr) :
-    m_lsm303d(lsm303d_init(bus, addr))
-{
-    if (!m_lsm303d)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm303d_init() failed");
-}
-
-LSM303D::~LSM303D()
-{
-    lsm303d_close(m_lsm303d);
-}
-
-void LSM303D::init(LSM303D_M_RES_T res)
-{
-    if (lsm303d_devinit(m_lsm303d, res))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm303d_devinit() failed");
-}
-
-void LSM303D::update()
-{
-    if (lsm303d_update(m_lsm303d))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm303d_update() failed");
-}
-
-uint8_t LSM303D::readReg(uint8_t reg)
-{
-    return lsm303d_read_reg(m_lsm303d, reg);
-}
-
-int LSM303D::readRegs(uint8_t reg, uint8_t *buffer, int len)
-{
-    int rv = lsm303d_read_regs(m_lsm303d, reg, buffer, len);
-    if (rv < 0)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm303d_read_regs() failed");
-
-    return rv;
-}
-
-void LSM303D::writeReg(uint8_t reg, uint8_t val)
-{
-    if (lsm303d_write_reg(m_lsm303d, reg, val))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm303d_write_reg() failed");
-}
-
-void LSM303D::getMagnetometer(float *x, float *y, float *z)
-{
-    lsm303d_get_magnetometer(m_lsm303d, x, y, z);
-}
-
-std::vector<float> LSM303D::getMagnetometer()
-{
-    float v[3];
-
-    getMagnetometer(&v[0], &v[1], &v[2]);
-    return std::vector<float>(v, v+3);
-}
-
-void LSM303D::getAccelerometer(float *x, float *y, float *z)
-{
-    lsm303d_get_accelerometer(m_lsm303d, x, y, z);
-}
-
-std::vector<float> LSM303D::getAccelerometer()
-{
-    float v[3];
-
-    getAccelerometer(&v[0], &v[1], &v[2]);
-    return std::vector<float>(v, v+3);
-}
-
-float LSM303D::getTemperature()
-{
-    return lsm303d_get_temperature(m_lsm303d);
-}
-
-void LSM303D::setAccelerometerFullScale(LSM303D_AFS_T fs)
-{
-    if (lsm303d_set_acc_full_scale(m_lsm303d, fs))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm303d_set_acc_full_scale() failed");
-}
-
-void LSM303D::setMagnetometerFullScale(LSM303D_MFS_T fs)
-{
-    if (lsm303d_set_mag_full_scale(m_lsm303d, fs))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm303d_set_mag_full_scale() failed");
-}
-void LSM303D::setAccelerometerODR(LSM303D_AODR_T odr)
-{
-    if (lsm303d_set_acc_odr(m_lsm303d, odr))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm303d_set_acc_odr() failed");
-}
-
-void LSM303D::setMagnetometerODR(LSM303D_MODR_T odr)
-{
-    if (lsm303d_set_mag_odr(m_lsm303d, odr))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm303d_set_mag_odr() failed");
-}
diff --git a/src/lsm303d/lsm303d.h b/src/lsm303d/lsm303d.h
deleted file mode 100644
index b156ae4..0000000
--- a/src/lsm303d/lsm303d.h
+++ /dev/null
@@ -1,238 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <unistd.h>
-#include <string.h>
-
-#include <mraa/i2c.h>
-#include <mraa/gpio.h>
-
-#include "upm.h"
-
-#include "lsm303d_defs.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    /**
-     * @file lsm303d.h
-     * @library lsm303d
-     * @brief C API for the lsm303d driver
-     *
-     * @include lsm303d.c
-     */
-
-    /**
-     * Device context
-     */
-    typedef struct _lsm303d_context {
-        mraa_i2c_context i2c;
-
-        // uncompensated temperature in C
-        float temperature;
-
-        // accelerometer scaling
-        float accScale;
-
-        // magnetometer scaling
-        float magScale;
-
-        // uncompensated acc data
-        float accX;
-        float accY;
-        float accZ;
-
-        // uncompensated mag data
-        float magX;
-        float magY;
-        float magZ;
-    } *lsm303d_context;
-
-
-    /**
-     * LSM303D initialization
-     *
-     * This driver only supports I2C.
-     *
-     * Due to the fact that this chip is currently obsolete, we only
-     * support minimum functionality.
-     *
-     * @param bus I2C bus to use
-     * @param addr The I2C address of the device
-     * @return The device context, or NULL if an error occurred
-     */
-    lsm303d_context lsm303d_init(int bus, int addr);
-
-    /**
-     * LSM303D Destructor
-     *
-     * @param dev The device context
-     */
-    void lsm303d_close(lsm303d_context dev);
-
-    /**
-     * Update the internal stored values from sensor data
-     *
-     * @param dev The device context
-     * @return UPM result
-     */
-    upm_result_t lsm303d_update(const lsm303d_context dev);
-
-    /**
-     * Return magnetometer data in micro-Teslas (uT).  update() must
-     * have been called prior to calling this function.
-     *
-     * @param dev The device context
-     * @param x Pointer to a floating point value that will have the
-     * current x component placed into it
-     * @param y Pointer to a floating point value that will have the
-     * current y component placed into it
-     * @param z Pointer to a floating point value that will have the
-     * current z component placed into it
-     */
-    void lsm303d_get_magnetometer(const lsm303d_context dev,
-                                  float *x, float *y, float *z);
-
-    /**
-     * Return accelerometer data in gravities.  update() must have
-     * been called prior to calling this function.
-     *
-     * @param dev The device context
-     * @param x Pointer to a floating point value that will have the
-     * current x component placed into it
-     * @param y Pointer to a floating point value that will have the
-     * current y component placed into it
-     * @param z Pointer to a floating point value that will have the
-     * current z component placed into it
-     */
-    void lsm303d_get_accelerometer(const lsm303d_context dev,
-                                   float *x, float *y, float *z);
-
-    /**
-     * Return temperature data in degrees Celsius..  update() must
-     * have been called prior to calling this function.
-     *
-     * @param dev The device context
-     * @return Temperature in degrees Celsius
-     */
-    float lsm303d_get_temperature(const lsm303d_context dev);
-
-    /**
-     * Set the full scale (sensitivity) value for the accelerometer.
-     * This device supports 2G, 4G, 6G, 8G, and 16G full scale modes.
-     *
-     * @param dev The device context
-     * @param fs One of the LSM303D_AFS_T values
-     * @return UPM result
-     */
-    upm_result_t lsm303d_set_acc_full_scale(const lsm303d_context dev,
-                                            LSM303D_AFS_T fs);
-
-    /**
-     * Set the full scale (sensitivity) value for the magnetometer.
-     * This device supports 2, 4, 8, and 16 Gauss.
-     *
-     * @param dev The device context
-     * @param fs One of the LSM303D_MFS_T values
-     * @return UPM result
-     */
-    upm_result_t lsm303d_set_mag_full_scale(const lsm303d_context dev,
-                                            LSM303D_MFS_T fs);
-
-    /**
-     * Initialize the device and start operation.  This function is
-     * called from the constructor so it will not typically need to be
-     * called by a user unless the device is reset.  It will
-     * initialize the accelerometer and magnetometer (if enabled) to
-     * certain default running modes.
-     *
-     * @param dev The device context
-     * @param res One of the LSM303D_M_RES_T values.  This value sets
-     * the resolution of the magnetometer.  At init time, this value
-     * is set to LSM303D_M_RES_HIGH.
-     * @return UPM result
-     */
-    upm_result_t lsm303d_devinit(const lsm303d_context dev,
-                                 LSM303D_M_RES_T res);
-
-    /**
-     * Set the accelerometer (acc) output data rate (odr)
-     *
-     * @param dev The device context
-     * @param odr One of the LSM303D_AODR_T values.  The default
-     * set at initialization time is LSM303D_AODR_100HZ.
-     * @return UPM result
-     */
-    upm_result_t lsm303d_set_acc_odr(const lsm303d_context dev,
-                                     LSM303D_AODR_T odr);
-
-    /**
-     * Set the magnetometer (mag) output data rate (odr)
-     *
-     * @param dev The device context
-     * @param odr One of the LSM303D_MODR_T values.  The default
-     * set at initialization time is LSM303D_MODR_12_5HZ.
-     * @return UPM result
-     */
-    upm_result_t lsm303d_set_mag_odr(const lsm303d_context dev,
-                                     LSM303D_MODR_T odr);
-
-    /**
-     * Read a register.
-     *
-     * @param dev The device context
-     * @param reg The register to read
-     * @return The value of the register
-     */
-    uint8_t lsm303d_read_reg(const lsm303d_context dev, uint8_t reg);
-
-    /**
-     * Read contiguous registers into a buffer
-     *
-     * @param dev The device context
-     * @param buffer The buffer to store the results
-     * @param len The number of registers to read
-     * @return The number of bytes read, or -1 on error
-     */
-    int lsm303d_read_regs(const lsm303d_context dev, uint8_t reg,
-                          uint8_t *buffer, int len);
-
-    /**
-     * Write to a register
-     *
-     * @param dev The device context
-     * @param reg The register to write to
-     * @param val The value to write
-     * @return UPM result
-     */
-    upm_result_t lsm303d_write_reg(const lsm303d_context dev,
-                                   uint8_t reg, uint8_t val);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/lsm303d/lsm303d.hpp b/src/lsm303d/lsm303d.hpp
deleted file mode 100644
index 1ae36f8..0000000
--- a/src/lsm303d/lsm303d.hpp
+++ /dev/null
@@ -1,244 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <vector>
-
-#include <mraa/gpio.hpp>
-#include "lsm303d.h"
-
-namespace upm {
-
-    /**
-     * @brief LSM303D Ultra-compact eCompass Module
-     * @defgroup lsm303d libupm-lsm303d
-     * @ingroup i2c gpio stmicro compass accelerometer
-     */
-
-    /**
-     * @library lsm303d
-     * @sensor lsm303d
-     * @comname Ultra-compact high-performance eCompass module
-     * @type compass
-     * @man stmicro
-     * @con i2c gpio
-     * @web http://www.st.com/en/mems-and-sensors/lsm303d.html
-     *
-     * @brief API for the LSM303D 3-Axis Geomagnetic Sensor
-     *
-     * The LSM303D is an ultra-low-power high-performance
-     * system-in-package featuring a 3D digital linear acceleration
-     * sensor and a 3D digital magnetic sensor.  The LSM303D has
-     * linear acceleration full scales of 2g/4g/8g/16g and a
-     * magnetic field dynamic range of 50 Gauss.
-     *
-     * Not all functionality of this chip has been implemented in this
-     * driver, however all the pieces are present to add any desired
-     * functionality.  This driver supports only I2C operation.
-     *
-     * This device requires 3.3v operation.
-     *
-     * @snippet lsm303d.cxx Interesting
-     */
-
-    class LSM303D {
-    public:
-        /**
-         * LSM303D constructor
-         *
-         * This driver only supports I2C.
-         *
-         * Due to the fact that this chip is currently obsolete, we only
-         * support minimum functionality.
-         *
-         * @param bus I2C bus to use
-         * @param addr The I2C address of the device
-         * @return The device context, or NULL if an error occurred
-         * @throws std::runtime_error on failure.
-         */
-        LSM303D(int bus=LSM303D_DEFAULT_I2C_BUS,
-                int addr=LSM303D_DEFAULT_I2C_ADDR);
-
-        /**
-         * LSM303D Destructor
-         */
-        ~LSM303D();
-
-        /**
-         * Update the internal stored values from sensor data.  This
-         * method must be called before querying the acceleration,
-         * magnetometer, or temperature.
-         *
-         * @throws std::runtime_error on failure
-         */
-        void update();
-
-        /**
-         * Return magnetometer data in micro-Teslas (uT).  update() must
-         * have been called prior to calling this method.
-         *
-         * @param x Pointer to a floating point value that will have the
-         * current x component placed into it
-         * @param y Pointer to a floating point value that will have the
-         * current y component placed into it
-         * @param z Pointer to a floating point value that will have the
-         * current z component placed into it
-         */
-        void getMagnetometer(float *x, float *y, float *z);
-
-        /**
-         * Return magnetometer data in micro-Teslas (uT) in the form
-         * of a floating point vector.  update() must have been called
-         * prior to calling this method.
-         *
-         * @return A floating point vector containing x, y, and z in
-         * that order
-         */
-        std::vector<float> getMagnetometer();
-
-        /**
-         * Return acceleration data in gravities.  update() must have
-         * been called prior to calling this method.
-         *
-         * @param x Pointer to a floating point value that will have the
-         * current x component placed into it
-         * @param y Pointer to a floating point value that will have the
-         * current y component placed into it
-         * @param z Pointer to a floating point value that will have the
-         * current z component placed into it
-         */
-        void getAccelerometer(float *x, float *y, float *z);
-
-        /**
-         * Return acceleration data in gravities in the form of a
-         * floating point vector.  update() must have been called
-         * prior to calling this method.
-         *
-         * @return A floating point vector containing x, y, and z in
-         * that order
-         */
-        std::vector<float> getAccelerometer();
-
-        /**
-         * Return temperature data in degrees Celsius.  NOTE: This is
-         * not the ambient room temperature.  update() must have been
-         * called prior to calling this method.
-         *
-         * @return Temperature in degrees Celsius
-         */
-        float getTemperature();
-
-        /**
-         * Initialize the device and start operation.  This function
-         * is called from the constructor so it will not typically
-         * need to be called by a user unless the device is reset.  It
-         * will initialize the accelerometer and magnetometer (if
-         * enabled) to certain default running modes.
-         *
-         * @param res One of the LSM303D_M_RES_T values.  This value
-         * sets the resolution of the magnetometer.  At init time,
-         * this value is set to LSM303D_M_RES_HIGH.
-         * @throws std::runtime_error on failure
-         */
-        void init(LSM303D_M_RES_T res);
-
-        /**
-         * Set the full scale (sensitivity) value for the
-         * accelerometer.  This device supports 2G, 4G, 6G, 8G, and
-         * 16G full scale modes.
-         *
-         * @param fs One of the LSM303D_AFS_T values
-         * @throws std::runtime_error on failure
-         */
-        void setAccelerometerFullScale(LSM303D_AFS_T fs);
-
-        /**
-         * Set the full scale (sensitivity) value for the
-         * magnetometer.  This device supports 2, 4, 8, and
-         * 16 Gauss full scale modes.
-         *
-         * @param fs One of the LSM303D_MFS_T values
-         * @throws std::runtime_error on failure
-         */
-        void setMagnetometerFullScale(LSM303D_MFS_T fs);
-
-        /**
-         * Set the accelerometer output data rate (ODR)
-         *
-         * @param odr One of the LSM303D_AODR_T values.  The default
-         * set at initialization time is LSM303D_AODR_100HZ.
-         * @throws std::runtime_error on failure
-         */
-        void setAccelerometerODR(LSM303D_AODR_T odr);
-
-        /**
-         * Set the magnetometer output data rate (ODR)
-         *
-         * @param odr One of the LSM303D_MODR_T values.
-         * The default set at initialization time is
-         * LSM303D_MODR_12_5HZ.
-         * @throws std::runtime_error on failure
-         */
-        void setMagnetometerODR(LSM303D_MODR_T odr);
-
-    protected:
-        // our underlying device context
-        lsm303d_context m_lsm303d;
-
-        /**
-         * Read a register
-         *
-         * @param reg The register to read
-         * @return The value of the register
-         */
-        uint8_t readReg(uint8_t reg);
-
-        /**
-         * Read contiguous registers into a buffer
-         *
-         * @param buffer The buffer to store the results
-         * @param len The number of registers to read
-         * @return The number of bytes read
-         * @throws std::runtime_error on failure
-         */
-        int readRegs(uint8_t reg, uint8_t *buffer, int len);
-
-        /**
-         * Write to a register
-         *
-         * @param reg The register to write to
-         * @param val The value to write
-         * @throws std::runtime_error on failure
-         */
-        void writeReg(uint8_t reg, uint8_t val);
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        LSM303D(const LSM303D&) = delete;
-        LSM303D &operator=(const LSM303D&) = delete;
-    };
-}
diff --git a/src/lsm303d/lsm303d.i b/src/lsm303d/lsm303d.i
deleted file mode 100644
index ba5c465..0000000
--- a/src/lsm303d/lsm303d.i
+++ /dev/null
@@ -1,48 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "../upm_javastdvector.i"
-
-%ignore getMagnetometer(float *, float *, float *);
-%ignore getAccelerometer(float *, float *, float *);
-
-%typemap(javaimports) SWIGTYPE %{
-import java.util.AbstractList;
-import java.lang.Float;
-%}
-
-%typemap(javaout) SWIGTYPE {
-    return new $&javaclassname($jnicall, true);
-}
-%typemap(javaout) std::vector<float> {
-    return (AbstractList<Float>)(new $&javaclassname($jnicall, true));
-}
-%typemap(jstype) std::vector<float> "AbstractList<Float>"
-
-%template(floatVector) std::vector<float>;
-
-JAVA_JNI_LOADLIBRARY(javaupm_lsm303d)
-#endif
-/* END Java syntax */
-
-/* BEGIN Javascript syntax  ------------------------------------------------- */
-#ifdef SWIGJAVASCRIPT
-%include "../upm_vectortypes.i"
-#endif
-/* END Javascript syntax */
-
-/* BEGIN Python syntax  ----------------------------------------------------- */
-#ifdef SWIGPYTHON
-%include "../upm_vectortypes.i"
-#endif
-/* END Python syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "lsm303d_defs.h"
-#include "lsm303d.hpp"
-%}
-%include "lsm303d_defs.h"
-%include "lsm303d.hpp"
-/* END Common SWIG syntax */
diff --git a/src/lsm303d/lsm303d.json b/src/lsm303d/lsm303d.json
deleted file mode 100644
index b112f14..0000000
--- a/src/lsm303d/lsm303d.json
+++ /dev/null
@@ -1,39 +0,0 @@
-{
-    "Library": "lsm303d",
-    "Description": "API for the LSM303D 3-Axis Geomagnetic Sensor",
-    "Sensor Class":
-    {
-        "LSM303D":
-        {
-            "Name": "Ultra-compact high-performance eCompass module",
-            "Description": "The LSM303D is an ultra-low-power high-performance system-in-package featuring a 3D digital linear acceleration sensor and a 3D digital magnetic sensor.  The LSM303D has linear acceleration full scales of 2g/4g/8g/16g and a magnetic field dynamic range of 50 Gauss. Not all functionality of this chip has been implemented in this driver, however all the pieces are present to add any desired functionality.  This driver supports only I2C operation.",
-            "Aliases": ["lsm303d"],
-            "Categories": ["compass"],
-            "Connections": ["i2c"],
-            "Project Type": ["robotics", "prototyping"],
-            "Manufacturers": ["stmicro"],
-            "Kits": [],
-            "Examples":
-            {
-                "Java": ["LSM303D_Example.java"],
-                "Python": ["lsm303d.py"],
-                "Node.js": ["lsm303d.js"],
-                "C++": ["lsm303d.cxx"],
-                "C": ["lsm303d.c"]
-            },
-            "Specifications":
-            {
-                "Operating Voltage": {"unit": "V", "low": 2.16, "high": 3.6},
-                "Operating Current": {"unit": "uA", "typ": 300},
-                "Operating Temperature": {"unit": "degC", "low": -40, "high": 85}
-
-            },
-            "Urls" :
-            {
-                "Product Pages": ["http://www.st.com/en/mems-and-sensors/lsm303d.html"],
-                "Datasheets": ["http://www.st.com/content/ccc/resource/technical/document/datasheet/1c/9e/71/05/4e/b7/4d/d1/DM00057547.pdf/files/DM00057547.pdf/jcr:content/translations/en.DM00057547.pdf"],
-                "Schematics": []
-            }
-        }
-    }
-}
diff --git a/src/lsm303d/lsm303d_defs.h b/src/lsm303d/lsm303d_defs.h
deleted file mode 100644
index ccbcef7..0000000
--- a/src/lsm303d/lsm303d_defs.h
+++ /dev/null
@@ -1,301 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-#define LSM303D_DEFAULT_I2C_BUS 0
-#define LSM303D_DEFAULT_I2C_ADDR 0x1e
-
-// from the WHO_AM_I_* register
-#define LSM303D_CHIPID 0x49
-
-
-    // Due to the fact that this chip is currently obsolete, we only
-    // support minimum functionality.  This register map is not
-    // complete.  While all registers are specified, bitfields and
-    // enumerants are only specified for certain registers of
-    // interest.  Feel free to add what you need.
-
-    // NOTE: Reserved registers must not be written into or permanent
-    // damage to the device can result.  Reading from them may return
-    // indeterminate values.  Registers containing reserved bitfields
-    // must be written as 0.
-
-    /**
-     * LSM303D registers
-     */
-    typedef enum {
-
-        // 0x00-0x04 reserved
-
-        LSM303D_REG_TEMP_OUT_L                   = 0x05,
-        LSM303D_REG_TEMP_OUT_H                   = 0x06,
-
-        LSM303D_REG_STATUS_M                     = 0x07,
-
-        LSM303D_REG_OUT_X_L_M                    = 0x08,
-        LSM303D_REG_OUT_X_H_M                    = 0x09,
-        LSM303D_REG_OUT_Y_L_M                    = 0x0a,
-        LSM303D_REG_OUT_Y_H_M                    = 0x0b,
-        LSM303D_REG_OUT_Z_L_M                    = 0x0c,
-        LSM303D_REG_OUT_Z_H_M                    = 0x0d,
-
-        // 0x0e reserved
-
-        LSM303D_REG_WHO_AM_I                     = 0x0f,
-
-        // 0x10-0x11 reserved
-
-        LSM303D_REG_INT_CTRL_M                   = 0x12,
-        LSM303D_REG_INT_SRC_M                    = 0x13,
-        LSM303D_REG_INT_THS_L_M                  = 0x14,
-        LSM303D_REG_INT_THS_H_M                  = 0x15,
-
-        LSM303D_REG_OFFSET_X_L_M                 = 0x16,
-        LSM303D_REG_OFFSET_X_H_M                 = 0x17,
-        LSM303D_REG_OFFSET_Y_L_M                 = 0x18,
-        LSM303D_REG_OFFSET_Y_H_M                 = 0x19,
-        LSM303D_REG_OFFSET_Z_L_M                 = 0x1a,
-        LSM303D_REG_OFFSET_Z_H_M                 = 0x1b,
-
-        LSM303D_REG_REFERENCE_X                  = 0x1c,
-        LSM303D_REG_REFERENCE_Y                  = 0x1d,
-        LSM303D_REG_REFERENCE_Z                  = 0x1e,
-
-        LSM303D_REG_CTRL0                        = 0x1f,
-        LSM303D_REG_CTRL1                        = 0x20,
-        LSM303D_REG_CTRL2                        = 0x21,
-        LSM303D_REG_CTRL3                        = 0x22,
-        LSM303D_REG_CTRL4                        = 0x23,
-        LSM303D_REG_CTRL5                        = 0x24,
-        LSM303D_REG_CTRL6                        = 0x25,
-        LSM303D_REG_CTRL7                        = 0x26,
-
-        LSM303D_REG_STATUS_A                     = 0x27,
-
-        LSM303D_REG_OUT_X_L_A                    = 0x28,
-        LSM303D_REG_OUT_X_H_A                    = 0x29,
-        LSM303D_REG_OUT_Y_L_A                    = 0x2a,
-        LSM303D_REG_OUT_Y_H_A                    = 0x2b,
-        LSM303D_REG_OUT_Z_L_A                    = 0x2c,
-        LSM303D_REG_OUT_Z_H_A                    = 0x2d,
-
-        LSM303D_REG_FIFO_CTRL                    = 0x2e,
-        LSM303D_REG_FIFO_SRC                     = 0x2f,
-
-        LSM303D_REG_IG_CFG1                      = 0x30,
-        LSM303D_REG_IG_SRC1                      = 0x31,
-        LSM303D_REG_IG_THS1                      = 0x32,
-        LSM303D_REG_IG_DUR1                      = 0x33,
-        LSM303D_REG_IG_CFG2                      = 0x34,
-        LSM303D_REG_IG_SRC2                      = 0x35,
-        LSM303D_REG_IG_THS2                      = 0x36,
-        LSM303D_REG_IG_DUR2                      = 0x37,
-
-        LSM303D_REG_CLICK_CFG                    = 0x38,
-        LSM303D_REG_CLICK_SRC                    = 0x39,
-        LSM303D_REG_CLICK_THS                    = 0x3a,
-
-        LSM303D_REG_TIME_LIMIT                   = 0x3b,
-        LSM303D_REG_TIME_LATENCY                 = 0x3c,
-        LSM303D_REG_TIME_WINDOW                  = 0x3d,
-
-        LSM303D_REG_ACT_THS                      = 0x3e,
-        LSM303D_REG_ACT_DUR                      = 0x3f,
-    } LSM303D_REGS_T;
-
-    // Accelerometer registers
-
-    /**
-     * CTRL1 bits
-     */
-    typedef enum {
-        LSM303D_CTRL1_AXEN                       = 0x01, // axis enables
-        LSM303D_CTRL1_AYEN                       = 0x02,
-        LSM303D_CTRL1_AZEN                       = 0x04,
-
-        LSM303D_CTRL1_BDU                        = 0x08,
-
-        LSM303D_CTRL1_AODR0                      = 0x10,
-        LSM303D_CTRL1_AODR1                      = 0x20,
-        LSM303D_CTRL1_AODR2                      = 0x40,
-        LSM303D_CTRL1_AODR3                      = 0x80,
-        _LSM303D_CTRL1_AODR_MASK                 = 15,
-        _LSM303D_CTRL1_AODR_SHIFT                = 4,
-    } LSM303D_CTRL1_BITS_T;
-
-    /**
-     * CTRL1_AODR values (and power mode)
-     */
-    typedef enum {
-        LSM303D_AODR_POWER_DOWN                 = 0,
-        LSM303D_AODR_3_125HZ                    = 1, // 3.125Hz
-        LSM303D_AODR_6_25HZ                     = 2,
-        LSM303D_AODR_12_5HZ                     = 3,
-        LSM303D_AODR_25HZ                       = 4,
-        LSM303D_AODR_50HZ                       = 5,
-        LSM303D_AODR_100HZ                      = 6,
-        LSM303D_AODR_200HZ                      = 7,
-        LSM303D_AODR_400HZ                      = 8,
-        LSM303D_AODR_800HZ                      = 9,
-        LSM303D_AODR_1600HZ                     = 10,
-    } LSM303D_AODR_T;
-
-    /**
-     * CTRL2 bits
-     */
-    typedef enum {
-        LSM303D_CTRL2_SIM                        = 0x01,
-        LSM303D_CTRL2_AST                        = 0x02,
-
-        // 0x04 reserved
-
-        LSM303D_CTRL2_AFS0                       = 0x08, // full scale
-        LSM303D_CTRL2_AFS1                       = 0x10,
-        LSM303D_CTRL2_AFS2                       = 0x20,
-        _LSM303D_CTRL2_AFS_MASK                  = 7,
-        _LSM303D_CTRL2_AFS_SHIFT                 = 3,
-
-        LSM303D_CTRL2_ABW0                       = 0x40,
-        LSM303D_CTRL2_ABW1                       = 0x80,
-        _LSM303D_CTRL2_ABW_MASK                  = 3,
-        _LSM303D_CTRL2_ABW_SHIFT                 = 6,
-    } LSM303D_CTRL2_BITS_T;
-
-    /**
-     * CTRL2_AFS values (full scale)
-     */
-    typedef enum {
-        LSM303D_AFS_2G                          = 0, // 2G
-        LSM303D_AFS_4G                          = 1,
-        LSM303D_AFS_6G                          = 2,
-        LSM303D_AFS_8G                          = 3,
-        LSM303D_AFS_16G                         = 4,
-    } LSM303D_AFS_T;
-
-    /**
-     * CTRL5 bits
-     */
-    typedef enum {
-        LSM303D_CTRL5_LIR1                       = 0x01,
-        LSM303D_CTRL5_LIR2                       = 0x02,
-
-        LSM303D_CTRL5_MODR0                      = 0x04, // mag odr
-        LSM303D_CTRL5_MODR1                      = 0x08,
-        LSM303D_CTRL5_MODR2                      = 0x10,
-        _LSM303D_CTRL5_MODR_MASK                 = 7,
-        _LSM303D_CTRL5_MODR_SHIFT                = 2,
-
-        LSM303D_CTRL5_M_RES0                     = 0x20, // resolution
-        LSM303D_CTRL5_M_RES1                     = 0x40,
-        _LSM303D_CTRL5_MRES_MASK                 = 3,
-        _LSM303D_CTRL5_MRES_SHIFT                = 6,
-
-        LSM303D_CTRL5_TEMP_EN                    = 0x80,
-    } LSM303D_CTRL5_BITS_T;
-
-    /**
-     * CTRL5_MODR values (mag output data rate)
-     */
-    typedef enum {
-        LSM303D_MODR_3_125HZ                     = 0, // 3.125Hz
-        LSM303D_MODR_6_25HZ                      = 1,
-        LSM303D_MODR_12_5HZ                      = 2,
-        LSM303D_MODR_25HZ                        = 3,
-        LSM303D_MODR_50HZ                        = 4,
-        LSM303D_MODR_100HZ                       = 5,
-    } LSM303D_MODR_T;
-
-    /**
-     * CTRL5_M_RES values (resolution)
-     */
-    typedef enum {
-        LSM303D_M_RES_LOW                        = 0,
-        LSM303D_M_RES_HIGH                       = 3,
-    } LSM303D_M_RES_T;
-
-    /**
-     * CTRL6 bits
-     */
-    typedef enum {
-        // 0x01-0x10 reserved
-
-        LSM303D_CTRL6_MFS0                       = 0x20,
-        LSM303D_CTRL6_MFS1                       = 0x40,
-        _LSM303D_CTRL6_MFS_MASK                  = 3,
-        _LSM303D_CTRL6_MFS_SHIFT                 = 5,
-
-        // 0x80 reserved
-    } LSM303D_CTRL6_BITS_T;
-
-    /**
-     * CTRL6_MFS values (mag full scale)
-     */
-    typedef enum {
-        LSM303D_MFS_2                            = 0, // 2 Gauss
-        LSM303D_MFS_4                            = 1,
-        LSM303D_MFS_8                            = 2,
-        LSM303D_MFS_12                           = 3,
-    } LSM303D_MFS_T;
-
-    /**
-     * CTRL7 bits
-     */
-    typedef enum {
-        LSM303D_CTRL7_MD0                        = 0x01,
-        LSM303D_CTRL7_MD1                        = 0x02,
-        _LSM303D_CTRL7_MD_MASK                   = 3,
-        _LSM303D_CTRL7_MD_SHIFT                  = 0,
-
-        LSM303D_CTRL7_MLP                        = 0x04,
-
-        // 0x08 reserved
-
-        LSM303D_CTRL7_T_ONLY                     = 0x10,
-        LSM303D_CTRL7_AFDS                       = 0x20,
-
-        LSM303D_CTRL7_AHPM0                      = 0x40,
-        LSM303D_CTRL7_AHPM1                      = 0x80,
-        _LSM303D_CTRL7_AHPM_MASK                 = 3,
-        _LSM303D_CTRL7_AHPM_SHIFT                = 6,
-    } LSM303D_CTRL7_BITS_T;
-
-    /**
-     * CTRL7_MD values (power mode)
-     */
-    typedef enum {
-        LSM303D_MD_CONTINUOUS                    = 0,
-        LSM303D_MD_SINGLE                        = 1,
-        LSM303D_MD_POWER_DOWN                    = 3, // 2 is pwr down too
-    } LSM303D_MD_T;
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/lsm303dlh/CMakeLists.txt b/src/lsm303dlh/CMakeLists.txt
deleted file mode 100644
index bab4ee7..0000000
--- a/src/lsm303dlh/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "lsm303dlh")
-set (libdescription "Triaxial Accelerometer/magnetometer")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/lsm303dlh/lsm303dlh.cxx b/src/lsm303dlh/lsm303dlh.cxx
deleted file mode 100644
index afd2222..0000000
--- a/src/lsm303dlh/lsm303dlh.cxx
+++ /dev/null
@@ -1,229 +0,0 @@
-/*
- * Author: Brendan Le Foll <brendan.le.foll@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Code based on LSM303DLH sample by Jim Lindblom SparkFun Electronics
- * and the CompensatedCompass.ino by Frankie Chu from SeedStudio
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-#include <unistd.h>
-#include <stdlib.h>
-
-#include "lsm303dlh.hpp"
-
-using namespace upm;
-
-LSM303DLH::LSM303DLH(int bus, int addrMag, int addrAcc, int accScale) :
-    m_i2cMag(bus), m_i2cAcc(bus)
-{
-    m_addrMag = addrMag;
-    m_addrAcc = addrAcc;
-
-
-    if (m_i2cMag.address(m_addrMag) != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_address() failed");
-    }
-
-    if (m_i2cAcc.address(m_addrAcc) != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_address() failed");
-    }
-
-    // 0x27 is the 'normal' mode with X/Y/Z enable
-    setRegisterSafe(LSM303DLH_ACC_T, CTRL_REG1_A, 0x27);
-
-    // scale can be 2, 4 or 8
-    if (2 == accScale) {
-        setRegisterSafe(LSM303DLH_ACC_T, CTRL_REG4_A, 0x00);
-    } else if (4 == accScale) {
-        setRegisterSafe(LSM303DLH_ACC_T, CTRL_REG4_A, 0x10);
-    } else { // default; equivalent to 8g
-        setRegisterSafe(LSM303DLH_ACC_T, CTRL_REG4_A, 0x30);
-    }
-
-    // 0x10 = minimum datarate ~15Hz output rate
-    setRegisterSafe(LSM303DLH_MAG_T, CRA_REG_M, 0x10);
-
-    // magnetic scale = +/-1.3
-    // Gaussmagnetic scale = +/-1.3Gauss (0x20)
-    // +-8.1Gauss (0xe0)
-    setRegisterSafe(LSM303DLH_MAG_T, CRB_REG_M, 0xe0);
-
-    // 0x00 = continouous conversion mode
-    setRegisterSafe(LSM303DLH_MAG_T, MR_REG_M, 0x00);
-}
-
-float
-LSM303DLH::getHeading()
-{
-    if (getCoordinates() != mraa::SUCCESS) {
-        return -1;
-    }
-
-    float heading = 180.0 * atan2(double(coor[Y]), double(coor[X]))/M_PI;
-
-    if (heading < 0.0)
-        heading += 360.0;
-
-    return heading;
-}
-
-int16_t*
-LSM303DLH::getRawAccelData()
-{
-    return &accel[0];
-}
-
-int16_t*
-LSM303DLH::getRawCoorData()
-{
-    return &coor[0];
-}
-
-int16_t
-LSM303DLH::getAccelX()
-{
-    return accel[X];
-}
-
-int16_t
-LSM303DLH::getAccelY()
-{
-    return accel[Y];
-}
-
-int16_t
-LSM303DLH::getAccelZ()
-{
-    return accel[Z];
-}
-
-mraa::Result
-LSM303DLH::getCoordinates()
-{
-    mraa::Result ret = mraa::SUCCESS;
-
-    memset(&buf[0], 0, sizeof(uint8_t)*6);
-    ret = m_i2cMag.writeByte(OUT_X_H_M);
-    int num = m_i2cMag.read(buf, 6);
-    if (num != 6) {
-        return ret;
-    }
-    // convert to coordinates
-    for (int i=0; i<3; i++) {
-        coor[i] = (int16_t(buf[2*i] << 8))
-            |  int16_t(buf[(2*i)+1]);
-    }
-    // swap elements 1 and 2 to get things in natural XYZ order
-    int16_t t = coor[2];
-    coor[2] = coor[1];
-    coor[1] = t;
-    //printf("X=%x, Y=%x, Z=%x\n", coor[X], coor[Y], coor[Z]);
-
-    return ret;
-}
-
-int16_t
-LSM303DLH::getCoorX() {
-    return coor[X];
-}
-
-int16_t
-LSM303DLH::getCoorY() {
-    return coor[Y];
-}
-
-int16_t
-LSM303DLH::getCoorZ() {
-    return coor[Z];
-}
-
-// helper function that writes a value to the acc and then reads
-// FIX: shouldn't this be write-then-read?
-int
-LSM303DLH::readThenWrite(uint8_t reg)
-{
-    m_i2cAcc.writeByte(reg);
-    return (int) m_i2cAcc.readByte();
-}
-
-mraa::Result
-LSM303DLH::getAcceleration()
-{
-    mraa::Result ret = mraa::SUCCESS;
-
-    accel[X] = (int16_t(readThenWrite(OUT_X_H_A)) << 8)
-        |  int16_t(readThenWrite(OUT_X_L_A));
-    accel[Y] = (int16_t(readThenWrite(OUT_Y_H_A)) << 8)
-        |  int16_t(readThenWrite(OUT_Y_L_A));
-    accel[Z] = (int16_t(readThenWrite(OUT_Z_H_A)) << 8)
-        |  int16_t(readThenWrite(OUT_Z_L_A));
-    //printf("X=%x, Y=%x, Z=%x\n", accel[X], accel[Y], accel[Z]);
-
-    return ret;
-}
-
-// helper function that sets a register and then checks the set was succesful
-mraa::Result
-LSM303DLH::setRegisterSafe(LSM303DLH_SLAVE_T slave, uint8_t sregister, uint8_t data)
-{
-    buf[0] = sregister;
-    buf[1] = data;
-    uint8_t val;
-
-    switch(slave) {
-        case LSM303DLH_MAG_T:
-            if (m_i2cMag.write(buf, 2) != mraa::SUCCESS) {
-                throw std::invalid_argument(std::string(__FUNCTION__) +
-                                ": mraa_i2c_write() failed");
-                return mraa::ERROR_INVALID_HANDLE;
-            }
-            val = m_i2cMag.readReg(sregister);
-            if (val != data) {
-                throw std::invalid_argument(std::string(__FUNCTION__) +
-                                ": failed to set register correctly");
-                return mraa::ERROR_UNSPECIFIED;
-            }
-        break;
-	case LSM303DLH_ACC_T:
-            if (m_i2cAcc.write(buf, 2) != mraa::SUCCESS) {
-                throw std::invalid_argument(std::string(__FUNCTION__) +
-                                ": mraa_i2c_write() failed");
-                return mraa::ERROR_INVALID_HANDLE;
-            }
-            val = m_i2cAcc.readReg(sregister);
-            if (val != data) {
-                throw std::invalid_argument(std::string(__FUNCTION__) +
-                                ": failed to set register correctly");
-                return mraa::ERROR_UNSPECIFIED;
-            }
-        break;
-	default:
-	    return mraa::ERROR_UNSPECIFIED;
-    }
-
-    return mraa::SUCCESS;
-}
diff --git a/src/lsm303dlh/lsm303dlh.hpp b/src/lsm303dlh/lsm303dlh.hpp
deleted file mode 100644
index 75b8e34..0000000
--- a/src/lsm303dlh/lsm303dlh.hpp
+++ /dev/null
@@ -1,185 +0,0 @@
-/*
- * Author: Brendan Le Foll<brendan.le.foll@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Code based on LSM303DLH sample by Jim Lindblom SparkFun Electronics
- * and the CompensatedCompass.ino by Frankie Chu from SeedStudio
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string.h>
-#include <mraa/i2c.hpp>
-#include <math.h>
-
-namespace upm {
-
-/* LSM303DLH Address definitions */
-#define LSM303DLH_MAG 0x1E
-#define LSM303DLH_ACC 0x19
-
-/* LSM303DLH Register definitions */
-#define CTRL_REG1_A 0x20
-#define CTRL_REG2_A 0x21
-#define CTRL_REG3_A 0x22
-#define CTRL_REG4_A 0x23
-#define CTRL_REG5_A 0x24
-
-#define CRA_REG_M 0x00
-#define CRB_REG_M 0x01
-
-#define MR_REG_M 0x02
-#define OUT_X_H_M 0x03
-
-#define OUT_X_L_A 0x28
-#define OUT_X_H_A 0x29
-#define OUT_Y_L_A 0x2A
-#define OUT_Y_H_A 0x2B
-#define OUT_Z_L_A 0x2C
-#define OUT_Z_H_A 0x2D
-
-#define X 0
-#define Y 1
-#define Z 2
-
-/**
- * @brief LSM303DLH Accelerometer/Compass
- * @defgroup lsm303dlh libupm-lsm303dlh
- * @ingroup seeed adafruit stmicro i2c accelerometer compass
- */
-
-/**
- * @library lsm303dlh
- * @sensor lsm303dlh
- * @comname Triaxial Accelerometer/magnetometer
- * @altname Grove 6-Axis Accelerometer & Compass
- * @type accelerometer compass
- * @man seeed adafruit stmicro
- * @web http://www.seeedstudio.com/wiki/Grove_-_6-Axis_Accelerometer%26Compass
- * @con i2c
- *
- * @brief API for the LSM303DLH Accelerometer & Compass
- *
- * This module defines the LSM303DLHDLH 3-axis magnetometer/3-axis accelerometer.
- * This module was tested with the Seeed Studio* Grove 6-Axis Accelerometer & Compass
- * module used over I2C. The magnetometer and acceleromter are accessed
- * at two seperate I2C addresses.
- *
- * @image html lsm303dlh.jpeg
- * @snippet lsm303dlh.cxx Interesting
- */
-    class LSM303DLH {
-    public:
-	typedef enum {
-		LSM303DLH_MAG_T = 0,
-		LSM303DLH_ACC_T } LSM303DLH_SLAVE_T;
-        /**
-         * Instantiates an LSM303DLH object
-         *
-         * @param bus I2C bus to use
-         * @param addrMag I2C address of the Magnetometer (default 0x1E)
-         * @param addrAcc I2C address of the Accelerometer (default 0x19)
-         * @param accScale Accelerometer scale, can be 2, 4 or 8 (default 8)
-         */
-        LSM303DLH (int bus,
-                   int addrMag=LSM303DLH_MAG,
-                   int addrAcc=LSM303DLH_ACC,
-                   int accScale=8);
-
-        /**
-         * LSM303DLH object destructor
-         * where is no more need for this here - I2c connection will be stopped
-         * automatically when m_i2c variable will go out of scope
-         * ~LSM303DLH ();
-         **/
-
-        /**
-         * Gets the current heading; headings <0 indicate an error has occurred
-         *
-         * @return float
-         */
-        float getHeading();
-
-        /**
-         * Gets the coordinates in the XYZ order
-         */
-        mraa::Result getCoordinates();
-
-        /**
-         * Gets accelerometer values
-         * Should be called before other "get" functions for acceleration
-         */
-        mraa::Result getAcceleration();
-
-        /**
-         * Gets raw coordinate data; it is updated when getCoordinates() is called
-         */
-        int16_t* getRawCoorData();
-
-        /**
-         * Gets the X component of the coordinates data
-         */
-        int16_t getCoorX();
-
-        /**
-         * Gets the Y component of the coordinates data
-         */
-        int16_t getCoorY();
-
-        /**
-         * Gets the Z component of the coordinates data
-         */
-        int16_t getCoorZ();
-
-        /**
-         * Gets raw accelerometer data; it is updated when getAcceleration() is called
-         */
-        int16_t* getRawAccelData();
-
-        /**
-         * Gets the X component of the acceleration data
-         */
-        int16_t getAccelX();
-
-        /**
-         * Gets the Y component of the acceleration data
-         */
-        int16_t getAccelY();
-
-        /**
-         * Gets the Z component of the acceleration data
-         */
-        int16_t getAccelZ();
-
-    private:
-        int readThenWrite(uint8_t reg);
-        mraa::Result setRegisterSafe(LSM303DLH_SLAVE_T slave, uint8_t sregister, uint8_t data);
-
-        mraa::I2c m_i2cMag;
-        mraa::I2c m_i2cAcc;
-        int m_addrMag;
-        int m_addrAcc;
-        uint8_t buf[6];
-        int16_t coor[3];
-        int16_t accel[3];
-    };
-
-}
diff --git a/src/lsm303dlh/lsm303dlh.i b/src/lsm303dlh/lsm303dlh.i
deleted file mode 100644
index b56cff4..0000000
--- a/src/lsm303dlh/lsm303dlh.i
+++ /dev/null
@@ -1,51 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%typemap(jni) int16_t* "jshortArray"
-%typemap(jstype) int16_t* "short[]"
-%typemap(jtype) int16_t* "short[]"
-
-%typemap(javaout) int16_t* {
-    return $jnicall;
-}
-
-%typemap(out) int16_t *getRawAccelData {
-    $result = JCALL1(NewShortArray, jenv, 3);
-    JCALL4(SetShortArrayRegion, jenv, $result, 0, 3, (jshort*)$1);
-}
-
-JAVA_JNI_LOADLIBRARY(javaupm_lsm303dlh)
-#endif
-/* END Java syntax */
-
-/* BEGIN Javascript syntax  ------------------------------------------------- */
-#ifdef SWIGJAVASCRIPT
-%include "../carrays_int16_t.i"
-
-// Adding this typemap because SWIG is converting int16 into a short by default
-// This forces SWIG to convert it correctly
-%typemap(out) int16_t* {
-	jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int16Array, 0 |  0 );
-}
-#endif
-/* END Javascript syntax */
-
-/* BEGIN Python syntax  ----------------------------------------------------- */
-#ifdef SWIGPYTHON
-%include "../carrays_int16_t.i"
-
-// Adding this typemap because SWIG is converting int16 into a short by default
-// This forces SWIG to convert it correctly
-%typemap(out) int16_t* {
-	resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int16Array, 0 |  0 );
-}
-#endif
-/* END Python syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "lsm303dlh.hpp"
-%}
-%include "lsm303dlh.hpp"
-/* END Common SWIG syntax */
diff --git a/src/lsm303dlh/lsm303dlh.json b/src/lsm303dlh/lsm303dlh.json
deleted file mode 100644
index 2cd07b5..0000000
--- a/src/lsm303dlh/lsm303dlh.json
+++ /dev/null
@@ -1,36 +0,0 @@
-{
-    "Library": "lsm303dlh",
-    "Description": "API for the LSM303DLH Accelerometer & Compass",
-    "Sensor Class":
-    {
-        "LSM303DLH":
-        {
-            "Name": "Triaxial Accelerometer/magnetometer",
-            "Description": "This module defines the LSM303DLH 3-axis magnetometer/3-axis accelerometer. This module was tested with the Seeed Studio* Grove 6-Axis Accelerometer & Compass module used over I2C. The magnetometer and acceleromter are accessed at two seperate I2C addresses.",
-            "Aliases": ["lsm303dlh"],
-            "Categories": ["compass", "accelerometer"],
-            "Connections": ["i2c"],
-            "Project Type": ["imu", "prototyping"],
-            "Manufacturers": ["seeed", "adafruit", "stmicro"],
-            "Kits": [],
-            "Examples":
-            {
-                "Java": ["LSM303DLH_Example.java"],
-                "Python": ["lsm303dlh.py"],
-                "Node.js": ["lsm303dhl.js"],
-                "C++": ["lsm303dlh.cxx"],
-                "C": []
-            },
-            "Specifications":
-            {
-                "Operating Voltage": {"unit": "V", "typ": 3.3}
-            },
-            "Urls" :
-            {
-                "Product Pages": ["https://www.seeedstudio.com/grove-6axis-accelerometercompass-p-1448.html?cPath=144_146"],
-                "Datasheets": ["http://wiki.seeedstudio.com/wiki/Grove_-_6-Axis_Accelerometer%26Compass_V1.0"],
-                "Schematics": []
-            }
-        }
-    }
-}
diff --git a/src/lsm6ds3h/CMakeLists.txt b/src/lsm6ds3h/CMakeLists.txt
deleted file mode 100644
index 25b0baa..0000000
--- a/src/lsm6ds3h/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME lsm6ds3h
-    DESCRIPTION "3-Axis Digital Accelerometer and Gyroscope"
-    C_HDR lsm6ds3h.h lsm6ds3h_defs.h
-    C_SRC lsm6ds3h.c
-    CPP_HDR lsm6ds3h.hpp
-    CPP_SRC lsm6ds3h.cxx
-    FTI_SRC lsm6ds3h_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/lsm6ds3h/lsm6ds3h.c b/src/lsm6ds3h/lsm6ds3h.c
deleted file mode 100644
index ca8b0fb..0000000
--- a/src/lsm6ds3h/lsm6ds3h.c
+++ /dev/null
@@ -1,640 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <assert.h>
-
-#include "upm_utilities.h"
-#include "lsm6ds3h.h"
-
-// macro for converting a uint8_t low/high pair into a float
-#define INT16_TO_FLOAT(h, l) \
-    (float)( (int16_t)( (l) | ((h) << 8) ) )
-
-// some useful macros to save on typing and text wrapping
-#undef _SHIFT
-#define _SHIFT(x) (_LSM6DS3H_##x##_SHIFT)
-
-#undef _MASK
-#define _MASK(x) (_LSM6DS3H_##x##_MASK)
-
-#undef _SHIFTMASK
-#define _SHIFTMASK(x) (_MASK(x) << _SHIFT(x))
-
-// SPI CS on and off functions
-static void _csOn(const lsm6ds3h_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->gpioCS)
-        mraa_gpio_write(dev->gpioCS, 0);
-}
-
-static void _csOff(const lsm6ds3h_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->gpioCS)
-        mraa_gpio_write(dev->gpioCS, 1);
-}
-
-// init
-lsm6ds3h_context lsm6ds3h_init(int bus, int addr, int cs)
-{
-    lsm6ds3h_context dev =
-        (lsm6ds3h_context)malloc(sizeof(struct _lsm6ds3h_context));
-
-    if (!dev)
-        return NULL;
-
-    // zero out context
-    memset((void *)dev, 0, sizeof(struct _lsm6ds3h_context));
-
-    // make sure MRAA is initialized
-    if (mraa_init() != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed.\n", __FUNCTION__);
-        lsm6ds3h_close(dev);
-        return NULL;
-    }
-
-    if (addr < 0)
-    {
-        // SPI
-        if (!(dev->spi = mraa_spi_init(bus)))
-        {
-            printf("%s: mraa_spi_init() failed.\n", __FUNCTION__);
-            lsm6ds3h_close(dev);
-            return NULL;
-        }
-
-        // Only create cs context if we are actually using a valid pin.
-        // A hardware controlled pin should specify cs as -1.
-        if (cs >= 0)
-        {
-            if (!(dev->gpioCS = mraa_gpio_init(cs)))
-            {
-                printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
-                lsm6ds3h_close(dev);
-                return NULL;
-            }
-            mraa_gpio_dir(dev->gpioCS, MRAA_GPIO_OUT);
-        }
-
-        mraa_spi_mode(dev->spi, MRAA_SPI_MODE0);
-        if (mraa_spi_frequency(dev->spi, 5000000))
-        {
-            printf("%s: mraa_spi_frequency() failed.\n", __FUNCTION__);
-            lsm6ds3h_close(dev);
-            return NULL;
-        }
-    }
-    else
-    {
-        // I2C
-        if (!(dev->i2c = mraa_i2c_init(bus)))
-        {
-            printf("%s: mraa_i2c_init() failed.\n", __FUNCTION__);
-            lsm6ds3h_close(dev);
-            return NULL;
-        }
-
-        if (mraa_i2c_address(dev->i2c, addr))
-        {
-            printf("%s: mraa_i2c_address() failed.\n", __FUNCTION__);
-            lsm6ds3h_close(dev);
-            return NULL;
-        }
-    }
-
-    // check the chip id
-
-    uint8_t chipID = lsm6ds3h_get_chip_id(dev);
-    if (chipID != LSM6DS3H_CHIPID)
-    {
-        printf("%s: invalid chip id: %02x.  Expected %02x\n",
-               __FUNCTION__, chipID, LSM6DS3H_CHIPID);
-        lsm6ds3h_close(dev);
-        return NULL;
-    }
-
-    // reset
-    if (lsm6ds3h_reset(dev))
-    {
-        printf("%s: lsm6ds3h_reset() failed.\n", __FUNCTION__);
-        lsm6ds3h_close(dev);
-        return NULL;
-    }
-
-    // call devinit with default options
-    if (lsm6ds3h_devinit(dev, LSM6DS3H_XL_ODR_104HZ, LSM6DS3H_XL_FS_2G,
-                         LSM6DS3H_G_ODR_104HZ, LSM6DS3H_G_FS_245DPS))
-    {
-        printf("%s: lsm6ds3h_devinit() failed.\n", __FUNCTION__);
-        lsm6ds3h_close(dev);
-        return NULL;
-    }
-
-    return dev;
-}
-
-void lsm6ds3h_close(lsm6ds3h_context dev)
-{
-    assert(dev != NULL);
-
-    lsm6ds3h_uninstall_isr(dev, LSM6DS3H_INTERRUPT_INT1);
-    lsm6ds3h_uninstall_isr(dev, LSM6DS3H_INTERRUPT_INT2);
-
-    if (dev->i2c)
-        mraa_i2c_stop(dev->i2c);
-    if (dev->spi)
-        mraa_spi_stop(dev->spi);
-    if (dev->gpioCS)
-        mraa_gpio_close(dev->gpioCS);
-
-    free(dev);
-}
-
-upm_result_t lsm6ds3h_devinit(const lsm6ds3h_context dev,
-                              LSM6DS3H_XL_ODR_T acc_odr,
-                              LSM6DS3H_XL_FS_T acc_fs,
-                              LSM6DS3H_G_ODR_T gyr_odr,
-                              LSM6DS3H_G_FS_T gyr_fs)
-{
-    assert(dev != NULL);
-
-    // enable register auto-increment and BDU (block data update)
-    uint8_t reg = lsm6ds3h_read_reg(dev, LSM6DS3H_REG_CTRL3_C);
-    reg |= (LSM6DS3H_CTRL3_IF_INC | LSM6DS3H_CTRL3_BDU);
-
-    if (lsm6ds3h_write_reg(dev, LSM6DS3H_REG_CTRL3_C, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    // set our ODR, FS, and HP mode
-    if (lsm6ds3h_set_acc_odr(dev, acc_odr)
-        || lsm6ds3h_set_acc_full_scale(dev, acc_fs)
-        || lsm6ds3h_set_gyr_odr(dev, gyr_odr)
-        || lsm6ds3h_set_gyr_full_scale(dev, gyr_fs)
-        || lsm6ds3h_high_performance(dev, true))
-    {
-        printf("%s: failed to set configuration parameters.\n",
-               __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // settle
-    upm_delay_ms(50);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t lsm6ds3h_set_acc_odr(const lsm6ds3h_context dev,
-                                  LSM6DS3H_XL_ODR_T odr)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = lsm6ds3h_read_reg(dev, LSM6DS3H_REG_CTRL1_XL);
-
-    // mask out ODR bits, add our own
-    reg &= ~_SHIFTMASK(CTRL1_XL_ODR);
-    reg |= (odr << _SHIFT(CTRL1_XL_ODR));
-
-    if (lsm6ds3h_write_reg(dev, LSM6DS3H_REG_CTRL1_XL, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t lsm6ds3h_set_gyr_odr(const lsm6ds3h_context dev,
-                                  LSM6DS3H_G_ODR_T odr)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = lsm6ds3h_read_reg(dev, LSM6DS3H_REG_CTRL2_G);
-
-    // mask out ODR bits, add our own
-    reg &= ~_SHIFTMASK(CTRL2_G_ODR);
-    reg |= (odr << _SHIFT(CTRL2_G_ODR));
-
-    if (lsm6ds3h_write_reg(dev, LSM6DS3H_REG_CTRL2_G, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t lsm6ds3h_set_acc_full_scale(const lsm6ds3h_context dev,
-                                         LSM6DS3H_XL_FS_T fs)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = lsm6ds3h_read_reg(dev, LSM6DS3H_REG_CTRL1_XL);
-
-    // mask out FS bits, add our own
-    reg &= ~_SHIFTMASK(CTRL1_XL_FS);
-    reg |= (fs << _SHIFT(CTRL1_XL_FS));
-
-    if (lsm6ds3h_write_reg(dev, LSM6DS3H_REG_CTRL1_XL, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    // 16b resolution
-    switch(fs)
-    {
-    case LSM6DS3H_XL_FS_2G:
-        dev->accScale = 0.061;
-        break;
-
-    case LSM6DS3H_XL_FS_4G:
-        dev->accScale = 0.122;
-        break;
-
-    case LSM6DS3H_XL_FS_8G:
-        dev->accScale = 0.244;
-        break;
-
-    case LSM6DS3H_XL_FS_16G:
-        dev->accScale = 0.488;
-        break;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t lsm6ds3h_set_gyr_full_scale(const lsm6ds3h_context dev,
-                                         LSM6DS3H_G_FS_T fs)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = lsm6ds3h_read_reg(dev, LSM6DS3H_REG_CTRL2_G);
-
-    // mask out FS bits, add our own
-    reg &= ~_SHIFTMASK(CTRL2_G_FS);
-
-    if ((int)fs > (int)_MASK(CTRL2_G_FS))
-        reg |= LSM6DS3H_CTRL2_G_FS_125;
-    else
-        reg &= ~LSM6DS3H_CTRL2_G_FS_125;
-
-    // mask off the virtual bit.  The end result will be 245dps (0),
-    // if it was tagged with the virtual bit.
-    fs &= _MASK(CTRL2_G_FS);
-    // add it to the register
-    reg |= (fs << _SHIFT(CTRL2_G_FS));
-
-    if (lsm6ds3h_write_reg(dev, LSM6DS3H_REG_CTRL2_G, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t lsm6ds3h_update(const lsm6ds3h_context dev)
-{
-    assert(dev != NULL);
-
-    int bufLen = 14;
-    uint8_t buf[bufLen];
-
-    if (lsm6ds3h_read_regs(dev, LSM6DS3H_REG_OUT_TEMP_L,
-                           buf, bufLen) != bufLen)
-    {
-        printf("%s: lsm6ds3h_read_regs() failed to read %d bytes\n",
-               __FUNCTION__, bufLen);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // temperature is first           msb     lsb
-    dev->temperature = INT16_TO_FLOAT(buf[1], buf[0]);
-
-    // gyroscope
-    dev->gyrX = INT16_TO_FLOAT(buf[3], buf[2]);
-    dev->gyrY = INT16_TO_FLOAT(buf[5], buf[4]);
-    dev->gyrZ = INT16_TO_FLOAT(buf[7], buf[6]);
-
-    // accelerometer
-    dev->accX = INT16_TO_FLOAT(buf[9], buf[8]);
-    dev->accY = INT16_TO_FLOAT(buf[11], buf[10]);
-    dev->accZ = INT16_TO_FLOAT(buf[13], buf[12]);
-
-    return UPM_SUCCESS;
-}
-
-uint8_t lsm6ds3h_read_reg(const lsm6ds3h_context dev, uint8_t reg)
-{
-    assert(dev != NULL);
-
-    if (dev->spi)
-    {
-        reg |= 0x80; // needed for read
-        uint8_t pkt[2] = {reg, 0};
-
-        _csOn(dev);
-        if (mraa_spi_transfer_buf(dev->spi, pkt, pkt, 2))
-        {
-            _csOff(dev);
-            printf("%s: mraa_spi_transfer_buf() failed.\n", __FUNCTION__);
-            return 0xff;
-        }
-        _csOff(dev);
-
-        return pkt[1];
-    }
-    else
-        return (uint8_t)mraa_i2c_read_byte_data(dev->i2c, reg);
-}
-
-int lsm6ds3h_read_regs(const lsm6ds3h_context dev, uint8_t reg,
-                       uint8_t *buffer, int len)
-{
-    assert(dev != NULL);
-
-    if (dev->spi)
-    {
-        reg |= 0x80; // needed for read
-
-        uint8_t sbuf[len + 1];
-        memset((char *)sbuf, 0, len + 1);
-        sbuf[0] = reg;
-
-        _csOn(dev);
-        if (mraa_spi_transfer_buf(dev->spi, sbuf, sbuf, len + 1))
-        {
-            _csOff(dev);
-            printf("%s: mraa_spi_transfer_buf() failed.\n", __FUNCTION__);
-            return -1;
-        }
-        _csOff(dev);
-
-        // now copy it into user buffer
-        for (int i=0; i<len; i++)
-            buffer[i] = sbuf[i + 1];
-    }
-    else
-    {
-        if (mraa_i2c_read_bytes_data(dev->i2c, reg, buffer, len) != len)
-            return -1;
-    }
-
-    return len;
-}
-
-upm_result_t lsm6ds3h_write_reg(const lsm6ds3h_context dev,
-                                uint8_t reg, uint8_t val)
-{
-    assert(dev != NULL);
-
-    if (dev->spi)
-    {
-        reg &= 0x7f; // mask off 0x80 for writing
-        uint8_t pkt[2] = {reg, val};
-
-        _csOn(dev);
-        if (mraa_spi_transfer_buf(dev->spi, pkt, NULL, 2))
-        {
-            _csOff(dev);
-            printf("%s: mraa_spi_transfer_buf() failed.",
-                   __FUNCTION__);
-
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-        _csOff(dev);
-    }
-    else
-    {
-        if (mraa_i2c_write_byte_data(dev->i2c, val, reg))
-        {
-            printf("%s: mraa_i2c_write_byte_data() failed.",
-                   __FUNCTION__);
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-    }
-
-    return UPM_SUCCESS;
-}
-
-uint8_t lsm6ds3h_get_chip_id(const lsm6ds3h_context dev)
-{
-    assert(dev != NULL);
-
-    return lsm6ds3h_read_reg(dev, LSM6DS3H_REG_WHO_AM_I);
-}
-
-void lsm6ds3h_get_accelerometer(const lsm6ds3h_context dev,
-                                float *x, float *y, float *z)
-{
-    assert(dev != NULL);
-
-    if (x)
-        *x = dev->accX * dev->accScale / 1000.00;
-
-    if (y)
-        *y = dev->accY * dev->accScale / 1000.00;
-
-    if (z)
-        *z = dev->accZ * dev->accScale / 1000.00;
-}
-
-void lsm6ds3h_get_gyroscope(const lsm6ds3h_context dev,
-                            float *x, float *y, float *z)
-{
-    assert(dev != NULL);
-
-    if (x)
-        *x = dev->gyrX / 1000.00;
-
-    if (y)
-        *y = dev->gyrY / 1000.00;
-
-    if (z)
-        *z = dev->gyrZ / 1000.00;
-}
-
-float lsm6ds3h_get_temperature(const lsm6ds3h_context dev)
-{
-    assert(dev != NULL);
-
-    // this seems to work, but I sure wish they would document this in
-    // their DS's
-    return (dev->temperature / 65536.0) + 25.0;
-}
-
-upm_result_t lsm6ds3h_high_performance(const lsm6ds3h_context dev,
-                                       bool enable)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = lsm6ds3h_read_reg(dev, LSM6DS3H_REG_CTRL6_C);
-
-    // acc
-    if (enable)
-        reg &= ~LSM6DS3H_CTRL6_XL_HM_MODE;
-    else
-        reg |= LSM6DS3H_CTRL6_XL_HM_MODE;
-
-    if (lsm6ds3h_write_reg(dev, LSM6DS3H_REG_CTRL6_C, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    // gyr
-    reg = lsm6ds3h_read_reg(dev, LSM6DS3H_REG_CTRL7_G);
-
-    if (enable)
-        reg &= ~LSM6DS3H_CTRL7_G_HM_MODE;
-    else
-        reg |= LSM6DS3H_CTRL7_G_HM_MODE;
-
-    if (lsm6ds3h_write_reg(dev, LSM6DS3H_REG_CTRL7_G, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    upm_delay_ms(100);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t lsm6ds3h_reset(const lsm6ds3h_context dev)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = lsm6ds3h_read_reg(dev, LSM6DS3H_REG_CTRL3_C);
-
-    reg |= LSM6DS3H_CTRL3_SW_RESET;
-
-    if (lsm6ds3h_write_reg(dev, LSM6DS3H_REG_CTRL3_C, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    upm_delay_ms(100);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t lsm6ds3h_set_interrupt_active_high(const lsm6ds3h_context dev,
-                                                bool high)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = lsm6ds3h_read_reg(dev, LSM6DS3H_REG_CTRL3_C);
-
-    if (high)
-        reg &= ~LSM6DS3H_CTRL3_H_LACTIVE;
-    else
-        reg |= LSM6DS3H_CTRL3_H_LACTIVE;
-
-    if (lsm6ds3h_write_reg(dev, LSM6DS3H_REG_CTRL3_C, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t lsm6ds3h_set_interrupt_push_pull(const lsm6ds3h_context dev,
-                                              bool pp)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = lsm6ds3h_read_reg(dev, LSM6DS3H_REG_CTRL3_C);
-
-    if (pp)
-        reg &= ~LSM6DS3H_CTRL3_PP_OD;
-    else
-        reg |= LSM6DS3H_CTRL3_PP_OD;
-
-    if (lsm6ds3h_write_reg(dev, LSM6DS3H_REG_CTRL3_C, reg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-uint8_t lsm6ds3h_get_status(const lsm6ds3h_context dev)
-{
-    assert(dev != NULL);
-
-    return lsm6ds3h_read_reg(dev, LSM6DS3H_REG_STATUS);
-}
-
-upm_result_t lsm6ds3h_install_isr(const lsm6ds3h_context dev,
-                                  LSM6DS3H_INTERRUPT_PINS_T intr, int gpio,
-                                  mraa_gpio_edge_t level,
-                                  void (*isr)(void *), void *arg)
-{
-    assert(dev != NULL);
-
-    // delete any existing ISR and GPIO context for this interrupt
-    lsm6ds3h_uninstall_isr(dev, intr);
-
-    mraa_gpio_context gpio_isr = NULL;
-
-    // create gpio context
-    if (!(gpio_isr = mraa_gpio_init(gpio)))
-    {
-        printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    mraa_gpio_dir(gpio_isr, MRAA_GPIO_IN);
-
-    if (mraa_gpio_isr(gpio_isr, level, isr, arg))
-    {
-        mraa_gpio_close(gpio_isr);
-        printf("%s: mraa_gpio_isr() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    switch (intr)
-    {
-    case LSM6DS3H_INTERRUPT_INT1:
-        dev->gpioINT1 = gpio_isr;
-        break;
-
-    case LSM6DS3H_INTERRUPT_INT2:
-        dev->gpioINT2 = gpio_isr;
-        break;
-    }
-
-    return UPM_SUCCESS;
-}
-
-void lsm6ds3h_uninstall_isr(const lsm6ds3h_context dev,
-                            LSM6DS3H_INTERRUPT_PINS_T intr)
-{
-    assert(dev != NULL);
-
-    switch (intr)
-    {
-    case LSM6DS3H_INTERRUPT_INT1:
-        if (dev->gpioINT1)
-        {
-            mraa_gpio_isr_exit(dev->gpioINT1);
-            mraa_gpio_close(dev->gpioINT1);
-            dev->gpioINT1 = NULL;
-        }
-        break;
-
-    case LSM6DS3H_INTERRUPT_INT2:
-        if (dev->gpioINT2)
-        {
-            mraa_gpio_isr_exit(dev->gpioINT2);
-            mraa_gpio_close(dev->gpioINT2);
-            dev->gpioINT2 = NULL;
-        }
-        break;
-    }
-}
diff --git a/src/lsm6ds3h/lsm6ds3h.cxx b/src/lsm6ds3h/lsm6ds3h.cxx
deleted file mode 100644
index 150abaa..0000000
--- a/src/lsm6ds3h/lsm6ds3h.cxx
+++ /dev/null
@@ -1,208 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016-2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <iostream>
-#include <stdexcept>
-#include <string>
-
-#include "lsm6ds3h.hpp"
-
-using namespace upm;
-using namespace std;
-
-// conversion from Celsius to Fahrenheit
-
-static float c2f(float c)
-{
-    return (c * (9.0 / 5.0) + 32.0);
-}
-
-LSM6DS3H::LSM6DS3H(int bus, int addr, int cs) :
-    m_lsm6ds3h(lsm6ds3h_init(bus, addr, cs))
-{
-    if (!m_lsm6ds3h)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm6ds3h_init() failed");
-}
-
-LSM6DS3H::~LSM6DS3H()
-{
-    lsm6ds3h_close(m_lsm6ds3h);
-}
-
-void LSM6DS3H::init(LSM6DS3H_XL_ODR_T acc_odr, LSM6DS3H_XL_FS_T acc_fs,
-                    LSM6DS3H_G_ODR_T gyr_odr,  LSM6DS3H_G_FS_T gyr_fs)
-{
-    if (lsm6ds3h_devinit(m_lsm6ds3h, acc_odr, acc_fs, gyr_odr, gyr_fs))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm6ds3h_devinit() failed");
-}
-
-void LSM6DS3H::update()
-{
-    if (lsm6ds3h_update(m_lsm6ds3h))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm6ds3h_update() failed");
-}
-
-uint8_t LSM6DS3H::readReg(uint8_t reg)
-{
-    return lsm6ds3h_read_reg(m_lsm6ds3h, reg);
-}
-
-int LSM6DS3H::readRegs(uint8_t reg, uint8_t *buffer, int len)
-{
-    int rv = lsm6ds3h_read_regs(m_lsm6ds3h, reg, buffer, len);
-    if (rv != len)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm6ds3h_read_regs() failed");
-
-    return rv;
-}
-
-void LSM6DS3H::writeReg(uint8_t reg, uint8_t val)
-{
-    if (lsm6ds3h_write_reg(m_lsm6ds3h, reg, val))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm6ds3h_write_reg() failed");
-}
-
-uint8_t LSM6DS3H::getChipID()
-{
-    return lsm6ds3h_get_chip_id(m_lsm6ds3h);
-}
-
-void LSM6DS3H::getAccelerometer(float *x, float *y, float *z)
-{
-    lsm6ds3h_get_accelerometer(m_lsm6ds3h, x, y, z);
-}
-
-std::vector<float> LSM6DS3H::getAccelerometer()
-{
-    float v[3];
-
-    getAccelerometer(&v[0], &v[1], &v[2]);
-    return std::vector<float>(v, v+3);
-}
-
-void LSM6DS3H::getGyroscope(float *x, float *y, float *z)
-{
-    lsm6ds3h_get_gyroscope(m_lsm6ds3h, x, y, z);
-}
-
-std::vector<float> LSM6DS3H::getGyroscope()
-{
-    float v[3];
-
-    getGyroscope(&v[0], &v[1], &v[2]);
-    return std::vector<float>(v, v+3);
-}
-
-float LSM6DS3H::getTemperature(bool fahrenheit)
-{
-    float temperature = lsm6ds3h_get_temperature(m_lsm6ds3h);
-    if (fahrenheit)
-        return c2f(temperature);
-    else
-        return temperature;
-}
-
-void LSM6DS3H::reset()
-{
-    if (lsm6ds3h_reset(m_lsm6ds3h))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm6ds3h_reset() failed");
-}
-
-void LSM6DS3H::setAccelerometerODR(LSM6DS3H_XL_ODR_T odr)
-{
-    if (lsm6ds3h_set_acc_odr(m_lsm6ds3h, odr))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm6ds3h_set_acc_odr() failed");
-}
-
-void LSM6DS3H::setAccelerometerFullScale(LSM6DS3H_XL_FS_T fs)
-{
-    if (lsm6ds3h_set_acc_full_scale(m_lsm6ds3h, fs))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm6ds3h_set_acc_full_scale() failed");
-}
-
-void LSM6DS3H::setGyroscopeODR(LSM6DS3H_G_ODR_T odr)
-{
-    if (lsm6ds3h_set_gyr_odr(m_lsm6ds3h, odr))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm6ds3h_set_gyr_odr() failed");
-}
-
-void LSM6DS3H::setGyroscopeFullScale(LSM6DS3H_G_FS_T fs)
-{
-    if (lsm6ds3h_set_gyr_full_scale(m_lsm6ds3h, fs))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm6ds3h_set_gyr_full_scale() failed");
-}
-
-void LSM6DS3H::setHighPerformance(bool enable)
-{
-    if (lsm6ds3h_high_performance(m_lsm6ds3h, enable))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm6ds3h_high_performance() failed");
-}
-
-void LSM6DS3H::setInterruptActiveHigh(bool high)
-{
-    if (lsm6ds3h_set_interrupt_active_high(m_lsm6ds3h, high))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm6ds3h_set_interrupt_active_high() failed");
-}
-
-void LSM6DS3H::setInterruptPushPull(bool pp)
-{
-    if (lsm6ds3h_set_interrupt_push_pull(m_lsm6ds3h, pp))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm6ds3h_set_interrupt_push_pull() failed");
-}
-
-uint8_t LSM6DS3H::getStatus()
-{
-    return lsm6ds3h_get_status(m_lsm6ds3h);
-}
-
-void LSM6DS3H::installISR(LSM6DS3H_INTERRUPT_PINS_T intr, int gpio,
-                          mraa::Edge level,
-                          void (*isr)(void *), void *arg)
-{
-    if (lsm6ds3h_install_isr(m_lsm6ds3h, intr, gpio,
-                             (mraa_gpio_edge_t)level, isr, arg))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": lsm6ds3h_install_isr() failed");
-}
-
-void LSM6DS3H::uninstallISR(LSM6DS3H_INTERRUPT_PINS_T intr)
-{
-    lsm6ds3h_uninstall_isr(m_lsm6ds3h, intr);
-}
diff --git a/src/lsm6ds3h/lsm6ds3h.h b/src/lsm6ds3h/lsm6ds3h.h
deleted file mode 100644
index 398c2e6..0000000
--- a/src/lsm6ds3h/lsm6ds3h.h
+++ /dev/null
@@ -1,340 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <unistd.h>
-#include <string.h>
-
-#include <mraa/i2c.h>
-#include <mraa/spi.h>
-#include <mraa/gpio.h>
-
-#include "upm.h"
-
-#include "lsm6ds3h_defs.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    /**
-     * @file lsm6ds3h.h
-     * @library lsm6ds3h
-     * @brief C API for the lsm6ds3h driver
-     *
-     * @include lsm6ds3h.c
-     */
-
-    /**
-     * Device context
-     */
-    typedef struct _lsm6ds3h_context {
-        mraa_i2c_context i2c;
-        mraa_spi_context spi;
-
-        mraa_gpio_context gpioCS; // SPI CS pin
-        mraa_gpio_context gpioINT1; // intr 1
-        mraa_gpio_context gpioINT2; // intr 2
-
-        // uncompensated temperature
-        float temperature;
-
-        // uncompensated acc data
-        float accX;
-        float accY;
-        float accZ;
-
-        // uncompensated gyr data
-        float gyrX;
-        float gyrY;
-        float gyrZ;
-
-        // acc scaling
-        float accScale;
-    } *lsm6ds3h_context;
-
-    /**
-     * LSM6DS3H initialization.
-     *
-     * This device can support both I2C and SPI. For SPI, set the addr
-     * to -1, and specify a positive integer representing the Chip
-     * Select (CS) pin for the cs argument.  If you are using a
-     * hardware CS pin (like Intel Edison with Arduino breakout), then
-     * you can connect the proper pin to the hardware CS pin on your
-     * MCU and supply -1 for cs.
-     *
-     * @param bus I2C or SPI bus to use
-     * @param addr The address for this device, or -1 for SPI
-     * @param cs The gpio pin to use for the SPI Chip Select.  Use -1 for
-     * I2C or for SPI with a hardware controlled pin.
-     * @return The device context, or NULL on error
-     */
-    lsm6ds3h_context lsm6ds3h_init(int bus, int addr, int cs);
-
-    /**
-     * LSM6DS3H Destructor
-     *
-     * @param dev The device context
-     */
-    void lsm6ds3h_close(lsm6ds3h_context dev);
-
-    /**
-     * Update the internal stored values from sensor data
-     *
-     * @param dev The device context
-     * @return UPM result
-     */
-    upm_result_t lsm6ds3h_update(const lsm6ds3h_context dev);
-
-    /**
-     * Return the chip ID
-     *
-     * @param dev The device context
-     * @return The chip ID (LSM6DS3H_CHIPID)
-     */
-    uint8_t lsm6ds3h_get_chip_id(const lsm6ds3h_context dev);
-
-    /**
-     * Initialize the device and start operation.  This function is
-     * called from lsm6ds3h_init(), so it will not need to be called
-     * by a user unless the device is reset.  It sets the
-     * accelerometer and gyroscope ODR and FS modes, and enables BDU,
-     * register auto-increment, and high performance mode.
-     *
-     * @param dev The device context
-     * @param acc_odr One of the LSM6DS3H_XL_ODR_T values
-     * @param acc_fs One of the LSM6DS3H_XL_FS_T values
-     * @param gyr_odr One of the LSM6DS3H_G_ODR_T values
-     * @param gyr_fs One of the LSM6DS3H_G_FS_T values
-     * @return UPM result
-     */
-    upm_result_t lsm6ds3h_devinit(const lsm6ds3h_context dev,
-                                  LSM6DS3H_XL_ODR_T acc_odr,
-                                  LSM6DS3H_XL_FS_T acc_fs,
-                                  LSM6DS3H_G_ODR_T gyr_odr,
-                                  LSM6DS3H_G_FS_T gyr_fs);
-
-    /**
-     * Set the output data rate (ODR) of the accelerometer
-     *
-     * @param dev The device context
-     * @param odr One of the LSM6DS3H_XL_ODR_T values
-     * @return UPM result
-     */
-    upm_result_t lsm6ds3h_set_acc_odr(const lsm6ds3h_context dev,
-                                      LSM6DS3H_XL_ODR_T odr);
-
-    /**
-     * Set the output data rate (ODR) of the gyroscope
-     *
-     * @param dev The device context
-     * @param odr One of the LSM6DS3H_G_ODR_T values
-     * @return UPM result
-     */
-    upm_result_t lsm6ds3h_set_gyr_odr(const lsm6ds3h_context dev,
-                                      LSM6DS3H_G_ODR_T odr);
-
-    /**
-     * Set the full scale (FS) of the accelerometer.  This device
-     * supports a full scale of 2, 4, 8, and 16G.
-     *
-     * @param dev The device context
-     * @param fs One of the LSM6DS3H_XL_FS_T values
-     * @return UPM result
-     */
-    upm_result_t lsm6ds3h_set_acc_full_scale(const lsm6ds3h_context dev,
-                                             LSM6DS3H_XL_FS_T fs);
-
-    /**
-     * Set the full scale (FS) of the gyroscope.  This device supports
-     * a full scale of 125, 245, 500, 1000, and 2000 degrees per
-     * second (DPS)
-     *
-     * @param dev The device context
-     * @param fs One of the LSM6DS3H_G_FS_T values
-     * @return UPM result
-     */
-    upm_result_t lsm6ds3h_set_gyr_full_scale(const lsm6ds3h_context dev,
-                                             LSM6DS3H_G_FS_T fs);
-
-    /**
-     * Return accelerometer data in gravities (g).  lsm6ds3h_update()
-     * must have been called prior to calling this function.
-     *
-     * @param dev The device context
-     * @param x Pointer to a floating point value that will have the
-     * current x component placed into it
-     * @param y Pointer to a floating point value that will have the
-     * current y component placed into it
-     * @param z Pointer to a floating point value that will have the
-     * current z component placed into it
-     */
-    void lsm6ds3h_get_accelerometer(const lsm6ds3h_context dev,
-                                    float *x, float *y, float *z);
-
-    /**
-     * Return gyroscope data in degrees per second (DPS).
-     * lsm6ds3h_update() must have been called prior to calling this
-     * function.
-     *
-     * @param dev The device context
-     * @param x Pointer to a floating point value that will have the
-     * current x component placed into it
-     * @param y Pointer to a floating point value that will have the
-     * current y component placed into it
-     * @param z Pointer to a floating point value that will have the
-     * current z component placed into it
-     */
-    void lsm6ds3h_get_gyroscope(const lsm6ds3h_context dev,
-                                float *x, float *y, float *z);
-
-    /**
-     * Return the current measured temperature.  Note, this is not
-     * ambient temperature.  lsm6ds3h_update() must have been called
-     * prior to calling this function.
-     *
-     * @param dev The device context
-     * @return The temperature in degrees Celsius
-     */
-    float lsm6ds3h_get_temperature(const lsm6ds3h_context dev);
-
-    /**
-     * Enable accelerometer and gyroscope high performance modes.
-     * These are further defined by the respective ODR settings to
-     * allow low power, and normal/high-performance modes.
-     *
-     * @param dev The device context
-     * @param enable true to enable high performance mode, false otherwise
-     * @return UPM result
-     */
-    upm_result_t lsm6ds3h_high_performance(const lsm6ds3h_context dev,
-                                           bool enable);
-
-    /**
-     * Reset the device as if during a power on reset.  All configured
-     * values are lost when this happens.  You should call
-     * lsm6ds3h_devinit() afterwards, or at least perform the same
-     * initialization lsm6ds3h_devinit() does before continuing.
-     *
-     * @param dev The device context
-     * @return UPM result
-     */
-    upm_result_t lsm6ds3h_reset(const lsm6ds3h_context dev);
-
-    /**
-     * Indicate whether the interrupt should be active high (default)
-     * or active low.  See the datasheet for details.
-     *
-     * @param dev The device context
-     * @param high true for active high, false for active low
-     * @return UPM result
-     */
-    upm_result_t lsm6ds3h_set_interrupt_active_high(const lsm6ds3h_context dev,
-                                                    bool high);
-
-    /**
-     * Indicate whether interrupts are push-pull (default) or open
-     * drain.  See the datasheet for details.
-     *
-     * @param dev The device context
-     * @param pp true for push-pull, false for open-drain
-     * @return UPM result
-     */
-    upm_result_t lsm6ds3h_set_interrupt_push_pull(const lsm6ds3h_context dev,
-                                                  bool pp);
-
-    /**
-     * Return the contents of the status register
-     *
-     * @param dev The device context
-     * @return A bitmask of values from LSM6DS3H_STATUS_BITS_T
-     */
-    uint8_t lsm6ds3h_get_status(const lsm6ds3h_context dev);
-
-    /**
-     * Install an interrupt handler
-     *
-     * @param dev The device context
-     * @param intr One of the LSM6DS3H_INTERRUPT_PINS_T values
-     * specifying which interrupt pin you are installing
-     * @param gpio GPIO pin to use as interrupt pin
-     * @param level The interrupt trigger level (one of mraa_gpio_edge_t
-     * values).  Make sure that you have configured the interrupt pin
-     * properly for whatever level you choose.
-     * @param isr The interrupt handler, accepting a void * argument
-     * @param arg The argument to pass the the interrupt handler
-     * @return UPM result
-     */
-    upm_result_t lsm6ds3h_install_isr(const lsm6ds3h_context dev,
-                                      LSM6DS3H_INTERRUPT_PINS_T intr, int gpio,
-                                      mraa_gpio_edge_t level,
-                                      void (*isr)(void *), void *arg);
-
-    /**
-     * Uninstall a previously installed interrupt handler
-     *
-     * @param dev The device context
-     * @param intr One of the LSM6DS3H_INTERRUPT_PINS_T values
-     * specifying which interrupt pin you are removing
-     */
-    void lsm6ds3h_uninstall_isr(const lsm6ds3h_context dev,
-                                LSM6DS3H_INTERRUPT_PINS_T intr);
-
-    /**
-     * Read a register
-     *
-     * @param dev The device context
-     * @param reg The register to read
-     * @return The value of the register
-     */
-    uint8_t lsm6ds3h_read_reg(const lsm6ds3h_context dev, uint8_t reg);
-
-    /**
-     * Read contiguous registers into a buffer
-     *
-     * @param dev The device context
-     * @param buffer The buffer to store the results
-     * @param len The number of registers to read
-     * @return The number of bytes read, or -1 on error
-     */
-    int lsm6ds3h_read_regs(const lsm6ds3h_context dev, uint8_t reg,
-                           uint8_t *buffer, int len);
-
-    /**
-     * Write to a register
-     *
-     * @param dev The device context
-     * @param reg The register to write to
-     * @param val The value to write
-     * @return UPM result
-     */
-    upm_result_t lsm6ds3h_write_reg(const lsm6ds3h_context dev,
-                                    uint8_t reg, uint8_t val);
-
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/lsm6ds3h/lsm6ds3h.hpp b/src/lsm6ds3h/lsm6ds3h.hpp
deleted file mode 100644
index 299282d..0000000
--- a/src/lsm6ds3h/lsm6ds3h.hpp
+++ /dev/null
@@ -1,325 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016-2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <vector>
-
-#include <mraa/gpio.hpp>
-#include "lsm6ds3h.h"
-
-namespace upm {
-
-    /**
-     * @brief LSM6DS6H 3-axis Accelerometer
-     * @defgroup lsm6ds3h libupm-lsm6ds3h
-     * @ingroup i2c spi gpio stmicro accelerometer
-     */
-
-    /**
-     * @library lsm6ds3h
-     * @sensor lsm6ds3h
-     * @comname Digital 3-axis Accelerometer and Gyroscope
-     * @type accelerometer gyro
-     * @man stmicro
-     * @con i2c spi gpio
-     * @web http://www.st.com/en/mems-and-sensors/lsm6ds3h.html
-     *
-     * @brief API for the LSM6DS3H 3-axis Accelerometer and Gyroscope
-     *
-     * The LSM6DS3H is a system-in-package featuring a 3D digital
-     * accelerometer and a 3D digital gyroscope performing at 1.1 mA
-     * (up to 1.6 kHz ODR) in high performance mode and enabling
-     * always-on low-power features for an optimal motion experience
-     * for the consumer.
-
-     * Not all functionality of this chip has been implemented in this
-     * driver, however all the pieces are present to add any desired
-     * functionality.  This driver supports both I2C (default) and SPI
-     * operation.
-     *
-     * @snippet lsm6ds3h.cxx Interesting
-     */
-
-    class LSM6DS3H {
-    public:
-
-        /**
-         * LSM6DS3H constructor.
-         *
-         * This device can support both I2C and SPI. For SPI, set the addr
-         * to -1, and specify a positive integer representing the Chip
-         * Select (CS) pin for the cs argument.  If you are using a
-         * hardware CS pin (like edison with arduino breakout), then you
-         * can connect the proper pin to the hardware CS pin on your MCU
-         * and supply -1 for cs.  The default operating mode is I2C.
-         *
-         * @param bus I2C or SPI bus to use
-         * @param addr The address for this device.  -1 for SPI
-         * @param cs The gpio pin to use for the SPI Chip Select.  -1 for
-         * I2C or for SPI with a hardware controlled pin.
-         * @throws std::runtime_error on initialization failure
-         */
-        LSM6DS3H(int bus=LSM6DS3H_DEFAULT_I2C_BUS,
-                 int addr=LSM6DS3H_DEFAULT_I2C_ADDR,
-                 int cs=-1);
-
-        /**
-         * LSM6DS3H destructor
-         */
-        virtual ~LSM6DS3H();
-
-        /**
-         * Update the internal stored values from sensor data
-         *
-         * @throws std::runtime_error on failure
-         */
-        void update();
-
-        /**
-         * Return the chip ID
-         *
-         * @return The chip ID
-         */
-        uint8_t getChipID();
-
-        /**
-         * Return accelerometer data in gravities.  update() must have
-         * been called prior to calling this method.
-         *
-         * @param x Pointer to a floating point value that will have the
-         * current x component placed into it
-         * @param y Pointer to a floating point value that will have the
-         * current y component placed into it
-         * @param z Pointer to a floating point value that will have the
-         * current z component placed into it
-         */
-        void getAccelerometer(float *x, float *y, float *z);
-
-        /**
-         * Return accelerometer data in gravities in the form of a
-         * floating point vector.  update() must have been called
-         * prior to calling this method.
-         *
-         * @return A floating point vector containing x, y, and z in
-         * that order
-         */
-        std::vector<float> getAccelerometer();
-
-        /**
-         * Return gyroscope data in degrees per second (DPS).
-         * update() must have been called prior to calling this
-         * method.
-         *
-         * @param x Pointer to a floating point value that will have the
-         * current x component placed into it
-         * @param y Pointer to a floating point value that will have the
-         * current y component placed into it
-         * @param z Pointer to a floating point value that will have the
-         * current z component placed into it
-         */
-        void getGyroscope(float *x, float *y, float *z);
-
-        /**
-         * Return gyroscope data in degrees per second in the form of
-         * a floating point vector.  update() must have been called
-         * prior to calling this method.
-         *
-         * @return A floating point vector containing x, y, and z in
-         * that order
-         */
-        std::vector<float> getGyroscope();
-
-        /**
-         * Return the current measured temperature.  Note, this is not
-         * ambient temperature.  update() must have been called prior to
-         * calling this method.
-         *
-         * @param fahrenheit true to return data in Fahrenheit, false for
-         * Celicus.  Celsius is the default.
-         * @return The temperature in degrees Celsius or Fahrenheit
-         */
-        float getTemperature(bool fahrenheit=false);
-
-        /**
-         * Initialize the device and start operation.  This function
-         * is called from the constructor, so it will not need to be
-         * called by a user unless the device is reset.  It sets the
-         * accelerometer and gyroscope ODR and FS modes, and enables
-         * BDU, register auto-increment, and high performance mode.
-         *
-         * @param acc_odr One of the LSM6DS3H_XL_ODR_T values
-         * @param acc_fs One of the LSM6DS3H_XL_FS_T values
-         * @param gyr_odr One of the LSM6DS3H_G_ODR_T values
-         * @param gyr_fs One of the LSM6DS3H_G_FS_T values
-         * @throws std::runtime_error on failure
-         */
-        void init(LSM6DS3H_XL_ODR_T acc_odr=LSM6DS3H_XL_ODR_104HZ,
-                  LSM6DS3H_XL_FS_T acc_fs=LSM6DS3H_XL_FS_2G,
-                  LSM6DS3H_G_ODR_T gyr_odr=LSM6DS3H_G_ODR_104HZ,
-                  LSM6DS3H_G_FS_T gyr_fs=LSM6DS3H_G_FS_245DPS);
-
-        /**
-         * Reset the device as if during a power on reset.  All configured
-         * values are lost when this happens.  You should call init()
-         * afterwards, or at least perform the same initialization init()
-         * does before continuing.
-         *
-         * @throws std::runtime_error on failure
-         */
-        void reset();
-
-        /**
-         * Set the output data rate (ODR) of the accelerometer
-         *
-         * @param odr One of the LSM6DS3H_XL_ODR_T values
-         * @throws std::runtime_error on failure
-         */
-        void setAccelerometerODR(LSM6DS3H_XL_ODR_T odr);
-
-        /**
-         * Set the full scale (FS) of the accelerometer.  This device
-         * supports a full scale of 2, 4, 8, and 16G.
-         *
-         * @param fs One of the LSM6DS3H_XL_FS_T values
-         * @throws std::runtime_error on failure
-         */
-        void setAccelerometerFullScale(LSM6DS3H_XL_FS_T fs);
-
-        /**
-         * Set the output data rate (ODR) of the gyroscope
-         *
-         * @param odr One of the LSM6DS3H_G_ODR_T values
-         * @throws std::runtime_error on failure
-         */
-        void setGyroscopeODR(LSM6DS3H_G_ODR_T odr);
-
-        /**
-         * Set the full scale (FS) of the gyroscope
-         *
-         * @param fs One of the LSM6DS3H_G_FS_T values
-         * @throws std::runtime_error on failure
-         */
-        void setGyroscopeFullScale(LSM6DS3H_G_FS_T fs);
-
-        /**
-         * Enable accelerometer and gyroscope high performance modes.
-         * These are further defined by the respective ODR settings to
-         * allow low power, and normal/high-performance modes.  This
-         * is enabled by default in init().
-         *
-         * @param enable true to enable high performance mode, false otherwise
-         * @throws std::runtime_error on failure
-         */
-        void setHighPerformance(bool enable);
-
-        /**
-         * Indicate whether the interrupt should be active high (default)
-         * or active low.  See the datasheet for details.
-         *
-         * @param high true for active high, false for active low
-         * @throws std::runtime_error on failure
-         */
-        void setInterruptActiveHigh(bool high);
-
-        /**
-         * Indicate whether interrupts are push-pull (default) or open
-         * drain.  See the datasheet for details.
-         *
-         * @param pp true for push-pull, false for open-drain
-         * @throws std::runtime_error on failure
-         */
-        void setInterruptPushPull(bool pp);
-
-        /**
-         * Return the contents of the status register
-         *
-         * @return A bitmask of values from LSM6DS3H_STATUS_BITS_T
-         */
-        uint8_t getStatus();
-
-        /**
-         * install an interrupt handler
-         *
-         * @param intr One of the LSM6DS3H_INTERRUPT_PINS_T values
-         * specifying which interrupt pin you are installing
-         * @param gpio GPIO pin to use as interrupt pin
-         * @param level The interrupt trigger level (one of mraa::Edge
-         * values).  Make sure that you have configured the interrupt pin
-         * properly for whatever level you choose.
-         * @param isr The interrupt handler, accepting a void * argument
-         * @param arg The argument to pass the the interrupt handler
-         * @throws std::runtime_error on failure
-         */
-        void installISR(LSM6DS3H_INTERRUPT_PINS_T intr, int gpio,
-                        mraa::Edge level,
-                        void (*isr)(void *), void *arg);
-
-        /**
-         * uninstall a previously installed interrupt handler
-         *
-         * @param intr One of the LSM6DS3H_INTERRUPT_PINS_T values
-         * specifying which interrupt pin you are removing
-         */
-        void uninstallISR(LSM6DS3H_INTERRUPT_PINS_T intr);
-
-        /**
-         * Read a register
-         *
-         * @param reg The register to read
-         * @return The value of the register
-         */
-        uint8_t readReg(uint8_t reg);
-
-        /**
-         * Read contiguous registers into a buffer
-         *
-         * @param buffer The buffer to store the results
-         * @param len The number of registers to read
-         * @return The number of bytes read
-         * @throws std::runtime_error on failure
-         */
-        int readRegs(uint8_t reg, uint8_t *buffer, int len);
-
-        /**
-         * Write to a register
-         *
-         * @param reg The register to write to
-         * @param val The value to write
-         * @throws std::runtime_error on failure
-         */
-        void writeReg(uint8_t reg, uint8_t val);
-
-    protected:
-        lsm6ds3h_context m_lsm6ds3h;
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        LSM6DS3H(const LSM6DS3H&) = delete;
-        LSM6DS3H &operator=(const LSM6DS3H&) = delete;
-
-    };
-}
diff --git a/src/lsm6ds3h/lsm6ds3h.i b/src/lsm6ds3h/lsm6ds3h.i
deleted file mode 100644
index 263b4a4..0000000
--- a/src/lsm6ds3h/lsm6ds3h.i
+++ /dev/null
@@ -1,28 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "../upm_vectortypes.i"
-
-%ignore getAccelerometer(float *, float *, float *);
-%ignore getGyroscope(float *, float *, float *);
-
-%ignore installISR(LSM6DS3H_INTERRUPT_PINS_T , int ,  mraa::Edge ,  void *, void *);
-
-%define INTERRUPT LSM6DS3H_INTERRUPT_PINS_T
-%enddef
-
-JAVA_ADD_INSTALLISR_INTERRUPT(upm::LSM6DS3H)
-JAVA_JNI_LOADLIBRARY(javaupm_lsm6ds3h)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%include "../upm_vectortypes.i"
-%{
-#include "lsm6ds3h_defs.h"
-#include "lsm6ds3h.hpp"
-%}
-%include "lsm6ds3h_defs.h"
-%include "lsm6ds3h.hpp"
-/* END Common SWIG syntax */
diff --git a/src/lsm6ds3h/lsm6ds3h.json b/src/lsm6ds3h/lsm6ds3h.json
deleted file mode 100644
index 49f35af..0000000
--- a/src/lsm6ds3h/lsm6ds3h.json
+++ /dev/null
@@ -1,39 +0,0 @@
-{
-    "Library": "lsm6ds3h",
-    "Description": "API for the LSM6DS3H 3-axis Accelerometer and Gyroscope",
-    "Sensor Class":
-    {
-        "LSM6DS3H":
-        {
-            "Name": "Digital 3-axis Accelerometer and Gyroscope",
-            "Description": "The LSM6DS3H is a system-in-package featuring a 3D digital accelerometer and a 3D digital gyroscope performing at 1.1 mA (up to 1.6 kHz ODR) in high performance mode and enabling always-on low-power features for an optimal motion experience for the consumer. Not all functionality of this chip has been implemented in this driver, however all the pieces are present to add any desired functionality.  This driver supports both I2C (default) and SPI operation.",
-            "Aliases": ["lsm6ds3h"],
-            "Categories": ["accelerometer", "gyroscope"],
-            "Connections": ["i2c", "spi", "gpio"],
-            "Project Type": ["imu", "prototyping"],
-            "Manufacturers": ["stmicro"],
-            "Kits": [],
-            "Examples":
-            {
-                "Java": ["LSM6DS3H_Example.java"],
-                "Python": ["lsm6ds3h.py"],
-                "Node.js": ["lsm6ds3h.js"],
-                "C++": ["lsm6ds3h.cxx"],
-                "C": ["lsm6ds3h.c"]
-            },
-            "Specifications":
-            {
-                "Operating Voltage": {"unit": "V", "low": 1.71, "high": 3.6},
-                "Operating Current": {"unit": "mA", "low": 0.85, "high": 1.1},
-                "Operating Temperature": {"unit": "degC", "low": -40, "high": 85}
-
-            },
-            "Urls" :
-            {
-                "Product Pages": ["http://www.st.com/en/mems-and-sensors/lsm6ds3h.html"],
-                "Datasheets": ["http://www.st.com/content/ccc/resource/technical/document/datasheet/group0/38/96/79/af/ab/62/42/c3/DM00229854/files/DM00229854.pdf/jcr:content/translations/en.DM00229854.pdf"],
-                "Schematics": []
-            }
-        }
-    }
-}
diff --git a/src/lsm6ds3h/lsm6ds3h_defs.h b/src/lsm6ds3h/lsm6ds3h_defs.h
deleted file mode 100644
index 1e92e39..0000000
--- a/src/lsm6ds3h/lsm6ds3h_defs.h
+++ /dev/null
@@ -1,644 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#define LSM6DS3H_DEFAULT_I2C_BUS 0
-#define LSM6DS3H_DEFAULT_SPI_BUS 0
-#define LSM6DS3H_DEFAULT_I2C_ADDR 0x6a
-
-#define LSM6DS3H_CHIPID 0x69
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    // NOTE: Reserved registers must not be written into or permanent
-    // damage can result.  Reading from them may return indeterminate
-    // values.  Registers containing reserved bitfields must be
-    // written as 0.
-
-    // This register map is not complete -- all registers are
-    // enumerated, however not all register bitmaps are enumerated
-    // here.  Feel free to add any you need that are missing.
-
-    /**
-     * LSM6DS3H registers
-     */
-    typedef enum {
-        // 0x00 reserved
-
-        LSM6DS3H_REG_FUNC_CFG_ACCESS              = 0x01,
-
-        // 0x02-0x03 reserved
-
-        LSM6DS3H_REG_SENSOR_SYNC_TIME_FRAME       = 0x04,
-
-        // 0x05 reserved
-
-        LSM6DS3H_REG_FIFO_CTRL1                   = 0x06,
-        LSM6DS3H_REG_FIFO_CTRL2                   = 0x07,
-        LSM6DS3H_REG_FIFO_CTRL3                   = 0x08,
-        LSM6DS3H_REG_FIFO_CTRL4                   = 0x09,
-        LSM6DS3H_REG_FIFO_CTRL5                   = 0x0a,
-
-        LSM6DS3H_REG_ORIENT_CFG_G                 = 0x0b,
-
-        // 0x0c reserved
-
-        LSM6DS3H_REG_INT1_CTRL                    = 0x0d,
-        LSM6DS3H_REG_INT2_CTRL                    = 0x0e,
-
-        LSM6DS3H_REG_WHO_AM_I                     = 0x0f,
-
-        LSM6DS3H_REG_CTRL1_XL                     = 0x10,
-        LSM6DS3H_REG_CTRL2_G                      = 0x11,
-        LSM6DS3H_REG_CTRL3_C                      = 0x12,
-        LSM6DS3H_REG_CTRL4_C                      = 0x13,
-        LSM6DS3H_REG_CTRL5_C                      = 0x14,
-        LSM6DS3H_REG_CTRL6_C                      = 0x15,
-        LSM6DS3H_REG_CTRL7_G                      = 0x16,
-        LSM6DS3H_REG_CTRL8_XL                     = 0x17,
-        LSM6DS3H_REG_CTRL9_XL                     = 0x18,
-        LSM6DS3H_REG_CTRL10_C                     = 0x19,
-
-        LSM6DS3H_REG_MASTER_CFG                   = 0x1a,
-        LSM6DS3H_REG_WAKE_UP_SRC                  = 0x1b,
-        LSM6DS3H_REG_TAP_SRC                      = 0x1c,
-        LSM6DS3H_REG_TAP_D6D                      = 0x1d,
-
-        // also STATUS_SPIAux
-        LSM6DS3H_REG_STATUS                       = 0x1e,
-
-        // 0x1f reserved
-
-        LSM6DS3H_REG_OUT_TEMP_L                   = 0x20,
-        LSM6DS3H_REG_OUT_TEMP_H                   = 0x21,
-
-        LSM6DS3H_REG_OUTX_L_G                     = 0x22,
-        LSM6DS3H_REG_OUTX_H_G                     = 0x23,
-        LSM6DS3H_REG_OUTY_L_G                     = 0x24,
-        LSM6DS3H_REG_OUTY_H_G                     = 0x25,
-        LSM6DS3H_REG_OUTZ_L_G                     = 0x26,
-        LSM6DS3H_REG_OUTZ_H_G                     = 0x27,
-
-        LSM6DS3H_REG_OUTX_L_XL                    = 0x28,
-        LSM6DS3H_REG_OUTX_H_XL                    = 0x29,
-        LSM6DS3H_REG_OUTY_L_XL                    = 0x2a,
-        LSM6DS3H_REG_OUTY_H_XL                    = 0x2b,
-        LSM6DS3H_REG_OUTZ_L_XL                    = 0x2c,
-        LSM6DS3H_REG_OUTZ_H_XL                    = 0x2d,
-
-        LSM6DS3H_REG_SENSORHUB1_REG               = 0x2e,
-        LSM6DS3H_REG_SENSORHUB2_REG               = 0x2f,
-        LSM6DS3H_REG_SENSORHUB3_REG               = 0x30,
-        LSM6DS3H_REG_SENSORHUB4_REG               = 0x31,
-        LSM6DS3H_REG_SENSORHUB5_REG               = 0x32,
-        LSM6DS3H_REG_SENSORHUB6_REG               = 0x33,
-        LSM6DS3H_REG_SENSORHUB7_REG               = 0x34,
-        LSM6DS3H_REG_SENSORHUB8_REG               = 0x35,
-        LSM6DS3H_REG_SENSORHUB9_REG               = 0x36,
-        LSM6DS3H_REG_SENSORHUB10_REG              = 0x37,
-        LSM6DS3H_REG_SENSORHUB11_REG              = 0x38,
-        LSM6DS3H_REG_SENSORHUB12_REG              = 0x39,
-
-        LSM6DS3H_REG_FIFO_STATUS1                 = 0x3a,
-        LSM6DS3H_REG_FIFO_STATUS2                 = 0x3b,
-        LSM6DS3H_REG_FIFO_STATUS3                 = 0x3c,
-        LSM6DS3H_REG_FIFO_STATUS4                 = 0x3d,
-
-        LSM6DS3H_REG_FIFO_DATA_OUT_L              = 0x3e,
-        LSM6DS3H_REG_FIFO_DATA_OUT_H              = 0x3f,
-
-        LSM6DS3H_REG_TIMESTAMP0_REG               = 0x40,
-        LSM6DS3H_REG_TIMESTAMP1_REG               = 0x41,
-        LSM6DS3H_REG_TIMESTAMP2_REG               = 0x42,
-
-        // 0x43-0x48 reserved
-
-        LSM6DS3H_REG_STEP_TIMESTAMP_L             = 0x49,
-        LSM6DS3H_REG_STEP_TIMESTAMP_H             = 0x4a,
-
-        LSM6DS3H_REG_STEP_COUNTER_L               = 0x4b,
-        LSM6DS3H_REG_STEP_COUNTER_H               = 0x4c,
-
-        LSM6DS3H_REG_SENSORHUB13_REG              = 0x4d,
-        LSM6DS3H_REG_SENSORHUB14_REG              = 0x4e,
-        LSM6DS3H_REG_SENSORHUB15_REG              = 0x4f,
-        LSM6DS3H_REG_SENSORHUB16_REG              = 0x50,
-        LSM6DS3H_REG_SENSORHUB17_REG              = 0x51,
-        LSM6DS3H_REG_SENSORHUB18_REG              = 0x52,
-
-        LSM6DS3H_REG_FUNC_SRC                     = 0x53,
-
-        // 0x54-0x57 reserved
-
-        LSM6DS3H_REG_TAP_CFG                      = 0x58,
-        LSM6DS3H_REG_TAP_THS_6D                   = 0x59,
-
-        // where is int_dur1?
-        LSM6DS3H_REG_INT_DUR2                     = 0x5a,
-
-        LSM6DS3H_REG_WAKE_UP_THS                  = 0x5b,
-        LSM6DS3H_REG_WAKE_UP_DUR                  = 0x5c,
-
-        LSM6DS3H_REG_FREE_FALL                    = 0x5d,
-
-        LSM6DS3H_REG_MD1_CFG                      = 0x5e,
-        LSM6DS3H_REG_MD2_CFG                      = 0x5f,
-
-        // 0x60-0x65 reserved
-
-        LSM6DS3H_REG_OUT_MAG_RAW_X_L              = 0x66,
-        LSM6DS3H_REG_OUT_MAG_RAW_X_H              = 0x67,
-        LSM6DS3H_REG_OUT_MAG_RAW_Y_L              = 0x68,
-        LSM6DS3H_REG_OUT_MAG_RAW_Y_H              = 0x69,
-        LSM6DS3H_REG_OUT_MAG_RAW_Z_L              = 0x6a,
-        LSM6DS3H_REG_OUT_MAG_RAW_Z_H              = 0x6b,
-
-        // 0x6c-0x6f assume reserved, but not listed in DS
-
-        LSM6DS3H_REG_CTRL_SPIAUX                  = 0x70,
-    } LSM6DS3H_REGS_T;
-
-    /**
-     * REG_FUNC_CFG_ACCESS bits
-     */
-    typedef enum {
-        // 0x00 - 0x40 reserved
-        LSM6DS3H_FUNC_CFG_EN                      = 0x80,
-    } LSM6DS3H_FUNC_CFG_ACCESS_BITS_T;
-
-    /**
-     * REG_ORIENT_CFG_G bits
-     */
-    typedef enum {
-        // 0x00 - 0x40 reserved
-        LSM6DS3H_ORIENT_CFG_G_ORIENT0             = 0x01,
-        LSM6DS3H_ORIENT_CFG_G_ORIENT1             = 0x02,
-        LSM6DS3H_ORIENT_CFG_G_ORIENT2             = 0x04,
-        _LSM6DS3H_ORIENT_CFG_G_ORIENT_MASK        = 7,
-        _LSM6DS3H_ORIENT_CFG_G_ORIENT_SHIFT       = 0,
-
-        LSM6DS3H_ORIENT_CFG_G_SIGNZ               = 0x08,
-        LSM6DS3H_ORIENT_CFG_G_SIGNY               = 0x10,
-        LSM6DS3H_ORIENT_CFG_G_SIGNX               = 0x20,
-
-        // 0x40-0x80 reserved
-    } LSM6DS3H_ORIENT_CFG_G_BITS_T;
-
-    /**
-     * ORIENT_CFG_G_ORIENT values
-     */
-    typedef enum {
-        LSM6DS3H_ORIENT_CFG_G_XYZ                 = 0,
-        LSM6DS3H_ORIENT_CFG_G_XZY                 = 1,
-        LSM6DS3H_ORIENT_CFG_G_YXZ                 = 2,
-        LSM6DS3H_ORIENT_CFG_G_YZX                 = 3,
-        LSM6DS3H_ORIENT_CFG_G_ZXY                 = 4,
-        LSM6DS3H_ORIENT_CFG_G_ZYX                 = 5,
-    } LSM6DS3H_ORIENT_G_ORIENT_T;
-
-    /**
-     * REG_INT1_CTRL bits
-     */
-    typedef enum {
-        LSM6DS3H_INT1_CTRL_DRDY_XL                = 0x01,
-        LSM6DS3H_INT1_CTRL_DRDY_G                 = 0x02,
-        LSM6DS3H_INT1_CTRL_BOOT                   = 0x04,
-        LSM6DS3H_INT1_CTRL_FTH                    = 0x08,
-        LSM6DS3H_INT1_CTRL_FIFO_OVR               = 0x10,
-        LSM6DS3H_INT1_CTRL_FULL_FLAG              = 0x20,
-        LSM6DS3H_INT1_CTRL_SIGN_MOT               = 0x40,
-        LSM6DS3H_INT1_CTRL_STEP_DETECTOR          = 0x80,
-    } LSM6DS3H_INT1_CTRL_BITS_T;
-
-    /**
-     * REG_INT2_CTRL bits
-     */
-    typedef enum {
-        LSM6DS3H_INT2_CTRL_DRDY_XL                = 0x01,
-        LSM6DS3H_INT2_CTRL_DRDY_G                 = 0x02,
-        LSM6DS3H_INT2_CTRL_DRDY_TEMP              = 0x04,
-        LSM6DS3H_INT2_CTRL_FTH                    = 0x08,
-        LSM6DS3H_INT2_CTRL_FIFO_OVR               = 0x10,
-        LSM6DS3H_INT2_CTRL_FULL_FLAG              = 0x20,
-        LSM6DS3H_INT2_CTRL_COUNT_OV               = 0x40,
-        LSM6DS3H_INT2_CTRL_STEP_DELTA             = 0x80,
-    } LSM6DS3H_INT2_CTRL_BITS_T;
-
-    /**
-     * REG_CTRL1_XL (accelerometer) bits
-     */
-    typedef enum {
-        LSM6DS3H_CTRL1_XL_BW0                     = 0x01,
-        LSM6DS3H_CTRL1_XL_BW1                     = 0x02,
-        _LSM6DS3H_CTRL1_XL_BW_MASK                = 3,
-        _LSM6DS3H_CTRL1_XL_BW_SHIFT               = 0,
-
-        LSM6DS3H_CTRL1_XL_FS0                     = 0x04,
-        LSM6DS3H_CTRL1_XL_FS1                     = 0x08,
-        _LSM6DS3H_CTRL1_XL_FS_MASK                = 3,
-        _LSM6DS3H_CTRL1_XL_FS_SHIFT               = 2,
-
-        LSM6DS3H_CTRL1_XL_ODR0                    = 0x10,
-        LSM6DS3H_CTRL1_XL_ODR1                    = 0x20,
-        LSM6DS3H_CTRL1_XL_ODR2                    = 0x40,
-        LSM6DS3H_CTRL1_XL_ODR3                    = 0x80,
-        _LSM6DS3H_CTRL1_XL_ODR_MASK               = 15,
-        _LSM6DS3H_CTRL1_XL_ODR_SHIFT              = 4,
-    } LSM6DS3H_CTRL1_XL_BITS_T;
-
-    /**
-     * CTRL1_XL_BW values (anti-aliasing filter bw)
-     */
-    typedef enum {
-        LSM6DS3H_XL_BW_400HZ                      = 0,
-        LSM6DS3H_XL_BW_200HZ                      = 1,
-        LSM6DS3H_XL_BW_100HZ                      = 2,
-        LSM6DS3H_XL_BW_50HZ                       = 3,
-    } LSM6DS3H_XL_BW_T;
-
-    /**
-     * CTRL1_XL_FS values (full scale)
-     */
-    typedef enum {
-        LSM6DS3H_XL_FS_2G                         = 0,
-        LSM6DS3H_XL_FS_16G                        = 1,
-        LSM6DS3H_XL_FS_4G                         = 2,
-        LSM6DS3H_XL_FS_8G                         = 3,
-    } LSM6DS3H_XL_FS_T;
-
-    /**
-     * CTRL1_XL_ODR values (output data rate)
-     */
-    typedef enum {
-        LSM6DS3H_XL_ODR_POWER_DOWN                = 0,
-        LSM6DS3H_XL_ODR_12_5HZ                    = 1,
-        LSM6DS3H_XL_ODR_26HZ                      = 2,
-        LSM6DS3H_XL_ODR_52HZ                      = 3,
-        LSM6DS3H_XL_ODR_104HZ                     = 4,
-        LSM6DS3H_XL_ODR_208HZ                     = 5,
-        LSM6DS3H_XL_ODR_416HZ                     = 6,
-        LSM6DS3H_XL_ODR_833HZ                     = 7,
-        LSM6DS3H_XL_ODR_1_66KHZ                   = 8,
-        LSM6DS3H_XL_ODR_3_33KHZ                   = 9,
-        LSM6DS3H_XL_ODR_6_66KHZ                   = 10,
-    } LSM6DS3H_XL_ODR_T;
-
-    /**
-     * REG_CTRL2_G (gyroscope) bits
-     */
-    typedef enum {
-        // 0x01 reserved
-
-        LSM6DS3H_CTRL2_G_FS_125                   = 0x02,
-
-        LSM6DS3H_CTRL2_G_FS0                      = 0x04,
-        LSM6DS3H_CTRL2_G_FS1                      = 0x08,
-        _LSM6DS3H_CTRL2_G_FS_MASK                 = 3,
-        _LSM6DS3H_CTRL2_G_FS_SHIFT                = 2,
-
-        LSM6DS3H_CTRL2_G_ODR0                     = 0x10,
-        LSM6DS3H_CTRL2_G_ODR1                     = 0x20,
-        LSM6DS3H_CTRL2_G_ODR2                     = 0x40,
-        LSM6DS3H_CTRL2_G_ODR3                     = 0x80,
-        _LSM6DS3H_CTRL2_G_ODR_MASK                = 0x15,
-        _LSM6DS3H_CTRL2_G_ODR_SHIFT               = 0x4,
-    } LSM6DS3H_CTRL2_G_BITS_T;
-
-    /**
-     * CTRL2_G_FS values (full scale)
-     */
-    typedef enum {
-        LSM6DS3H_G_FS_245DPS                      = 0, // degrees per second
-        LSM6DS3H_G_FS_500DPS                      = 1,
-        LSM6DS3H_G_FS_1000DPS                     = 2,
-        LSM6DS3H_G_FS_2000DPS                     = 3,
-
-        // 125dps is a special case - it's just a bit you set or clear
-        // to enable 125 or disable it.  We add a virtual bit 3 (4)
-        // here as a flag to the driver to enable/disable this
-        // "special" FS setting.
-        LSM6DS3H_G_FS_125DPS                      = (4 + 0),
-    } LSM6DS3H_G_FS_T;
-
-    /**
-     * CTRL2_G_ODR values (output data rate)
-     */
-    typedef enum {
-        LSM6DS3H_G_ODR_POWER_DOWN                 = 0,
-        LSM6DS3H_G_ODR_12_5HZ                     = 1,
-        LSM6DS3H_G_ODR_26HZ                       = 2,
-        LSM6DS3H_G_ODR_52HZ                       = 3,
-        LSM6DS3H_G_ODR_104HZ                      = 4,
-        LSM6DS3H_G_ODR_208HZ                      = 5,
-        LSM6DS3H_G_ODR_416HZ                      = 6,
-        LSM6DS3H_G_ODR_833HZ                      = 7,
-        LSM6DS3H_G_ODR_1_66KHZ                    = 8,
-    } LSM6DS3H_G_ODR_T;
-
-    /**
-     * REG_CTRL3 (_C, common) bits
-     */
-    typedef enum {
-        LSM6DS3H_CTRL3_SW_RESET                   = 0x01,
-        LSM6DS3H_CTRL3_BLE                        = 0x02,
-        LSM6DS3H_CTRL3_IF_INC                     = 0x04,
-        LSM6DS3H_CTRL3_SIM                        = 0x08,
-        LSM6DS3H_CTRL3_PP_OD                      = 0x10,
-        LSM6DS3H_CTRL3_H_LACTIVE                  = 0x20,
-        LSM6DS3H_CTRL3_BDU                        = 0x40,
-        LSM6DS3H_CTRL3_BOOT                       = 0x80,
-    } LSM6DS3H_CTRL3_BITS_T;
-
-    /**
-     * REG_CTRL4 (_C, common) bits
-     */
-    typedef enum {
-        LSM6DS3H_CTRL4_STOP_ON_FTH                = 0x01,
-        LSM6DS3H_CTRL4_3_3KHZ_ODR                 = 0x02,
-        LSM6DS3H_CTRL4_I2C_DISABLE                = 0x04,
-        LSM6DS3H_CTRL4_DRDY_MASK                  = 0x08,
-        LSM6DS3H_CTRL4_FIFO_TEMP_EN               = 0x10,
-        LSM6DS3H_CTRL4_INT2_ON_INT1               = 0x20,
-        LSM6DS3H_CTRL4_SLEEP_G                    = 0x40,
-        LSM6DS3H_CTRL4_XL_BW_SCAL_ODR             = 0x80,
-    } LSM6DS3H_CTRL4_BITS_T;
-
-    /**
-     * REG_CTRL5 (_C, common) bits
-     */
-    typedef enum {
-        LSM6DS3H_CTRL5_ST_XL0                     = 0x01,
-        LSM6DS3H_CTRL5_ST_XL1                     = 0x02,
-        _LSM6DS3H_CTRL5_ST_XL_MASK                = 3,
-        _LSM6DS3H_CTRL5_ST_XL_SHIFT               = 0,
-
-        LSM6DS3H_CTRL5_ST_G0                      = 0x04,
-        LSM6DS3H_CTRL5_ST_G1                      = 0x08,
-        _LSM6DS3H_CTRL5_ST_G_MASK                 = 3,
-        _LSM6DS3H_CTRL5_ST_G_SHIFT                = 2,
-
-        // 0x10 reserved
-
-        LSM6DS3H_CTRL5_ROUNDING0                  = 0x20,
-        LSM6DS3H_CTRL5_ROUNDING1                  = 0x40,
-        LSM6DS3H_CTRL5_ROUNDING2                  = 0x80,
-        _LSM6DS3H_CTRL5_ROUNDING_MASK             = 7,
-        _LSM6DS3H_CTRL5_ROUNDING_SHIFT            = 5,
-    } LSM6DS3H_CTRL5_BITS_T;
-
-    /**
-     * CTRL5_ST_XL values (self test accelerometer)
-     */
-    typedef enum {
-        LSM6DS3H_ST_XL_NORMAL                     = 0,
-        LSM6DS3H_ST_XL_POSITIVE                   = 1,
-        LSM6DS3H_ST_XL_NEGATIVE                   = 2,
-    } LSM6DS3H_ST_XL_T;
-
-    /**
-     * CTRL5_ST_G values (self test gyroscope)
-     */
-    typedef enum {
-        LSM6DS3H_ST_G_NORMAL                     = 0,
-        LSM6DS3H_ST_G_POSITIVE                   = 1,
-        LSM6DS3H_ST_G_NEGATIVE                   = 3,
-    } LSM6DS3H_ST_G_T;
-
-    /**
-     * REG_CTRL6 (_C, common) bits
-     */
-    typedef enum {
-        // 0x01-0x08 reserved
-        LSM6DS3H_CTRL6_XL_HM_MODE                = 0x10,
-        LSM6DS3H_CTRL6_LVL2_EN                   = 0x20,
-        LSM6DS3H_CTRL6_LVLEN                     = 0x40,
-        LSM6DS3H_CTRL6_TRIG_EN                   = 0x80,
-    } LSM6DS3H_CTRL6_BITS_T;
-
-    /**
-     * REG_CTRL7_G bits
-     */
-    typedef enum {
-        // 0x01-0x02 reserved
-        LSM6DS3H_CTRL7_G_ROUNDING_STATUS         = 0x04,
-        LSM6DS3H_CTRL7_G_HP_RST                  = 0x08,
-
-        LSM6DS3H_CTRL7_G_HPCF0                   = 0x10,
-        LSM6DS3H_CTRL7_G_HPCF1                   = 0x20,
-        _LSM6DS3H_CTRL7_G_HPCF_MASK              = 3,
-        _LSM6DS3H_CTRL7_G_HPCF_SHIFT             = 4,
-
-        LSM6DS3H_CTRL7_G_HP_EN                   = 0x40,
-        LSM6DS3H_CTRL7_G_HM_MODE                 = 0x80,
-    } LSM6DS3H_CTRL7_G_BITS_T;
-
-    /**
-     * CTRL7_G_HPCF values (high pass cutoff, in high performance mode only)
-     */
-    typedef enum {
-        LSM6DS3H_G_HPCF_0_0081HZ                 = 0, // 0.0081hz
-        LSM6DS3H_G_HPCF_0_0324HZ                 = 1,
-        LSM6DS3H_G_HPCF_2_07HZ                   = 2,
-        LSM6DS3H_G_HPCF_16_32HZ                  = 3,
-    } LSM6DS3H_G_HPCF_T;
-
-    /**
-     * REG_CTRL8_XL bits
-     */
-    typedef enum {
-        LSM6DS3H_CTRL8_XL_LOW_PASS_ON_6D         = 0x01,
-
-        // 0x02 reserved
-
-        LSM6DS3H_CTRL8_XL_HP_SLOPE_EN            = 0x04,
-
-        // 0x08-0x10 reserved
-
-        LSM6DS3H_CTRL8_XL_HPCF0                  = 0x20,
-        LSM6DS3H_CTRL8_XL_HPCF1                  = 0x40,
-        _LSM6DS3H_CTRL8_XL_HPCF_MASK             = 3,
-        _LSM6DS3H_CTRL8_XL_HPCF_SHIFT            = 5,
-
-        LSM6DS3H_CTRL8_XL_LPF2_EN                = 0x80,
-    } LSM6DS3H_CTRL8_XL_BITS_T;
-
-    /**
-     * REG_CTRL9_XL bits
-     */
-    typedef enum {
-        // 0x01-0x02 reserved
-
-        LSM6DS3H_CTRL9_XL_SOFT_EN                = 0x04,
-        LSM6DS3H_CTRL9_XL_XEN                    = 0x08,
-        LSM6DS3H_CTRL9_XL_YEN                    = 0x10,
-        LSM6DS3H_CTRL9_XL_ZEN                    = 0x20,
-
-        // 0x40-0x80 reserved
-    } LSM6DS3H_CTRL9_XL_BITS_T;
-
-    /**
-     * REG_CTRL10_C bits
-     */
-    typedef enum {
-        LSM6DS3H_CTRL10_C_SIGN_MOT_EN            = 0x01,
-        LSM6DS3H_CTRL10_C_PEDO_RST_STEP          = 0x02,
-        LSM6DS3H_CTRL10_C_FUNC_EN                = 0x04,
-        LSM6DS3H_CTRL10_C_XEN                    = 0x08,
-        LSM6DS3H_CTRL10_C_YEN                    = 0x10,
-        LSM6DS3H_CTRL10_C_ZEN                    = 0x20,
-
-        // 0x40-0x80 reserved
-    } LSM6DS3H_CTRL10_C_BITS_T;
-
-    /**
-     * REG_MASTER_CONFIG bits
-     */
-    typedef enum {
-        LSM6DS3H_MASTER_CONFIG_MASTER_ON         = 0x01,
-        LSM6DS3H_MASTER_CONFIG_IRON_EN           = 0x02,
-        LSM6DS3H_MASTER_CONFIG_PASS_THROUGH_MODE = 0x04,
-        LSM6DS3H_MASTER_CONFIG_PULL_UP_EN        = 0x08,
-        LSM6DS3H_MASTER_CONFIG_START_CONFIG      = 0x10,
-
-        // 0x20 reserved
-
-        LSM6DS3H_MASTER_CONFIG_DATA_VALID_SEL_FIFO = 0x40,
-        LSM6DS3H_MASTER_CONFIG_DRDY_ON_INT1      = 0x80,
-    } LSM6DS3H_MASTER_CONFIG_BITS_T;
-
-    /**
-     * REG_WAKE_UP_SRC bits
-     */
-    typedef enum {
-        LSM6DS3H_WAKE_UP_SRC_Z_WU                = 0x01,
-        LSM6DS3H_WAKE_UP_SRC_Y_WU                = 0x02,
-        LSM6DS3H_WAKE_UP_SRC_X_WU                = 0x04,
-        LSM6DS3H_WAKE_UP_SRC_WU_IA               = 0x08,
-        LSM6DS3H_WAKE_UP_SRC_SLEEP_STATE_IA      = 0x10,
-        LSM6DS3H_WAKE_UP_SRC_FF_AA               = 0x20,
-
-        // 0x40-0x80 reserved
-    } LSM6DS3H_WAKE_UP_SRC_BITS_T;
-
-    /**
-     * REG_TAP_SRC bits
-     */
-    typedef enum {
-        LSM6DS3H_TAP_SRC_Z_TAP                   = 0x01,
-        LSM6DS3H_TAP_SRC_Y_TAP                   = 0x02,
-        LSM6DS3H_TAP_SRC_X_TAP                   = 0x04,
-        LSM6DS3H_TAP_SRC_TAP_SIGN                = 0x08,
-        LSM6DS3H_TAP_SRC_DOUBLE_TAP              = 0x10,
-        LSM6DS3H_TAP_SRC_SINGLE_TAP              = 0x20,
-        LSM6DS3H_TAP_SRC_TAP_IA                  = 0x40,
-
-        // 0x80 reserved
-    } LSM6DS3H_TAP_SRC_BITS_T;
-
-    /**
-     * REG_D6D_SRC bits
-     */
-    typedef enum {
-        LSM6DS3H_D6D_SRC_XL                      = 0x01,
-        LSM6DS3H_D6D_SRC_XH                      = 0x02,
-        LSM6DS3H_D6D_SRC_YL                      = 0x04,
-        LSM6DS3H_D6D_SRC_YH                      = 0x08,
-        LSM6DS3H_D6D_SRC_ZL                      = 0x10,
-        LSM6DS3H_D6D_SRC_ZH                      = 0x20,
-        LSM6DS3H_D6D_SRC_D6D_IA                  = 0x40,
-
-        // 0x80 reserved
-    } LSM6DS3H_D6D_SRC_BITS_T;
-
-    /**
-     * REG_STATUS bits
-     */
-    typedef enum {
-        LSM6DS3H_STATUS_XLDA                     = 0x01, // acc data avail
-        LSM6DS3H_STATUS_GDA                      = 0x02, // gyr data avail
-        LSM6DS3H_STATUS_TDA                      = 0x04, // temp data avail
-
-        // 0x08-0x80 reserved
-    } LSM6DS3H_STATUS_BITS_T;
-
-    /**
-     * REG_FUNC_SRC bits
-     */
-    typedef enum {
-        LSM6DS3H_FUNC_SRC_SENSORHUB_END_OP       = 0x01,
-        LSM6DS3H_FUNC_SRC_SI_END_OP              = 0x02,
-
-        // 0x04 reserved
-
-        LSM6DS3H_FUNC_SRC_STEP_OVERFLOW          = 0x08,
-        LSM6DS3H_FUNC_SRC_STEP_DETECTED          = 0x10,
-        LSM6DS3H_FUNC_SRC_TILT_IA                = 0x20,
-        LSM6DS3H_FUNC_SRC_SIGN_MOTION_IA         = 0x40,
-        LSM6DS3H_FUNC_SRC_STEP_COUNT_DELTA_IA    = 0x80,
-    } LSM6DS3H_FUNC_SRC_BITS_T;
-
-    /**
-     * REG_MD1_CFG bits (function routing to INT1).  We are omitting
-     * the "INT1" redundancy in these item names.
-     */
-    typedef enum {
-        LSM6DS3H_MD1_CFG_TIMER                   = 0x01,
-        LSM6DS3H_MD1_CFG_TILT                    = 0x02,
-        LSM6DS3H_MD1_CFG_6D                      = 0x04,
-        LSM6DS3H_MD1_CFG_DOUBLE_TAP              = 0x08,
-        LSM6DS3H_MD1_CFG_FF                      = 0x10,
-        LSM6DS3H_MD1_CFG_WU                      = 0x20,
-        LSM6DS3H_MD1_CFG_SINGLE_TAP              = 0x40,
-        LSM6DS3H_MD1_CFG_INACT_STATE             = 0x80,
-    } LSM6DS3H_MD1_CFG_BITS_T;
-
-    /**
-     * REG_MD2_CFG bits (function routing to INT2).  We are omitting
-     * the "INT2" redundancy in these item names.
-     */
-    typedef enum {
-        LSM6DS3H_MD2_CFG_IRON                    = 0x01,
-        LSM6DS3H_MD2_CFG_TILT                    = 0x02,
-        LSM6DS3H_MD2_CFG_6D                      = 0x04,
-        LSM6DS3H_MD2_CFG_DOUBLE_TAP              = 0x08,
-        LSM6DS3H_MD2_CFG_FF                      = 0x10,
-        LSM6DS3H_MD2_CFG_WU                      = 0x20,
-        LSM6DS3H_MD2_CFG_SINGLE_TAP              = 0x40,
-        LSM6DS3H_MD2_CFG_INACT_STATE             = 0x80,
-    } LSM6DS3H_MD2_CFG_BITS_T;
-
-    // interrupt selection for installISR() and uninstallISR()
-    typedef enum {
-        LSM6DS3H_INTERRUPT_INT1,
-        LSM6DS3H_INTERRUPT_INT2
-    } LSM6DS3H_INTERRUPT_PINS_T;
-
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/lsm6ds3h/lsm6ds3h_fti.c b/src/lsm6ds3h/lsm6ds3h_fti.c
deleted file mode 100644
index 78d8d48..0000000
--- a/src/lsm6ds3h/lsm6ds3h_fti.c
+++ /dev/null
@@ -1,127 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * The MIT License
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "lsm6ds3h.h"
-#include "upm_fti.h"
-
-/**
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_lsm6ds3h_name[] = "LSM6DS3H";
-const char upm_lsm6ds3h_description[] =
-    "Triple Axis Digital Accelerometer and Gyroscope";
-const upm_protocol_t upm_lsm6ds3h_protocol[] = {UPM_I2C, UPM_SPI, UPM_GPIO};
-const upm_sensor_t upm_lsm6ds3h_category[] = {UPM_ACCELEROMETER,
-                                              UPM_GYROSCOPE};
-
-// forward declarations
-const void *upm_lsm6ds3h_get_ft(upm_sensor_t sensor_type);
-void *upm_lsm6ds3h_init_name();
-void upm_lsm6ds3h_close(void *dev);
-upm_result_t upm_lsm6ds3h_get_acc_value(void *dev, float *value,
-                                    upm_acceleration_u unit);
-upm_result_t upm_lsm6ds3h_get_gyr_value(void *dev, float *value);
-
-const upm_sensor_descriptor_t upm_lsm6ds3h_get_descriptor()
-{
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_lsm6ds3h_name;
-    usd.description = upm_lsm6ds3h_description;
-    usd.protocol_size = 3;
-    usd.protocol = upm_lsm6ds3h_protocol;
-    usd.category_size = 2;
-    usd.category = upm_lsm6ds3h_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = upm_lsm6ds3h_init_name,
-    .upm_sensor_close = upm_lsm6ds3h_close,
-};
-
-static const upm_acceleration_ft aft =
-{
-    .upm_acceleration_get_value = upm_lsm6ds3h_get_acc_value
-};
-
-static const upm_gyroscope_ft gft =
-{
-    .upm_gyroscope_get_value = upm_lsm6ds3h_get_gyr_value
-};
-
-const void *upm_lsm6ds3h_get_ft(upm_sensor_t sensor_type)
-{
-    switch(sensor_type)
-    {
-    case UPM_SENSOR:
-        return &ft;
-
-    case UPM_ACCELEROMETER:
-        return &aft;
-
-    case UPM_GYROSCOPE:
-        return &gft;
-
-    default:
-        return NULL;
-    }
-}
-
-void *upm_lsm6ds3h_init_name()
-{
-    return NULL;
-}
-
-void upm_lsm6ds3h_close(void *dev)
-{
-    lsm6ds3h_close((lsm6ds3h_context)dev);
-}
-
-upm_result_t upm_lsm6ds3h_get_acc_value(void *dev, float *value,
-                                        upm_acceleration_u unit)
-{
-    if (lsm6ds3h_update((lsm6ds3h_context)dev))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    // no conversion facility in place yet, so we don't do anything
-    // with units
-
-    lsm6ds3h_get_accelerometer(dev, &value[0], &value[1], &value[2]);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t upm_lsm6ds3h_get_gyr_value(void *dev, float *value)
-{
-    if (lsm6ds3h_update((lsm6ds3h_context)dev))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    lsm6ds3h_get_gyroscope(dev, &value[0], &value[1], &value[2]);
-
-    return UPM_SUCCESS;
-}
diff --git a/src/lsm9ds0/CMakeLists.txt b/src/lsm9ds0/CMakeLists.txt
deleted file mode 100644
index e28488e..0000000
--- a/src/lsm9ds0/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "lsm9ds0")
-set (libdescription "Triaxial Gyroscope/accelerometer/magnetometer Sensor")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/lsm9ds0/lsm9ds0.cxx b/src/lsm9ds0/lsm9ds0.cxx
deleted file mode 100644
index d4aa85f..0000000
--- a/src/lsm9ds0/lsm9ds0.cxx
+++ /dev/null
@@ -1,789 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <iostream>
-#include <stdexcept>
-#include <string.h>
-#include <vector>
-
-#include "lsm9ds0.hpp"
-
-using namespace upm;
-using namespace std;
-
-
-LSM9DS0::LSM9DS0(int bus, bool raw, uint8_t gAddress, uint8_t xmAddress) :
-  m_i2cG(bus, raw), m_i2cXM(bus, raw), m_gpioG_INT(0), m_gpioG_DRDY(0),
-  m_gpioXM_GEN1(0), m_gpioXM_GEN2(0)
-{
-  m_gAddr = gAddress;
-  m_xmAddr = xmAddress;
-
-  m_accelX = 0.0;
-  m_accelY = 0.0;
-  m_accelZ = 0.0;
-
-  m_gyroX = 0.0;
-  m_gyroY = 0.0;
-  m_gyroZ = 0.0;
-
-  m_magX = 0.0;
-  m_magY = 0.0;
-  m_magZ = 0.0;
-
-  m_temp = 0.0;
-
-  m_accelScale = 0.0;
-  m_gyroScale = 0.0;
-  m_magScale = 0.0;
-
-  mraa::Result rv;
-  if ( (rv = m_i2cG.address(m_gAddr)) != mraa::SUCCESS)
-    {
-      throw std::runtime_error(string(__FUNCTION__) +
-                               ": Could not initialize Gyro i2c address");
-      return;
-    }
-
-  if ( (rv = m_i2cXM.address(m_xmAddr)) != mraa::SUCCESS)
-    {
-      throw std::runtime_error(string(__FUNCTION__) +
-                               ": Could not initialize XM i2c address");
-      return;
-    }
-}
-
-LSM9DS0::~LSM9DS0()
-{
-  uninstallISR(INTERRUPT_G_INT);
-  uninstallISR(INTERRUPT_G_DRDY);
-  uninstallISR(INTERRUPT_XM_GEN1);
-  uninstallISR(INTERRUPT_XM_GEN2);
-}
-
-bool LSM9DS0::init()
-{
-  // Init the gyroscope
-
-  // power up
-  if (!setGyroscopePowerDown(false))
-    {
-      throw std::runtime_error(string(__FUNCTION__) +
-                               ": Unable to wake up gyro");
-      return false;
-    }
-
-  // enable all axes
-  if (!setGyroscopeEnableAxes(CTRL_REG1_G_YEN |CTRL_REG1_G_XEN |
-                              CTRL_REG1_G_ZEN))
-    {
-      throw std::runtime_error(string(__FUNCTION__) +
-                               ": Unable to enable gyro axes");
-      return false;
-    }
-
-  // set gyro ODR
-  if (!setGyroscopeODR(G_ODR_95_25))
-    {
-      throw std::runtime_error(string(__FUNCTION__) +
-                               ": Unable to set gyro ODR");
-      return false;
-    }
-
-  // set gyro scale
-  if (!setGyroscopeScale(G_FS_245))
-    {
-      throw std::runtime_error(string(__FUNCTION__) +
-                               ": Unable to set gyro scale");
-      return false;
-    }
-
-  // Init the accelerometer
-
-  // power up and set ODR
-  if (!setAccelerometerODR(XM_AODR_100))
-    {
-      throw std::runtime_error(string(__FUNCTION__) +
-                               ": Unable to set accel ODR");
-      return false;
-    }
-
-  // enable all axes
-  if (!setAccelerometerEnableAxes(CTRL_REG1_XM_AXEN |CTRL_REG1_XM_AYEN |
-                                  CTRL_REG1_XM_AZEN))
-    {
-      throw std::runtime_error(string(__FUNCTION__) +
-                               ": Unable to enable accel axes");
-      return false;
-    }
-
-  // set scaling rate
-  if (!setAccelerometerScale(XM_AFS_2))
-    {
-      throw std::runtime_error(string(__FUNCTION__) +
-                               ": Unable to set accel scale");
-      return false;
-    }
-
-  // temperature sensor
-
-  // enable the temperature sensor
-  if (!enableTemperatureSensor(true))
-    {
-      throw std::runtime_error(string(__FUNCTION__) +
-                               ": Unable to enable temp sensor");
-      return false;
-    }
-
-  // Init the magnetometer
-
-  // set mode (this also powers it up if not XM_MD_POWERDOWN)
-  if (!setMagnetometerMode(XM_MD_CONTINUOUS))
-    {
-      throw std::runtime_error(string(__FUNCTION__) +
-                               ": Unable to set mag scale");
-      return false;
-    }
-
-  // turn LPM off
-  if (!setMagnetometerLPM(false))
-    {
-      throw std::runtime_error(string(__FUNCTION__) +
-                               ": Unable to disable mag LPM");
-      return false;
-    }
-
-  // set resolution
-  if (!setMagnetometerResolution(XM_RES_LOW))
-    {
-      throw std::runtime_error(string(__FUNCTION__) +
-                               ": Unable to set mag res");
-      return false;
-    }
-
-  // set ODR
-  if (!setMagnetometerODR(XM_ODR_12_5))
-    {
-      throw std::runtime_error(string(__FUNCTION__) +
-                               ": Unable to set mag ODR");
-      return false;
-    }
-
-  // set scale
-  if (!setMagnetometerScale(XM_MFS_2))
-    {
-      throw std::runtime_error(string(__FUNCTION__) +
-                               ": Unable to set mag scale");
-      return false;
-    }
-
-  return true;
-}
-
-
-void LSM9DS0::update()
-{
-  updateGyroscope();
-  updateAccelerometer();
-  updateMagnetometer();
-  updateTemperature();
-}
-
-void LSM9DS0::updateGyroscope()
-{
-  uint8_t buffer[6];
-
-  memset(buffer, 0, 6);
-  readRegs(DEV_GYRO, REG_OUT_X_L_G, buffer, 6);
-
-  int16_t x, y, z;
-
-  x =  ( (buffer[1] << 8) | buffer[0] );
-  y =  ( (buffer[3] << 8) | buffer[2] );
-  z =  ( (buffer[5] << 8) | buffer[4] );
-
-  m_gyroX = float(x);
-  m_gyroY = float(y);
-  m_gyroZ = float(z);
-}
-
-void LSM9DS0::updateAccelerometer()
-{
-  uint8_t buffer[6];
-
-  memset(buffer, 0, 6);
-  readRegs(DEV_XM, REG_OUT_X_L_A, buffer, 6);
-
-  int16_t x, y, z;
-
-  x =  ( (buffer[1] << 8) | buffer[0] );
-  y =  ( (buffer[3] << 8) | buffer[2] );
-  z =  ( (buffer[5] << 8) | buffer[4] );
-
-  m_accelX = float(x);
-  m_accelY = float(y);
-  m_accelZ = float(z);
-}
-
-void LSM9DS0::updateMagnetometer()
-{
-  uint8_t buffer[6];
-
-  memset(buffer, 0, 6);
-  readRegs(DEV_XM, REG_OUT_X_L_M, buffer, 6);
-
-  int16_t x, y, z;
-
-  x =  ( (buffer[1] << 8) | buffer[0] );
-  y =  ( (buffer[3] << 8) | buffer[2] );
-  z =  ( (buffer[5] << 8) | buffer[4] );
-
-  m_magX = float(x);
-  m_magY = float(y);
-  m_magZ = float(z);
-}
-
-void LSM9DS0::updateTemperature()
-{
-  uint8_t buffer[2];
-
-  memset(buffer, 0, 2);
-  readRegs(DEV_XM, REG_OUT_TEMP_L_XM, buffer, 2);
-
-  //  cerr << "HIGH: " << int(buffer[1]) << " LOW: " << int(buffer[0]) << endl;
-
-  // 12b signed
-  int16_t temp = ( (buffer[1] << 8) | (buffer[0] ) );
-  if (temp & 0x0800)
-    {
-      temp &= ~0x0800;
-      temp *= -1;
-    }
-
-  m_temp = float(temp);
-}
-
-uint8_t LSM9DS0::readReg(DEVICE_T dev, uint8_t reg)
-{
-  mraa::I2c *device;
-
-  switch(dev)
-    {
-    case DEV_GYRO: device = &m_i2cG; break;
-    case DEV_XM:   device = &m_i2cXM; break;
-    default:
-      throw std::logic_error(string(__FUNCTION__) +
-                             ": Internal error, invalid device specified");
-      return 0;
-    }
-
-  return device->readReg(reg);
-}
-
-void LSM9DS0::readRegs(DEVICE_T dev, uint8_t reg, uint8_t *buffer, int len)
-{
-  mraa::I2c *device;
-
-  switch(dev)
-    {
-    case DEV_GYRO: device = &m_i2cG; break;
-    case DEV_XM:   device = &m_i2cXM; break;
-    default:
-      throw std::logic_error(string(__FUNCTION__) +
-                             ": Internal error, invalid device specified");
-      return;
-    }
-
-  // We need to set the high bit of the register to enable
-  // auto-increment mode for reading multiple registers in one go.
-  device->readBytesReg(reg | m_autoIncrementMode, buffer, len);
-}
-
-bool LSM9DS0::writeReg(DEVICE_T dev, uint8_t reg, uint8_t val)
-{
-  mraa::I2c *device;
-
-  switch(dev)
-    {
-    case DEV_GYRO: device = &m_i2cG; break;
-    case DEV_XM:   device = &m_i2cXM; break;
-    default:
-      throw std::logic_error(string(__FUNCTION__) +
-                             ": Internal error, invalid device specified");
-      return false;
-    }
-
-  mraa::Result rv;
-  if ((rv = device->writeReg(reg, val)) != mraa::SUCCESS)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": I2c.writeReg() failed");
-      return false;
-    }
-
-  return true;
-}
-
-bool LSM9DS0::setGyroscopePowerDown(bool enable)
-{
-  uint8_t reg = readReg(DEV_GYRO, REG_CTRL_REG1_G);
-
-  if (enable)
-    reg &= ~CTRL_REG1_G_PD;
-  else
-    reg |= CTRL_REG1_G_PD;
-
-  return writeReg(DEV_GYRO, REG_CTRL_REG1_G, reg);
-}
-
-bool LSM9DS0::setGyroscopeEnableAxes(uint8_t axes)
-{
-  uint8_t reg = readReg(DEV_GYRO, REG_CTRL_REG1_G);
-
-  // filter out any non-axis related data from arg
-  axes &= (CTRL_REG1_G_YEN | CTRL_REG1_G_XEN |  CTRL_REG1_G_ZEN);
-
-  // clear them in the register
-  reg &= ~(CTRL_REG1_G_YEN | CTRL_REG1_G_XEN |  CTRL_REG1_G_ZEN);
-
-  // now add them
-  reg |= axes;
-
-  return writeReg(DEV_GYRO, REG_CTRL_REG1_G, reg);
-}
-
-bool LSM9DS0::setGyroscopeODR(G_ODR_T odr)
-{
-  uint8_t reg = readReg(DEV_GYRO, REG_CTRL_REG1_G);
-
-  reg &= ~(_CTRL_REG1_G_ODR_MASK << _CTRL_REG1_G_ODR_SHIFT);
-
-  reg |= (odr << _CTRL_REG1_G_ODR_SHIFT);
-
-  return writeReg(DEV_GYRO, REG_CTRL_REG1_G, reg);
-}
-
-bool LSM9DS0::setGyroscopeScale(G_FS_T scale)
-{
-  uint8_t reg = readReg(DEV_GYRO, REG_CTRL_REG4_G);
-
-  reg &= ~(_CTRL_REG4_G_FS_MASK << _CTRL_REG4_G_FS_SHIFT);
-
-  reg |= (scale << _CTRL_REG4_G_FS_SHIFT);
-
-  if (!writeReg(DEV_GYRO, REG_CTRL_REG4_G, reg))
-    {
-      return false;
-    }
-
-  // store scaling factor (mDeg/s/LSB)
-
-  switch (scale)
-    {
-    case G_FS_245:
-      m_gyroScale = 8.75;
-      break;
-
-    case G_FS_500:
-      m_gyroScale = 17.5;
-      break;
-
-    case G_FS_2000:
-      m_gyroScale = 70.0;
-      break;
-
-    default: // should never occur, but...
-      m_gyroScale = 0.0;        // set a safe, though incorrect value
-      throw std::logic_error(string(__FUNCTION__) +
-                             ": internal error, unsupported scale");
-      break;
-    }
-
-  return true;
-}
-
-bool LSM9DS0::setAccelerometerEnableAxes(uint8_t axes)
-{
-  uint8_t reg = readReg(DEV_XM, REG_CTRL_REG1_XM);
-
-  // filter out any non-axis related data from arg
-  axes &= (CTRL_REG1_XM_AXEN | CTRL_REG1_XM_AYEN | CTRL_REG1_XM_AZEN);
-
-  // clear them in the register
-  reg &= ~(CTRL_REG1_XM_AXEN | CTRL_REG1_XM_AYEN | CTRL_REG1_XM_AZEN);
-
-  // now add them
-  reg |= axes;
-
-  return writeReg(DEV_XM, REG_CTRL_REG1_XM, reg);
-}
-
-bool LSM9DS0::setAccelerometerODR(XM_AODR_T odr)
-{
-  uint8_t reg = readReg(DEV_XM, REG_CTRL_REG1_XM);
-
-  reg &= ~(_CTRL_REG1_XM_AODR_MASK << _CTRL_REG1_XM_AODR_SHIFT);
-
-  reg |= (odr << _CTRL_REG1_XM_AODR_SHIFT);
-
-  return writeReg(DEV_XM, REG_CTRL_REG1_XM, reg);
-}
-
-bool LSM9DS0::setAccelerometerScale(XM_AFS_T scale)
-{
-  uint8_t reg = readReg(DEV_XM, REG_CTRL_REG2_XM);
-
-  reg &= ~(_CTRL_REG2_XM_AFS_MASK << _CTRL_REG2_XM_AFS_SHIFT);
-
-  reg |= (scale << _CTRL_REG2_XM_AFS_SHIFT);
-
-  if (!writeReg(DEV_XM, REG_CTRL_REG2_XM, reg))
-    {
-      return false;
-    }
-
-  // store scaling factor
-
-  switch (scale)
-    {
-    case XM_AFS_2:
-      m_accelScale = 0.061;
-      break;
-
-    case XM_AFS_4:
-      m_accelScale = 0.122 ;
-      break;
-
-    case XM_AFS_6:
-      m_accelScale = 0.183 ;
-      break;
-
-    case XM_AFS_8:
-      m_accelScale = 0.244 ;
-      break;
-
-    case XM_AFS_16:
-      m_accelScale = 0.732 ;
-      break;
-
-    default: // should never occur, but...
-      m_accelScale = 0.0;        // set a safe, though incorrect value
-      throw std::logic_error(string(__FUNCTION__) +
-                             ": internal error, unsupported scale");
-      break;
-    }
-
-  return true;
-}
-
-bool LSM9DS0::setMagnetometerResolution(XM_RES_T res)
-{
-  uint8_t reg = readReg(DEV_XM, REG_CTRL_REG5_XM);
-
-  reg &= ~(_CTRL_REG5_XM_RES_MASK << _CTRL_REG5_XM_RES_SHIFT);
-
-  reg |= (res << _CTRL_REG5_XM_RES_SHIFT);
-
-  return writeReg(DEV_XM, REG_CTRL_REG5_XM, reg);
-}
-
-bool LSM9DS0::setMagnetometerODR(XM_ODR_T odr)
-{
-  uint8_t reg = readReg(DEV_XM, REG_CTRL_REG5_XM);
-
-  reg &= ~(_CTRL_REG5_XM_ODR_MASK << _CTRL_REG5_XM_ODR_SHIFT);
-
-  reg |= (odr << _CTRL_REG5_XM_ODR_SHIFT);
-
-  return writeReg(DEV_XM, REG_CTRL_REG5_XM, reg);
-}
-
-bool LSM9DS0::setMagnetometerMode(XM_MD_T mode)
-{
-  uint8_t reg = readReg(DEV_XM, REG_CTRL_REG7_XM);
-
-  reg &= ~(_CTRL_REG7_XM_MD_MASK << _CTRL_REG7_XM_MD_SHIFT);
-
-  reg |= (mode << _CTRL_REG7_XM_MD_SHIFT);
-
-  return writeReg(DEV_XM, REG_CTRL_REG7_XM, reg);
-}
-
-bool LSM9DS0::setMagnetometerLPM(bool enable)
-{
-  uint8_t reg = readReg(DEV_XM, REG_CTRL_REG7_XM);
-
-  if (enable)
-    reg |= CTRL_REG7_XM_MLP;
-  else
-    reg &= ~CTRL_REG7_XM_MLP;
-
-  return writeReg(DEV_XM, REG_CTRL_REG7_XM, reg);
-}
-
-bool LSM9DS0::setMagnetometerScale(XM_MFS_T scale)
-{
-  uint8_t reg = readReg(DEV_XM, REG_CTRL_REG6_XM);
-
-  reg &= ~(_CTRL_REG6_XM_MFS_MASK << _CTRL_REG6_XM_MFS_SHIFT);
-
-  reg |= (scale << _CTRL_REG6_XM_MFS_SHIFT);
-
-  if (!writeReg(DEV_XM, REG_CTRL_REG6_XM, reg))
-    {
-      return false;
-    }
-
-  // store scaling factor
-
-  switch (scale)
-    {
-    case XM_MFS_2:
-      m_magScale = 0.08;
-      break;
-
-    case XM_MFS_4:
-      m_magScale = 0.16;
-      break;
-
-    case XM_MFS_8:
-      m_magScale = 0.32;
-      break;
-
-    case XM_MFS_12:
-      m_magScale = 0.48;
-      break;
-
-    default: // should never occur, but...
-      m_magScale = 0.0;        // set a safe, though incorrect value
-      throw std::logic_error(string(__FUNCTION__) +
-                             ": internal error, unsupported scale");
-      break;
-    }
-
-  return true;
-}
-
-void LSM9DS0::getAccelerometer(float *x, float *y, float *z)
-{
-  if (x)
-    *x = (m_accelX * m_accelScale) / 1000.0;
-
-  if (y)
-    *y = (m_accelY * m_accelScale) / 1000.0;
-
-  if (z)
-    *z = (m_accelZ * m_accelScale) / 1000.0;
-}
-
-void LSM9DS0::getGyroscope(float *x, float *y, float *z)
-{
-  if (x)
-    *x = (m_gyroX * m_gyroScale) / 1000.0;
-
-  if (y)
-    *y = (m_gyroY * m_gyroScale) / 1000.0;
-
-  if (z)
-    *z = (m_gyroZ * m_gyroScale) / 1000.0;
-}
-
-void LSM9DS0::getMagnetometer(float *x, float *y, float *z)
-{
-  if (x)
-    *x = (m_magX * m_magScale) / 1000.0;
-
-  if (y)
-    *y = (m_magY * m_magScale) / 1000.0;
-
-  if (z)
-    *z = (m_magZ * m_magScale) / 1000.0;
-}
-
-std::vector<float> LSM9DS0::getAccelerometer()
-{
-  std::vector<float> v(3);
-  getAccelerometer(&v[0], &v[1], &v[2]);
-  return v;
-}
-
-std::vector<float> LSM9DS0::getGyroscope()
-{
-  std::vector<float> v(3);
-  getGyroscope(&v[0], &v[1], &v[2]);
-  return v;
-}
-
-std::vector<float> LSM9DS0::getMagnetometer()
-{
-  std::vector<float> v(3);
-  getMagnetometer(&v[0], &v[1], &v[2]);
-  return v;
-}
-
-float LSM9DS0::getTemperature()
-{
-  // This might be wrong... The datasheet does not provide enough info
-  // to calculate the temperature given a specific sensor reading.  So
-  // - with 12b resolution, signed, and 8 degrees/per LSB, we come up
-  // with the following.  Then scale up and we get a number that seems
-  // pretty close.
-  return (((m_temp / 2048.0) * 8.0) * 100.0);
-}
-
-bool LSM9DS0::enableTemperatureSensor(bool enable)
-{
-  uint8_t reg = readReg(DEV_XM, REG_CTRL_REG5_XM);
-
-  if (enable)
-    reg |= CTRL_REG5_XM_TEMP_EN;
-  else
-    reg &= ~CTRL_REG5_XM_TEMP_EN;
-
-  return writeReg(DEV_XM, REG_CTRL_REG5_XM, reg);
-}
-
-uint8_t LSM9DS0::getGyroscopeStatus()
-{
-  return readReg(DEV_GYRO, REG_STATUS_REG_G);
-}
-
-uint8_t LSM9DS0::getMagnetometerStatus()
-{
-  return readReg(DEV_XM, REG_STATUS_REG_M);
-}
-
-uint8_t LSM9DS0::getAccelerometerStatus()
-{
-  return readReg(DEV_XM, REG_STATUS_REG_A);
-}
-
-uint8_t LSM9DS0::getGyroscopeInterruptConfig()
-{
-  return readReg(DEV_GYRO, REG_INT1_CFG_G);
-}
-
-bool LSM9DS0::setGyroscopeInterruptConfig(uint8_t enables)
-{
-  return writeReg(DEV_GYRO, REG_INT1_CFG_G, enables);
-}
-
-uint8_t LSM9DS0::getGyroscopeInterruptSrc()
-{
-  return readReg(DEV_GYRO, REG_INT1_SRC_G);
-}
-
-uint8_t LSM9DS0::getMagnetometerInterruptControl()
-{
-  return readReg(DEV_XM, REG_INT_CTRL_REG_M);
-}
-
-bool LSM9DS0::setMagnetometerInterruptControl(uint8_t enables)
-{
-  return writeReg(DEV_XM, REG_INT_CTRL_REG_M, enables);
-}
-
-uint8_t LSM9DS0::getMagnetometerInterruptSrc()
-{
-  return readReg(DEV_XM, REG_INT_SRC_REG_M);
-}
-
-uint8_t LSM9DS0::getInterruptGen1()
-{
-  return readReg(DEV_XM, REG_INT_GEN_1_REG);
-}
-
-bool LSM9DS0::setInterruptGen1(uint8_t enables)
-{
-  return writeReg(DEV_XM, REG_INT_GEN_1_REG, enables);
-}
-
-uint8_t LSM9DS0::getInterruptGen1Src()
-{
-  return readReg(DEV_XM, REG_INT_GEN_1_SRC);
-}
-
-uint8_t LSM9DS0::getInterruptGen2()
-{
-  return readReg(DEV_XM, REG_INT_GEN_2_REG);
-}
-
-bool LSM9DS0::setInterruptGen2(uint8_t enables)
-{
-  return writeReg(DEV_XM, REG_INT_GEN_2_REG, enables);
-}
-
-uint8_t LSM9DS0::getInterruptGen2Src()
-{
-  return readReg(DEV_XM, REG_INT_GEN_2_SRC);
-}
-
-
-void LSM9DS0::installISR(INTERRUPT_PINS_T intr, int gpio, mraa::Edge level,
-                         void (*isr)(void *), void *arg)
-{
-  // delete any existing ISR and GPIO context
-  uninstallISR(intr);
-
-  // greate gpio context
-  getPin(intr) = new mraa::Gpio(gpio);
-
-  getPin(intr)->dir(mraa::DIR_IN);
-  getPin(intr)->isr(level, isr, arg);
-}
-
-
-void LSM9DS0::uninstallISR(INTERRUPT_PINS_T intr)
-{
-  if (getPin(intr))
-    {
-      getPin(intr)->isrExit();
-      delete getPin(intr);
-
-      getPin(intr) = 0;
-    }
-}
-
-mraa::Gpio*& LSM9DS0::getPin(INTERRUPT_PINS_T intr)
-{
-  switch(intr)
-    {
-    case INTERRUPT_G_INT:
-      return m_gpioG_INT;
-      break;
-    case INTERRUPT_G_DRDY:
-      return m_gpioG_DRDY;
-      break;
-    case INTERRUPT_XM_GEN1:
-      return m_gpioXM_GEN1;
-      break;
-    case INTERRUPT_XM_GEN2:
-      return m_gpioXM_GEN2;
-      break;
-    default:
-      throw std::out_of_range(string(__FUNCTION__) +
-                              ": Invalid interrupt enum passed");
-    }
-}
diff --git a/src/lsm9ds0/lsm9ds0.hpp b/src/lsm9ds0/lsm9ds0.hpp
deleted file mode 100644
index fe10e10..0000000
--- a/src/lsm9ds0/lsm9ds0.hpp
+++ /dev/null
@@ -1,1484 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <vector>
-#include <mraa/common.hpp>
-#include <mraa/i2c.hpp>
-
-#include <mraa/gpio.hpp>
-
-#define LSM9DS0_I2C_BUS 1
-#define LSM9DS0_DEFAULT_XM_ADDR 0x1d
-#define LSM9DS0_DEFAULT_GYRO_ADDR 0x6b
-
-namespace upm {
-
-  /**
-   * @brief LSM9DS0 accelerometer library
-   * @defgroup lsm9ds0 libupm-lsm9ds0
-   * @ingroup sparkfun stmicro i2c gpio accelerometer compass
-   */
-
-  /**
-   * @library lsm9ds0
-   * @sensor lsm9ds0
-   * @comname Triaxial Gyroscope/accelerometer/magnetometer Sensor
-   * @type accelerometer compass
-   * @man sparkfun stmicro
-   * @con i2c gpio
-   * @web https://www.sparkfun.com/products/13033
-   *
-   * @brief API for the LSM9DS0 3-axis Gyroscope, Accelerometer,
-   * and Magnetometer
-   *
-   * The LSM9DS0 is a system-in-package featuring a 3D digital linear
-   * acceleration sensor, a 3D digital angular rate sensor, and a 3D
-   * digital magnetic sensor.
-   *
-   * The LSM9DS0 has a linear acceleration full scale of
-   * 2g/4g/6g/8g/16g, a magnetic field full scale of 2/4/8/12
-   * gauss and an angular rate of 245/500/2000 dps.
-   *
-   * While not all of the functionality of this device is supported
-   * initially, methods and register definitions are provided that
-   * should allow an end user to implement whatever features are
-   * required.
-   *
-   * This driver was developed on a Sparkfun 9DOF edison block.
-   *
-   * @image html lsm9ds0.jpg
-   * <br><em>LSM9DS0 Sensor image provided by SparkFun* under
-   * <a href=https://creativecommons.org/licenses/by/2.0/>
-   * CC BY 2.0</a>.</em>
-   *
-   * @snippet lsm9ds0.cxx Interesting
-   */
-
-  class LSM9DS0 {
-  public:
-
-    // NOTE: reserved registers must not be written into or permanent
-    // damage to the device can result.  Reserved bitfields must
-    // always be 0.
-
-    // There are two sub-devices within this device - the
-    // Accelerometer and Magnetometer (XM) and the Gyroscope (G), each
-    // with their own I2C address.
-
-    /**
-     * LSM9DS0 Gyroscope (G) registers
-     */
-    typedef enum {
-      // 0x00-0x0e reserved
-
-      REG_WHO_AM_I_G            = 0x0f, // should be 0xd4
-
-      // 0x10-0x1f reserved
-
-      REG_CTRL_REG1_G           = 0x20,
-      REG_CTRL_REG2_G           = 0x21,
-      REG_CTRL_REG3_G           = 0x22,
-      REG_CTRL_REG4_G           = 0x23,
-      REG_CTRL_REG5_G           = 0x24,
-
-      REG_REFERENCE_G           = 0x25,
-
-      // 0x26 reserved
-
-      REG_STATUS_REG_G          = 0x27,
-
-      REG_OUT_X_L_G             = 0x28, // gyro output, X axis, LSB
-      REG_OUT_X_H_G             = 0x29, // gyro output, X axis, MSB
-      REG_OUT_Y_L_G             = 0x2a,
-      REG_OUT_Y_H_G             = 0x2b,
-      REG_OUT_Z_L_G             = 0x2c,
-      REG_OUT_Z_H_G             = 0x2d,
-
-      REG_FIFO_CTRL_REG_G       = 0x2e,
-      REG_FIFO_SRC_REG_G        = 0x2f,
-
-      REG_INT1_CFG_G            = 0x30,
-      REG_INT1_SRC_G            = 0x31,
-
-      REG_INT1_TSH_XH_G         = 0x32, // interrupt threshold registers
-      REG_INT1_TSH_XL_G         = 0x33,
-      REG_INT1_TSH_YH_G         = 0x34,
-      REG_INT1_TSH_YL_G         = 0x35,
-      REG_INT1_TSH_ZH_G         = 0x36,
-      REG_INT1_TSH_ZL_G         = 0x37,
-
-      // See fig 19 & 20 and preceeding description in the datasheet
-      // on how to use this register
-      REG_INT1_DURATION_G       = 0x38
-    } REG_G_T;
-
-    /**
-     * Gyro CTRL_REG1_G bits
-     */
-    typedef enum {
-      CTRL_REG1_G_YEN           = 0x01, // Y enable, odd ordering...
-      CTRL_REG1_G_XEN           = 0x02,
-      CTRL_REG1_G_ZEN           = 0x04,
-      CTRL_REG1_G_PD            = 0x08, // power down (0)
-
-      CTRL_REG1_G_BW0           = 0x10, // bandwidth
-      CTRL_REG1_G_BW1           = 0x20,
-      _CTRL_REG1_G_BW_MASK      = 3,
-      _CTRL_REG1_G_BW_SHIFT     = 4,
-
-      CTRL_REG1_G_DR0           = 0x40, // data rate
-      CTRL_REG1_G_DR1           = 0x80,
-      _CTRL_REG1_G_DR_MASK      = 3,
-      _CTRL_REG1_G_DR_SHIFT     = 6,
-
-      // The following are synthetic register and shift/mask
-      // definitions.  Together both BW and DR setup the device for a
-      // specific output data rate (ODR) and cutoff frequency. These
-      // definitions allow us to use a more informative configuration
-      // for these 4 bits, rather than having the user go to the
-      // datasheet to figure out what to put for those values in order
-      // to get the desired ODR/cutoff.  These are the values we will
-      // use in this driver.
-
-      CTRL_REG1_G_ODR0          = 0x10, // BW0
-      CTRL_REG1_G_ODR1          = 0x20, // BW1
-      CTRL_REG1_G_ODR2          = 0x40, // DR0
-      CTRL_REG1_G_ODR3          = 0x80, // DR1
-      _CTRL_REG1_G_ODR_MASK     = 15,
-      _CTRL_REG1_G_ODR_SHIFT    = 4
-    } CTRL_REG1_G_BITS_T;
-
-    /**
-     * CRTL_REG1_G_ODR values
-     */
-    typedef enum {
-      G_ODR_95_12_5             = 0, // ODR = 95Hz, cutoff = 12.5
-      G_ODR_95_25               = 1, // ODR = 95Hz, cutoff = 25
-      // Other two (2 and 3) are the same (95_25)
-
-      G_ODR_190_12_5            = 4,
-      G_ODR_190_25              = 5,
-      G_ODR_190_50              = 6,
-      G_ODR_190_70              = 7,
-
-      G_ODR_380_20              = 8,
-      G_ODR_380_25              = 9,
-      G_ODR_380_50              = 10,
-      G_ODR_380_100             = 11,
-
-      G_ODR_760_30              = 12,
-      G_ODR_760_35              = 13,
-      G_ODR_760_50              = 14,
-      G_ODR_760_100             = 15
-    } G_ODR_T;
-
-    /**
-     * Gyro CTRL_REG2_G bits
-     */
-    typedef enum {
-      CTRL_REG2_G_HPCF0         = 0x01, // high-pass cutoff freq
-      CTRL_REG2_G_HPCF1         = 0x02,
-      CTRL_REG2_G_HPCF2         = 0x04,
-      CTRL_REG2_G_HPCF3         = 0x08,
-      _CTRL_REG2_G_HPCF_MASK    = 15,
-      _CTRL_REG2_G_HPCF_SHIFT   = 0,
-
-      CTRL_REG2_G_HPM0          = 0x10, // high-pass filter mode
-      CTRL_REG2_G_HPM1          = 0x20,
-      _CTRL_REG2_G_HPM_MASK     = 3,
-      _CTRL_REG2_G_HPM_SHIFT    = 4,
-
-      // 0x40, 0x80 reserved
-    } CTRL_REG2_G_BITS_T;
-
-    /**
-     * CRTL_REG2_G_HPCF values
-     *
-     * See table 26 in the datasheet, as these depend on your data
-     * rate (ODR).  We will label these according to the 95Hz column,
-     * but of course the actual cutoff frequency depends on ODR.
-     */
-    typedef enum {
-      G_HPCF_7_2                = 0, // 7.2 Hz (if ODR is 95Hz)
-      G_HPCF_3_5                = 1,
-      G_HPCF_1_8                = 2,
-      G_HPCF_0_9                = 3, // 0.9Hz
-      G_HPCF_0_45               = 4,
-      G_HPCF_0_18               = 5,
-      G_HPCF_0_09               = 6,
-      G_HPCF_0_045              = 7,
-      G_HPCF_0_018              = 8,
-      G_HPCF_0_009              = 9
-
-      // 10-15 unused
-    } G_HPCF_T;
-
-    /**
-     * CRTL_REG2_G_HPM values
-     *
-     */
-    typedef enum {
-      G_HPM_NORMAL_RESET_HPF    = 0, // reset reading (HP_RESET_FILTER)
-      G_HPM_REFERENCE           = 1, // REF signal for filtering
-      G_HPM_NORMAL              = 2, // normal mode
-      G_HPM_AUTORESET_ON_INTR   = 3  // autoreset in interrupt event
-    } G_HPM_T;
-
-    /**
-     * Gyro CTRL_REG3_G bits (interrupt G config)
-     */
-    typedef enum {
-      CTRL_REG3_G_I2_EMPTY      = 0x01, // FIFO empty on DRDY_G
-      CTRL_REG3_G_I2_ORUN       = 0x02, // FIFO Overrun intr
-      CTRL_REG3_G_I2_WTM        = 0x04, // FIFO watermark intr
-      CTRL_REG3_G_I2_DRDY       = 0x08, // data ready on DRDY_G
-      CTRL_REG3_G_PP_OD         = 0x10, // push-pull/open drain
-      CTRL_REG3_G_H_LACTIVE     = 0x20,
-      CTRL_REG3_G_I1_BOOT       = 0x40,
-      CTRL_REG3_G_I1_INT1       = 0x80, // intr enable on INT_G pin
-    } CTRL_REG3_G_BITS_T;
-
-    /**
-     * Gyro CTRL_REG4_G bits
-     */
-    typedef enum {
-      CTRL_REG4_G_SIM           = 0x01, // SPI mode selection
-
-      CTRL_REG4_G_ST0           = 0x02, // self test enables
-      CTRL_REG4_G_ST1           = 0x04,
-      _CTRL_REG4_G_ST_MASK      = 3,
-      _CTRL_REG4_G_ST_SHIFT     = 1,
-
-      // 0x08 reserved
-
-      CTRL_REG4_G_FS0           = 0x10, // full scale selection
-      CTRL_REG4_G_FS1           = 0x20,
-      _CTRL_REG4_G_FS_MASK      = 3,
-      _CTRL_REG4_G_FS_SHIFT     = 4,
-
-      CTRL_REG4_G_BLE           = 0x40, // big/little endian data selection
-      CTRL_REG4_G_BDU           = 0x80  // block data updates
-    } CTRL_REG4_G_BITS_T;
-
-    /**
-     * CRTL_REG4_G_ST values
-     *
-     */
-    typedef enum {
-      G_ST_NORMAL               = 0, // normal mode
-      G_ST_SELFTEST0            = 1, // x+, y-, z-
-
-      // 2, reserved
-
-      G_ST_SELFTEST1            = 3  // x-, y+, z+
-    } G_ST_T;
-
-    /**
-     * CRTL_REG4_G_FS values
-     *
-     */
-    typedef enum {
-      G_FS_245                  = 0, // 245 deg/sec
-      G_FS_500                  = 1,
-      G_FS_2000                 = 2
-      // 3 is also 2000
-    } G_FS_T;
-
-    /**
-     * Gyro CTRL_REG5_G bits
-     */
-    typedef enum {
-      CTRL_REG5_G_OUTSEL0       = 0x01, // see fig. 18 in the datasheet
-      CTRL_REG5_G_OUTSEL1       = 0x02,
-      _CTRL_REG5_G_OUTSEL_MASK  = 3,
-      _CTRL_REG5_G_OUTSEL_SHIFT = 0,
-
-      CTRL_REG5_G_INT1SEL0      = 0x04, // see fig. 18 in the datasheet
-      CTRL_REG5_G_INT1SEL1      = 0x08,
-      _CTRL_REG5_G_INT1SEL_MASK = 3,
-      _CTRL_REG5_G_INT1SEL_SHIFT = 2,
-
-      CTRL_REG5_G_HPEN          = 0x10, // HPF enable
-
-      // 0x20 reserved
-
-      CTRL_REG5_G_FIFO_EN       = 0x40,
-      CTRL_REG5_G_BOOT          = 0x80  // reboot memory content
-    } CTRL_REG5_G_BITS_T;
-
-
-    /**
-     * CRTL_REG5_G_OUTSEL and INT1SEL values.  See Figure 18 in the
-     * datasheet.
-     */
-    typedef enum {
-      G_INT1OUTSEL_0            = 0,
-      G_INT1OUTSEL_1            = 1,
-      G_INT1OUTSEL_2            = 2,
-      G_INT1OUTSEL_3            = 3
-    } G_INT1OUTSEL_T;
-
-    /**
-     * Gyro STATUS_REG_G bits
-     */
-    typedef enum {
-      STATUS_REG_G_XDA          = 0x01, // X axis data available
-      STATUS_REG_G_YDA          = 0x02,
-      STATUS_REG_G_ZDA          = 0x04,
-      STATUS_REG_G_ZYXDA        = 0x08, // X, Y, and Z data available
-
-      STATUS_REG_G_XOR          = 0x10, // X data overrun
-      STATUS_REG_G_YOR          = 0x20,
-      STATUS_REG_G_ZOR          = 0x40,
-      STATUS_REG_G_ZYXOR        = 0x80
-    } STATUS_REG_G_BITS_T;
-
-    /**
-     * Gyro FIFO_CTRL_REG_G bits
-     */
-    typedef enum {
-      FIFO_CTRL_REG_G_WTM0      = 0x01, // FIFO watermark
-      FIFO_CTRL_REG_G_WTM1      = 0x02,
-      FIFO_CTRL_REG_G_WTM2      = 0x04,
-      FIFO_CTRL_REG_G_WTM3      = 0x08,
-      FIFO_CTRL_REG_G_WTM4      = 0x10,
-      _FIFO_CTRL_REG_G_WTM_MASK = 31,
-      _FIFO_CTRL_REG_G_WTM_SHIFT = 0,
-
-      FIFO_CTRL_REG_G_FM0       = 0x20, // FIFO mode config
-      FIFO_CTRL_REG_G_FM1       = 0x40,
-      FIFO_CTRL_REG_G_FM2       = 0x80,
-      _FIFO_CTRL_REG_G_FM_MASK  = 7,
-      _FIFO_CTRL_REG_G_FM_SHIFT = 5,
-    } FIFO_CTRL_REG_G_T;
-
-    // FIFO_CTRL_REG_G_WTM (FIFO watermark) is just a numeric value
-    // between 0-31, so we won't enumerate those values.
-
-    /**
-     * FIFO_CTRL_REG_G_FM values (FIFO Modes)
-     *
-     */
-    typedef enum {
-      G_FM_BYPASS               = 0,
-      G_FM_FIFO                 = 1,
-      G_FM_STREAM               = 2,
-      G_FM_STREAM2FIFO          = 3,
-      G_FM_BYPASS2STREAM        = 4
-
-      // 5-7 unused
-    } G_FM_T;
-
-    /**
-     * FIFO_SRC_REG_G bits
-     *
-     */
-    typedef enum {
-      FIFO_CTRL_REG_G_FSS0      = 0x01, // FIFO stored data level
-      FIFO_CTRL_REG_G_FSS1      = 0x02,
-      FIFO_CTRL_REG_G_FSS2      = 0x04,
-      FIFO_CTRL_REG_G_FSS3      = 0x08,
-      FIFO_CTRL_REG_G_FSS4      = 0x10,
-      _FIFO_CTRL_REG_G_FSS_MASK = 31,
-      _FIFO_CTRL_REG_G_FSS_SHIFT = 0,
-
-      FIFO_CTRL_REG_G_EMPTY     = 0x20, // FIFO empty
-      FIFO_CTRL_REG_G_OVRN      = 0x40, // FIFO overrun
-      FIFO_CTRL_REG_G_WTM       = 0x80  // watermark status
-    } FIFO_SRC_REG_G_BITS_T;
-
-    /**
-     * INT1_CFG_G bits
-     *
-     */
-    typedef enum {
-      INT1_CFG_G_XLIE           = 0x01, // X Low event interrupt enable
-      INT1_CFG_G_XHIE           = 0x02, // X High event interrupt enable
-      INT1_CFG_G_YLIE           = 0x04,
-      INT1_CFG_G_YHIE           = 0x08,
-      INT1_CFG_G_ZLIE           = 0x10,
-      INT1_CFG_G_ZHIE           = 0x20,
-
-      INT1_CFG_G_LIR            = 0x40, // latch interrupt request
-      INT1_CFG_G_ANDOR          = 0x80  // OR or AND interrupt events
-    } INT1_CFG_G_BITS_T;
-
-    /**
-     * INT1_SRC_G bits
-     *
-     */
-    typedef enum {
-      INT1_SRC_G_XL             = 0x01, // X low interrupt
-      INT1_SRC_G_XH             = 0x02, // X high interrupt
-      INT1_SRC_G_YL             = 0x04,
-      INT1_SRC_G_YH             = 0x08,
-      INT1_SRC_G_ZL             = 0x10,
-      INT1_SRC_G_ZH             = 0x20,
-
-      INT1_SRC_G_IA             = 0x40 // interrupt active
-
-      // 0x80 reserved
-    } INT1_SRC_G_BITS_T;
-
-    // The following registers are for the Accelerometer (A/X),
-    // Magnetometer (M), and Temperature device.
-
-    /**
-     * LSM9DS0 Accelerometer (X) and Magnetometer (M) registers
-     */
-    typedef enum {
-      // 0x00-0x04 reserved
-
-      REG_OUT_TEMP_L_XM         = 0x05, // temperature
-      REG_OUT_TEMP_H_XM         = 0x06,
-
-      REG_STATUS_REG_M          = 0x07,
-
-      REG_OUT_X_L_M             = 0x08, // magnetometer outputs
-      REG_OUT_X_H_M             = 0x09,
-      REG_OUT_Y_L_M             = 0x0a,
-      REG_OUT_Y_H_M             = 0x0b,
-      REG_OUT_Z_L_M             = 0x0c,
-      REG_OUT_Z_H_M             = 0x0d,
-
-      // 0x0e reserved
-
-      REG_WHO_AM_I_XM           = 0x0f,
-
-      // 0x10, 0x11 reserved
-
-      REG_INT_CTRL_REG_M        = 0x12,
-      REG_INT_SRC_REG_M         = 0x13,
-
-      REG_INT_THS_L_M           = 0x14, // magnetometer threshold
-      REG_INT_THS_H_M           = 0x15,
-
-      REG_OFFSET_X_L_M          = 0x16,
-      REG_OFFSET_X_H_M          = 0x17,
-      REG_OFFSET_Y_L_M          = 0x18,
-      REG_OFFSET_Y_H_M          = 0x19,
-      REG_OFFSET_Z_L_M          = 0x1a,
-      REG_OFFSET_Z_H_M          = 0x1b,
-
-      REG_REFERENCE_X           = 0x1c,
-      REG_REFERENCE_Y           = 0x1d,
-      REG_REFERENCE_Z           = 0x1e,
-
-      REG_CTRL_REG0_XM          = 0x1f,
-      REG_CTRL_REG1_XM          = 0x20,
-      REG_CTRL_REG2_XM          = 0x21,
-      REG_CTRL_REG3_XM          = 0x22,
-      REG_CTRL_REG4_XM          = 0x23,
-      REG_CTRL_REG5_XM          = 0x24,
-      REG_CTRL_REG6_XM          = 0x25,
-      REG_CTRL_REG7_XM          = 0x26,
-
-      REG_STATUS_REG_A          = 0x27,
-
-      REG_OUT_X_L_A             = 0x28, // accelerometer outputs
-      REG_OUT_X_H_A             = 0x29,
-      REG_OUT_Y_L_A             = 0x2a,
-      REG_OUT_Y_H_A             = 0x2b,
-      REG_OUT_Z_L_A             = 0x2c,
-      REG_OUT_Z_H_A             = 0x2d,
-
-      REG_FIFO_CTRL_REG         = 0x2e,
-      REG_FIFO_SRC_REG          = 0x2f,
-
-      REG_INT_GEN_1_REG         = 0x30,
-      REG_INT_GEN_1_SRC         = 0x31,
-      REG_INT_GEN_1_THS         = 0x32,
-      REG_INT_GEN_1_DURATION    = 0x33,
-
-      REG_INT_GEN_2_REG         = 0x34,
-      REG_INT_GEN_2_SRC         = 0x35,
-      REG_INT_GEN_2_THS         = 0x36,
-      REG_INT_GEN_2_DURATION    = 0x37,
-
-      REG_CLICK_CFG             = 0x38,
-      REG_CLICK_SRC             = 0x39,
-      REG_CLICK_THS             = 0x3a,
-
-      REG_TIME_LIMIT            = 0x3b,
-      REG_TIME_LATENCY          = 0x3c,
-      REG_TIME_WINDOW           = 0x3d,
-
-      REG_ACT_THS               = 0x3e,
-      REG_ACT_DUR               = 0x3f
-    } REG_XM_T;
-
-    /**
-     * XM STATUS_REG_M bits
-     */
-    typedef enum {
-      STATUS_REG_M_XMDA         = 0x01, // X mag axis data available
-      STATUS_REG_M_YMDA         = 0x02,
-      STATUS_REG_M_ZMDA         = 0x04,
-      STATUS_REG_M_ZYXMDA       = 0x08, // X, Y, and Z mag data available
-
-      STATUS_REG_M_XMOR         = 0x10, // X mag data overrun
-      STATUS_REG_M_YMOR         = 0x20,
-      STATUS_REG_M_ZMOR         = 0x40,
-      STATUS_REG_M_ZYXMOR       = 0x80
-    } STATUS_REG_M_BITS_T;
-
-    /**
-     * INT_CTRL_REG_M bits
-     */
-    typedef enum {
-      INT_CTRL_REG_M_MIEN       = 0x01, // mag interrupt enable
-      INT_CTRL_REG_M_4D         = 0x02,
-      INT_CTRL_REG_M_IEL        = 0x04, // latch intr request
-      INT_CTRL_REG_M_IEA        = 0x08,
-      INT_CTRL_REG_M_PP_OD      = 0x10, // push-pull/open drian
-      INT_CTRL_REG_M_ZMIEN      = 0x20, // Z mag axis interrupt recognition
-      INT_CTRL_REG_M_YMIEN      = 0x40,
-      INT_CTRL_REG_M_XMIEN      = 0x80
-    } INT_CTRL_REG_M_BITS_T;
-
-    /**
-     * INT_SRC_REG_M bits
-     */
-    typedef enum {
-      INT_SRC_REG_M_MINT        = 0x01,
-      INT_SRC_REG_M_MROI        = 0x02,
-      INT_SRC_REG_M_NTH_Z       = 0x04,
-      INT_SRC_REG_M_NTH_Y       = 0x08,
-      INT_SRC_REG_M_NTH_X       = 0x10,
-      INT_SRC_REG_M_PTH_Z       = 0x20,
-      INT_SRC_REG_M_PTH_Y       = 0x40,
-      INT_SRC_REG_M_PTH_X       = 0x80
-    } INT_SRC_REG_M_BITS_T;
-
-
-    /**
-     * CTRL_REG0_XM bits
-     */
-    typedef enum {
-      CTRL_REG0_XM_HPIS2        = 0x01, // HPF enable for int generator 2
-      CTRL_REG0_XM_HPIS1        = 0x02,
-
-      CTRL_REG0_XM_HP_CLICK     = 0x04, // HPF enable for click
-
-      // 0x08,0x10 reserved
-
-      CTRL_REG0_XM_WTM_LEN      = 0x20, // watermark enable
-      CTRL_REG0_XM_FIFO_EN      = 0x40, // FIFO enable
-      CTRL_REG0_XM_BOOT         = 0x80  // reboot memory content
-    } CTRL_REG0_XM_BITS_T;
-
-    /**
-     * CTRL_REG1_XM bits
-     */
-    typedef enum {
-      CTRL_REG1_XM_AXEN         = 0x01, // accelerometer x axis enable
-      CTRL_REG1_XM_AYEN         = 0x02,
-      CTRL_REG1_XM_AZEN         = 0x03,
-
-      CTRL_REG1_XM_BDU          = 0x04, // block data update
-
-      CTRL_REG1_XM_AODR0        = 0x10, // accelerometer output data rate
-      CTRL_REG1_XM_AODR1        = 0x20,
-      CTRL_REG1_XM_AODR2        = 0x40,
-      CTRL_REG1_XM_AODR3        = 0x80,
-      _CTRL_REG1_XM_AODR_MASK   = 15,
-      _CTRL_REG1_XM_AODR_SHIFT  = 4
-    } CTRL_REG1_XM_BITS_T;
-
-    /**
-     * CTRL_REG1_XM_AODR values
-     */
-    typedef enum {
-      XM_AODR_PWRDWN            = 0, // power down mode
-      XM_AODR_3_125             = 1, // 3.125 Hz
-      XM_AODR_6_25              = 2,
-      XM_AODR_12_5              = 3,
-      XM_AODR_25                = 4, // 25Hz
-      XM_AODR_50                = 5,
-      XM_AODR_100               = 6,
-      XM_AODR_200               = 7,
-      XM_AODR_400               = 8,
-      XM_AODR_800               = 9,
-      XM_AODR_1000              = 10
-      // 11-15 unused
-    } XM_AODR_T;
-
-    /**
-     * CTRL_REG2_XM bits
-     */
-    typedef enum {
-      CTRL_REG2_XM_SIM         = 0x01,
-
-      CTRL_REG2_XM_AST0        = 0x02, // accel self-test enable
-      CTRL_REG2_XM_AST1        = 0x04,
-      _CTRL_REG2_XM_AST_MASK   = 3,
-      _CTRL_REG2_XM_AST_SHIFT  = 1,
-
-      CTRL_REG2_XM_AFS0        = 0x08, // accel full scale
-      CTRL_REG2_XM_AFS1        = 0x10,
-      CTRL_REG2_XM_AFS2        = 0x20,
-      _CTRL_REG2_XM_AFS_MASK   = 7,
-      _CTRL_REG2_XM_AFS_SHIFT  = 3,
-
-      CTRL_REG2_XM_ABW0        = 0x40, // accel anti-alias filter bandwidth
-      CTRL_REG2_XM_ABW1        = 0x80,
-      _CTRL_REG2_XM_ABW_MASK   = 3,
-      _CTRL_REG2_XM_ABW_SHIFT  = 6
-    } CTRL_REG2_XM_BITS_T;
-
-    /**
-     * CTRL_REG2_XM_AST values
-     */
-    typedef enum {
-      XM_AST_NORMAL            = 0,
-      XM_AST_POS_SIGN          = 1,
-      XM_AST_NEG_SIGN          = 2
-      // 3 not allowed
-    } XM_AST_T;
-
-    /**
-     * CTRL_REG2_XM_AFS (accel full scale) values
-     */
-    typedef enum {
-      XM_AFS_2                 = 0, // 2g
-      XM_AFS_4                 = 1,
-      XM_AFS_6                 = 2,
-      XM_AFS_8                 = 3,
-      XM_AFS_16                = 4
-
-      // 5-7 not used
-    } XM_AFS_T;
-
-    /**
-     * CTRL_REG2_XM_ABW (accel anti-alias filter bandwidth) values
-     */
-    typedef enum {
-      XM_ABW_773               = 0, // 773Hz
-      XM_ABW_194               = 1, // these two might be inverted (typo in ds)
-      XM_ABW_362               = 2,
-      XM_ABW_50                = 3
-    } XM_ABW_T;
-
-    /**
-     * CTRL_REG3_XM bits
-     */
-    typedef enum {
-      CTRL_REG3_XM_P1_EMPTY    = 0x01, // INT1_XM pin enables
-      CTRL_REG3_XM_P1_DRDYM    = 0x02,
-      CTRL_REG3_XM_P1_DRDYA    = 0x04,
-      CTRL_REG3_XM_P1_INTM     = 0x08,
-      CTRL_REG3_XM_P1_INT2     = 0x10,
-      CTRL_REG3_XM_P1_INT1     = 0x20,
-      CTRL_REG3_XM_P1_TAP      = 0x40,
-      CTRL_REG3_XM_P1_BOOT     = 0x80
-    } CTRL_REG3_XM_BITS_T;
-
-    /**
-     * CTRL_REG4_XM bits
-     */
-    typedef enum {
-      CTRL_REG4_XM_P2_WTM      = 0x01, // INT2_XM pin enables
-      CTRL_REG4_XM_P2_OVERRUN  = 0x02,
-      CTRL_REG4_XM_P2_DRDYM    = 0x04,
-      CTRL_REG4_XM_P2_DRDYA    = 0x08,
-      CTRL_REG4_XM_P2_INTM     = 0x10,
-      CTRL_REG4_XM_P2_INT2     = 0x20,
-      CTRL_REG4_XM_P2_INT1     = 0x40,
-      CTRL_REG4_XM_P2_TAP      = 0x80
-    } CTRL_REG4_XM_BITS_T;
-
-    /**
-     * CTRL_REG5_XM bits
-     */
-    typedef enum {
-      CTRL_REG5_XM_LIR1        = 0x01, // latch intr 1
-      CTRL_REG5_XM_LIR2        = 0x02, // latch intr 2
-
-      CTRL_REG5_XM_ODR0        = 0x04, // mag output data rate
-      CTRL_REG5_XM_ODR1        = 0x08,
-      CTRL_REG5_XM_ODR2        = 0x10,
-      _CTRL_REG5_XM_ODR_MASK   = 7,
-      _CTRL_REG5_XM_ODR_SHIFT  = 2,
-
-      CTRL_REG5_XM_RES0        = 0x20, // mag resolution
-      CTRL_REG5_XM_RES1        = 0x40,
-      _CTRL_REG5_XM_RES_MASK   = 3,
-      _CTRL_REG5_XM_RES_SHIFT  = 5,
-
-      CTRL_REG5_XM_TEMP_EN     = 0x80  // temp sensor enable
-    } CTRL_REG5_XM_BITS_T;
-
-    /**
-     * CTRL_REG5_XM_ODR (magnetometer output data rate) values
-     */
-    typedef enum {
-      XM_ODR_3_125             = 0, // 3.125Hz
-      XM_ODR_6_25              = 1,
-      XM_ODR_12_5              = 2,
-      XM_ODR_25                = 3,
-      XM_ODR_50                = 4,
-      XM_ODR_100               = 5
-
-      // 6, 7 reserved
-    } XM_ODR_T;
-
-    /**
-     * CTRL_REG5_XM_RES (magnetometer resolution) values
-     */
-    typedef enum {
-      XM_RES_LOW               = 0, // low resolution
-
-      // 1, 2 reserved
-
-      XM_RES_HIGH              = 3,
-    } XM_RES_T;
-
-    /**
-     * CTRL_REG6_XM bits
-     */
-    typedef enum {
-      // 0x01-0x10 reserved
-
-      CTRL_REG6_XM_MFS0        = 0x20,
-      CTRL_REG6_XM_MFS1        = 0x40,
-      _CTRL_REG6_XM_MFS_MASK   = 3,
-      _CTRL_REG6_XM_MFS_SHIFT  = 5
-
-      // 0x80 reserved
-    } CTRL_REG6_XM_BITS_T;
-
-    /**
-     * CTRL_REG6_XM_MFS (magnetometer full scale) values
-     */
-    typedef enum {
-      XM_MFS_2                 = 0, // +/- 2 gauss
-      XM_MFS_4                 = 1,
-      XM_MFS_8                 = 2,
-      XM_MFS_12                = 3
-    } XM_MFS_T;
-
-    /**
-     * CTRL_REG7_XM bits
-     */
-    typedef enum {
-      CTRL_REG7_XM_MD0         = 0x01, // mag sensor mode
-      CTRL_REG7_XM_MD1         = 0x02,
-      _CTRL_REG7_XM_MD_MASK    = 3,
-      _CTRL_REG7_XM_MD_SHIFT   = 0,
-
-      CTRL_REG7_XM_MLP         = 0x04, // mag low power mode
-
-      // 0x08, 0x10 reserved
-
-      CTRL_REG7_XM_AFDS        = 0x20, // filtered acceleration data
-
-      CTRL_REG7_XM_AHPM0       = 0x40, // accel HPF selection
-      CTRL_REG7_XM_AHPM1       = 0x80,
-      _CTRL_REG7_XM_AHPM_MASK  = 3,
-      _CTRL_REG7_XM_AHPM_SHIFT = 6
-    } CTRL_REG7_XM_BITS_T;
-
-    /**
-     * CTRL_REG7_XM_MD (magnetometer sensor mode) values
-     */
-    typedef enum {
-      XM_MD_CONTINUOUS         = 0, // continuous conversion
-      XM_MD_SINGLE             = 1, // single conversion
-      XM_MD_POWERDOWN          = 2  // power down mode
-      // 3 is also power down mode, for some odd reason
-    } XM_MD_T;
-
-    /**
-     * CTRL_REG7_AHPM_MD (accel high-pass filter mode) values
-     */
-    typedef enum {
-      // XM_AHPM_NORMAL_REF: Normal mode (resets x, y and z-axis
-      // reading REFERENCE_X (1Ch), REFERENCE_Y (1Dh) and REFERENCE_Y
-      // (1Dh) registers respectively)
-
-      XM_AHPM_NORMAL_REF       = 0,
-      XM_AHPM_REFERENCE        = 1,
-      XM_AHPM_NORMAL           = 2,
-      XM_AHPM_AUTORESET        = 3  // autoreset on interrupt
-    } XM_AHPM_T;
-
-    /**
-     * XM STATUS_REG_A bits
-     */
-    typedef enum {
-      STATUS_REG_A_XADA         = 0x01, // X accel axis data available
-      STATUS_REG_A_YADA         = 0x02,
-      STATUS_REG_A_ZADA         = 0x04,
-      STATUS_REG_A_ZYXADA       = 0x08, // X, Y, and Z accel data available
-
-      STATUS_REG_A_XAOR         = 0x10, // X accel data overrun
-      STATUS_REG_A_YAOR         = 0x20,
-      STATUS_REG_A_ZAOR         = 0x40,
-      STATUS_REG_A_ZYXAOR       = 0x80
-    } STATUS_REG_A_BITS_T;
-
-    /**
-     * XM FIFO_CTRL_REG bits
-     */
-    typedef enum {
-      FIFO_CTRL_REG_FTH0        = 0x01, // FIFO watermark/threshold
-      FIFO_CTRL_REG_FTH1        = 0x02,
-      FIFO_CTRL_REG_FTH2        = 0x04,
-      FIFO_CTRL_REG_FTH3        = 0x08,
-      FIFO_CTRL_REG_FTH4        = 0x10,
-      _FIFO_CTRL_REG_FTH_MASK   = 31,
-      _FIFO_CTRL_REG_FTH_SHIFT  = 0,
-
-      FIFO_CTRL_REG_FM0         = 0x20, // FIFO mode config
-      FIFO_CTRL_REG_FM1         = 0x40,
-      FIFO_CTRL_REG_FM2         = 0x80,
-      _FIFO_CTRL_REG_FM_MASK    = 7,
-      _FIFO_CTRL_REG_FM_SHIFT   = 5,
-    } FIFO_CTRL_REG_T;
-
-    // FIFO_CTRL_REG_FTH (FIFO watermark/threshold) is just a numeric
-    // value between 0-31, so we won't enumerate those values.
-
-    /**
-     * XM FIFO_CTRL_REG_FM values (FIFO Modes)
-     *
-     */
-    typedef enum {
-      FM_BYPASS                 = 0,
-      FM_FIFO                   = 1,
-      FM_STREAM                 = 2,
-      FM_STREAM2FIFO            = 3,
-      FM_BYPASS2STREAM          = 4
-
-      // 5-7 unused
-    } FM_T;
-
-    /**
-     * FIFO_SRC_REG bits
-     *
-     */
-    typedef enum {
-      FIFO_CTRL_REG_FSS0        = 0x01, // FIFO stored data level
-      FIFO_CTRL_REG_FSS1        = 0x02,
-      FIFO_CTRL_REG_FSS2        = 0x04,
-      FIFO_CTRL_REG_FSS3        = 0x08,
-      FIFO_CTRL_REG_FSS4        = 0x10,
-      _FIFO_CTRL_REG_FSS_MASK   = 31,
-      _FIFO_CTRL_REG_FSS_SHIFT  = 0,
-
-      FIFO_CTRL_REG_EMPTY       = 0x20, // FIFO empty
-      FIFO_CTRL_REG_OVRN        = 0x40, // FIFO overrun
-      FIFO_CTRL_REG_WTM         = 0x80  // watermark status
-    } FIFO_SRC_REG_BITS_T;
-
-    /**
-     * INT_GEN_1_REG and INT_GEN_2_REG (GEN_X) bits
-     *
-     */
-    typedef enum {
-      INT_GEN_X_REG_XLIE_XDOWNE = 0x01, // enable intr on X low or dir recog
-      INT_GEN_X_REG_XHIE_XUPE   = 0x02,
-      INT_GEN_X_REG_YLIE_YDOWNE = 0x04,
-      INT_GEN_X_REG_YHIE_YUPE   = 0x08,
-      INT_GEN_X_REG_ZLIE_ZDOWNE = 0x10,
-      INT_GEN_X_REG_ZHIE_ZUPE   = 0x20,
-      INT_GEN_X_REG_6D          = 0x40, // enable 6D direction function
-      INT_GEN_X_REG_AOI         = 0x80  // AND/OR combination of intrs
-    } INT_GEN_X_REG_BITS_T;
-
-    /**
-     * INT_GEN_1_SRC and INT_GEN_2_SRC (GEN_X) bits
-     *
-     */
-    typedef enum {
-      INT_GEN_X_SRC_XL          = 0x01,
-      INT_GEN_X_SRC_XH          = 0x02,
-      INT_GEN_X_SRC_YL          = 0x04,
-      INT_GEN_X_SRC_YH          = 0x08,
-      INT_GEN_X_SRC_ZL          = 0x10,
-      INT_GEN_X_SRC_ZH          = 0x20,
-      INT_GEN_X_SRC_IA          = 0x40
-      // 0x80 reserved
-    } INT_GEN_X_SRC_BITS_T;
-
-    /**
-     * INT_GEN_1_THS and INT_GEN_2_THS (GEN_X) bits
-     *
-     */
-    typedef enum {
-      INT_GEN_X_THS0            = 0x01, // interrupt threshold
-      INT_GEN_X_THS1            = 0x02,
-      INT_GEN_X_THS2            = 0x04,
-      INT_GEN_X_THS3            = 0x08,
-      INT_GEN_X_THS4            = 0x10,
-      INT_GEN_X_THS5            = 0x20,
-      INT_GEN_X_THS6            = 0x40,
-      _INT_GEN_X_THS_MASK       = 127,
-      _INT_GEN_X_THS_SHIFT      = 0
-      // 0x80 reserved
-    } INT_GEN_X_THS_BITS_T;
-
-    /**
-     * INT_GEN_1_DUR and INT_GEN_2_DUR (GEN_X) bits
-     *
-     */
-    typedef enum {
-      INT_GEN_X_DUR0            = 0x01, // interrupt duration
-      INT_GEN_X_DUR1            = 0x02,
-      INT_GEN_X_DUR2            = 0x04,
-      INT_GEN_X_DUR3            = 0x08,
-      INT_GEN_X_DUR4            = 0x10,
-      INT_GEN_X_DUR5            = 0x20,
-      INT_GEN_X_DUR6            = 0x40,
-      _INT_GEN_X_DUR_MASK       = 127,
-      _INT_GEN_X_DUR_SHIFT      = 0
-      // 0x80 reserved
-    } INT_GEN_X_DUR_BITS_T;
-
-    /**
-     * CLICK_CONFIG bits
-     *
-     */
-    typedef enum {
-      CLICK_CONFIG_XS           = 0x01, // enable intr single click x
-      CLICK_CONFIG_XD           = 0x02, // enable intr double click x
-      CLICK_CONFIG_YS           = 0x04,
-      CLICK_CONFIG_YD           = 0x08,
-      CLICK_CONFIG_ZS           = 0x10,
-      CLICK_CONFIG_ZD           = 0x20
-      // 0x40, 0x80 reserved
-    } CLICK_CONFIG_BITS_T;
-
-    /**
-     * CLICK_SRC bits
-     *
-     */
-    typedef enum {
-      CLICK_SRC_X               = 0x01,
-      CLICK_SRC_Y               = 0x02,
-      CLICK_SRC_Z               = 0x04,
-      CLICK_SRC_SIGN            = 0x08,
-      CLICK_SRC_SCLICK          = 0x10,
-      CLICK_SRC_DCLICK          = 0x20,
-      CLICK_SRC_IA              = 0x40
-      // 0x80 reserved
-    } CLICK_SRC_BITS_T;
-
-    /**
-     * CLICK_THS bits
-     *
-     */
-    typedef enum {
-      CLICK_THS_THS0            = 0x01, // click threshold
-      CLICK_THS_THS1            = 0x02,
-      CLICK_THS_THS2            = 0x04,
-      CLICK_THS_THS3            = 0x08,
-      CLICK_THS_THS4            = 0x10,
-      CLICK_THS_THS5            = 0x20,
-      CLICK_THS_THS6            = 0x40,
-      _CLICK_THS_THS_MASK       = 127,
-      _CLICK_THS_THS_SHIFT      = 0
-      // 0x80 reserved
-    } CLICK_THS_BITS_T;
-
-    /**
-     * CLICK_TIME_LIMIT bits
-     *
-     */
-    typedef enum {
-      CLICK_TIME_LIMIT_TLI0     = 0x01,
-      CLICK_TIME_LIMIT_TLI1     = 0x02,
-      CLICK_TIME_LIMIT_TLI2     = 0x04,
-      CLICK_TIME_LIMIT_TLI3     = 0x08,
-      CLICK_TIME_LIMIT_TLI4     = 0x10,
-      CLICK_TIME_LIMIT_TLI5     = 0x20,
-      CLICK_TIME_LIMIT_TLI6     = 0x40,
-      _CLICK_TIME_LIMIT_TLI_MASK = 127,
-      _CLICK_TIME_LIMIT_TLI_SHIFT = 0
-      // 0x80 reserved
-    } CLICK_TIME_LIMIT_BITS_T;
-
-    /**
-     * ACT_THS (sleep-to-wake/return-to-sleep activation threshold) bits
-     *
-     */
-    typedef enum {
-      ACT_THS_ACTH0             = 0x01, // 1 LSb = 16mg (?)
-      ACT_THS_ACTH1             = 0x02,
-      ACT_THS_ACTH2             = 0x04,
-      ACT_THS_ACTH3             = 0x08,
-      ACT_THS_ACTH4             = 0x10,
-      ACT_THS_ACTH5             = 0x20,
-      ACT_THS_ACTH6             = 0x40,
-      _ACT_THS_ACTH_MASK        = 127,
-      _ACT_THS_ACTH_SHIFT       = 0
-      // 0x80 reserved
-    } ACT_THS_BITS_T;
-
-    // Driver specific enumerations
-
-    // device enums for read/write regs
-    typedef enum {
-      DEV_GYRO,
-      DEV_XM
-    } DEVICE_T;
-
-    // interrupt selection for installISR() and uninstallISR()
-    typedef enum {
-      INTERRUPT_G_INT,  // gyroscope interrupt
-      INTERRUPT_G_DRDY, // gyroscope data ready interrupt
-      INTERRUPT_XM_GEN1, // XM interrupt generator 1
-      INTERRUPT_XM_GEN2  // XM interrupt generator 2
-    } INTERRUPT_PINS_T;
-
-
-    /**
-     * lsm9ds0 constructor
-     *
-     * @param bus i2c bus to use
-     * @param raw bypass board definition file, set to true if using Sparkfun
-     * 9DOF Block on an Intel Edison Arduino board
-     * @param gAddress the gyroscope address for this device
-     * @param xmAddress the accelerometer/magnetometer address for this device
-     */
-    LSM9DS0(int bus=LSM9DS0_I2C_BUS,
-            bool raw=false,
-            uint8_t gAddress=LSM9DS0_DEFAULT_GYRO_ADDR,
-            uint8_t xmAddress=LSM9DS0_DEFAULT_XM_ADDR);
-
-    /**
-     * LSM9DS0 Destructor
-     */
-    ~LSM9DS0();
-
-    /**
-     * set up initial values and start operation
-     *
-     * @return true if successful
-     */
-    bool init();
-
-    /**
-     * update the accelerometer, gyroscope, magnetometer and
-     * termperature values.
-     */
-    void update();
-
-    /**
-     * update the gyroscope values only
-     */
-    void updateGyroscope();
-
-    /**
-     * update the accelerometer values only
-     */
-    void updateAccelerometer();
-
-    /**
-     * update the magnetometer values only
-     */
-    void updateMagnetometer();
-
-    /**
-     * update the temperature value only
-     */
-    void updateTemperature();
-
-    /**
-     * read a register
-     *
-     * @param dev the device to access (XM or G)
-     * @param reg the register to read
-     * @return the value of the register
-     */
-    uint8_t readReg(DEVICE_T dev, uint8_t reg);
-
-    /**
-     * read contiguous register into a buffer
-     *
-     * @param dev the device to access (XM or G)
-     * @param reg the register to start reading at
-     * @param buf the buffer to store the results
-     * @param len the number of registers to read
-     * @return the value of the register
-     */
-    void readRegs(DEVICE_T dev, uint8_t reg, uint8_t *buffer, int len);
-
-    /**
-     * write to a register
-     *
-     * @param dev the device to access (XM or G)
-     * @param reg the register to write to
-     * @param val the value to write
-     * @return true if successful, false otherwise
-     */
-    bool writeReg(DEVICE_T dev, uint8_t reg, uint8_t val);
-
-    /**
-     * enable or disable the gyro power down mode
-     *
-     * @param enable true to put device to sleep, false to wake up
-     * @return true if successful, false otherwise
-     */
-    bool setGyroscopePowerDown(bool enable);
-
-    /**
-     * enable or disable gyroscope axes.  If all axis are disabled,
-     * and powerdown mode is not set, then the gyro goes into sleep
-     * mode.
-     *
-     * @param axes bit mask of valid axes, (CTRL_REG1_G_YEN, ...)
-     * @return true if successful, false otherwise
-     */
-    bool setGyroscopeEnableAxes(uint8_t axes);
-
-    /**
-     * set the gyroscope Output Data Rate (ODR)
-     *
-     * @param odr one of the G_ODR_T values
-     * @return true if successful, false otherwise
-     */
-    bool setGyroscopeODR(G_ODR_T odr);
-
-    /**
-     * set the scaling mode of the gyroscope
-     *
-     * @param scale one of the G_FS_T values
-     * @return true if successful, false otherwise
-     */
-    bool setGyroscopeScale(G_FS_T scale);
-
-    /**
-     * enable or disable accelerometer axes.
-     *
-     * @param axes bit mask of valid axes, (CTRL_REG1_XM_AXEN, ...)
-     * @return true if successful, false otherwise
-     */
-    bool setAccelerometerEnableAxes(uint8_t axes);
-
-    /**
-     * set the accelerometer Output Data Rate (ODR)
-     *
-     * @param odr one of the XM_AODR_T values
-     * @return true if successful, false otherwise
-     */
-    bool setAccelerometerODR(XM_AODR_T odr);
-
-    /**
-     * set the scaling mode of the accelerometer
-     *
-     * @param scale one of the XM_AFS_T values
-     * @return true if successful, false otherwise
-     */
-    bool setAccelerometerScale(XM_AFS_T scale);
-
-    /**
-     * set the magnetometer resolution
-     *
-     * @param res one of the XM_RES_T values
-     * @return true if successful, false otherwise
-     */
-    bool setMagnetometerResolution(XM_RES_T res);
-
-    /**
-     * set the magnetometer Output Data Rate (ODR)
-     *
-     * @param odr one of the XM_ODR_T values
-     * @return true if successful, false otherwise
-     */
-    bool setMagnetometerODR(XM_ODR_T odr);
-
-    /**
-     * set the magnetometer sensor mode
-     *
-     * @param mode one of the XM_MD_T values
-     * @return true if successful, false otherwise
-     */
-    bool setMagnetometerMode(XM_MD_T mode);
-
-    /**
-     * enable or disable magnetometer low power mode (LPM).  When in
-     * low power mode, the magnetometer updates at 3.125Hz, regardless
-     * of it's ODR setting.
-     *
-     * @param enable true to enable LPM, false otherwise
-     * @return true if successful, false otherwise
-     */
-    bool setMagnetometerLPM(bool enable);
-
-    /**
-     * set the scaling mode of the magnetometer
-     *
-     * @param scale one of the XM_MFS_T values
-     * @return true if successful, false otherwise
-     */
-    bool setMagnetometerScale(XM_MFS_T scale);
-
-    /**
-     * get the accelerometer values in gravities
-     *
-     * @param x the returned x value, if arg is non-NULL
-     * @param y the returned y value, if arg is non-NULL
-     * @param z the returned z value, if arg is non-NULL
-     * @return true if successful, false otherwise
-     */
-    void getAccelerometer(float *x, float *y, float *z);
-
-    /**
-     * get the gyroscope values in degrees per second
-     *
-     * @param x the returned x value, if arg is non-NULL
-     * @param y the returned y value, if arg is non-NULL
-     * @param z the returned z value, if arg is non-NULL
-     * @return true if successful, false otherwise
-     */
-    void getGyroscope(float *x, float *y, float *z);
-
-    /**
-     * get the magnetometer values in gauss
-     *
-     * @param x the returned x value, if arg is non-NULL
-     * @param y the returned y value, if arg is non-NULL
-     * @param z the returned z value, if arg is non-NULL
-     * @return true if successful, false otherwise
-     */
-    void getMagnetometer(float *x, float *y, float *z);
-
-    /**
-     * get the accelerometer values in gravities
-     *
-     * @return std::vector containing X, Y, Z acceleration values
-     */
-    std::vector<float> getAccelerometer();
-
-    /**
-     * get the gyroscope values in degrees per second
-     *
-     * @return std::vector containing X, Y, Z gyroscope values
-     */
-    std::vector<float> getGyroscope();
-
-    /**
-     * get the magnetometer values in gauss
-     *
-     * @return std::vector containing X, Y, Z magnetometer values
-     */
-    std::vector<float> getMagnetometer();
-
-    /**
-     * get the temperature value.  Unfortunately the datasheet does
-     * not provide a mechanism to convert the temperature value into
-     * the correct value, so I made a 'guess'.  If it's wrong, and you
-     * figure it out, send a patch!
-     *
-     * @return the temperature value in degrees Celsius
-     */
-    float getTemperature();
-
-    /**
-     * enable onboard temperature measurement sensor
-     *
-     * @param enable true to enable temperature sensor, false to disable
-     * @return true if successful, false otherwise
-     */
-    bool enableTemperatureSensor(bool enable);
-
-    /**
-     * return the gyroscope status register
-     *
-     * @return bitmask of STATUS_REG_G_BITS_T bits
-     */
-    uint8_t getGyroscopeStatus();
-
-    /**
-     * return the magnetometer status register
-     *
-     * @return bitmask of STATUS_REG_M_BITS_T bits
-     */
-    uint8_t getMagnetometerStatus();
-
-    /**
-     * return the accelerometer status register
-     *
-     * @return bitmask of STATUS_REG_A_BITS_T bits
-     */
-    uint8_t getAccelerometerStatus();
-
-    /**
-     * return the gyroscope interrupt config register
-     *
-     * @return bitmask of INT1_CFG_G_BITS_T bits
-     */
-    uint8_t getGyroscopeInterruptConfig();
-
-    /**
-     * set the gyroscope interrupt config register
-     *
-     * @param enables bitmask of INT1_CFG_G_BITS_T values
-     * @return true if successful
-     */
-    bool setGyroscopeInterruptConfig(uint8_t enables);
-
-    /**
-     * return the gyroscope interrupt src register
-     *
-     * @return bitmask of INT1_SRC_G_BITS_T bits
-     */
-    uint8_t getGyroscopeInterruptSrc();
-
-    /**
-     * return the magnetometer interrupt control register
-     *
-     * @return bitmask of INT_CTRL_REG_M_BITS_T bits
-     */
-    uint8_t getMagnetometerInterruptControl();
-
-    /**
-     * set the magnetometer interrupt control register
-     *
-     * @param enables bitmask of INT_CTRL_REG_M_BITS_T values
-     * @return true if successful
-     */
-    bool setMagnetometerInterruptControl(uint8_t enables);
-
-    /**
-     * return the magnetometer interrupt src register
-     *
-     * @return bitmask of INT_SRC_REG_M_BITS_T bits
-     */
-    uint8_t getMagnetometerInterruptSrc();
-
-    /**
-     * return the inertial interrupt generator 1 register
-     *
-     * @return bitmask of INT_GEN_X_REG_BITS_T bits
-     */
-    uint8_t getInterruptGen1();
-
-    /**
-     * set the inertial interrupt generator 1 register
-     *
-     * @param enables bitmask of INT_GEN_X_REG_BITS_T values
-     * @return true if successful
-     */
-    bool setInterruptGen1(uint8_t enables);
-
-    /**
-     * return the inertial interrupt generator 1 src register
-     *
-     * @return bitmask of INT_GEN_X_SRC_BITS_T bits
-     */
-    uint8_t getInterruptGen1Src();
-
-    /**
-     * return the inertial interrupt generator 2 register
-     *
-     * @return bitmask of INT_GEN_X_REG_BITS_T bits
-     */
-    uint8_t getInterruptGen2();
-
-    /**
-     * set the inertial interrupt generator 2 register
-     *
-     * @param enables bitmask of INT_GEN_X_REG_BITS_T values
-     * @return true if successful
-     */
-    bool setInterruptGen2(uint8_t enables);
-
-    /**
-     * return the inertial interrupt generator 2 src register
-     *
-     * @return bitmask of INT_GEN_X_SRC_BITS_T bits
-     */
-    uint8_t getInterruptGen2Src();
-
-
-    /**
-     * install an interrupt handler.
-     *
-     * @param intr one of the INTERRUPT_PINS_T values specifying which
-     * interrupt pin out of 4 you are installing
-     * @param gpio gpio pin to use as interrupt pin
-     * @param level the interrupt trigger level (one of mraa::Edge
-     * values).  Make sure that you have configured the interrupt pin
-     * properly for whatever level you choose.
-     * @param isr the interrupt handler, accepting a void * argument
-     * @param arg the argument to pass the the interrupt handler
-     */
-    void installISR(INTERRUPT_PINS_T intr, int gpio, mraa::Edge level,
-                    void (*isr)(void *), void *arg);
-
-    /**
-     * uninstall a previously installed interrupt handler
-     *
-     * @param intr one of the INTERRUPT_PINS_T values specifying which
-     * interrupt pin out of 4 you are uninstalling
-     */
-    void uninstallISR(INTERRUPT_PINS_T intr);
-
-  protected:
-    // uncompensated accelerometer and gyroscope values
-    float m_accelX;
-    float m_accelY;
-    float m_accelZ;
-
-    float m_gyroX;
-    float m_gyroY;
-    float m_gyroZ;
-
-    float m_magX;
-    float m_magY;
-    float m_magZ;
-
-    // uncompensated temperature value
-    float m_temp;
-
-    // accelerometer and gyro scaling factors, depending on their Full
-    // Scale settings.
-    float m_accelScale;
-    float m_gyroScale;
-    float m_magScale;
-
-  private:
-    // OR'd with a register, this enables register autoincrement mode,
-    // which we need.
-    static const uint8_t m_autoIncrementMode = 0x80;
-
-    mraa::I2c m_i2cG;
-    mraa::I2c m_i2cXM;
-    uint8_t m_gAddr;
-    uint8_t m_xmAddr;
-
-    // return a reference to a gpio pin pointer depending on intr
-    mraa::Gpio*& getPin(INTERRUPT_PINS_T intr);
-
-    // possible interrupt pins
-    mraa::Gpio *m_gpioG_INT;
-    mraa::Gpio *m_gpioG_DRDY;
-    mraa::Gpio *m_gpioXM_GEN1;
-    mraa::Gpio *m_gpioXM_GEN2;
-  };
-}
diff --git a/src/lsm9ds0/lsm9ds0.i b/src/lsm9ds0/lsm9ds0.i
deleted file mode 100644
index a6aeaf6..0000000
--- a/src/lsm9ds0/lsm9ds0.i
+++ /dev/null
@@ -1,69 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "arrays_java.i";
-%include "../java_buffer.i"
-
-%apply int {mraa::Edge};
-%apply float *INOUT { float *x, float *y, float *z };
-
-%typemap(jni) float* "jfloatArray"
-%typemap(jstype) float* "float[]"
-%typemap(jtype) float* "float[]"
-
-%typemap(javaout) float* {
-    return $jnicall;
-}
-
-%typemap(out) float *getAccelerometer {
-    $result = JCALL1(NewFloatArray, jenv, 3);
-    JCALL4(SetFloatArrayRegion, jenv, $result, 0, 3, $1);
-    delete [] $1;
-}
-
-%typemap(out) float *getGyroscope {
-    $result = JCALL1(NewFloatArray, jenv, 3);
-    JCALL4(SetFloatArrayRegion, jenv, $result, 0, 3, $1);
-    delete [] $1;
-}
-
-%typemap(out) float *getMagnetometer {
-    $result = JCALL1(NewFloatArray, jenv, 3);
-    JCALL4(SetFloatArrayRegion, jenv, $result, 0, 3, $1);
-    delete [] $1;
-}
-
-%ignore getAccelerometer(float *, float *, float *);
-%ignore getGyroscope(float *, float *, float *);
-%ignore getMagnetometer(float *, float *, float *);
-
-%ignore installISR(INTERRUPT_PINS_T, int, mraa::Edge, void *, void *);
-
-%define INTERRUPT INTERRUPT_PINS_T
-%enddef
-
-JAVA_ADD_INSTALLISR_INTERRUPT(upm::LSM9DS0)
-
-JAVA_JNI_LOADLIBRARY(javaupm_lsm9ds0)
-#endif
-/* END Java syntax */
-
-/* BEGIN Javascript syntax  ------------------------------------------------- */
-#ifdef SWIGJAVASCRIPT
-%pointer_functions(float, floatp);
-#endif
-/* END Javascript syntax */
-
-/* BEGIN Python syntax  ----------------------------------------------------- */
-#ifdef SWIGPYTHON
-%pointer_functions(float, floatp);
-#endif
-/* END Python syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "lsm9ds0.hpp"
-%}
-%include "lsm9ds0.hpp"
-/* END Common SWIG syntax */
diff --git a/src/lsm9ds0/lsm9ds0.json b/src/lsm9ds0/lsm9ds0.json
deleted file mode 100644
index 0394f8d..0000000
--- a/src/lsm9ds0/lsm9ds0.json
+++ /dev/null
@@ -1,39 +0,0 @@
-{
-    "Library": "lsm9ds0",
-    "Description": "API for the LSM9DS0 Gyroscope/Accelerometer/Magnetometer",
-    "Sensor Class":
-    {
-        "LSM9DS0":
-        {
-            "Name": "Triaxial Gyroscope/Accelerometer/Magnetometer Sensor",
-            "Description": "The LSM9DS0 is a system-in-package featuring a 3D digital linear acceleration sensor, a 3D digital angular rate sensor, and a 3D digital magnetic sensor. The LSM9DS0 has a linear acceleration full scale of 2g/4g/6g/8g/16g, a magnetic field full scale of 2/4/8/12 gauss and an angular rate of 245/500/2000 dps. While not all of the functionality of this device is supported initially, methods and register definitions are provided that should allow an end user to implement whatever features are required. This driver was developed on a Sparkfun 9DOF edison block.",
-            "Aliases": ["lsm9ds0"],
-            "Categories": ["gyroscope", "accelerometer", "magnetometer"],
-            "Connections": ["i2c", "gpio"],
-            "Project Type": ["robotics", "wearables", "prototyping"],
-            "Manufacturers": ["sparkfun", "stmicro"],
-            "Kits": [],
-            "Image": "lsm9ds0.jpg",
-            "Examples":
-            {
-                "Java": [],
-                "Python": ["lsm9ds0.py"],
-                "Node.js": ["lsm9ds0.js"],
-                "C++": ["lsm9ds0.cxx"],
-                "C": []
-            },
-            "Specifications":
-            {
-                "Accelerometer Range (+-)": {"unit": "g", "low": 2, "high": 16},
-                "Magnetometer Range (+-)": {"unit": "gauss", "low": 2, "high": 12},
-                "Gyroscope Range (+-)": {"unit": "deg/s", "low": 245, "high": 2000}
-            },
-            "Urls" :
-            {
-                "Product Pages": ["https://www.sparkfun.com/products/13033"],
-                "Datasheets": [],
-                "Schematics": ["https://cdn.sparkfun.com/datasheets/Dev/Edison/9dof_block.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/m24lr64e/CMakeLists.txt b/src/m24lr64e/CMakeLists.txt
deleted file mode 100644
index 65a4442..0000000
--- a/src/m24lr64e/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME m24lr64e
-    DESCRIPTION "Dynamic NFC/RFID Tag Module"
-    C_HDR m24lr64e.h
-    C_SRC m24lr64e.c
-    CPP_HDR m24lr64e.hpp
-    CPP_SRC m24lr64e.cxx
-    FTI_SRC m24lr64e_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/m24lr64e/m24lr64e.c b/src/m24lr64e/m24lr64e.c
deleted file mode 100644
index a6d39bf..0000000
--- a/src/m24lr64e/m24lr64e.c
+++ /dev/null
@@ -1,344 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- *
- * This code was adapted from the Seeed Studio code at:
- * https://github.com/Seeed-Studio/NFC_Tag_M24LR6E
- *
- * Copyright (c) 2014 seeed technology inc.
- * Website    : www.seeed.cc
- * Author     : lawliet zou
- * Create Time: March 2014
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "m24lr64e.h"
-#include "upm_utilities.h"
-
-// forward declarations - these were protected methods in original C++
-// code.  Might need to expose them?
-upm_result_t m24lr64e_eeprom_read_byte(m24lr64e_context dev,
-                                       uint32_t address, uint8_t* data);
-upm_result_t m24lr64e_eeprom_read_bytes(m24lr64e_context dev,
-                                        uint32_t address,
-                                        uint8_t* data, int len);
-upm_result_t m24lr64e_eeprom_write_byte(m24lr64e_context dev,
-                                        uint32_t address, uint8_t data);
-upm_result_t m24lr64e_eeprom_write_bytes(m24lr64e_context dev,
-                                         uint32_t address,
-                                         uint8_t* data, int len);
-
-m24lr64e_context m24lr64e_init(int bus, m24lr64e_access_mode mode){
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        return NULL;
-    }
-
-    m24lr64e_context dev =
-      (m24lr64e_context)malloc(sizeof(struct _m24lr64e_context));
-
-    if (!dev)
-      return NULL;
-
-    dev->bus = bus;
-    dev->mode = mode;
-
-    if (dev->mode == M24LR64E_USER_MODE)
-        dev->address = M24LR64E_DEFAULT_I2C_ADDR;
-    else
-        dev->address = M24LR64E_DEFAULT_I2C_ADDR_E2;
-
-    dev->i2c = mraa_i2c_init(dev->bus);
-    if (mraa_i2c_address(dev->i2c, dev->address) != MRAA_SUCCESS) {
-        return NULL;
-    }
-
-    return dev;
-}
-
-void m24lr64e_close(m24lr64e_context dev){
-    mraa_i2c_stop(dev->i2c);
-    free(dev);
-}
-
-upm_result_t m24lr64e_submit_password(m24lr64e_context dev,
-                                      uint32_t password){
-    // this device actually uses two bytes to address a register
-    const int pktLen = 11;
-    uint8_t buf[pktLen];
-
-    buf[0] = 0x09;
-    buf[1] = 0x00;
-
-    buf[2] = ((password >> 24) & 0xff);
-    buf[3] = ((password >> 16) & 0xff);
-    buf[4] = ((password >> 8) & 0xff);
-    buf[5] = (password & 0xff);
-
-    buf[6] = 0x09;
-
-    // the password is written twice
-    buf[7] = ((password >> 24) & 0xff);
-    buf[8] = ((password >> 16) & 0xff);
-    buf[9] = ((password >> 8) & 0xff);
-    buf[10] = (password & 0xff);
-
-    if (mraa_i2c_write(dev->i2c, buf, pktLen) != MRAA_SUCCESS){
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-    return UPM_SUCCESS;
-}
-
-upm_result_t m24lr64e_write_password(m24lr64e_context dev, uint32_t password){
-    const int pktLen = 11;
-    uint8_t buf[pktLen];
-
-    buf[0] = 0x09;
-    buf[1] = 0x00;
-
-    buf[2] = ((password >> 24) & 0xff);
-    buf[3] = ((password >> 16) & 0xff);
-    buf[4] = ((password >> 8) & 0xff);
-    buf[5] = (password & 0xff);
-
-    buf[6] = 0x07;
-
-    // the password is written twice
-    buf[7] = ((password >> 24) & 0xff);
-    buf[8] = ((password >> 16) & 0xff);
-    buf[9] = ((password >> 8) & 0xff);
-    buf[10] = (password & 0xff);
-
-    if(mraa_i2c_write(dev->i2c, buf, pktLen) != MRAA_SUCCESS){
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-    return UPM_SUCCESS;
-}
-
-upm_result_t m24lr64e_sector_protect_config(m24lr64e_context dev,
-                                            uint32_t sector_number,
-                                            bool protect_enable,
-                                            sector_access_right access_right,
-                                            sector_select_password password){
-    if(!protect_enable){
-        m24lr64e_write_byte(dev, sector_number, 0x0);
-    }
-    else{
-        m24lr64e_write_byte(dev, sector_number,
-                            (protect_enable | (access_right << 1) |
-                             (password << 2)));
-    }
-    return UPM_SUCCESS;
-}
-
-upm_result_t m24lr64e_clear_sector_protect(m24lr64e_context dev){
-    uint8_t buf[64]={0x0};
-    return m24lr64e_eeprom_write_bytes(dev, 0, buf, 64);
-}
-
-upm_result_t m24lr64e_sector_write_lock_bit(m24lr64e_context dev,
-                                                uint32_t sector_number,
-                                                bool sock_enable){
-    uint32_t sector_address = M24LR64E_SECTOR_SECURITY_STATUS_BASE_ADDR
-        + (sector_number/8);
-
-    uint8_t sector_bit = sector_number % 8;
-    // byte read from the EEPROM into pre_status
-    uint8_t pre_status;
-    m24lr64e_eeprom_read_byte(dev, sector_address, &pre_status);
-
-    bool status = (pre_status >> sector_bit) & 0x01;
-    if(status != sock_enable){
-        if(status == true){
-            // Call to write byte function
-            m24lr64e_write_byte(dev, sector_address, pre_status&(~(1<<sector_bit)));
-        }
-        else{
-            // another call to write byte function
-            m24lr64e_write_byte(dev, sector_address, pre_status|(1<<sector_bit));
-        }
-    }
-    return UPM_SUCCESS;
-}
-
-upm_result_t m24lr64e_get_dsfid(m24lr64e_context dev, uint8_t* dsfid){
-    // EEPROM read byte function call
-    return m24lr64e_eeprom_read_byte(dev, M24LR64E_DSFID_ADDRESS, dsfid);
-}
-
-upm_result_t m24lr64e_get_afi(m24lr64e_context dev, uint8_t* afi){
-    // call to EEPROM read byte
-    return m24lr64e_eeprom_read_byte(dev, M24LR64E_AFI_ADDRESS, afi);
-}
-
-upm_result_t m24lr64e_get_uid(m24lr64e_context dev, uint8_t* uid){
-    //uint8_t* buffer;
-    //uint8_t arr[M24LR64E_UID_LENGTH];
-    //buffer = arr;
-    // call to EEPROM read bytes
-    m24lr64e_eeprom_read_bytes(dev, M24LR64E_UID_ADDRESS, uid,
-                               M24LR64E_UID_LENGTH);
-    // not so sure about this
-//#warning "THIS NEEDS FIXING"
-    //*uid = *buffer;
-    return UPM_SUCCESS;
-}
-
-upm_result_t m24lr64e_get_memory_size(m24lr64e_context dev,
-                                      uint32_t* memory_size){
-    uint32_t volume = 0x0;
-    uint8_t temp_vol = 0x0;
-    // us the EEPROM read byte function to calculate the volume
-    if (m24lr64e_eeprom_read_byte(dev, M24LR64E_MEM_SIZE_ADDRESS,
-                                 &temp_vol) != UPM_SUCCESS){
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-    volume = temp_vol;
-    if (m24lr64e_eeprom_read_byte(dev, M24LR64E_MEM_SIZE_ADDRESS+1,
-                                  &temp_vol) != UPM_SUCCESS){
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-    volume = volume<<8|temp_vol;
-    temp_vol = 0x0;
-    if (m24lr64e_eeprom_read_byte(dev, M24LR64E_MEM_SIZE_ADDRESS+2,
-                                  &temp_vol) != UPM_SUCCESS){
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-    volume = volume << 8 | temp_vol;
-    *memory_size = volume;
-    return UPM_SUCCESS;
-}
-
-upm_result_t m24lr64e_clear_memory(m24lr64e_context dev){
-    int i=0;
-    for(i = 0; i < M24LR64E_EEPROM_I2C_LENGTH; i++){
-        // call to write byte function
-        m24lr64e_write_byte(dev, i, 0x0);
-    }
-    return UPM_SUCCESS;
-}
-
-upm_result_t m24lr64e_write_byte(m24lr64e_context dev, uint32_t address,
-                                 uint8_t data){
-    // call to EEPROM write byte
-    return m24lr64e_eeprom_write_byte(dev, address, data);
-}
-
-upm_result_t m24lr64e_write_bytes(m24lr64e_context dev,
-                                  uint32_t address, uint8_t* buffer, int len){
-    // call to EEPROM write bytes
-    return m24lr64e_eeprom_write_bytes(dev, address, buffer, len);
-}
-
-upm_result_t m24lr64e_read_byte(m24lr64e_context dev, uint32_t address,
-                                uint8_t* data){
-    // call to EEPROM read byte
-    return m24lr64e_eeprom_read_byte(dev, address, data);
-}
-
-upm_result_t m24lr64e_read_bytes(m24lr64e_context dev, uint32_t address,
-                                 uint8_t* buffer, int len){
-    // call to EEPROM read bytes
-    return m24lr64e_eeprom_write_bytes(dev, address, buffer, len);
-}
-
-upm_result_t m24lr64e_eeprom_write_byte(m24lr64e_context dev, uint32_t address,
-                                        uint8_t data){
-    int pkt_len = 3;
-    uint8_t buf[pkt_len];
-    buf[0] = ((address >> 8) & 0xff);
-    buf[1] = (address & 0xff);
-    buf[2] = data;
-
-    if (mraa_i2c_write(dev->i2c, buf, pkt_len) != MRAA_SUCCESS){
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    upm_delay_us(M24LR64E_I2C_WRITE_TIME*1000);
-    return UPM_SUCCESS;
-}
-
-upm_result_t m24lr64e_eeprom_write_bytes(m24lr64e_context dev,
-                                         uint32_t address, uint8_t* data,
-                                         int len){
-    uint32_t pkt_len = 2 + len;
-    uint8_t buf[pkt_len];
-
-    buf[0] = ((address >> 8) & 0xff);
-    buf[1] = (address & 0xff);
-
-    int i = 0;
-    for (i=0; i<len; i++)
-        buf[2+i] = data[i];
-
-    if (mraa_i2c_write(dev->i2c, buf, pkt_len) != MRAA_SUCCESS){
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-    upm_delay_us(M24LR64E_I2C_WRITE_TIME*1000);
-    return UPM_SUCCESS;
-}
-
-upm_result_t m24lr64e_eeprom_read_byte(m24lr64e_context dev, uint32_t address,
-                                       uint8_t* data){
-    int pkt_len = 2;
-    uint8_t buf[pkt_len];
-
-    buf[0] = ((address >> 8) & 0xff);
-    buf[1] = (address & 0xff);
-
-    if (mraa_i2c_write(dev->i2c, buf, pkt_len) != MRAA_SUCCESS){
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    pkt_len = 1;
-    uint8_t abuf[pkt_len];
-    abuf[0] = 0;
-
-    if (mraa_i2c_read(dev->i2c, abuf, pkt_len) != pkt_len){
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-    *data = abuf[0];
-    return UPM_SUCCESS;
-}
-
-upm_result_t m24lr64e_eeprom_read_bytes(m24lr64e_context dev, uint32_t address,
-                                        uint8_t* data, int len){
-    uint32_t pkt_len = 2;
-    uint8_t buf[pkt_len];
-
-    buf[0] = ((address >> 8) & 0xff);
-    buf[1] = (address & 0xff);
-
-    if (mraa_i2c_write(dev->i2c, buf, pkt_len) != MRAA_SUCCESS){
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    if(mraa_i2c_read(dev->i2c, data, len) != len){
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
diff --git a/src/m24lr64e/m24lr64e.cxx b/src/m24lr64e/m24lr64e.cxx
deleted file mode 100644
index a4e1cd7..0000000
--- a/src/m24lr64e/m24lr64e.cxx
+++ /dev/null
@@ -1,306 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <math.h>
-#include <iostream>
-#include <string>
-
-#include "m24lr64e.hpp"
-
-using namespace upm;
-using namespace std;
-
-
-M24LR64E::M24LR64E(int bus, AccessMode mode):
-  m_i2c(bus)
-{
-  if (mode == USER_MODE)
-    m_addr = M24LR64E_DEFAULT_I2C_ADDR;
-  else
-    m_addr = M24LR64E_DEFAULT_I2C_ADDR_E2;
-
-  mraa::Result rv;
-  if ( (rv = m_i2c.address(m_addr)) != mraa::SUCCESS)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": I2c.address() failed");
-      return;
-    }
-}
-
-M24LR64E::~M24LR64E()
-{
-}
-
-bool M24LR64E::submitPasswd(uint32_t passwd)
-{
-  // this device actually uses two bytes to address a register
-  const int pktLen = 11;
-  uint8_t buf[pktLen];
-
-  buf[0] = 0x09;
-  buf[1] = 0x00;
-
-  buf[2] = ((passwd >> 24) & 0xff);
-  buf[3] = ((passwd >> 16) & 0xff);
-  buf[4] = ((passwd >> 8) & 0xff);
-  buf[5] = (passwd & 0xff);
-
-  buf[6] = 0x09;
-
-  // the password is written twice
-  buf[7] = ((passwd >> 24) & 0xff);
-  buf[8] = ((passwd >> 16) & 0xff);
-  buf[9] = ((passwd >> 8) & 0xff);
-  buf[10] = (passwd & 0xff);
-  
-  if (m_i2c.write(buf, pktLen))
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": I2c.write() failed");
-      return false;
-    }
-
-  return true;
-}
-
-bool M24LR64E::writePasswd(uint32_t passwd)
-{
-  const int pktLen = 11;
-  uint8_t buf[pktLen];
-
-  buf[0] = 0x09;
-  buf[1] = 0x00;
-
-  buf[2] = ((passwd >> 24) & 0xff);
-  buf[3] = ((passwd >> 16) & 0xff);
-  buf[4] = ((passwd >> 8) & 0xff);
-  buf[5] = (passwd & 0xff);
-
-  buf[6] = 0x07;
-
-  // the password is written twice
-  buf[7] = ((passwd >> 24) & 0xff);
-  buf[8] = ((passwd >> 16) & 0xff);
-  buf[9] = ((passwd >> 8) & 0xff);
-  buf[10] = (passwd & 0xff);
-  
-  if (m_i2c.write(buf, pktLen))
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": I2c.write() failed");
-      return false;
-    }
-
-  return true;
-}
-
-void M24LR64E::sectorProtectConfig(unsigned int sectorNumber, 
-                                   bool protectEnable, 
-                                   SectorAccessRight accessRight, 
-                                   SectorSelectPassWd passwd)
-{
-  if(!protectEnable) {
-    EEPROM_Write_Byte(sectorNumber,0x0);
-  } else {
-    EEPROM_Write_Byte(sectorNumber,
-                      protectEnable | (accessRight<<1) |(passwd<<2));
-  }
-}
-
-void M24LR64E::clearSectorProtect(void)
-{
-  uint8_t buf[64]={0x0};
-  EEPROM_Write_Bytes(0, buf, 64);
-}
-
-
-void M24LR64E::sectorWriteLockBit(unsigned int sectorNumber, 
-                                  bool sockEnable)
-{
-  unsigned int sectorAddress = SECTOR_SECURITY_STATUS_BASE_ADDR 
-    + (sectorNumber/8);
-  uint8_t sectorBit = sectorNumber % 8;
-  uint8_t preStatus = EEPROM_Read_Byte(sectorAddress);
-  
-  bool status = (preStatus >> sectorBit) & 0x01;
-  if(status != sockEnable) {
-    if(status == true) {
-      writeByte(sectorAddress,preStatus&(~(1<<sectorBit)));
-    } else {
-      writeByte(sectorAddress,preStatus|(1<<sectorBit));
-    }
-  }
-}
-
-uint8_t M24LR64E::getDSFID()
-{
-  return EEPROM_Read_Byte(DSFID_ADDR);
-}
-
-uint8_t M24LR64E::getAFI()
-{
-  return EEPROM_Read_Byte(AFI_ADDR);
-}
-
-uint8_t *M24LR64E::getUID()
-{
-  uint8_t* buffer = new uint8_t[UID_LENGTH];
-  EEPROM_Read_Bytes(UID_ADDR, buffer, UID_LENGTH);
-
-  return buffer;
-}
-
-uint32_t M24LR64E::getMemorySize()
-{
-  uint32_t volume = 0x0;
-  volume = EEPROM_Read_Byte(MEM_SIZE_ADDR); 
-  volume = volume<<8|EEPROM_Read_Byte(MEM_SIZE_ADDR+1);
-  volume = volume<<8|EEPROM_Read_Byte(MEM_SIZE_ADDR+2);
-  return volume;
-}
-
-void M24LR64E::clearMemory()
-{
-  for(int i = 0; i < EEPROM_I2C_LENGTH; i++){
-    writeByte(i,0x0);
-  }
-}
-
-mraa::Result M24LR64E::writeByte(unsigned int address, uint8_t data)
-{
-  return EEPROM_Write_Byte(address, data);
-}
-
-mraa::Result M24LR64E::writeBytes(unsigned int address, uint8_t* buffer, int len)
-{
-  return EEPROM_Write_Bytes(address, buffer, len);
-}
-
-uint8_t M24LR64E::readByte(unsigned int address)
-{
-  return EEPROM_Read_Byte(address);
-}
-
-int M24LR64E::readBytes(unsigned int address, uint8_t* buffer, int len)
-{
-  return EEPROM_Read_Bytes(address, buffer, len);
-}
-
-mraa::Result M24LR64E::EEPROM_Write_Byte(unsigned int address, uint8_t data)
-{
-  const int pktLen = 3;
-  uint8_t buf[pktLen];
-  mraa::Result rv;
-  
-  buf[0] = ((address >> 8) & 0xff);
-  buf[1] = (address & 0xff);
-  buf[2] = data;
-
-  if ((rv = m_i2c.write(buf, pktLen)))
-    throw std::runtime_error(std::string(__FUNCTION__) +
-                             ": I2c.write() failed");
-
-  usleep(I2C_WRITE_TIME * 1000);
-  return rv;
-}
-
-mraa::Result M24LR64E::EEPROM_Write_Bytes(unsigned int address, uint8_t* data,
-                                  int len)
-{
-  const int pktLen = 2 + len;
-  uint8_t buf[pktLen];
-  mraa::Result rv;
-  
-  buf[0] = ((address >> 8) & 0xff);
-  buf[1] = (address & 0xff);
-
-  for (int i=0; i<len; i++)
-    buf[2+i] = data[i];
-
-  if ((rv = m_i2c.write(buf, pktLen)))
-    throw std::runtime_error(std::string(__FUNCTION__) +
-                             ": I2c.write() failed");
-
-  usleep(I2C_WRITE_TIME * 1000);
-
-  return rv;
-}
-
-uint8_t M24LR64E::EEPROM_Read_Byte(unsigned int address)
-{
-  const int apktLen = 2;
-  uint8_t abuf[apktLen];
-
-  abuf[0] = ((address >> 8) & 0xff);
-  abuf[1] = (address & 0xff);
-  
-  if (m_i2c.write(abuf, apktLen))
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": I2c.write() failed");
-      return 0x00;
-    }
-
-  const int pktLen = 1;
-  uint8_t buf[apktLen];
-
-  buf[0] = 0;
-  
-  if (m_i2c.read(buf, pktLen) != pktLen)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": I2c.write() failed");
-      return 0x00;
-    }
-  
-  return buf[0];
-}
-
-int M24LR64E::EEPROM_Read_Bytes(unsigned int address, 
-                                         uint8_t* buffer, int len)
-{
-  const int apktLen = 2;
-  uint8_t abuf[apktLen];
-
-  abuf[0] = ((address >> 8) & 0xff);
-  abuf[1] = (address & 0xff);
-  
-  if (m_i2c.write(abuf, apktLen))
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": I2c.write() failed");
-      return false;
-    }
-
-  int rv = m_i2c.read(buffer, len);
-  if (rv != len)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": I2c.read() failed");
-    }
-
-  return rv;
-}
diff --git a/src/m24lr64e/m24lr64e.h b/src/m24lr64e/m24lr64e.h
deleted file mode 100644
index a177ee8..0000000
--- a/src/m24lr64e/m24lr64e.h
+++ /dev/null
@@ -1,272 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- *
- * This code was adapted from the Seeed Studio code at:
- * https://github.com/Seeed-Studio/NFC_Tag_M24LR6E
- *
- * Copyright (c) 2014 seeed technology inc.
- * Website    : www.seeed.cc
- * Author     : lawliet zou
- * Create Time: March 2014
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef M24LR64E_H_
-#define M24LR64E_H_
-
-#include "upm.h"
-#include "mraa/i2c.h"
-
-#define M24LR64E_I2C_BUS 0
-#define M24LR64E_DEFAULT_I2C_ADDR 0x53
-#define M24LR64E_DEFAULT_I2C_ADDR_E2 (M24LR64E_DEFAULT_I2C_ADDR | 0x04)
-
-#define M24LR64E_EEPROM_I2C_LENGTH 8192
-#define M24LR64E_PASSWORD_LENGTH 4
-#define M24LR64E_SECTOR_SECURITY_STATUS_BASE_ADDR 0x800
-#define M24LR64E_LOCK_PROTECT_BIT 0x01
-#define M24LR64E_WRITE_READ_PROTECT_BIT 0x02
-#define M24LR64E_PASSWORD_CTRL_BIT 0x04
-
-#define M24LR64E_UID_LENGTH 8
-#define M24LR64E_I2C_WRITE_TIME 5
-
-/**
- * @file m24lr64e.h
- * @library m24lr64e
- * @brief C API for M24LR64E based NFC Tags
- *
- * @include m24lr64e.c
- */
-
-#include <stdint.h>
-
-typedef enum {
-    M24LR64E_I2C_PASSWORD_ADDRESS                  = 2304,
-    M24LR64E_RF_PASSWORD_1_ADDRESS                 = 2308, // RF pwds not available in
-    M24LR64E_RF_PASSWORD_2_ADDRESS                 = 2312, // I2C access modes
-    M24LR64E_RF_PASSWORD_3_ADDRESS                 = 2316,
-    M24LR64E_DSFID_ADDRESS                         = 2320, // 1 byte
-    M24LR64E_AFI_ADDRESS                           = 2321, // 1 byte
-    M24LR64E_RESV_ADDRESS                          = 2322, // 1 bytes
-    M24LR64E_CONFIG_ADDRESS                        = 2323, // 1 bytes
-    M24LR64E_UID_ADDRESS                           = 2324, // 8 bytes
-    M24LR64E_MEM_SIZE_ADDRESS                      = 2332, // 3 bytes
-    M24LR64E_IC_REF_ADDRESS                        = 2335, // 1 byte
-    M24LR64E_PROG_COMP_ENERGY_HARVEST_ADDRESS      = 2339  // 1 byte
-} M24LR64E_ADDR_T;
-
-typedef enum {
-    M24LR64E_USER_MODE = 0x0,   // offers simple read/write access right
-    M24LR64E_ROOT_MODE = 0x1    // offers password change access right
-} m24lr64e_access_mode;
-
-typedef enum {
-    //      **********************************
-    //      *  submit passWd *   no submit   *
-    //b2,b1 *  Read * Write  *  Read * Write *
-    // 00   *    1       1        1      0   *
-    // 01   *    1       1        1      1   *
-    // 10   *    1       1        0      0   *
-    // 11   *    0       1        0      0   *
-    //      **********************************
-    m24lr64e_access_1110 = 0,
-    m24lr64e_access_1111 = 1,
-    m24lr64e_access_1100 = 2,
-    m24lr64e_access_0111 = 3,
-} sector_access_right;
-
-typedef enum {
-    //00 => no passwd protect
-    //01 => passWd 1
-    //10 => passWd 2
-    //11 => passwd 3
-    m24lr64e_no_password = 0,
-    m24lr64e_password_1 = 1,
-    m24lr64e_password_2 = 2,
-    m24lr64e_password_3 = 3,
-} sector_select_password;
-
-/*
- * device context
- */
-typedef struct _m24lr64e_context {
-    mraa_i2c_context            i2c;
-    int                         bus;
-    uint8_t                     address;
-    m24lr64e_access_mode        mode;
-} *m24lr64e_context;
-
-/**
- * M24LR64E Init function
- *
- * @param bus I2C bus to use
- * @param mode Access mode (user or root) to use
- */
-m24lr64e_context m24lr64e_init(int bus, m24lr64e_access_mode mode);
-
-/**
- * M24LR64E close function
- *
- * @param dev void pointer to sensor struct
- */
-void m24lr64e_close(m24lr64e_context dev);
-
-/**
- * Submits an I2C access password
- *
- * @param dev void pointer to sensor struct
- * @param passwd 4-byte access password
- */
-upm_result_t m24lr64e_submit_password(m24lr64e_context dev, uint32_t password);
-
-/**
- * Writes a new I2C password
- *
- * @param dev void pointer to sensor struct
- * @param passwd 4-byte access password
- */
-upm_result_t m24lr64e_write_password(m24lr64e_context dev, uint32_t password);
-
-/**
- * Sets a protection bit for a sector. Must be in the root mode
- *
- * @param dev void pointer to sensor struct
- * @param sectorNumber Sector whose protection you are modifying
- * @param protectEnable True if you are enabling protection
- * @param accessRight Access rights to set
- * @param passwd Password number to enable, if any
- */
-upm_result_t m24lr64e_sector_protect_config(m24lr64e_context dev,
-                                            uint32_t sector_number,
-                                            bool protect_enable,
-                                            sector_access_right access_right,
-                                            sector_select_password password);
-
-/**
- * Clears sector protection bits. Must be in the root mode.
- *
- * @param dev void pointer to sensor struct
- */
-upm_result_t m24lr64e_clear_sector_protect(m24lr64e_context dev);
-
-/**
- * Sets or clears a sector security status lock bit for a sector.
- * Must be in the root mode.
- *
- * @param dev void pointer to sensor struct
- * @param sectorNumber Sector whose SSS you want to modify
- * @param sockEnable True to set the bit, false to clear it
- */
-upm_result_t m24lr64e_sector_write_lock_bit(m24lr64e_context dev,
-                                            uint32_t sector_number,
-                                            bool sock_enable);
-
-/**
- * Returns a data storage family identifier (DSFID)
- * Must be in the root mode.
- *
- * @param dev void pointer to sensor struct
- * @param dsfid pointer to hold return value
- */
-upm_result_t m24lr64e_get_dsfid(m24lr64e_context dev, uint8_t* dsfid);
-
-/**
- * Returns an application family identifier (AFI)
- * Must be in the root mode.
- *
- * @param dev void pointer to sensor struct
- * @param afi pointer to hold return value
- */
-upm_result_t m24lr64e_get_afi(m24lr64e_context dev, uint8_t* afi);
-
-/**
- * Returns a unique ID.
- * Must be in the root mode.
- * Maintained to preserve compatibility with older code.
- *
- * @param dev void pointer to sensor struct
- * @param uid pointer to hold return value
- */
-upm_result_t m24lr64e_get_uid(m24lr64e_context dev, uint8_t* uid);
-
-/**
- * Returns the memory size
- * Must be in the root mode.
- *
- * @param dev void pointer to sensor struct
- * @param memory_size pointer to hold return value
- */
-upm_result_t m24lr64e_get_memory_size(m24lr64e_context dev, uint32_t* memory_size);
-
-/**
- * Sets all memory to 0, if permissions allow
- *
- * @param dev void pointer to sensor struct
- */
-upm_result_t m24lr64e_clear_memory(m24lr64e_context dev);
-
-/**
- * Writes a byte to the EEPROM
- *
- * @param dev void pointer to sensor struct
- * @param address Address to write to
- * @param data Data to write
- */
-upm_result_t m24lr64e_write_byte(m24lr64e_context dev, uint32_t address,
-                                 uint8_t data);
-
-/**
- * Writes bytes to the EEPROM
- *
- * @param dev void pointer to sensor struct
- * @param address Address to write to
- * @param data Data to write
- * @param data Length of the data buffer
- */
-upm_result_t m24lr64e_write_bytes(m24lr64e_context dev, uint32_t address,
-                                  uint8_t* buffer, int len);
-
-/**
- * Reads a byte from the EEPROM
- *
- * @param dev void pointer to sensor struct
- * @param address Address to read from
- * @param data holds return value
- */
-upm_result_t m24lr64e_read_byte(m24lr64e_context dev, uint32_t address,
-                                uint8_t* data);
-
-/**
- * Reads multiple bytes from the EEPROM
- *
- * @param dev void pointer to sensor struct
- * @param address Address to read from
- * @param buffer Buffer to store data
- * @param len Number of bytes to read
- */
-upm_result_t m24lr64e_read_bytes(m24lr64e_context dev, uint32_t address,
-                                 uint8_t* buffer, int len);
-
-#endif /* M24LR64E_H_ */
diff --git a/src/m24lr64e/m24lr64e.hpp b/src/m24lr64e/m24lr64e.hpp
deleted file mode 100644
index 7e57d00..0000000
--- a/src/m24lr64e/m24lr64e.hpp
+++ /dev/null
@@ -1,287 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- *
- * This code was adapted from the Seeed Studio code at:
- * https://github.com/Seeed-Studio/NFC_Tag_M24LR6E  
- *
- * Copyright (c) 2014 seeed technology inc.
- * Website    : www.seeed.cc
- * Author     : lawliet zou
- * Create Time: March 2014
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/common.hpp>
-#include <mraa/i2c.hpp>
-
-#define M24LR64E_I2C_BUS 0
-#define M24LR64E_DEFAULT_I2C_ADDR 0x53
-#define M24LR64E_DEFAULT_I2C_ADDR_E2 (M24LR64E_DEFAULT_I2C_ADDR | 0x04)
-
-namespace upm {
-  
-  /**
-   * @brief M24LR64E NFC Tag Module
-   * @defgroup m24lr64e libupm-m24lr64e
-   * @ingroup seeed i2c other
-   */
-
-  /**
-   * @library m24lr64e
-   * @sensor m24lr64e
-   * @comname Dynamic NFC/RFID Tag Module
-   * @altname Grove NFC Tag
-   * @type other
-   * @man seeed
-   * @web http://www.seeedstudio.com/wiki/Grove_-_NFC_Tag
-   * @con i2c
-   *
-   * @brief C++ API for the M24LR64E NFC Tag
-   *
-   * The M24LR64E NFC tag is an 8KB electrically erasable programmable
-   * read-only memory (EEPROM) that can be written to or read from using
-   * I2C and NFC-equipped devices.
-   *
-   * The user mode (default) allows read and write access to all 8KB
-   * of space, provided the sector security status (SSS) allows it.
-   * The root mode allows modification of the SSS data and other
-   * information, provided the proper password is submitted.  The
-   * default password for a new tag is 0x00000000. See the datasheet
-   * for more details.
-   *
-   * The Seeed Studio* wiki page for this device includes a link to an
-   * Android* application that can be used to also read and write the
-   * device via NFC, as well as set NFC passwords, which cannot be
-   * done via I2C.
-   *
-   * @image html m24lr64e.jpg
-   * @snippet m24lr64e.cxx Interesting
-   */
-  class M24LR64E {
-  public:
-    
-    static const int EEPROM_I2C_LENGTH          = 8192;
-    static const int PASSWORD_LENGTH            = 4;
-    static const int SECTOR_SECURITY_STATUS_BASE_ADDR = 0x800; // 2048
-    
-    static const uint8_t LOCK_PROTECT_BIT       = 0x01;
-    static const uint8_t WRITE_READ_PROTECT_BIT = 0x02;
-    static const uint8_t PASSWORD_CTRL_BIT      = 0x04;
-    
-    static const int UID_LENGTH                 = 8; // bytes
-
-    static const unsigned int I2C_WRITE_TIME    = 5; // 5ms
-
-    /**
-     * M24LR64E addresses, accessible only in the root mode
-     */
-    typedef enum {
-      I2C_PASSWORD_ADDR                  = 2304,
-      RF_PASSWORD_1_ADDR                 = 2308, // RF pwds not available in
-      RF_PASSWORD_2_ADDR                 = 2312, // I2C access modes
-      RF_PASSWORD_3_ADDR                 = 2316,
-      DSFID_ADDR                         = 2320, // 1 byte
-      AFI_ADDR                           = 2321, // 1 byte
-      RESV_ADDR                          = 2322, // 1 bytes
-      CONFIG_ADDR                        = 2323, // 1 bytes
-      UID_ADDR                           = 2324, // 8 bytes
-      MEM_SIZE_ADDR                      = 2332, // 3 bytes
-      IC_REF_ADDR                        = 2335, // 1 byte
-      PROG_COMP_ENERGY_HARVEST_ADDR      = 2339  // 1 byte
-    } M24LR64E_ADDR_T;
-
-    enum AccessMode {
-      USER_MODE = 0x0,   // offers simple read/write access right
-      ROOT_MODE = 0x1    // offers password change access right
-    };
-
-    enum SectorAccessRight {
-      //      **********************************
-      //      *  submit passWd *   no submit   * 
-      //b2,b1 *  Read * Write  *  Read * Write *
-      // 00   *    1       1        1      0   *
-      // 01   *    1       1        1      1   *
-      // 10   *    1       1        0      0   *
-      // 11   *    0       1        0      0   *
-      //      **********************************
-      Access_1110 = 0,
-      Access_1111 = 1,
-      Access_1100 = 2,
-      Access_0111 = 3,
-    };
-
-    enum SectorSelectPassWd {
-      //00 => no passwd protect
-      //01 => passWd 1
-      //10 => passWd 2
-      //11 => passwd 3
-      noPasswd = 0,
-      passwd_1 = 1,
-      passwd_2 = 2,
-      passwd_3 = 3,
-    };
-
-    /**
-     * M24LR64E constructor
-     *
-     * @param bus I2C bus to use
-     * @param mode Access mode (user or root) to use
-     */
-    M24LR64E(int bus, AccessMode mode = USER_MODE);
-
-    /**
-     * M24LR64E destructor
-     */
-    ~M24LR64E();
-    
-    /**
-     * Submits an I2C access password
-     *
-     * @param passwd 4-byte access password
-     */
-    bool submitPasswd(uint32_t passwd);
-
-    /**
-     * Writes a new I2C password
-     *
-     * @param passwd 4-byte access password
-     */
-    bool writePasswd(uint32_t passwd);
-
-    /**
-     * Sets a protection bit for a sector. Must be in the root mode
-     *
-     * @param sectorNumber Sector whose protection you are modifying
-     * @param protectEnable True if you are enabling protection
-     * @param accessRight Access rights to set
-     * @param passwd Password number to enable, if any
-     */
-    void sectorProtectConfig(unsigned int sectorNumber, 
-                             bool protectEnable, 
-                             SectorAccessRight accessRight, 
-                             SectorSelectPassWd passwd);
-
-    /**
-     * Clears sector protection bits. Must be in the root mode.
-     */
-    void clearSectorProtect(void);
-
-    /**
-     * Sets or clears a sector security status lock bit for a sector.  
-     * Must be in the root mode.
-     *
-     * @param sectorNumber Sector whose SSS you want to modify
-     * @param sockEnable True to set the bit, false to clear it
-     */
-    void sectorWriteLockBit(unsigned int sectorNumber, 
-                            bool sockEnable);
-
-    /**
-     * Returns a data storage family identifier (DSFID)
-     * Must be in the root mode.
-     *
-     * @return DSFID
-     */
-    uint8_t getDSFID();
-
-    /**
-     * Returns an application family identifier (AFI)
-     * Must be in the root mode.
-     *
-     * @return AFI
-     */
-    uint8_t getAFI();
-
-    /**
-     * Returns a unique ID.
-     * Must be in the root mode.
-     * Maintained to preserve compatibility with older code.
-     *
-     * @result buf Buffer to hold the UID. Must be UID_LENGTH bytes.
-     */
-    uint8_t *getUID();
-
-    /**
-     * Returns the memory size
-     * Must be in the root mode.
-     *
-     * @return Amount of memory present
-     */
-    uint32_t getMemorySize();
-
-    /**
-     * Sets all memory to 0, if permissions allow
-     */
-    void clearMemory();
-
-    /**
-     * Writes a byte to the EEPROM
-     *
-     * @param address Address to write to
-     * @param data Data to write
-     */
-    mraa::Result writeByte(unsigned int address, uint8_t data);
-
-    /**
-     * Writes bytes to the EEPROM
-     *
-     * @param address Address to write to
-     * @param buffer Data to write
-     * @param len Length of the data buffer
-     */
-    mraa::Result writeBytes(unsigned int address, uint8_t* buffer, int len);
-
-    /**
-     * Reads a byte from the EEPROM
-     *
-     * @param address Address to read from
-     * @return data Value read
-     */
-    uint8_t readByte(unsigned int address);
-
-    /**
-     * Reads multiple bytes from the EEPROM
-     *
-     * @param address Address to read from
-     * @param buffer Buffer to store data
-     * @param len Number of bytes to read
-     */
-    int readBytes(unsigned int address, uint8_t* buffer, int len);
-
-  protected:
-    mraa::I2c m_i2c;
-    mraa::Result EEPROM_Write_Byte(unsigned int address, uint8_t data);
-    mraa::Result EEPROM_Write_Bytes(unsigned int address, uint8_t* data,
-                            int len);
-    uint8_t EEPROM_Read_Byte(unsigned int address);
-    int EEPROM_Read_Bytes(unsigned int address, 
-                                   uint8_t* buffer, int len);
-
-  private:
-    uint8_t m_addr;
-  };
-}
-
-
diff --git a/src/m24lr64e/m24lr64e.i b/src/m24lr64e/m24lr64e.i
deleted file mode 100644
index 3cd8904..0000000
--- a/src/m24lr64e/m24lr64e.i
+++ /dev/null
@@ -1,32 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "arrays_java.i";
-%include "../java_buffer.i"
-
-%typemap(jni) uint8_t * "jbyteArray"
-%typemap(jtype) uint8_t * "byte[]"
-%typemap(jstype) uint8_t * "byte[]"
-
-%typemap(javaout) uint8_t * {
-    return $jnicall;
-}
-
-%typemap(out) uint8_t *{
-    int length = upm::M24LR64E::UID_LENGTH;
-    $result = JCALL1(NewByteArray, jenv, length);
-    JCALL4(SetByteArrayRegion, jenv, $result, 0, length, reinterpret_cast<signed char *>($1));
-    delete [] $1;
-}
-
-JAVA_JNI_LOADLIBRARY(javaupm_m24lr64e)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "m24lr64e.hpp"
-%}
-%include "m24lr64e.hpp"
-/* END Common SWIG syntax */
diff --git a/src/m24lr64e/m24lr64e.json b/src/m24lr64e/m24lr64e.json
deleted file mode 100644
index c5e0259..0000000
--- a/src/m24lr64e/m24lr64e.json
+++ /dev/null
@@ -1,38 +0,0 @@
-{
-    "Library": "m24lr64e",
-    "Description": "API for the M24LR64E NFC Tag",
-    "Sensor Class":
-    {
-        "M24LR64E":
-        {
-            "Name": "Dynamic NFC/RFID Tag Module",
-            "Description": "The M24LR64E NFC tag is an 8KB electrically erasable programmable read-only memory (EEPROM) that can be written to or read from using I2C and NFC-equipped devices. The user mode (default) allows read and write access to all 8KB of space, provided the sector security status (SSS) allows it. The root mode allows modification of the SSS data and other information, provided the proper password is submitted.  The default password for a new tag is 0x00000000. See the datasheet for more details. The Seeed Studio* wiki page for this device includes a link to an Android* application that can be used to also read and write the device via NFC, as well as set NFC passwords, which cannot be done via I2C.",
-            "Aliases": ["m24lr64e"],
-            "Categories": ["rfid", "wireless"],
-            "Connections": ["i2c", "nfc"],
-            "Project Type": ["access control", "prototyping"],
-            "Manufacturers": ["seeed"],
-            "Kits": [],
-            "Image": "m24lr64e.jpg",
-            "Examples":
-            {
-                "Java": ["M24LR64E_Example.java"],
-                "Python": ["m24lr64e.py"],
-                "Node.js": ["m24lr64e.js"],
-                "C++": ["m24lr64e.cxx"],
-                "C": ["m24lr64e.c"]
-            },
-            "Specifications":
-            {
-                "Operating Voltage": {"unit": "V", "low": 1.8, "high": 5.5},
-                "Operating Temperature": {"unit": "degC", "low": -40, "high": 85}
-            },
-            "Urls" :
-            {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-NFC-Tag-p-1866.html"],
-                "Datasheets": ["http://www.seeedstudio.com/wiki/Grove_-_NFC_Tag", "https://raw.githubusercontent.com/SeeedDocument/Grove-NFC_Tag/master/res/M24LR64E-R.pdf"],
-                "Schematics": []
-            }
-        }
-    }
-}
diff --git a/src/m24lr64e/m24lr64e_fti.c b/src/m24lr64e/m24lr64e_fti.c
deleted file mode 100644
index eaf3c0d..0000000
--- a/src/m24lr64e/m24lr64e_fti.c
+++ /dev/null
@@ -1,49 +0,0 @@
-#include "m24lr64e.h"
-#include "upm_fti.h"
-
-/** 
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_m24lr64e_name[] = "M24LR64E";
-const char upm_m24lr64e_description[] = "Grove NFC Tag";
-const upm_protocol_t upm_m24lr64e_protocol[] = {UPM_I2C};
-const upm_sensor_t upm_m24lr64e_category[] = {UPM_NFC};
-
-// forward declarations
-const void* upm_m24lr64e_get_ft(upm_sensor_t sensor_type);
-void* upm_m24lr64e_init_name();
-void upm_m24lr64e_close(void* dev);
-
-const upm_sensor_descriptor_t upm_m24lr64e_get_descriptor(){
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_m24lr64e_name;
-    usd.description = upm_m24lr64e_description;
-    usd.protocol_size = 1;
-    usd.protocol = upm_m24lr64e_protocol;
-    usd.category_size = 1;
-    usd.category = upm_m24lr64e_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = &upm_m24lr64e_init_name,
-    .upm_sensor_close = &upm_m24lr64e_close,
-    .upm_sensor_get_descriptor = &upm_m24lr64e_get_descriptor
-};
-
-const void* upm_m24lr64e_get_ft(upm_sensor_t sensor_type){
-    if(sensor_type == UPM_SENSOR){
-        return &ft;
-    }
-    return NULL;
-}
-
-void* upm_m24lr64e_init_name(){
-    return NULL;
-}
-
-void upm_m24lr64e_close(void* dev){
-    m24lr64e_close((m24lr64e_context)dev);
-}
diff --git a/src/mag3110/CMakeLists.txt b/src/mag3110/CMakeLists.txt
deleted file mode 100644
index 32be442..0000000
--- a/src/mag3110/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "mag3110")
-set (libdescription "Three-Axis Digital Magnetometer")
-set (module_src ${libname}.cpp)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/mag3110/mag3110.cpp b/src/mag3110/mag3110.cpp
deleted file mode 100644
index 18db6d4..0000000
--- a/src/mag3110/mag3110.cpp
+++ /dev/null
@@ -1,269 +0,0 @@
-/*
- * Author: Norbert Wesp <nwesp@phytec.de>
- * Copyright (c) 2017 Phytec Messtechnik GmbH.
- *
- * based on: RIOT-driver mag3110 by Johann Fischer <j.fischer@phytec.de>
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include <unistd.h>
-#include <stdlib.h>
-#include <endian.h>
-
-#include "mag3110.hpp"
-
-using namespace upm;
-
-MAG3110::MAG3110 (int bus, uint8_t dros, int devAddr) : m_i2ControlCtx(bus) {
-    s_data->x = 0;
-    s_data->y = 0;
-    s_data->z = 0;
-    s_data->status = 0;
-    s_data->dtemp = 0;
-
-    uint8_t reg;
-
-    m_name = MAG3110_NAME;
-
-    m_controlAddr = devAddr;
-    m_bus = bus;
-
-    if (dros > MAG3110_DROS_0008_128) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": given DR-OS invalid");
-    }
-
-    mraa::Result ret = m_i2ControlCtx.address(m_controlAddr);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_address() failed");
-    }
-
-    if (checkID() != 0) {
-        /* sensor_id does not match! maybe wrong sensor chosen? */
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": checkID() failed");
-    }
-
-    /* enable automatic magnetic sensor reset */
-    reg = MAG3110_CTRL_REG2_AUTO_MRST_EN;
-    ret = m_i2ControlCtx.writeReg(MAG3110_CTRL_REG2, reg);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_byte_data() failed");
-    }
-
-    reg = MAG3110_CTRL_REG1_DROS(dros);
-    ret = m_i2ControlCtx.writeReg(MAG3110_CTRL_REG1, reg);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_byte_data() failed");
-    }
-}
-
-int
-MAG3110::checkID(void)
-{
-    uint8_t id;
-
-    id = m_i2ControlCtx.readReg(MAG3110_DEVICE_ID_REG);
-
-    if (id != MAG3110_DEVICE_ID) {
-        return -1;
-    }
-
-    return 0;
-}
-
-int
-MAG3110::setUserOffset(int16_t x, int16_t y, int16_t z)
-{
-    mraa::Result ret;
-    ret = m_i2ControlCtx.writeWordReg(MAG3110_OFF_X_MSB, (uint16_t)x);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_word_data() failed");
-        return -1;
-    }
-
-    ret = m_i2ControlCtx.writeWordReg(MAG3110_OFF_Y_MSB, (uint16_t)y);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_word_data() failed");
-        return -1;
-    }
-
-    ret = m_i2ControlCtx.writeWordReg(MAG3110_OFF_Z_MSB, (uint16_t)z);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_word_data() failed");
-        return -1;
-    }
-
-    return 0;
-}
-
-int
-MAG3110::setActive(void)
-{
-    uint8_t reg;
-
-    reg = m_i2ControlCtx.readReg(MAG3110_CTRL_REG1);
-
-    reg |= MAG3110_CTRL_REG1_AC;
-
-    mraa::Result ret = m_i2ControlCtx.writeReg(MAG3110_CTRL_REG1, reg);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_byte_data() failed");
-        return -1;
-    }
-
-    return 0;
-}
-
-int
-MAG3110::setStandby(void)
-{
-    uint8_t reg;
-
-    reg = m_i2ControlCtx.readReg(MAG3110_CTRL_REG1);
-
-    reg &= ~MAG3110_CTRL_REG1_AC;
-
-    mraa::Result ret = m_i2ControlCtx.writeReg(MAG3110_CTRL_REG1, reg);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_byte_data() failed");
-        return -1;
-    }
-
-    return 0;
-}
-
-int
-MAG3110::isReady(void)
-{
-    uint8_t reg;
-
-    reg = m_i2ControlCtx.readReg(MAG3110_DR_STATUS);
-
-    return (int)(reg & MAG3110_DR_STATUS_ZYXDR);
-}
-
-int
-MAG3110::sampleData(void)
-{
-    uint8_t buf[7];
-    uint8_t dtemp;
-    int re = 0;
-
-    re = m_i2ControlCtx.readBytesReg(MAG3110_DR_STATUS, buf, 7);
-    if (re != 7) {
-        /* did not read enough bytes */
-        return -1;
-    }
-
-    s_data->status = buf[0];
-    s_data->x = ((int16_t)buf[1] << 8) | buf[2];
-    s_data->y = ((int16_t)buf[3] << 8) | buf[4];
-    s_data->z = ((int16_t)buf[5] << 8) | buf[6];
-
-    dtemp = m_i2ControlCtx.readReg(MAG3110_DIE_TEMP);
-
-    s_data->dtemp = dtemp;
-
-    return 0;
-}
-
-int16_t
-MAG3110::getX(int bSampleData)
-{
-    if (bSampleData) {
-        if (sampleData() != 0) {
-            /* error in read values from reg */
-            return -999;
-        }
-    }
-
-    return s_data->x;
-}
-
-int16_t
-MAG3110::getY(int bSampleData)
-{
-    if (bSampleData) {
-        if (sampleData() != 0) {
-            /* error in read values from reg */
-            return -999;
-        }
-    }
-
-    return s_data->y;
-}
-
-int16_t
-MAG3110::getZ(int bSampleData)
-{
-    if (bSampleData) {
-        if (sampleData() != 0) {
-            /* error in read values from reg */
-            return -999;
-        }
-    }
-
-    return s_data->z;
-}
-
-uint8_t
-MAG3110::getStatus(void)
-{
-    return s_data->status;
-}
-
-int8_t
-MAG3110::getDieTemperature(void)
-{
-    return s_data->dtemp;
-}
-
-int
-MAG3110::getData(mag3110_data_t* data, int bSampleData)
-{
-    if (bSampleData) {
-        if (sampleData() != 0) {
-            /* error in read values from reg */
-            return -1;
-        }
-    }
-
-    data->x = s_data->x;
-    data->y = s_data->y;
-    data->z = s_data->z;
-    data->status = s_data->status;
-    data->dtemp = s_data->dtemp;
-
-    return 0;
-}
diff --git a/src/mag3110/mag3110.hpp b/src/mag3110/mag3110.hpp
deleted file mode 100644
index fd9c306..0000000
--- a/src/mag3110/mag3110.hpp
+++ /dev/null
@@ -1,296 +0,0 @@
-/*
- * Author: Norbert Wesp <nwesp@phytec.de>
- * Copyright (c) 2017 Phytec Messtechnik GmbH.
- *
- * based on: RIOT-driver mag3110 by Johann Fischer <j.fischer@phytec.de>
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <string>
-#include <mraa/i2c.hpp>
-#include <stdint.h>
-#include <stdbool.h>
-
-#define MAG3110_NAME "MAG3110"
-#define MAG3110_I2C_ADDRESS   0x0E
-#define MAG3110_DEVICE_ID     0xC4
-#define MAG3110_DEVICE_ID_REG 0x07
-
-/* MAG3110 Register Map */
-#define MAG3110_DR_STATUS            0x00 /**< Data ready status per axis */
-#define MAG3110_OUT_X_MSB            0x01 /**< Bits [15:8] of X measurement */
-#define MAG3110_OUT_X_LSB            0x02 /**< Bits [7:0] of X measurement */
-#define MAG3110_OUT_Y_MSB            0x03 /**< Bits [15:8] of Y measurement */
-#define MAG3110_OUT_Y_LSB            0x04 /**< Bits [7:0] of Y measurement */
-#define MAG3110_OUT_Z_MSB            0x05 /**< Bits [15:8] of Z measurement */
-#define MAG3110_OUT_Z_LSB            0x06 /**< Bits [7:0] of Z measurement */
-#define MAG3110_SYSMOD               0x08 /**< FIFO Status Register */
-#define MAG3110_OFF_X_MSB            0x09 /**< Bits [15:8] of user X offset */
-#define MAG3110_OFF_X_LSB            0x0A /**< Bits [7:0] of user X offset */
-#define MAG3110_OFF_Y_MSB            0x0B /**< Bits [15:8] of user Y offset */
-#define MAG3110_OFF_Y_LSB            0x0C /**< Bits [7:0] of user Y offset */
-#define MAG3110_OFF_Z_MSB            0x0D /**< Bits [15:8] of user Z offset */
-#define MAG3110_OFF_Z_LSB            0x0E /**< Bits [7:0] of user Z offset */
-#define MAG3110_DIE_TEMP             0x0F /**< Temperature, signed 8 bits */
-#define MAG3110_CTRL_REG1            0x10 /**< Operation modes */
-#define MAG3110_CTRL_REG2            0x11 /**< Operation modes */
-
-/* MAG3110 DR-STATUS Register */
-#define MAG3110_DR_STATUS_ZYXOW           (1 << 7)
-#define MAG3110_DR_STATUS_ZOW             (1 << 6)
-#define MAG3110_DR_STATUS_YOW             (1 << 5)
-#define MAG3110_DR_STATUS_XOW             (1 << 4)
-#define MAG3110_DR_STATUS_ZYXDR           (1 << 3)
-#define MAG3110_DR_STATUS_ZDR             (1 << 2)
-#define MAG3110_DR_STATUS_YDR             (1 << 1)
-#define MAG3110_DR_STATUS_XDR             (1 << 0)
-
-/* MAG3110 SYSMOD Register */
-#define MAG3110_SYSMOD_STANDBY            0
-#define MAG3110_SYSMOD_ACTIVE_RAW         1
-#define MAG3110_SYSMOD_ACTIVE             2
-
-/* MAG3110 Control Register 1 */
-#define MAG3110_CTRL_REG1_DROS_SHIFT      3
-#define MAG3110_CTRL_REG1_DROS_MASK       0xF8
-#define MAG3110_CTRL_REG1_DROS(x)         (((uint8_t)(((uint8_t)(x))<<\
-                                          MAG3110_CTRL_REG1_DROS_SHIFT))\
-                                          &MAG3110_CTRL_REG1_DROS_MASK)
-#define MAG3110_CTRL_REG1_FR              (1 << 2)
-#define MAG3110_CTRL_REG1_TM              (1 << 1)
-#define MAG3110_CTRL_REG1_AC              (1 << 0)
-
-/* MAG3110 Control Register 2 */
-#define MAG3110_CTRL_REG2_AUTO_MRST_EN    (1 << 7)
-#define MAG3110_CTRL_REG2_RAW             (1 << 5)
-#define MAG3110_CTRL_REG2_MAG_RST         (1 << 4)
-
-/* MAG3110 Output Rate (DR) and Over Sample (OS) Ratio for CTRL_REG1 */
-#define MAG3110_DROS_8000_16     0 /* DR 80   Hz, OS Ratio 16 */
-#define MAG3110_DROS_4000_32     1 /* DR 40   Hz, OS Ratio 32 */
-#define MAG3110_DROS_2000_64     2 /* DR 20   Hz, OS Ratio 64 */
-#define MAG3110_DROS_1000_128    3 /* DR 10   Hz, OS Ratio 128 */
-#define MAG3110_DROS_4000_16     4 /* DR 40   Hz, OS Ratio 16 */
-#define MAG3110_DROS_2000_32     5 /* DR 20   Hz, OS Ratio 32 */
-#define MAG3110_DROS_1000_64     6 /* DR 10   Hz, OS Ratio 64 */
-#define MAG3110_DROS_0500_128    7 /* DR 5    Hz, OS Ratio 128 */
-#define MAG3110_DROS_2000_16     8 /* DR 20   Hz, OS Ratio 16 */
-#define MAG3110_DROS_1000_32     9 /* DR 10   Hz, OS Ratio 32 */
-#define MAG3110_DROS_0500_64    10 /* DR 5    Hz, OS Ratio 64 */
-#define MAG3110_DROS_0250_128   11 /* DR 2.5  Hz, OS Ratio 128 */
-#define MAG3110_DROS_1000_16    12 /* DR 10   Hz, OS Ratio 16 */
-#define MAG3110_DROS_0500_32    13 /* DR 5    Hz, OS Ratio 32 */
-#define MAG3110_DROS_0250_64    14 /* DR 2.5  Hz, OS Ratio 64 */
-#define MAG3110_DROS_0125_128   15 /* DR 1.25 Hz, OS Ratio 128 */
-#define MAG3110_DROS_0500_16    16 /* DR 5    Hz, OS Ratio 16 */
-#define MAG3110_DROS_0250_32    17 /* DR 2.5  Hz, OS Ratio 32 */
-#define MAG3110_DROS_0125_64    18 /* DR 1.25 Hz, OS Ratio 64 */
-#define MAG3110_DROS_0063_128   19 /* DR 0.63 Hz, OS Ratio 128 */
-#define MAG3110_DROS_0250_16    20 /* DR 2.5  Hz, OS Ratio 16 */
-#define MAG3110_DROS_0125_32    21 /* DR 1.25 Hz, OS Ratio 32 */
-#define MAG3110_DROS_0063_64    22 /* DR 0.63 Hz, OS Ratio 64 */
-#define MAG3110_DROS_0031_128   23 /* DR 0.31 Hz, OS Ratio 128 */
-#define MAG3110_DROS_0125_16    24 /* DR 1.25 Hz, OS Ratio 16 */
-#define MAG3110_DROS_0063_32    25 /* DR 0.63 Hz, OS Ratio 32 */
-#define MAG3110_DROS_0031_64    26 /* DR 0.31 Hz, OS Ratio 64 */
-#define MAG3110_DROS_0016_128   27 /* DR 0.16 Hz, OS Ratio 128 */
-#define MAG3110_DROS_0063_16    28 /* DR 0.63 Hz, OS Ratio 16 */
-#define MAG3110_DROS_0031_32    29 /* DR 0.31 Hz, OS Ratio 32 */
-#define MAG3110_DROS_0016_64    30 /* DR 0.16 Hz, OS Ratio 64 */
-#define MAG3110_DROS_0008_128   31 /* DR 0.08 Hz, OS Ratio 128 */
-#define MAG3110_DROS_DEFAULT    MAG3110_DROS_0125_128 
-                                /* Default Setting for testing*/
-
-namespace upm {
-
-typedef struct {
-    int16_t x;
-    int16_t y;
-    int16_t z;
-    uint8_t status;
-    int8_t dtemp;
-} mag3110_data_t;
-
-/**
- * @brief MAG3110 Three-Axis Digital Magnetometer
- * @defgroup mag3110 libupm-mag3110
- * @ingroup freescale i2c accelerometer compass
- */
-
-/**
- * @library mag3110
- * @sensor mag3110
- * @comname MAG3110 Three-Axis Digital Magnetometer
- * @type accelerometer compass
- * @man freescale
- * @web http://www.nxp.com/assets/documents/data/en/data-sheets/MAG3110.pdf
- * @con i2c
- *
- * @brief API for the MAG3110 Three-Axis Digital Magnetometer
- *
- * Description in web-link above:
- * The MAG3110 is a small, low-power digital 3D magnetic sensor with a wide
- * dynamic range to allow operation in PCBs with high extraneous magnetic
- * fields.
- * It measures the components of the local magnetic field, the sum of the
- * geomagnetic field and the magnetic field created by components on the
- * circuit board.
- * It can be used in conjunction with a 3-axis accelerometer so that
- * orientation-independent accurate compass heading information may be achieved
- * It is capable of measuring local magnetic fields up to 10 Gauss with output
- * data rates up to 80 Hz.
- *
- * @snippet mag3110.cxx Interesting
- */
-class MAG3110 {
-    public:
-        /**
-         *
-         * Instantiates an MAG3110 object
-         *
-         * @param bus Number of the used bus
-         * @param dros Data rate and over sampling selection
-         * @param devAddr Address of the used I2C device
-         */
-        MAG3110 (int bus, uint8_t dros=MAG3110_DROS_DEFAULT,
-                             int devAddr=MAG3110_I2C_ADDRESS);
-
-        /**
-         * Check device_id of sensor
-         *
-         * @return  0 on success
-         *         -1 on error
-         */
-        int checkID(void);
-
-        /**
-         * Set user offset correction
-         * Offset correction register will be erased after accelerometer reset
-         *
-         * @param x Offset correction value for x-axis
-         * @param y Offset correction value for y-axis
-         * @param z Offset correction value for z-axis
-         *
-         * @return  0 on success
-         *         -1 on error
-         */
-        int setUserOffset(int16_t x, int16_t y, int16_t z);
-
-        /**
-         * Set active mode, this enables periodic measurements
-         *
-         * @return  0 on success
-         *         -1 on error
-         */
-        int setActive(void);
-
-        /**
-         * Set standby mode, this disables periodic measurements
-         *
-         * @return  0 on success
-         *         -1 on error
-         */
-        int setStandby(void);
-
-        /**
-         * Check for new set of measurement data.
-         *
-         * @return >0 if x-, y- and z-axis new sample is ready
-         *          0 if measurement is in progress
-         */
-        int isReady(void);
-
-        /**
-         * Read magnetometer's data and saves them to variables
-         *
-         * Info: To get the actual values for the magnetic field someone
-         * has to divide the returned values from the magnetometer by 10
-         *
-         * @return  0 on success
-         *         -1 on error
-         */
-        int sampleData(void);
-
-        /**
-         * Get x-axis magnetic field strength
-         *
-         * @param bSampleData Flag to read sensor
-         * @return The x-axis magnetic field strength on success
-         *         -999 on error
-         */
-        int16_t getX(int bSampleData = 0);
-
-        /**
-         * Get y-axis magnetic field strength
-         *
-         * @param bSampleData Flag to read sensor
-         * @return The y-axis magnetic field strength on success
-         *         -999 on error
-         */
-        int16_t getY(int bSampleData = 0);
-
-        /**
-         * Get z-axis magnetic field strength
-         *
-         * @param bSampleData Flag to read sensor
-         * @return The z-axis magnetic field strength on success
-         *         -999 on error
-         */
-        int16_t getZ(int bSampleData = 0);
-
-        /**
-         * Get value of status register
-         *
-         * @return Value of status register
-         */
-        uint8_t getStatus(void);
-
-        /**
-         * Get die temperature
-         *
-         * @return Die temperature
-         */
-        int8_t getDieTemperature(void);
-
-        /**
-         * Get sensor values
-         *
-         * @param data Sensor values
-         * @param bSampleData Flag to read sensor
-         * @return  0 on success
-         *         -1 on error
-         */
-        int getData(mag3110_data_t* data, int bSampleData = 0);
-
-    private:
-
-        std::string m_name;
-
-        int m_controlAddr;
-        int m_bus;
-        mraa::I2c m_i2ControlCtx;
-
-        mag3110_data_t s_data[1];
-};
-
-}
diff --git a/src/mag3110/mag3110.json b/src/mag3110/mag3110.json
deleted file mode 100644
index b0d5781..0000000
--- a/src/mag3110/mag3110.json
+++ /dev/null
@@ -1,38 +0,0 @@
-{
-    "Library": "mag3110",
-    "Description": "API for the MAG3110 Three-Axis Digital Magnetometer",
-    "Sensor Class":
-    {
-        "MAG3110":
-        {
-            "Name": "MAG3110 Three-Axis Digital Magnetometer",
-            "Description": "The MAG3110 is a small, low-power digital 3D magnetic sensor with a wide dynamic range to allow operation in PCBs with high extraneous magnetic fields. It measures the components of the local magnetic field, the sum of the geomagnetic field and the magnetic field created by components on the circuit board. It can be used in conjunction with a 3-axis accelerometer so that orientation-independent accurate compass heading information may be achieved It is capable of measuring local magnetic fields up to 10 Gauss with output data rates up to 80 Hz.",
-            "Aliases": ["mag3110"],
-            "Categories": ["magnetometer"],
-            "Connections": ["i2c"],
-            "Project Type": ["imu", "prototyping"],
-            "Manufacturers": ["freescale"],
-            "Kits": [],
-            "Examples":
-            {
-                "Java": [],
-                "Python": ["mag3110.py"],
-                "Node.js": [],
-                "C++": ["mag3110.cxx"],
-                "C": []
-            },
-            "Specifications":
-            {
-                "Operating Voltage": {"unit": "V", "low": 1.95, "high": 3.6},
-                "Operating Current": {"unit": "uA", "low": 8.6, "high": 900},
-                "Operating Temperature": {"unit": "degC", "low": -40, "high": 85}
-            },
-            "Urls" :
-            {
-                "Product Pages": ["http://www.nxp.com/products/sensors/magnetometers/high-accuracy-3d-magnetometer:MAG3110"],
-                "Datasheets": ["http://www.nxp.com/docs/en/data-sheet/MAG3110.pdf"],
-                "Schematics": []
-            }
-        }
-    }
-}
diff --git a/src/max30100/CMakeLists.txt b/src/max30100/CMakeLists.txt
deleted file mode 100644
index f2e11c6..0000000
--- a/src/max30100/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME max30100
-    DESCRIPTION "Pulse Oximeter and Heart-rate Sensor"
-    C_HDR max30100.h
-    C_SRC max30100.c
-    CPP_HDR max30100.hpp
-    CPP_SRC max30100.cxx
-    FTI_SRC max30100_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/max30100/max30100.c b/src/max30100/max30100.c
deleted file mode 100644
index 9318efb..0000000
--- a/src/max30100/max30100.c
+++ /dev/null
@@ -1,536 +0,0 @@
-/*
- * Author: Noel Eck <noel.eck@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <assert.h>
-#include <stdlib.h>
-#include <syslog.h>
-#include <math.h>
-
-#include "max30100.h"
-#include "upm_utilities.h"
-
-max30100_context* max30100_init(int16_t i2c_bus)
-{
-    /* Allocate space for the sensor structure */
-    max30100_context* dev = (max30100_context*) malloc(sizeof(max30100_context));
-    if(dev == NULL)
-    {
-        syslog(LOG_CRIT, "%s: malloc() failed\n", __FUNCTION__);
-        goto max30100_init_fail;
-    }
-
-    /* Initialize mraa */
-    mraa_result_t result = mraa_init();
-    if (result != MRAA_SUCCESS)
-    {
-        syslog(LOG_ERR, "%s: mraa_init() failed (%d)\n", __FUNCTION__, result);
-        goto max30100_init_fail;
-    }
-
-    /* Initialize I2C */
-    dev->_i2c_context = mraa_i2c_init(i2c_bus);
-    if(dev->_i2c_context == NULL)
-    {
-        syslog(LOG_ERR, "%s: mraa_i2c_init() failed\n", __FUNCTION__);
-        goto max30100_init_fail;
-    }
-
-    /* Set the I2C slave address for this device */
-    if (mraa_i2c_address(dev->_i2c_context, MAX30100_I2C_ADDRESS) != MRAA_SUCCESS)
-    {
-        syslog(LOG_ERR, "%s: mraa_i2c_address() failed\n", __FUNCTION__);
-        goto max30100_init_fail;
-    }
-
-    /* Attempt to run the device at 100kHz */
-    if (mraa_i2c_frequency(dev->_i2c_context, MRAA_I2C_STD))
-        syslog(LOG_ERR, "%s: mraa_i2c_frequency() failed, device may not function correctly\n", __FUNCTION__);
-
-    /* Start without GPIO */
-    dev->_gpio_context = NULL;
-
-    return dev;
-
-    /* Handle all failing cases here */
-max30100_init_fail:
-    /* Free structure memory if allocated */
-    if (dev != NULL)
-        free(dev);
-
-    return NULL;
-}
-
-void max30100_close(max30100_context* dev)
-{
-    assert(dev != NULL && "max30100_close: Context cannot be NULL");
-
-    /* Cleanup the I2C context */
-    mraa_i2c_stop(dev->_i2c_context);
-    free(dev);
-}
-
-static void internal_uninstall_isr(max30100_context* dev)
-{
-    assert(dev != NULL && "internal_uninstall_isr: Context cannot be NULL");
-
-    /* If no GPIO context exists, return */
-    if (dev->_gpio_context == NULL) return;
-
-    mraa_gpio_isr_exit(dev->_gpio_context);
-    mraa_gpio_close(dev->_gpio_context);
-    dev->_gpio_context = NULL;
-}
-
-static upm_result_t _internal_install_isr(max30100_context* dev, int gpio_pin,
-                                 void (*isr)(void *), void *arg)
-{
-    /* Only allow one ISR */
-    internal_uninstall_isr(dev);
-
-    if (!(dev->_gpio_context = mraa_gpio_init(gpio_pin)))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    /* Set the GPIO to input */
-    if (mraa_gpio_dir(dev->_gpio_context, MRAA_GPIO_IN) != MRAA_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    /* MAX30100 interrupts are active low, pull GPIO high */
-    if (mraa_gpio_mode(dev->_gpio_context, MRAA_GPIO_PULLUP) != MRAA_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    /* Install the interrupt handler */
-    if (mraa_gpio_isr(dev->_gpio_context, MRAA_GPIO_EDGE_FALLING, isr, arg) != MRAA_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t max30100_read(const max30100_context* dev, MAX30100_REG reg, uint8_t* rd_data)
-{
-    assert(dev != NULL && "max30100_read: Context cannot be NULL");
-    /* Read the register */
-    int tmp_val = mraa_i2c_read_byte_data(dev->_i2c_context, reg);
-    if (tmp_val < 0) return UPM_ERROR_OPERATION_FAILED;
-
-    *rd_data = (uint8_t)tmp_val;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t max30100_write(const max30100_context* dev, MAX30100_REG reg, uint8_t wr_data)
-{
-    assert(dev != NULL && "max30100_write: Context cannot be NULL");
-
-    if (mraa_i2c_write_byte_data(dev->_i2c_context, (uint8_t)wr_data, reg) != MRAA_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t max30100_rd_mod_wr(const max30100_context* dev,
-        MAX30100_REG reg, uint8_t value, uint8_t mask)
-{
-    uint8_t tmp_val = 0;
-
-    /* Read the register */
-    upm_result_t result = max30100_read(dev, reg, &tmp_val);
-
-    if (result != UPM_SUCCESS) return result;
-
-    /* Modify the value, firt clear the bits from mask */
-    tmp_val &= (~mask);
-    /* Make sure the new value doesn't have anything set outside the mask */
-    value &= mask;
-    /* OR in the new value */
-    tmp_val |= value;
-
-    /* Write the value back */
-    return max30100_write(dev, reg, tmp_val);
-}
-
-upm_result_t max30100_get_version(const max30100_context* dev, uint16_t* version)
-{
-    assert(dev != NULL && "max30100_get_version: Context cannot be NULL");
-
-    /* Read the revision ID */
-    uint8_t tmp_val = 0;
-    upm_result_t result = max30100_read(dev, MAX30100_REG_REV_ID, &tmp_val);
-    if (result != UPM_SUCCESS) return result;
-
-    *version = (uint8_t)tmp_val;
-
-    result = max30100_read(dev, MAX30100_REG_PART_ID, &tmp_val);
-    if (result != UPM_SUCCESS) return result;
-
-    /* Move the PART ID to upper byte */
-    *version += ((uint16_t)tmp_val << 8);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t max30100_get_temperature(const max30100_context* dev, float* temperature)
-{
-    assert(dev != NULL && "max30100_get_temperature: Context cannot be NULL");
-    int8_t tmp_val = 0;
-
-    /* First, set TEMP_EN to initiate a temperature read */
-    upm_result_t result = max30100_rd_mod_wr(dev, MAX30100_REG_MODE_CONFIG,
-            MAX30100_TEMP_EN, MAX30100_TEMP_EN);
-    if (result != UPM_SUCCESS) return result;
-
-    /* Note, the docs for reading a temperature value states:
-     * This is a self-clearing bit which, when set, initiates a single
-     * temperature reading from the temperature sensor. This bit is
-     * cleared automatically back to zero at the conclusion of the
-     * temperature reading when the bit is set to one in heart rate
-     * or SpO2 mode.
-     *
-     * However, the next read of the MODE CONFIG register *always* seems
-     * to have TEMP_EN cleared w/o values in TINT/TFRAC until a short
-     * while later.  To account for this, a delay has been added - sorry */
-
-    upm_delay_ms(100);
-
-    /* Read the integer portion of the temperature */
-    result = max30100_read(dev, MAX30100_REG_TEMP_INTEGER, (uint8_t*)&tmp_val);
-    if (result != UPM_SUCCESS) return result;
-
-    /* cast the signed integer portion to float */
-    *temperature = (float)tmp_val;
-
-    /* This register stores the fractional temperature data in increments of
-     * 0.0625C (1/16th of a degree C).  If this fractional temperature is
-     * paired with a negative integer, it still adds as a positive fractional
-     * value (e.g., -128 C + 0.5 C = -127.5 C). */
-    result = max30100_read(dev, MAX30100_REG_TEMP_FRACTION, (uint8_t*)&tmp_val);
-    if (result != UPM_SUCCESS) return result;
-
-    /* Add the fraction */
-    *temperature += ((float)tmp_val)/16.0;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t max30100_set_mode(const max30100_context* dev, MAX30100_MODE mode)
-{
-    assert(dev != NULL && "max30100_set_mode: Context cannot be NULL");
-    return max30100_rd_mod_wr(dev, MAX30100_REG_MODE_CONFIG, (uint8_t)mode, 0x03);
-}
-
-upm_result_t max30100_get_mode(const max30100_context* dev, MAX30100_MODE* mode)
-{
-    assert(dev != NULL && "max30100_get_mode: Context cannot be NULL");
-
-    /* Read the mode configuration register */
-    uint8_t data = 0;
-    upm_result_t result = max30100_read(dev, MAX30100_REG_MODE_CONFIG, &data);
-    if (result != UPM_SUCCESS) return result;
-
-    *mode = (MAX30100_MODE) data & 0x7;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t max30100_set_high_res(const max30100_context* dev, bool high_res)
-{
-    assert(dev != NULL && "MAX30100_set_high_res: Context cannot be NULL");
-    uint8_t wr_val = high_res ? MAX30100_SPO2_HI_RES_EN : ~MAX30100_SPO2_HI_RES_EN;
-    return max30100_rd_mod_wr(dev, MAX30100_REG_SPO2_CONFIG, wr_val, 0x40);
-}
-
-upm_result_t max30100_get_high_res(const max30100_context* dev, bool* high_res)
-{
-    assert(dev != NULL && "MAX30100_get_high_res: Context cannot be NULL");
-
-    /* Read the SpO2 configuration register */
-    uint8_t data = 0;
-    upm_result_t result = max30100_read(dev, MAX30100_REG_SPO2_CONFIG, &data);
-    if (result != UPM_SUCCESS) return result;
-
-    *high_res = data & 0x40;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t max30100_set_sample_rate(const max30100_context* dev, MAX30100_SR sample_rate)
-{
-    assert(dev != NULL && "MAX30100_set_sample_rate: Context cannot be NULL");
-    return max30100_rd_mod_wr(dev, MAX30100_REG_SPO2_CONFIG, (uint8_t)sample_rate << 2, 0x1c);
-}
-
-upm_result_t max30100_get_sample_rate(const max30100_context* dev, MAX30100_SR* sample_rate)
-{
-    assert(dev != NULL && "MAX30100_get_high_res: Context cannot be NULL");
-
-    /* Read the SpO2 configuration register */
-    uint8_t data = 0;
-    upm_result_t result = max30100_read(dev, MAX30100_REG_SPO2_CONFIG, &data);
-    if (result != UPM_SUCCESS) return result;
-
-    *sample_rate = (MAX30100_SR)((data >> 2) & 0x7);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t max30100_set_pulse_width(const max30100_context* dev, MAX30100_LED_PW pulse_width)
-{
-    assert(dev != NULL && "MAX30100_set_pulse_width: Context cannot be NULL");
-    return max30100_rd_mod_wr(dev, MAX30100_REG_SPO2_CONFIG, (uint8_t)pulse_width, 0x03);
-}
-
-upm_result_t max30100_get_pulse_width(const max30100_context* dev, MAX30100_LED_PW* pulse_width)
-{
-    assert(dev != NULL && "MAX30100_get_high_res: Context cannot be NULL");
-
-    /* Read the SpO2 configuration register */
-    uint8_t data = 0;
-    upm_result_t result = max30100_read(dev, MAX30100_REG_SPO2_CONFIG, &data);
-    if (result != UPM_SUCCESS) return result;
-
-    *pulse_width = (MAX30100_LED_PW)(data & 0x3);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t max30100_set_current(const max30100_context* dev,
-        MAX30100_LED_CURRENT ir, MAX30100_LED_CURRENT r)
-{
-    assert(dev != NULL && "max30100_set_current: Context cannot be NULL");
-
-    return max30100_write(dev, MAX30100_REG_LED_CONFIG,
-            (uint8_t)((r << 4) | r));
-}
-
-upm_result_t max30100_get_current(const max30100_context* dev,
-        MAX30100_LED_CURRENT* ir, MAX30100_LED_CURRENT* r)
-{
-    assert(dev != NULL && "max30100_get_current: Context cannot be NULL");
-
-    /* Read the LED configuration register */
-    uint8_t data = 0;
-    upm_result_t result = max30100_read(dev, MAX30100_REG_LED_CONFIG, &data);
-    if (result != UPM_SUCCESS) return result;
-
-    *ir = (MAX30100_LED_CURRENT)(data & 0x0f);
-    *r = (MAX30100_LED_CURRENT)((data >> 4) & 0x0f);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t max30100_reset(const max30100_context* dev)
-{
-    assert(dev != NULL && "max30100_reset: Context cannot be NULL");
-
-    /* Set the RESET bit, don't worry about read/mod/write */
-    return max30100_write(dev, MAX30100_REG_MODE_CONFIG, (uint8_t)0x40);
-}
-
-upm_result_t max30100_sleep(const max30100_context* dev, bool sleep)
-{
-    assert(dev != NULL && "max30100_sleep: Context cannot be NULL");
-
-    /* Read/mod/write to set the SHDN bit */
-    uint8_t wr_val = sleep ? MAX30100_SHDN : (uint8_t)~MAX30100_SHDN;
-    return max30100_rd_mod_wr(dev, MAX30100_REG_MODE_CONFIG, wr_val, MAX30100_SHDN);
-}
-
-static upm_result_t _read_single_sample(const max30100_context* dev, max30100_value *samp)
-{
-    uint8_t data[4];
-    if (mraa_i2c_read_bytes_data(dev->_i2c_context,  MAX30100_REG_FIFO_DATA, data, 4) != 4)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    samp->IR = ((uint16_t)data[0] << 8) | data[1];
-    samp->R = ((uint16_t)data[2] << 8) | data[3];
-
-    return UPM_SUCCESS;
-}
-
-static void _internal_sample_rdy(void *arg)
-{
-    max30100_context* dev = arg;
-
-    if (dev->sample_state == MAX30100_SAMPLE_STATE_IDLE) return;
-
-    int i = 15;
-    max30100_value samp = {0, 0};
-    /* If state is BUFFERED, read 16 samples, else read 1 sample */
-    do
-    {
-        if (_read_single_sample(dev, &samp) != UPM_SUCCESS)
-            goto max30100_sample_rdy_fail;
-
-        // Call handler
-        dev->func_sample_ready(samp, dev->arg);
-
-    } while ((i-- > 0) && (dev->sample_state == MAX30100_SAMPLE_STATE_CONTINUOUS_BUFFERED));
-
-    /* If a FIFO full interrupt generated this, clear it by reading sts */
-    uint8_t tmp;
-    if (dev->sample_state == MAX30100_SAMPLE_STATE_CONTINUOUS_BUFFERED)
-        if(max30100_read(dev, MAX30100_REG_INTERRUPT_STATUS, &tmp) != UPM_SUCCESS)
-            goto max30100_sample_rdy_fail;
-
-    return;
-
-    /* If a failure occurs in this method (which running on a seperate thread,
-     * log an error in syslog and attempt to stop sampling
-     * Handle all failing cases here */
-    max30100_sample_rdy_fail:
-        syslog(LOG_CRIT,
-                "%s: _internal_sample_rdy() failed, attempting to restart sampling...\n",
-                __FUNCTION__);
-
-        /* Read FIFO AND status register in a last attempt to continue
-         * sampling, ignore result */
-        max30100_read(dev, MAX30100_REG_FIFO_WR_PTR, &tmp);
-        max30100_read(dev, MAX30100_REG_INTERRUPT_STATUS, &tmp);
-
-        return;
-}
-
-upm_result_t max30100_sample(max30100_context* dev, max30100_value *samp)
-{
-    assert(dev != NULL && "max30100_sample: Context cannot be NULL");
-
-    upm_result_t result = UPM_SUCCESS;
-
-    // Disable interrupts
-    result = max30100_write(dev, MAX30100_REG_INTERRUPT_ENABLE, 0x00);
-    if (result != UPM_SUCCESS) return result;
-
-    /* Set the state to one-shot */
-    dev->sample_state = MAX30100_SAMPLE_STATE_ONE_SHOT;
-
-    /* Clear wr/rd pointers */
-    result = max30100_write(dev, MAX30100_REG_FIFO_WR_PTR, 0x00);
-    if (result != UPM_SUCCESS) return result;
-    result = max30100_write(dev, MAX30100_REG_FIFO_RD_PTR, 0x00);
-    if (result != UPM_SUCCESS) return result;
-
-    /* Wait for a sample */
-    uint8_t wr_ptr = 0;
-    int retry = 50;
-    while ((wr_ptr == 0) && (--retry > 0))
-    {
-        result = max30100_read(dev, MAX30100_REG_FIFO_WR_PTR, &wr_ptr);
-        if (result != UPM_SUCCESS) return result;
-    }
-
-    /* Return timeout if retry count is zero */
-    if (retry == 0) return UPM_ERROR_TIMED_OUT;
-
-    /* Set the rd ptr to wr ptr to ensure reading the most current sample */
-    result = max30100_write(dev, MAX30100_REG_FIFO_RD_PTR, wr_ptr - 1);
-    if (result != UPM_SUCCESS) return result;
-
-    /* Read the sample */
-    if (_read_single_sample(dev, samp) != UPM_SUCCESS)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t max30100_sample_continuous(max30100_context* dev, int gpio_pin,
-        bool buffered, func_sample_ready_handler isr, void* arg)
-{
-    assert(dev != NULL && "max30100_sample_continuous: Context cannot be NULL");
-    uint8_t tmp;
-
-    upm_result_t result = UPM_SUCCESS;
-
-    // Set state to IDLE
-    dev->sample_state = MAX30100_SAMPLE_STATE_IDLE;
-
-    // Disable interrupts
-    result = max30100_write(dev, MAX30100_REG_INTERRUPT_ENABLE, 0x00);
-    if (result != UPM_SUCCESS) return result;
-
-    /* Setup the external callback info */
-    dev->func_sample_ready = isr;
-    dev->arg = arg;
-    // Register internal callback handler
-    result = _internal_install_isr(dev, gpio_pin, _internal_sample_rdy, dev);
-    if (result != UPM_SUCCESS) return result;
-
-    uint8_t tmp_int_en = 0;
-    if (buffered)
-    {
-        dev->sample_state = MAX30100_SAMPLE_STATE_CONTINUOUS_BUFFERED;
-
-        // Set value of interrupt for FIFO_FULL
-        tmp_int_en = MAX30100_EN_A_FULL;
-    }
-    else
-    {
-        dev->sample_state = MAX30100_SAMPLE_STATE_CONTINUOUS;
-
-        // Read the mode field from the mode configuration register,
-        // decide which interrupt to set
-        result = max30100_read(dev, MAX30100_REG_MODE_CONFIG, &tmp);
-        if (result != UPM_SUCCESS) return result;
-        MAX30100_MODE mode = (MAX30100_MODE)(tmp & 0x3);
-
-        // Set value of interrupt for HR or SpO2
-        tmp_int_en = mode == MAX30100_MODE_HR_EN ? MAX30100_EN_HR_RDY :
-            (mode == MAX30100_MODE_SPO2_EN ? MAX30100_EN_SPO2_RDY : 0x00);
-    }
-
-    /* Clear wr/rd pointers */
-    result = max30100_write(dev, MAX30100_REG_FIFO_WR_PTR, 0x00);
-    if (result != UPM_SUCCESS) return result;
-    result = max30100_write(dev, MAX30100_REG_FIFO_RD_PTR, 0x00);
-    if (result != UPM_SUCCESS) return result;
-
-    /* Enable interrupt, either FIFO full, HR only, or SpO2 */
-    result = max30100_write(dev, MAX30100_REG_INTERRUPT_ENABLE, tmp_int_en);
-    if (result != UPM_SUCCESS) return result;
-
-    /* Read the STATUS register to get things moving */
-    result = max30100_read(dev, MAX30100_REG_INTERRUPT_STATUS, &tmp);
-    if (result != UPM_SUCCESS) return result;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t max30100_sample_stop(max30100_context* dev)
-{
-    assert(dev != NULL && "max30100_sample_stop: Context cannot be NULL");
-
-    dev->sample_state = MAX30100_SAMPLE_STATE_IDLE;
-
-    /* Uninstall sampling ISR */
-    internal_uninstall_isr(dev);
-
-//    // Disable sampling
-//    upm_result_t result = max30100_write(dev, MAX30100_REG_MODE_CONFIG, MAX30100_MODE_DISABLED);
-//    if (result != UPM_SUCCESS) return result;
-
-    // Disable interrupts
-    upm_result_t result = max30100_write(dev, MAX30100_REG_INTERRUPT_ENABLE, 0);
-    if (result != UPM_SUCCESS) return result;
-
-    return UPM_SUCCESS;
-}
-
diff --git a/src/max30100/max30100.cxx b/src/max30100/max30100.cxx
deleted file mode 100644
index 01f64a3..0000000
--- a/src/max30100/max30100.cxx
+++ /dev/null
@@ -1,213 +0,0 @@
-/*
- * Author: Noel Eck <noel.eck@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <stdexcept>
-#include <string>
-
-#include "max30100.hpp"
-
-using namespace upm;
-
-void max30100_throw(std::string func, std::string cmd, upm_result_t result)
-{
-    throw std::runtime_error(func + ": " + cmd + " failed, " +
-            "upm_result_t: " + std::to_string(result));
-}
-
-MAX30100::MAX30100(int16_t i2c_bus) : _dev(max30100_init(i2c_bus))
-{
-    if (_dev == NULL)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                ": failed to initialize sensor, check syslog");
-}
-
-void _read_sample_proxy(max30100_value sample, void* _max30100)
-{
-    if ((_max30100 != NULL) && ((MAX30100*)_max30100)->_callback != NULL)
-        ((MAX30100*)_max30100)->_callback->run(sample);
-}
-
-max30100_value MAX30100::sample()
-{
-    max30100_value retval;
-    upm_result_t result = max30100_sample(_dev, &retval);
-    if (result != UPM_SUCCESS)
-        max30100_throw(__FUNCTION__, "max30100_sample", result);
-    return retval;
-}
-
-
-void MAX30100::sample_continuous(int gpio_pin, bool buffered, Callback *cb)
-{
-    // Use a default callback if one is NOT provided
-    if (cb == NULL)
-        _callback = (Callback *)&_default_callback;
-    else
-        _callback = cb;
-    max30100_sample_continuous(_dev, gpio_pin, buffered, &_read_sample_proxy, this);
-}
-
-void MAX30100::sample_stop()
-{
-    upm_result_t result = max30100_sample_stop(_dev);
-    if (result != UPM_SUCCESS)
-        max30100_throw(__FUNCTION__, "max30100_sample_stop" , result);
-}
-
-uint16_t MAX30100::version()
-{
-    uint16_t retval;
-    upm_result_t result = max30100_get_version(_dev, &retval);
-    if (result != UPM_SUCCESS)
-        max30100_throw(__FUNCTION__, "max30100_get_version" , result);
-    return retval;
-}
-
-float MAX30100::temperature()
-{
-    float retval;
-    upm_result_t result = max30100_get_temperature(_dev, &retval);
-    if (result != UPM_SUCCESS)
-        max30100_throw(__FUNCTION__, "max30100_get_temperature", result);
-    return retval;
-}
-
-void MAX30100::mode(MAX30100_MODE mode)
-{
-    upm_result_t result = max30100_set_mode(_dev, mode);
-    if (result != UPM_SUCCESS)
-        max30100_throw(__FUNCTION__, "max30100_set_mode", result);
-}
-
-MAX30100_MODE MAX30100::mode()
-{
-    MAX30100_MODE mode;
-    upm_result_t result =  max30100_get_mode(_dev, &mode);
-    if (result != UPM_SUCCESS)
-        max30100_throw(__FUNCTION__, "max30100_get_mode", result);
-    return mode;
-}
-
-void MAX30100::high_res_enable(bool enable)
-{
-    upm_result_t result = max30100_set_high_res(_dev, enable);
-    if (result != UPM_SUCCESS)
-        max30100_throw(__FUNCTION__, "max30100_set_high_res", result);
-}
-
-bool MAX30100::high_res_enable()
-{
-    bool enabled;
-    upm_result_t result =  max30100_get_high_res(_dev, &enabled);
-    if (result != UPM_SUCCESS)
-        max30100_throw(__FUNCTION__, "max30100_get_high_res", result);
-    return enabled;
-}
-
-void MAX30100::sample_rate(MAX30100_SR sample_rate)
-{
-    upm_result_t result = max30100_set_sample_rate(_dev, sample_rate);
-    if (result != UPM_SUCCESS)
-        max30100_throw(__FUNCTION__, "max30100_set_sample_rate", result);
-}
-
-MAX30100_SR MAX30100::sample_rate()
-{
-    MAX30100_SR sample_rate;
-    upm_result_t result =  max30100_get_sample_rate(_dev, &sample_rate);
-    if (result != UPM_SUCCESS)
-        max30100_throw(__FUNCTION__, "max30100_get_sample_rate", result);
-    return sample_rate;
-}
-
-void MAX30100::pulse_width(MAX30100_LED_PW pulse_width)
-{
-    upm_result_t result = max30100_set_pulse_width(_dev, pulse_width);
-    if (result != UPM_SUCCESS)
-        max30100_throw(__FUNCTION__, "max30100_set_pulse_width", result);
-}
-
-MAX30100_LED_PW MAX30100::pulse_width()
-{
-    MAX30100_LED_PW pulse_width;
-    upm_result_t result =  max30100_get_pulse_width(_dev, &pulse_width);
-    if (result != UPM_SUCCESS)
-        max30100_throw(__FUNCTION__, "max30100_get_pulse_width", result);
-    return pulse_width;
-}
-
-void MAX30100::current(MAX30100_LED_CURRENT ir, MAX30100_LED_CURRENT r)
-{
-    upm_result_t result =  max30100_set_current(_dev, ir, r);
-    if (result != UPM_SUCCESS)
-        max30100_throw(__FUNCTION__, "set_current", result);
-}
-
-MAX30100_LED_CURRENT MAX30100::current_ir()
-{
-    MAX30100_LED_CURRENT ir, r;
-    upm_result_t result =  max30100_get_current(_dev, &ir, &r);
-    if (result != UPM_SUCCESS)
-        max30100_throw(__FUNCTION__, "get_current_ir", result);
-    return ir;
-}
-
-MAX30100_LED_CURRENT MAX30100::current_r()
-{
-    MAX30100_LED_CURRENT ir, r;
-    upm_result_t result =  max30100_get_current(_dev, &ir, &r);
-    if (result != UPM_SUCCESS)
-        max30100_throw(__FUNCTION__, "get_current_r", result);
-    return r;
-}
-
-void MAX30100::reset()
-{
-    upm_result_t result =  max30100_reset(_dev);
-    if (result != UPM_SUCCESS)
-        max30100_throw(__FUNCTION__, "max30100_reset", result);
-}
-
-uint8_t MAX30100::read(MAX30100_REG reg)
-{
-    uint8_t retval;
-    upm_result_t result = max30100_read(_dev, reg, &retval);
-    if (result != UPM_SUCCESS)
-        max30100_throw(__FUNCTION__, "max30100_read", result);
-    return retval;
-}
-
-void MAX30100::write(MAX30100_REG reg, uint8_t value)
-{
-    upm_result_t result =  max30100_write(_dev, reg, value);
-    if (result != UPM_SUCCESS)
-        max30100_throw(__FUNCTION__, "max30100_write", result);
-}
-
-void MAX30100::sleep(bool sleep)
-{
-    upm_result_t result =  max30100_sleep(_dev, sleep);
-    if (result != UPM_SUCCESS)
-        max30100_throw(__FUNCTION__, "max30100_sleep", result);
-}
diff --git a/src/max30100/max30100.h b/src/max30100/max30100.h
deleted file mode 100644
index 8f5fad2..0000000
--- a/src/max30100/max30100.h
+++ /dev/null
@@ -1,318 +0,0 @@
-/*
- * Author: Noel Eck <noel.eck@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <errno.h>
-#include <stdint.h>
-
-#include "max30100_regs.h"
-
-#include "mraa/gpio.h"
-#include "mraa/i2c.h"
-#include "upm.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @file max30100.h
- * @library max30100
- * @brief C API for the Pulse oximeter and heart-rate sensor.
- *
- * @include max30100.c
- */
-
-/**
- * device context
- */
-typedef struct {
-    /* mraa I2C context */
-    mraa_i2c_context _i2c_context;
-
-    /* mraa gpio context (for interrupt) */
-    mraa_gpio_context _gpio_context;
-
-    /* Sensor acquire mode */
-    MAX30100_SAMPLE_STATE sample_state;
-
-    /* Continuous sampling function ptr */
-    func_sample_ready_handler func_sample_ready;
-
-    /* Optional void ptr arg returned from callback */
-    void* arg;
-} max30100_context;
-
-/**
- * Initialize sensor.  Note, the MAX30100 I2C address is set to 0x57.
- *
- * @param i2c_bus Target I2C bus
- * @return sensor context pointer
- */
-max30100_context* max30100_init(int16_t i2c_bus);
-
-/**
- * Sensor close method.
- *
- * Cleans up any memory held by this device
- * @param dev Sensor context pointer
- */
-void max30100_close(max30100_context* dev);
-
-/**
- * Sample a single set of infrared/red values
- *
- * Note, all setup (sample rate, LED current, and pulse width must be done
- * prior to calling this sample method.
- *
- * @param dev Sensor context pointer
- * @param samp IR/R values are returned in this structure
- * @return Function result code
- */
-upm_result_t max30100_sample(max30100_context* dev, max30100_value *samp);
-
-/**
- * Continuously sample Infrared/Red values.
- *
- * This method requires a GPIO pin which is used to signal
- * sample/samples ready.  The INT * pin is open-drain and requires a
- * pullup resistor. The interrupt pin is not designed  to sink large
- * currents, so the pull-up resistor value should be large, such as
- * 4.7k ohm.  The RCWL-0530 PCB which this library was designed with
- * had the I2C lines and INT pin pulled up to 1.8v.
- *
- * Note, all setup (sample rate, mode, LED current, and pulse width
- * must be done prior to calling this sample method.
- *
- * @param dev Sensor context pointer
- * @param gpio_pin GPIO pin used for interrupt (input from sensor INT pin)
- * @param buffered Enable buffered sampling.  In buffered sampling mode, the
- * device reads 16 samples at a time.  This can help with I2C read timing.
- *      buffered == true, enable buffered sampling
- *      buffered == false, single-sample mode
- * @param isr Function pointer which handles 1 IR/R sample and a void ptr arg
- * @param arg Void * passed back with ISR call
- * @return Function result code
- */
-upm_result_t max30100_sample_continuous(max30100_context* dev,
-                                        int gpio_pin,
-                                        bool buffered,
-                                        func_sample_ready_handler isr,
-                                        void* arg);
-
-/**
- * Stop continuous sampling.  Disable interrupts.
- *
- * @param dev Sensor context pointer
- * @return Function result code
- */
-upm_result_t max30100_sample_stop(max30100_context* dev);
-
-/**
- * Read Oximeter and heart-rate sensor register
- *
- * @param dev Sensor context pointer
- * @param reg Target register
- * @param rd_data Data from sensor
- * @return Function result code
- */
-upm_result_t max30100_read(const max30100_context* dev, MAX30100_REG reg, uint8_t* rd_data);
-
-/**
- * Write Oximeter and heart-rate sensor register
- *
- * @param dev Sensor context pointer
- * @param reg Target register to write
- * @param wr_data Target data to write
- * @return Function result code
- */
-upm_result_t max30100_write(const max30100_context* dev, MAX30100_REG reg, uint8_t wr_data);
-
-/**
- * Read modify write Oximeter and heart-rate sensor register
- *
- * @param dev Sensor context pointer
- * @param reg Target register
- * @param value Target bits to set/clear
- * @param mask Specify the bits to set/clear
- *      If mask = 0xf0, read full byte, modify only the upper 4 bits
- *      If mask = 0xaa, read full byte, modify every other bit
- * @return Function result code
- */
-upm_result_t max30100_rd_mod_wr(const max30100_context* dev,
-        MAX30100_REG reg, uint8_t value, uint8_t mask);
-
-/**
- * Get sensor version
- * Sensor version is a 2 byte value:
- *      upper byte = PART ID
- *      lower byte = REVISION ID
- *
- * example:
- *      version() return 0x1105
- *      0x11 = PART ID
- *      0x05 = REVISION
- *
- * @param dev Sensor context pointer
- * @param rd_data Sensor version
- * @return Function result code
- */
-upm_result_t max30100_get_version(const max30100_context* dev, uint16_t* version);
-
-/**
- * Get temperature reading from device
- * @param dev Sensor context pointer
- * @param rd_data Temperature in degrees Celsius
- * @return Function result code
- */
-upm_result_t max30100_get_temperature(const max30100_context* dev, float* temperature);
-
-/**
- * Set the sampling mode (none vs red only vs SpO2)
- *
- * @param dev Sensor context pointer
- * @param mode Sensor mode value to write into the mode configuration register
- * @return Function result code
- */
-upm_result_t max30100_set_mode(const max30100_context* dev, MAX30100_MODE mode);
-
-/**
- * Get the mode field from the mode configuration register
- *
- * @param dev Sensor context pointer
- * @param mode Sensor mode value read from mode configuration register
- * @return Function result code
- */
-upm_result_t max30100_get_mode(const max30100_context* dev, MAX30100_MODE* mode);
-
-/**
- * Set the high-res field in the SpO2 configuration register
- *
- * @param dev Sensor context pointer
- * @param high_res Sensor high-res value to write into the SpO2 configuration register
- * @return Function result code
- */
-upm_result_t max30100_set_high_res(const max30100_context* dev, bool high_res);
-
-/**
- * Get the high-res field from the SpO2 configuration register
- *
- * @param dev Sensor context pointer
- * @param high_res Sensor high_res value read from the SpO2 configuration register
- * @return Function result code
- */
-upm_result_t max30100_get_high_res(const max30100_context* dev, bool* high_res);
-
-/**
- * Set the sample rate field in the SpO2 configuration register
- *
- * @param dev Sensor context pointer
- * @param sample_rate Sensor sample rate value to write into the SpO2 configuration register
- * @return Function result code
- */
-upm_result_t max30100_set_sample_rate(const max30100_context* dev, MAX30100_SR sample_rate);
-
-/**
- * Get the sample rate field from the SpO2 configuration register
- *
- * @param dev Sensor context pointer
- * @param sample_rate Sensor sample rate value read from the SpO2 configuration register
- * @return Function result code
- */
-upm_result_t max30100_get_sample_rate(const max30100_context* dev, MAX30100_SR* sample_rate);
-
-/**
- * Set the pulse width field in the SpO2 configuration register
- *
- * @param dev Sensor context pointer
- * @param pulse_width Sensor pulse width value to write into the SpO2 configuration register
- * @return Function result code
- */
-upm_result_t max30100_set_pulse_width(const max30100_context* dev, MAX30100_LED_PW pulse_width);
-
-/**
- * Get the pulse width field from the SpO2 configuration register
- *
- * @param dev Sensor context pointer
- * @param pulse_width Sensor pulse width value read from the SpO2 configuration register
- * @return Function result code
- */
-upm_result_t max30100_get_pulse_width(const max30100_context* dev, MAX30100_LED_PW* pulse_width);
-
-/**
- * Set the LED current
- *
- * @param dev Sensor context pointer
- * @param ir Infrared LED current enum
- * @param r Red LED current enum
- * @return Function result code
- */
-upm_result_t max30100_set_current(const max30100_context* dev,
-        MAX30100_LED_CURRENT ir,
-        MAX30100_LED_CURRENT r);
-
-/**
- * Get the LED current
- *
- * @param dev Sensor context pointer
- * @param ir Infrared LED current read from the LED configuration register
- * @param r Red LED current read from the LED configuration register
- * @return Function result code
- */
-upm_result_t max30100_get_current(const max30100_context* dev,
-        MAX30100_LED_CURRENT* ir,
-        MAX30100_LED_CURRENT* r);
-
-/**
- * Reset sensor
- *
- * When the RESET bit is set to one, all configuration, threshold,
- * and data registers are reset to their power-on-state. The only
- * exception is writing both RESET and TEMP_EN bits to one at the
- * same time since temperature data registers 0x16 and 0x17 are not
- * cleared. The RESET bit is cleared automatically back to zero after
- * the reset sequence is completed.
- *
- * @param dev Sensor context pointer
- * @return Function result code
- */
-upm_result_t max30100_reset(const max30100_context* dev);
-
-/**
- * Put device into power-save mode.  While in power-save mode, all
- * registers retain their values, and write/read operations function
- * as normal. All interrupts are cleared to zero in this mode.
- *
- * @param dev Sensor context pointer
- * @param sleep Enter/exit power-save mode
- *      true = Enter power-save mode
- *      false = Exit power-save mode
- * @return Function result code
- */
-upm_result_t max30100_sleep(const max30100_context* dev, bool sleep);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/max30100/max30100.hpp b/src/max30100/max30100.hpp
deleted file mode 100644
index a99149b..0000000
--- a/src/max30100/max30100.hpp
+++ /dev/null
@@ -1,295 +0,0 @@
-/*
- * Author: Noel Eck <noel.eck@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <iostream>
-
-#include "mraa/i2c.h"
-#include "max30100.h"
-
-namespace upm {
-
-/* Callback class for continuously reading samples */
-class Callback {
-    public:
-        virtual ~Callback() { }
-        /* Default run method, called for each new sample in continous
-         * sampling mode.
-         * Override this method */
-        virtual void run(max30100_value samp)
-        { std::cout << "Base sample IR: " << samp.IR << " R: " << samp.R << std::endl; }
-};
-
-/**
- * @brief MAX30100 Pulse Oximeter and Heart Rate Sensor
- * @defgroup max30100 libupm-max30100
- * @ingroup maxim i2c medical
- */
-
-/**
- * @library max30100
- * @sensor max30100
- * @comname Pulse Oximeter and Heart-rate Sensor
- * @type medical
- * @man maxim
- * @web https://www.maximintegrated.com/en/products/analog/sensors-and-sensor-interface/MAX30100.html
- * @con i2c gpio
- *
- * @brief API for the Pulse oximeter and heart-rate sensor
- *
- * The MAX30100 is an integrated pulse oximetry and heartrate monitor sensor
- * solution. It combines two LEDs, a photodetector, optimized optics, and
- * low-noise analog signal processing to detect pulse oximetry and heart-rate
- * signals.
- *
- * I2C sensor which can be used to read:
- *    Heart-rate
- *    Peripheral capillary oxygen saturation
- *    temperature
- *
- * @image html max30100.png
- * @snippet max30100.cxx Interesting
- */
-
-class MAX30100 {
-    public:
-        /**
-         * Oximeter and heart-rate sensor constructor
-         *
-         * Initialize Oximeter and heart-rate sensor.  Note, the I2C address
-         * is 0x57.
-         * @param i2c_bus Target I2C bus
-         * @return sensor context pointer
-         * @throws std::runtime_error if sensor initialization fails
-         */
-        MAX30100(int16_t i2c_bus);
-
-        /**
-         * MAX30100 destructor
-         */
-        virtual ~MAX30100() {};
-
-        /**
-         * Sample a single set of infrared/red values
-         *
-         * Note, all setup (sample rate, LED current, and pulse width must be done
-         * prior to calling this sample method.
-         *
-         * @return One IR/R sample
-         * @throws std::runtime_error on I2C command failure
-         */
-        max30100_value sample();
-
-        /**
-         * Continuously sample Infrared/Red values.
-         *
-         * This method requires a GPIO pin which is used to signal
-         * sample/samples ready.  The INT * pin is open-drain and requires a
-         * pullup resistor. The interrupt pin is not designed  to sink large
-         * currents, so the pull-up resistor value should be large, such as
-         * 4.7k ohm.  The RCWL-0530 PCB which this library was designed with
-         * had the I2C lines and INT pin pulled up to 1.8v.
-         *
-         * Note, all setup (sample rate, mode, LED current, and pulse width
-         * must be done prior to calling this sample method.
-         *
-         * @param gpio_pin GPIO pin for interrupt (input from sensor INT pin)
-         * @param buffered Enable buffered sampling.  In buffered sampling mode,
-         * the device reads 16 samples at a time.  This can help with I2C read
-         * timing.
-         *      buffered == true, enable buffered sampling
-         *      buffered == false, single-sample mode
-         * @param cb Pointer to instance of Callback class.  If parameter is left
-         * NULL, a default instance of the Callback class will be used which
-         * prints out the IR/R values.
-         * @throws std::runtime_error on I2C command failure
-         */
-        void sample_continuous(int gpio_pin, bool buffered, Callback *cb = NULL);
-
-        /**
-         * Stop continuous sampling.  Disable interrupts.
-         */
-        void sample_stop();
-
-        /**
-         * Read Oximeter and heart-rate sensor registers
-         * @param reg Target register to read
-         * @return Data returned from sensor
-         * @throws std::runtime_error if I2C read command fails
-         */
-        uint8_t read(MAX30100_REG reg);
-
-        /**
-         * Write Oximeter and heart-rate sensor registers
-         * @param reg Target register to write
-         * @param wr_data Target data to write
-         * @throws std::runtime_error if I2C write command fails
-         */
-        void write(MAX30100_REG reg, uint8_t wr_data);
-
-        /**
-         * Get sensor version
-         * Sensor version is a 2 byte value:
-         *      upper byte = PART ID
-         *      lower byte = REVISION ID
-         *
-         * example:
-         *      version() return 0x1105
-         *      0x11 = PART ID
-         *      0x05 = REVISION
-         * @return Sensor version
-         * @throws std::runtime_error on I2C command failure
-         */
-        uint16_t version();
-
-        /**
-         * Get temperature reading from device
-         * @return rd_data Temperature in degrees Celsius
-         * @throws std::runtime_error on I2C command failure
-         */
-        float temperature();
-
-        /**
-         * Set the sampling mode (none vs red only vs SpO2)
-         *
-         * @param mode Target sampling mode
-         * @throws std::runtime_error on I2C command failure
-         */
-        void mode(MAX30100_MODE mode);
-
-        /**
-         * Get the sampling mode
-         *
-         * @return Current sampling mode
-         * @throws std::runtime_error on I2C command failure
-         */
-        MAX30100_MODE mode();
-
-        /**
-         * Enable or disable high-resolution mode
-         *
-         * @param enable High-resolution enable
-         *      true == SpO2 ADC resolution of 16 bit with 1.6ms LED pw
-         * @throws std::runtime_error on I2C command failure
-         */
-        void high_res_enable(bool enable);
-
-        /**
-         * Get the high-resolution enable bit
-         *
-         * @return Current high-resolution bit value
-         * @throws std::runtime_error on I2C command failure
-         */
-        bool high_res_enable();
-
-        /**
-         * Set the sample rate
-         *
-         * @param sample_rate Target sample rate
-         * @throws std::runtime_error on I2C command failure
-         */
-        void sample_rate(MAX30100_SR sample_rate);
-
-        /**
-         * Get the sample rate
-         *
-         * @return Current sample rate
-         * @throws std::runtime_error on I2C command failure
-         */
-        MAX30100_SR sample_rate();
-
-        /**
-         * Set the LED pulse width
-         *
-         * @param pulse_width Target LED pulse width
-         * @throws std::runtime_error on I2C command failure
-         */
-        void pulse_width(MAX30100_LED_PW pulse_width);
-
-        /**
-         * Get the LED pulse width
-         *
-         * @return Current LED pulse width
-         * @throws std::runtime_error on I2C command failure
-         */
-        MAX30100_LED_PW pulse_width();
-
-        /**
-         * Set the current for the infrared and red LEDs
-         *
-         * @param ir LED current enum
-         * @param r LED current enum
-         * @throws std::runtime_error on I2C command failure
-         */
-        void current(MAX30100_LED_CURRENT ir, MAX30100_LED_CURRENT r);
-
-        /**
-         * Get the infrared LED current
-         *
-         * @throws std::runtime_error on I2C command failure
-         */
-        MAX30100_LED_CURRENT current_ir();
-
-        /**
-         * Get the red LED current
-         *
-         * @throws std::runtime_error on I2C command failure
-         */
-        MAX30100_LED_CURRENT current_r();
-
-        /**
-         * Reset sensor
-         *
-         * When the RESET bit is set to one, all configuration, threshold,
-         * and data registers are reset to their power-on-state. The only
-         * exception is writing both RESET and TEMP_EN bits to one at the
-         * same time since temperature data registers 0x16 and 0x17 are not
-         * cleared. The RESET bit is cleared automatically back to zero after
-         * the reset sequence is completed.
-         *
-         * @throws std::runtime_error on I2C command failure
-         */
-        void reset();
-
-        /**
-         * Put device into power-save mode.  While in power-save mode, all
-         * registers retain their values, and write/read operations function
-         * as normal. All interrupts are cleared to zero in this mode.
-         *
-         * @param sleep Enter/exit power-save mode
-         * @throws std::runtime_error on I2C command failure
-         */
-        void sleep(bool sleep);
-
-        /* Callback pointer available for a user-specified callback */
-        Callback *_callback;
-    private:
-        /* base Callback instance to use if none provided */
-        Callback _default_callback;
-
-        /* device context struct */
-        max30100_context* _dev;
-};
-}
diff --git a/src/max30100/max30100.i b/src/max30100/max30100.i
deleted file mode 100644
index e188e32..0000000
--- a/src/max30100/max30100.i
+++ /dev/null
@@ -1,28 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-#ifndef ANDROID
-%module(directors="1", threads="1") javaupm_max30100
-%feature("director") upm::Callback;
-#endif
-JAVA_JNI_LOADLIBRARY(javaupm_max30100)
-#endif
-/* END Java syntax */
-
-/* BEGIN Python syntax  ----------------------------------------------------- */
-#ifdef SWIGPYTHON
-%module(directors="1", threads="1") pyupm_max30100
-
-%feature("director") upm::Callback;
-#endif
-/* END Python syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "max30100_regs.h"
-#include "max30100.hpp"
-%}
-%include "max30100_regs.h"
-%include "max30100.hpp"
-/* END Common SWIG syntax */
diff --git a/src/max30100/max30100.json b/src/max30100/max30100.json
deleted file mode 100644
index 038e085..0000000
--- a/src/max30100/max30100.json
+++ /dev/null
@@ -1,37 +0,0 @@
-{
-    "Library": "max30100",
-    "Description": "API for the Pulse Oximeter and Heart-Rate Sensor",
-    "Sensor Class":
-    {
-        "MAX30100":
-        {
-            "Name": "Pulse Oximeter and Heart-rate Sensor",
-            "Description": "The MAX30100 is an integrated pulse oximetry and heartrate monitor sensor solution. It combines two LEDs, a photodetector, optimized optics, and low-noise analog signal processing to detect pulse oximetry and heart-rate signals.",
-            "Aliases": ["max30100"],
-            "Categories": ["heartrate", "pulse-ox"],
-            "Connections": ["i2c", "gpio"],
-            "Project Type": ["medical", "wearables", "prototyping"],
-            "Manufacturers": ["maxim"],
-            "Kits": [],
-            "Examples":
-            {
-                "Java": ["MAX30100_Example.java"],
-                "Python": ["max30100.py"],
-                "Node.js": ["max30100.js"],
-                "C++": ["max30100.cxx"],
-                "C": ["max30100.c"]
-            },
-            "Specifications":
-            {
-                "Operating Voltage": {"unit": "V", "low": 1.8, "high": 3.3},
-                "Operating Current": {"unit": "uA", "low": 0.7, "high": 1200}
-            },
-            "Urls" :
-            {
-                "Product Pages": ["https://www.maximintegrated.com/en/products/analog/sensors-and-sensor-interface/MAX30100.html"],
-                "Datasheets": ["https://datasheets.maximintegrated.com/en/ds/MAX30100.pdf"],
-                "Schematics": []
-            }
-        }
-    }
-}
diff --git a/src/max30100/max30100_fti.c b/src/max30100/max30100_fti.c
deleted file mode 100644
index 4bdf4ed..0000000
--- a/src/max30100/max30100_fti.c
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Author: Noel Eck <noel.eck@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string.h>
-#include <stdlib.h>
-
-#include "max30100.h"
-#include "upm_fti.h"
-#include "fti/upm_sensor.h"
-
-/** 
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_max30100_name[] = "MAX30100";
-const char upm_max30100_description[] = "Pulse oximeter and heart-rate sensor";
-const upm_protocol_t upm_max30100_protocol[] = {UPM_I2C};
-/* TODO: Add/implement heart rate and SpO2 categories */
-const upm_sensor_t upm_max30100_category[] = {UPM_TEMPERATURE};
-
-// forward declarations
-const void* upm_max30100_get_ft(upm_sensor_t sensor_type);
-void* upm_max30100_init_str(const char* protocol, const char* params);
-void upm_max30100_close(void* dev);
-const upm_sensor_descriptor_t upm_max30100_get_descriptor();
-upm_result_t upm_max30100_get_temperature(void* dev, float *value, upm_temperature_u unit);
-
-/* This sensor implementes 2 function tables */
-/* 1. Generic base function table */
-static const upm_sensor_ft ft_gen =
-{
-    .upm_sensor_init_name = &upm_max30100_init_str,
-    .upm_sensor_close = &upm_max30100_close,
-    .upm_sensor_get_descriptor = &upm_max30100_get_descriptor
-};
-
-/* 2. Temperatur function table */
-static const upm_temperature_ft ft_temperature =
-{
-    .upm_temperature_set_offset = NULL,
-    .upm_temperature_set_scale = NULL,
-    .upm_temperature_get_value = &upm_max30100_get_temperature
-};
-
-const void* upm_max30100_get_ft(upm_sensor_t sensor_type)
-{
-    switch(sensor_type)
-    {
-        case UPM_SENSOR:
-            return &ft_gen;
-        case UPM_TEMPERATURE:
-            return &ft_temperature;
-        default:
-            return NULL;
-    }
-}
-
-void* upm_max30100_init_str(const char* protocol, const char* params)
-{
-    fprintf(stderr,
-            "String initialization - not implemented, using i2c bus 0: %s\n", __FILENAME__);
-    return max30100_init(0);
-}
-
-void upm_max30100_close(void* dev)
-{
-    max30100_close(dev);
-}
-
-const upm_sensor_descriptor_t upm_max30100_get_descriptor()
-{
-    /* Fill in the descriptor */
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_max30100_name;
-    usd.description = upm_max30100_description;
-    usd.protocol_size = 1;
-    usd.protocol = upm_max30100_protocol;
-    usd.category_size = 2;
-    usd.category = upm_max30100_category;
-
-    return usd;
-}
-
-upm_result_t upm_max30100_get_temperature(void* dev, float *value, upm_temperature_u unit)
-{
-    upm_result_t result = max30100_get_temperature((max30100_context*)dev, value);
-    return result;
-}
diff --git a/src/max30100/max30100_regs.h b/src/max30100/max30100_regs.h
deleted file mode 100644
index 6bf35f2..0000000
--- a/src/max30100/max30100_regs.h
+++ /dev/null
@@ -1,170 +0,0 @@
-/*
- * Author: Noel Eck <noel.eck@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <stdint.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define MAX30100_I2C_ADDRESS 0x57
-
-/* Single IR/R sample */
-typedef struct {
-    /* Raw IR (pulse) read value */
-    uint16_t IR;
-    /* Raw R (O2) read value */
-    uint16_t R;
-} max30100_value;
-
-/* Function pointer for returning 1 IR/R sample */
-typedef void (*func_sample_ready_handler)(max30100_value sample, void* arg);
-
-/* Sample state */
-typedef enum {
-    /* NOT sampling */
-    MAX30100_SAMPLE_STATE_IDLE,
-    /* Take one sample/currently taking one sample */
-    MAX30100_SAMPLE_STATE_ONE_SHOT,
-    /* Sample continuously/currently sampling continuously */
-    MAX30100_SAMPLE_STATE_CONTINUOUS,
-    /* Sample continuously using buffer/currently sampling continuously using buffer*/
-    MAX30100_SAMPLE_STATE_CONTINUOUS_BUFFERED
-} MAX30100_SAMPLE_STATE;
-
-/* Pulse oximeter and heart-rate sensor I2C registers */
-typedef enum {
-    /* Interrupt status (RO) */
-    MAX30100_REG_INTERRUPT_STATUS = 0x00,
-    /* Interrupt enable */
-    MAX30100_REG_INTERRUPT_ENABLE = 0x01,
-    /* FIFO write pointer */
-    MAX30100_REG_FIFO_WR_PTR = 0x02,
-    /* FIFO overflow counter */
-    MAX30100_REG_FIFO_OVF_COUNTER = 0x03,
-    /* FIFO read pointer */
-    MAX30100_REG_FIFO_RD_PTR = 0x04,
-    /* FIFO data */
-    MAX30100_REG_FIFO_DATA = 0x05,
-    /* Mode configuration */
-    MAX30100_REG_MODE_CONFIG = 0x06,
-    /* SPO2 configuration */
-    MAX30100_REG_SPO2_CONFIG = 0x07,
-    /* LED configuration */
-    MAX30100_REG_LED_CONFIG = 0x09,
-    /* Temperature integer (2's compliment) */
-    MAX30100_REG_TEMP_INTEGER = 0x16,
-    /* Temperature fraction) */
-    MAX30100_REG_TEMP_FRACTION = 0x17,
-    /* Revision ID (RO)*/
-    MAX30100_REG_REV_ID = 0xFE,
-    /* Part ID */
-    MAX30100_REG_PART_ID = 0xFF
-} MAX30100_REG;
-
-/* MAX30100_REG_INTERRUPT_STATUS register fields */
-/* FIFO almost full, set to 1 when WR_PTR == RD_PTR - 1 */
-#define MAX30100_A_FULL         (1 << 7)
-/* Temperature date ready flag */
-#define MAX30100_TEMP_RDY       (1 << 6)
-/* Heartrate data ready flag */
-#define MAX30100_HR_RDY         (1 << 5)
-/* HR and O2 data ready flag */
-#define MAX30100_SPO2_RDY       (1 << 4)
-/* Power ready after brownout flag */
-#define MAX30100_PWR_RDY        (1 << 0)
-
-/* MAX30100_REG_INTERRUPT_ENABLE register fields */
-/* Enable interrupt on FIFO almost full */
-#define MAX30100_EN_A_FULL      (1 << 7)
-/* Enable interrupt on temperature date ready */
-#define MAX30100_EN_TEMP_RDY    (1 << 6)
-/* Enable interrupt on HR data ready */
-#define MAX30100_EN_HR_RDY      (1 << 5)
-/* Enable interrupt on HR and O2 data ready */
-#define MAX30100_EN_SPO2_RDY    (1 << 4)
-
-/* MAX30100_REG_MODE_CONFIG register fields */
-/* Enable power-save mode */
-#define MAX30100_SHDN           (1 << 7)
-/* Reset device */
-#define MAX30100_RESET          (1 << 6)
-/* Initiate temperature reading */
-#define MAX30100_TEMP_EN        (1 << 3)
-/* Device sample mode (HR, vs SpO2) */
-typedef enum _MAX30100_MODE {
-/* Turn off sampling */
-    MAX30100_MODE_DISABLED = 0x00,
-/* Enable heartrate ONLY sampling */
-    MAX30100_MODE_HR_EN = 0x02,
-/* Enable SpO2 sampling */
-    MAX30100_MODE_SPO2_EN = 0x03
-} MAX30100_MODE;
-
-/* MAX30100_REG_SPO2_CONFIG register fields */
-#define MAX30100_SPO2_HI_RES_EN (1 << 6)
-typedef enum _MAX30100_SR {
-    MAX30100_SR_50_HZ = 0x00,
-    MAX30100_SR_100_HZ = 0x01,
-    MAX30100_SR_167_HZ = 0x02,
-    MAX30100_SR_200_HZ = 0x03,
-    MAX30100_SR_400_HZ = 0x04,
-    MAX30100_SR_600_HZ = 0x05,
-    MAX30100_SR_900_HZ = 0x06,
-    MAX30100_SR_1000_HZ = 0x07
-} MAX30100_SR;
-/* LED pulse width (microseconds) */
-typedef enum _MAX30100_LED_PW {
-    MAX30100_LED_PW_200_US_13_BITS = 0x00,
-    MAX30100_LED_PW_400_US_14_BITS = 0x01,
-    MAX30100_LED_PW_800_US_15_BITS = 0x02,
-    MAX30100_LED_PW_1600_US_16_BITS = 0x03
-} MAX30100_LED_PW;
-
-/* MAX30100_REG_LED_CONFIG register fields */
-/* LED (IR and R) current (milliamps) */
-typedef enum _MAX30100_LED_CURRENT {
-    MAX30100_LED_CURRENT_0_0_MA = 0x00,
-    MAX30100_LED_CURRENT_4_4_MA = 0x01,
-    MAX30100_LED_CURRENT_7_6_MA = 0x02,
-    MAX30100_LED_CURRENT_11_0_MA = 0x03,
-    MAX30100_LED_CURRENT_14_2_MA = 0x04,
-    MAX30100_LED_CURRENT_17_4_MA = 0x05,
-    MAX30100_LED_CURRENT_20_8_MA = 0x06,
-    MAX30100_LED_CURRENT_24_0_MA = 0x07,
-    MAX30100_LED_CURRENT_27_1_MA = 0x08,
-    MAX30100_LED_CURRENT_30_6_MA = 0x09,
-    MAX30100_LED_CURRENT_33_8_MA = 0x0a,
-    MAX30100_LED_CURRENT_37_0_MA = 0x0b,
-    MAX30100_LED_CURRENT_40_2_MA = 0x0c,
-    MAX30100_LED_CURRENT_43_6_MA = 0x0d,
-    MAX30100_LED_CURRENT_46_8_MA = 0x0e,
-    MAX30100_LED_CURRENT_50_0_MA = 0x0f
-} MAX30100_LED_CURRENT;
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/max31723/CMakeLists.txt b/src/max31723/CMakeLists.txt
deleted file mode 100644
index cdf7db7..0000000
--- a/src/max31723/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "max31723")
-set (libdescription "SPI/3-wire Digital Thermometer")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/max31723/max31723.cxx b/src/max31723/max31723.cxx
deleted file mode 100644
index 042627a..0000000
--- a/src/max31723/max31723.cxx
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <unistd.h>
-#include <stdlib.h>
-#include <stdexcept>
-
-#include "max31723.hpp"
-
-using namespace upm;
-
-MAX31723::MAX31723 (int bus, int csn) : m_spi(bus), m_csnPinCtx(csn) {
-    mraa::Result error = mraa::SUCCESS;
-    m_name = "MAX31723";
-
-    error = m_csnPinCtx.dir (mraa::DIR_OUT);
-    if (error != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) + 
-                                    ": m_csnPinCtx.dir() failed");
-    }
-
-    CSOff ();
-
-    // set spi mode to mode2 (CPOL = 1, CPHA = 0)
-    m_spi.mode (mraa::SPI_MODE2);
-    // set ontinuously perform temperature conversions
-    writeRegister (R_STS_WRITE_CMD, B_CONT_READING);
-}
-
-short
-MAX31723::getTemperature () {
-    uint8_t msb = 0;
-    short temperature = 0;
-
-    readRegister (R_TEMPERATURE_LSB);
-    msb = readRegister (R_TEMPERATURE_MSB);
-
-    if ((msb & 0x80) != 0) {
-        msb &= 0x7F;
-        temperature = 0 - msb;
-
-    } else {
-        temperature = msb;
-    }
-
-    return temperature;
-}
-
-/*
- * **************
- *  private area
- * **************
- */
-
-uint8_t
-MAX31723::readRegister (uint8_t reg) {
-    uint8_t     data[2]     = { 0x00, 0x00 };
-    uint8_t*    sensorData  = NULL;
-
-    CSOn ();
-    data[0] = reg;
-    sensorData = m_spi.write(data, 2);
-    CSOff ();
-
-    return sensorData[1];
-}
-
-void
-MAX31723::writeRegister (uint8_t reg, uint8_t data) {
-    uint8_t     buffer[2]   = { 0x00, 0x00 };
-
-    CSOn ();
-    buffer[0] = reg;
-    buffer[1] = data;
-    m_spi.write(buffer, 2);
-    CSOff ();
-}
-
-mraa::Result
-MAX31723::CSOn () {
-    return m_csnPinCtx.write (HIGH);
-}
-
-mraa::Result
-MAX31723::CSOff () {
-    return m_csnPinCtx.write (LOW);
-}
diff --git a/src/max31723/max31723.hpp b/src/max31723/max31723.hpp
deleted file mode 100644
index aad5de5..0000000
--- a/src/max31723/max31723.hpp
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/aio.hpp>
-
-#include <mraa/gpio.hpp>
-
-#include <mraa/spi.hpp>
-
-#define HIGH                    1
-#define LOW                     0
-
-namespace upm {
-
-/**
- * @brief MAX31723 Temperature Sensor
- * @defgroup max31723 libupm-max31723
- * @ingroup maxim spi temp
- */
-/**
- * @library max31723
- * @sensor max31723
- * @comname SPI/3-wire Digital Thermometer
- * @type temp
- * @man maxim
- * @con spi
- * @web https://www.maximintegrated.com/en/products/analog/sensors-and-sensor-interface/MAX31723.html
- *
- * @brief API for the MAX31723 Temperature Sensor
- *
- * Maxim Integrated*
- * [MAX31723](http://datasheets.maximintegrated.com/en/ds/MAX31722-MAX31723.pdf)
- * is a low-voltage 3-wire/SPI temperature sensor controller. This module was
- * tested on the Maxim Integrated [MAX31732PMB1 PMOD
- * module](http://datasheets.maximintegrated.com/en/ds/MAX31723PMB1.pdf) from
- * the analog PMOD kit.
- *
- * @snippet max31723.cxx Interesting
- */
-class MAX31723 {
-    public:
-        static const uint8_t R_STS_READ_CMD     = 0x00;
-        static const uint8_t R_STS_WRITE_CMD    = 0x80;
-        static const uint8_t R_TEMPERATURE_LSB  = 0x01;
-        static const uint8_t R_TEMPERATURE_MSB  = 0x02;
-
-        static const uint8_t B_CONT_READING     = 0x00;
-
-        /**
-         * Instantiates an MAX31723 object
-         *
-         * @param bus Number of the SPI bus used
-         * @param csn Chip select (slave select) pin to use
-         */
-        MAX31723 (int bus, int csn);
-
-        /**
-         * MAXDS3231M object destructor; basically, it closes the I2C connection.
-         * it is not needed anymore, as the connections will be closed when
-         * m_spi and m_csnPinCtx variables will go out of scope
-         * ~MAX31723 ();
-         **/
-
-        /**
-         * Gets the on-board temperature.
-         */
-        short getTemperature ();
-
-        /**
-         * Returns the name of the component
-         */
-        std::string name()
-        {
-            return m_name;
-        }
-    private:
-        std::string m_name;
-        mraa::Spi        m_spi;
-        mraa::Gpio       m_csnPinCtx;
-
-        uint8_t readRegister (uint8_t reg);
-        void writeRegister (uint8_t reg, uint8_t data);
-
-        /**
-         * Sets the chip select pin to LOW
-         */
-        mraa::Result CSOn ();
-
-        /**
-         * Sets the chip select pin to HIGH
-         */
-        mraa::Result CSOff ();
-};
-
-}
diff --git a/src/max31723/max31723.json b/src/max31723/max31723.json
deleted file mode 100644
index 80f6a89..0000000
--- a/src/max31723/max31723.json
+++ /dev/null
@@ -1,39 +0,0 @@
-{
-    "Library": "max31723",
-    "Description": "API for the MAX31723 Temperature Sensor",
-    "Sensor Class":
-    {
-        "MAX31723":
-        {
-            "Name": "SPI/3-wire Digital Thermometer",
-            "Description": "Maxim Integrated* [MAX31723](http://datasheets.maximintegrated.com/en/ds/MAX31722-MAX31723.pdf) is a low-voltage 3-wire/SPI temperature sensor controller. This module was tested on the Maxim Integrated [MAX31732PMB1 PMOD module](http://datasheets.maximintegrated.com/en/ds/MAX31723PMB1.pdf) from the analog PMOD kit.",
-            "Aliases": ["max31723"],
-            "Categories": ["temperature"],
-            "Connections": ["spi"],
-            "Project Type": ["environmental", "prototyping"],
-            "Manufacturers": ["maxim"],
-            "Kits": [],
-            "Examples":
-            {
-                "Java": [],
-                "Python": [],
-                "Node.js": [],
-                "C++": ["max31723.cxx"],
-                "C": []
-            },
-            "Specifications":
-            {
-                "Operating Voltage": {"unit": "V", "low": 1.7, "high": 3.7},
-                "Operating Current": {"unit": "uA", "low": 100, "high":1200},
-                "Operating Temperature": {"unit": "degC", "low": -55, "high": 125}
-
-            },
-            "Urls" :
-            {
-                "Product Pages": ["https://www.maximintegrated.com/en/products/analog/sensors-and-sensor-interface/MAX31723.html"],
-                "Datasheets": ["https://datasheets.maximintegrated.com/en/ds/MAX31722-MAX31723.pdf"],
-                "Schematics": []
-            }
-        }
-    }
-}
diff --git a/src/max31855/CMakeLists.txt b/src/max31855/CMakeLists.txt
deleted file mode 100644
index 9196e90..0000000
--- a/src/max31855/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "max31855")
-set (libdescription "Thermocouple-to-Digital Converter")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/max31855/max31855.cxx b/src/max31855/max31855.cxx
deleted file mode 100644
index d940703..0000000
--- a/src/max31855/max31855.cxx
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * Author: Brendan Le Foll <brendan.le.foll@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-#include <unistd.h>
-#include <stdlib.h>
-#include <functional>
-#include <string.h>
-
-#include "max31855.hpp"
-
-using namespace upm;
-
-//! [Constructor]
-MAX31855::MAX31855(int bus, int cs)
-{
-    // initialise chip select as a normal gpio
-    if ( !(m_gpio = mraa_gpio_init(cs)) ) 
-      {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_gpio_init(cs) failed, invalid pin?");
-        return;
-      }
-    mraa_gpio_dir(m_gpio, MRAA_GPIO_OUT);
-
-    // initialise the spi bus with a 2Mhz clock
-    m_sensor = mraa_spi_init(bus);
-    mraa_spi_frequency(m_sensor, 2000000);
-}
-//! [Constructor]
-
-//! [Destructor]
-MAX31855::~MAX31855()
-{
-    // close both m_sensor & m_gpio cleanly
-    mraa_result_t error;
-    error = mraa_spi_stop(m_sensor);
-    if (error != MRAA_SUCCESS) {
-        mraa_result_print(error);
-    }
-    error = mraa_gpio_close(m_gpio);
-    if (error != MRAA_SUCCESS) {
-        mraa_result_print(error);
-    }
-}
-//! [Destructor]
-
-double
-MAX31855::getTemp()
-{
-//! [spi]
-    // set chip select low
-    mraa_gpio_write(m_gpio, 0);
-
-    uint8_t buf[4];
-
-    // set our input buffer to 0, this is clean but not required
-    memset(buf, 0, sizeof(uint8_t)*4);
-
-    // Write buffer to the spi slave
-    uint8_t* x = mraa_spi_write_buf(m_sensor, buf, 4);
-//! [spi]
-
-//! [conversion]
-    // Endian correct way of making our char array into an 32bit int
-    int32_t temp = (x[0] << 24) | (x[1] << 16) | (x[2] << 8) | x[3];;
-
-    // mraa_spi_write_buf does not free the return buffer
-    free(x);
-
-    if (temp & 0x7) {
-        std::cerr << "Something went very wrong!" << std::endl;
-    }
-
-    // scrap all the data we dont care about
-    temp >>= 18;
-
-    // LSB = 0.25 degrees C
-    double c = (double) temp;
-    c *= 0.25;
-//! [conversion]
-
-    // set chip select high
-    mraa_gpio_write(m_gpio, 1);
-
-    return c;
-}
diff --git a/src/max31855/max31855.hpp b/src/max31855/max31855.hpp
deleted file mode 100644
index c6ccac6..0000000
--- a/src/max31855/max31855.hpp
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Author: Brendan Le Foll <brendan.le.foll@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/spi.h>
-#include <mraa/gpio.h>
-
-namespace upm {
-
-/**
- * @brief MAX31855 Thermocouple
- * @defgroup max31855 libupm-max31855
- * @ingroup maxim adafruit spi other
- */
-/**
- * @library max31855
- * @sensor max31855
- * @comname Thermocouple-to-Digital Converter
- * @type other
- * @man maxim adafruit
- * @con spi
- * @web https://www.maximintegrated.com/en/products/analog/sensors-and-sensor-interface/MAX31855.html
- *
- * @brief API for the MAX31855 Thermocouple Amplifier
- *
- * Maxim Integrated*
- * [MAX31855](http://datasheets.maximintegrated.com/en/ds/MAX31855.pdf)
- * is a cold-junction compensated thermocouple-to-digital converter. This
- * module was tested on the Maxim Integrated 
- * [MAX31855PMB1 PMOD module]
- * (http://datasheets.maximintegrated.com/en/ds/MAX31855PMB1.pdf) from the
- * analog PMOD kit.
- *
- * @image html max31855.jpg
- * @snippet max31855.cxx Interesting
- */
-class MAX31855 {
-    public:
-        /**
-         * Instantiates an MAX31855 object
-         *
-         * @param bus SPI bus to use
-         * @param cs Chip select pin
-         */
-        MAX31855(int bus, int cs);
-
-        /**
-         * MAX31855 object destructor
-         */
-        ~MAX31855();
-
-        /**
-         * Gets the distance from the sensor
-         *
-         * @return Value in Celsius
-         */
-//! [Interesting]
-        double getTemp();
-//! [Interesting]
-
-    private:
-        mraa_spi_context m_sensor;
-        mraa_gpio_context m_gpio;
-};
-
-}
diff --git a/src/max31855/max31855.i b/src/max31855/max31855.i
deleted file mode 100644
index d63b39b..0000000
--- a/src/max31855/max31855.i
+++ /dev/null
@@ -1,17 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-//! [Interesting]
-
-JAVA_JNI_LOADLIBRARY(javaupm_max31855)
-//! [Interesting]
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "max31855.hpp"
-%}
-%include "max31855.hpp"
-/* END Common SWIG syntax */
diff --git a/src/max31855/max31855.json b/src/max31855/max31855.json
deleted file mode 100644
index bf7af2d..0000000
--- a/src/max31855/max31855.json
+++ /dev/null
@@ -1,38 +0,0 @@
-{
-    "Library": "max31855",
-    "Description": "API for the MAX31855 Thermocouple Amplifier",
-    "Sensor Class":
-    {
-        "MAX31855":
-        {
-            "Name": "Thermocouple-to-Digital Converter",
-            "Description": "Maxim Integrated* [MAX31855](http://datasheets.maximintegrated.com/en/ds/MAX31855.pdf) is a cold-junction compensated thermocouple-to-digital converter. This module was tested on the Maxim Integrated  [MAX31855PMB1 PMOD module] (http://datasheets.maximintegrated.com/en/ds/MAX31855PMB1.pdf) from the analog PMOD kit.",
-            "Aliases": ["max31855"],
-            "Categories": ["temperature"],
-            "Connections": ["spi"],
-            "Project Type": ["thermal", "prototyping"],
-            "Manufacturers": ["maxim", "adafruit"],
-            "Kits": [],
-            "Image": "max31855.jpg",
-            "Examples":
-            {
-                "Java": ["MAX31855_Example.java"],
-                "Python": [],
-                "Node.js": [],
-                "C++": ["max31855.cxx"],
-                "C": []
-            },
-            "Specifications":
-            {
-                "Operating Voltage": {"unit": "V", "low": 3, "high": 3.6},
-                "Operating Current": {"unit": "uA", "max": 1500}
-            },
-            "Urls" :
-            {
-                "Product Pages": ["https://www.maximintegrated.com/en/products/analog/sensors-and-sensor-interface/MAX31855.html"],
-                "Datasheets": ["https://datasheets.maximintegrated.com/en/ds/MAX31855.pdf"],
-                "Schematics": []
-            }
-        }
-    }
-}
diff --git a/src/max44000/CMakeLists.txt b/src/max44000/CMakeLists.txt
deleted file mode 100644
index 48a4702..0000000
--- a/src/max44000/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "max44000")
-set (libdescription "Ambient and Infrared Proximity Sensor")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/max44000/max44000.cxx b/src/max44000/max44000.cxx
deleted file mode 100644
index d6fa601..0000000
--- a/src/max44000/max44000.cxx
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-#include <unistd.h>
-#include <stdlib.h>
-
-#include "max44000.hpp"
-
-using namespace upm;
-
-MAX44000::MAX44000 (int bus, int devAddr) : m_i2cMaxControlCtx(bus) {
-    m_name = "MAX44000";
-
-    m_maxControlAddr = devAddr;
-    m_bus = bus;
-
-    mraa::Result ret = m_i2cMaxControlCtx.address(m_maxControlAddr);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_address() failed");
-    }
-
-    // i2cWriteReg (MCR, 0x2C);
-    // i2cWriteReg (TCR, 0x6);
-}
-
-uint16_t
-MAX44000::getProximity () {
-    uint16_t data = 0;
-
-    data = (i2cReadReg_8 (ALSDATA_HIGH) & 0x7F) << 8;
-    data = data | i2cReadReg_8 (ALSDATA_LOW);
-
-    return data;
-}
-
-uint16_t
-MAX44000::getAmbient () {
-    uint16_t data = 0;
-
-    data = (i2cReadReg_8 (ALSDATA_HIGH) & 0x7F) << 8;
-    data = data | i2cReadReg_8 (ALSDATA_LOW);
-
-    return data;
-}
-
-/*
- * **************
- *  private area
- * **************
- */
-uint8_t
-MAX44000::i2cReadReg_8 (int reg) {
-    uint8_t data;
-
-    m_i2cMaxControlCtx.writeByte(reg);
-
-    m_i2cMaxControlCtx.read(&data, 0x1);
-
-    return data;
-}
-
-uint16_t
-MAX44000::i2cReadReg_16 (int reg) {
-    uint16_t data;
-
-    m_i2cMaxControlCtx.writeByte(reg);
-
-    m_i2cMaxControlCtx.read((uint8_t *)&data, 0x2);
-
-    return data;
-}
-
-mraa::Result
-MAX44000::i2cWriteReg (uint8_t reg, uint8_t value) {
-    mraa::Result error = mraa::SUCCESS;
-
-    uint8_t data[2] = { reg, value };
-    error = m_i2cMaxControlCtx.write (data, 2);
-
-    return error;
-}
diff --git a/src/max44000/max44000.hpp b/src/max44000/max44000.hpp
deleted file mode 100644
index 333c73c..0000000
--- a/src/max44000/max44000.hpp
+++ /dev/null
@@ -1,145 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/i2c.hpp>
-
-#define ADDR               0x4A // device address
-
-// registers address
-#define ISR                0x00 // Interrupt Status Register
-#define MCR                0x01 // Main Configuration Register
-#define RCR                0x02 // Receive Configuration Register
-#define TCR                0x03 // Transmit Configuration Register
-#define ALSDATA_HIGH       0x04 // ambient sensor data high byte
-#define ALSDATA_LOW        0x05 // ambient sensor data low byte
-#define PRXDATA            0x15 // proximity sensor data
-
-#define ALS_UP_THRESH_HIGH 0x06 // ALS Interrupt Threshold Registers High
-#define ALS_UP_THRESH_LOW  0x07 // ALS Interrupt Threshold Registers Low
-#define ALS_LO_THRESH_HIGH 0x08 // ALS Interrupt Threshold Registers High
-#define ALS_LO_THRESH_LOW  0x09 // ALS Interrupt Threshold Registers Low
-#define TPTR               0x0A // ALS/PROX Threshold Persist Timer Register
-#define PROX_THRESH_IND    0x0B // Proximity Threshold Register
-#define PROX_THRESH        0x0C // Proximity Threshold Register
-#define TRIM_GAIN_GREEN    0x0F // Digital Gain Trim Register
-#define TRIM_GAIN_IR       0x10 // Digital Gain Trim Register
-
-#define HIGH               1
-#define LOW                0
-
-namespace upm {
-
-/**
- * @brief MAX44000 Proximity Sensor
- * @defgroup max44000 libupm-max44000
- * @ingroup maxim i2c light
- */
-/**
- * @library max44000
- * @sensor max44000
- * @comname Ambient and Infrared Proximity Sensor
- * @type light
- * @man maxim
- * @con i2c
- * @web https://www.maximintegrated.com/en/products/analog/sensors-and-sensor-interface/MAX44000.html
- *
- * @brief API for the MAX44000 Ambient and Infrared Proximity Sensor
- *
- * Maxim Integrated*
- * [MAX44000](http://datasheets.maximintegrated.com/en/ds/MAX44000.pdf)
- * is an ambient and infrared proximity sensor. This module was tested on the
- * Maxim Integrated 
- * [MAX44000PMB1 PMOD module]
- * (http://datasheets.maximintegrated.com/en/ds/MAX44000PMB1.pdf) from the
- * analog PMOD kit.
- *
- * @snippet max44000.cxx Interesting
- */
-class MAX44000 {
-    public:
-        /**
-         * Instantiates an MAX44000 object
-         *
-         * @param bus Number of the used bus
-         * @param devAddr Address of the used I2C device
-         */
-        MAX44000 (int bus, int devAddr=ADDR);
-
-        /**
-         * MAX44000 object destructor; basically, it closes the I2C connection.
-         * ~MAX44000 ();
-         * no need for the destructor - the I2c connection will be closed when
-         * m_i2cMaxControlCtx variable will be out of context
-         **/
-
-        /**
-         * Reads the proximity value from the sensor (based on ambient data).
-         */
-        uint16_t getProximity ();
-        /**
-         * Reads the ambient value from the sensor (based on ambient data).
-         */
-        uint16_t getAmbient ();
-
-        /**
-         * Returns the name of the component
-         */
-        std::string name()
-        {
-            return m_name;
-        }
-
-        /**
-         * Reads a one-byte register
-         *
-         * @param reg Address of the register
-         */
-        uint8_t i2cReadReg_8 (int reg);
-
-        /**
-         * Reads a two-byte register
-         *
-         * @param reg Address of the register
-         */
-        uint16_t i2cReadReg_16 (int reg);
-
-        /**
-         * Writes to a one-byte register
-         *
-         * @param reg Address of the register
-         * @param value Byte to be written
-         */
-        mraa::Result i2cWriteReg (uint8_t reg, uint8_t value);
-
-    private:
-        std::string m_name;
-
-        int m_maxControlAddr;
-        int m_bus;
-        mraa::I2c m_i2cMaxControlCtx;
-};
-
-}
diff --git a/src/max44000/max44000.i b/src/max44000/max44000.i
deleted file mode 100644
index 508c198..0000000
--- a/src/max44000/max44000.i
+++ /dev/null
@@ -1,14 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_max44000)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "max44000.hpp"
-%}
-%include "max44000.hpp"
-/* END Common SWIG syntax */
diff --git a/src/max44000/max44000.json b/src/max44000/max44000.json
deleted file mode 100644
index 45de2f0..0000000
--- a/src/max44000/max44000.json
+++ /dev/null
@@ -1,39 +0,0 @@
-{
-    "Library": "max44000",
-    "Description": "API for the MAX44000 Ambient and Infrared Proximity Sensor",
-    "Sensor Class":
-    {
-        "MAX44000":
-        {
-            "Name": "Ambient and Infrared Proximity Sensor",
-            "Description": "Maxim Integrated* [MAX44000](http://datasheets.maximintegrated.com/en/ds/MAX44000.pdf) is an ambient and infrared proximity sensor. This module was tested on the Maxim Integrated  [MAX44000PMB1 PMOD module] (http://datasheets.maximintegrated.com/en/ds/MAX44000PMB1.pdf) from the analog PMOD kit.",
-            "Aliases": ["max44000"],
-            "Categories": ["proximity"],
-            "Connections": ["i2c"],
-            "Project Type": ["robotics", "prototyping"],
-            "Manufacturers": ["maxim"],
-            "Kits": [],
-            "Examples":
-            {
-                "Java": ["MAX44000_Example.java"],
-                "Python": [],
-                "Node.js": [],
-                "C++": ["max44000.cxx"],
-                "C": []
-            },
-            "Specifications":
-            {
-                "Operating Voltage": {"unit": "V", "low": 1.7, "high": 3.6},
-                "Operating Current": {"unit": "mA", "low": 10, "high":110},
-                "Operating Temperature": {"unit": "degC", "low": -40, "high": 105}
-
-            },
-            "Urls" :
-            {
-                "Product Pages": ["https://www.maximintegrated.com/en/products/analog/sensors-and-sensor-interface/MAX44000.html"],
-                "Datasheets": ["https://datasheets.maximintegrated.com/en/ds/MAX44000.pdf"],
-                "Schematics": []
-            }
-        }
-    }
-}
diff --git a/src/max44009/CMakeLists.txt b/src/max44009/CMakeLists.txt
deleted file mode 100644
index 7ab5b1f..0000000
--- a/src/max44009/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "max44009")
-set (libdescription "I2C Low-power Digital Ambient Light Sensor")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa interfaces)
diff --git a/src/max44009/max44009.cxx b/src/max44009/max44009.cxx
deleted file mode 100644
index 84e99f8..0000000
--- a/src/max44009/max44009.cxx
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * Author: Scott Ware <scott.r.ware@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <unistd.h>
-#include <stdlib.h>
-#include <math.h>
-
-#include "max44009.hpp"
-
-using namespace upm;
-
-MAX44009::MAX44009 (int bus, int devAddr) {
-
-    m_maxControlAddr = devAddr;
-    i2c = new mraa::I2c(bus);
-    i2c->address(m_maxControlAddr);
-
-    // Reset chip to defaults
-    status = mraa::SUCCESS;
-    reset();
-    if (status != mraa::SUCCESS)
-        UPM_THROW("config failure");
-}
-
-MAX44009::~MAX44009() {
-    delete i2c;
-}
-
-mraa::Result
-MAX44009::reset() {
-    uint8_t address[5] = {MAX44009_INT_ENABLE_ADDR, MAX44009_CONFIG_ADDR, \
-                                   MAX44009_THR_HIGH_ADDR, MAX44009_THR_LOW_ADDR, \
-                                   MAX44009_THR_TIMER_ADDR};
-    uint8_t value[5]   = {MAX44009_INT_DISABLED, MAX44009_DEFAULT_CONFIGURATION, \
-                                   0xFF, 0x00, 0xFF};
-    uint8_t i;
-    for (i = 0; i < sizeof(address) && status == mraa::SUCCESS; i++) {
-        status = i2c->writeReg(address[i], value[i]);
-    }
-    return status;
-}
-
-uint16_t
-MAX44009::getVisibleRaw() {
-    uint8_t data[MAX44009_LUX_LENGTH];
-    uint16_t* value = reinterpret_cast<uint16_t*>(&data[0]);
-
-    int length = i2c->readBytesReg(MAX44009_LUX_START_ADDR, data, MAX44009_LUX_LENGTH);
-
-    if(length != MAX44009_LUX_LENGTH)
-        UPM_THROW("Read error");
-
-    return *value;
-}
-
-
-double
-MAX44009::getVisibleLux() {
-    uint16_t rawValue = getVisibleRaw();
-    uint8_t rawValueMsb = rawValue >> 8;
-    uint8_t rawValueLsb = rawValue & 0xFF;
-    uint8_t exponent = (( rawValueMsb & 0xF0 ) >> 4);
-    uint8_t mantissa = (( rawValueMsb & 0x0F ) << 4 ) | ( rawValueLsb & 0x0F );
-
-    // Check for overrange condition
-    if(exponent == MAX44009_OVERRANGE_CONDITION)
-        UPM_THROW("Overrange error");
-
-    return pow((double)2,(double)exponent) * mantissa * 0.045;
-}
-
diff --git a/src/max44009/max44009.hpp b/src/max44009/max44009.hpp
deleted file mode 100644
index 0b78b90..0000000
--- a/src/max44009/max44009.hpp
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Author: Scott Ware <scott.r.ware@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/i2c.hpp>
-
-#include "interfaces/iLightSensor.hpp"
-
-/* ADDRESS AND NOT_FOUND VALUE */
-#define MAX44009_ADDRESS                    ( 0x4A )
-#define MAX44009_NOT_FOUND                  ( 0x00 )
-
-/* I2C BUS */
-#define MAX44009_I2C_BUS                    ( 1 )
-
-/* REGISTER ADDRESSES */
-#define MAX44009_INT_STATUS_ADDR            ( 0x00 )    // R
-#define MAX44009_INT_ENABLE_ADDR            ( 0x01 )    // R/W
-#define MAX44009_CONFIG_ADDR                ( 0x02 )    // R/W
-#define MAX44009_LUX_START_ADDR             ( 0x03 )
-#define MAX44009_LUX_LENGTH                 ( 2 )
-#define MAX44009_LUX_HIGH                   ( 0 )
-#define MAX44009_LUX_LOW                    ( 1 )
-#define MAX44009_THR_HIGH_ADDR              ( 0x05 )    // R/W
-#define MAX44009_THR_LOW_ADDR               ( 0x06 )    // R/W
-#define MAX44009_THR_TIMER_ADDR             ( 0x07 )    // R/W
-
-/* INTERRUPT VALUES */
-#define MAX44009_INT_STATUS_OFF             ( 0x00 )
-#define MAX44009_INT_STATUS_ON              ( 0x01 )
-#define MAX44009_INT_DISABLED               ( 0x00 )
-#define MAX44009_INT_ENABLED                ( 0x01 )
-
-/* CONFIGURATION VALUES */
-#define MAX44009_CONFIG_DEFAULT             ( 0 << 7 )
-#define MAX44009_CONFIG_CONTINUOUS          ( 1 << 7 )
-#define MAX44009_CONFIG_AUTO                ( 0 << 6 )
-#define MAX44009_CONFIG_MANUAL              ( 1 << 6 )
-#define MAX44009_CONFIG_CDR_NORMAL          ( 0 << 3 )
-#define MAX44009_CONFIG_CDR_DIVIDED         ( 1 << 3 )
-#define MAX44009_CONFIG_INTEGRATION_800ms   ( 0 << 0 )
-#define MAX44009_CONFIG_INTEGRATION_400ms   ( 1 << 0 )
-#define MAX44009_CONFIG_INTEGRATION_200ms   ( 2 << 0 )
-#define MAX44009_CONFIG_INTEGRATION_100ms   ( 3 << 0 )
-#define MAX44009_CONFIG_INTEGRATION_50ms    ( 4 << 0 )
-#define MAX44009_CONFIG_INTEGRATION_25ms    ( 5 << 0 )
-#define MAX44009_CONFIG_INTEGRATION_12ms    ( 6 << 0 )
-#define MAX44009_CONFIG_INTEGRATION_6ms     ( 7 << 0 )
-
-/* DEFAULT CONFIGURATION */
-#define MAX44009_DEFAULT_CONFIGURATION      ( MAX44009_CONFIG_DEFAULT | \
-                                              MAX44009_CONFIG_AUTO | \
-                                              MAX44009_CONFIG_CDR_NORMAL | \
-                                              MAX44009_CONFIG_INTEGRATION_100ms )
-
-/* MISCELLANEOUS */
-#define MAX44009_OVERRANGE_CONDITION        ( 0x0F )
-
-namespace upm {
-
-/**
- * @brief MAX44009 Ambient Light Sensor
- * @defgroup max44009 libupm-max44009
- * @ingroup maxim i2c light ilightsensor
- */
-
-/**
- * @brief C++ API for MAX44009 chip (Ambient Light Sensor)
- *
- * The Maxim Integrated
- * [MAX44009](http://datasheets.maximintegrated.com/en/ds/MAX44009.pdf)
- * is Industry's Lowest-Power Ambient Light Sensor with ADC.
- *
- * @library max44009
- * @sensor max44009
- * @comname I2C Low-power Digital Ambient Light Sensor
- * @altname MAX44009
- * @type light
- * @man maxim
- * @con i2c
- * @web https://www.maximintegrated.com/en/products/analog/sensors-and-sensor-interface/MAX44009.html
- * @if ilightsensor
- *
- * @snippet max44009.cxx Interesting
- *
- */
-class MAX44009 : public ILightSensor {
-    public:
-        /**
-         * Instanciates a MAX44009 object
-         *
-         * @param bus number of used bus
-         * @param devAddr address of used i2c device
-         */
-        MAX44009 (int bus = MAX44009_I2C_BUS, int devAddr = MAX44009_ADDRESS);
-
-        /**
-         * MAX44009 object destructor, basicaly it close i2c connection.
-         */
-        ~MAX44009 ();
-
-        /**
-         * Read the raw visible light value
-         */
-        uint16_t getVisibleRaw();
-
-        /**
-         * Read the lux value
-         */
-        double getVisibleLux();
-
-        virtual const char* getModuleName() { return "max44009"; }
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        MAX44009(const MAX44009&) = delete;
-        MAX44009 &operator=(const MAX44009&) = delete;
-
-        mraa::Result reset();
-
-        int m_maxControlAddr;
-        mraa::I2c* i2c;
-        mraa::Result status;
-};
-
-}
diff --git a/src/max44009/max44009.i b/src/max44009/max44009.i
deleted file mode 100644
index 21c139e..0000000
--- a/src/max44009/max44009.i
+++ /dev/null
@@ -1,19 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "arrays_java.i";
-%include "../java_buffer.i"
-%typemap(javaimports) SWIGTYPE %{import upm_interfaces.*;%}
-%import "../interfaces/javaupm_iLightSensor.i"
-
-JAVA_JNI_LOADLIBRARY(javaupm_max44009)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "max44009.hpp"
-%}
-%include "max44009.hpp"
-/* END Common SWIG syntax */
diff --git a/src/max44009/max44009.json b/src/max44009/max44009.json
deleted file mode 100644
index 6476aaa..0000000
--- a/src/max44009/max44009.json
+++ /dev/null
@@ -1,40 +0,0 @@
-{
-    "Library": "max44009",
-    "Description": "Ambient Light Sensor Library",
-    "Sensor Class":
-    {
-        "MAX44009":
-        {
-            "Name": "Digital Humidity, Pressure, and Temperature Sensor",
-            "Description": "The MAX44009 ambient light sensor features an i2c digital output that is ideal for a number of portable applications such as smartphones, notebooks and industrial sensors",
-            "Aliases": ["max44009"],
-            "Categories": ["light"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping", "industrial"],
-            "Manufacturers": ["Maxim integrated"],
-            "Image": "",
-            "Examples":
-            {
-                "C++": ["max44009.cxx"]
-            },
-            "Specifications":
-            {
-                "Vdd": {"unit": "v", "low" : 1.7, "high": 3.6},
-                "Temperature Range": {"unit": "C", "low" : -40, "high": 85},
-                "Dynamic Range": {"unit": "lux", "low" : 0.045, "high": 188000}
-            },
-            "Platforms":
-            {
-                "Intel Joule Module":
-                {
-                    "Notes": ["might need pull up resistors"]
-                }
-            },
-            "Urls" :
-            {
-                "Product Pages": ["https://www.maximintegrated.com/en/products/analog/sensors-and-sensor-interface/MAX44009.html"],
-                "Datasheets": ["https://datasheets.maximintegrated.com/en/ds/MAX44009.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/max5487/CMakeLists.txt b/src/max5487/CMakeLists.txt
deleted file mode 100644
index 96fb4d3..0000000
--- a/src/max5487/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "max5487")
-set (libdescription "Digital Potentiometer")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/max5487/max5487.cxx b/src/max5487/max5487.cxx
deleted file mode 100644
index 1b89e7b..0000000
--- a/src/max5487/max5487.cxx
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <unistd.h>
-#include <stdlib.h>
-#include <stdexcept>
-
-#include "max5487.hpp"
-
-using namespace upm;
-
-MAX5487::MAX5487 (int csn) :m_spi(0), m_csnPinCtx(csn) {
-    mraa::Result error = mraa::SUCCESS;
-    m_name = "MAX5487";
-
-    if (csn == -1) {
-        throw std::invalid_argument(std::string(__FUNCTION__));
-    }
-
-    error = m_csnPinCtx.dir (mraa::DIR_OUT);
-    if (error != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) + 
-                                    ": mraa_gpio_dir() failed");
-    }
-
-    CSOff ();
-}
-
-void
-MAX5487::setWiperA (uint8_t wiper) {
-    uint8_t data[2] = { 0x00, 0x00};
-
-    CSOn ();
-
-    data[0] = R_WR_WIPER_A;
-    data[1] = wiper;
-
-    m_spi.write(data, 2);
-
-    CSOff ();
-}
-
-void
-MAX5487::setWiperB (uint8_t wiper) {
-    uint8_t data[2] = { 0x00, 0x00};
-
-    CSOn ();
-
-    data[0] = R_WR_WIPER_B;
-    data[1] = wiper;
-
-    m_spi.write(data, 2);
-
-    CSOff ();
-}
-
-/*
- * **************
- *  private area
- * **************
- */
-
-mraa::Result
-MAX5487::CSOn () {
-    return m_csnPinCtx.write(LOW);
-}
-
-mraa::Result
-MAX5487::CSOff () {
-    return m_csnPinCtx.write(HIGH);
-}
diff --git a/src/max5487/max5487.hpp b/src/max5487/max5487.hpp
deleted file mode 100644
index 6a1c19b..0000000
--- a/src/max5487/max5487.hpp
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/aio.hpp>
-
-#include <mraa/gpio.hpp>
-#include <mraa/spi.hpp>
-
-#define HIGH                    1
-#define LOW                     0
-
-namespace upm {
-
-/**
- * @brief MAX5487 Digital Potentiometer
- * @defgroup max5487 libupm-max5487
- * @ingroup maxim spi digipot
- */
-/**
- * @library max5487
- * @sensor max5487
- * @comname Digital Potentiometer
- * @type digipot
- * @man maxim
- * @con spi
- * @web https://www.maximintegrated.com/en/products/analog/data-converters/digital-potentiometers/MAX5487.html
- *
- * @brief API for the MAX5487 SPI Digital Potentiometer
- *
- * Maxim Integrated*
- * [MAX5487](http://datasheets.maximintegrated.com/en/ds/MAX5487-MAX5489.pdf)
- * is a dual, 256-tap, nonvolatile, SPI, linear-taper digital
- * potentiometer. This module was tested on the  Maxim Integrated [MAX5487PMB1
- * PMOD module](http://datasheets.maximintegrated.com/en/ds/MAX5487PMB1.pdf)
- * from the analog PMOD kit.
- *
- * @snippet max5487.cxx Interesting
- */
-class MAX5487 {
-    public:
-        static const uint8_t R_WR_WIPER_A   = 0x01;
-        static const uint8_t R_WR_WIPER_B   = 0x02;
-
-        /**
-         * Instantiates an MAX5487 object
-         *
-         * @param csn CSN to use, if any; by default, ICSP CS (-1) is used
-         */
-        MAX5487 (int csn = -1);
-
-        /**
-         * MAX5487 object destructor, closes all IO connections
-         * no more needed as the connections will be closed when
-         * m_spi and m_csnPinCtx will go out of scope
-         * ~MAX5487 ();
-         **/
-
-        /**
-         * Sets a wiper for port A.
-         */
-        void setWiperA (uint8_t wiper);
-
-        /**
-         * Sets a wiper for port B.
-         */
-        void setWiperB (uint8_t wiper);
-
-        /**
-         * Returns the name of the component
-         */
-        std::string name()
-        {
-            return m_name;
-        }
-    private:
-        std::string m_name;
-        mraa::Spi        m_spi;
-        mraa::Gpio       m_csnPinCtx;
-
-        /**
-         * Sets the chip select pin to LOW
-         */
-        mraa::Result CSOn ();
-
-        /**
-         * Sets the chip select pin to HIGH
-         */
-        mraa::Result CSOff ();
-};
-
-}
diff --git a/src/max5487/max5487.json b/src/max5487/max5487.json
deleted file mode 100644
index 23ad21d..0000000
--- a/src/max5487/max5487.json
+++ /dev/null
@@ -1,51 +0,0 @@
-{
-    "Library": "max5487",
-    "Description": "MAX5487 Digital Potentiometer library",
-    "Sensor Class": {
-        "MAX5487": {
-            "Name": "MAX5487 Digital Potentiometer",
-            "Description": "This is the UPM Module for the Maxim dual, linear-taper, digital potentiometer. It offers 256 Tap positions, as well as a 10 kiloohm end to end resistance. It interfaces using 3 wire spi, and feature nonvolatile memory.",
-            "Aliases": ["max5487", "MAX5487 Dual, 256-Tap, Nonvolatile, SPI-Interface, Linear-Taper Digital Potentiometers"],
-            "Categories": ["digital potentiometer"],
-            "Connections": ["spi"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["maxim"],
-            "Examples": {
-                "Java": ["MAX5487_Example.java"],
-                "C++": ["max5487.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 2.7,
-                    "max": 5.25
-                },
-                "Supply Current": {
-                    "unit": "uA",
-                    "min" : "0.5",
-                    "max" : "400"
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need pull up resistors"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.maximintegrated.com/en/products/analog/data-converters/digital-potentiometers/MAX5487.html"],
-                "Datasheets": ["https://datasheets.maximintegrated.com/en/ds/MAX5487-MAX5489.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/maxds3231m/CMakeLists.txt b/src/maxds3231m/CMakeLists.txt
deleted file mode 100644
index 66f6e6f..0000000
--- a/src/maxds3231m/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "maxds3231m")
-set (libdescription "Realtime Clock (RTC) Sensor Library")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/maxds3231m/maxds3231m.cxx b/src/maxds3231m/maxds3231m.cxx
deleted file mode 100644
index c33c765..0000000
--- a/src/maxds3231m/maxds3231m.cxx
+++ /dev/null
@@ -1,124 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <unistd.h>
-#include <stdlib.h>
-#include <stdexcept>
-
-#include "maxds3231m.hpp"
-
-using namespace upm;
-
-MAXDS3231M::MAXDS3231M (int bus, int devAddr) : m_i2Ctx(bus) {
-    m_name = "MAXDS3231M";
-
-    m_i2cAddr = devAddr;
-    m_bus = bus;
-
-    mraa::Result ret = m_i2Ctx.address(m_i2cAddr);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) + 
-                                    ": m_i2Ctx.address() failed");
-    }
-}
-
-void
-MAXDS3231M::setDate (Time3231 &time) {
-    uint8_t *data = (uint8_t *)&time;
-
-    i2cWriteReg_N (TIME_CAL_ADDR, 7, data);
-}
-
-bool
-MAXDS3231M::getDate (Time3231 &time) {
-    uint8_t buffer[7];
-
-    // We need 7 bytes of data.
-    if (i2cReadReg_N (TIME_CAL_ADDR, 7, buffer) > 6) {
-        uint8_t century = (buffer[5] & 0x80) >> 7;
-
-        time.second     = BCDtoDEC(buffer[0]);
-        time.minute     = BCDtoDEC(buffer[1]);
-        time.hour       = BCDtoDEC(buffer[2]);
-        time.day        = BCDtoDEC(buffer[4]);
-        time.month      = BCDtoDEC(buffer[5] & 0x1F);
-        time.year       = (century == 1) ? 2000 + BCDtoDEC(buffer[6]) : 1900 + BCDtoDEC(buffer[6]);
-        time.weekDay    = BCDtoDEC(buffer[3]);
-
-        return true;
-    }
-
-    return false;
-}
-
-uint16_t
-MAXDS3231M::getTemperature () {
-    uint8_t     buffer[2];
-    uint8_t     msb     = 0;
-    uint8_t     lsb     = 0;
-
-    i2cReadReg_N (TEMPERATURE_ADDR, 2, buffer);
-    msb = buffer[0];
-    lsb = buffer[1] >> 6;
-
-    if ((msb & 0x80) != 0)
-        msb |= ~((1 << 8) - 1); // if negative get two's complement
-
-    return 0.25 * lsb + msb;
-}
-
-/*
- * **************
- *  private area
- * **************
- */
-uint16_t
-MAXDS3231M::i2cReadReg_N (int reg, unsigned int len, uint8_t * buffer) {
-    int readByte = 0;
-
-    m_i2Ctx.writeByte(reg);
-
-    readByte = m_i2Ctx.read(buffer, len);
-    return readByte;
-}
-
-mraa::Result
-MAXDS3231M::i2cWriteReg_N (uint8_t reg, unsigned int len, uint8_t * buffer) {
-    mraa::Result error = mraa::SUCCESS;
-
-    error = m_i2Ctx.write (buffer, len);
-
-    return error;
-}
-
-uint8_t
-MAXDS3231M::DECtoBSD(uint8_t data) {
-    return ((data / 10 * 16) + (data % 10));
-}
-
-uint8_t
-MAXDS3231M::BCDtoDEC(uint8_t data) {
-    return ((data / 16 * 10) + (data % 16));
-}
diff --git a/src/maxds3231m/maxds3231m.hpp b/src/maxds3231m/maxds3231m.hpp
deleted file mode 100644
index 546544d..0000000
--- a/src/maxds3231m/maxds3231m.hpp
+++ /dev/null
@@ -1,134 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/i2c.hpp>
-
-#define ADDR                    0x68 // device address
-
-// timekeeping registers
-#define TIME_CAL_ADDR           0x00
-#define ALARM1_ADDR             0x07
-#define ALARM2_ADDR             0x0B
-#define CONTROL_ADDR            0x0E
-#define STATUS_ADDR             0x0F
-#define AGING_OFFSET_ADDR       0x10
-#define TEMPERATURE_ADDR        0x11
-
-// control register bits
-#define A1IE                    0x1
-#define A2IE                    0x2
-#define INTCN                   0x4
-
-// status register bits
-#define A1F                     0x1
-#define A2F                     0x2
-#define OSF                     0x80
-
-#define HIGH                    1
-#define LOW                     0
-
-namespace upm {
-
-struct Time3231 {
-    uint8_t second;
-    uint8_t minute;
-    uint8_t hour;
-    uint8_t day;
-    uint8_t month;
-    int16_t year;
-    uint8_t weekDay;
-};
-
-/**
- * @brief MAXDS3231M Proximity Sensor
- * @defgroup maxds3231m libupm-maxds3231m
- * @ingroup maxim i2c light
- */
-/**
- * @library maxds3231m
- * @sensor maxds3231m
- * @comname Realtime Clock (RTC) Sensor Library
- * @type light
- * @man maxim
- * @con i2c
- * @web https://www.maximintegrated.com/en/products/digital/real-time-clocks/DS3231.html
- *
- * @brief API for the MAXDS3231M I2C Real-Time Clock
- *
- * This module defines the API for MAXDS3231M
- *
- * @snippet maxds3231m.cxx Interesting
- */
-class MAXDS3231M {
-    public:
-        /**
-         * Instantiates an MAXDS3231M object
-         *
-         * @param bus Number of the used bus
-         * @param devAddr Address of the used I2C device
-         */
-        MAXDS3231M (int bus=0, int devAddr=0x68);
-
-        /**
-         * Sets the date and time on the chip.
-         *
-         * @param time Time structure
-         */
-        void setDate (Time3231 &time);
-
-        /**
-         * Gets the date and time from the chip.
-         *
-         * @param time Time structure
-         */
-        bool getDate (Time3231 &time);
-
-        /**
-         * Gets the on-board temperature.
-         */
-        uint16_t getTemperature ();
-
-        /**
-         * Returns the name of the component
-         */
-        std::string name()
-        {
-            return m_name;
-        }
-    private:
-        std::string m_name;
-
-        int m_i2cAddr;
-        int m_bus;
-        mraa::I2c m_i2Ctx;
-
-        uint16_t i2cReadReg_N (int reg, unsigned int len, uint8_t * buffer);
-        mraa::Result i2cWriteReg_N (uint8_t reg, unsigned int len, uint8_t * buffer);
-        uint8_t DECtoBSD (uint8_t data);
-        uint8_t BCDtoDEC (uint8_t data);
-};
-
-}
diff --git a/src/maxds3231m/maxds3231m.json b/src/maxds3231m/maxds3231m.json
deleted file mode 100644
index b0faefb..0000000
--- a/src/maxds3231m/maxds3231m.json
+++ /dev/null
@@ -1,56 +0,0 @@
-{
-    "Library": "maxds3231m",
-    "Description": "maxds3231m Realtime Clock (RTC) Sensor Library",
-    "Sensor Class": {
-        "MAXDS3231M": {
-            "Name": "maxds3231m Realtime Clock (RTC) Sensor",
-            "Description": "This is the UPM Module for the Maxim Realtime Clock module. It offers i2c connectivity, with a temperature compensated crystal and crystal oscillator. It offers 12 and 24 hour clock formats, as built in battery backup support.",
-            "Aliases": ["maxds3231m", "DS3231", "DS3231 Extremely Accurate I2C-Integrated RTC/TCXO/Crystal"],
-            "Categories": ["RTC"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["Maxim"],
-            "Examples": {
-                "Java": ["MAXds3231m_Example.java"],
-                "C++": ["maxds3231m.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 2.3,
-                    "max": 5.5
-                },
-                "Supply Current": {
-                    "unit": "uA",
-                    "min" : 130,
-                    "max" : 650
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -45,
-                    "max": 85
-                },
-                "Compensated Temperature Range": {
-                    "unit": "C",
-                    "min": 0,
-                    "max": 40
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need pull up resistors"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.maximintegrated.com/en/products/digital/real-time-clocks/DS3231.html"],
-                "Datasheets": ["https://datasheets.maximintegrated.com/en/ds/DS3231M.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/maxsonarez/CMakeLists.txt b/src/maxsonarez/CMakeLists.txt
deleted file mode 100644
index feae391..0000000
--- a/src/maxsonarez/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "maxsonarez")
-set (libdescription "MaxSonar EZ Family of Ultrasonic Rangers")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/maxsonarez/maxsonarez.cxx b/src/maxsonarez/maxsonarez.cxx
deleted file mode 100644
index d6974e7..0000000
--- a/src/maxsonarez/maxsonarez.cxx
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "maxsonarez.hpp"
-
-using namespace std;
-using namespace upm;
-
-MAXSONAREZ::MAXSONAREZ(int pin, float aref)
-{
-  if (!(m_aio = mraa_aio_init(pin)))
-    {
-      throw std::invalid_argument(std::string(__FUNCTION__) +
-                                  ": mraa_aio_init() failed, invalid pin?");
-      return;
-    }
-
-  m_aRes = (1 << mraa_aio_get_bit(m_aio));
-  m_aref = aref;
-
-  // volt's per inch of this sensor
-  m_vI = (m_aref / MAXSONAREZ_RES);
-}
-
-MAXSONAREZ::~MAXSONAREZ()
-{
-  mraa_aio_close(m_aio);
-}
-
-int MAXSONAREZ::inches()
-{
-  int val = mraa_aio_read(m_aio);
-  if (val == -1) {
-    return -1;
-  }
-  float volts = float(val) * (m_aref / m_aRes);
-
-  return int(volts / m_vI);
-}
diff --git a/src/maxsonarez/maxsonarez.hpp b/src/maxsonarez/maxsonarez.hpp
deleted file mode 100644
index cdceacc..0000000
--- a/src/maxsonarez/maxsonarez.hpp
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <iostream>
-#include <string>
-#include <mraa/aio.h>
-
-// EZ series is volts/512
-#define MAXSONAREZ_RES  512
-
-namespace upm {
-  /**
-   * @brief MaxSonar-EZ Family of Ultrasonic Rangers
-   * @defgroup maxsonarez libupm-maxsonarez
-   * @ingroup seeed analog sound
-   */
-
-  /**
-   * @library maxsonarez
-   * @sensor maxsonarez
-   * @comname LV-MaxSonar-EZ Ultrasonic Ranger
-   * @altname EZ1, EZ2, EZ3, EZ4
-   * @type sound
-   * @man sparkfun
-   * @web https://www.sparkfun.com/products/8502
-   * @con analog
-   *
-   * @brief API for the LV-MaxSonar-EZ Family of Ultrasonic Rangers
-   *
-   * Sensors of this family return an analog voltage corresponding to the
-   * distance of an object from the sensor in inches. They have a
-   * resolution of about 9.7 millivolts per inch with an analog reference voltage of 5.0 V. The
-   * differences between various versions (EZ1, EZ2, etc.) are
-   * related to the narrowness of the beam angle.
-   *
-   * This class supports these sensors with an analog input only.
-   *
-   * This driver was developed using an LV-MaxSonar-EZ3 ultrasonic ranger.
-   *
-   * @image html maxsonarez.jpg
-   * <br><em>LV-MaxSonar-EZ Ultrasonic Ranger image provided by SparkFun* under
-   * <a href=https://creativecommons.org/licenses/by/2.0/>
-   * CC BY 2.0</a>.</em>
-   *
-   * @snippet maxsonarez.cxx Interesting
-   */
-
-  class MAXSONAREZ {
-  public:
-
-    /**
-     * MAXSONAREZ constructor
-     *
-     * @param pin Analog pin to use
-     * @param aref Analog reference voltage; default is 5.0 V
-     */
-    MAXSONAREZ(int pin, float aref=5.0);
-
-    /**
-     * MAXSONAREZ destructor
-     */
-    ~MAXSONAREZ();
-
-    /**
-     * Gets the distance to the object in inches
-     *
-     * @return Distance to the object in inches
-     */
-    int inches();
-
-  private:
-    mraa_aio_context m_aio;
-    float m_aref;
-    // ADC resolution
-    int m_aRes;
-    // computed volts per inch
-    float m_vI;
-  };
-}
-
-
diff --git a/src/maxsonarez/maxsonarez.json b/src/maxsonarez/maxsonarez.json
deleted file mode 100644
index 30f7c96..0000000
--- a/src/maxsonarez/maxsonarez.json
+++ /dev/null
@@ -1,57 +0,0 @@
-{
-    "Library": "maxsonarez",
-    "Description": "API for the MaxBotix LV-MaxSonar-EZ Family of Ultrasonic Rangers",
-    "Sensor Class": {
-        "MAXSONAREZ": {
-            "Name": "LV-MaxSonar-EZ0 Ultrasonic range finder",
-            "Description": "This is the UPM Module for the MaxBotix Ultrasonic Range Finder series. The EZ0 offers the widest beam of the EZ collection. The EZ1 offers the second widest beam of the EZ collection, as well as high sensativity and side object rejectoin. The EZ2 offers a good balance of high sensativity and side object rejection. The EZ3 offers a very narrow beam, with good side object rejection. The EZ4 is the narrowest beam sensor, with the best side object rejection, which provides good detection for large objects.",
-            "Aliases": ["maxsonarez", "LV-MaxSonar-EZ0", "MB1000 LV-MaxSonar-EZ0", "LV-MaxSonar-EZ1", "MB1010 LV-MaxSonar-EZ1", "LV-MaxSonar-EZ2", "MB1020 LV-MaxSonar-EZ2", "LV-MaxSonar-EZ3", "MB1030 LV-MaxSonar-EZ3", "LV-MaxSonar-EZ4", "MB1040 LV-MaxSonar-EZ4"],
-            "Categories": ["sound"],
-            "Connections": ["analog"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["MaxBotix"],
-            "Image": "maxsonarez.jpg",
-            "Examples": {
-                "Python": ["maxsonarez.py"],
-                "Node.js": ["maxsonarez.js"],
-                "C++": ["maxsonarez.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 2.5,
-                    "max": 5.5
-                },
-                "Supply Current":{
-                    "unit": "mA",
-                    "Typ" : "2"
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Effective Range": {
-                    "unit": "cm",
-                    "min": "15.24",
-                    "max": "645"
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need pull up resistors"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.maxbotix.com/Ultrasonic_Sensors/MB1000.htm"],
-                "Datasheets": ["http://www.maxbotix.com/documents/LV-MaxSonar-EZ_Datasheet.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/mb704x/CMakeLists.txt b/src/mb704x/CMakeLists.txt
deleted file mode 100644
index 33892a7..0000000
--- a/src/mb704x/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME mb704x
-    DESCRIPTION "MB7040/7047 I2C MaxSonar WR Ultrasonic Ranger"
-    C_HDR mb704x.h
-    C_SRC mb704x.c
-    CPP_HDR mb704x.hpp
-    CPP_SRC mb704x.cxx
-    FTI_SRC mb704x_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/mb704x/mb704x.c b/src/mb704x/mb704x.c
deleted file mode 100644
index 085d4ee..0000000
--- a/src/mb704x/mb704x.c
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <stdlib.h>
-#include <string.h>
-#include <assert.h>
-
-#include <upm_utilities.h>
-
-#include "mb704x.h"
-
-// The delay to wait (in ms) for a ranging command to complete before
-// requesting the range data.
-#define MB704X_RANGE_DELAY     (100)
-
-// range command
-#define MB704X_CMD_RANGE       (81)
-
-mb704x_context mb704x_init(unsigned int bus, int addr)
-{
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        return NULL;
-    }
-
-    mb704x_context dev =
-        (mb704x_context)malloc(sizeof(struct _mb704x_context));
-
-    if (!dev)
-        return NULL;
-
-    // zero out context
-    memset((void *)dev, 0, sizeof(struct _mb704x_context));
-
-    // initialize the MRAA contexts
-
-    if (!(dev->i2c = mraa_i2c_init(bus)))
-    {
-        printf("%s: mraa_i2c_init() failed.\n", __FUNCTION__);
-        mb704x_close(dev);
-        return NULL;
-    }
-
-    if (mraa_i2c_address(dev->i2c, (uint8_t)addr))
-    {
-        printf("%s: mraa_i2c_address() failed.\n", __FUNCTION__);
-        mb704x_close(dev);
-        return NULL;
-    }
-
-    // max power up delay
-    upm_delay_ms(135);
-
-    return dev;
-}
-
-void mb704x_close(mb704x_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->i2c)
-        mraa_i2c_stop(dev->i2c);
-
-    free(dev);
-}
-
-int mb704x_get_range(const mb704x_context dev)
-{
-    assert(dev != NULL);
-
-    // first, send the range command.
-    uint8_t cmd = MB704X_CMD_RANGE;
-    if (mraa_i2c_write(dev->i2c, &cmd, 1))
-    {
-        printf("%s: mraa_i2c_write() failed.\n", __FUNCTION__);
-        return -1;
-    }
-
-    // delay for measurement
-    upm_delay_ms(MB704X_RANGE_DELAY);
-
-    // At this point, we should be able to do our read of the data
-    uint8_t buffer[2];
-    if (mraa_i2c_read(dev->i2c, buffer, 2) != 2)
-    {
-        printf("%s: mraa_i2c_read() failed.\n", __FUNCTION__);
-        return -1;
-    }
-
-    return ((buffer[0] << 8) | buffer[1]);
-}
diff --git a/src/mb704x/mb704x.cxx b/src/mb704x/mb704x.cxx
deleted file mode 100644
index 725ad3c..0000000
--- a/src/mb704x/mb704x.cxx
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <stdexcept>
-
-#include "mb704x.hpp"
-
-using namespace upm;
-using namespace std;
-
-MB704X::MB704X(unsigned int bus, unsigned int addr) :
-    m_mb704x(mb704x_init(bus, addr))
-{
-    if (!m_mb704x)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": mb704x_*_init() failed");
-}
-
-MB704X::~MB704X()
-{
-    mb704x_close(m_mb704x);
-}
-
-int MB704X::getRange()
-{
-    return mb704x_get_range(m_mb704x);
-}
diff --git a/src/mb704x/mb704x.h b/src/mb704x/mb704x.h
deleted file mode 100644
index 5b98d30..0000000
--- a/src/mb704x/mb704x.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <stdint.h>
-#include <upm.h>
-#include <mraa/i2c.h>
-#include <mraa/gpio.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    /**
-     * @file mb704x.h
-     * @library mb704x
-     * @brief C API for the MB704x MaxSonar-WR Ultrasonic Ranger
-     *
-     * @include mb704x.c
-     */
-
-    /**
-     * Device context
-     */
-    typedef struct _mb704x_context {
-        mraa_i2c_context         i2c;
-    } *mb704x_context;
-
-    /**
-     * MB704X Initializer
-     *
-     * @param bus Specify which the I2C bus to use.
-     * @param addr Specify the I2C address to use.  The default is 112.
-     * @return an initialized device context on success, NULL on error.
-     */
-    mb704x_context mb704x_init(unsigned int bus, int addr);
-
-    /**
-     * MB704X sensor close function
-     */
-    void mb704x_close(mb704x_context dev);
-
-    /**
-     * Query the device for a range reading.  The range will be
-     * reported in centimeters (cm).
-     *
-     * @param dev Device context
-     * @return Measured range, -1 on error. The range is reported in
-     * centimeters (cm).
-     */
-    int mb704x_get_range(const mb704x_context dev);
-
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/mb704x/mb704x.hpp b/src/mb704x/mb704x.hpp
deleted file mode 100644
index d40247e..0000000
--- a/src/mb704x/mb704x.hpp
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <iostream>
-
-#include <stdlib.h>
-#include <unistd.h>
-
-#include "mb704x.h"
-
-namespace upm {
-    /**
-     * @brief MB704x MaxSonar-WR Ultrasonic Ranger
-     * @defgroup mb704x libupm-mb704x
-     * @ingroup i2c sound
-     */
-
-    /**
-     * @library mb704x
-     * @sensor mb704x
-     * @comname I2C MaxSonar WR Ultrasonic Ranger
-     * @altname MB7040 MB7047 MB7247
-     * @type sound
-     * @man maxbotix
-     * @con i2c
-     * @web http://www.maxbotix.com/Ultrasonic_Sensors/I2C_Distance_Sensors.htm
-     *
-     * @brief API for the MB704x MaxSonar-WR Ultrasonic Ranger
-     *
-     * This driver was tested with the MB704x MaxSonar-WR Ultrasonic
-     * Ranger using the long distance, weather resistant horn.
-     * Depending on your sensor type and horn, tanges from 20cm to
-     * 750cm are possible.
-     *
-     * @snippet mb704x.cxx Interesting
-     */
-
-    class MB704X {
-    public:
-
-        /**
-         * Initialize a device context.
-         *
-         * @param bus Specify which the I2C bus to use.  The default is 0.
-         * @param addr Specify the I2C address to use.  The default is 112.
-         */
-        MB704X(unsigned int bus=0, unsigned int addr=112);
-
-        /**
-         * MB704X object destructor
-         */
-        ~MB704X();
-
-        /**
-         * Query the device for a range reading.  The range will be
-         * reported in centimeters (cm).
-         *
-         * @param dev Device context
-         * @return Measured range, -1 on error. The range is reported in
-         * centimeters (cm).
-         */
-        int getRange();
-
-
-    protected:
-        // mb704x device context
-        mb704x_context m_mb704x;
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        MB704X(const MB704X&) = delete;
-        MB704X &operator=(const MB704X&) = delete;
-    };
-}
diff --git a/src/mb704x/mb704x.i b/src/mb704x/mb704x.i
deleted file mode 100644
index f88ca40..0000000
--- a/src/mb704x/mb704x.i
+++ /dev/null
@@ -1,14 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_mb704x)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "mb704x.hpp"
-%}
-%include "mb704x.hpp"
-/* END Common SWIG syntax */
diff --git a/src/mb704x/mb704x.json b/src/mb704x/mb704x.json
deleted file mode 100644
index e39375c..0000000
--- a/src/mb704x/mb704x.json
+++ /dev/null
@@ -1,58 +0,0 @@
-{
-    "Library": "mb704x",
-    "Description": "API for the MaxBotix MB704x MaxSonar-WR Ultrasonic Ranger",
-    "Sensor Class": {
-        "MB704X": {
-            "Name": "MB704x MaxSonar-WR Ultrasonic Ranger",
-            "Description": "This is the UPM Module for the API for the MB704x MaxSonar-WR Ultrasonic Ranger. It was tested with a long distance weather resistant horn, others are offered however giving this sensor a large range of uses.",
-            "Aliases": ["MB704x", "MB704x MaxSonar-WR Ultrasonic Ranger"],
-            "Categories": ["sound"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping", "industrial"],
-            "Manufacturers": ["MaxBotix"],
-            "Examples": {
-                "Java": ["MB704X_Example.java"],
-                "Python": ["mb704x.py"],
-                "Node.js": ["mb704x.js"],
-                "C++": ["mb704x.cxx"],
-                "C": ["mb704x.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.0,
-                    "max": 5.5
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "Typ" : "3.4"
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 70
-                },
-                "Effective Range": {
-                    "unit": "cm",
-                    "min" : "20",
-                    "max" : "765"
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need pull up resistors"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["http://www.maxbotix.com/Ultrasonic_Sensors/I2C_Distance_Sensors.htm"],
-                "Datasheets": ["https://www.maxbotix.com/documents/I2CXL-MaxSonar-WR_Datasheet.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/mb704x/mb704x_fti.c b/src/mb704x/mb704x_fti.c
deleted file mode 100644
index 059674e..0000000
--- a/src/mb704x/mb704x_fti.c
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "mb704x.h"
-#include "upm_fti.h"
-
-/**
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_mb704x_name[] = "MB704X";
-const char upm_mb704x_description[] = "MB704x MaxSonar-WR Ultrasonic Ranger";
-const upm_protocol_t upm_mb704x_protocol[] = {UPM_I2C};
-const upm_sensor_t upm_mb704x_category[] = {UPM_DISTANCE};
-
-// forward declarations
-const void* upm_mb704x_get_ft(upm_sensor_t sensor_type);
-void* upm_mb704x_init_name();
-void upm_mb704x_close(void *dev);
-upm_result_t upm_mb704x_get_distance(void *dev, float *value,
-                                     upm_distance_u unit);
-
-const upm_sensor_descriptor_t upm_es08a_get_descriptor()
-{
-    upm_sensor_descriptor_t usd;
-
-    usd.name = upm_mb704x_name;
-    usd.description = upm_mb704x_description;
-    usd.protocol_size = 1;
-    usd.protocol = upm_mb704x_protocol;
-    usd.category_size = 1;
-    usd.category = upm_mb704x_category;
-
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-  .upm_sensor_init_name = &upm_mb704x_init_name,
-  .upm_sensor_close = &upm_mb704x_close,
-};
-
-static const upm_distance_ft dft =
-{
-  .upm_distance_get_value = upm_mb704x_get_distance
-};
-
-const void* upm_mb704x_get_ft(upm_sensor_t sensor_type)
-{
-  switch(sensor_type)
-    {
-    case UPM_SENSOR:
-      return &ft;
-
-    case UPM_DISTANCE:
-      return &dft;
-
-    default:
-      return NULL;
-    }
-}
-
-void *upm_mb704x_init_name()
-{
-  return NULL;
-}
-
-void upm_mb704x_close(void *dev)
-{
-  mb704x_close((mb704x_context)dev);
-}
-
-upm_result_t upm_mb704x_get_distance(void *dev, float *value,
-                                     upm_distance_u unit)
-{
-    int rv;
-
-    if ((rv = mb704x_get_range((mb704x_context)dev)) < 0)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    switch(unit)
-    {
-    case CENTIMETER:
-        *value = (float)rv;
-    case INCH:
-        *value = ((float)rv * 0.393701);
-    default:
-        return UPM_ERROR_INVALID_PARAMETER;
-    }
-
-    return UPM_SUCCESS;
-}
diff --git a/src/mcp2515/CMakeLists.txt b/src/mcp2515/CMakeLists.txt
deleted file mode 100644
index 5feb105..0000000
--- a/src/mcp2515/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-upm_mixed_module_init (NAME mcp2515
-    DESCRIPTION "CAN Bus Controller"
-    C_HDR mcp2515.h mcp2515_regs.h
-    C_SRC mcp2515.c
-    CPP_HDR mcp2515.hpp
-    CPP_SRC mcp2515.cxx
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/mcp2515/license.txt b/src/mcp2515/license.txt
deleted file mode 100644
index ccbbd2d..0000000
--- a/src/mcp2515/license.txt
+++ /dev/null
@@ -1,51 +0,0 @@
-The table of CNF1-3 valuses used to set the CAN bus baudrate were
-taken from the Seeed studio code at:
-
-https://github.com/Seeed-Studio/CAN_BUS_Shield/
-
-/*
-  mcp_can.cpp
-  2012 Copyright (c) Seeed Technology Inc.  All right reserved.
-
-  Author:Loovee
-  2014-1-16
-
-  Contributor:
-
-  Cory J. Fowler
-  Latonita
-  Woodward1
-  Mehtajaghvi
-  BykeBlast
-  TheRo0T
-  Tsipizic
-  ralfEdmund
-  Nathancheek
-  BlueAndi
-  Adlerweb
-  Btetz
-  Hurvajs
-  xboxpro1
-
-  The MIT License (MIT)
-
-  Copyright (c) 2013 Seeed Technology Inc.
-
-  Permission is hereby granted, free of charge, to any person obtaining a copy
-  of this software and associated documentation files (the "Software"), to deal
-  in the Software without restriction, including without limitation the rights
-  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-  copies of the Software, and to permit persons to whom the Software is
-  furnished to do so, subject to the following conditions:
-
-  The above copyright notice and this permission notice shall be included in
-  all copies or substantial portions of the Software.
-
-  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-  THE SOFTWARE.
-*/
diff --git a/src/mcp2515/mcp2515.c b/src/mcp2515/mcp2515.c
deleted file mode 100644
index 4c2531a..0000000
--- a/src/mcp2515/mcp2515.c
+++ /dev/null
@@ -1,1107 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <string.h>
-#include <assert.h>
-
-#include "mcp2515.h"
-
-#include <upm_platform.h>
-#include <upm_utilities.h>
-
-// in ms
-#define MCP2515_MAX_TIMEOUT (5000)
-
-// static array of cnf1-3 value for setting speed.  These values were
-// taken from the Seeed code at:
-// https://github.com/Seeed-Studio/CAN_BUS_Shield/
-
-struct _mcp2515_config {
-    uint8_t cnf1;
-    uint8_t cnf2;
-    uint8_t cnf3;
-};
-
-// NOTE: These indexes must match the enum MCP2515_SPEED_T values in
-// mcp2515_regs.h!  Add any new values to the end, with a corresponding
-// enum value in MCP2515_SPEED_T.
-static struct _mcp2515_config mcp2515_configs[] = {
-    { 0x3f, 0xff, 0x87 }, // 0 - 5kbps
-    { 0x1f, 0xff, 0x87 }, // 1 - 10kbps
-    { 0x0f, 0xff, 0x87 }, // 2 - 20kbps
-    { 0x0f, 0xba, 0x07 }, // 3 - 25kbps
-    { 0x0f, 0xf1, 0x85 }, // 4 - 31k25kbps
-    { 0x09, 0xbe, 0x07 }, // 5 - 33kbps
-    { 0x07, 0xff, 0x87 }, // 6 - 40kbps
-    { 0x07, 0xfa, 0x87 }, // 7 - 50kbps
-    { 0x03, 0xff, 0x87 }, // 8 - 80kbps
-    { 0x03, 0xbe, 0x07 }, // 9 - 83kbps
-
-    { 0x03, 0xad, 0x07 }, // 10 - 95kbps
-    { 0x03, 0xfa, 0x87 }, // 11 - 100kbps
-    { 0x03, 0xf0, 0x86 }, // 12 - 125kbps
-    { 0x01, 0xfa, 0x87 }, // 13 - 200kbps
-    { 0x41, 0xf1, 0x85 }, // 14 - 250kbps
-    { 0x00, 0xf0, 0x86 }, // 15 - 500kbps
-    { 0x00, 0xa0, 0x04 }, // 16 - 666kbps
-    { 0x00, 0xd0, 0x82 }, // 17 - 1000kbps
-};
-
-// For SPI, these are our CS on/off functions, if needed
-static void mcp2515_cs_on(const mcp2515_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->gpio)
-        mraa_gpio_write(dev->gpio, 0);
-}
-
-static void mcp2515_cs_off(const mcp2515_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->gpio)
-        mraa_gpio_write(dev->gpio, 1);
-}
-
-// convert an integer id into the 4-byte breakout format used by the
-// device.
-static void mcp2515_int_to_id(const mcp2515_context dev, int id, bool ext,
-                              bool is_filter, MCP2515_ID_T *did)
-{
-    assert(dev != NULL);
-    assert(did != NULL);
-
-    // mask off all but the lower 29 bits
-    id &= 0x1fffffff;
-
-    did->SIDH = (id >> 3) & 0xff;
-    did->SIDL = ((id & 0x07) << 5);
-    did->EID8 = 0;
-    did->EID0 = 0;
-
-    // This is a sort of special case (ext vs. filter).  When using
-    // this function to create a filter, but the msg type is standard,
-    // the filtering/masking engine can use the first 16 bits of
-    // extended filter data (EID8, EID0) to compare against the first
-    // 16 bits of the data payload (D0 and D1).  For a standard id,
-    // the extended bits 16 and 17 are ignored, so we only include
-    // these (along with the extended bit) on true extended ids
-    // regardless of filtering.
-    if (ext || is_filter)
-    {
-        if (ext)
-        {
-            // add ext bits 17 and 16
-            did->SIDL |= ((id & 0x18000000) >> 27) & 0x03;
-            // set the extended id bit
-            did->SIDL |= MCP2515_SIDL_EXIDE;
-        }
-        // now fill in the extended bits
-        did->EID8 = (id >> 19) & 0xff;
-        did->EID0 = (id >> 11) & 0xff;
-    }
-}
-
-// convert the 4-byte breakout format used by the device into an integer id
-static int mcp2515_id_to_int(const mcp2515_context dev, bool *ext,
-                             MCP2515_ID_T *did)
-{
-    assert(dev != NULL);
-    assert(did != NULL);
-
-    int id = 0;
-    *ext = false;
-
-    id |= (did->SIDH << 3);
-    id |= (did->SIDL >> 5) & 0x07;
-
-    // is it an extended id?
-    if (did->SIDL & MCP2515_SIDL_EXIDE)
-    {
-        *ext = true;
-        id |= ((did->SIDL & 0x03) << 27);
-
-        id |= (did->EID8 << 19);
-        id |= (did->EID0 << 11);
-    }
-
-    return id;
-}
-
-// init...
-mcp2515_context mcp2515_init(int bus, int cs_pin)
-{
-    mcp2515_context dev =
-        (mcp2515_context)malloc(sizeof(struct _mcp2515_context));
-
-    if (!dev)
-        return NULL;
-
-    // zero out context
-    memset((void *)dev, 0, sizeof(struct _mcp2515_context));
-
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        mcp2515_close(dev);
-        return NULL;
-    }
-
-    if (!(dev->spi = mraa_spi_init(bus)))
-    {
-        printf("%s: mraa_spi_init() failed.\n", __FUNCTION__);
-        mcp2515_close(dev);
-        return NULL;
-    }
-
-    // Only create cs context if we are actually using a valid pin.
-    // A hardware controlled pin should specify cs as -1.
-    if (cs_pin >= 0)
-    {
-        if (!(dev->gpio = mraa_gpio_init(cs_pin)))
-        {
-            printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
-            mcp2515_close(dev);
-            return NULL;
-        }
-
-        mraa_gpio_dir(dev->gpio, MRAA_GPIO_OUT);
-        mcp2515_cs_off(dev);
-    }
-
-    if (mraa_spi_mode(dev->spi, MRAA_SPI_MODE0))
-    {
-        printf("%s: mraa_spi_mode() failed.\n", __FUNCTION__);
-        mcp2515_close(dev);
-        return NULL;
-    }
-
-    if (mraa_spi_frequency(dev->spi, 10000000))
-    {
-        printf("%s: mraa_spi_frequency() failed.\n", __FUNCTION__);
-        mcp2515_close(dev);
-        return NULL;
-    }
-
-    // reset
-    if (mcp2515_reset(dev))
-    {
-        printf("%s: mcp2515_reset() failed.\n", __FUNCTION__);
-        mcp2515_close(dev);
-        return NULL;
-    }
-
-    // make sure the mode is config (should be after a reset), set a
-    // default speed, and then set normal mode.
-    if (mcp2515_set_opmode(dev, MCP2515_OPMODE_CONFIG))
-    {
-        printf("%s: mcp2515_set_opmode(config) failed.\n", __FUNCTION__);
-        mcp2515_close(dev);
-        return NULL;
-    }
-
-    if (mcp2515_set_speed(dev, MCP2515_SPEED_50KBPS))
-    {
-        printf("%s: mcp2515_set_speed() failed.\n", __FUNCTION__);
-        mcp2515_close(dev);
-        return NULL;
-    }
-
-    // clear all filters and masks
-    if (mcp2515_set_filter(dev, MCP2515_RX_FILTER0, false, 0)
-        || mcp2515_set_filter(dev, MCP2515_RX_FILTER1, false, 0)
-        || mcp2515_set_filter(dev, MCP2515_RX_FILTER2, false, 0)
-        || mcp2515_set_filter(dev, MCP2515_RX_FILTER3, false, 0)
-        || mcp2515_set_filter(dev, MCP2515_RX_FILTER4, false, 0)
-        || mcp2515_set_filter(dev, MCP2515_RX_FILTER5, false, 0))
-    {
-        printf("%s: mcp2515_set_filter() failed.\n", __FUNCTION__);
-        mcp2515_close(dev);
-        return NULL;
-    }
-
-    if (mcp2515_set_mask(dev, MCP2515_RX_MASK0, false, 0)
-        || mcp2515_set_mask(dev, MCP2515_RX_MASK1, false, 0))
-    {
-        printf("%s: mcp2515_set_mask() failed.\n", __FUNCTION__);
-        mcp2515_close(dev);
-        return NULL;
-    }
-
-    // set the mode for any filter.  With the above settings, all
-    // packets will be received since all of the mode bits are 0, so
-    // the filter bits are ignored.
-    if (mcp2515_set_rx_buffer_mode(dev, MCP2515_RX_BUFFER0,
-                                   MCP2515_RXMODE_ANY_FILTER)
-        || mcp2515_set_rx_buffer_mode(dev, MCP2515_RX_BUFFER1,
-                                      MCP2515_RXMODE_ANY_FILTER))
-    {
-        printf("%s: mcp2515_set_rx_buffer_mode() failed.\n", __FUNCTION__);
-        mcp2515_close(dev);
-        return NULL;
-    }
-
-    // turn off all interrupt enables
-    if (mcp2515_set_intr_enables(dev, 0))
-    {
-        printf("%s: mcp2515_set_intr_enables() failed.\n", __FUNCTION__);
-        mcp2515_close(dev);
-        return NULL;
-    }
-
-    // switch to normal operating mode
-    if (mcp2515_set_opmode(dev, MCP2515_OPMODE_NORMAL))
-    {
-        printf("%s: mcp2515_set_opmode(normal) failed.\n", __FUNCTION__);
-        mcp2515_close(dev);
-        return NULL;
-    }
-
-    return dev;
-}
-
-void mcp2515_close(mcp2515_context dev)
-{
-    assert(dev != NULL);
-
-    mcp2515_uninstall_isr(dev);
-
-    if (dev->spi)
-        mraa_spi_stop(dev->spi);
-
-    if (dev->gpio)
-        mraa_gpio_close(dev->gpio);
-
-    free(dev);
-}
-
-// bus read and write functions
-upm_result_t mcp2515_bus_read(const mcp2515_context dev, uint8_t cmd,
-                              uint8_t *args, unsigned int arglen,
-                              uint8_t *data, uint8_t len)
-{
-    int buflen = len + 1 + arglen;
-    uint8_t sbuf[buflen];
-
-    memset((void *)sbuf, 0, buflen);
-
-    int index = 0;
-    sbuf[index++] = cmd;
-
-    if (args && arglen)
-    {
-        for (unsigned int i=0; i<arglen; i++)
-            sbuf[index++] = args[i];
-    }
-
-    mcp2515_cs_on(dev);
-
-    if (mraa_spi_transfer_buf(dev->spi, sbuf, sbuf, buflen))
-    {
-        mcp2515_cs_off(dev);
-        printf("%s: mraa_spi_transfer_buf() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-    mcp2515_cs_off(dev);
-
-    // now copy it into user buffer
-    for (int i=0; i<len; i++)
-        data[i] = sbuf[i + 1 + arglen];
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t mcp2515_bus_write(const mcp2515_context dev, uint8_t cmd,
-                               uint8_t *data, uint8_t len)
-{
-    assert(dev != NULL);
-
-    uint8_t sbuf[len + 1];
-    memset((void *)sbuf, 0, len + 1);
-    sbuf[0] = cmd;
-
-    // copy in the data to write...
-    if (data && len)
-    {
-        for (int i=0; i<len; i++)
-            sbuf[i + 1] = data[i];
-    }
-
-    mcp2515_cs_on(dev);
-
-    if (mraa_spi_transfer_buf(dev->spi, sbuf, sbuf, len + 1))
-    {
-        mcp2515_cs_off(dev);
-        printf("%s: mraa_spi_transfer_buf() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-    mcp2515_cs_off(dev);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t mcp2515_write_reg(const mcp2515_context dev, uint8_t reg,
-                               uint8_t value)
-{
-    assert(dev != NULL);
-
-    uint8_t arg[2]; // reg addr, value
-
-    arg[0] = reg;
-    arg[1] = value;
-
-    return mcp2515_bus_write(dev, MCP2515_CMD_WRITE, arg, 2);
-}
-
-upm_result_t mcp2515_write_regs(const mcp2515_context dev, uint8_t reg,
-                                uint8_t *buffer, int len)
-{
-    assert(dev != NULL);
-    assert(buffer != NULL);
-
-    int writeLen = len + 1;
-    uint8_t arg[1+len]; // reg addr, data...
-
-    arg[0] = reg;
-
-    for (int i=0; i<len; i++)
-        arg[i+1] = buffer[i];
-
-    return mcp2515_bus_write(dev, MCP2515_CMD_WRITE, arg, writeLen);
-}
-
-upm_result_t mcp2515_read_reg(const mcp2515_context dev, uint8_t reg,
-                              uint8_t *value)
-{
-    assert(dev != NULL);
-
-    uint8_t arg = reg;
-
-    return mcp2515_bus_read(dev, MCP2515_CMD_READ, &arg, 1, value, 1);
-}
-
-upm_result_t mcp2515_reset(const mcp2515_context dev)
-{
-    assert(dev != NULL);
-
-    upm_result_t rv = mcp2515_bus_write(dev, MCP2515_CMD_RESET, NULL, 0);
-    upm_delay_ms(100);
-
-    return rv;
-}
-
-upm_result_t mcp2515_bit_modify(const mcp2515_context dev, uint8_t addr,
-                                uint8_t mask, uint8_t value)
-{
-    assert(dev != NULL);
-
-    // build the command and send it
-    uint8_t args[3]; // addr, mask, value
-    args[0] = addr;
-    args[1] = mask;
-    args[2] = value;
-
-    return mcp2515_bus_write(dev, MCP2515_CMD_BIT_MODIFY, args, 3);
-}
-
-upm_result_t mcp2515_set_opmode(const mcp2515_context dev,
-                                MCP2515_OPMODE_T opmode)
-{
-    assert(dev != NULL);
-
-    // make it so
-    upm_result_t rv =
-        mcp2515_bit_modify(dev, MCP2515_REG_CANCTRL,
-                           (_MCP2515_CANCTRL_REQOP_MASK
-                            << _MCP2515_CANCTRL_REQOP_SHIFT),
-                           (opmode
-                            << _MCP2515_CANCTRL_REQOP_SHIFT));
-
-    if (rv)
-    {
-        printf("%s: mcp2515_bit_modify() failed\n", __FUNCTION__);
-        return rv;
-    }
-
-    // now spin until the mode is set (there can be a delay if the
-    // chip is busy sending or receiving packets, or, secretly
-    // communicating with our alien overlords).
-    // We set an upper limit of 5 seconds before we decide to timeout.
-    const uint8_t shiftmask = (_MCP2515_CANSTAT_OPMODE_MASK
-                               << _MCP2515_CANSTAT_OPMODE_SHIFT);
-
-    bool done = false;
-    upm_clock_t clock = upm_clock_init();
-
-    do
-    {
-        uint8_t reg;
-
-        rv = mcp2515_read_reg(dev, MCP2515_REG_CANSTAT, &reg);
-        if (rv)
-        {
-            printf("%s: mcp2515_bus_read() failed\n", __FUNCTION__);
-            return rv;
-        }
-
-        if ((reg & shiftmask) == (opmode << _MCP2515_CANSTAT_OPMODE_SHIFT))
-            done = true;
-        else
-            upm_delay_ms(10);
-
-    } while (!done && (upm_elapsed_ms(&clock) < MCP2515_MAX_TIMEOUT));
-
-    if (!done)
-        return UPM_ERROR_TIMED_OUT;
-    else
-        return UPM_SUCCESS;
-}
-
-upm_result_t mcp2515_set_speed(const mcp2515_context dev,
-                               MCP2515_SPEED_T speed)
-{
-    assert(dev != NULL);
-
-    upm_result_t rv;
-
-    if ((rv = mcp2515_write_reg(dev, MCP2515_REG_CNF1,
-                                mcp2515_configs[speed].cnf1)))
-        return rv;
-
-    if ((rv = mcp2515_write_reg(dev, MCP2515_REG_CNF2,
-                                mcp2515_configs[speed].cnf2)))
-        return rv;
-
-    if ((rv = mcp2515_write_reg(dev, MCP2515_REG_CNF3,
-                                mcp2515_configs[speed].cnf3)))
-        return rv;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t mcp2515_load_tx_buffer(const mcp2515_context dev,
-                                    MCP2515_TX_BUFFER_T bufnum,
-                                    int id, bool ext, bool rtr,
-                                    uint8_t *payload, int len)
-{
-    assert(dev != NULL);
-
-    // The first thing to do is make sure that the tx buffer is
-    // actually available (ie: does not already contain a packet
-    // awaiting transmit).
-
-    if (!mcp2515_tx_buffer_is_free(dev, bufnum))
-    {
-        printf("%s: buffer is busy\n", __FUNCTION__);
-        return UPM_ERROR_NO_RESOURCES;
-    }
-
-    uint8_t cmd = 0;
-    switch (bufnum)
-    {
-    case MCP2515_TX_BUFFER0:
-        cmd = MCP2515_CMD_LOAD_TXBUF_TXB0SIDH;
-        break;
-
-    case MCP2515_TX_BUFFER1:
-        cmd = MCP2515_CMD_LOAD_TXBUF_TXB1SIDH;
-        break;
-
-    case MCP2515_TX_BUFFER2:
-        cmd = MCP2515_CMD_LOAD_TXBUF_TXB2SIDH;
-        break;
-
-    default:
-        printf("%s: invalid buffer specified\n", __FUNCTION__);
-        return UPM_ERROR_INVALID_PARAMETER;
-    }
-
-    // start preparing for the load
-    MCP2515_ID_T idBuf;
-    MCP2515_PKT_T packet;
-
-    memset(&packet, 0, sizeof(MCP2515_PKT_T));
-
-    // first add the id converted to the 4-byte id the device requires
-    // mask off all but the lower 29 bits
-    id &= 0x1fffffff;
-    mcp2515_int_to_id(dev, id, ext, false, &idBuf);
-
-    // copy in the [device]id bytes, then fill in the DLC reg.
-    packet.SIDH = idBuf.SIDH;
-    packet.SIDL = idBuf.SIDL;
-    packet.EID8 = idBuf.EID8;
-    packet.EID0 = idBuf.EID0;
-
-    // DLC register
-    if (len > MCP2515_MAX_PAYLOAD_DATA)
-        len = MCP2515_MAX_PAYLOAD_DATA;
-    if (len < 0)
-        len = 0;
-
-    packet.DLC = (len & _MCP2515_TXBDLC_MASK) << _MCP2515_TXBDLC_SHIFT;
-
-    if (rtr)
-        packet.DLC |= MCP2515_TXBDLC_RTR;
-
-    // now the payload
-    for (int i=0; i<len; i++)
-        packet.data[i+MCP2515_PKT_D0] = payload[i];
-
-    // load the buffer
-    if (mcp2515_bus_write(dev, cmd, packet.data, MCP2515_MAX_PKT_DATA))
-    {
-        printf("%s: mcp2515_bus_write() failed\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t mcp2515_transmit_buffer(const mcp2515_context dev,
-                                     MCP2515_TX_BUFFER_T bufnum,
-                                     bool wait)
-{
-    assert(dev != NULL);
-
-    uint8_t waitreg = 0;
-    uint8_t rtscmd = 0;
-    switch (bufnum)
-    {
-    case MCP2515_TX_BUFFER0:
-        waitreg = MCP2515_REG_TXB0CTRL;
-        rtscmd = MCP2515_CMD_RTS_BUFFER0;
-        break;
-
-    case MCP2515_TX_BUFFER1:
-        waitreg = MCP2515_REG_TXB1CTRL;
-        rtscmd = MCP2515_CMD_RTS_BUFFER1;
-        break;
-
-    case MCP2515_TX_BUFFER2:
-        waitreg = MCP2515_REG_TXB2CTRL;
-        rtscmd = MCP2515_CMD_RTS_BUFFER2;
-        break;
-
-    default:
-        return UPM_ERROR_INVALID_PARAMETER;
-    }
-
-    // now transmit the requested buffer
-    if (mcp2515_bus_write(dev, rtscmd, NULL, 0))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    // if we are not waiting for transmission to complete, we are done
-    // here.
-    if (!wait)
-        return UPM_SUCCESS;
-
-    // now spin with timeout waiting for it to be transmitted
-    upm_clock_t clock =  upm_clock_init();
-    bool done = false;
-
-    do
-    {
-        uint8_t txbctrl = 0;
-
-        if (mcp2515_read_reg(dev, waitreg, &txbctrl))
-            return UPM_ERROR_OPERATION_FAILED;
-
-        if (!(txbctrl & MCP2515_TXBCTRL_TXREQ))
-            done = true;
-
-        upm_delay_ms(1);
-    } while (!done && (upm_elapsed_ms(&clock) < MCP2515_MAX_TIMEOUT));
-
-    if (!done)
-        return UPM_ERROR_TIMED_OUT;
-    else
-        return UPM_SUCCESS;
-}
-
-bool mcp2515_tx_buffer_is_free(const mcp2515_context dev,
-                               MCP2515_TX_BUFFER_T bufnum)
-{
-    assert(dev != NULL);
-
-    uint8_t chkreg = 0;
-    switch (bufnum)
-    {
-    case MCP2515_TX_BUFFER0:
-        chkreg = MCP2515_REG_TXB0CTRL;
-        break;
-
-    case MCP2515_TX_BUFFER1:
-        chkreg = MCP2515_REG_TXB1CTRL;
-        break;
-
-    case MCP2515_TX_BUFFER2:
-        chkreg = MCP2515_REG_TXB2CTRL;
-        break;
-
-    default:
-        return false;
-    }
-
-    uint8_t txbctrl = 0;
-
-    if (mcp2515_read_reg(dev, chkreg, &txbctrl))
-        return false;
-
-    if (!(txbctrl & MCP2515_TXBCTRL_TXREQ))
-        return true;
-    else
-        return false;
-}
-
-MCP2515_TX_BUFFER_T mcp2515_find_free_tx_buffer(const mcp2515_context dev)
-{
-    assert(dev != NULL);
-
-    // check each of the tx buffers and return one if it's free.
-    if (mcp2515_tx_buffer_is_free(dev, MCP2515_TX_BUFFER0))
-        return MCP2515_TX_BUFFER0;
-
-    if (mcp2515_tx_buffer_is_free(dev, MCP2515_TX_BUFFER1))
-        return MCP2515_TX_BUFFER1;
-
-    if (mcp2515_tx_buffer_is_free(dev, MCP2515_TX_BUFFER2))
-        return MCP2515_TX_BUFFER2;
-
-    return MCP2515_TX_NO_BUFFERS;
-}
-
-// can only be set in CONFIG mode
-upm_result_t mcp2515_set_filter(const mcp2515_context dev,
-                                MCP2515_RX_FILTER_T filter, bool ext, int id)
-{
-    assert(dev != NULL);
-
-    MCP2515_ID_T idBuf;
-    mcp2515_int_to_id(dev, id, ext, true, &idBuf);
-
-    uint8_t reg = 0;
-
-    switch (filter)
-    {
-    case MCP2515_RX_FILTER0:
-        reg = MCP2515_REG_FILTER0;
-        break;
-
-    case MCP2515_RX_FILTER1:
-        reg = MCP2515_REG_FILTER1;
-        break;
-
-    case MCP2515_RX_FILTER2:
-        reg = MCP2515_REG_FILTER2;
-        break;
-
-    case MCP2515_RX_FILTER3:
-        reg = MCP2515_REG_FILTER3;
-        break;
-
-    case MCP2515_RX_FILTER4:
-        reg = MCP2515_REG_FILTER4;
-        break;
-
-    case MCP2515_RX_FILTER5:
-        reg = MCP2515_REG_FILTER5;
-        break;
-
-    default:
-        return UPM_ERROR_INVALID_PARAMETER;
-    }
-
-    return mcp2515_write_regs(dev, reg, idBuf.data, MCP2515_MAX_ID_BYTES);
-}
-
-// can only be set in CONFIG mode
-upm_result_t mcp2515_set_mask(const mcp2515_context dev,
-                              MCP2515_RX_MASK_T mask, bool ext, int id)
-{
-    assert(dev != NULL);
-
-    MCP2515_ID_T idBuf;
-    mcp2515_int_to_id(dev, id, ext, true, &idBuf);
-
-    uint8_t reg = 0;
-
-    switch (mask)
-    {
-    case MCP2515_RX_MASK0:
-        reg = MCP2515_REG_MASK0;
-        break;
-    case MCP2515_RX_MASK1:
-        reg = MCP2515_REG_MASK1;
-        break;
-    default:
-        return UPM_ERROR_INVALID_PARAMETER;
-    }
-
-    return mcp2515_write_regs(dev, reg, idBuf.data, MCP2515_MAX_ID_BYTES);
-}
-
-upm_result_t mcp2515_set_rx_buffer_mode(const mcp2515_context dev,
-                                        MCP2515_RX_BUFFER_T bufnum,
-                                        MCP2515_RXMODE_T rxm)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = 0;
-    uint8_t mask = 0, shift = 0;
-    switch (bufnum)
-    {
-    case MCP2515_RX_BUFFER0:
-        reg = MCP2515_REG_RXB0CTRL;
-        mask = _MCP2515_RXB0CTRL_RXMODE_MASK;
-        shift = _MCP2515_RXB0CTRL_RXMODE_SHIFT;
-        break;
-
-    case MCP2515_RX_BUFFER1:
-        reg = MCP2515_REG_RXB1CTRL;
-        mask = _MCP2515_RXB1CTRL_RXMODE_MASK;
-        shift = _MCP2515_RXB1CTRL_RXMODE_SHIFT;
-        break;
-
-    default:
-        return UPM_ERROR_INVALID_PARAMETER;
-    }
-
-    return mcp2515_bit_modify(dev, reg, mask << shift, rxm << shift);
-}
-
-upm_result_t mcp2515_set_tx_buffer_priority(const mcp2515_context dev,
-                                            MCP2515_TX_BUFFER_T bufnum,
-                                            MCP2515_TXP_T priority)
-{
-    assert(dev != NULL);
-
-    uint8_t reg = 0;
-    uint8_t mask = _MCP2515_TXBCTRL_TXP_MASK;
-    uint8_t shift = _MCP2515_TXBCTRL_TXP_SHIFT;
-    switch (bufnum)
-    {
-    case MCP2515_TX_BUFFER0:
-        reg = MCP2515_REG_TXB0CTRL;
-        break;
-
-    case MCP2515_TX_BUFFER1:
-        reg = MCP2515_REG_TXB1CTRL;
-        break;
-
-    case MCP2515_TX_BUFFER2:
-        reg = MCP2515_REG_TXB2CTRL;
-        break;
-
-    default:
-        printf("%s: invalid buffer specified\n", __FUNCTION__);
-        return UPM_ERROR_INVALID_PARAMETER;
-    }
-
-    return mcp2515_bit_modify(dev, reg, mask << shift, priority << shift);
-}
-
-MCP2515_RXMSG_T mcp2515_rx_status_msgs(const mcp2515_context dev)
-{
-    assert(dev != NULL);
-
-    uint8_t rx_status_byte;
-    if (mcp2515_bus_read(dev, MCP2515_CMD_RX_STATUS, NULL, 0,
-                               &rx_status_byte, 1))
-        return MCP2515_RXMSG_NONE;
-
-    MCP2515_RXMSG_T buffers =
-        (rx_status_byte &
-         (_MCP2515_RXSTATUS_RXMSG_MASK << _MCP2515_RXSTATUS_RXMSG_SHIFT))
-        >> _MCP2515_RXSTATUS_RXMSG_SHIFT;
-
-    return buffers;
-}
-
-MCP2515_MSGTYPE_T mcp2515_rx_status_msg_type(const mcp2515_context dev)
-{
-    assert(dev != NULL);
-
-    uint8_t rx_status_byte;
-    if (mcp2515_bus_read(dev, MCP2515_CMD_RX_STATUS, NULL, 0,
-                               &rx_status_byte, 1))
-        return MCP2515_MSGTYPE_STD; // not really, but....
-
-    MCP2515_MSGTYPE_T msgtype =
-        (rx_status_byte &
-         (_MCP2515_RXSTATUS_MSGTYPE_MASK << _MCP2515_RXSTATUS_MSGTYPE_SHIFT))
-        >> _MCP2515_RXSTATUS_MSGTYPE_SHIFT;
-
-    return msgtype;
-}
-
-MCP2515_FILTERMATCH_T mcp2515_rx_status_filtermatch(const mcp2515_context dev)
-{
-    assert(dev != NULL);
-
-    uint8_t rx_status_byte;
-    if (mcp2515_bus_read(dev, MCP2515_CMD_RX_STATUS, NULL, 0,
-                               &rx_status_byte, 1))
-        return MCP2515_FILTERMATCH_RXF0; // not really, but....
-
-    MCP2515_FILTERMATCH_T fm =
-        (rx_status_byte &
-         (_MCP2515_RXSTATUS_FILTERMATCH_MASK
-          << _MCP2515_RXSTATUS_FILTERMATCH_SHIFT))
-        >> _MCP2515_RXSTATUS_FILTERMATCH_SHIFT;
-
-    return fm;
-}
-
-upm_result_t mcp2515_get_rx_msg(const mcp2515_context dev,
-                                MCP2515_RX_BUFFER_T bufnum,
-                                MCP2515_MSG_T *msg)
-{
-    assert(dev != NULL);
-    assert(msg != NULL);
-
-    uint8_t cmd = 0;
-    uint8_t rxbctrl_reg = 0;
-    switch (bufnum)
-    {
-    case MCP2515_RX_BUFFER0:
-        cmd = MCP2515_CMD_READ_RXBUF_RXB0SIDH;
-        rxbctrl_reg = MCP2515_REG_RXB0CTRL;
-        break;
-
-    case MCP2515_RX_BUFFER1:
-        cmd = MCP2515_CMD_READ_RXBUF_RXB1SIDH;
-        rxbctrl_reg = MCP2515_REG_RXB1CTRL;
-        break;
-
-    default:
-        return UPM_ERROR_INVALID_PARAMETER;
-    }
-
-    // first see if we have a message waiting
-    MCP2515_RXMSG_T rxmsgs = mcp2515_rx_status_msgs(dev);
-    bool msgavail = false;
-    if (rxmsgs == MCP2515_RXMSG_BOTH)
-        msgavail = true;
-    else if (rxmsgs == MCP2515_RXMSG_RXB0 && bufnum == MCP2515_RX_BUFFER0)
-        msgavail = true;
-    else if (rxmsgs == MCP2515_RXMSG_RXB1 && bufnum == MCP2515_RX_BUFFER1)
-        msgavail = true;
-
-    // nope
-    if (!msgavail)
-        return UPM_ERROR_NO_RESOURCES;
-
-    // get the control reg
-    upm_result_t rv;
-    uint8_t rxbctrl;
-    if ((rv = mcp2515_read_reg(dev, rxbctrl_reg, &rxbctrl)))
-        return rv;
-
-    // go ahead and grab the message and fill in the details
-    memset(msg, 0, sizeof(MCP2515_MSG_T));
-    if ((rv = mcp2515_bus_read(dev, cmd, NULL, 0,
-                               msg->pkt.data, MCP2515_MAX_PKT_DATA)))
-    {
-        printf("mcp2515_bus_read failed\n");
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // if we are here, we got the packet, so decode and determine some
-    // things.
-
-    // id & ext
-    MCP2515_ID_T did;
-    did.SIDH = msg->pkt.SIDH;
-    did.SIDL = msg->pkt.SIDL;
-    did.EID8 = msg->pkt.EID8;
-    did.EID0 = msg->pkt.EID0;
-
-    msg->id = mcp2515_id_to_int(dev, &(msg->ext), &did);
-
-    // rtr
-    if (!msg->ext)
-    {
-        // The RTR flag bit is the same for both the RXB0CTRL and
-        // RXB1CTRL registers, so it's safe to just compare against
-        // the first regardless of the buffer we are interested in.
-        if (rxbctrl & MCP2515_RXB0CTRL_RXRTR)
-            msg->rtr = true;
-    }
-    else
-    {
-        // ext message stores rtr separately
-        if (msg->pkt.DLC & MCP2515_RXBDLC_RTR)
-            msg->rtr = true;
-    }
-
-    // filter num
-    if (bufnum == MCP2515_RX_BUFFER0)
-    {
-        if (rxbctrl & MCP2515_RXB0CTRL_FILHIT)
-            msg->filter_num = 1;
-        else
-            msg->filter_num = 0;
-
-    }
-    else
-    {
-        msg->filter_num =
-            (int)((rxbctrl &
-                   (_MCP2515_RXB1CTRL_FILHIT_MASK
-                    << _MCP2515_RXB1CTRL_FILHIT_SHIFT))
-                  >> _MCP2515_RXB1CTRL_FILHIT_SHIFT);
-    }
-
-    // now the payload length
-    msg->len = ((msg->pkt.DLC & (_MCP2515_RXBDLC_MASK << _MCP2515_RXBDLC_SHIFT))
-                >> _MCP2515_RXBDLC_SHIFT);
-
-
-    return UPM_SUCCESS;
-}
-
-void mcp2515_print_msg(const mcp2515_context dev, MCP2515_MSG_T *msg)
-{
-    assert(dev != NULL);
-    assert(msg != NULL);
-
-    // print it out
-    printf("id %08x ext %d rtr %d filt %d len %d\n",
-           msg->id, msg->ext, msg->rtr, msg->filter_num, msg->len);
-    printf("\tpayload: ");
-    for (int i=0; i<msg->len; i++)
-        printf("0x%02x ", msg->pkt.data[MCP2515_PKT_D0 + i]);
-    printf("\n");
-}
-
-upm_result_t mcp2515_abort_tx(const mcp2515_context dev,
-                              MCP2515_TX_BUFFER_T bufnum)
-{
-    assert(dev != NULL);
-
-    uint8_t reg;
-    switch (bufnum)
-    {
-    case MCP2515_TX_BUFFER0:
-        reg = MCP2515_REG_TXB0CTRL;
-        break;
-
-    case MCP2515_TX_BUFFER1:
-        reg = MCP2515_REG_TXB1CTRL;
-        break;
-
-    case MCP2515_TX_BUFFER2:
-        reg = MCP2515_REG_TXB2CTRL;
-        break;
-
-    default:
-        return UPM_ERROR_INVALID_PARAMETER;
-    }
-
-    // Clear the TXREQ bit.
-    return mcp2515_bit_modify(dev, reg, MCP2515_TXBCTRL_TXREQ, 0);
-}
-
-upm_result_t mcp2515_install_isr(const mcp2515_context dev, int pin,
-                                 void (*isr)(void *), void *arg)
-{
-    assert(dev != NULL);
-
-    mcp2515_uninstall_isr(dev);
-
-    if ( !(dev->intr = mraa_gpio_init(pin)) )
-    {
-        printf("%s: mraa_gpio_init failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    mraa_gpio_dir(dev->intr, MRAA_GPIO_IN);
-
-    // install our interrupt handler
-    mraa_gpio_isr(dev->intr, MRAA_GPIO_EDGE_FALLING,
-                  isr, arg);
-
-    return UPM_SUCCESS;
-}
-
-void mcp2515_uninstall_isr(const mcp2515_context dev)
-{
-    assert(dev != NULL);
-
-    if (!dev->intr)
-        return;
-
-    mraa_gpio_isr_exit(dev->intr);
-    mraa_gpio_close(dev->intr);
-    dev->intr = NULL;
-}
-
-upm_result_t mcp2515_set_intr_enables(const mcp2515_context dev,
-                                      uint8_t enables)
-{
-    assert(dev != NULL);
-
-    return mcp2515_write_reg(dev, MCP2515_REG_CANINTE, enables);
-}
-
-upm_result_t mcp2515_get_intr_flags(const mcp2515_context dev, uint8_t *flags)
-{
-    assert(dev != NULL);
-
-    return mcp2515_read_reg(dev, MCP2515_REG_CANINTF, flags);
-}
-
-upm_result_t mcp2515_set_intr_flags(const mcp2515_context dev, uint8_t flags)
-{
-    assert(dev != NULL);
-
-    return mcp2515_bit_modify(dev, MCP2515_REG_CANINTF, flags, 0xff);
-}
-
-upm_result_t mcp2515_clear_intr_flags(const mcp2515_context dev, uint8_t flags)
-{
-    assert(dev != NULL);
-
-    return mcp2515_bit_modify(dev, MCP2515_REG_CANINTF, flags, 0);
-}
-
-upm_result_t mcp2515_get_error_flags(const mcp2515_context dev, uint8_t *flags)
-{
-    assert(dev != NULL);
-
-    return mcp2515_read_reg(dev, MCP2515_REG_EFLG, flags);
-}
-
-upm_result_t mcp2515_clear_error_flags(const mcp2515_context dev,
-                                       uint8_t flags)
-{
-    assert(dev != NULL);
-
-    return mcp2515_bit_modify(dev, MCP2515_REG_EFLG, flags, 0);
-}
diff --git a/src/mcp2515/mcp2515.cxx b/src/mcp2515/mcp2515.cxx
deleted file mode 100644
index d797dcf..0000000
--- a/src/mcp2515/mcp2515.cxx
+++ /dev/null
@@ -1,253 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <iostream>
-#include <stdexcept>
-#include <string>
-
-#include "mcp2515.hpp"
-
-using namespace upm;
-using namespace std;
-
-MCP2515::MCP2515(int bus, int csPin) :
-    m_mcp2515(mcp2515_init(bus, csPin))
-{
-    if (!m_mcp2515)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": mcp2515_init() failed");
-}
-
-MCP2515::~MCP2515()
-{
-    mcp2515_close(m_mcp2515);
-}
-
-void MCP2515::reset()
-{
-    if (mcp2515_reset(m_mcp2515))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": mcp2515_reset() failed");
-}
-
-void MCP2515::setOpmode(MCP2515_OPMODE_T opmode)
-{
-    if (mcp2515_set_opmode(m_mcp2515, opmode))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": mcp2515_set_opmode() failed");
-}
-
-void MCP2515::setSpeed(MCP2515_SPEED_T speed)
-{
-    if (mcp2515_set_speed(m_mcp2515, speed))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": mcp2515_set_speed() failed");
-}
-
-void MCP2515::loadTXBuffer(MCP2515_TX_BUFFER_T bufnum, int id, bool ext,
-                  bool rtr, std::string payload)
-{
-    if (mcp2515_load_tx_buffer(m_mcp2515, bufnum, id, ext, rtr,
-                               (uint8_t *)payload.data(), payload.size()))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": mcp2515_load_tx_buffer() failed");
-
-}
-
-void MCP2515::transmitBuffer(MCP2515_TX_BUFFER_T bufnum, bool wait)
-{
-    if (mcp2515_transmit_buffer(m_mcp2515, bufnum, wait))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": mcp2515_transmit_buffer() failed");
-}
-
-bool MCP2515::isTXBufferFree(MCP2515_TX_BUFFER_T bufnum)
-{
-    return mcp2515_tx_buffer_is_free(m_mcp2515, bufnum);
-}
-
-MCP2515_TX_BUFFER_T MCP2515::findFreeTXBuffer()
-{
-    return mcp2515_find_free_tx_buffer(m_mcp2515);
-}
-
-void MCP2515::setTXBufferPriority(MCP2515_TX_BUFFER_T bufnum,
-                                  MCP2515_TXP_T priority)
-{
-    if (mcp2515_set_tx_buffer_priority(m_mcp2515, bufnum, priority))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": mcp2515_set_tx_buffer_priority() failed");
-}
-
-void MCP2515::abortTX(MCP2515_TX_BUFFER_T bufnum)
-{
-    if (mcp2515_abort_tx(m_mcp2515, bufnum))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": mcp2515_abort_tx() failed");
-}
-
-void MCP2515::setRXBufferMode(MCP2515_RX_BUFFER_T bufnum, MCP2515_RXMODE_T rxm)
-{
-    if (mcp2515_set_rx_buffer_mode(m_mcp2515, bufnum, rxm))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": mcp2515_set_rx_buffer_mode() failed");
-}
-
-MCP2515_RXMSG_T MCP2515::rxStatusMsgs()
-{
-    return mcp2515_rx_status_msgs(m_mcp2515);
-}
-
-MCP2515_MSGTYPE_T MCP2515::rxStatusMsgType()
-{
-    return mcp2515_rx_status_msg_type(m_mcp2515);
-}
-
-MCP2515_FILTERMATCH_T MCP2515::rxStatusFiltermatch()
-{
-    return mcp2515_rx_status_filtermatch(m_mcp2515);
-}
-
-upm_result_t MCP2515::getRXMsg(MCP2515_RX_BUFFER_T bufnum)
-{
-    return mcp2515_get_rx_msg(m_mcp2515, bufnum, &m_message);
-}
-
-void MCP2515::printMsg()
-{
-    mcp2515_print_msg(m_mcp2515, &m_message);
-}
-
-void MCP2515::installISR(int pin, void (*isr)(void *), void *arg)
-{
-    if (mcp2515_install_isr(m_mcp2515, pin, isr, arg))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": mcp2515_install_isr() failed");
-}
-
-void MCP2515::uninstallISR()
-{
-    mcp2515_uninstall_isr(m_mcp2515);
-}
-
-void MCP2515::setIntrEnables(uint8_t enables)
-{
-    if (mcp2515_set_intr_enables(m_mcp2515, enables))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": mcp2515_set_intr_enables() failed");
-}
-
-uint8_t MCP2515::getIntrFlags()
-{
-    uint8_t flags = 0;
-    if (mcp2515_get_intr_flags(m_mcp2515, &flags))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": mcp2515_get_intr_flags() failed");
-    return flags;
-}
-
-void MCP2515::setIntrFlags(uint8_t flags)
-{
-    if (mcp2515_set_intr_flags(m_mcp2515, flags))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": mcp2515_set_intr_flags() failed");
-}
-
-void MCP2515::clearIntrFlags(uint8_t flags)
-{
-    if (mcp2515_clear_intr_flags(m_mcp2515, flags))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": mcp2515_clear_intr_flags() failed");
-}
-
-uint8_t MCP2515::getErrorFlags()
-{
-    uint8_t flags = 0;
-    if (mcp2515_get_error_flags(m_mcp2515, &flags))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": mcp2515_get_error_flags() failed");
-    return flags;
-}
-
-void MCP2515::clearErrorFlags(uint8_t flags)
-{
-    if (mcp2515_clear_error_flags(m_mcp2515, flags))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": mcp2515_clear_error_flags() failed");
-}
-
-void MCP2515::setFilter(MCP2515_RX_FILTER_T filter, bool ext, int id)
-{
-    if (mcp2515_set_filter(m_mcp2515, filter, ext, id))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": mcp2515_set_filter() failed");
-}
-
-void MCP2515::setMask(MCP2515_RX_MASK_T mask, bool ext, int id)
-{
-    if (mcp2515_set_mask(m_mcp2515, mask, ext, id))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": mcp2515_set_mask() failed");
-}
-
-string MCP2515::busRead(uint8_t cmd, std::string args, int datalen)
-{
-    uint8_t data[datalen];
-
-    if (mcp2515_bus_read(m_mcp2515, cmd, (uint8_t *)args.data(), args.size(),
-                         data, datalen))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": mcp2515_bus_read() failed");
-    return string((char *)data, datalen);
-}
-
-void MCP2515::busWrite(uint8_t cmd, std::string data)
-{
-    if (mcp2515_bus_write(m_mcp2515, cmd, (uint8_t *)data.data(), data.size()))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": mcp2515_bus_write() failed");
-}
-
-void MCP2515::writeReg(uint8_t reg, uint8_t value)
-{
-    if (mcp2515_write_reg(m_mcp2515, reg, value))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": mcp2515_write_reg() failed");
-}
-
-void MCP2515::writeRegs(uint8_t reg, std::string buffer)
-{
-    if (mcp2515_write_regs(m_mcp2515, reg, (uint8_t *)buffer.data(),
-                           buffer.size()))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": mcp2515_write_regs() failed");
-}
-
-void MCP2515::bitModify(uint8_t addr, uint8_t mask, uint8_t value)
-{
-    if (mcp2515_bit_modify(m_mcp2515, addr, mask, value))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": mcp2515_bit_modify() failed");
-}
diff --git a/src/mcp2515/mcp2515.h b/src/mcp2515/mcp2515.h
deleted file mode 100644
index 1d9644e..0000000
--- a/src/mcp2515/mcp2515.h
+++ /dev/null
@@ -1,525 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <stdint.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <upm.h>
-
-#include <mraa/i2c.h>
-#include <mraa/spi.h>
-#include <mraa/gpio.h>
-
-#include "mcp2515_regs.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    /**
-     * @file mcp2515
-     * @library mcp2515
-     * @brief C API for the MCP2515 CAN bus controller
-     *
-     * @include mcp2515.c
-     * @include mcp2515_regs.c
-     */
-
-    /**
-     * Device context
-     */
-    typedef struct _mcp2515_context {
-        mraa_spi_context        spi;
-
-        // CS pin, if we are using one
-        mraa_gpio_context       gpio;
-
-        // interrupt, if enabled
-        mraa_gpio_context       intr;
-    } *mcp2515_context;
-
-    /**
-     * MCP2515 initializer
-     *
-     * @param bus spi bus to use
-     * @param cs_pin The GPIO pin to use for Chip Select (CS).  Pass
-     * pass -1 if your CS is handled automatically by your SPI
-     * implementation (Edison).
-     * @return an initialized device context on success, NULL on error.
-     */
-    mcp2515_context mcp2515_init(int bus, int cs_pin);
-
-    /**
-     * MCP2515 close
-     *
-     * @param dev Device context.
-     */
-    void mcp2515_close(mcp2515_context dev);
-
-    /**
-     * Reset the device.
-     *
-     * @param dev Device context.
-     * @return UPM result.
-     */
-    upm_result_t mcp2515_reset(const mcp2515_context dev);
-
-    /**
-     * Set the operating mode of the device.  After initialization
-     * (mcp2515_init()), the device mode will be set to NORMAL.  Note
-     * that some operations require the device to be placed into CONFIG
-     * mode.  This function will wait until the selected mode has been
-     * entered.
-     *
-     * @param dev Device context.
-     * @param opmode One of the MCP2515_OPMODE_T values.
-     * @return UPM result.
-     */
-    upm_result_t mcp2515_set_opmode(const mcp2515_context dev,
-                                    MCP2515_OPMODE_T opmode);
-
-    /**
-     * Set the baud rate of the CAN bus.  All devices on a given CAN
-     * bus must be operating at the correct speed.  The device must be
-     * switched into CONFIG mode bofore this function will have any
-     * effect.  On initialization (mcp2515_init()), the default CAN
-     * bus speed will be set to 50Kbps.
-     *
-     * @param dev Device context.
-     * @param speed One of the MCP2515_SPEED_T values.
-     * @return UPM result.
-     */
-    upm_result_t mcp2515_set_speed(const mcp2515_context dev,
-                                   MCP2515_SPEED_T speed);
-
-    /**
-     * Load a transmit buffer with the id, payload, and other
-     * information.  This function does not actually transmit the
-     * buffer.  There are 3 TX buffers available.  The buffer must be
-     * free (ie: not awaiting transmit) before it can be loaded.  Once
-     * a TX buffer has been successfully loaded, it can be transmitted
-     * with the mcp2515_transmit_buffer() function.
-     *
-     * @param dev Device context.
-     * @param bufnum The buffer to load.  One of the
-     * MCP2515_TX_BUFFER_T values.
-     * @param id The integer representation of the CAN bus ID.
-     * @param ext True if the ID is an extended identifier, false otherwise.
-     * @param rtr True if this is a Remote Transfer Request, false otherwise.
-     * @param payload A pointer to an array of bytes that make up the
-     * payload to send.
-     * @param len The length of the payload.  The length is limited to
-     * 8.
-     * @return UPM result.
-     */
-    upm_result_t mcp2515_load_tx_buffer(const mcp2515_context dev,
-                                        MCP2515_TX_BUFFER_T bufnum,
-                                        int id, bool ext, bool rtr,
-                                        uint8_t *payload, int len);
-
-    /**
-     * Transmit a buffer already loaded by mcp2515_load_tx_buffer().
-     *
-     * @param dev Device context.
-     * @param bufnum The buffer to transmit.  One of the
-     * MCP2515_TX_BUFFER_T values.
-     * @param wait True if the function should wait until transmission
-     * is complete before returning, false otherwise.
-     * @return UPM result.
-     */
-    upm_result_t mcp2515_transmit_buffer(const mcp2515_context dev,
-                                         MCP2515_TX_BUFFER_T bufnum,
-                                         bool wait);
-
-    /**
-     * Determine whether a TX buffer is available for use or not. A TX
-     * buffer is unavailable if a transmit request is pending on it,
-     * but transmission has not yet completed.
-     *
-     * @param dev Device context.
-     * @param bufnum The buffer to check. One of the
-     * MCP2515_TX_BUFFER_T values.
-     * @return True if the buffer is availabe, false otherwise.
-     */
-    bool mcp2515_tx_buffer_is_free(const mcp2515_context dev,
-                                   MCP2515_TX_BUFFER_T bufnum);
-
-    /**
-     * Find a free TX buffer and return it.
-     *
-     * @param dev Device context.
-     * @return One of the MCP2515_TX_BUFFER_T values.  If no buffers
-     * are available, MCP2515_TX_NO_BUFFERS will be returned.
-     */
-    MCP2515_TX_BUFFER_T mcp2515_find_free_tx_buffer(const mcp2515_context dev);
-
-    /**
-     * Set the transmit priority of a TX buffer.  Higher priority
-     * buffers are always transmitted before lower priority buffers.
-     * This function can be called on a buffer at any time prior to
-     * actual transmission.
-     *
-     * @param dev Device context.
-     * @param bufnum The buffer to set priority for.  One of the
-     * MCP2515_TX_BUFFER_T values.
-     * @param priority The priority to set for the buffer.  One of the
-     * MCP2515_TXP_T values.
-     * @return UPM result.
-     */
-    upm_result_t mcp2515_set_tx_buffer_priority(const mcp2515_context dev,
-                                                MCP2515_TX_BUFFER_T bufnum,
-                                                MCP2515_TXP_T priority);
-
-    /**
-     * Abort a transmission that has been queued, but not yet
-     * completed.  This will also free up the TX buffer for future
-     * use.  Note, if you abort a transmission, but transmission has
-     * already started, this call will have no effect, and the buffer
-     * will complete transmission.
-     *
-     * @param dev Device context.
-     * @param bufnum The buffer to abort.  One of the
-     * MCP2515_TX_BUFFER_T values.
-     * @return UPM result.
-     */
-    upm_result_t mcp2515_abort_tx(const mcp2515_context dev,
-                                  MCP2515_TX_BUFFER_T bufnum);
-
-    /**
-     * Set the mode for an RX buffer.  The mode specifies, at a high
-     * level, what packets should be captured from the bus and placed
-     * into an RX buffer.  See the datasheet for details, but the
-     * default, MCP2515_RXMODE_ANY_FILTER, should be sufficient in
-     * most cases.  It is also possible to use this to restrict the
-     * types of CAN ids accepted (extended only, standard only) as
-     * well as a debug ANY_NOFILTER mode.
-     *
-     * @param dev Device context.
-     * @param bufnum The buffer to set the mode for.  One of the
-     * MCP2515_RX_BUFFER_T values.
-     * @param rxm The mode to set.  One of the MCP2515_RXMODE_T values.
-     * @return UPM result.
-     */
-    upm_result_t mcp2515_set_rx_buffer_mode(const mcp2515_context dev,
-                                            MCP2515_RX_BUFFER_T bufnum,
-                                            MCP2515_RXMODE_T rxm);
-
-    /**
-     * Return a bitmask indicating which of the 2 RX buffers have
-     * packets waiting in them.  This can be 0 (no packets), 1(RXB0),
-     * 2(RXB1), or 3 (RXB0 and RXB1).  This information is retrieved
-     * using the MCP2515_CMD_RX_STATUS command.
-     *
-     * @param dev Device context.
-     * @return A bitmask indicating which RX buffers (if any) have
-     * packets in them.  One of the MCP2515_RXMSG_T values.
-     */
-    MCP2515_RXMSG_T mcp2515_rx_status_msgs(const mcp2515_context dev);
-
-    /**
-     * Return the message type present in one of the RX buffers.  RXB0
-     * has the highest priority, so if both RX buffers are full, this
-     * function will only return data for the packet in RXB0.  This
-     * information is retrieved using the MCP2515_CMD_RX_STATUS
-     * command.
-     *
-     * @param dev Device context.
-     * @return One of the MCP2515_MSGTYPE_T values.
-     */
-    MCP2515_MSGTYPE_T mcp2515_rx_status_msg_type(const mcp2515_context dev);
-
-    /**
-     * Return the filter that matched an RX buffer.  RXB0 has the
-     * highest priority, so if both RX buffers are full, this function
-     * will only return data for the packet in RXB0.  This information
-     * is retrieved using the MCP2515_CMD_RX_STATUS command.
-     *
-     * @param dev Device context.
-     * @return One of the MCP2515_FILTERMATCH_T values.
-     */
-    MCP2515_FILTERMATCH_T mcp2515_rx_status_filtermatch(const mcp2515_context dev);
-
-    /**
-     * This function retrieves a message from the specified RX buffer.
-     * The message (MCP2515_MSG_T) contains all of the data in the
-     * packet, including id, rtr, ext, payload and payload length.  In
-     * addition, after retrieving the message, the RX buffer is freed
-     * to receive further data from the CAN bus.
-     *
-     * @param dev Device context.
-     * @param bufnum The buffer to retrieve.  One of the
-     * MCP2515_RX_BUFFER_T values.
-     * @param msg A pointer to a MCP2515_MSG_T, which will be filled
-     * with the decoded contents of the RX buffer.
-     * @return UPM result.
-     */
-    upm_result_t mcp2515_get_rx_msg(const mcp2515_context dev,
-                                    MCP2515_RX_BUFFER_T bufnum,
-                                    MCP2515_MSG_T *msg);
-
-    /**
-     * This is a utility function that accepts a MCP2515_MSG_T and
-     * prints out it's decoded contents.  This is of primary
-     * importance for debugging, and to simplify the examples
-     * somewhat.
-     *
-     * The output will look similar to:
-     *
-     * id 00000000 ext 0 rtr 0 filt 0 len 8
-     *          payload: 0xc8 0x01 0x02 0x03 0x04 0x05 0x06 0x07
-     *
-     * @param dev Device context.
-     * @param msg A pointer to a MCP2515_MSG_T containing the data to
-     * be printed out.
-     */
-    void mcp2515_print_msg(const mcp2515_context dev, MCP2515_MSG_T *msg);
-
-    /**
-     * Installs an interrupt service routine (ISR) to be called when
-     * an interrupt occurs.
-     *
-     * @param dev Device context.
-     * @param pin GPIO pin to use as the interrupt pin.
-     * @param isr Pointer to a function to be called on interrupt.
-     * @param arg Pointer to an object to be supplied as an
-     * argument to the ISR.
-     * @return UPM result.
-     */
-    upm_result_t mcp2515_install_isr(const mcp2515_context dev, int pin,
-                                     void (*isr)(void *), void *arg);
-
-    /**
-     * Uninstalls the previously installed ISR
-     *
-     * @param dev Device context.
-     */
-    void mcp2515_uninstall_isr(const mcp2515_context dev);
-
-    /**
-     * Set the interrupt enables register.
-     *
-     * @param dev Device context.
-     * @param enables A bitmask of interrupts to enable from
-     * MCP2515_CANINT_BITS_T.
-     * @return UPM result.
-     */
-    upm_result_t mcp2515_set_intr_enables(const mcp2515_context dev,
-                                          uint8_t enables);
-
-    /**
-     * Retrieve the interrupt flags register.
-     *
-     * @param dev Device context.
-     * @param flags A pointer to a bitmask that will be filled with
-     * values from MCP2515_CANINT_BITS_T, indicating which interrupt
-     * flags are set.
-     * @return UPM result.
-     */
-    upm_result_t mcp2515_get_intr_flags(const mcp2515_context dev,
-                                        uint8_t *flags);
-
-    /**
-     * This function allows you to set specific interrupt flags.  If
-     * the corresponding interrupt enable is set, an interrupt will be
-     * generated.
-     *
-     * @param dev Device context.
-     * @param flags A bitmask of interrupt flags to set, from
-     * MCP2515_CANINT_BITS_T values.
-     * @return UPM result.
-     */
-    upm_result_t mcp2515_set_intr_flags(const mcp2515_context dev,
-                                        uint8_t flags);
-
-    /**
-     * This function allows you to clear specific interrupt flags.
-     * See the datasheet.  Some flags cannot be cleared until the
-     * underlying cause has been corrected.
-     *
-     * @param dev Device context.
-     * @param flags A bitmask of interrupt flags to clear, from
-     * MCP2515_CANINT_BITS_T values.
-     * @return UPM result.
-     */
-    upm_result_t mcp2515_clear_intr_flags(const mcp2515_context dev,
-                                          uint8_t flags);
-
-    /**
-     * Retrieve the error flags register
-     *
-     * @param dev Device context.
-     * @param flags A pointer to a uint8_t that will hold the flags
-     * with values from MCP2515_EFLG_BITS_T.
-     * @return UPM result.
-     */
-    upm_result_t mcp2515_get_error_flags(const mcp2515_context dev,
-                                         uint8_t *flags);
-
-    /**
-     * Clear error flags.  Note, some flags cannot be cleared
-     * until the underlying issues is resolved.
-     *
-     * @param dev Device context.
-     * @param flags A bitmask of values from MCP2515_EFLG_BITS_T
-     * specifying the flags to clear.
-     * @return UPM result.
-     */
-    upm_result_t mcp2515_clear_error_flags(const mcp2515_context dev,
-                                           uint8_t flags);
-
-    /**
-     * This function allows you to set one of the 6 RX filters
-     * available.  Filters 0 and 1 are for RXB0 only, while filters
-     * 2-5 are for RXB1.  See the datasheet for details on how these
-     * filters (along with the masks) are used to select candidate CAN
-     * bus data for retrieval from the CAN bus.
-     *
-     * These can only be set when the device is in CONFIG mode.
-     *
-     * @param dev Device context.
-     * @param filter One of the 6 MCP2515_RX_FILTER_T values.
-     * @param ext True if the id is extended, false for standard.
-     * @param id Integer representation of a CAN bus ID.
-     * @return UPM result.
-     */
-    upm_result_t mcp2515_set_filter(const mcp2515_context dev,
-                                    MCP2515_RX_FILTER_T filter, bool ext,
-                                    int id);
-
-    /**
-     * This function allows you to set one of the 2 RX masks.  Mask 0
-     * is for RXB0, mask 1 is for RXB1.  The masks specify which bits
-     * in the filters are used for matching CAN bus data.  See the
-     * datasheet for details on how these masks (along with the
-     * filters) are used to select candidate CAN bus data for retrieval
-     * from the CAN bus.
-     *
-     * These can only be set when the device is in CONFIG mode.
-     *
-     * @param dev Device context.
-     * @param mask One of the 2 MCP2515_RX_MASK_T values.
-     * @param ext True if the id is extended, false for standard.
-     * @param id Integer representation of a CAN bus ID.
-     * @return UPM result.
-     */
-    upm_result_t mcp2515_set_mask(const mcp2515_context dev,
-                                  MCP2515_RX_MASK_T mask, bool ext, int id);
-
-    /**
-     * Perform a bus read.  This function is exposed here for those
-     * users wishing to perform their own low level accesses.  This is
-     * a low level function, and should not be used unless you know
-     * what you are doing.
-     *
-     * @param dev Device context.
-     * @param cmd The command to send.
-     * @param args An array of arguments, or NULL.
-     * @param arglen The number of args, or 0.
-     * @param data A pointer to a buffer in which data will be read into.
-     * @param len The number of bytes to read.
-     * @return UPM result.
-     */
-    upm_result_t mcp2515_bus_read(const mcp2515_context dev, uint8_t cmd,
-                                  uint8_t *args, unsigned int arglen,
-                                  uint8_t *data, uint8_t len);
-
-    /**
-     * Perform a bus write.  This function is exposed here for those
-     * users wishing to perform their own low level accesses.  This is
-     * a low level function, and should not be used unless you know
-     * what you are doing.
-     *
-     * @param dev Device context
-     * @param cmd The command to send.
-     * @param data A pointer to a buffer containing data to write.
-     * @param len The number of bytes to write.
-     * @return UPM Status
-     */
-    upm_result_t mcp2515_bus_write(const mcp2515_context dev, uint8_t cmd,
-                                   uint8_t *data, uint8_t len);
-
-    /**
-     * Write to a specific register.  This function is exposed here
-     * for those users wishing to perform their own low level
-     * accesses.  This is a low level function, and should not be used
-     * unless you know what you are doing.
-     *
-     * @param dev Device context
-     * @param reg The register to write to.
-     * @param value The byte to write.
-     * @return UPM Status
-     */
-    upm_result_t mcp2515_write_reg(const mcp2515_context dev, uint8_t reg,
-                                   uint8_t value);
-
-    /**
-     * Write to multiple consecutive registers.  This function is
-     * exposed here for those users wishing to perform their own low
-     * level accesses.  This is a low level function, and should not
-     * be used unless you know what you are doing.
-     *
-     * @param dev Device context
-     * @param reg The register to start writing to.
-     * @param buffer A pointer to an array of bytes to write.
-     * @param len The number of bytes to write.
-     * @return UPM Status
-     */
-    upm_result_t mcp2515_write_regs(const mcp2515_context dev, uint8_t reg,
-                                    uint8_t *buffer, int len);
-
-    /**
-     * Read a register.  This function is exposed here for those users
-     * wishing to perform their own low level accesses.  This is a low
-     * level function, and should not be used unless you know what you
-     * are doing.
-     *
-     * @param dev Device context
-     * @param reg The register to read.
-     * @param buffer A pointer to a a byte where the value will be placed.
-     * @return UPM Status
-     */
-    upm_result_t mcp2515_read_reg(const mcp2515_context dev, uint8_t reg,
-                                  uint8_t *value);
-
-    /**
-     * Perform a bit modify operation on a register.  Only certain
-     * registers support this method of access - check the datasheet.
-     * This function is exposed here for those users wishing to
-     * perform their own low level accesses.  This is a low level
-     * function, and should not be used unless you know what you are
-     * doing.
-     *
-     * @param dev Device context
-     * @param addr The address of the register to access.
-     * @param mask A bitmask used to mask off value bits.
-     * @param value The value to write (bits masked by mask).
-     * @return UPM Status
-     */
-    upm_result_t mcp2515_bit_modify(const mcp2515_context dev, uint8_t addr,
-                                    uint8_t mask, uint8_t value);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/mcp2515/mcp2515.hpp b/src/mcp2515/mcp2515.hpp
deleted file mode 100644
index 81e07ad..0000000
--- a/src/mcp2515/mcp2515.hpp
+++ /dev/null
@@ -1,517 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-
-#include "mcp2515.h"
-
-namespace upm {
-
-    /**
-     * @brief MCP2515 CAN Bus Controller
-     * @defgroup mcp2515 libupm-mcp2515
-     * @ingroup spi gpio
-     */
-
-    /**
-     * @library mcp2515
-     * @sensor mcp2515
-     * @comname CAN Bus Controller
-     * @man seeed
-     * @con spi gpio
-     * @web https://www.seeedstudio.com/CANBUS-Shield-p-2256.html
-     *
-     * @brief API for the MCP2515 CAN bus controller
-     *
-     * The MCP2515 is a stand-alone CAN controller developed to
-     * simplify applications that require interfacing with a CAN bus.
-     *
-     * This driver was developed using the Grove CAN bus shield
-     * version 1.2.
-     *
-     * An example using the loopback mode.
-     * @snippet mcp2515.cxx Interesting
-     * A simple transmit and receive example.
-     * @snippet mcp2515-txrx.cxx Interesting
-     */
-    class MCP2515 {
-    public:
-
-        /**
-         * MCP2515 constructor.
-         *
-         * @param bus spi bus to use
-         * @param csPin The GPIO pin to use for Chip Select (CS).  Pass
-         * pass -1 if your CS is handled automatically by your SPI
-         * implementation (Edison).
-         */
-        MCP2515(int bus, int csPin);
-
-        /**
-         * MCP2515 Destructor
-         */
-        ~MCP2515();
-
-        /**
-         * Reset the device.
-         *
-         */
-        void reset();
-
-        /**
-         * Set the operating mode of the device.  After initialization,
-         * the device mode will be set to NORMAL.  Note that some
-         * operations require the device to be placed into CONFIG mode.
-         * This function will wait until the selected mode has been
-         * entered.
-         *
-         * @param opmode One of the MCP2515_OPMODE_T values.
-         */
-        void setOpmode(MCP2515_OPMODE_T opmode);
-
-        /**
-         * Set the baud rate of the CAN bus.  All devices on a given
-         * CAN bus must be operating at the correct speed.  The device
-         * must be switched into CONFIG mode bofore this function will
-         * have any effect.  On initialization, the default CAN bus
-         * speed will be set to 50Kbps.
-         *
-         * @param speed One of the MCP2515_SPEED_T values.
-         */
-        void setSpeed(MCP2515_SPEED_T speed);
-
-        /**
-         * Load a transmit buffer with the id, payload, and other
-         * information.  This function does not actually transmit the
-         * buffer.  There are 3 TX buffers available.  The buffer must be
-         * free (ie: not awaiting transmit) before it can be loaded.  Once
-         * a TX buffer has been successfully loaded, it can be transmitted
-         * with the TransmitBuffer() method.
-         *
-         * @param bufnum The buffer to load.  One of the
-         * MCP2515_TX_BUFFER_T values.
-         * @param id The integer representation of the CAN bus ID.
-         * @param ext True if the ID is an extended identifier, false otherwise.
-         * @param rtr True if this is a Remote Transfer Request, false
-         * otherwise.
-         * @param payload A string containing the payload bytes.
-         * Maximum length is 8.
-         */
-        void loadTXBuffer(MCP2515_TX_BUFFER_T bufnum,
-                          int id, bool ext, bool rtr,
-                          std::string payload);
-
-        /**
-         * Transmit a buffer already loaded by loadTXBuffer().
-         *
-         * @param bufnum The buffer to transmit.  One of the
-         * MCP2515_TX_BUFFER_T values.
-         * @param wait True if the function should wait until transmission
-         * is complete before returning, false otherwise.
-         */
-        void transmitBuffer(MCP2515_TX_BUFFER_T bufnum, bool wait);
-
-        /**
-         * Determine whether a TX buffer is available for use or not. A TX
-         * buffer is unavailable if a transmit request is pending on it,
-         * but transmission has not yet completed.
-         *
-         * @param bufnum The buffer to check. One of the
-         * MCP2515_TX_BUFFER_T values.
-         * @return True if the buffer is availabe, false otherwise.
-         */
-        bool isTXBufferFree(MCP2515_TX_BUFFER_T bufnum);
-
-        /**
-         * Find a free TX buffer and return it.
-         *
-         * @return One of the MCP2515_TX_BUFFER_T values.  If no buffers
-         * are available, MCP2515_TX_NO_BUFFERS will be returned.
-         */
-        MCP2515_TX_BUFFER_T findFreeTXBuffer();
-
-        /**
-         * Set the transmit priority of a TX buffer.  Higher priority
-         * buffers are always transmitted before lower priority buffers.
-         * This function can be called on a buffer at any time prior to
-         * actual transmission.
-         *
-         * @param bufnum The buffer to set priority for.  One of the
-         * MCP2515_TX_BUFFER_T values.
-         * @param priority The priority to set for the buffer.  One of the
-         * MCP2515_TXP_T values.
-         */
-        void setTXBufferPriority(MCP2515_TX_BUFFER_T bufnum,
-                                 MCP2515_TXP_T priority);
-
-        /**
-         * Abort a transmission that has been queued, but not yet
-         * completed.  This will also free up the TX buffer for future
-         * use.  Note, if you abort a transmission, but transmission has
-         * already started, this call will have no effect, and the buffer
-         * will complete transmission.
-         *
-         * @param bufnum The buffer to abort.  One of the
-         * MCP2515_TX_BUFFER_T values.
-         */
-        void abortTX(MCP2515_TX_BUFFER_T bufnum);
-
-        /**
-         * Set the mode for an RX buffer.  The mode specifies, at a high
-         * level, what packets should be captured from the bus and placed
-         * into an RX buffer.  See the datasheet for details, but the
-         * default, MCP2515_RXMODE_ANY_FILTER, should be sufficient in
-         * most cases.  It is also possible to use this to restrict the
-         * types of CAN ids accepted (extended only, standard only) as
-         * well as a debug ANY_NOFILTER mode.
-         *
-         * @param bufnum The buffer to set the mode for.  One of the
-         * MCP2515_RX_BUFFER_T values.
-         * @param rxm The mode to set.  One of the MCP2515_RXMODE_T values.
-         */
-        void setRXBufferMode(MCP2515_RX_BUFFER_T bufnum,
-                             MCP2515_RXMODE_T rxm);
-
-        /**
-         * Return a bitmask indicating which of the 2 RX buffers have
-         * packets waiting in them.  This can be 0 (no packets), 1(RXB0),
-         * 2(RXB1), or 3 (RXB0 and RXB1).  This information is retrieved
-         * using the MCP2515_CMD_RX_STATUS command.
-         *
-         * @return A bitmask indicating which RX buffers (if any) have
-         * packets in them.  One of the MCP2515_RXMSG_T values.
-         */
-        MCP2515_RXMSG_T rxStatusMsgs();
-
-        /**
-         * Return the message type present in one of the RX buffers.  RXB0
-         * has the highest priority, so if both RX buffers are full, this
-         * function will only return data for the packet in RXB0.  This
-         * information is retrieved using the MCP2515_CMD_RX_STATUS
-         * command.
-         *
-         * @return One of the MCP2515_MSGTYPE_T values.
-         */
-        MCP2515_MSGTYPE_T rxStatusMsgType();
-
-        /**
-         * Return the filter that matched an RX buffer.  RXB0 has the
-         * highest priority, so if both RX buffers are full, this function
-         * will only return data for the packet in RXB0.  This information
-         * is retrieved using the MCP2515_CMD_RX_STATUS command.
-         *
-         * @return One of the MCP2515_FILTERMATCH_T values.
-         */
-        MCP2515_FILTERMATCH_T rxStatusFiltermatch();
-
-        /**
-         * This function retrieves a message from the specified RX
-         * buffer.  The message (MCP2515_MSG_T) contains all of the
-         * data in the packet, including id, rtr, ext, payload and
-         * payload length.  In addition, after retrieving the message,
-         * the RX buffer is freed to receive further data from the CAN
-         * bus.  The message is stored within the class.
-         *
-         * @param bufnum The buffer to retrieve.  One of the
-         * MCP2515_RX_BUFFER_T values.
-         */
-        upm_result_t getRXMsg(MCP2515_RX_BUFFER_T bufnum);
-
-        /**
-         * This is a utility function prints the current (last
-         * received) messages decoded contents.  This is of
-         * primary importance for debugging, and to simplify the
-         * examples somewhat.
-         *
-         * The output will look similar to:
-         *
-         * id 00000000 ext 0 rtr 0 filt 0 len 8
-         *          payload: 0xc8 0x01 0x02 0x03 0x04 0x05 0x06 0x07
-         *
-         */
-        void printMsg();
-
-
-        /**
-         * This method returns the id of a received message.  It will
-         * only be valid after a successful completion of rxGetMsg().
-         *
-         * @return ID of the last received message.
-         */
-        int msgGetID()
-        {
-            return m_message.id;
-        }
-
-        /**
-         * This method returns the RTR flag of a received message.  It will
-         * only be valid after a successful completion of rxGetMsg().
-         *
-         * @return True if the message has the RTR flag set, false otherwise.
-         */
-        bool msgGetRTR()
-        {
-            return m_message.rtr;
-        }
-
-        /**
-         * This method returns the EXT (extended ID) flag of a
-         * received message.  It will only be valid after a successful
-         * completion of rxGetMsg().
-         *
-         * @return True if the message has an extended ID, false otherwise.
-         */
-        bool msgGetEXT()
-        {
-            return m_message.ext;
-        }
-
-        /**
-         * This method returns the filter number that caused the
-         * message to be stored in the RX buffer.  It will only be
-         * valid after a successful completion of rxGetMsg().
-         *
-         * @return The filter number that was matched.
-         */
-        int msgGetFilterNum()
-        {
-            return m_message.filter_num;
-        }
-
-        /**
-         * This method returns the length of the payload of the RX
-         * buffer.  It will only be valid after a successful
-         * completion of rxGetMsg().
-         *
-         * @return Length of the payload in bytes, max 8.
-         */
-        int msgGetPayloadLen()
-        {
-            return m_message.len;
-        }
-
-        /**
-         * This method returns the contents of the payload in the last
-         * received message.  It will only be valid after a successful
-         * completion of rxGetMsg().
-         *
-         * @return String containing the payload.
-         */
-        std::string msgGetPayload()
-        {
-            return std::string((char *)m_message.pkt.data, m_message.len);
-        }
-
-
-        /**
-         * Installs an interrupt service routine (ISR) to be called when
-         * an interrupt occurs.
-         *
-         * @param pin GPIO pin to use as the interrupt pin.
-         * @param isr Pointer to a function to be called on interrupt.
-         * @param arg Pointer to an object to be supplied as an
-         * argument to the ISR.
-         */
-        void installISR(int pin, void (*isr)(void *), void *arg);
-
-
-        /**
-         * Uninstalls the previously installed ISR
-         *
-         * @param dev Device context.
-         */
-        void uninstallISR();
-
-        /**
-         * Set the interrupt enables register.
-         *
-         * @param enables A bitmask of interrupts to enable from
-         * MCP2515_CANINT_BITS_T.
-         */
-        void setIntrEnables(uint8_t enables);
-
-        /**
-         * Retrieve the interrupt flags register.
-         *
-         * @return A bitmask that will be filled with values from
-         * MCP2515_CANINT_BITS_T, indicating which interrupt flags are
-         * set.
-         */
-        uint8_t getIntrFlags();
-
-        /**
-         * This function allows you to set specific interrupt flags.  If
-         * the corresponding interrupt enable is set, an interrupt will be
-         * generated.
-         *
-         * @param flags A bitmask of interrupt flags to set, from
-         * MCP2515_CANINT_BITS_T values.
-         */
-        void setIntrFlags(uint8_t flags);
-
-        /**
-         * This function allows you to clear specific interrupt flags.
-         * See the datasheet.  Some flags cannot be cleared until the
-         * underlying cause has been corrected.
-         *
-         * @param flags A bitmask of interrupt flags to clear, from
-         * MCP2515_CANINT_BITS_T values.
-         */
-        void clearIntrFlags(uint8_t flags);
-
-        /**
-         * Retrieve the error flags register
-         *
-         * @return A bitmask that will be filled with values from
-         * MCP2515_EFLG_BITS_T, indicating which error flags are set.
-         */
-        uint8_t getErrorFlags();
-
-        /**
-         * Clear error flags.  Note, some flags cannot be cleared
-         * until the underlying issues is resolved.
-         *
-         * @return A bitmask of values from MCP2515_EFLG_BITS_T,
-         * indicating which error flags to clear.
-         */
-        void clearErrorFlags(uint8_t flags);
-
-        /**
-         * This function allows you to set one of the 6 RX filters
-         * available.  Filters 0 and 1 are for RXB0 only, while filters
-         * 2-5 are for RXB1.  See the datasheet for details on how these
-         * filters (along with the masks) are used to select candidate CAN
-         * bus data for retrieval from the CAN bus.
-         *
-         * These can only be set when the device is in CONFIG mode.
-         *
-         * @param filter One of the 6 MCP2515_RX_FILTER_T values.
-         * @param ext True if the id is extended, false for standard.
-         * @param id Integer representation of a CAN bus ID.
-         */
-        void setFilter(MCP2515_RX_FILTER_T filter, bool ext, int id);
-
-        /**
-         * This function allows you to set one of the 2 RX masks.  Mask 0
-         * is for RXB0, mask 1 is for RXB1.  The masks specify which bits
-         * in the filters are used for matching CAN bus data.  See the
-         * datasheet for details on how these masks (along with the
-         * filters) are used to select candidate CAN bus data for retrieval
-         * from the CAN bus.
-         *
-         * These can only be set when the device is in CONFIG mode.
-         *
-         * @param mask One of the 2 MCP2515_RX_MASK_T values.
-         * @param ext True if the id is extended, false for standard.
-         * @param id Integer representation of a CAN bus ID.
-         */
-        void setMask(MCP2515_RX_MASK_T mask, bool ext, int id);
-
-
-    protected:
-        mcp2515_context m_mcp2515;
-
-        // We operate only on this message (for received messages) to
-        // simplify SWIG accesses.
-        MCP2515_MSG_T m_message;
-
-        /**
-         * Perform a bus read.  This function is exposed here for those
-         * users wishing to perform their own low level accesses.  This is
-         * a low level function, and should not be used unless you know
-         * what you are doing.
-         *
-         * @param cmd The command to send.
-         * @param args String containing arguments, or empty for no arguments.
-         * @param datalen The length of the data to read.
-         * @return A string containing the data.
-         */
-        std::string busRead(uint8_t cmd, std::string args, int datalen);
-
-        /**
-         * Perform a bus write.  This function is exposed here for those
-         * users wishing to perform their own low level accesses.  This is
-         * a low level function, and should not be used unless you know
-         * what you are doing.
-         *
-         * @param cmd The command to send.
-         * @param data A string containing the data to write.
-         * @param len The number of bytes to write.
-         */
-        void busWrite(uint8_t cmd, std::string data);
-
-        /**
-         * Write to a specific register.  This function is exposed here
-         * for those users wishing to perform their own low level
-         * accesses.  This is a low level function, and should not be used
-         * unless you know what you are doing.
-         *
-         * @param reg The register to write to.
-         * @param value The byte to write.
-         */
-        void writeReg(uint8_t reg, uint8_t value);
-
-        /**
-         * Write to multiple consecutive registers.  This function is
-         * exposed here for those users wishing to perform their own low
-         * level accesses.  This is a low level function, and should not
-         * be used unless you know what you are doing.
-         *
-         * @param reg The register to start writing to.
-         * @param buffer A string containing data to write.
-         */
-        void writeRegs(uint8_t reg, std::string buffer);
-
-        /**
-         * Read a register.  This function is exposed here for those users
-         * wishing to perform their own low level accesses.  This is a low
-         * level function, and should not be used unless you know what you
-         * are doing.
-         *
-         * @param reg The register to read.
-         * @return The register contents.
-         */
-        uint8_t readReg(uint8_t reg);
-
-        /**
-         * Perform a bit modify operation on a register.  Only certain
-         * registers support this method of access - check the datasheet.
-         * This function is exposed here for those users wishing to
-         * perform their own low level accesses.  This is a low level
-         * function, and should not be used unless you know what you are
-         * doing.
-         *
-         * @param addr The address of the register to access.
-         * @param mask A bitmask used to mask off value bits.
-         * @param value The value to write (bits masked by mask).
-         */
-        void bitModify(uint8_t addr, uint8_t mask, uint8_t value);
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        MCP2515(const MCP2515&) = delete;
-        MCP2515 &operator=(const MCP2515&) = delete;
-    };
-}
diff --git a/src/mcp2515/mcp2515.i b/src/mcp2515/mcp2515.i
deleted file mode 100644
index 86375ab..0000000
--- a/src/mcp2515/mcp2515.i
+++ /dev/null
@@ -1,25 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "arrays_java.i"
-%include "../java_buffer.i"
-
-%ignore installISR(int pin, void *, void *);
-
-JAVA_JNI_LOADLIBRARY(javaupm_mcp2515)
-JAVA_ADD_INSTALLISR_PIN(upm::MCP2515)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%include "../carrays_uint8_t.i"
-%pointer_functions(float, floatp);
-
-%{
-#include "mcp2515_regs.h"
-#include "mcp2515.hpp"
-%}
-%include "mcp2515_regs.h"
-%include "mcp2515.hpp"
-/* END Common SWIG syntax */
diff --git a/src/mcp2515/mcp2515.json b/src/mcp2515/mcp2515.json
deleted file mode 100644
index 67c6cd6..0000000
--- a/src/mcp2515/mcp2515.json
+++ /dev/null
@@ -1,60 +0,0 @@
-{
-    "Library": "mcp2515",
-    "Description": "API for the Microchip MCP2515 CAN bus controller",
-    "Sensor Class": {
-        "MCP2515": {
-            "Name": "Microchip MCP2515 CAN bus controller",
-            "Description": "This is the UPM Module for the Microchip MCP2515 CAN bus controller. This Arduino/Genuino compatable shield offers the ability to communicate over CAN-BUS. This offers a good medium speed, long distance and high reliablity communication solution for Arduino/Genuino projects.",
-            "Aliases": ["mcp2515", "CAN-BUS Shield V1.2"],
-            "Categories": ["communication"],
-            "Connections": ["spi", "gpio"],
-            "Project Type": ["prototyping"],
-            "Manufacturers": ["Seeed", "Microchip"],
-            "Examples": {
-                "Java": ["MCP2515_Example.java", "MCP2515_TXRX_Example.java"],
-                "Python": ["mcp2515-txrx.py", "mcp2515.py"],
-                "Node.js": ["mcp2515-txrx.js", "mcp2515.js"],
-                "C++": ["mcp2515-txrx.cxx", "mcp2515.cxx"],
-                "C": ["mcp2515-txrx.c", "mcp2515.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 2.7,
-                    "max": 5.5
-                },
-                "Supply Current": {
-                    "Normal Mode" : {
-                        "unit": "mA",
-                        "Typ" : "10"
-                    },
-                    "Sleep Mode" : {
-                        "unit": "uA",
-                        "min" : "5",
-                        "max" : "8"
-                    }
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Data Frame Buffer": {
-                    "unit": "bit",
-                    "min" : "11",
-                    "max" : "29"
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                },
-                "Arduino 101": {
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/CANBUS-Shield-p-2256.html"],
-                "Datasheets": ["http://ww1.microchip.com/downloads/en/DeviceDoc/21801e.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/mcp2515/mcp2515_regs.h b/src/mcp2515/mcp2515_regs.h
deleted file mode 100644
index b08beb3..0000000
--- a/src/mcp2515/mcp2515_regs.h
+++ /dev/null
@@ -1,641 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-// maximum number of bytes we can send/receive
-#define MCP2515_MAX_PAYLOAD_DATA (8)
-
-// This includes SIDH, SIDL, EID8, EID0, DLC, and 8 payload bytes.
-// This represents the non-control components of the RX and TX
-// buffers.
-#define MCP2515_MAX_PKT_DATA (13)
-// Now we break them out for clarity.  These are offsets into a
-// transmitted or received packet.
-#define MCP2515_PKT_SIDH     (0)
-#define MCP2515_PKT_SIDL     (1)
-#define MCP2515_PKT_EID8     (2)
-#define MCP2515_PKT_EID0     (3)
-#define MCP2515_PKT_DLC      (4)
-#define MCP2515_PKT_D0       (5)
-#define MCP2515_PKT_D1       (6)
-#define MCP2515_PKT_D2       (7)
-#define MCP2515_PKT_D3       (8)
-#define MCP2515_PKT_D4       (9)
-#define MCP2515_PKT_D5       (10)
-#define MCP2515_PKT_D6       (11)
-#define MCP2515_PKT_D7       (12)
-
-// The number of bytes that make up an ID (SIDH, SIDL, EID8, EID0)
-#define MCP2515_MAX_ID_BYTES (4)
-
-    // 4 byte SIDH, SIDL, SID8, SID0 id.  This is used only for
-    // converting back and forth from an integer and 4-byte device
-    // representation of a standard or extended ID.
-    typedef union {
-        uint8_t data[MCP2515_MAX_ID_BYTES];
-        struct {
-            uint8_t SIDH;
-            uint8_t SIDL;
-            uint8_t EID8;
-            uint8_t EID0;
-        };
-    } MCP2515_ID_T;
-
-    // 13 byte packet starting at SIDH.  This is used to represent
-    // packets for transmission and reception.
-    typedef union {
-        uint8_t data[MCP2515_MAX_PKT_DATA];
-        struct {
-            uint8_t SIDH; // Id data
-            uint8_t SIDL;
-            uint8_t EID8;
-            uint8_t EID0;
-            uint8_t DLC;  // DLC (data length)
-            uint8_t D0;   // start of 8 byte (max) payload
-            uint8_t D1;
-            uint8_t D2;
-            uint8_t D3;
-            uint8_t D4;
-            uint8_t D5;
-            uint8_t D6;
-            uint8_t D7;
-        };
-    } MCP2515_PKT_T;
-
-    // A received message.  This includes the packet, and some decoded
-    // data (rtr, ext, id, etc.
-    typedef struct {
-        int id;
-        bool rtr;
-        bool ext;
-        int filter_num;
-        int len;
-        MCP2515_PKT_T pkt;
-    } MCP2515_MSG_T;
-
-    // Registers
-    typedef enum {
-        // 5 RX filters, each composed of SIDH, SIDL, EID8, EID0.  We
-        // only specify the leading (SIDH) address here.
-
-        // first two filters are associated with rxb0
-        MCP2515_REG_FILTER0              = 0x00,
-        MCP2515_REG_FILTER1              = 0x04,
-        // remaining 4 filters are associated with rxb1
-        MCP2515_REG_FILTER2              = 0x08,
-        MCP2515_REG_FILTER3              = 0x10,
-        MCP2515_REG_FILTER4              = 0x14,
-        MCP2515_REG_FILTER5              = 0x18,
-
-        // 2 RX filter mask registers, like above, we only specify the
-        // SIDH address
-
-        // associated with rxb0
-        MCP2515_REG_MASK0                = 0x20,
-        // associated with rxb1
-        MCP2515_REG_MASK1                = 0x24,
-
-        MCP2515_REG_BFPCTL               = 0x0c,
-        MCP2515_REG_TXRTSCTRL            = 0x0d, // tx ready-to-send
-
-        // CANSTAT and CANCTRL are aliased in several locations to
-        // make it easier to get maximum data using burst reads.  In
-        // reality, they are the same register, but we list them all
-        // anyway for completeness.
-
-        // CANSTAT and aliases
-        MCP2515_REG_CANSTAT              = 0x0e,
-        MCP2515_REG_CANSTAT_0            = 0x0e, // same as CANSTAT
-
-        MCP2515_REG_CANSTAT_1            = 0x1e, // rest of the aliases
-        MCP2515_REG_CANSTAT_2            = 0x2e,
-        MCP2515_REG_CANSTAT_3            = 0x3e,
-        MCP2515_REG_CANSTAT_4            = 0x4e,
-        MCP2515_REG_CANSTAT_5            = 0x5e,
-        MCP2515_REG_CANSTAT_6            = 0x6e,
-        MCP2515_REG_CANSTAT_7            = 0x7e,
-
-        // CANCTRL and aliases
-        MCP2515_REG_CANCTRL              = 0x0f,
-        MCP2515_REG_CANCTRL_0            = 0x0f, // same as CANCTRL
-
-        MCP2515_REG_CANCTRL_1            = 0x1f, // rest of the aliases
-        MCP2515_REG_CANCTRL_2            = 0x2f,
-        MCP2515_REG_CANCTRL_3            = 0x3f,
-        MCP2515_REG_CANCTRL_4            = 0x4f,
-        MCP2515_REG_CANCTRL_5            = 0x5f,
-        MCP2515_REG_CANCTRL_6            = 0x6f,
-        MCP2515_REG_CANCTRL_7            = 0x7f,
-
-        MCP2515_REG_TEC                  = 0x1c, // tx error count
-        MCP2515_REG_REC                  = 0x1d, // rx error count
-
-        MCP2515_REG_CNF3                 = 0x28, // configuration bytes
-        MCP2515_REG_CNF2                 = 0x29,
-        MCP2515_REG_CNF1                 = 0x2a,
-
-        MCP2515_REG_CANINTE              = 0x2b, // intr enables
-        MCP2515_REG_CANINTF              = 0x2c, // intr flags
-
-        MCP2515_REG_EFLG                 = 0x2a, // error flags
-
-        // Start of the buffer reg ranges for tx and rx buffers.
-        // There are 3 transmit buffers and 2 rx buffers.  You can
-        // read and write 16 bytes (0x0f) starting at these locations
-        // to set and/get buffer control bits, message ids, msg
-        // content, and CANSTAT and CANCTRL regs in one bus transaction.
-
-        // See the datasheet page 61
-        MCP2515_REG_TXB0CTRL             = 0x30, // tx buffer 0 ctrl
-        MCP2515_REG_TXB1CTRL             = 0x40, // tx buffer 1 ctrl
-        MCP2515_REG_TXB2CTRL             = 0x50, // tx buffer 2 ctrl
-
-        MCP2515_REG_RXB0CTRL             = 0x60, // rx buffer 0 ctrl
-        MCP2515_REG_RXB1CTRL             = 0x70 // rx buffer 1 ctrl
-    } MCP2515_REG_T;
-
-    // MCP2515_REG_CANCTRL bits
-    typedef enum {
-        MCP2515_CANCTRL_CLKPRE0          = 0x01,
-        MCP2515_CANCTRL_CLKPRE1          = 0x02,
-        _MCP2515_CANCTRL_CLKPRE_MASK     = 3,
-        _MCP2515_CANCTRL_CLKPRE_SHIFT    = 0,
-
-        MCP2515_CANCTRL_CLKEN            = 0x04, //enable CLKOUT pin
-
-        MCP2515_CANCTRL_OSM              = 0x08, // one shot mode
-
-        MCP2515_CANCTRL_ABAT             = 0x10, // abort all pending tx
-
-        MCP2515_CANCTRL_REQOP0           = 0x20, // request new operating mode
-        MCP2515_CANCTRL_REQOP1           = 0x40,
-        MCP2515_CANCTRL_REQOP2           = 0x80,
-        _MCP2515_CANCTRL_REQOP_MASK      = 7,
-        _MCP2515_CANCTRL_REQOP_SHIFT     = 5,
-    } MCP2515_CANCTRL_BITS_T;
-
-    // MCP2515_CLKPRE values
-    typedef enum {
-        MCP2515_CLKPRE_DIV1              = 0, // sysclk/1
-        MCP2515_CLKPRE_DIV2              = 1, // sysclk/2
-        MCP2515_CLKPRE_DIV4              = 2, // sysclk/4
-        MCP2515_CLKPRE_DIV8              = 3  // sysclk/8
-    } MCP2515_CLKPRE_T;
-
-    // MCP2515_OPMODE values.  These are the same for the CANCTRL_REQOP and
-    // CANSTAT_OPMODE bitfields.
-    typedef enum {
-        MCP2515_OPMODE_NORMAL            = 0,
-        MCP2515_OPMODE_SLEEP             = 1,
-        MCP2515_OPMODE_LOOPBACK          = 2,
-        MCP2515_OPMODE_LISTENONLY        = 3,
-        MCP2515_OPMODE_CONFIG            = 4
-    } MCP2515_OPMODE_T;
-
-    // MCP2515_REG_CANSTAT bits
-    typedef enum {
-        // 0x01 reserved
-
-        MCP2515_CANSTAT_ICOD0            = 0x02, // intr flag code
-        MCP2515_CANSTAT_ICOD1            = 0x04,
-        MCP2515_CANSTAT_ICOD2            = 0x08,
-        _MCP2515_CANSTAT_ICOD_MASK       = 7,
-        _MCP2515_CANSTAT_ICOD_SHIFT      = 1,
-
-        // 0x10 reserved
-
-        MCP2515_CANSTAT_OPMODE0          = 0x20, // request new operating mode
-        MCP2515_CANSTAT_OPMODE1          = 0x40,
-        MCP2515_CANSTAT_OPMODE2          = 0x80,
-        _MCP2515_CANSTAT_OPMODE_MASK     = 7,
-        _MCP2515_CANSTAT_OPMODE_SHIFT    = 5,
-    } MCP2515_CANSTAT_BITS_T;
-
-    // MCP2515_REG_BFPCTL bits, Buffer Pin Control
-    typedef enum {
-        MCP2515_BFPCTL_B0BFM             = 0x01, // opmode bit
-        MCP2515_BFPCTL_B1BFM             = 0x02,
-
-        MCP2515_BFPCTL_B0BFE             = 0x04, // func enable bit
-        MCP2515_BFPCTL_B1BFE             = 0x08,
-
-        MCP2515_BFPCTL_B0BFS             = 0x10, // pin state (output mode only)
-        MCP2515_BFPCTL_B1BFS             = 0x20,
-
-        // 0x40-0x080 reserved
-    } MCP2515_BFPCTL_BITS_T;
-
-    // MCP2515_REG_TXRTSCTRL bits, TX RTS pin control
-    typedef enum {
-        MCP2515_TXRTSCTRL_B0RTSM          = 0x01, // pin mode
-        MCP2515_TXRTSCTRL_B1RTSM          = 0x02,
-        MCP2515_TXRTSCTRL_B2RTSM          = 0x04,
-
-        MCP2515_TXRTSCTRL_B0RTS           = 0x08, // pin state when in
-                                                  // input mode
-        MCP2515_TXRTSCTRL_B1RTS           = 0x10,
-        MCP2515_TXRTSCTRL_B2RTS           = 0x20,
-
-        // 0x40-0x80 reserved
-    } MCP2515_TXRTSCTRL_BITS_T;
-
-    // MCP2515_REG_EFLG bits, Error flags
-    typedef enum {
-        MCP2515_EFLG_EWARN               = 0x01, // error warning (TEC/REC > 96)
-        MCP2515_EFLG_RXWAR               = 0x02, // rx warning (REC > 96)
-        MCP2515_EFLG_TXWAR               = 0x04, // tx warning (REC > 96)
-
-        MCP2515_EFLG_RXEP                = 0x08, // rx error-passive
-        MCP2515_EFLG_TXEP                = 0x10, // tx error-passive
-
-        MCP2515_EFLG_TXBO                = 0x20, // tx bus off
-
-        MCP2515_EFLG_RX0OVR              = 0x40, // rx buf 0 overflow
-        MCP2515_EFLG_RX1OVR              = 0x80, // rx buf 1 overflow
-    } MCP2515_EFLG_BITS_T;
-
-    // MCP2515_REG_CANINTE and MCP2515_REG_CANINTF bits, interrupt
-    // enables and flags.  We use the same enum here as the two regs
-    // have the same bits.
-    typedef enum {
-        MCP2515_CANINT_RX0I              = 0x01, // rx buf 0 full
-        MCP2515_CANINT_RX1I              = 0x02, // rx buf 1 full
-
-        MCP2515_CANINT_TX0I              = 0x04, // tx buf 1 empty
-        MCP2515_CANINT_TX1I              = 0x08, // tx buf 2 empty
-        MCP2515_CANINT_TX2I              = 0x10, // tx buf 3 empty
-
-        MCP2515_CANINT_ERRI              = 0x20, // error intr
-        MCP2515_CANINT_WAKI              = 0x40, // wakeup intr
-
-        MCP2515_CANINT_MERR              = 0x80  // msg error
-    } MCP2515_CANINT_BITS_T;
-
-    // MCP2515_REG_TXBCTRL, TX control for tx buffers 0 (0x30), 1
-    // (0x40), and 2 (0x50)
-    typedef enum {
-        MCP2515_TXBCTRL_TXP0              = 0x01, // message priority
-        MCP2515_TXBCTRL_TXP1              = 0x02,
-        _MCP2515_TXBCTRL_TXP_MASK         = 3,
-        _MCP2515_TXBCTRL_TXP_SHIFT        = 0,
-
-        // 0x04 reserved
-
-        MCP2515_TXBCTRL_TXREQ             = 0x08, // tx request
-        MCP2515_TXBCTRL_TXERR             = 0x10, // tx error detected
-        MCP2515_TXBCTRL_MLOA              = 0x20, // msg lost arbitration
-        MCP2515_TXBCTRL_ABTF              = 0x40  // msg aborted flag
-
-        // 0x80 reserved
-    } MCP2515_TXBCTRL_BITS_T;
-
-    // MCP2515_TXBCTRL_TXP priority values
-    typedef enum {
-        MCP2515_TXP_LOWEST                = 0,
-        MCP2515_TXP_LOW                   = 1,
-        MCP2515_TXP_HIGH                  = 2,
-        MCP2515_TXP_HIGHEST               = 3
-    } MCP2515_TXP_T;
-
-    // MCP2515_TXBDLC bits, (addresses 0x35, 0x45, 0x55)
-    typedef enum {
-        MCP2515_TXBDLC_DLC0               = 0x01, // data length code
-        MCP2515_TXBDLC_DLC1               = 0x02, // max is 8 bytes
-        MCP2515_TXBDLC_DLC2               = 0x04,
-        MCP2515_TXBDLC_DLC3               = 0x08,
-        _MCP2515_TXBDLC_MASK              = 15,
-        _MCP2515_TXBDLC_SHIFT             = 0,
-
-        // 0x10-0x20 reserved
-
-        MCP2515_TXBDLC_RTR                = 0x40, // remote
-                                                  // transmission
-                                                  // request bit
-
-        // 0x80 reserved
-    } MCP2515_TXBDLC_BITS_T;
-
-    // MCP2515_REG_RXB0CTRL, RX control for rx buffer 0 (0x60)
-    typedef enum {
-        MCP2515_RXB0CTRL_FILHIT            = 0x01, // which filter was hit
-
-        MCP2515_RXB0CTRL_BUKT1             = 0x02, // readonly version of BUKT
-        MCP2515_RXB0CTRL_BUKT              = 0x04, // rollover enable (to rx1)
-
-        MCP2515_RXB0CTRL_RXRTR             = 0x08, // RTR request
-
-        // 0x10 reserved
-
-        MCP2515_RXB0CTRL_RXMODE0           = 0x20, // rx buf mode bits
-        MCP2515_RXB0CTRL_RXMODE1           = 0x40,
-        _MCP2515_RXB0CTRL_RXMODE_MASK      = 3,
-        _MCP2515_RXB0CTRL_RXMODE_SHIFT     = 5
-
-        // 0x80 reserved
-    } MCP2515_RXB0CTRL_BITS_T;
-
-    // These values determine whether the filters are used and what
-    // kinds of messages to accept.  They are the same for both rx
-    // buffers.
-    typedef enum {
-        MCP2515_RXMODE_ANY_FILTER          = 0, // std/ext based on filter
-        MCP2515_RXMODE_STANDARD_FILTER     = 1, // standard only, filter
-        MCP2515_RXMODE_EXTENDED_FILTER     = 2, // extended only, filter
-        MCP2515_RXMODE_ANY_NOFILTER        = 3  // any, no filter
-    } MCP2515_RXMODE_T;
-
-    // MCP2515_REG_RXB1CTRL, RX control for rx buffer 1 (0x70)
-    typedef enum {
-        MCP2515_RXB1CTRL_FILHIT0           = 0x01, // which filter was hit
-        MCP2515_RXB1CTRL_FILHIT1           = 0x02, // for a rollover, this can
-        MCP2515_RXB1CTRL_FILHIT2           = 0x04, // be filter 0 or 1 too.
-        _MCP2515_RXB1CTRL_FILHIT_MASK      = 7,
-        _MCP2515_RXB1CTRL_FILHIT_SHIFT     = 0,
-
-        MCP2515_RXB1CTRL_RXRTR             = 0x08, // RTR request
-
-        // 0x10 reserved
-
-        MCP2515_RXB1CTRL_RXMODE0           = 0x20, // rx buf mode bits
-        MCP2515_RXB1CTRL_RXMODE1           = 0x40,
-        _MCP2515_RXB1CTRL_RXMODE_MASK      = 3,
-        _MCP2515_RXB1CTRL_RXMODE_SHIFT     = 5
-
-        // 0x80 reserved
-    } MCP2515_RXB1CTRL_BITS_T;
-
-    // MCP2515_RXB1CTRL_FILHIT values for rx buffer 1
-    typedef enum {
-        MCP2515_FILHIT_F0                  = 0, // filter 0 hit (only if bukt)
-        MCP2515_FILHIT_F1                  = 1, // filter 1 hit (only if bukt)
-        MCP2515_FILHIT_F2                  = 2, // filter 2 hit
-        MCP2515_FILHIT_F3                  = 3,
-        MCP2515_FILHIT_F4                  = 4,
-        MCP2515_FILHIT_F5                  = 5
-    } MCP2515_FILHIT_T;
-
-    // Valid CANBUS speeds.  These are precomputed and represented in
-    // a table in mcp2515.c.  It is a requirement that the enum values
-    // below correspond to the indexes in the speed table.  Keep them
-    // in sync!  Add any new values to the end of this enum, and to
-    // the corresponding table in mcp2515.c.
-    //
-    // These values are valid only for 16Mhz clocks.
-    typedef enum {
-        MCP2515_SPEED_5KBPS                = 0,
-        MCP2515_SPEED_10KBPS               = 1,
-        MCP2515_SPEED_20KBPS               = 2,
-        MCP2515_SPEED_25KBPS               = 3,
-        MCP2515_SPEED_31_25KBPS            = 4, // 31.25kbps
-        MCP2515_SPEED_33KBPS               = 5,
-        MCP2515_SPEED_40KBPS               = 6,
-        MCP2515_SPEED_50KBPS               = 7,
-        MCP2515_SPEED_80KBPS               = 8,
-        MCP2515_SPEED_83KBPS               = 9,
-
-        MCP2515_SPEED_95KBPS               = 10,
-        MCP2515_SPEED_100KBPS              = 11,
-        MCP2515_SPEED_125KBPS              = 12,
-        MCP2515_SPEED_200KBPS              = 13,
-        MCP2515_SPEED_250KBPS              = 14,
-        MCP2515_SPEED_500KBPS              = 15,
-        MCP2515_SPEED_666KBPS              = 16,
-        MCP2515_SPEED_1000KBPS             = 17
-    } MCP2515_SPEED_T;
-
-    // MCP2515_RXBDLC bits, (addresses 0x65, 0x75)
-    typedef enum {
-        MCP2515_RXBDLC_DLC0               = 0x01, // data length code
-        MCP2515_RXBDLC_DLC1               = 0x02, // max is 8 bytes
-        MCP2515_RXBDLC_DLC2               = 0x04,
-        MCP2515_RXBDLC_DLC3               = 0x08,
-        _MCP2515_RXBDLC_MASK              = 15,
-        _MCP2515_RXBDLC_SHIFT             = 0,
-
-        // 0x10-0x20 reserved
-
-        MCP2515_RXBDLC_RTR                = 0x40, // remote
-                                                  // transmission
-                                                  // request bit, if
-                                                  // extended id
-
-        // 0x80 reserved
-    } MCP2515_RXBDLC_BITS_T;
-
-    // SPI commands - these are commands sent to the device to start
-    // certain operations.  The datasheet specifies that after CS is
-    // active, the first byte must be the command byte.  It is not
-    // possible to send multiple commands in a single transaction
-    // (a CS On/CS Off sequence).
-    typedef enum {
-        MCP2515_CMD_RESET                  = 0xc0,
-
-        MCP2515_CMD_READ                   = 0x03,
-
-        // These commands allows the specification of a read buffer.
-        // The real command is 0x90. The lower nibble is 0mn0,
-        // where m and n specify the 4 locations to start reading
-        // from.  In this list, we will enumerate all of them.
-        //
-        // n  m  cmd        real hex addr
-        // ------------------------------
-        // 0  0  RXB0SIDH   0x61
-        // 0  1  RXB0D0     0x66
-        // 1  0  RXB1SIDH   0x71
-        // 1  1  RXB1D0     0x76
-        MCP2515_CMD_READ_RXBUF_RXB0SIDH    = 0x90,
-        MCP2515_CMD_READ_RXBUF_RXB0D0      = 0x92,
-        MCP2515_CMD_READ_RXBUF_RXB1SIDH    = 0x94,
-        MCP2515_CMD_READ_RXBUF_RXB1D0      = 0x96,
-
-        MCP2515_CMD_WRITE                  = 0x02,
-
-        // This command allows speedier loading of tx buffer contents.
-        // The lower nibble is 0b0abc, where abc specifies 6 location
-        // addresses to start writing to.  This works similarly to the
-        // READ_RXBUF_* commands.
-        //
-        // a  b  c   cmd        real hex addr
-        // ----------------------------------
-        // 0  0  0   TXB0SIDH   0x31
-        // 0  0  1   TXB0D0     0x36
-        // 0  1  0   TXB1SIDH   0x41
-        // 0  1  1   TXB1D0     0x46
-        // 1  0  0   TXB2SIDH   0x51
-        // 1  0  1   TXB2D0     0x56
-        MCP2515_CMD_LOAD_TXBUF_TXB0SIDH    = 0x40,
-        MCP2515_CMD_LOAD_TXBUF_TXB0D0      = 0x41,
-        MCP2515_CMD_LOAD_TXBUF_TXB1SIDH    = 0x42,
-        MCP2515_CMD_LOAD_TXBUF_TXB1D0      = 0x43,
-        MCP2515_CMD_LOAD_TXBUF_TXB2SIDH    = 0x44,
-        MCP2515_CMD_LOAD_TXBUF_TXB2D0      = 0x45,
-
-        // Request to Send.  This is a quick way to request the
-        // sending of tx buffers without having to do a
-        // read/modify/write register sequence.  The lower 3 bits
-        // indicate which buffer(s) to setup for transmission.
-        //
-        // 0x8n Where n is 0b0xxx. bit 0 is for txb 0, bit 1 for txb 1
-        // and bit 2 for txb 2.
-        MCP2515_CMD_RTS                    = 0x80,
-        MCP2515_CMD_RTS_BUFFER0            = 0x81,
-        MCP2515_CMD_RTS_BUFFER1            = 0x82,
-        MCP2515_CMD_RTS_BUFFER2            = 0x84,
-
-        // return status bits for rx and tx. See MCP2515_RDSTATUS_BITS_T.
-        MCP2515_CMD_READ_STATUS            = 0xa0,
-
-        // returns information on which filters have been matched.
-        // See MCP2515_RXSTATUS_BITS_T.
-        MCP2515_CMD_RX_STATUS              = 0xb0,
-
-        // This command allows for certain registers to have certain
-        // bit(s) modified w/o going through a read/modify/write cycle
-        // of the whole register.  See the datasheet - only certain
-        // registers can be used with this command.
-        //
-        // The format for this command is: cmd, addr, mask, value
-        MCP2515_CMD_BIT_MODIFY             = 0x05
-    } MCP2515_CMD_T;
-
-    // This bitfield is the contents of the byte returned from a
-    // CMD_READ_STATUS command.
-    typedef enum {
-        MCP2515_RDSTATUS_RX0IF              = 0x01, // rx buf 0 full IF
-        MCP2515_RDSTATUS_RX1IF              = 0x02, // rx buf 1 full IF
-        MCP2515_RDSTATUS_TXB0REQ            = 0x04, // TX buf 0 req bit
-        MCP2515_RDSTATUS_TXB0IF             = 0x08, // TX buf 0 empty IF
-        MCP2515_RDSTATUS_TXB1REQ            = 0x10, // TX buf 1 req bit
-        MCP2515_RDSTATUS_TXB1IF             = 0x20, // TX buf 1 empty IF
-        MCP2515_RDSTATUS_TXB2REQ            = 0x40, // TX buf 2 req bit
-        MCP2515_RDSTATUS_TXB2IF             = 0x80  // TX buf 2 empty IF
-    } MCP2515_RDSTATUS_BITS_T;
-
-    // This bitfield is the contents of the byte returned from a
-    // CMD_READ_RX_STATUS command.
-    typedef enum {
-        MCP2515_RXSTATUS_FILTERMATCH0       = 0x01,
-        MCP2515_RXSTATUS_FILTERMATCH1       = 0x02,
-        MCP2515_RXSTATUS_FILTERMATCH2       = 0x04,
-        _MCP2515_RXSTATUS_FILTERMATCH_MASK  = 7,
-        _MCP2515_RXSTATUS_FILTERMATCH_SHIFT = 0,
-
-        MCP2515_RXSTATUS_MSGTYPE0           = 0x08,
-        MCP2515_RXSTATUS_MSGTYPE1           = 0x10,
-        _MCP2515_RXSTATUS_MSGTYPE_MASK      = 3,
-        _MCP2515_RXSTATUS_MSGTYPE_SHIFT     = 3,
-
-        // 0x20 is not mentioned in the DS
-
-        MCP2515_RXSTATUS_RXMSG0             = 0x40,
-        MCP2515_RXSTATUS_RXMSG1             = 0x80,
-        _MCP2515_RXSTATUS_RXMSG_MASK        = 3,
-        _MCP2515_RXSTATUS_RXMSG_SHIFT       = 6
-    } MCP2515_RXSTATUS_BITS_T;
-
-    // MCP2515_RXSTATUS_FILTERMATCH values
-    typedef enum {
-        MCP2515_FILTERMATCH_RXF0            = 0,
-        MCP2515_FILTERMATCH_RXF1            = 1,
-        MCP2515_FILTERMATCH_RXF2            = 2,
-        MCP2515_FILTERMATCH_RXF3            = 3,
-        MCP2515_FILTERMATCH_RXF4            = 4,
-        MCP2515_FILTERMATCH_RXF5            = 5,
-        MCP2515_FILTERMATCH_RXF0_ROLLOVER   = 6,
-        MCP2515_FILTERMATCH_RXF1_ROLLOVER   = 7
-    } MCP2515_FILTERMATCH_T;
-
-    // MCP2515_RXSTATUS_MSGTYPE values
-    typedef enum {
-        MCP2515_MSGTYPE_STD                 = 0, // standard
-        MCP2515_MSGTYPE_STDRF               = 1, // standard remote frame
-        MCP2515_MSGTYPE_EXT                 = 2, // extended
-        MCP2515_MSGTYPE_EXTRF               = 3  // extended remote frame
-    } MCP2515_MSGTYPE_T;
-
-    // MCP2515_RXSTATUS_RXMSG values
-    typedef enum {
-        MCP2515_RXMSG_NONE                  = 0, // no msg
-        MCP2515_RXMSG_RXB0                  = 1, // msg in rxb0
-        MCP2515_RXMSG_RXB1                  = 2, // msg in rxb1
-        MCP2515_RXMSG_BOTH                  = 3  // msg in both
-    } MCP2515_RXMSG_T;
-
-    // we spell out the SIDL registers as they contain the EXIDE bit.
-    // The others (SIDL, EID0 and EID8 just contain their respective
-    // ID bits.
-    typedef enum {
-        MCP2515_SIDL_EID16                  = 0x01,
-        MCP2515_SIDL_EID17                  = 0x02,
-
-        // 0x04 reserved
-
-        MCP2515_SIDL_EXIDE                  = 0x08,
-
-        // 0x10 reserved
-
-        MCP2515_SIDL_SID0                   = 0x20,
-        MCP2515_SIDL_SID1                   = 0x40,
-        MCP2515_SIDL_SID2                   = 0x80
-    } MCP2515_SIDL_T;
-
-    // An enum to specify one of the 3 TX buffers
-    typedef enum {
-        MCP2515_TX_BUFFER0                  = 0,
-        MCP2515_TX_BUFFER1                  = 1,
-        MCP2515_TX_BUFFER2                  = 2,
-        // special value indicating no buffers
-        MCP2515_TX_NO_BUFFERS               = 255
-    } MCP2515_TX_BUFFER_T;
-
-    // An enum to specify one of the 2 rx buffers
-    typedef enum {
-        MCP2515_RX_BUFFER0                  = 0,
-        MCP2515_RX_BUFFER1                  = 1
-    } MCP2515_RX_BUFFER_T;
-
-    // An enum to specify one of the 6 rx filters
-    typedef enum {
-        MCP2515_RX_FILTER0                  = 0,
-        MCP2515_RX_FILTER1                  = 1,
-        MCP2515_RX_FILTER2                  = 2,
-        MCP2515_RX_FILTER3                  = 3,
-        MCP2515_RX_FILTER4                  = 4,
-        MCP2515_RX_FILTER5                  = 5
-    } MCP2515_RX_FILTER_T;
-
-    // An enum to specify one of the 2 rx masks
-    typedef enum {
-        MCP2515_RX_MASK0                    = 0,
-        MCP2515_RX_MASK1                    = 1
-    } MCP2515_RX_MASK_T;
-
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/md/CMakeLists.txt b/src/md/CMakeLists.txt
deleted file mode 100644
index 79cb7f8..0000000
--- a/src/md/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-upm_mixed_module_init (NAME md
-    DESCRIPTION "I2C Motor Driver"
-    C_HDR md.h md_defs.h
-    C_SRC md.c
-    CPP_HDR md.hpp
-    CPP_SRC md.cxx
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/md/md.c b/src/md/md.c
deleted file mode 100644
index 21b8580..0000000
--- a/src/md/md.c
+++ /dev/null
@@ -1,265 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <assert.h>
-#include <string.h>
-
-#include <upm_utilities.h>
-
-#include "md.h"
-
-// static (private) functions
-static void md_stepper_step(const md_context dev)
-{
-    assert(dev != NULL);
-
-    int step = dev->currentStep % 4;
-
-    switch (step)
-    {
-    case 0:
-        md_write_packet(dev, MD_REG_SET_DIRECTION, 0b0101, MD_NOOP);
-        break;
-    case 1:
-        md_write_packet(dev, MD_REG_SET_DIRECTION, 0b0110, MD_NOOP);
-        break;
-    case 2:
-        md_write_packet(dev, MD_REG_SET_DIRECTION, 0b1010, MD_NOOP);
-        break;
-    case 3:
-        md_write_packet(dev, MD_REG_SET_DIRECTION, 0b1001, MD_NOOP);
-        break;
-    default:
-        // can't happen in this universe
-        break;
-    }
-}
-
-md_context md_init(int bus, uint8_t address)
-{
-    md_context dev =
-        (md_context)malloc(sizeof(struct _md_context));
-
-    if (!dev)
-        return NULL;
-
-    memset((void *)dev, 0, sizeof(struct _md_context));
-    dev->i2c = NULL;
-    dev->initialized = false;
-
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        md_close(dev);
-        return NULL;
-    }
-
-    // MRAA contexts...
-    if ( !(dev->i2c = mraa_i2c_init(bus)) )
-    {
-        printf("%s: mraa_gpio_init() failed\n",
-               __FUNCTION__);
-        md_close(dev);
-        return NULL;
-    }
-
-    // this board *requires* 100Khz i2c bus only
-    if (mraa_i2c_frequency(dev->i2c, MRAA_I2C_STD))
-    {
-        printf("%s: mraa_i2c_frequency(MRAA_I2C_STD) failed\n", __FUNCTION__);
-        md_close(dev);
-        return NULL;
-    }
-
-    if (mraa_i2c_address(dev->i2c, address))
-    {
-        printf("%s: mraa_i2c_frequency(MRAA_I2C_STD) failed\n", __FUNCTION__);
-        md_close(dev);
-        return NULL;
-    }
-
-    // default to mode1 stepper operation, 200 steps per rev.
-    md_config_stepper(dev, 200, MD_STEP_MODE1);
-
-    dev->initialized = true;
-
-    return dev;
-}
-
-void md_close(md_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->initialized)
-    {
-        md_set_motor_speeds(dev, 0, 0);
-        md_write_packet(dev, MD_REG_SET_DIRECTION, 0, MD_NOOP);
-    }
-
-    if (dev->i2c)
-        mraa_i2c_stop(dev->i2c);
-
-    free(dev);
-}
-
-bool md_write_packet(const md_context dev, MD_REG_T reg,
-                     uint8_t data1, uint8_t data2)
-{
-    assert(dev != NULL);
-
-    uint8_t buf[3];
-
-    buf[0] = reg;
-    buf[1] = data1;
-    buf[2] = data2;
-
-    if (mraa_i2c_write(dev->i2c, buf, 3))
-    {
-        printf("%s: mraa_i2c_write() failed\n", __FUNCTION__);
-        return false;
-    }
-
-    // This sleep appears to be required.  Without it, writes randomly
-    // fail (no ACK received).  This happens most often on the SET_SPEED
-    // packet.  I am guessing that there is a timing problem and/or bug
-    // in the motor driver's firmware.
-
-    upm_delay_us(100);
-
-    return true;
-}
-
-bool md_set_motor_speeds(const md_context dev, uint8_t speedA, uint8_t speedB)
-{
-    assert(dev != NULL);
-
-    return md_write_packet(dev, MD_REG_SET_SPEED, speedA, speedB);
-}
-
-bool md_set_pwm_frequency_prescale(const md_context dev, uint8_t freq)
-{
-    assert(dev != NULL);
-
-    return md_write_packet(dev, MD_REG_SET_PWM_FREQ, freq, MD_NOOP);
-}
-
-bool md_set_motor_directions(const md_context dev, MD_DC_DIRECTION_T dirA,
-                             MD_DC_DIRECTION_T dirB)
-{
-    assert(dev != NULL);
-
-    uint8_t dir = ((dirB & 0x03) << 2) | (dirA & 0x03);
-    return md_write_packet(dev, MD_REG_SET_DIRECTION, dir, MD_NOOP);
-}
-
-bool md_enable_stepper(const md_context dev, MD_STEP_DIRECTION_T dir,
-                       uint8_t speed)
-{
-    assert(dev != NULL);
-
-    // If mode 2, send the command and return immediately
-    if (dev->stepMode == MD_STEP_MODE2)
-        return md_write_packet(dev, MD_REG_STEPPER_ENABLE, dir, speed);
-
-    // otherwise, mode 1, setup the basics and start stepping.
-
-    dev->stepDelay = 60 * 1000 / dev->stepsPerRev / speed;
-    dev->stepDirection = ((dir == MD_STEP_DIR_CW) ? 1 : -1);
-
-    // seeed says speed should always be 255,255 for stepper operation
-    md_set_motor_speeds(dev, 255, 255);
-
-    while (dev->totalSteps > 0)
-    {
-        upm_delay_ms(dev->stepDelay);
-
-        dev->currentStep += dev->stepDirection;
-
-        if (dev->stepDirection == 1)
-        {
-            if (dev->currentStep >= dev->stepsPerRev)
-                dev->currentStep = 0;
-        }
-        else
-        {
-            if (dev->currentStep <= 0)
-                dev->currentStep = dev->stepsPerRev;
-        }
-
-        dev->totalSteps--;
-        md_stepper_step(dev);
-    }
-
-    // and... we're done
-    return true;
-}
-
-bool md_disable_stepper(const md_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->stepMode == MD_STEP_MODE2)
-        return md_write_packet(dev, MD_REG_STEPPER_DISABLE, MD_NOOP, MD_NOOP);
-
-    // else, mode 1
-    md_write_packet(dev, MD_REG_SET_DIRECTION, 0, MD_NOOP);
-    return md_set_motor_speeds(dev, 0, 0);
-}
-
-bool md_set_stepper_steps(const md_context dev, unsigned int steps)
-{
-    assert(dev != NULL);
-
-    if (dev->stepMode == MD_STEP_MODE2)
-    {
-        if (steps == 0)
-        {
-            // invalid
-            printf("%s: invalid number of steps. "
-                   "Valid values are between 1 and 255. \n", __FUNCTION__);
-            return false;
-        }
-        return md_write_packet(dev, MD_REG_STEPPER_NUM_STEPS, steps, MD_NOOP);
-    }
-
-    // for mode one, just store it for future use by enableStepper()
-    dev->totalSteps = steps;
-    return true;
-}
-
-void md_config_stepper(const md_context dev, unsigned int stepsPerRev,
-                       MD_STEP_MODE_T mode)
-{
-    assert(dev != NULL);
-
-    dev->stepsPerRev = stepsPerRev;
-    dev->stepMode = mode;
-    dev->currentStep = 0;
-    dev->stepDelay = 0;
-    dev->stepDirection = 1;
-    dev->totalSteps = 0;
-}
diff --git a/src/md/md.cxx b/src/md/md.cxx
deleted file mode 100644
index f9a636c..0000000
--- a/src/md/md.cxx
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014-2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "md.hpp"
-
-using namespace upm;
-using namespace std;
-
-
-MD::MD(int bus, uint8_t address) :
-    m_md(md_init(bus, address))
-{
-    if (!m_md)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": md_init() failed");
-}
-
-MD::~MD()
-{
-    md_close(m_md);
-}
-
-bool MD::writePacket(MD_REG_T reg, uint8_t data1, uint8_t data2)
-{
-    if (!md_write_packet(m_md, reg, data1, data2))
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": md_write_packet() failed");
-
-    return true;
-}
-
-bool MD::setMotorSpeeds(uint8_t speedA, uint8_t speedB)
-{
-    if (!md_set_motor_speeds(m_md, speedA, speedB))
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": md_set_motor_speeds() failed");
-
-    return true;
-}
-
-bool MD::setPWMFrequencyPrescale(uint8_t freq)
-{
-    if (!md_set_pwm_frequency_prescale(m_md, freq))
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": md_set_pwm_frequency_prescale() failed");
-
-    return true;
-}
-
-bool MD::setMotorDirections(MD_DC_DIRECTION_T dirA, MD_DC_DIRECTION_T dirB)
-{
-    if (!md_set_motor_directions(m_md, dirA, dirB))
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": md_set_motor_directions() failed");
-
-    return true;
-}
-
-bool MD::enableStepper(MD_STEP_DIRECTION_T dir, uint8_t speed)
-{
-    return md_enable_stepper(m_md, dir, speed);
-}
-
-bool MD::disableStepper()
-{
-    return md_disable_stepper(m_md);
-}
-
-bool MD::setStepperSteps(unsigned int steps)
-{
-    return md_set_stepper_steps(m_md, steps);
-}
-
-void MD::configStepper(unsigned int stepsPerRev, MD_STEP_MODE_T mode)
-{
-    md_config_stepper(m_md, stepsPerRev, mode);
-}
-
diff --git a/src/md/md.h b/src/md/md.h
deleted file mode 100644
index b9c3d3d..0000000
--- a/src/md/md.h
+++ /dev/null
@@ -1,186 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <upm.h>
-#include <mraa/i2c.h>
-
-#include "md_defs.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    /**
-     * @file md.h
-     * @library md
-     * @brief C API for the md driver
-     *
-     * @include md.c
-     */
-
-    /**
-     * Device context
-     */
-    typedef struct _md_context {
-        mraa_i2c_context i2c;
-
-        // steps per revolution
-        int stepsPerRev;
-        int currentStep;
-        uint32_t stepDelay;
-        uint32_t totalSteps;
-        MD_STEP_MODE_T stepMode;
-
-        // step direction: - 1 = forward, -1 = backward
-        int stepDirection;
-
-        // initialized?
-        bool initialized;
-
-    } *md_context;
-
-    /**
-     * MD initializer.
-     *
-     * @param bus I2C bus to use
-     * @param address I2C address to use
-     * @return Device context.
-     */
-    md_context md_init(int bus, uint8_t address);
-
-    /**
-     * MD close.
-     *
-     * @param dev Device context.
-     */
-    void md_close(md_context dev);
-
-    /**
-     * Composes and writes a 3-byte packet to the controller
-     *
-     * @param dev Device context.
-     * @param reg Register location
-     * @param data1 First byte of data
-     * @param data2 Second byte of data
-     * @return True if successful
-     */
-    bool md_write_packet(const md_context dev, MD_REG_T reg, uint8_t data1,
-                         uint8_t data2);
-
-    /**
-     * To control DC motors, sets the speed of motors A & B.
-     * Valid values are 0-255.
-     *
-     * @param dev Device context.
-     * @param speedA Speed of motor A
-     * @param speedB Speed of motor B
-     * @return True if successful
-     */
-    bool md_set_motor_speeds(const md_context dev, uint8_t speedA,
-                             uint8_t speedB);
-
-    /**
-     * To control DC motors, sets the PWM frequency prescale
-     * factor. Note: this register is not ducumented other than to say
-     * the default value is 0x03. Presumably, this is the timer
-     * prescale factor used on the ATMega MCU timer driving the PWM.
-     *
-     * @param dev Device context.
-     * @param freq PWM prescale frequency; default should be 0x03
-     * @return True if successful
-     */
-    bool md_set_pwm_frequency_prescale(const md_context dev, uint8_t freq);
-
-    /**
-     * To control DC motors, sets the directions of motors A & B
-     *
-     * @param dev Device context.
-     * @param dirA Direction for motor A, MD_DIR_CW or MD_DIR_CCW
-     * @param dirB Direction for motor B, MD_DIR_CW or MD_DIR_CCW
-     * @return True if successful
-     */
-    bool md_set_motor_directions(const md_context dev, MD_DC_DIRECTION_T dirA,
-                                 MD_DC_DIRECTION_T dirB);
-
-    /**
-     * To control a stepper motor, sets its direction and speed, and
-     * then starts operation.  For Mode2, this method will return
-     * immediately.  For Mode1 (the default) this method returns when
-     * the number of steps specified by md_set_stepper_steps() has
-     * completed.
-     *
-     * @param dev Device context.
-     * @param dir Direction, MD_STEP_DIR_CW or MD_STEP_DIR_CCW
-     * @param speed Motor speed. Valid range is 1-255. For Mode 1
-     * (default), this specifies the speed in RPM's.  For Mode 2,
-     * speed is multiplied by 4ms by the board, so higher numbers
-     * will mean a slower speed.
-     * @return True if successful
-     */
-    bool md_enable_stepper(const md_context dev, MD_STEP_DIRECTION_T dir,
-                           uint8_t speed);
-
-    /**
-     * To control a stepper motor, stops the stepper motor.
-     *
-     * @param dev Device context.
-     * @return True if successful
-     */
-    bool md_disable_stepper(const md_context dev);
-
-    /**
-     * To control a stepper motor, specifies the number of steps to
-     * execute. For Mode2, valid values are between 1-255, 255 means
-     * continuous rotation.
-     *
-     * For Mode1 (the default) steps can be any positive integer.
-     *
-     * @param dev Device context.
-     * @param steps Number of steps to execute. 255 (only in Mode2)
-     * means continuous rotation.
-     * @return True if successful
-     */
-    bool md_set_stepper_steps(const md_context dev, unsigned int steps);
-
-    /**
-     * Configure the initial Stepper parameters.  This should be
-     * called before any other stepper method.
-     *
-     * @param dev Device context.
-     * @param stepsPerRev The number of steps required to complete one
-     * full revolution.
-     * @param mode The stepper operating mode.  MD_STEP_MODE1 is more
-     * flexible, and is handled directly by this driver.
-     * MD_STEP_MODE2 is handled completely by the MCU on board the
-     * motor driver, but is much more restrictive and requires updated
-     * firmware.  We generally recommend MODE1.
-     */
-    void md_config_stepper(const md_context dev, unsigned int stepsPerRev,
-                           MD_STEP_MODE_T mode);
-
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/md/md.hpp b/src/md/md.hpp
deleted file mode 100644
index de2ecda..0000000
--- a/src/md/md.hpp
+++ /dev/null
@@ -1,193 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014-2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-
-#include <md.h>
-
-namespace upm {
-    /**
-     * @brief I2C Motor Driver
-     * @defgroup md libupm-md
-     * @ingroup seeed i2c motor robok
-     */
-
-    /**
-     * @library md
-     * @sensor md
-     * @comname I2C Motor Driver
-     * @altname Grove Motor Driver
-     * @type motor
-     * @man seeed
-     * @con i2c
-     * @web http://wiki.seeed.cc/Grove-I2C_Motor_Driver_V1.3/
-     * @kit robok
-     *
-     * @brief API for the I2C Motor Driver
-     *
-     * This class implements support for the I2C Motor Driver.
-     * This device can support a single 4-wire stepper motor, or two
-     * 2-wire DC motors. The device contains an Atmel* ATmega8L
-     * microcontroller that manages an L298N H-bridge driver chip.
-     *
-     * This device supports an I2C bus speed of 100Khz only.
-     *
-     * The module does not provide any telemetry or status - it only
-     * accepts I2C commands for its various operations.
-     *
-     * This module was tested with version 1.3 of the I2C Motor
-     * Driver.
-     *
-     * For stepper operation, this driver can run in one of two modes -
-     * Mode 1, where this driver handles the stepping operation, and
-     * Mode 2, where this driver simply sends commands to the
-     * Motor Driver, and it handles the stepping operation.  Mode2
-     * requires updated (and working) firmware to be loaded onto the
-     * device.
-     *
-     * The default stepper operation mode is Mode1, which is generally
-     * more flexible and is supported on all firmware revisions.
-     *
-     * @image html md.jpg
-     * An example showing the use of a DC motor
-     * @snippet md.cxx Interesting
-     * An example showing the use of a 4-wire stepper
-     * @snippet md-stepper.cxx Interesting
-     */
-    class MD {
-
-    public:
-        /**
-         * MD constructor
-         *
-         * @param bus I2C bus to use
-         * @param address I2C address to use
-         */
-        MD(int bus=MD_I2C_BUS, uint8_t address=MD_DEFAULT_I2C_ADDR);
-
-        /**
-         * MD destructor
-         */
-        ~MD();
-
-        /**
-         * Composes and writes a 3-byte packet to the controller
-         *
-         * @param reg Register location
-         * @param data1 First byte of data
-         * @param data2 Second byte of data
-         * @return True if successful
-         */
-        bool writePacket(MD_REG_T reg, uint8_t data1, uint8_t data2);
-
-        /**
-         * To control DC motors, sets the speed of motors A & B.
-         * Valid values are 0-255.
-         *
-         * @param speedA Speed of motor A
-         * @param speedB Speed of motor B
-         * @return True if successful
-         */
-        bool setMotorSpeeds(uint8_t speedA, uint8_t speedB);
-
-        /**
-         * To control DC motors, sets the PWM frequency prescale
-         * factor. Note: this register is not ducumented other than to say
-         * the default value is 0x03. Presumably, this is the timer
-         * prescale factor used on the ATMega MCU timer driving the PWM.
-         *
-         * @param freq PWM prescale frequency; default is 0x03
-         * @return True if successful
-         */
-        bool setPWMFrequencyPrescale(uint8_t freq=0x03);
-
-        /**
-         * To control DC motors, sets the directions of motors A & B
-         *
-         * @param dirA Direction for motor A, DIR_CW or DIR_CCW
-         * @param dirB Direction for motor B, DIR_CW or DIR_CCW
-         * @return True if successful
-         */
-        bool setMotorDirections(MD_DC_DIRECTION_T dirA, MD_DC_DIRECTION_T dirB);
-
-        /**
-         * To control a stepper motor, sets its direction and speed, and
-         * then starts operation.  For Mode2, this method will return
-         * immediately.  For Mode1 (the default) this method returns when
-         * the number of steps specified by setStepperSteps() has
-         * completed.
-         *
-         * @param dir Direction, STEP_DIR_CW or STEP_DIR_CCW
-         * @param speed Motor speed. Valid range is 1-255. For Mode 1
-         * (default), this specifies the speed in RPM's.  For Mode 2,
-         * speed is multiplied by 4ms by the board, so higher numbers
-         * will mean a slower speed.
-         * @return True if successful
-         */
-        bool enableStepper(MD_STEP_DIRECTION_T dir, uint8_t speed);
-
-        /**
-         * To control a stepper motor, stops the stepper motor.
-         *
-         * @return True if successful
-         */
-        bool disableStepper();
-
-        /**
-         * To control a stepper motor, specifies the number of steps to
-         * execute. For Mode2, valid values are between 1-255, 255 means
-         * continuous rotation.
-         *
-         * For Mode1 (the default) steps can be any positive integer.
-         *
-         * @param steps Number of steps to execute. 255 (only in Mode2)
-         * means continuous rotation.
-         * @return True if successful
-         */
-        bool setStepperSteps(unsigned int steps);
-
-        /**
-         * Configure the initial Stepper parameters.  This should be
-         * called before any other stepper method.
-         *
-         * @param stepsPerRev The number of steps required to complete one
-         * full revolution.
-         * @param mode The stepper operating mode, default STEP_MODE1
-         * @return Elapsed milliseconds
-         */
-        void configStepper(unsigned int stepsPerRev,
-                           MD_STEP_MODE_T mode=MD_STEP_MODE1);
-
-    protected:
-        md_context m_md;
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        MD(const MD&) = delete;
-        MD &operator=(const MD&) = delete;
-    };
-}
-
-
diff --git a/src/md/md.i b/src/md/md.i
deleted file mode 100644
index 40daf82..0000000
--- a/src/md/md.i
+++ /dev/null
@@ -1,16 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_md)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "md_defs.h"
-#include "md.hpp"
-%}
-%include "md_defs.h"
-%include "md.hpp"
-/* END Common SWIG syntax */
diff --git a/src/md/md.json b/src/md/md.json
deleted file mode 100644
index acddb95..0000000
--- a/src/md/md.json
+++ /dev/null
@@ -1,53 +0,0 @@
-{
-    "Library": "md",
-    "Description": "I2C Motor Driver library",
-    "Sensor Class": {
-        "MD": {
-            "Name": "Grove I2C Motor Driver",
-            "Description": "This class implements support for the I2C Motor Driver. This device can support a single 4-wire stepper motor, or two 2-wire DC motors. The device contains an Atmel* ATmega8L microcontroller that manages an L298N H-bridge driver chip. This device supports an I2C bus speed of 100Khz only. The module does not provide any telemetry or status - it only accepts I2C commands for its various operations. This module was tested with version 1.3 of the I2C Motor Driver. For stepper operation, this driver can run in one of two modes - Mode 1, where this driver handles the stepping operation, and Mode 2, where this driver simply sends commands to the Motor Driver, and it handles the stepping operation. Mode2 requires updated (and working) firmware to be loaded onto the device. The default stepper operation mode is Mode1, which is generally more flexible and is supported on all firmware revisions.",
-            "Aliases": ["Grove - I2C Motor Driver"],
-            "Categories": ["motor"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping", "robotics"],
-            "Manufacturers": ["Seeed"],
-            "Kits": ["robok"],
-            "Image": "md.jpg",
-            "Examples": {
-                "Java": ["GroveMD_Example.java"],
-                "Python": ["grovemd-stepper.py", "grovemd.py"],
-                "Node.js": ["md-stepper.js", "md.js"],
-                "C++": ["md-stepper.cxx", "md.cxx"],
-                "C": ["md-stepper.c", "md.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.3,
-                    "max": 5.0
-                },
-                "Supply Current": {
-                    "unit": "A",
-                    "min" : 0.5,
-                    "max" : 4
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Requires Grove Shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Requires Grove Shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-I2C-Motor-Driver-p-907.html"],
-                "Datasheets": ["http://wiki.seeed.cc/Grove-I2C_Motor_Driver_V1.3/"]
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/md/md_defs.h b/src/md/md_defs.h
deleted file mode 100644
index 30bfdcd..0000000
--- a/src/md/md_defs.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define MD_I2C_BUS 0
-#define MD_DEFAULT_I2C_ADDR 0x0f
-
-// This is a NOOP value used to pad packets
-#define MD_NOOP 0x01
-
-
-    // MD registers
-    typedef enum {
-        MD_REG_SET_SPEED           = 0x82,
-        MD_REG_SET_PWM_FREQ        = 0x84,
-        MD_REG_SET_DIRECTION       = 0xaa,
-        MD_REG_SET_MOTOR_A         = 0xa1, // not documented
-        MD_REG_SET_MOTOR_B         = 0xa5, // not documented
-        MD_REG_STEPPER_ENABLE      = 0x1a,
-        MD_REG_STEPPER_DISABLE     = 0x1b,
-        MD_REG_STEPPER_NUM_STEPS   = 0x1c
-    } MD_REG_T;
-
-    // legal directions for the stepper
-    typedef enum {
-        MD_STEP_DIR_CCW    = 0x01,
-        MD_STEP_DIR_CW     = 0x00
-    } MD_STEP_DIRECTION_T;
-
-    // legal directions for individual DC motors
-    typedef enum {
-        MD_DIR_CCW    = 0x02,
-        MD_DIR_CW     = 0x01
-    } MD_DC_DIRECTION_T;
-
-    // stepper modes
-    typedef enum {
-        MD_STEP_MODE1 = 0x00,
-        MD_STEP_MODE2 = 0x01
-    } MD_STEP_MODE_T;
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/mg811/CMakeLists.txt b/src/mg811/CMakeLists.txt
deleted file mode 100644
index 1709499..0000000
--- a/src/mg811/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "mg811")
-set (libdescription "CO2 Sensor")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/mg811/mg811.cxx b/src/mg811/mg811.cxx
deleted file mode 100644
index 8330f88..0000000
--- a/src/mg811/mg811.cxx
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Thanks to public domain code by Martin Liddament for some useful clues!
- * http://www.veetech.org.uk/CO2_Monitor_Sketch_2_Operation.txt
- * and sandbox electronics (http://sandboxelectronics.com/?p=147).
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <math.h>
-#include "mg811.hpp"
-
-using namespace std;
-using namespace upm;
-
-// voltage gain of the DC amplifier
-static const float dcGain = 8.5;
-
-MG811::MG811(int pin, int dpin, float aref) :
-  m_aio(pin), m_gpio(dpin)
-{
-  m_aRes = m_aio.getBit();
-  m_aref = aref;
-
-  m_gpio.dir(mraa::DIR_IN);
-
-  // these are just placeholder values (coarsely measured during
-  // development), you should determine the appropriate values (in
-  // volts) for your environment at the specified concentrations.  Use
-  // the getReferenceVoltage() method to get these values at 400ppm
-  // and 1000ppm respectively.  Good luck.
-  setCalibration(0.5514, 0.370);
-}
-
-MG811::~MG811()
-{
-}
-
-float MG811::volts()
-{
-  int val = m_aio.read();
-
-  return(float(val) * (m_aref / float(1 << m_aRes)));
-}
-
-void MG811::setCalibration(float ppm400, float ppm1000)
-{
-  m_zeroPointValue = ppm400;
-  m_reactionValue = ppm1000;
-}
-
-float MG811::getReferenceVoltage()
-{
-  return (volts() / dcGain);
-}
-
-float MG811::ppm()
-{
-  static const float log400 = log10f(400);
-  static const float log1000 = log10f(1000);
-
-  float val = volts();
-
-  if ((val / dcGain) >= m_zeroPointValue)
-    return 0.0;
-  else
-    return powf(10.0, ((val/dcGain)-m_zeroPointValue) / 
-                      (m_reactionValue / (log400-log1000))+log400);
-}
-
-bool MG811::thresholdReached()
-{
-  return (m_gpio.read() ? true : false);
-}
diff --git a/src/mg811/mg811.hpp b/src/mg811/mg811.hpp
deleted file mode 100644
index ae26d44..0000000
--- a/src/mg811/mg811.hpp
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <iostream>
-#include <string>
-#include <mraa/aio.hpp>
-#include <mraa/gpio.hpp>
-
-namespace upm {
-  /**
-   * @brief MG811 CO2 Sensor
-   * @defgroup mg811 libupm-mg811
-   * @ingroup dfrobot analog gaseous
-   */
-
-  /**
-   * @library mg811
-   * @sensor mg811
-   * @comname CO2 Sensor
-   * @altname MG811
-   * @type gaseous
-   * @man dfrobot
-   * @web http://www.dfrobot.com/index.php?route=product/product&product_id=1023
-   * @con analog
-   *
-   * @brief API for the DFRobot CO2 Sensor
-   *
-   * This sensor returns an an analog voltage that falls as the
-   * concentration of CO2 increases.  It contains a heater that must
-   * be allowed to 'warm' up the sensor before measurements are stable
-   * (hours to days is the recommendation).  It requires that the MCU
-   * be powered from an external power supply (not USB) at 5v, since
-   * the heater will consume significant current.
-   *
-   * The sensor should be allowed to 'heat' up for some time before
-   * beginning use, typically a couple of hours minimum.  It also
-   * needs fairly precise calibration at 400ppm and 1000ppm to return
-   * meaningful results.
-   *
-   * The sensor also incorporates a potentiometer that can be adjusted
-   * to specific threshold.  Once that threshold is reached, an LED
-   * on the sensor will light, and the digital pin will be driven
-   * high.
-   *
-   * @image html mg811.jpg
-   * @snippet mg811.cxx Interesting
-   */
-
-  class MG811 {
-  public:
-
-    /**
-     * MG811 constructor
-     *
-     * @param pin Analog pin to use
-     * @param dpin Digital pin that indicates threshold
-     * @param aref Analog reference voltage; default is 5.0 V
-     */
-    MG811(int pin, int dpin, float aref=5.0);
-
-    /**
-     * MG811 destructor
-     */
-    ~MG811();
-
-    /**
-     * Return a cumputed reference voltage to be used in calibration.
-     * @return Computed reference voltage
-     */
-    float getReferenceVoltage();
-
-    /**
-     * Set calibration parameters.  You should measure the reference
-     * voltage you get when at CO2 concentrations of 400ppm (ambient)
-     * and 1000ppm using the getReferenceVoltage() method.  Then
-     * specify those voltages here for more accurate results.
-     *
-     * @param ppm400 The measured reference voltage at 400 ppm
-     * @param ppm1000 The measured reference voltage at 1000 ppm
-     */
-    void setCalibration(float ppm400, float ppm1000);
-
-    /**
-     * Returns the voltage detected on the analog pin
-     *
-     * @return The detected voltage
-     */
-    float volts();
-
-    /**
-     * Returns the computed CO2 concentration in ppm (Parts Per
-     * Million).  This method will return 0.0 if the reference voltage
-     * is greater than the ppm400 value.  Essentially, ppm values
-     * below 400 will be reported as 0.
-     *
-     * @return The computed CO2 concentration in ppm
-     */
-    float ppm();
-
-    /**
-     * Read the digital pin and return true if the set threshold has
-     * been reached or exceeded.  This threshold is set by adjusting
-     * the potentiometer on the sensor.
-     *
-     * @return true if the threshold has been reached, false otherwise
-     */
-    bool thresholdReached();
-
-  protected:
-    mraa::Aio m_aio;
-    mraa::Gpio m_gpio;
-
-    // calibration values
-    float m_zeroPointValue;
-    float m_reactionValue;
-
-    // ADC resolution
-    int m_aRes;
-
-  private:
-    float m_aref;
-  };
-}
-
-
diff --git a/src/mg811/mg811.json b/src/mg811/mg811.json
deleted file mode 100644
index 856a576..0000000
--- a/src/mg811/mg811.json
+++ /dev/null
@@ -1,54 +0,0 @@
-{
-    "Library": "mg811",
-    "Description": "API for the DFRobot CO2 Sensor",
-    "Sensor Class": {
-        "MG811": {
-            "Name": "DFRobot CO2 Sensor",
-            "Description": "This sensor returns an an analog voltage that falls as the concentration of CO2 increases.  It contains a heater that must be allowed to 'warm' up the sensor before measurements are stable (hours to days is the recommendation).  It requires that the MCU be powered from an external power supply (not USB) at 5v, since the heater will consume significant current. The sensor should be allowed to 'heat' up for some time before beginning use, typically a couple of hours minimum.  It also needs fairly precise calibration at 400ppm and 1000ppm to return meaningful results. The sensor also incorporates a potentiometer that can be adjusted to specific threshold.  Once that threshold is reached, an LED on the sensor will light, and the digital pin will be driven high.",
-            "Aliases": ["mg811", "Gravity: Analog CO2 Gas Sensor For Arduino"],
-            "Categories": ["gaseous"],
-            "Connections": ["analog"],
-            "Project Type": ["prototype", "industrial", "commercial"],
-            "Manufacturers": ["dfrobot"],
-            "Image": "mg811.jpg",
-            "Examples": {
-                "Python": ["mg811.py"],
-                "Node.js": ["mg811.js"],
-                "C++": ["mg811.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 0,
-                    "max": 5.0
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "typ" : 200
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -20,
-                    "max": 50
-                },
-                "Effective Range": {
-                    "unit": "ppm",
-                    "min" : "350",
-                    "max" : "10,000"
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Requires the Gravity: IO Expansion Shield for Arduino V7.1"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Requires the Gravity: IO Expansion Shield for Arduino V7.1"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.dfrobot.com/product-1023.html"],
-                "Datasheets": ["http://image.dfrobot.com/image/data/SEN0159/CO2b%20MG811%20datasheet.pdf"]
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/mhz16/CMakeLists.txt b/src/mhz16/CMakeLists.txt
deleted file mode 100644
index 66373a6..0000000
--- a/src/mhz16/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "mhz16")
-set (libdescription "CO2 Sensor")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/mhz16/mhz16.cxx b/src/mhz16/mhz16.cxx
deleted file mode 100644
index 9809617..0000000
--- a/src/mhz16/mhz16.cxx
+++ /dev/null
@@ -1,262 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "mhz16.hpp"
-
-using namespace upm;
-using namespace std;
-
-static const int defaultDelay = 100;     // max wait time for read
-
-MHZ16::MHZ16(int uart)
-{
-  m_ttyFd = -1;
-
-  if ( !(m_uart = mraa_uart_init(uart)) )
-    {
-      throw std::invalid_argument(std::string(__FUNCTION__) +
-                                  ": mraa_uart_init() failed");
-    }
-
-  // This requires a recent MRAA (1/2015)
-  const char *devPath = mraa_uart_get_dev_path(m_uart);
-
-  if (!devPath)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": mraa_uart_get_dev_path() failed");
-    }
-
-  // now open the tty
-  if ( (m_ttyFd = open(devPath, O_RDWR)) == -1)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": open of " +
-                               string(devPath) + " failed: " +
-                               string(strerror(errno)));
-    }
-}
-
-MHZ16::MHZ16(const std::string& uart_raw)
-{
-  m_ttyFd = -1;
-
-  if ( !(m_uart = mraa_uart_init_raw(uart_raw.c_str())) )
-    {
-      throw std::invalid_argument(std::string(__FUNCTION__) +
-                                  ": mraa_uart_init_raw() failed");
-    }
-
-  // This requires a recent MRAA (1/2015)
-  const char *devPath = mraa_uart_get_dev_path(m_uart);
-
-  if (!devPath)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": mraa_uart_get_dev_path() failed");
-    }
-
-  // now open the tty
-  if ( (m_ttyFd = open(devPath, O_RDWR)) == -1)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": open of " +
-                               string(devPath) + " failed: " +
-                               string(strerror(errno)));
-    }
-}
-
-MHZ16::~MHZ16()
-{
-  if (m_ttyFd != -1)
-    close(m_ttyFd);
-
-  mraa_deinit();
-}
-
-bool MHZ16::dataAvailable(unsigned int millis)
-{
-  if (m_ttyFd == -1)
-    return false;
-
-  struct timeval timeout;
-
-  // no waiting
-  timeout.tv_sec = 0;
-  timeout.tv_usec = millis * 1000;
-
-  fd_set readfds;
-
-  FD_ZERO(&readfds);
-
-  FD_SET(m_ttyFd, &readfds);
-
-  if (select(m_ttyFd + 1, &readfds, NULL, NULL, &timeout) > 0)
-    return true;                // data is ready
-
-  return false;
-}
-
-int MHZ16::readData(char *buffer, int len)
-{
-  if (m_ttyFd == -1)
-    return(-1);
-
-  if (!dataAvailable(defaultDelay))
-    return 0;               // timed out
-
-  int rv = read(m_ttyFd, buffer, len);
-
-  if (rv < 0)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": read() failed: " +
-                               string(strerror(errno)));
-    }
-
-  return rv;
-}
-
-int MHZ16::writeData(char *buffer, int len)
-{
-  if (m_ttyFd == -1)
-    return(-1);
-
-  // first, flush any pending but unread input
-  tcflush(m_ttyFd, TCIFLUSH);
-
-  int rv = write(m_ttyFd, buffer, len);
-
-  if (rv < 0)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": write() failed: " +
-                               string(strerror(errno)));
-    }
-
-  tcdrain(m_ttyFd);
-
-  return rv;
-}
-
-bool MHZ16::setupTty(speed_t baud)
-{
-  if (m_ttyFd == -1)
-    return(false);
-
-  struct termios termio;
-
-  // get current modes
-  tcgetattr(m_ttyFd, &termio);
-
-  // setup for a 'raw' mode.  81N, no echo or special character
-  // handling, such as flow control.
-  cfmakeraw(&termio);
-
-  // set our baud rates
-  cfsetispeed(&termio, baud);
-  cfsetospeed(&termio, baud);
-
-  // make it so
-  if (tcsetattr(m_ttyFd, TCSAFLUSH, &termio) < 0)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": tcsetattr() failed: " +
-                               string(strerror(errno)));
-    }
-
-  return true;
-}
-
-bool MHZ16::verifyPacket(uint8_t *pkt, int len)
-{
-  if (pkt[0] != 0xff || pkt[1] != 0x86)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": invalid packet header received");
-    }
-
-  return true;
-}
-
-bool MHZ16::getData()
-{
-  // the query command
-  const unsigned char cmd[9] =
-    {0xff, 0x01, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79};
-
-  writeData((char *)cmd, 9);
-
-  // wait up to one second for a response
-  if (!dataAvailable(1000))
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": Timed out waiting for response");
-    }
-
-  // read the packet
-  unsigned char packet[9];
-  int rv;
-
-  if ((rv = readData((char *)packet, 9)) != 9)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": Invalid packet size read");
-    }
-
-  // will throw an exception if it fails
-  verifyPacket(packet, sizeof(packet));
-
-  // pull out the data and return it.
-  gas = (packet[2] << 8) | packet[3];
-  temp = packet[4] - 40;
-
-  return true;
-}
-
-int MHZ16::getGas()
-{
-  return gas;
-}
-
-int MHZ16::getTemperature()
-{
-  return temp;
-}
-
-void MHZ16::calibrateZeroPoint()
-{
-  // the query command
-  const unsigned char cmd[9] =
-    {0xff, 0x01, 0x87, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78};
-
-  writeData((char *)cmd, 9);
-
-  // no response
-}
-
diff --git a/src/mhz16/mhz16.hpp b/src/mhz16/mhz16.hpp
deleted file mode 100644
index 435195e..0000000
--- a/src/mhz16/mhz16.hpp
+++ /dev/null
@@ -1,179 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <iostream>
-
-#include <stdint.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-#include <fcntl.h>
-#include <errno.h>
-#include <termios.h>
-#include <sys/time.h>
-#include <sys/select.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-
-#include <mraa/uart.h>
-
-namespace upm {
-    /**
-     * @brief MHZ16 Serial CO2 Sensor
-     * @defgroup mhz16 libupm-mhz16
-     * @ingroup seeed uart gaseous
-     */
-
-    /**
-     * @library mhz16
-     * @sensor mhz16
-     * @comname CO2 Sensor
-     * @altname MHZ16 Serial CO2 Sensor
-     * @type gaseous
-     * @man seeed
-     * @con uart
-     * @web http://wiki.seeed.cc/Grove-CO2_Sensor/
-     *
-     * @brief API support for the Grove CO2 sensor
-     *
-     * This class implements support for the Grove CO2 sensor.
-     *
-     * Its CO2 detection range is 0-2,000 ppm. It requires a
-     * 2-3 minute warm-up time before reporting valid data.
-     *
-     * @image html mhz16.jpg
-     * @snippet mhz16.cxx Interesting
-     */
-  class MHZ16 {
-  public:
-
-
-    /**
-     * MHZ16 constructor
-     *
-     * @param uart Default mraa UART index to use
-     */
-    MHZ16(int uart);
-
-    /**
-     * MHZ16 constructor
-     *
-     * @param uart_raw Full path to UART device.
-     */
-     MHZ16(const std::string& uart_raw = "/dev/ttyS0");
-
-    /**
-     * MHZ16 destructor
-     */
-    virtual ~MHZ16();
-
-    /**
-     * Checks to see if there is data available for reading
-     *
-     * @param millis Number of milliseconds to wait; 0 means no waiting.
-     * @return True if there is data available for reading
-     */
-    bool dataAvailable(unsigned int millis);
-
-    /**
-     * Reads any available data in a user-supplied buffer. Note: the
-     * call blocks until data is available to be read. Use
-     * dataAvailable() to determine whether there is data available
-     * beforehand, to avoid blocking.
-     *
-     * @param buffer Buffer to hold the data read
-     * @param len Length of the buffer
-     * @return Number of bytes read
-     */
-    int readData(char *buffer, int len);
-
-    /**
-     * Writes the data in the buffer to the device
-     *
-     * @param buffer Buffer to hold the data read
-     * @param len Length of the buffer
-     * @return Number of bytes written
-     */
-    int writeData(char *buffer, int len);
-
-    /**
-     * Sets up proper tty I/O modes and the baud rate. The default
-     * baud rate is 9,600 (B9600).
-     *
-     * @param baud Desired baud rate.
-     * @return True if successful
-     */
-    bool setupTty(speed_t baud=B9600);
-
-    /**
-     * Verifies the packet header and indicates its validity
-     *
-     * @param pkt Packet to check
-     * @return True if the checksum is valid, false otherwise
-     */
-    bool verifyPacket(uint8_t *pkt, int len);
-
-    /**
-     * Queries the sensor and gets the gas (CO2) concentration and
-     * temperature data.
-     * Should be called before other "get" functions.
-     *
-     * @return True if successful
-     */
-    bool getData();
-
-    /**
-     * Returns the gas (CO2) concentration data.
-     *
-     * @return Gas concentration
-     */
-    int getGas();
-
-    /**
-     * Returns the temperature data.
-     *
-     * @return Temperature in Celsius
-     */
-    int getTemperature();
-
-    /**
-     * Sets the zero point of the sensor
-     *
-     */
-    void calibrateZeroPoint();
-
-  protected:
-    int ttyFd() { return m_ttyFd; };
-
-  private:
-    mraa_uart_context m_uart;
-    int m_ttyFd = 0;
-    int gas = 0;
-    int temp = 0;
-  };
-}
-
-
diff --git a/src/mhz16/mhz16.i b/src/mhz16/mhz16.i
deleted file mode 100644
index 4f3dca0..0000000
--- a/src/mhz16/mhz16.i
+++ /dev/null
@@ -1,23 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "arrays_java.i";
-%include "../java_buffer.i"
-
-%apply int *OUTPUT { int *gas, int *temp };
-
-JAVA_JNI_LOADLIBRARY(javaupm_mhz16)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%pointer_functions(int, intp);
-
-%{
-#include "mhz16.hpp"
-speed_t int_B9600 = B9600;
-%}
-%include "mhz16.hpp"
-speed_t int_B9600 = B9600;
-/* END Common SWIG syntax */
diff --git a/src/mhz16/mhz16.json b/src/mhz16/mhz16.json
deleted file mode 100644
index ee99473..0000000
--- a/src/mhz16/mhz16.json
+++ /dev/null
@@ -1,73 +0,0 @@
-{
-    "Library": "mhz16",
-    "Description": "MHZ16 Serial CO2 Sensor library",
-    "Sensor Class": {
-        "MHZ16": {
-            "Name": "MHZ16 Serial CO2 Sensor library",
-            "Description": "This is the UPM Module for the Seeed/Zhengzhou Winsen Electronics Technology MHZ16 Serial CO2 Sensor. This class implements support for the Grove CO2 sensor. Its CO2 detection range is 0-2,000 ppm. It requires a 2-3 minute warm-up time before reporting valid data.",
-            "Aliases": ["Grove - CO2 Sensor", "MH-Z16 Intelligent Infrared Gas Module"],
-            "Categories": ["gaseous"],
-            "Connections": ["uart"],
-            "Project Type": ["industrial", "commercial"],
-            "Manufacturers": ["Seeed", "Zhengzhou Winsen Electronics Technology"],
-            "Image": "mhz16.jpg",
-            "Examples": {
-                "Java" : ["MHZ16_Example.java"],
-                "Python": ["mhz16.py"],
-                "Node.js": ["mhz16.js"],
-                "C++": ["mhz16.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 4.5,
-                    "max": 6.0
-                },
-                "Supply Current":{
-                    "unit": "mA",
-                    "min": "50",
-                    "max": "100"
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": 0,
-                    "max": 50
-                },
-                "Response Time": {
-                    "unit": "s",
-                    "time": "<90"
-                },
-                "Warm-up Time": {
-                    "unit": "minute",
-                    "time": 3
-                },
-                "Effective Range":{
-                    "unit": "ppm",
-                    "min" : 0,
-                    "max" : 2000
-                },
-                "Accuracy": {
-                    "unit": "ppm",
-                    "accuracy": 200
-                },
-                "Operating Humidity": {
-                    "unit": "RH",
-                    "min" : "0%",
-                    "max" : "90%"
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Requires Grove Arduino breakout board"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Requires Grove Arduino breakout board"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-CO2-Sensor-p-1863.html"],
-                "Datasheets": ["http://wiki.seeed.cc/Grove-CO2_Sensor/", "https://raw.githubusercontent.com/SeeedDocument/Grove-CO2_Sensor/master/res/MH-Z16_CO2_datasheet_EN.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/mic/CMakeLists.txt b/src/mic/CMakeLists.txt
deleted file mode 100644
index b9ecde3..0000000
--- a/src/mic/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-upm_mixed_module_init (NAME mic
-    DESCRIPTION "Simple Analog Microphone"
-    C_HDR mic.h
-    C_SRC mic.c
-    CPP_HDR mic.hpp
-    CPP_SRC mic.cxx
-    FTI_SRC mic_fti.c
-    REQUIRES mraa)
diff --git a/src/mic/mic.c b/src/mic/mic.c
deleted file mode 100644
index c6b7c35..0000000
--- a/src/mic/mic.c
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Author: Brendan Le Foll <brendan.le.foll@intel.com>
- * 	   Sisinty Sasmita Patra <sisinty.s.patra@intel.com>
- * 	   
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "mic.h"
-
-mic_context upm_mic_init(int pin)
-{
-    mic_context dev = (mic_context)malloc(sizeof(struct _mic_context));
-
-    if(dev == NULL) return NULL;
-
-    dev->analog_pin = pin;
-    dev->aio = mraa_aio_init(dev->analog_pin);
-
-    if(dev->aio == NULL)
-    {
-        printf("unable to initialize the AIO pin");
-        free(dev);
-        return NULL;
-    }
-
-    return dev;
-}
-
-void mic_close(mic_context dev)
-{
-    mraa_aio_close(dev->aio);
-    free(dev);
-}
-
-upm_result_t mic_get_value(mic_context dev, float *micval)
-{
-    *micval =  mraa_aio_read(dev->aio);
-    return UPM_SUCCESS;
-}
diff --git a/src/mic/mic.cxx b/src/mic/mic.cxx
deleted file mode 100644
index 9928335..0000000
--- a/src/mic/mic.cxx
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Author: Brendan Le Foll <brendan.le.foll@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-#include <unistd.h>
-#include <stdlib.h>
-#include <functional>
-#include <string.h>
-#include "mic.hpp"
-
-using namespace upm;
-
-Microphone::Microphone(int micPin) {
-    // initialise analog mic input
-    
-    if ( !(m_micCtx = mraa_aio_init(micPin)) ) 
-      {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_aio_init() failed, invalid pin?");
-        return;
-      }
-}
-
-Microphone::~Microphone() {
-    // close analog input
-    mraa_result_t error;
-    error = mraa_aio_close(m_micCtx);
-    if (error != MRAA_SUCCESS) {
-        mraa_result_print(error);
-    }
-}
-
-int
-Microphone::getSampledWindow (unsigned int freqMS, int numberOfSamples,
-                            uint16_t * buffer) {
-    int sampleIdx = 0;
-
-    // must have freq
-    if (!freqMS) {
-        return 0;
-    }
-
-    // too much samples
-    if (numberOfSamples > 0xFFFFFF) {
-        return 0;
-    }
-
-    while (sampleIdx < numberOfSamples) {
-        int x = mraa_aio_read (m_micCtx);
-        if (x == -1) {
-            return 0;
-        }
-        buffer[sampleIdx++] = x;
-        usleep(freqMS * 1000);
-    }
-
-    return sampleIdx;
-}
-
-int
-Microphone::findThreshold (thresholdContext* ctx, unsigned int threshold,
-                                uint16_t * buffer, int len) {
-    long sum = 0;
-    for (int i = 0; i < len; i++) {
-        sum += buffer[i];
-    }
-
-    ctx->averageReading = sum / len;
-    ctx->runningAverage = (((ctx->averagedOver-1) * ctx->runningAverage) + ctx->averageReading) / ctx->averagedOver;
-
-    if (ctx->runningAverage > threshold) {
-        return ctx->runningAverage;
-    } else {
-        return 0;
-    }
-}
-
-void
-Microphone::printGraph (thresholdContext* ctx) {
-    for (unsigned int i = 0; i < ctx->runningAverage; i++)
-        std::cout << ".";
-    std::cout << std::endl;
-}
diff --git a/src/mic/mic.h b/src/mic/mic.h
deleted file mode 100644
index c9cce97..0000000
--- a/src/mic/mic.h
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Author: Brendan Le Foll <brendan.le.foll@intel.com>
- * 	   Sisinty Sasmita Patra <sisinty.s.patra@intel.com>
- *
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef MIC_H_
-#define MIC_H_
-
-#pragma once
-#include <stdlib.h>
-#include <unistd.h>
-
-#include "upm.h"
-#include "mraa/aio.h"
-
-/**
- * @file mic.h
- * @library mic
- * @brief C API for the Analog Microphone
- *
- * @include mic.c
- */
-
-/**
- * device context
- */
-typedef struct _mic_context {
-    mraa_aio_context aio;
-    uint16_t analog_pin;
-} *mic_context;
-
-/**
- * Microphone sensor initialization function
- *
- * @param pin analog pin to use
- * @return sensor context
- */
-mic_context mic_init(int pin);
-
-/**
- * Microphone sensor destructor
- *
- * @param dev sensor context pointer
- */
-void mic_close(mic_context dev);
-
-/**
- * Gets a sample from the microphone
- *
- * @param dev sensor context pointer
- * @param micval microphone value in ADC counts
- * @return result of the operation
- */
-upm_result_t mic_get_value(mic_context dev, float* micval);
-
-#endif /* MIC_H_ */
diff --git a/src/mic/mic.hpp b/src/mic/mic.hpp
deleted file mode 100644
index 25e9976..0000000
--- a/src/mic/mic.hpp
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Author: Brendan Le Foll <brendan.le.foll@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/gpio.h>
-#include <mraa/aio.h>
-
-struct thresholdContext {
-    long averageReading;
-    unsigned long runningAverage;
-    int averagedOver;
-};
-
-namespace upm {
-
-/**
- * @brief Analog Microphone Library
- * @defgroup mic libupm-mic
- * @ingroup seeed pwm sound gsk
- */
-/**
- * @library mic
- * @sensor microphone
- * @comname Simple Analog Microphone
- * @altname Grove Sound Sensor
- * @type sound
- * @man seeed
- * @web http://www.seeedstudio.com/wiki/Grove_-_Sound_Sensor
- * @con analog
- * @kit gsk
- *
- * @brief API for the Analog Microphone
- *
- * This module defines the Analog Microphone sensor
- *
- * @image html mic.jpg
- * @snippet mic.cxx Interesting
- */
-class Microphone {
-    public:
-        /**
-         * Instantiates a Microphone object
-         *
-         * @param micPin Pin where the microphone is connected
-         */
-        Microphone(int micPin);
-
-        /**
-         * Microphone object destructor
-         */
-        ~Microphone();
-
-        /**
-         * Gets samples from the microphone according to the provided window and
-         * number of samples
-         *
-         * @param freqMS Time between each sample (in microseconds)
-         * @param numberOfSamples Number of sample to sample for this window
-         * @param buffer Buffer with sampled data
-         */
-        int getSampledWindow (unsigned int freqMS, int numberOfSamples, uint16_t * buffer);
-
-        /**
-         * Given the sampled buffer, this method returns TRUE/FALSE if threshold
-         * is reached
-         *
-         * @param ctx Threshold context
-         * @param threshold Sample threshold
-         * @param buffer Buffer with samples
-         * @param len Buffer length
-         */
-        int findThreshold (thresholdContext* ctx, unsigned int threshold, uint16_t * buffer, int len);
-
-        /**
-         *
-         * Prints a running average of the threshold context
-         *
-         * @param ctx Threshold context
-         */
-        void printGraph (thresholdContext* ctx);
-
-    private:
-        mraa_aio_context    m_micCtx;
-};
-
-}
diff --git a/src/mic/mic.i b/src/mic/mic.i
deleted file mode 100644
index 8a8eef6..0000000
--- a/src/mic/mic.i
+++ /dev/null
@@ -1,58 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "arrays_java.i"
-
-%typemap(jni) (uint16_t *buffer, int len) "jshortArray";
-%typemap(jtype) (uint16_t *buffer, int len) "short[]";
-%typemap(jstype) (uint16_t *buffer, int len) "short[]";
-
-%typemap(javain) (uint16_t *buffer, int len) "$javainput";
-
-%typemap(in) (uint16_t *buffer, int len) {
-        $1 = (uint16_t *) JCALL2(GetShortArrayElements, jenv, $input, NULL);
-        $2 = JCALL1(GetArrayLength, jenv, $input);
-}
-
-%typemap(freearg) (uint16_t *buffer, int len) {
-        JCALL3(ReleaseShortArrayElements, jenv, $input, (jshort *)$1, 0);
-}
-
-%typemap(jni) (int numberOfSamples, uint16_t *buffer) "jshortArray";
-%typemap(jtype) (int numberOfSamples, uint16_t *buffer) "short[]";
-%typemap(jstype) (int numberOfSamples, uint16_t *buffer) "short[]";
-
-%typemap(javain) (int numberOfSamples, uint16_t *buffer) "$javainput";
-
-%typemap(in) (int numberOfSamples, uint16_t *buffer) {
-        $2 = (uint16_t *) JCALL2(GetShortArrayElements, jenv, $input, NULL);
-        $1 = JCALL1(GetArrayLength, jenv, $input);
-}
-
-%typemap(freearg) (int numberOfSamples, uint16_t *buffer) {
-        JCALL3(ReleaseShortArrayElements, jenv, $input, (jshort *)$2, 0);
-}
-
-JAVA_JNI_LOADLIBRARY(javaupm_mic)
-#endif
-/* END Java syntax */
-
-/* BEGIN Javascript syntax  ------------------------------------------------- */
-#ifdef SWIGJAVASCRIPT
-%include "../carrays_uint16_t.i"
-#endif
-/* END Javascript syntax */
-
-/* BEGIN Python syntax  ----------------------------------------------------- */
-#ifdef SWIGPYTHON
-%include "../carrays_uint16_t.i"
-#endif
-/* END Python syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "mic.hpp"
-%}
-%include "mic.hpp"
-/* END Common SWIG syntax */
diff --git a/src/mic/mic.json b/src/mic/mic.json
deleted file mode 100644
index 51aa721..0000000
--- a/src/mic/mic.json
+++ /dev/null
@@ -1,31 +0,0 @@
-{
-    "Library": "mic",
-    "Description": "Generic analog microphone library",
-    "Sensor Class":
-    {
-        "Microphone":
-        {
-            "Name": "Analog Microphone",
-            "Description": "This module defines the Analog Microphone sensor.",
-            "Aliases": ["Grove - Sound Sensor"],
-            "Categories": ["sound"],
-            "Connections": ["analog"],
-            "Project Type": ["prototyping", "industrial"],
-            "Manufacturers": ["seeed", "dfrobot", "sparkfun", "adafruit", "generic"],
-            "Kits": ["gsk"],
-            "Image": "mic.jpg",
-            "Examples":
-            {
-                "Java": ["Microphone_Example.java"],
-                "Python": ["mic.py"],
-                "Node.js": ["mic.js"],
-                "C++": ["mic.cxx"]
-            },
-            "Urls" :
-            {
-                "Product Pages": ["http://www.seeedstudio.com/wiki/Grove_-_Sound_Sensor"],
-                "Schematics": ["https://github.com/SeeedDocument/Grove_Sound_Sensor/raw/master/res/Grove%20-%20Sound%20Sensor%20v1.6%20Schematic.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/mic/mic_fti.c b/src/mic/mic_fti.c
deleted file mode 100644
index 9d2b39b..0000000
--- a/src/mic/mic_fti.c
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Author: Brendan Le Foll <brendan.le.foll@intel.com>
- * 	   Sisinty Sasmita Patra <sisinty.s.patra@intel.com>
- * 	   
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "mic.h"
-#include "upm_fti.h"
-
-/** 
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_mic_name[] = "Microphone";
-const char upm_mic_description[] = "Analog Microphone";
-const upm_protocol_t upm_mic_protocol[] = {UPM_ANALOG};
-const upm_sensor_t upm_mic_category[] = {UPM_AUDIO};
-
-// forward declarations
-const upm_sensor_descriptor_t upm_mic_get_descriptor();
-const void* upm_mic_get_ft(upm_sensor_t sensot_type);
-void* upm_mic_init_name();
-void upm_mic_close(void* dev);
-upm_result_t upm_mic_get_value(void* dev, float* micval, upm_audio_u unit);
-
-const upm_sensor_descriptor_t upm_mic_get_descriptor() {
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_mic_name;
-    usd.description = upm_mic_description;
-    usd.protocol_size = 1;
-    usd.protocol = upm_mic_protocol;
-    usd.category_size = 1;
-    usd.category = upm_mic_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = &upm_mic_init_name,
-    .upm_sensor_close = &upm_mic_close,
-    .upm_sensor_get_descriptor = &upm_mic_get_descriptor
-};
-
-static const upm_audio_ft aft =
-{
-    .upm_audio_get_value = &upm_mic_get_value
-};
-
-const void* upm_mic_get_ft(upm_sensor_t sensor_type) {
-    if(sensor_type == UPM_SENSOR) {
-        return &ft;
-    }
-    if(sensor_type == UPM_AUDIO) {
-        return &aft;
-    }
-    return NULL;
-}
-
-void* upm_mic_init_name(){
-    return NULL;
-}
-
-void upm_mic_close(void* dev)
-{
-    mic_close((mic_context)dev);
-}
-
-upm_result_t upm_mic_get_value(void* dev, float *micval, upm_audio_u unit)
-{
-    return mic_get_value((mic_context)dev, micval);
-}
diff --git a/src/micsv89/CMakeLists.txt b/src/micsv89/CMakeLists.txt
deleted file mode 100644
index 9c9d126..0000000
--- a/src/micsv89/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "micsv89")
-set (libdescription "Low-power Air Quality Sensor")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/micsv89/micsv89.cxx b/src/micsv89/micsv89.cxx
deleted file mode 100644
index 602101a..0000000
--- a/src/micsv89/micsv89.cxx
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Author: Marc Graham <marc@m2ag.net>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-
-#include "micsv89.hpp"
-
-#include "mraa/i2c.hpp"
-
-using namespace upm;
-
-MICSV89::MICSV89 (int bus, uint8_t address) {
-    m_name = "micsv89";
-    m_valid = false;
-    m_address = address;
-    i2c = new mraa::I2c(bus);
-     if(i2c->address(m_address) != mraa::SUCCESS){
-      throw std::invalid_argument(std::string(__FUNCTION__) + ": I2c.address() failed");
-      return;
-    }
-    if(i2c->frequency(mraa::I2C_STD) != mraa::SUCCESS){
-      throw std::invalid_argument(std::string(__FUNCTION__) + ": I2c.frequency(I2C_STD) failed");
-      return;
-    }
-    tx_buf[0] = 0x09;
-    tx_buf[1] = 0x00;
-    tx_buf[2] = 0x00;
-}
-
-void MICSV89::update() {
-    m_valid = false;   
-    if(i2c->write(tx_buf, 3) != mraa::SUCCESS){
-      throw std::invalid_argument(std::string(__FUNCTION__) + ": I2c.write() failed");
-      return;
-    }
-    sleep(1); //Give the device time to make the measurement.
-    if(i2c->read(rx_buf, 6) != 6){
-      throw std::invalid_argument(std::string(__FUNCTION__) + ": I2c.read() failed");
-      return;
-    }
-    m_valid = true;
-}
-
-float MICSV89::co2equ() {
-    return ((rx_buf[0] - 13) * (1600/229) + 400);
-}
-
-int MICSV89::vocshort() {
-    return rx_buf[1];
-}
-
-float MICSV89::tvoc() {
-    return rx_buf[2] * (1000/229);
-}
-
-float MICSV89::resistor() {
-    return 10 * (rx_buf[3] + (256 * rx_buf[4]) + (65536 * rx_buf[5]));
-}
-
-MICSV89::~MICSV89() {
-    delete i2c;
-}
diff --git a/src/micsv89/micsv89.hpp b/src/micsv89/micsv89.hpp
deleted file mode 100644
index ca4d822..0000000
--- a/src/micsv89/micsv89.hpp
+++ /dev/null
@@ -1,131 +0,0 @@
-/*
- * Author: Marc Graham <marc@m2ag.net>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <iostream>
-#include <string>
-
-namespace mraa { class I2c;}
-
-namespace upm {
-  /**
-   * @brief MICS-VZ89 Environmental Sensor
-   * @defgroup micsv89 libupm-micsv89
-   * @ingroup generic i2c gaseous
-   */
-  /**
-   * @library micsv89
-   * @sensor micsv89
-   * @comname Low-power Air Quality Sensor
-   * @type gaseous
-   * @man generic
-   * @con i2c
-   * @web http://sgx.cdistore.com/datasheets/e2v/MiCS-VZ-86%20and%20VZ-89%20rev%204.pdf
-   * @web http://www.sgxsensortech.com/content/uploads/2015/01/MICS-VZ-89-I2C-specs-rev-A.pdf
-   *
-   * @brief API for the MICS-VZ89 Gas Sensor
-   *
-   * The MiCS-VZ-86/89 combines state-of-the-art MOS sensor technology with
-   * intelligent detection algorithms to monitor VOCs and CO2 equivalent
-   * variations in confined spaces.
-   *
-   * The MICSV89 comes in 4 variants, PWM and I2C in 3.3 volts and 5 volts.
-   * This library only implements the I2c version of the device.
-   *
-   * Device output is not valid until a warm up of 15 minutes of operation.
-   *
-   * @image html micsv89.jpg
-   * @snippet micsv89.cxx Interesting
-   */
-    class MICSV89 {
-        public:
-            /**
-             * MICSV89 constructor
-             *
-             * @param bus i2c bus the sensor is attached to.
-             * @param address Device address. Default is 0x70.
-             */
-            MICSV89 (int bus, uint8_t address = 0x70);
-
-            /**
-             * MICSV89 destructor
-             */
-            ~MICSV89 ();
-
-            /**
-             * Returns the name of the sensor
-             */
-            std::string name()
-            {
-                return m_name;
-            }
-
-            /**
-             * Returns the  CO2 equivalent value.
-             */
-            float co2equ();
-
-            /**
-             * Returns VOC Short value.
-             */
-            int vocshort();
-
-            /**
-             * Returns Total VOC.
-             */
-            float tvoc();
-
-            /**
-             * Returns resistor value.
-             */
-            float resistor();
-
-            /**
-             * Performs a write/read cycle.
-             */
-            void update();
-
-            /**
-             * Returns true if a valid write/read cycle has been completed.
-             * At startup and during write/read cycle will be false.
-             */
-            bool valid()
-            {
-                return m_valid;
-            }
-
-        private:
-            /* Disable implicit copy and assignment operators */
-            MICSV89(const MICSV89&) = delete;
-            MICSV89 &operator=(const MICSV89&) = delete;
-
-            std::string m_name;
-            bool m_valid;
-            uint8_t m_address;
-            uint8_t rx_buf[6];
-            uint8_t tx_buf[3];
-            mraa::I2c* i2c;
-    };
-}
diff --git a/src/micsv89/micsv89.json b/src/micsv89/micsv89.json
deleted file mode 100644
index 1796dbe..0000000
--- a/src/micsv89/micsv89.json
+++ /dev/null
@@ -1,40 +0,0 @@
-{
-    "Library": "micsv89",
-    "Description": "MICS-VZ89 environmental sensor library",
-    "Sensor Class": {
-        "MICSV89": {
-            "Name": "API for the MICS-VZ89 Gas Sensor",
-            "Description": "This is the UPM Module for the SGX Sensortech MICS-VZ-89. The MiCS-VZ-86/89 combines state-of-the-art MOS sensor technology with intelligent detection algorithms to monitor VOCs and CO2 equivalent variations in confined spaces. This library only supports the i2c variants of this sensor.",
-            "Aliases": ["micsv89", "MICS-VZ-89TE", "MICS-VZ-89TE Indoor Air Quality Sensor"],
-            "Categories": ["gaseous"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["SGX"],
-            "Image": "micsv89.jpg",
-            "Examples": {
-                "Node.js": ["micsv89.js"],
-                "C++": ["micsv89.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.3,
-                    "max": 5.0
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Warm-up Time": {
-                    "unit": "minute",
-                    "time": 15
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://sgx.cdistore.com/ProductDetail/MICSVZ89TE-SGX-Sensortech-Limited/598202/"],
-                "Datasheets": ["https://sgx.cdistore.com/datasheets/e2v/MiCS-VZ-89TE_V1.0.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/mlx90614/CMakeLists.txt b/src/mlx90614/CMakeLists.txt
deleted file mode 100644
index bde35e2..0000000
--- a/src/mlx90614/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "mlx90614")
-set (libdescription "Digital No-contact Infrared Thermometer")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/mlx90614/mlx90614.cxx b/src/mlx90614/mlx90614.cxx
deleted file mode 100644
index 2115836..0000000
--- a/src/mlx90614/mlx90614.cxx
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <unistd.h>
-#include <stdlib.h>
-#include <stdexcept>
-
-#include "mlx90614.hpp"
-
-using namespace upm;
-
-MLX90614::MLX90614 (int bus, int devAddr) : m_i2Ctx(bus) {
-    m_name = "MLX90614";
-
-    m_i2cAddr = devAddr;
-    m_bus = bus;
-
-    mraa::Result ret = m_i2Ctx.address(m_i2cAddr);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) + 
-                                    ": address() failed");
-    }
-
-    if ((ret = m_i2Ctx.frequency(mraa::I2C_STD)) != mraa::SUCCESS ) {
-      throw std::invalid_argument(std::string(__FUNCTION__) +
-                                  ": I2c.frequency(I2C_STD) failed");
-      return;
-    }
-}
-
-float
-MLX90614::readObjectTempF(int objAddr) {
-    return (readTemperature(objAddr) * 9 / 5) + 32;
-}
-
-float
-MLX90614::readAmbientTempF(void) {
-    return (readTemperature(MLX90614_TA) * 9 / 5) + 32;
-}
-
-float
-MLX90614::readObjectTempC(int objAddr) {
-    return readTemperature(objAddr);
-}
-
-float
-MLX90614::readAmbientTempC(void) {
-    return readTemperature(MLX90614_TA);
-}
-
-/*
- * **************
- *  private area
- * **************
- */
-float
-MLX90614::readTemperature (uint8_t address) {
-    return m_i2Ctx.readWordReg(address) * 0.02 - 273.15;
-}
diff --git a/src/mlx90614/mlx90614.hpp b/src/mlx90614/mlx90614.hpp
deleted file mode 100644
index fae8242..0000000
--- a/src/mlx90614/mlx90614.hpp
+++ /dev/null
@@ -1,131 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/i2c.hpp>
-
-#define DEVICE_ADDR         0x5A // device address
-
-// RAM
-#define MLX90614_RAWIR1     0x04
-#define MLX90614_RAWIR2     0x05
-#define MLX90614_TA         0x06
-#define MLX90614_TOBJ1      0x07
-#define MLX90614_TOBJ2      0x08
-// EEPROM
-#define MLX90614_TOMAX      0x20
-#define MLX90614_TOMIN      0x21
-#define MLX90614_PWMCTRL    0x22
-#define MLX90614_TARANGE    0x23
-#define MLX90614_EMISS      0x24
-#define MLX90614_CONFIG     0x25
-#define MLX90614_ADDR       0x0E
-#define MLX90614_ID1        0x3C
-#define MLX90614_ID2        0x3D
-#define MLX90614_ID3        0x3E
-#define MLX90614_ID4        0x3F
-
-#define HIGH                    1
-#define LOW                     0
-
-namespace upm {
-
-/**
- * @brief MLX90614 Temperature Sensor
- * @defgroup mlx90614 libupm-mlx90614
- * @ingroup generic i2c temp
- */
-/**
- * @library mlx90614
- * @sensor mlx90614
- * @comname Digital No-contact Infrared Thermometer
- * @type temp
- * @man generic
- * @con i2c
- * @web https://www.melexis.com/en/product/MLX90614/Digital-Plug-Play-Infrared-Thermometer-TO-Can
- *
- * @brief API for the MLX90614 Temperature Sensor
- *
- * This module defines the MLX90614 interface for libmlx90614
- *
- * @image html mlx90614.jpg
- * @snippet mlx90614.cxx Interesting
- */
-class MLX90614 {
-    public:
-
-        /**
-         * Instantiates an MLX90614 object
-         *
-         * @param bus Number of the used bus
-         * @param devAddr Address of the used I2C device
-         */
-        MLX90614 (int bus=0, int devAddr=0x5A);
-
-        /**
-         * Reads the object temperature in Fahrenheit
-         *
-         * @param objAddr Object register for models with dual sensors
-         * Can be MLX90614_TOBJ1 (default) or MLX90614_TOBJ2
-         */
-        float readObjectTempF(int objAddr=MLX90614_TOBJ1);
-
-        /**
-         * Reads the ambient temperature in Fahrenheit
-         */
-        float readAmbientTempF(void);
-        /**
-         * Reads the object temperature in Celsius
-         *
-         * @param objAddr Object register for models with dual sensors
-         * Can be MLX90614_TOBJ1 (default) or MLX90614_TOBJ2
-         */
-        float readObjectTempC(int objAddr=MLX90614_TOBJ1);
-
-        /**
-         * Reads the ambient temperature in Celsius
-         */
-        float readAmbientTempC(void);
-
-        /**
-         * Returns the name of the component
-         */
-        std::string name()
-        {
-            return m_name;
-        }
-    private:
-        std::string m_name;
-
-        int m_i2cAddr;
-        int m_bus;
-        mraa::I2c m_i2Ctx;
-
-        uint16_t i2cReadReg_N (int reg, unsigned int len, uint8_t * buffer);
-        mraa::Result i2cWriteReg_N (uint8_t reg, unsigned int len, uint8_t * buffer);
-        float readTemperature (uint8_t address);
-};
-
-}
diff --git a/src/mlx90614/mlx90614.json b/src/mlx90614/mlx90614.json
deleted file mode 100644
index d5152e9..0000000
--- a/src/mlx90614/mlx90614.json
+++ /dev/null
@@ -1,66 +0,0 @@
-{
-    "Library": "mlx90614",
-    "Description": "MLX90614 Temperature Sensor library",
-    "Sensor Class": {
-        "MLX90614": {
-            "Name": "API for the Melexis MLX90614 Temperature Sensor",
-            "Description": "This is the UPM Module for the Melexis mlx90614 temperature sensor. The MLX90614 is an infrared thermometer for non-contact temperature measurements. Both the IR sensitive thermopile detector chip and the signal conditioning ASIC are integrated in the same TO-39 can. Integrated into the MLX90614 are a low noise amplifier, 17-bit ADC and powerful DSP unit thus achieving high accuracy and resolution of the thermometer.",
-            "Aliases": ["mlx90614", "Digital plug & play infrared thermometer in a TO-can"],
-            "Categories": ["temperature"],
-            "Connections": ["i2c"],
-            "Project Type": ["medical", "industrial", "commercial"],
-            "Manufacturers": ["Melexis"],
-            "Image": "mlx90614.jpg",
-            "Examples": {
-                "C++": ["mlx90614.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.6,
-                    "max": 5.5
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "min": 1.3,
-                    "max": 2
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 125
-                },
-                "Effective Range":{
-                    "unit": "C",
-                    "min": -70,
-                    "max": 380
-                },
-                "Accuracy": {
-                    "Between 0 and 50 C":{
-                        "unit": "C",
-                        "accuracy": 0.5
-                    }
-                },
-                "Resolution": {
-                    "unit": "C",
-                    "resolution": "0.02"
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need pull up resistors"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.melexis.com/en/product/MLX90614/Digital-Plug-Play-Infrared-Thermometer-TO-Can"],
-                "Datasheets": ["https://www.melexis.com/-/media/files/documents/datasheets/mlx90614-datasheet-melexis.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/mma7361/CMakeLists.txt b/src/mma7361/CMakeLists.txt
deleted file mode 100644
index 1fc49c9..0000000
--- a/src/mma7361/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME mma7361
-    DESCRIPTION "Triaxial Analog Accelerometer"
-    C_HDR mma7361.h
-    C_SRC mma7361.c
-    CPP_HDR mma7361.hpp
-    CPP_SRC mma7361.cxx
-    FTI_SRC mma7361_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/mma7361/mma7361.c b/src/mma7361/mma7361.c
deleted file mode 100644
index 79023d1..0000000
--- a/src/mma7361/mma7361.c
+++ /dev/null
@@ -1,402 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string.h>
-#include <assert.h>
-
-#include "mma7361.h"
-
-#include "upm_utilities.h"
-
-// arduino map() function in macro form (Public Domain)
-#define MAP(_value, _in_min, _in_max, _out_min, _out_max) \
-  ( ((_value) - (_in_min)) * ((_out_max) - (_out_min)) /  \
-    ((_in_max) - (_in_min)) + _out_min )
-
-// While the DFR board can be powered at 5.0 to 3.3v, the analog
-// outputs are always going to be 3.3v - ie: the outputs are not
-// scaled to 5v, so we need to account for that.
-// We may need to make this configurable too in the future...
-#define MMA_OUTPUT_AREF 3.3
-
-mma7361_context mma7361_init(int x_pin, int y_pin, int z_pin,
-                             int selftest_pin, int sleep_pin,
-                             int freefall_pin, int range_pin,
-                             float a_ref)
-{
-  // sanity check - at least one axis needs to be enabled, or what's
-  // the point?
-  if (x_pin < 0 && y_pin < 0 && z_pin < 0)
-    {
-      printf("%s: At least one axis must be enabled.\n", __FUNCTION__);
-      return NULL;
-    }
-
-  // make sure MRAA is initialized
-  int mraa_rv;
-  if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-  {
-      printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-      return NULL;
-  }
-
-  mma7361_context dev =
-    (mma7361_context)malloc(sizeof(struct _mma7361_context));
-
-  if (!dev)
-    return NULL;
-
-  // zero out context
-  memset((void *)dev, 0, sizeof(struct _mma7361_context));
-  
-  dev->aio_x = NULL;
-  dev->aio_y = NULL;
-  dev->aio_z = NULL;
-
-  dev->gpio_selftest = NULL;
-  dev->gpio_sleep = NULL;
-  dev->gpio_freefall = NULL;
-  dev->gpio_range = NULL;
-
-  dev->a_res = 0;
-  dev->a_ref = a_ref;
-  dev->g_range = 1.5;
-
-  dev->offset_x = dev->offset_y = dev->offset_z = 0.0;
-  dev->scale_x = dev->scale_y = dev->scale_z = 1.0;
-
-  dev->accel_x = 0.0;
-  dev->accel_y = 0.0;
-  dev->accel_z = 0.0;
-
-  dev->volts_x = 0.0;
-  dev->volts_y = 0.0;
-  dev->volts_z = 0.0;
-
-  dev->normalized_x = 0;
-  dev->normalized_y = 0;
-  dev->normalized_z = 0;
-
-  // initialize the MRAA contexts (only what we need)
-
-  // analogs
-  if (x_pin >= 0)
-    {
-      if (!(dev->aio_x = mraa_aio_init(x_pin)))
-        {
-          printf("%s: mraa_aio_init(x) failed.\n", __FUNCTION__);
-          mma7361_close(dev);
-          return NULL;
-        }
-      // set our analog resolution
-      dev->a_res = (float)(1 << mraa_aio_get_bit(dev->aio_x)) - 1;
-    }
-
-  if (y_pin >= 0)
-    {
-      if (!(dev->aio_y = mraa_aio_init(y_pin)))
-        {
-          printf("%s: mraa_aio_init(y) failed.\n", __FUNCTION__);
-          mma7361_close(dev);
-          return NULL;
-        }
-
-      // set our analog resolution if not already set
-      if (!dev->a_res)
-        dev->a_res = (float)(1 << mraa_aio_get_bit(dev->aio_y)) - 1;
-    }
-
-  if (z_pin >= 0)
-    {
-      if (!(dev->aio_z = mraa_aio_init(z_pin)))
-        {
-          printf("%s: mraa_aio_init(z) failed.\n", __FUNCTION__);
-          mma7361_close(dev);
-          return NULL;
-        }
-
-      // set our analog resolution if not already set
-      if (!dev->a_res)
-        dev->a_res = (float)(1 << mraa_aio_get_bit(dev->aio_z)) - 1;
-    }
-
-  // now the gpios
-  if (selftest_pin >= 0)
-    {
-      if (!(dev->gpio_selftest = mraa_gpio_init(selftest_pin)))
-        {
-          printf("%s: mraa_gpio_init(selftest) failed.\n", __FUNCTION__);
-          mma7361_close(dev);
-          return NULL;
-        }
-
-      mraa_gpio_dir(dev->gpio_selftest, MRAA_GPIO_OUT);
-      mma7361_selftest(dev, false);
-    }
-
-  if (sleep_pin >= 0)
-    {
-      if (!(dev->gpio_sleep = mraa_gpio_init(sleep_pin)))
-        {
-          printf("%s: mraa_gpio_init(sleep) failed.\n", __FUNCTION__);
-          mma7361_close(dev);
-          return NULL;
-        }
-
-      mraa_gpio_dir(dev->gpio_sleep, MRAA_GPIO_OUT);
-      mma7361_sleep(dev, false);
-    }
-
-  if (freefall_pin >= 0)
-    {
-      if (!(dev->gpio_freefall = mraa_gpio_init(freefall_pin)))
-        {
-          printf("%s: mraa_gpio_init(freefall) failed.\n", __FUNCTION__);
-          mma7361_close(dev);
-          return NULL;
-        }
-
-      mraa_gpio_dir(dev->gpio_freefall, MRAA_GPIO_IN);
-    }
-
-  if (range_pin >= 0)
-    {
-      if (!(dev->gpio_range = mraa_gpio_init(range_pin)))
-        {
-          printf("%s: mraa_gpio_init(range) failed.\n", __FUNCTION__);
-          mma7361_close(dev);
-          return NULL;
-        }
-
-      mraa_gpio_dir(dev->gpio_range, MRAA_GPIO_OUT);
-      mma7361_set_range(dev, false);
-    }
-
-  return dev;
-}
-
-void mma7361_close(mma7361_context dev)
-{
-  assert(dev != NULL);
-
-  // analogs
-  if (dev->aio_x)
-    mraa_aio_close(dev->aio_x);
-  if (dev->aio_y)
-    mraa_aio_close(dev->aio_y);
-  if (dev->aio_z)
-    mraa_aio_close(dev->aio_z);
-
-  // gpios
-  if (dev->gpio_selftest)
-    mraa_gpio_close(dev->gpio_selftest);
-  if (dev->gpio_sleep)
-    mraa_gpio_close(dev->gpio_sleep);
-  if (dev->gpio_freefall)
-    mraa_gpio_close(dev->gpio_freefall);
-  if (dev->gpio_range)
-    mraa_gpio_close(dev->gpio_range);
-
-  free(dev);
-}
-
-upm_result_t mma7361_selftest(const mma7361_context dev, bool selftest)
-{
-  assert(dev != NULL);
-
-  if (!dev->gpio_selftest)
-    return UPM_ERROR_NO_RESOURCES;
-
-  if (selftest)
-    mraa_gpio_write(dev->gpio_selftest, 1);
-  else
-    mraa_gpio_write(dev->gpio_selftest, 0);
-
-  return UPM_SUCCESS;
-}
-
-upm_result_t mma7361_sleep(const mma7361_context dev, bool sleep)
-{
-  assert(dev != NULL);
-
-  if (!dev->gpio_sleep)
-    return UPM_ERROR_NO_RESOURCES;
-
-  if (sleep)
-    mraa_gpio_write(dev->gpio_sleep, 0);
-  else
-    mraa_gpio_write(dev->gpio_sleep, 1);
-
-  upm_delay_ms(2);
-
-  return UPM_SUCCESS;
-}
-
-upm_result_t mma7361_freefall(const mma7361_context dev, bool *freefall)
-{
-  assert(dev != NULL);
-
-  if (!dev->gpio_freefall)
-    return UPM_ERROR_NO_RESOURCES;
-
-  *freefall = mraa_gpio_read(dev->gpio_freefall) ? true : false;
-
-  return UPM_SUCCESS;
-}
-
-void mma7361_set_range(const mma7361_context dev, bool range)
-{
-  assert(dev != NULL);
-
-  // for this one, if there is no actual GPIO available, we will not
-  // error out, but still set the internal range.
-
-  if (range)
-    dev->g_range = 6.0;
-  else
-    dev->g_range = 1.5;
-
-  if (dev->gpio_range)
-    {
-      if (range)
-        mraa_gpio_write(dev->gpio_range, 1);
-      else
-        mraa_gpio_write(dev->gpio_range, 0);
-    }
-}
-
-void mma7361_set_offset(const mma7361_context dev, float x, float y, float z)
-{
-  assert(dev != NULL);
-
-  dev->offset_x = x;
-  dev->offset_y = y;
-  dev->offset_z = z;
-}
-
-void mma7361_set_scale(const mma7361_context dev, float x, float y, float z)
-{
-  assert(dev != NULL);
-
-  dev->scale_x = x;
-  dev->scale_y = y;
-  dev->scale_z = z;
-}
-
-upm_result_t mma7361_update(const mma7361_context dev)
-{
-  assert(dev != NULL);
-
-  float sample;
-
-  if (dev->aio_x)
-    {
-      if ((sample = (float)mraa_aio_read(dev->aio_x)) < 0.0)
-        {
-          printf("%s: mraa_aio_read(x) failed.\n", __FUNCTION__);
-          return UPM_ERROR_OPERATION_FAILED;
-        }
-
-      dev->normalized_x = sample / dev->a_res;
-      dev->volts_x = dev->normalized_x * dev->a_ref;
-      dev->accel_x = MAP(dev->volts_x, 0.0, MMA_OUTPUT_AREF,
-                         -dev->g_range, dev->g_range);
-    }
-
-  if (dev->aio_y)
-    {
-      if ((sample = (float)mraa_aio_read(dev->aio_y)) < 0.0)
-        {
-          printf("%s: mraa_aio_read(y) failed.\n", __FUNCTION__);
-          return UPM_ERROR_OPERATION_FAILED;
-        }
-
-      dev->normalized_y = sample / dev->a_res;
-      dev->volts_y = dev->normalized_y * dev->a_ref;
-      dev->accel_y = MAP(dev->volts_y, 0.0, MMA_OUTPUT_AREF,
-                         -dev->g_range, dev->g_range);
-    }
-
-  if (dev->aio_z)
-    {
-      if ((sample = (float)mraa_aio_read(dev->aio_z)) < 0.0)
-        {
-          printf("%s: mraa_aio_read(z) failed.\n", __FUNCTION__);
-          return UPM_ERROR_OPERATION_FAILED;
-        }
-
-      dev->normalized_z = sample / dev->a_res;
-      dev->volts_z = dev->normalized_z * dev->a_ref;
-      dev->accel_z = MAP(dev->volts_z, 0.0, MMA_OUTPUT_AREF,
-                         -dev->g_range, dev->g_range);
-    }
-
-  return UPM_SUCCESS;
-}
-
-void mma7361_get_acceleration(const mma7361_context dev,
-                              float *x, float *y, float *z)
-{
-  assert(dev != NULL);
-
-  if (x)
-    *x = dev->accel_x * dev->scale_x + (dev->offset_x * dev->scale_x);
-
-  if (y)
-    *y = dev->accel_y * dev->scale_y + (dev->offset_y * dev->scale_y);
-
-  if (z)
-    *z = dev->accel_z * dev->scale_z + (dev->offset_z * dev->scale_z);
-}
-
-void mma7361_get_volts(const mma7361_context dev,
-                       float *x, float *y, float *z)
-{
-  assert(dev != NULL);
-
-  if (x)
-    *x = dev->volts_x;
-
-  if (y)
-    *y = dev->volts_y;
-
-  if (z)
-    *z = dev->volts_z;
-}
-
-void mma7361_get_normalized(const mma7361_context dev,
-                            float *x, float *y, float *z)
-{
-  assert(dev != NULL);
-
-  if (x)
-    *x = dev->normalized_x;
-
-  if (y)
-    *y = dev->normalized_y;
-
-  if (z)
-    *z = dev->normalized_z;
-}
-
diff --git a/src/mma7361/mma7361.cxx b/src/mma7361/mma7361.cxx
deleted file mode 100644
index f80d5e8..0000000
--- a/src/mma7361/mma7361.cxx
+++ /dev/null
@@ -1,150 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <stdexcept>
-#include <string>
-
-#include "mma7361.hpp"
-
-using namespace upm;
-using namespace std;
-
-MMA7361::MMA7361(int x_pin, int y_pin, int z_pin,
-                 int selftest_pin, int sleep_pin,
-                 int freefall_pin, int range_pin,
-                 float a_ref) :
-  m_mma7361(mma7361_init(x_pin, y_pin, z_pin, selftest_pin, sleep_pin,
-                         freefall_pin, range_pin, a_ref))
-{
-  if (!m_mma7361)
-    throw std::runtime_error(string(__FUNCTION__)
-                             + ": mma7361_init() failed");
-}
-
-MMA7361::~MMA7361()
-{
-  mma7361_close(m_mma7361);
-}
-
-void MMA7361::setRange(bool range)
-{
-  mma7361_set_range(m_mma7361, range);
-}
-
-void MMA7361::setSleep(bool sleep)
-{
-  mma7361_sleep(m_mma7361, sleep);
-}
-
-bool MMA7361::isInFreefall()
-{
-  bool freefall;
-  upm_result_t rv;
-  
-  if ((rv = mma7361_freefall(m_mma7361, &freefall)))
-    {
-      throw std::runtime_error(string(__FUNCTION__)
-                               + ": mma7361_freefall() failed with UPM error "
-                               + to_string(int(rv)) );
-    }
-
-  return freefall;
-}
-
-void MMA7361::enableSelftest(bool enable)
-{
-  upm_result_t rv;
-  
-  if ((rv = mma7361_selftest(m_mma7361, enable)))
-    {
-      throw std::runtime_error(string(__FUNCTION__)
-                               + ": mma7361_selftest() failed with UPM error "
-                               + to_string(int(rv)) );
-    }
-}
-
-void MMA7361::update()
-{
-  upm_result_t rv;
-  
-  if ((rv = mma7361_update(m_mma7361)))
-    {
-      throw std::runtime_error(string(__FUNCTION__)
-                               + ": mma7361_update() failed with UPM error "
-                               + to_string(int(rv)) );
-    }
-}
-
-void MMA7361::setOffset(float x, float y, float z)
-{
-  mma7361_set_offset(m_mma7361, x, y, z);
-}
-
-void MMA7361::setScale(float x, float y, float z)
-{
-  mma7361_set_scale(m_mma7361, x, y, z);
-}
-
-void MMA7361::getAcceleration(float *x, float *y, float *z)
-{
-  mma7361_get_acceleration(m_mma7361, x, y, z);
-}
-
-float *MMA7361::getAcceleration()
-{
-  static float data[3];
-
-  getAcceleration(&data[0], &data[1], &data[2]);
-
-  return data;
-}
-
-void MMA7361::getVolts(float *x, float *y, float *z)
-{
-  mma7361_get_volts(m_mma7361, x, y, z);
-}
-
-float *MMA7361::getVolts()
-{
-  static float data[3];
-
-  getVolts(&data[0], &data[1], &data[2]);
-
-  return data;
-}
-
-void MMA7361::getNormalized(float *x, float *y, float *z)
-{
-  mma7361_get_normalized(m_mma7361, x, y, z);
-}
-
-float *MMA7361::getNormalized()
-{
-  static float data[3];
-
-  getNormalized(&data[0], &data[1], &data[2]);
-
-  return data;
-}
diff --git a/src/mma7361/mma7361.h b/src/mma7361/mma7361.h
deleted file mode 100644
index 49f0263..0000000
--- a/src/mma7361/mma7361.h
+++ /dev/null
@@ -1,248 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <stdint.h>
-#include "upm.h"
-#include "mraa/aio.h"
-#include "mraa/gpio.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-  /**
-   * @file mma7361.h
-   * @library mma7361
-   * @brief C API for the MMA7361 Analog Accelerometer
-   *
-   * @include mma7361.c
-   */
-  
-  /**
-   * Device context
-   */
-  typedef struct _mma7361_context {
-    // at least one of these must be intialized
-    mraa_aio_context    aio_x;
-    mraa_aio_context    aio_y;
-    mraa_aio_context    aio_z;
-    
-    // optional - enable selftest
-    mraa_gpio_context   gpio_selftest;
-    
-    // optional - enable sleep mode
-    mraa_gpio_context   gpio_sleep;
-    
-    // optional - detect free fall (0g)
-    mraa_gpio_context   gpio_freefall;
-    
-    // optional - if unconnected, range is 1.5g
-    mraa_gpio_context   gpio_range;
-    
-    // selected G range
-    float g_range;
-
-    // analog ADC resolution
-    float               a_res;
-
-    // analog reference voltage
-    float               a_ref;
-    
-    // for external offset and scaling of the results
-    float               offset_x;
-    float               offset_y;
-    float               offset_z;
-
-    float               scale_x;
-    float               scale_y;
-    float               scale_z;
-    
-    // our measurements
-    float               accel_x;
-    float               accel_y;
-    float               accel_z;
-
-    // volts
-    float               volts_x;
-    float               volts_y;
-    float               volts_z;
-
-    // normalized ADC
-    float               normalized_x;
-    float               normalized_y;
-    float               normalized_z;
-  } *mma7361_context;
-  
-  /**
-   * MMA7361 Initializer
-   *
-   * This sensor isn't designed for navigational purposes - rather
-   * it's intended for less precise measurements such as determining
-   * tilt and orientation.
-   *
-   * All of these pins are optional, and will depend on how your
-   * device is connected.  For those pins you do not need, supply -1
-   * as the pin. You must supply a valid pin for at least one of the
-   * axes, or what's the point?
-   *
-   * The DFRobot variant of this sensor uses a mechanical switch on
-   * the board to determine the G-range to use, so on this board you
-   * would supply -1 for the range_pin, but be sure to call
-   * mma7361_set_range() with the correct parameter so that the
-   * internal logic will generate correct results.
-   *
-   * @param x_pin Analog pin to use for X axis. -1 to disable.
-   * @param y_pin Analog pin to use for Y axis. -1 to disable.
-   * @param z_pin Analog pin to use for Z axis. -1 to disable.
-   * @param selftest_pin GPIO pin to use for self test. -1 to disable.
-   * @param sleep_pin GPIO pin to use for sleep function. -1 to disable.
-   * @param freefall_pin GPIO pin to use for free fall (0g)
-   * detection. -1 to disable.
-   * @param range_pin GPIO pin to select range (1.5g or 6g).  -1 to
-   * disable.
-   * @param a_ref The analog reference voltage in use
-   */
-  mma7361_context mma7361_init(int x_pin, int y_pin, int z_pin,
-                               int selftest_pin, int sleep_pin,
-                               int freefall_pin, int range_pin,
-                               float a_ref);
-
-  /**
-   * MMA7361 sensor close function
-   */
-  void mma7361_close(mma7361_context dev);
-
-  /**
-   * Set the range of the device.  This device supports two G ranges:
-   * 1.5 and 6.  The default is 1.5G.
-   *
-   * @param dev sensor context
-   * @param range true for 6G, false for 1.5G
-   */
-  void mma7361_set_range(const mma7361_context dev, bool range);
-
-  /**
-   * Set sleep mode.  When in sleep mode the sensor uses minimal power.
-   *
-   * @param dev sensor context
-   * @param sleep true to go into sleep mode, false to wake up
-   * @return UPM result
-   */
-  upm_result_t mma7361_sleep(const mma7361_context dev, bool sleep);
-
-  /**
-   * Get freefall detection status.
-   *
-   * @param dev sensor context
-   * @param freefall O pointer to a boolean value indicating whether a
-   * freefall condition is being detected.
-   * @return UPM result
-   */
-  upm_result_t mma7361_freefall(const mma7361_context dev, bool *freefall);
-
-  /**
-   * Enable self test mode.
-   *
-   * @param dev sensor context
-   * @param selftest true to enable the self test mode, false otherwise.
-   * @return UPM result
-   */
-  upm_result_t mma7361_selftest(const mma7361_context dev, bool selftest);
-
-  /**
-   * Read the sensor status an update internal state.
-   * mma7361_update() must have been called before calling
-   * mma7361_get_acceleration(), mma7361_get_normalized(), or
-   * mma7361_get_volts().
-   *
-   * @param dev sensor context
-   * @return UPM result
-   */
-  upm_result_t mma7361_update(const mma7361_context dev);
-
-  /**
-   * Set sensor offset.  This offset is applied to the return values
-   * before scaling.  Default is 0.0.
-   *
-   * @param dev sensor context pointer
-   * @param x Scale to apply to X value
-   * @param y Scale to apply to Y value
-   * @param z Scale to apply to Z value
-   */
-  void mma7361_set_offset(const mma7361_context dev, float x, float y,
-                          float z);
-
-  /**
-   * Set sensor scale.  The acceleration return values are scaled by
-   * this value before the offset is applied.  Default is 1.0.
-   *
-   * @param dev sensor context pointer
-   * @param x Offset to apply to X value
-   * @param y Offset to apply to Y value
-   * @param z Offset to apply to Z value
-   */
-  void mma7361_set_scale(const mma7361_context dev, float x, float y,
-                         float z);
-
-  /**
-   * Get computed acceleration from the sensor. mma7361_update() must
-   * have been called prior to calling this function.
-   *
-   * @param dev sensor context pointer
-   * @param x a pointer in which X acceleration data will be returned
-   * @param y a pointer in which Y acceleration data will be returned
-   * @param z a pointer in which Z acceleration data will be returned
-   */
-  void mma7361_get_acceleration(const mma7361_context dev,
-                                float *x, float *y, float *z);
-
-  /**
-   * Get the measured volts from the sensor. mma7361_update() must
-   * have been called prior to calling this function.
-   *
-   * @param dev sensor context pointer
-   * @param x a pointer in which X volt data will be returned
-   * @param y a pointer in which Y volt data will be returned
-   * @param z a pointer in which Z volt data will be returned
-   */
-  void mma7361_get_volts(const mma7361_context dev,
-                         float *x, float *y, float *z);
-
-  /**
-   * Get the normalized ADC values from the sensor.  mma7361_update() must
-   * have been called prior to calling this function.
-   *
-   * @param dev sensor context pointer
-   * @param x a pointer in which X normalized ADC data will be returned
-   * @param y a pointer in which Y normalized ADC data will be returned
-   * @param z a pointer in which Z normalized ADC data will be returned
-   */
-  void mma7361_get_normalized(const mma7361_context dev,
-                              float *x, float *y, float *z);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/mma7361/mma7361.hpp b/src/mma7361/mma7361.hpp
deleted file mode 100644
index 7db3aee..0000000
--- a/src/mma7361/mma7361.hpp
+++ /dev/null
@@ -1,211 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <iostream>
-
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-
-#include "mma7361.h"
-
-namespace upm {
-  /**
-   * @brief MMA7361 Analog Accelerometer
-   * @defgroup mma7361 libupm-mma7361
-   * @ingroup dfrobot gpio analog accelerometer
-   */
-  
-  /**
-   * @library mma7361
-   * @sensor mma7361
-   * @comname Triaxial Analog Accelerometer
-   * @type accelerometer
-   * @man dfrobot
-   * @con analog gpio
-   * @web http://www.dfrobot.com/index.php?route=product/product&path=36&product_id=507#.V7YEj99ytNJ
-   *
-   * @brief API for the DFRobot MMA7361 Analog Accelerometer
-   *
-   * This library was tested with the DFRobot MMA7361 Analog
-   * Accelerometer.  It supports 3 Axes with a selectable 1.5G and 6G
-   * sensitivity.
-   *
-   * @snippet mma7361.cxx Interesting
-   */
-
-  class MMA7361 {
-  public:
-
-    /**
-     * MMA7361 object constructor
-     *
-     * @param x_pin Analog pin to use for X axis. -1 to disable.
-     * @param y_pin Analog pin to use for Y axis. -1 to disable.
-     * @param z_pin Analog pin to use for Z axis. -1 to disable.
-     * @param selftest_pin GPIO pin to use for self test. -1 to disable.
-     * @param sleep_pin GPIO pin to use for sleep function. -1 to disable.
-     * @param freefall_pin GPIO pin to use for free fall (0g)
-     * detection. -1 to disable.
-     * @param range_pin GPIO pin to select range (1.5g or 6g).  -1 to
-     * disable.
-     * @param a_ref The analog reference voltage in use.  Default 5.0.
-     */
-    MMA7361(int x_pin, int y_pin, int z_pin,
-            int selftest_pin, int sleep_pin,
-            int freefall_pin, int range_pin,
-            float a_ref=5.0);
-
-    /**
-     * MMA7361 object destructor
-     */
-    ~MMA7361();
-
-    /**
-     * Set the range of the device.  This device supports two G ranges:
-     * 1.5 and 6.  The default is 1.5G.
-     *
-     * @param range true for 6G, false for 1.5G
-     */
-    void setRange(bool range);
-
-    /**
-     * Set sleep mode.  When in sleep mode the sensor uses minimal power.
-     *
-     * @param sleep true to go into sleep mode, false to wake up
-     */
-    void setSleep(bool sleep);
-
-    /**
-     * Get freefall detection status.
-     *
-     * @return true if a freefall condition is detected, false otherwise.
-     */
-    bool isInFreefall();
-
-    /**
-     * Enable self test mode.
-     *
-     * @param enable true to enable the self test mode, false otherwise.
-     */
-    void enableSelftest(bool enable);
-
-    /**
-     * Read the sensor status an update internal state.
-     * update() must have been called before calling
-     * getAcceleration(), getNormalized(), or getVolts().
-     */
-    void update();
-
-    /**
-     * Set sensor offset.  This offset is applied to the return values
-     * before scaling.  Default is 0.0.
-     *
-     * @param x Offset to apply to X value
-     * @param y Offset to apply to Y value
-     * @param z Offset to apply to Z value
-     */
-    void setOffset(float x, float y, float z);
-
-    /**
-     * Set sensor scale.  The acceleration return values are scaled by
-     * this value before the offset is applied.  Default is 1.0.
-     *
-     * @param x Scale to apply to X value
-     * @param y Scale to apply to Y value
-     * @param z Scale to apply to Z value
-     */
-    void setScale(float x, float y, float z);
-
-    /**
-     * Get computed acceleration from the sensor. update() must have
-     * been called prior to calling this function.
-     *
-     * @param x a pointer in which X acceleration data will be returned
-     * @param y a pointer in which Y acceleration data will be returned
-     * @param z a pointer in which Z acceleration data will be returned
-     */
-    void getAcceleration(float *x, float *y, float *z);
-
-    /**
-     * Get computed acceleration from the sensor. update() must have
-     * been called prior to calling this function.
-     *
-     * @return a pointer to a statically allocated array of 3 floats
-     * containing the X, Y, and Z componenets.
-     */
-    float *getAcceleration();
-
-    /**
-     * Get the measured volts from the sensor. update() must have been
-     * called prior to calling this function.
-     *
-     * @param x a pointer in which X volt data will be returned
-     * @param y a pointer in which Y volt data will be returned
-     * @param z a pointer in which Z volt data will be returned
-     */
-    void getVolts(float *x, float *y, float *z);
-
-    /**
-     * Get the measured volts from the sensor. update() must have been
-     * called prior to calling this function.
-     *
-     * @return a pointer to a statically allocated array of 3 floats
-     * containing the X, Y, and Z componenets.
-     */
-    float *getVolts();
-
-    /**
-     * Get the normalized ADC values from the sensor.  update() must have
-     * been called prior to calling this function.
-     *
-     * @param x a pointer in which X normalized ADC data will be returned
-     * @param y a pointer in which Y normalized ADC data will be returned
-     * @param z a pointer in which Z normalized ADC data will be returned
-     */
-    void getNormalized(float *x, float *y, float *z);
-
-    /**
-     * Get the normalized ADC values from the sensor.  update() must have
-     * been called prior to calling this function.
-     *
-     * @return a pointer to a statically allocated array of 3 ints
-     * containing the X, Y, and Z componenets.
-     */
-    float *getNormalized();
-
-  protected:
-    // mma7361 device context
-    mma7361_context m_mma7361;
-
-  private:
-    /* Disable implicit copy and assignment operators */
-    MMA7361(const MMA7361&) = delete;
-    MMA7361 &operator=(const MMA7361&) = delete;
-  };
-}
-
-
diff --git a/src/mma7361/mma7361.i b/src/mma7361/mma7361.i
deleted file mode 100644
index 32fbfef..0000000
--- a/src/mma7361/mma7361.i
+++ /dev/null
@@ -1,61 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "arrays_java.i";
-%include "../java_buffer.i"
-
-%apply int *OUTPUT { int *x, int *y, int *z };
-%apply float *OUTPUT { float *ax, float *ay, float *az  };
-
-%typemap(jni) float* "jfloatArray"
-%typemap(jstype) float* "float[]"
-%typemap(jtype) float* "float[]"
-
-%typemap(javaout) float* {
-    return $jnicall;
-}
-
-%typemap(out) float *getAcceleration {
-    $result = JCALL1(NewFloatArray, jenv, 3);
-    JCALL4(SetFloatArrayRegion, jenv, $result, 0, 3, $1);
-}
-
-%typemap(out) float *getVolts {
-    $result = JCALL1(NewFloatArray, jenv, 3);
-    JCALL4(SetFloatArrayRegion, jenv, $result, 0, 3, $1);
-}
-
-%typemap(out) float *getNormalized {
-    $result = JCALL1(NewFloatArray, jenv, 3);
-    JCALL4(SetFloatArrayRegion, jenv, $result, 0, 3, $1);
-}
-
-%ignore getNormalized(float *, float *, float *);
-%ignore getAcceleration(float *, float *, float *);
-%ignore getVolts(float *, float *, float *);
-
-JAVA_JNI_LOADLIBRARY(javaupm_mma7361)
-#endif
-/* END Java syntax */
-
-/* BEGIN Javascript syntax  ------------------------------------------------- */
-#ifdef SWIGJAVASCRIPT
-%pointer_functions(int, intp);
-%pointer_functions(float, floatp);
-#endif
-/* END Javascript syntax */
-
-/* BEGIN Python syntax  ----------------------------------------------------- */
-#ifdef SWIGPYTHON
-%pointer_functions(int, intp);
-%pointer_functions(float, floatp);
-#endif
-/* END Python syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "mma7361.hpp"
-%}
-%include "mma7361.hpp"
-/* END Common SWIG syntax */
diff --git a/src/mma7361/mma7361.json b/src/mma7361/mma7361.json
deleted file mode 100644
index 232031d..0000000
--- a/src/mma7361/mma7361.json
+++ /dev/null
@@ -1,65 +0,0 @@
-{
-    "Library": "mma7361",
-    "Description": "UPM API for the DFRobot MMA7361 Analog Accelerometer",
-    "Sensor Class": {
-        "MMA7361": {
-            "Name": "API for the DFRobot MMA7361 Analog Accelerometer",
-            "Description": "This is the UPM Module for the DFRobot mma7361 analog accelerometer. This triaxial accelerometer has variable sensitivity, and offers an easy to read analog interface. This library was tested with the DFRobot MMA7361 Analog Accelerometer.",
-            "Aliases": ["mma7361", "Triple Axis Accelerometer MMA7361", "DFR0143"],
-            "Categories": ["accelerometer"],
-            "Connections": ["analog", "gpio"],
-            "Project Type": ["prototyping"],
-            "Manufacturers": ["DFRobot"],
-            "Examples": {
-                "Java": ["MMA7361_Example.java"],
-                "Python": ["mma7361.py"],
-                "Node.js": ["mma7361.js"],
-                "C++": ["mma7361.cxx"],
-                "C": ["mma7361.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.3,
-                    "max": 8.0
-                },
-                "Supply Current": {
-                    "Measurement Mode": {
-                        "unit": "uA",
-                        "typ": 500
-                    },
-                    "Standby Mode": {
-                        "unit": "uA",
-                        "typ": 3
-                    }
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Resolution": {
-                    "unit": "mV/g",
-                    "sensativity": 800
-                },
-                "Sensitivity": {
-                    "unit": "g",
-                    "min" : 1.5,
-                    "max" : 6.0
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might DFRobot IO/Sensor expansion board."]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might DFRobot IO/Sensor expansion board."]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.dfrobot.com/product-507.html#.V7YEj99ytNJ"],
-                "Datasheets": ["https://www.dfrobot.com/wiki/index.php/Triple_Axis_Accelerometer_MMA7361_SKU:DFR0143", "http://www.nxp.com/docs/en/data-sheet/MMA7361L.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/mma7361/mma7361_fti.c b/src/mma7361/mma7361_fti.c
deleted file mode 100644
index 54fff47..0000000
--- a/src/mma7361/mma7361_fti.c
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "mma7361.h"
-#include "upm_fti.h"
-
-/** 
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_mma7361_name[] = "MMA7361";
-const char upm_mma7361_description[] = "Analog 3-axis Accelerometer";
-const upm_protocol_t upm_mma7361_protocol[] = {UPM_ANALOG, UPM_ANALOG, 
-                                               UPM_ANALOG, UPM_GPIO, UPM_GPIO,
-                                               UPM_GPIO, UPM_GPIO};
-const upm_sensor_t upm_mma7361_category[] = {UPM_ACCELEROMETER};
-
-// forward declarations
-const void* upm_mma7361_get_ft(upm_sensor_t sensor_type);
-void* upm_mma7361_init_name();
-void upm_mma7361_close(void *dev);
-upm_result_t upm_mma7361_get_acceleration(void *dev, float *value,
-                                          upm_acceleration_u unit);
-upm_result_t upm_mma7361_set_scale(void *dev, float *scale);
-upm_result_t upm_mma7361_set_offset(void *dev, float *offset);
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = &upm_mma7361_init_name,
-    .upm_sensor_close = &upm_mma7361_close,
-};
-
-static const upm_acceleration_ft aft =
-{
-    .upm_acceleration_get_value = &upm_mma7361_get_acceleration
-};
-
-const void* upm_mma7361_get_ft(upm_sensor_t sensor_type)
-{
-  switch(sensor_type)
-    {
-    case UPM_SENSOR:
-      return &ft;
-      
-    case UPM_ACCELEROMETER:
-      return &aft;
-      
-    default:
-      return NULL;
-    }
-}
-
-void* upm_mma7361_init_name()
-{
-    return NULL;
-}
-
-
-void upm_mma7361_close(void *dev)
-{
-    mma7361_close((mma7361_context)dev);
-}
-
-upm_result_t upm_mma7361_get_acceleration(void *dev, float *value,
-                                          upm_acceleration_u unit)
-{
-  upm_result_t rv;
-  if ((rv = mma7361_update((mma7361_context)dev)))
-    return rv;
-
-  // Which "value" is supposed to be returned here?  Is it an array?
-  // Needs docs in the FTI header file for this sensor type.  We'll
-  // assume it's array.
-  // FIXME/CHECKME
-
-  // Only in G's
-  mma7361_get_acceleration((mma7361_context)dev, &value[0], &value[1],
-                           &value[2]);
-
-  return UPM_SUCCESS;
-}
-
-upm_result_t upm_mma7361_set_scale(void *dev, float *scale)
-{
-  // FIXME/CHECKME
-  // again, which scale?  As it's a pointer, we'll assume it's
-  // an array of 3 floats.  FTI needs some docs.
-
-  mma7361_set_scale((mma7361_context)dev, scale[0], scale[1], scale[2]);
-  return UPM_SUCCESS;
-}
-
-upm_result_t upm_mma7361_set_offset(void *dev, float *offset)
-{
-  // FIXME/CHECKME
-  // As it's a pointer, we'll assume it's an array of 3 floats.  FTI
-  // needs some docs.
-
-  mma7361_set_offset((mma7361_context)dev, offset[0], offset[1], offset[2]);
-  return UPM_SUCCESS;
-}
diff --git a/src/mma7455/CMakeLists.txt b/src/mma7455/CMakeLists.txt
deleted file mode 100644
index 14e2692..0000000
--- a/src/mma7455/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "mma7455")
-set (libdescription "Three Axis +/- 2/4/8 g Digital Accelerometer")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/mma7455/mma7455.cxx b/src/mma7455/mma7455.cxx
deleted file mode 100644
index 4b8e5ec..0000000
--- a/src/mma7455/mma7455.cxx
+++ /dev/null
@@ -1,170 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-#include <unistd.h>
-#include <vector>
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-
-#include "mma7455.hpp"
-
-using namespace upm;
-
-MMA7455::MMA7455 (int bus, int devAddr) : m_i2ControlCtx(bus) {
-    unsigned char data   = 0;
-
-    m_name = "MMA7455";
-
-    m_controlAddr = devAddr;
-    m_bus = bus;
-
-    mraa::Result error = m_i2ControlCtx.address(m_controlAddr);
-    if (error != mraa::SUCCESS) {
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": mraa_i2c_address() failed");
-        return;
-    }
-
-    // setting GLVL 0x1 (64LSB/g) and MODE 0x1 (Measurement Mode)
-    data = (BIT (MMA7455_GLVL0) | BIT (MMA7455_MODE0));
-    error = i2cWriteReg (MMA7455_MCTL, &data, 0x1);
-    if (error != mraa::SUCCESS) {
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": writing mode register failed");
-        return;
-    }
-
-    if (mraa::SUCCESS != calibrate ()) {
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": calibrate() failed");
-        return;
-    }
-}
-
-mraa::Result
-MMA7455::calibrate () {
-    mraa::Result error = mraa::SUCCESS;
-    int i = 0;
-
-    accelData xyz;
-    xyz.value.x = xyz.value.y = xyz.value.z = 0;
-
-    do {
-        error = readData (&xyz.value.x, &xyz.value.y, &xyz.value.z);
-        if (mraa::SUCCESS != error) {
-            return error;
-        }
-
-        xyz.value.x += 2 * -xyz.value.x;
-        xyz.value.y += 2 * -xyz.value.y;
-        xyz.value.z += 2 * -(xyz.value.z - 64);
-
-        error = i2cWriteReg (MMA7455_XOFFL,  (unsigned char *) &xyz, 0x6);
-        if (error != mraa::SUCCESS) {
-            return error;
-        }
-
-    } while ( ++i < 3 );
-
-    return error;
-}
-
-mraa::Result
-MMA7455::readData (short * ptrX, short * ptrY, short * ptrZ) {
-    accelData xyz;
-    int nBytes = 0;
-
-    /*do {
-        nBytes = i2cReadReg (MMA7455_STATUS, &data, 0x1);
-    } while ( !(data & MMA7455_DRDY) && nBytes == mraa::SUCCESS);
-
-    if (nBytes == mraa::SUCCESS) {
-        std::cout << "NO_GDB :: 1" << std::endl;
-        return mraa::SUCCESS;
-    }*/
-
-    nBytes = i2cReadReg (MMA7455_XOUTL, (unsigned char *) &xyz, 0x6);
-    if (nBytes == 0) {
-        std::cout << "NO_GDB :: 2" << std::endl;
-        return mraa::ERROR_UNSPECIFIED;
-    }
-
-    if (xyz.reg.x_msb & 0x02) {
-        xyz.reg.x_msb |= 0xFC;
-    }
-
-    if (xyz.reg.y_msb & 0x02) {
-        xyz.reg.y_msb |= 0xFC;
-    }
-
-    if (xyz.reg.z_msb & 0x02) {
-        xyz.reg.z_msb |= 0xFC;
-    }
-
-    // The result is the g-force in units of 64 per 'g'.
-    *ptrX = xyz.value.x;
-    *ptrY = xyz.value.y;
-    *ptrZ = xyz.value.z;
-
-    return mraa::SUCCESS;
-}
-
-std::vector<short> MMA7455::readData() {
-    std::vector<short> v(3);
-    readData(&v[0], &v[1], &v[2]);
-    return v;
-}
-
-int
-MMA7455::i2cReadReg (unsigned char reg, uint8_t *buffer, int len) {
-    if (mraa::SUCCESS != m_i2ControlCtx.writeByte(reg)) {
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": mraa_i2c_write_byte() failed");
-        return 0;
-    }
-
-    return (int) m_i2ControlCtx.read(buffer, len);
-}
-
-mraa::Result
-MMA7455::i2cWriteReg (unsigned char reg, uint8_t *buffer, int len) {
-    mraa::Result error = mraa::SUCCESS;
-
-    uint8_t data[len + 1];
-    data[0] = reg;
-    memcpy(&data[1], buffer, len);
-
-    error = m_i2ControlCtx.write (data, len + 1);
-    if (error != mraa::SUCCESS) {
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": mraa_i2c_write() failed");
-        return error;
-    }
-
-    return error;
-}
diff --git a/src/mma7455/mma7455.hpp b/src/mma7455/mma7455.hpp
deleted file mode 100644
index ce9bae9..0000000
--- a/src/mma7455/mma7455.hpp
+++ /dev/null
@@ -1,244 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <vector>
-#include <mraa/i2c.hpp>
-
-#define ADDR               0x1D // device address
-
-// Register names according to the datasheet.
-// Register 0x1C is sometimes called 'PW', and sometimes 'PD'.
-// The two reserved registers cannot be used.
-#define MMA7455_XOUTL 0x00      // Read only, Output Value X LSB
-#define MMA7455_XOUTH 0x01      // Read only, Output Value X MSB
-#define MMA7455_YOUTL 0x02      // Read only, Output Value Y LSB
-#define MMA7455_YOUTH 0x03      // Read only, Output Value Y MSB
-#define MMA7455_ZOUTL 0x04      // Read only, Output Value Z LSB
-#define MMA7455_ZOUTH 0x05      // Read only, Output Value Z MSB
-#define MMA7455_XOUT8 0x06      // Read only, Output Value X 8 bits
-#define MMA7455_YOUT8 0x07      // Read only, Output Value Y 8 bits
-#define MMA7455_ZOUT8 0x08      // Read only, Output Value Z 8 bits
-#define MMA7455_STATUS 0x09     // Read only, Status Register
-#define MMA7455_DETSRC 0x0A     // Read only, Detection Source Register
-#define MMA7455_TOUT 0x0B       // Temperature Output Value (Optional)
-#define MMA7455_RESERVED1 0x0C  // Reserved
-#define MMA7455_I2CAD 0x0D      // Read/Write, I2C Device Address
-#define MMA7455_USRINF 0x0E     // Read only, User Information (Optional)
-#define MMA7455_WHOAMI 0x0F     // Read only, "Who am I" value (Optional)
-#define MMA7455_XOFFL 0x10      // Read/Write, Offset Drift X LSB
-#define MMA7455_XOFFH 0x11      // Read/Write, Offset Drift X MSB
-#define MMA7455_YOFFL 0x12      // Read/Write, Offset Drift Y LSB
-#define MMA7455_YOFFH 0x13      // Read/Write, Offset Drift Y MSB
-#define MMA7455_ZOFFL 0x14      // Read/Write, Offset Drift Z LSB
-#define MMA7455_ZOFFH 0x15      // Read/Write, Offset Drift Z MSB
-#define MMA7455_MCTL 0x16       // Read/Write, Mode Control Register
-#define MMA7455_INTRST 0x17     // Read/Write, Interrupt Latch Reset
-#define MMA7455_CTL1 0x18       // Read/Write, Control 1 Register
-#define MMA7455_CTL2 0x19       // Read/Write, Control 2 Register
-#define MMA7455_LDTH 0x1A       // Read/Write, Level Detection Threshold Limit Value
-#define MMA7455_PDTH 0x1B       // Read/Write, Pulse Detection Threshold Limit Value
-#define MMA7455_PD 0x1C         // Read/Write, Pulse Duration Value
-#define MMA7455_LT 0x1D         // Read/Write, Latency Time Value (between pulses)
-#define MMA7455_TW 0x1E         // Read/Write, Time Window for Second Pulse Value
-#define MMA7455_RESERVED2 0x1F  // Reserved
-
-// Defines for the bits to be able to change
-// between the bit number and the binary definition.
-// By using the bit number, programming MMA7455
-// is like programming an AVR microcontroller.
-// But instead of using "(1<<X)", or "_BV(X)",
-// the Arduino "bit(X)" is used.
-#define MMA7455_D0 0
-#define MMA7455_D1 1
-#define MMA7455_D2 2
-#define MMA7455_D3 3
-#define MMA7455_D4 4
-#define MMA7455_D5 5
-#define MMA7455_D6 6
-#define MMA7455_D7 7
-
-// Status Register
-#define MMA7455_DRDY MMA7455_D0
-#define MMA7455_DOVR MMA7455_D1
-#define MMA7455_PERR MMA7455_D2
-
-// Mode Control Register
-#define MMA7455_MODE0 MMA7455_D0
-#define MMA7455_MODE1 MMA7455_D1
-#define MMA7455_GLVL0 MMA7455_D2
-#define MMA7455_GLVL1 MMA7455_D3
-#define MMA7455_STON MMA7455_D4
-#define MMA7455_SPI3W MMA7455_D5
-#define MMA7455_DRPD MMA7455_D6
-
-// Control 1 Register
-#define MMA7455_INTPIN MMA7455_D0
-#define MMA7455_INTREG0 MMA7455_D1
-#define MMA7455_INTREG1 MMA7455_D2
-#define MMA7455_XDA MMA7455_D3
-#define MMA7455_YDA MMA7455_D4
-#define MMA7455_ZDA MMA7455_D5
-#define MMA7455_THOPT MMA7455_D6
-#define MMA7455_DFBW MMA7455_D7
-
-// Control 2 Register
-#define MMA7455_LDPL MMA7455_D0
-#define MMA7455_PDPL MMA7455_D1
-#define MMA7455_DRVO MMA7455_D2
-
-// Interrupt Latch Reset Register
-#define MMA7455_CLR_INT1 MMA7455_D0
-#define MMA7455_CLR_INT2 MMA7455_D1
-
-// Detection Source Register
-#define MMA7455_INT1 MMA7455_D0
-#define MMA7455_INT2 MMA7455_D1
-#define MMA7455_PDZ MMA7455_D2
-#define MMA7455_PDY MMA7455_D3
-#define MMA7455_PDX MMA7455_D4
-#define MMA7455_LDZ MMA7455_D5
-#define MMA7455_LDY MMA7455_D6
-#define MMA7455_LDX MMA7455_D7
-
-// I2C Device Address Register
-#define MMA7455_I2CDIS MMA7455_D7
-
-#define HIGH               1
-#define LOW                0
-
-namespace upm {
-
-typedef union {
-    struct {
-        unsigned char x_lsb;
-        unsigned char x_msb;
-        unsigned char y_lsb;
-        unsigned char y_msb;
-        unsigned char z_lsb;
-        unsigned char z_msb;
-    } reg;
-
-    struct {
-        short x;
-        short y;
-        short z;
-    } value;
-} accelData;
-
-#define BIT(n) (1<<n)
-
-/**
- * @brief MMA7455 Accelerometer
- * @defgroup mma7455 libupm-mma7455
- * @ingroup generic i2c accelerometer
- */
-/**
- * @library mma7455
- * @sensor mma7455
- * @comname Three Axis +/- 2/4/8 g Digital Accelerometer
- * @type accelerometer
- * @man generic
- * @con i2c
- * @web http://www.nxp.com/products/sensors/accelerometers/3-axis-accelerometers/2g-4g-8g-low-g-digital-accelerometer:MMA745xL
- *
- * @brief API for the MMA7455 Accelerometer
- *
- * This module defines the MMA7455 interface for libmma7455
- *
- * @image html mma7455.jpg
- * @snippet mma7455.cxx Interesting
- */
-class MMA7455 {
-    public:
-        /**
-         * Instantiates an MMA7455 object
-         *
-         * @param bus Number of the used bus
-         * @param devAddr Address of the used I2C device
-         */
-        MMA7455 (int bus=0, int devAddr=0x1D);
-
-        /**
-         * Returns the name of the component
-         *
-         * @return Name of the component
-         */
-        std::string name()
-        {
-            return m_name;
-        }
-
-        /**
-         * Calibrates the sensor
-         *
-         * @return 0 (MRAA_SUCCESS) if successful; non-zero otherwise
-         */
-        mraa::Result calibrate ();
-
-        /**
-         * Reads X-axis, Y-axis, and Z-axis acceleration data
-         *
-         * @param ptrX X-axis
-         * @param ptrY Y-axis
-         * @param ptrZ Z-axis
-         *
-         * @return 0 (MRAA_SUCCESS) if successful; non-zero otherwise
-         */
-        mraa::Result readData (short * ptrX, short * ptrY, short * ptrZ);
-
-        /**
-         * Reads X-axis, Y-axis, and Z-axis acceleration data
-         *
-         * @return std::vector containing X, Y, Z acceleration data
-         */
-        std::vector<short> readData ();
-
-        /**
-         * Internal function for reading I2C data
-         *
-         * @param reg Register address
-         * @param buffer Register data buffer
-         * @param len Buffer size
-         */
-        int i2cReadReg (unsigned char reg, uint8_t *buffer, int len);
-
-        /**
-         * Internal function for writing I2C data
-         *
-         * @param reg Register address
-         * @param buffer Register data buffer
-         * @param len Buffer size
-         */
-        mraa::Result i2cWriteReg (unsigned char reg, uint8_t *buffer, int len);
-
-    private:
-        std::string m_name;
-        int              m_controlAddr;
-        int              m_bus;
-        mraa::I2c  m_i2ControlCtx;
-};
-
-}
diff --git a/src/mma7455/mma7455.i b/src/mma7455/mma7455.i
deleted file mode 100644
index 5422a74..0000000
--- a/src/mma7455/mma7455.i
+++ /dev/null
@@ -1,20 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "arrays_java.i";
-%include "../java_buffer.i"
-%include "std_vector.i"
-%apply short *OUTPUT { short * ptrX, short * ptrY, short * ptrZ };
-%template(ShortVector) std::vector<short>;
-
-JAVA_JNI_LOADLIBRARY(javaupm_mma7455)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "mma7455.hpp"
-%}
-%include "mma7455.hpp"
-/* END Common SWIG syntax */
diff --git a/src/mma7455/mma7455.json b/src/mma7455/mma7455.json
deleted file mode 100644
index 7b64a61..0000000
--- a/src/mma7455/mma7455.json
+++ /dev/null
@@ -1,63 +0,0 @@
-{
-    "Library": "mma7455",
-    "Description": "NXP MMA7455 Accelerometer library",
-    "Sensor Class": {
-        "MMA7455": {
-            "Name": "API for the NXP MMA7455 Accelerometer",
-            "Description": "This is the UPM Module for the NXP MMA7455 Accelerometer. The MMA7455L 3-Axis Digital Output Accelerometer is a low power, micro machined sensor capable of measuring acceleration along its X, Y, and Z axes. It offers several convenient integrated features including an analog to digital converter (ADC), digital low-pass filter, and selectable sensitivity ranges of 2g, 4g, or 8g. This device can be easily configured to detect quick motion pulses as single taps, double taps, and 0g (free fall) conditions on any or all axes and provides configurable interrupt pins (INT1 and INT2) for each type of event.",
-            "Aliases": ["mma7455", "MMA7455 3-Axis Accelerometer Module"],
-            "Categories": ["accelerometer"],
-            "Connections": ["i2c", "spi"],
-            "Project Type": ["prototyping", "robotics"],
-            "Manufacturers": ["NXP", "Freescale"],
-            "Image": "mma7455.jpg",
-            "Examples": {
-                "Java": ["MMA7455_Example.java"],
-                "C++": ["mma7455.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 2.5,
-                    "max": 5.5
-                },
-
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Sensitivity": {
-                    "unit": "g",
-                    "min": 2,
-                    "max": 10
-                },
-                "Supply Current":{
-                    "Standby Mode": {
-                        "unit": "uA",
-                        "typ": 26
-                    },
-                    "Full Operation": {
-                        "unit": "mA",
-                        "typ": "<3"
-                    }
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need pull up resistors"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.parallax.com/product/28526"],
-                "Datasheets": ["https://www.parallax.com/sites/default/files/downloads/28526-Freescale-MMA7455L-Device-Documentation.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/mma7660/CMakeLists.txt b/src/mma7660/CMakeLists.txt
deleted file mode 100644
index 0285d80..0000000
--- a/src/mma7660/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME mma7660
-    DESCRIPTION "I2C 3-axis Digital Accelerometer (1.5g)"
-    C_HDR mma7660.h mma7660_regs.h
-    C_SRC mma7660.c
-    CPP_HDR mma7660.hpp
-    CPP_SRC mma7660.cxx
-    FTI_SRC mma7660_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa)
diff --git a/src/mma7660/mma7660.c b/src/mma7660/mma7660.c
deleted file mode 100644
index c27e9e6..0000000
--- a/src/mma7660/mma7660.c
+++ /dev/null
@@ -1,368 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string.h>
-#include <assert.h>
-#include "mma7660.h"
-
-mma7660_context mma7660_init(int bus, uint8_t address)
-{
-    mma7660_context dev =
-        (mma7660_context)malloc(sizeof(struct _mma7660_context));
-
-    if (!dev)
-        return NULL;
-
-    memset((void *)dev, 0, sizeof(struct _mma7660_context));
-
-    dev->i2c = NULL;
-    dev->gpio = NULL;
-    dev->isrInstalled = false;
-
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        mma7660_close(dev);
-        return NULL;
-    }
-
-    // setup our i2c
-    if ( !(dev->i2c = mraa_i2c_init(bus)) )
-    {
-        printf("%s: mraa_i2c_init() failed\n", __FUNCTION__);
-        mma7660_close(dev);
-        return NULL;
-    }
-
-    if (mraa_i2c_address(dev->i2c, address))
-    {
-        printf("%s: mraa_i2c_address() failed\n", __FUNCTION__);
-        mma7660_close(dev);
-        return NULL;
-    }
-
-    return dev;
-}
-
-void mma7660_close(mma7660_context dev)
-{
-    assert(dev != NULL);
-
-    mma7660_uninstall_isr(dev);
-
-    if (dev->i2c)
-    {
-        mma7660_set_mode_standby(dev);
-        mraa_i2c_stop(dev->i2c);
-    }
-
-    free(dev);
-}
-
-upm_result_t mma7660_write_byte(const mma7660_context dev,
-                                uint8_t reg, uint8_t byte)
-{
-    assert(dev != NULL);
-
-    if (mraa_i2c_write_byte_data(dev->i2c, byte, reg))
-    {
-        printf("%s: mraa_i2c_write_byte_data() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t mma7660_read_byte(const mma7660_context dev, uint8_t reg,
-                               uint8_t *byte)
-{
-    uint8_t data[11];
-    assert(dev != NULL);
-
-    int ret = mraa_i2c_read_bytes_data(dev->i2c, 0x00, data, 11);
-
-    if (ret != 11) {
-        printf("%s: mraa_i2c_read_bytes_data() failed.\n", __FUNCTION__);
-        printf("returned %d bytes upon read\n", ret);
-        if (byte)
-            *byte = 0;
-
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    if (byte)
-        *byte = (uint8_t)(data[reg] & 0xff);
-
-  return UPM_SUCCESS;
-}
-
-upm_result_t mma7660_get_raw_values(const mma7660_context dev,
-                                    int *x, int *y, int *z)
-{
-    assert(dev != NULL);
-
-    int rv;
-    if (x)
-    {
-        if ( (rv = mma7660_get_verified_axis(dev, MMA7660_REG_XOUT, x)) )
-            return rv;
-    }
-    if (y)
-    {
-        if ( (rv = mma7660_get_verified_axis(dev, MMA7660_REG_YOUT, y)) )
-            return rv;
-    }
-    if (z)
-    {
-        if ( (rv = mma7660_get_verified_axis(dev, MMA7660_REG_ZOUT, z)) )
-            return rv;
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t mma7660_set_mode_active(const mma7660_context dev)
-{
-    assert(dev != NULL);
-
-    uint8_t modeReg;
-    if (mma7660_read_byte(dev, MMA7660_REG_MODE, &modeReg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    // The D2 (TON bit) should be cleared, and the MODE bit set
-
-    modeReg &= ~MMA7660_MODE_TON;
-    modeReg |= MMA7660_MODE_MODE;
-
-    return mma7660_write_byte(dev, MMA7660_REG_MODE, modeReg);
-}
-
-upm_result_t mma7660_set_mode_standby(const mma7660_context dev)
-{
-    assert(dev != NULL);
-
-    uint8_t modeReg;
-    if (mma7660_read_byte(dev, MMA7660_REG_MODE, &modeReg))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    // the D0 (mode bit) and D2 (TON bit) should be cleared.
-
-    modeReg &= ~MMA7660_MODE_TON;
-    modeReg &= ~MMA7660_MODE_MODE;
-
-    return mma7660_write_byte(dev, MMA7660_REG_MODE, modeReg);
-}
-
-// read an axis value, verifying it's validity
-upm_result_t mma7660_get_verified_axis(const mma7660_context dev,
-                                       MMA7660_REG_T axis, int *val)
-{
-    assert(dev != NULL);
-
-    *val = 0;
-    // We only want one of the 3 axes
-
-    if (axis > 2)
-    {
-        printf("%s: axis must be 0, 1, or 2.\n", __FUNCTION__);
-        return UPM_ERROR_OUT_OF_RANGE;
-    }
-
-    // we need to check the alert bit and sign bits if the alert bit is
-    // set, this means that the register was being updated when the
-    // register was read, so re-read until it's clear.
-
-    uint8_t value = 0;
-    do {
-        if (mma7660_read_byte(dev, axis, &value))
-            return UPM_ERROR_OPERATION_FAILED;
-
-        // check alert bit
-    } while (value & 0x40);
-
-    // shift the sign bit over, and compensate
-    *val = ((int8_t)(value << 2) / 4);
-
-    return UPM_SUCCESS;
-}
-
-// read the tilt register, verifying it's validity
-upm_result_t mma7660_get_verified_tilt(const mma7660_context dev,
-                                       uint8_t *val)
-{
-    assert(dev != NULL);
-
-    // we need to check the alert bit and sign bits if the alert bit is
-    // set, this means that the register was being updated when the
-    // register was read, so re-read until it's clear.
-
-    do {
-        if (mma7660_read_byte(dev, MMA7660_REG_TILT, val))
-            return UPM_ERROR_OPERATION_FAILED;
-
-        // check alert bit
-    } while (*val & 0x40);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t mma7660_tilt_back_front(const mma7660_context dev,
-                                     uint8_t *bits)
-{
-    assert(dev != NULL);
-
-    if (mma7660_get_verified_tilt(dev, bits))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    // mask off the bits we don't care about
-    *bits &= 0x03;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t mma7660_tilt_landscape_portrait(const mma7660_context dev,
-                                             uint8_t *bits)
-{
-    assert(dev != NULL);
-
-    if (mma7660_get_verified_tilt(dev, bits))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    // mask off the bits we don't care about
-    *bits >>= 2;
-    *bits &= 0x07;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t mma7660_tilt_tap(const mma7660_context dev, bool *tap)
-{
-    assert(dev != NULL);
-
-    uint8_t val = 0;
-    if (mma7660_get_verified_tilt(dev, &val))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if (val & 0x20)
-        *tap = true;
-    else
-        *tap = false;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t mma7660_tilt_shake(const mma7660_context dev, bool *shake)
-{
-    assert(dev != NULL);
-
-    uint8_t val = 0;
-    if (mma7660_get_verified_tilt(dev, &val))
-        return UPM_ERROR_OPERATION_FAILED;
-
-    if (val & 0x80)
-        *shake = true;
-    else
-        *shake = false;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t mma7660_install_isr(const mma7660_context dev, int pin,
-                                 void (*isr)(void *), void *arg)
-{
-    assert(dev != NULL);
-
-    mma7660_uninstall_isr(dev);
-
-    if ( !(dev->gpio = mraa_gpio_init(pin)) )
-    {
-        printf("%s: mraa_gpio_init failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    mraa_gpio_dir(dev->gpio, MRAA_GPIO_IN);
-
-    // install our interrupt handler
-    mraa_gpio_isr(dev->gpio, MRAA_GPIO_EDGE_RISING,
-                  isr, arg);
-    dev->isrInstalled = true;
-
-    return UPM_SUCCESS;
-}
-
-void mma7660_uninstall_isr(const mma7660_context dev)
-{
-    assert(dev != NULL);
-
-    if (!dev->isrInstalled)
-        return;
-
-    mraa_gpio_isr_exit(dev->gpio);
-    dev->isrInstalled = false;
-    mraa_gpio_close(dev->gpio);
-    dev->gpio = NULL;
-}
-
-upm_result_t mma7660_set_interrupt_bits(const mma7660_context dev,
-                                        uint8_t ibits)
-{
-    assert(dev != NULL);
-
-    return mma7660_write_byte(dev, MMA7660_REG_INTSU, ibits);
-}
-
-upm_result_t mma7660_set_sample_rate(const mma7660_context dev,
-                                     MMA7660_AUTOSLEEP_T sr)
-{
-    assert(dev != NULL);
-
-    return mma7660_write_byte(dev, MMA7660_REG_SR, sr);
-}
-
-upm_result_t mma7660_get_acceleration(const mma7660_context dev,
-                                      float *ax, float *ay, float *az)
-{
-    assert(dev != NULL);
-
-    int x, y, z;
-
-    if (mma7660_get_raw_values(dev, &x, &y, &z))
-    {
-        printf("%s: mma7660_get_raw_values() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // 21.33, typical counts/g
-
-    if (ax)
-        *ax = x/21.33;
-    if (ay)
-        *ay = y/21.33;
-    if (az)
-        *az = z/21.33;
-
-    return UPM_SUCCESS;
-}
diff --git a/src/mma7660/mma7660.cxx b/src/mma7660/mma7660.cxx
deleted file mode 100644
index 38df355..0000000
--- a/src/mma7660/mma7660.cxx
+++ /dev/null
@@ -1,192 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015-2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <stdexcept>
-#include <string>
-
-#include "mma7660.hpp"
-
-using namespace upm;
-using namespace std;
-
-
-MMA7660::MMA7660(int bus, uint8_t address) :
-    m_mma7660(mma7660_init(bus, address))
-{
-    if (!m_mma7660)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": mma7660_init() failed");
-}
-
-MMA7660::~MMA7660()
-{
-    mma7660_close(m_mma7660);
-}
-
-bool MMA7660::writeByte(uint8_t reg, uint8_t byte)
-{
-    if (mma7660_write_byte(m_mma7660, reg, byte))
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": mma7660_write_byte() failed");
-    return true;
-}
-
-uint8_t MMA7660::readByte(uint8_t reg)
-{
-    uint8_t val = 0;
-    if (mma7660_read_byte(m_mma7660, reg, &val))
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": mma7660_read_byte() failed");
-
-    return val;
-}
-
-void MMA7660::getRawValues(int *x, int *y, int *z)
-{
-    if (mma7660_get_raw_values(m_mma7660, x, y, z))
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": mma7660_get_raw_values() failed");
-}
-
-void MMA7660::setModeActive()
-{
-    if (mma7660_set_mode_active(m_mma7660))
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": mma7660_set_mode_active() failed");
-}
-
-void MMA7660::setModeStandby()
-{
-    if (mma7660_set_mode_standby(m_mma7660))
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": mma7660_set_mode_standby() failed");
-}
-
-// read an axis value, verifying it's validity
-int MMA7660::getVerifiedAxis(MMA7660_REG_T axis)
-{
-    // We only want one of the 3 axes
-
-    if (axis > 2)
-    {
-        throw std::out_of_range(std::string(__FUNCTION__) +
-                                ": axis must be 0, 1, or 2.");
-        return 0;
-    }
-
-    int val;
-    if (mma7660_get_verified_axis(m_mma7660, axis, &val))
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": mma7660_get_verified_axis() failed");
-
-    return val;
-}
-
-// read the tilt register, verifying it's validity
-uint8_t MMA7660::getVerifiedTilt()
-{
-    uint8_t val;
-    if (mma7660_get_verified_tilt(m_mma7660, &val))
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": mma7660_get_verified_axis() failed");
-
-    return val;
-}
-
-uint8_t MMA7660::tiltBackFront()
-{
-    uint8_t val;
-    if (mma7660_tilt_back_front(m_mma7660, &val))
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": mma7660_tilt_back_front() failed");
-
-    return val;
-}
-
-uint8_t MMA7660::tiltLandscapePortrait()
-{
-    uint8_t val;
-    if (mma7660_tilt_landscape_portrait(m_mma7660, &val))
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": mma7660_tilt_landscape_portrait() failed");
-
-    return val;
-}
-
-bool MMA7660::tiltTap()
-{
-    bool val;
-    if (mma7660_tilt_tap(m_mma7660, &val))
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": mma7660_tilt_tap_portrait() failed");
-
-    return val;
-}
-
-bool MMA7660::tiltShake()
-{
-    bool val;
-    if (mma7660_tilt_shake(m_mma7660, &val))
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": mma7660_tilt_tap_shake() failed");
-
-    return val;
-}
-
-void MMA7660::installISR(int pin, void (*isr)(void *), void *arg)
-{
-    if (mma7660_install_isr(m_mma7660, pin, isr, arg))
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": mma7660_install_isr() failed");
-}
-
-void MMA7660::uninstallISR()
-{
-    mma7660_uninstall_isr(m_mma7660);
-}
-
-bool MMA7660::setInterruptBits(uint8_t ibits)
-{
-    if (mma7660_set_interrupt_bits(m_mma7660, ibits))
-        return false;
-    else
-        return true;
-}
-
-bool MMA7660::setSampleRate(MMA7660_AUTOSLEEP_T sr)
-{
-    if (mma7660_set_sample_rate(m_mma7660, sr))
-        return false;
-    else
-        return true;
-}
-
-void MMA7660::getAcceleration(float *ax, float *ay, float *az)
-{
-    if (mma7660_get_acceleration(m_mma7660, ax, ay, az))
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": mma7660_get_acceleration() failed");
-}
-
diff --git a/src/mma7660/mma7660.h b/src/mma7660/mma7660.h
deleted file mode 100644
index afdfcfd..0000000
--- a/src/mma7660/mma7660.h
+++ /dev/null
@@ -1,251 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <upm.h>
-
-#include <mraa/i2c.h>
-#include <mraa/gpio.h>
-
-#include "mma7660_regs.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    /**
-     * @file mma7660.h
-     * @library mma7660
-     * @brief C API for the mma7660 driver
-     *
-     * @include mma7660.c
-     */
-
-    /**
-     * Device context
-     */
-    typedef struct _mma7660_context {
-        mraa_i2c_context  i2c;
-        mraa_gpio_context gpio;
-
-        bool              isrInstalled;
-    } *mma7660_context;
-
-    /**
-     * MMA7660 initialization.
-     *
-     * @param bus I2C bus to use
-     * @param address Address for this sensor
-     */
-    mma7660_context mma7660_init(int bus, uint8_t address);
-
-    /**
-     * MMA7660 destructor
-     *
-     * @param dev Device context.
-     */
-    void mma7660_close(mma7660_context dev);
-
-    /**
-     * Writes a byte value into a register
-     *
-     * @param dev Device context.
-     * @param reg Register location to write into
-     * @param byte Byte to write
-     * @return UPM result
-     */
-    upm_result_t mma7660_write_byte(const mma7660_context dev,
-                                    uint8_t reg, uint8_t byte);
-
-    /**
-     * Reads a byte value from a register
-     *
-     * @param dev Device context.
-     * @param reg Register location to read from
-     * @param byte A pointer to hold the value that was read
-     * @return UPM result
-     */
-    upm_result_t mma7660_read_byte(const mma7660_context dev, uint8_t reg,
-                                   uint8_t *byte);
-
-    /**
-     * Reads the current value of conversion
-     *
-     * @param dev Device context.
-     * @param x Returned x value
-     * @param y Returned y value
-     * @param z Returned z value
-     * @return UPM result
-     */
-    upm_result_t mma7660_get_raw_values(const mma7660_context dev,
-                                        int *x, int *y, int *z);
-
-    /**
-     * Gets the computed acceleration
-     *
-     * @param dev Device context.
-     * @param ax Returned computed acceleration of the X-axis
-     * @param ay Returned computed acceleration of the Y-axis
-     * @param az Returned computed acceleration of the Z-axis
-     * @return UPM result
-     */
-    upm_result_t mma7660_get_acceleration(const mma7660_context dev,
-                                          float *ax, float *ay, float *az);
-
-    /**
-     * Reads an axis, verifying its validity. The value passed must be
-     * one of MMA7660_REG_XOUT, MMA7660_REG_YOUT, or MMA7660_REG_ZOUT.
-     *
-     * @param dev Device context.
-     * @param axis Axis to read
-     * @param val pointer containing returned value
-     * @return UPM result
-     */
-    upm_result_t mma7660_get_verified_axis(const mma7660_context dev,
-                                           MMA7660_REG_T axis, int *val);
-
-    /**
-     * Reads the tilt register, verifying its validity
-     *
-     * @param dev Device context.
-     * @param val Pointer to returned value
-     * @return UPM result
-     */
-    upm_result_t mma7660_get_verified_tilt(const mma7660_context dev,
-                                           uint8_t *val);
-
-    /**
-     * Puts the device in the active mode. In this mode, register
-     * writes are not allowed. Place the device in the standby mode before
-     * attempting to write registers.
-     *
-     * @param dev Device context.
-     * @return UPM result
-     */
-    upm_result_t mma7660_set_mode_active(const mma7660_context dev);
-
-    /**
-     * Puts the device in the standby (power saving) mode. Note: when in
-     * the standby mode, there is no valid data in the registers. In
-     * addition, the only way to write a register is to put the
-     * device in the standby mode.
-     *
-     * @param dev Device context.
-     * @return UPM result
-     */
-    upm_result_t mma7660_set_mode_standby(const mma7660_context dev);
-
-    /**
-     * Reads tiltBackFront bits
-     *
-     * The value returned is one of the MMA7660_TILT_BF_T values
-     *
-     * @param dev Device context.
-     * @param bits Pointer to returned bits corresponding to the
-     * BackFront tilt status
-     * @return UPM result
-     */
-    upm_result_t mma7660_tilt_back_front(const mma7660_context dev,
-                                         uint8_t *bits);
-
-    /**
-     * Reads tiltLandscapePortrait bits
-     *
-     * The value returned is one of the MMA7660_TILT_LP_T values
-     *
-     * @param dev Device context.
-     * @param bits Pointer to returned bits corresponding to the
-     * LandscapePortrait tilt status
-     * @return UPM result
-     */
-    upm_result_t mma7660_tilt_landscape_portrait(const mma7660_context dev,
-                                                 uint8_t *bits);
-
-    /**
-     * Reads the tiltTap status
-     *
-     * @param dev Device context.
-     * @param tap Pointer to a bool indicating tap detection
-     * @return UPM result
-     */
-    upm_result_t mma7660_tilt_tap(const mma7660_context dev, bool *tap);
-
-    /**
-     * Reads the tiltShake status
-     *
-     * @param dev Device context.
-     * @param shake Pointer to a bool indicating shake detection
-     * @return UPM result
-     */
-    upm_result_t mma7660_tilt_shake(const mma7660_context dev, bool *shake);
-
-    /**
-     * Installs an interrupt service routine (ISR) to be called when
-     * an interrupt occurs
-     *
-     * @param dev Device context.
-     * @param pin GPIO pin to use as the interrupt pin
-     * @param isr Pointer to a function to be called on interrupt
-     * @param arg Pointer to an object to be supplied as an
-     * argument to the ISR.
-     * @return UPM result
-     */
-    upm_result_t mma7660_install_isr(const mma7660_context dev, int pin,
-                                     void (*isr)(void *), void *arg);
-
-    /**
-     * Uninstalls the previously installed ISR
-     *
-     * @param dev Device context.
-     */
-    void mma7660_uninstall_isr(const mma7660_context dev);
-
-    /**
-     * Enables interrupt generation based on passed interrupt bits.
-     * The bits are a bitmask of the requested MMA7660_INTR_T values.
-     * Note: the device must be in the standby mode to set this register.
-     *
-     * @param dev Device context.
-     * @param ibits Sets the requested interrupt bits
-     * @return UPM result
-     */
-    upm_result_t mma7660_set_interrupt_bits(const mma7660_context dev,
-                                            uint8_t ibits);
-
-    /**
-     * Sets the sampling rate of the sensor. The value supplied must
-     * be one of the MMA7660_AUTOSLEEP_T values.
-     *
-     * @param dev Device context.
-     * @param sr One of the MMA7660_AUTOSLEEP_T values
-     * @return UPM result
-     */
-    upm_result_t mma7660_set_sample_rate(const mma7660_context dev,
-                                         MMA7660_AUTOSLEEP_T sr);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/mma7660/mma7660.hpp b/src/mma7660/mma7660.hpp
deleted file mode 100644
index ec260dd..0000000
--- a/src/mma7660/mma7660.hpp
+++ /dev/null
@@ -1,250 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015-2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <vector>
-
-#include "mma7660.h"
-
-namespace upm {
-
-    /**
-     * @brief MMA7660 3-Axis Digital Accelerometer
-     * @defgroup mma7660 libupm-mma7660
-     * @ingroup seeed i2c gpio accelerometer
-     */
-    /**
-     * @library mma7660
-     * @sensor mma7660
-     * @comname I2C 3-axis Digital Accelerometer (1.5g)
-     * @altname Grove 3-Axis Digital Accelerometer (1.5g)
-     * @type accelerometer
-     * @man seeed
-     * @con i2c gpio
-     * @web http://www.nxp.com/products/sensors/accelerometers/3-axis-accelerometers/1.5g-low-g-digital-accelerometer:MMA7660FC
-     *
-     * @brief API for the MMA7660 I2C 3-Axis Digital Accelerometer
-     *
-     * UPM module for the MMA7660 I2C 3-axis digital accelerometer.
-     * This device supports a variety of capabilities, including the
-     * generation of interrupts for various conditions, tilt and basic
-     * gesture detection, and X/Y/Z-axis measurements of g-forces
-     * being applied (up to 1.5g)
-     *
-     * This module was tested with the Grove 3-Axis Digital
-     * Accelerometer (1.5g)
-     *
-     * @image html mma7660.jpg
-     * @snippet mma7660.cxx Interesting
-     */
-    class MMA7660 {
-    public:
-
-        /**
-         * MMA7660 constructor
-         *
-         * @param bus I2C bus to use
-         * @param address Address for this sensor; default is 0x55
-         */
-        MMA7660(int bus, uint8_t address=MMA7660_DEFAULT_I2C_ADDR);
-
-        /**
-         * MMA7660 destructor
-         */
-        virtual ~MMA7660();
-
-        /**
-         * Writes a byte value into a register
-         *
-         * @param reg Register location to write into
-         * @param byte Byte to write
-         * @return True if successful
-         */
-        bool writeByte(uint8_t reg, uint8_t byte);
-
-        /**
-         * Reads a byte value from a register
-         *
-         * @param reg Register location to read from
-         * @return Value in a specified register
-         */
-        uint8_t readByte(uint8_t reg);
-
-        /**
-         * Reads the current value of conversion
-         *
-         * @param x Returned x value
-         * @param y Returned y value
-         * @param z Returned z value
-         */
-        void getRawValues(int *x, int *y, int *z);
-
-        /**
-         * Gets the computed acceleration
-         *
-         * @param ax Returned computed acceleration of the X-axis
-         * @param ay Returned computed acceleration of the Y-axis
-         * @param az Returned computed acceleration of the Z-axis
-         */
-        void getAcceleration(float *ax, float *ay, float *az);
-
-        /**
-         * Reads an axis, verifying its validity. The value passed must
-         * be one of REG_XOUT, REG_YOUT, or REG_ZOUT.
-         *
-         * @param axis Axis to read
-         * @return Axis value
-         */
-        int getVerifiedAxis(MMA7660_REG_T axis);
-
-        /**
-         * Reads the tilt register, verifying its validity
-         *
-         * @return Tilt value
-         */
-        uint8_t getVerifiedTilt();
-
-        /**
-         * Puts the device in the active mode. In this mode, register
-         * writes are not allowed. Place the device in the standby mode before
-         * attempting to write registers.
-         *
-         */
-        void setModeActive();
-
-        /**
-         * Puts the device in the standby (power saving) mode. Note: when in
-         * the standby mode, there is no valid data in the registers. In
-         * addition, the only way to write a register is to put the
-         * device in the standby mode.
-         *
-         */
-        void setModeStandby();
-
-        /**
-         * Reads tiltBackFront bits
-         *
-         * The value returned is one of the MMA7660_TILT_BF_T values
-         *
-         * @return Bits corresponding to the BackFront tilt status
-         */
-        uint8_t tiltBackFront();
-
-        /**
-         * Reads tiltLandscapePortrait bits
-         *
-         * The value returned is one of the MMA7660_TILT_LP_T values
-         *
-         * @return Bits corresponding to the LandscapePortrait tilt status
-         */
-        uint8_t tiltLandscapePortrait();
-
-        /**
-         * Reads the tiltTap status
-         *
-         * @return True if a tap is detected
-         */
-        bool tiltTap();
-
-        /**
-         * Reads the tiltShake status
-         *
-         * @return True if a shake is detected
-         */
-        bool tiltShake();
-
-        /**
-         * Uninstalls the previously installed ISR
-         *
-         */
-        void uninstallISR();
-
-        /**
-         * Enables interrupt generation based on passed interrupt bits.
-         * The bits are a bitmask of the requested MMA7660_INTR_T values.
-         * Note: the device must be in the standby mode to set this register.
-         *
-         * @param ibits Sets the requested interrupt bits
-         * @return True if successful
-         */
-        bool setInterruptBits(uint8_t ibits);
-
-        /**
-         * Sets the sampling rate of the sensor. The value supplied must
-         * be one of the MMA7660_AUTOSLEEP_T values.
-         *
-         * @param sr One of the MMA7660_AUTOSLEEP_T values
-         * @return True if successful
-         */
-        bool setSampleRate(MMA7660_AUTOSLEEP_T sr);
-
-        /**
-         * Reads the current acceleration values.  The returned memory
-         * is statically allocated and will be overwritten on each
-         * call.
-         *
-         * @return std::vector containing x, y, z.
-         */
-        std::vector<float> getAcceleration()
-        {
-            std::vector<float> values(3);
-            getAcceleration(&values[0], &values[1], &values[2]);
-            return values;
-        }
-
-        /**
-         * Reads the current value of conversion. The returned memory
-         * is statically allocated and will be overwritten on each
-         * call.
-         *
-         * @return std::vector containing x, y, z.
-         */
-        std::vector<int> getRawValues()
-        {
-            std::vector<int> values(3);
-            getRawValues(&values[0], &values[1], &values[2]);
-            return values;
-        }
-
-        /**
-         * Installs an interrupt service routine (ISR) to be called when
-         * an interrupt occurs
-         *
-         * @param pin GPIO pin to use as the interrupt pin
-         * @param isr Pointer to a function to be called on interrupt
-         * @param arg Pointer to an object to be supplied as an
-         * argument to the ISR.
-         */
-        void installISR(int pin, void (*isr)(void *), void *arg);
-
-    protected:
-        mma7660_context m_mma7660;
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        MMA7660(const MMA7660&) = delete;
-        MMA7660 &operator=(const MMA7660&) = delete;
-
-    };
-}
diff --git a/src/mma7660/mma7660.i b/src/mma7660/mma7660.i
deleted file mode 100644
index 1e21621..0000000
--- a/src/mma7660/mma7660.i
+++ /dev/null
@@ -1,31 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "arrays_java.i";
-%include "../java_buffer.i"
-%include "std_vector.i"
-
-%apply float *OUTPUT { float *ax, float *ay, float *az  };
-%apply int *OUTPUT { int *x, int *y, int *z };
-%ignore installISR(int , void *, void *);
-
-%template(IntVector) std::vector<int>;
-%template(FloatVector) std::vector<float>;
-
-JAVA_ADD_INSTALLISR_PIN(upm::MMA7660)
-JAVA_JNI_LOADLIBRARY(javaupm_mma7660)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%pointer_functions(int, intp);
-%pointer_functions(float, floatp);
-
-%{
-#include "mma7660_regs.h"
-#include "mma7660.hpp"
-%}
-%include "mma7660_regs.h"
-%include "mma7660.hpp"
-/* END Common SWIG syntax */
diff --git a/src/mma7660/mma7660.json b/src/mma7660/mma7660.json
deleted file mode 100644
index 0bfb77c..0000000
--- a/src/mma7660/mma7660.json
+++ /dev/null
@@ -1,56 +0,0 @@
-{
-    "Library": "mma7660",
-    "Description": "MMA7660 I2C 3-Axis Digital Accelerometer library",
-    "Sensor Class": {
-        "MMA7660": {
-            "Name": " API for the Seeed/NXP MMA7660 I2C 3-Axis Digital Accelerometer",
-            "Description": "This is the UPM Module for the Seeed/NXP MMA7660 i2c 3-axis digital accelerometer. This device supports a variety of capabilities, including the generation of interrupts for various conditions, tilt and basic gesture detection, and X/Y/Z-axis measurements of g-forces being applied",
-            "Aliases": ["mma7660", "Grove - 3-Axis Digital Accelerometer(1.5g)"],
-            "Categories": ["accelerometer"],
-            "Connections": ["i2c", "gpio"],
-            "Project Type": ["prototyping", "robotics"],
-            "Manufacturers": ["Seeed", "NXP"],
-            "Image": "mma7660.jpg",
-            "Examples": {
-                "Java": ["MMA7660_Example.java"],
-                "Python": ["mma7660.py"],
-                "Node.js": ["mma7660.js"],
-                "C++": ["mma7660.cxx"],
-                "C": ["mma7660.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.0,
-                    "max": 5.5
-                },
-                "Supply Current": {
-                    "unit": "uA",
-                    "min": 0.4,
-                    "max": 47
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Sensitivity": {
-                    "unit": "LSB/g",
-                    "sensitivity": "21"
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might Grove breakout shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might Grove breakout shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-3-Axis-Digital-Accelerometer(%C2%B11.5g)-p-765.html"],
-                "Datasheets": ["http://wiki.seeed.cc/Grove-3-Axis_Digital_Accelerometer-1.5g/"]
-            }
-        }
-    }
-}
diff --git a/src/mma7660/mma7660_fti.c b/src/mma7660/mma7660_fti.c
deleted file mode 100644
index b1140c3..0000000
--- a/src/mma7660/mma7660_fti.c
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "mma7660.h"
-#include "upm_fti.h"
-
-/**
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_mma7660_name[] = "MMA7660";
-const char upm_mma7660_description[] = "Digital 3-axis Accelerometer";
-const upm_protocol_t upm_mma7660_protocol[] = {UPM_I2C, UPM_GPIO};
-const upm_sensor_t upm_mma7660_category[] = {UPM_ACCELEROMETER};
-
-// forward declarations
-const void* upm_mma7660_get_ft(upm_sensor_t sensor_type);
-void* upm_mma7660_init_name();
-void upm_mma7660_close(void *dev);
-upm_result_t upm_mma7660_get_acceleration(void *dev, float *value,
-                                          upm_acceleration_u unit);
-
-const upm_sensor_descriptor_t upm_mma7660_get_descriptor()
-{
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_mma7660_name;
-    usd.description = upm_mma7660_description;
-    usd.protocol_size = 2;
-    usd.protocol = upm_mma7660_protocol;
-    usd.category_size = 1;
-    usd.category = upm_mma7660_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = &upm_mma7660_init_name,
-    .upm_sensor_close = &upm_mma7660_close,
-};
-
-static const upm_acceleration_ft aft =
-{
-    .upm_acceleration_get_value = &upm_mma7660_get_acceleration
-};
-
-const void* upm_mma7660_get_ft(upm_sensor_t sensor_type)
-{
-  switch(sensor_type)
-    {
-    case UPM_SENSOR:
-      return &ft;
-
-    case UPM_ACCELEROMETER:
-      return &aft;
-
-    default:
-      return NULL;
-    }
-}
-
-void* upm_mma7660_init_name()
-{
-    return NULL;
-}
-
-
-void upm_mma7660_close(void *dev)
-{
-    mma7660_close((mma7660_context)dev);
-}
-
-upm_result_t upm_mma7660_get_acceleration(void *dev, float *value,
-                                          upm_acceleration_u unit)
-{
-  return mma7660_get_acceleration((mma7660_context)dev, &value[0], &value[1],
-                                  &value[2]);
-}
diff --git a/src/mma7660/mma7660_regs.h b/src/mma7660/mma7660_regs.h
deleted file mode 100644
index d1086d8..0000000
--- a/src/mma7660/mma7660_regs.h
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#define MMA7660_DEFAULT_I2C_BUS 0
-#define MMA7660_DEFAULT_I2C_ADDR 0x4c
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    // MMA7660 registers
-    typedef enum {
-        MMA7660_REG_XOUT       = 0x00,
-        MMA7660_REG_YOUT       = 0x01,
-        MMA7660_REG_ZOUT       = 0x02,
-        MMA7660_REG_TILT       = 0x03,
-        MMA7660_REG_SRST       = 0x04, // Sampling Rate Status
-        MMA7660_REG_SPCNT      = 0x05, // sleep count
-        MMA7660_REG_INTSU      = 0x06, // Interrupt setup
-        MMA7660_REG_MODE       = 0x07, // operating mode
-        MMA7660_REG_SR         = 0x08, // auto-wake/sleep, SPS, and debounce
-        MMA7660_REG_PDET       = 0x09, // tap detection
-        MMA7660_REG_PD         = 0x0a  // tap debounce count
-        // 0x0b-0x1f reserved
-    } MMA7660_REG_T;
-
-    // interrupt enable register bits
-    typedef enum {
-        MMA7660_INTR_NONE          = 0x00, // disabled
-        MMA7660_INTR_FBINT         = 0x01, // front/back
-        MMA7660_INTR_PLINT         = 0x02, // up/down/right/left
-        MMA7660_INTR_PDINT         = 0x04, // tap detection
-        MMA7660_INTR_ASINT         = 0x08, // exit auto-sleep
-        MMA7660_INTR_GINT          = 0x10, // measurement intr
-        MMA7660_INTR_SHINTZ        = 0x20, // shake on Z
-        MMA7660_INTR_SHINTY        = 0x40, // shake on Y
-        MMA7660_INTR_SHINTX        = 0x80  // shake on X
-    } MMA7660_INTR_T;
-
-    // operating mode register bits
-    typedef enum {
-        MMA7660_MODE_MODE          = 0x01, // determines mode with MODE_TON
-        // 0x02 reserved
-        MMA7660_MODE_TON           = 0x04, // determines mode with MODE_MODE
-        MMA7660_MODE_AWE           = 0x08, // auto-wake
-        MMA7660_MODE_ASE           = 0x10, // auto-sleep
-        MMA7660_MODE_SCPS          = 0x20, // sleep count prescale
-        MMA7660_MODE_IPP           = 0x40, // intr out push-pull/open drain
-        MMA7660_MODE_IAH           = 0x80  // intr active low/high
-    } MMA7660_MODE_T;
-
-    // tilt BackFront (BF) bits
-    typedef enum {
-        MMA7660_BF_UNKNOWN          = 0x00,
-        MMA7660_BF_LYING_FRONT      = 0x01,
-        MMA7660_BF_LYING_BACK       = 0x02
-    } MMA7660_TILT_BF_T;
-
-    // tilt LandscapePortrait (LP) bits
-    typedef enum {
-        MMA7660_LP_UNKNOWN          = 0x00,
-        MMA7660_LP_LANDSCAPE_LEFT   = 0x01,
-        MMA7660_LP_LANDSCAPE_RIGHT  = 0x02,
-        MMA7660_LP_VERT_DOWN        = 0x05,
-        MMA7660_LP_VERT_UP          = 0x06
-    } MMA7660_TILT_LP_T;
-
-    // sample rate (auto-sleep) values
-    typedef enum {
-        MMA7660_AUTOSLEEP_120   = 0x00,
-        MMA7660_AUTOSLEEP_64    = 0x01,
-        MMA7660_AUTOSLEEP_32    = 0x02,
-        MMA7660_AUTOSLEEP_16    = 0x03,
-        MMA7660_AUTOSLEEP_8     = 0x04,
-        MMA7660_AUTOSLEEP_4     = 0x05,
-        MMA7660_AUTOSLEEP_2     = 0x06,
-        MMA7660_AUTOSLEEP_1     = 0x07
-    } MMA7660_AUTOSLEEP_T;
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/mma8x5x/CMakeLists.txt b/src/mma8x5x/CMakeLists.txt
deleted file mode 100644
index fdd28e5..0000000
--- a/src/mma8x5x/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "mma8x5x")
-set (libdescription "Tri-axis Accelerometer Sensor")
-set (module_src ${libname}.cpp)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/mma8x5x/mma8x5x.cpp b/src/mma8x5x/mma8x5x.cpp
deleted file mode 100644
index a1a5d7b..0000000
--- a/src/mma8x5x/mma8x5x.cpp
+++ /dev/null
@@ -1,346 +0,0 @@
-/*
- * Author: Norbert Wesp <nwesp@phytec.de>
- * Copyright (c) 2017 Phytec Messtechnik GmbH.
- *
- * based on: RIOT-driver mma8x5x by Johann Fischer <j.fischer@phytec.de>
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include <unistd.h>
-#include <stdlib.h>
-#include <endian.h>
-#include <time.h>
-
-#include "mma8x5x.hpp"
-
-using namespace upm;
-
-MMA8X5X::MMA8X5X (int bus, mma8x5x_params_t *params,
-                                         int devAddr) : m_i2ControlCtx(bus) {
-    uint8_t reg;
-
-    s_data->x = 0;
-    s_data->y = 0;
-    s_data->z = 0;
-
-    m_controlAddr = devAddr;
-    m_bus = bus;
-
-    mraa::Result ret = m_i2ControlCtx.address(m_controlAddr);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_address() failed");
-    }
-
-    if (setDeviceParams(params)) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": setDeviceParams() failed");
-    }
-
-    /* reset device */
-    ret = m_i2ControlCtx.writeReg(MMA8X5X_CTRL_REG2, MMA8X5X_CTRL_REG2_RST);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_byte_data() failed");
-    }
-    do {
-        usleep(500000);
-        reg = m_i2ControlCtx.readReg(MMA8X5X_CTRL_REG2);
-    } while (reg & MMA8X5X_CTRL_REG2_RST);
-
-    /* configure the user offset */
-    ret = m_i2ControlCtx.writeReg(MMA8X5X_OFF_X, s_params->offsetX);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_byte_data() failed");
-    }
-    ret = m_i2ControlCtx.writeReg(MMA8X5X_OFF_Y, s_params->offsetY);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_byte_data() failed");
-    }
-    ret = m_i2ControlCtx.writeReg(MMA8X5X_OFF_Z, s_params->offsetZ);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_byte_data() failed");
-    }
-
-    /* configure range */
-    reg = (s_params->range & MMA8X5X_XYZ_DATA_CFG_FS_MASK);
-    ret = m_i2ControlCtx.writeReg(MMA8X5X_XYZ_DATA_CFG, reg);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_byte_data() failed");
-    }
-
-    /* configure rate and activate the device */
-    reg = ((s_params->rate & MMA8X5X_CTRL_REG1_DR_MASK) |
-           MMA8X5X_CTRL_REG1_ACTIVE);
-    ret = m_i2ControlCtx.writeReg(MMA8X5X_CTRL_REG1, reg);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_byte_data() failed");
-    }
-}
-
-int
-MMA8X5X::setDeviceName(uint8_t type)
-{
-    uint8_t id;
-
-    if (type == 0){
-        id = m_i2ControlCtx.readReg(MMA8X5X_DEVICE_ID_REG);
-    } else {
-        id = type;
-    }
-
-    switch (id) {
-        case (MMA8X5X_DEVICE_ID_MMA8652):
-            m_name = MMA8X5X_NAME_MMA8652;
-            s_params->type = MMA8X5X_DEVICE_ID_MMA8652;
-            break;
-        case (MMA8X5X_DEVICE_ID_MMA8653):
-            m_name = MMA8X5X_NAME_MMA8653;
-            s_params->type = MMA8X5X_DEVICE_ID_MMA8653;
-            break;
-        case (MMA8X5X_DEVICE_ID_MMA8451):
-            m_name = MMA8X5X_NAME_MMA8451;
-            s_params->type = MMA8X5X_DEVICE_ID_MMA8451;
-            break;
-        case (MMA8X5X_DEVICE_ID_MMA8452):
-            m_name = MMA8X5X_NAME_MMA8452;
-            s_params->type = MMA8X5X_DEVICE_ID_MMA8452;
-            break;
-        case (MMA8X5X_DEVICE_ID_MMA8453):
-            m_name = MMA8X5X_NAME_MMA8453;
-            s_params->type = MMA8X5X_DEVICE_ID_MMA8453;
-            break;
-        default:
-            return -1;
-    }
-
-    return 0;
-}
-
-int
-MMA8X5X::setDeviceParams (mma8x5x_params_t* params)
-{
-    if (params == NULL) {
-        if (setDeviceName(0)) {
-            return -1;
-        }
-
-        s_params->rate = MMA8X5X_RATE_DEFAULT;
-        s_params->range = MMA8X5X_RANGE_DEFAULT;
-        s_params->offsetX = 0;
-        s_params->offsetY = 0;
-        s_params->offsetZ = 0;
-    } else {
-        if (params->type != MMA8X5X_DEVICE_ID_MMA8652 &&
-            params->type != MMA8X5X_DEVICE_ID_MMA8653 &&
-            params->type != MMA8X5X_DEVICE_ID_MMA8451 &&
-            params->type != MMA8X5X_DEVICE_ID_MMA8452 &&
-            params->type != MMA8X5X_DEVICE_ID_MMA8453) {
-            /* given type is not supported */
-            return -1;
-        }
-        setDeviceName(params->type);
-
-        if (params->rate != MMA8X5X_RATE_800HZ &&
-            params->rate != MMA8X5X_RATE_400HZ &&
-            params->rate != MMA8X5X_RATE_200HZ &&
-            params->rate != MMA8X5X_RATE_100HZ &&
-            params->rate != MMA8X5X_RATE_50HZ &&
-            params->rate != MMA8X5X_RATE_1HZ25 &&
-            params->rate != MMA8X5X_RATE_6HZ25 &&
-            params->rate != MMA8X5X_RATE_1HZ56) {
-            /* given rate is not supported */
-            return -1;
-        }
-        s_params->rate = params->rate;
-
-        if (params->range != MMA8X5X_RANGE_2G &&
-            params->range != MMA8X5X_RANGE_4G &&
-            params->range != MMA8X5X_RANGE_8G) {
-            /* given range is not supported */
-            return -1;
-        }
-        s_params->range = params->range;
-
-        s_params->offsetX = params->offsetX;
-        s_params->offsetY = params->offsetY;
-        s_params->offsetZ = params->offsetZ;
-    }
-
-    return 0;
-}
-
-int
-MMA8X5X::setUserOffset(int8_t x, int8_t y, int8_t z)
-{
-    mraa::Result ret = m_i2ControlCtx.writeReg(MMA8X5X_OFF_X, (uint8_t)x);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_byte_data() failed");
-        return -1;
-    }
-    ret = m_i2ControlCtx.writeReg(MMA8X5X_OFF_Y, (uint8_t)y);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_byte_data() failed");
-        return -1;
-    }
-    ret = m_i2ControlCtx.writeReg(MMA8X5X_OFF_Z, (uint8_t)z);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_byte_data() failed");
-        return -1;
-    }
-
-    return 0;
-}
-
-int
-MMA8X5X::setActive(void)
-{
-    uint8_t reg;
-
-    reg = m_i2ControlCtx.readReg(MMA8X5X_CTRL_REG1);
-    reg |= MMA8X5X_CTRL_REG1_ACTIVE;
-
-    mraa::Result ret = m_i2ControlCtx.writeReg(MMA8X5X_CTRL_REG1, reg);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_byte_data() failed");
-        return -1;
-    }
-    return 0;
-}
-
-int
-MMA8X5X::setStandby(void)
-{
-    uint8_t reg;
-
-    reg = m_i2ControlCtx.readReg(MMA8X5X_CTRL_REG1);
-    reg &= ~MMA8X5X_CTRL_REG1_ACTIVE;
-
-    mraa::Result ret = m_i2ControlCtx.writeReg(MMA8X5X_CTRL_REG1, reg);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_byte_data() failed");
-        return -1;
-    }
-    return 0;
-}
-
-int
-MMA8X5X::isReady(void)
-{
-    uint8_t reg;
-
-    reg = m_i2ControlCtx.readReg(MMA8X5X_STATUS);
-
-    if (reg & MMA8X5X_STATUS_ZYXDR) {
-        return MMA8X5X_DATA_READY;
-    } else {
-        return MMA8X5X_NODATA;
-    }
-}
-
-int
-MMA8X5X::sampleData(void)
-{
-    uint8_t buf[7];
-    int re = 0;
-
-    re = m_i2ControlCtx.readBytesReg(MMA8X5X_STATUS, buf, 7);
-    if (re != 7) {
-        /* did not read enough bytes */
-        return -1;
-    }
-
-    s_data->x = ((int16_t)(buf[1] << 8 | buf[2])) / (16 >> s_params->range);
-    s_data->y = ((int16_t)(buf[3] << 8 | buf[4])) / (16 >> s_params->range);
-    s_data->z = ((int16_t)(buf[5] << 8 | buf[6])) / (16 >> s_params->range);
-
-    return 0;
-}
-
-int16_t
-MMA8X5X::getX(int bSampleData)
-{
-    if (bSampleData) {
-        if (sampleData() != 0) {
-            /* error in read values from reg */
-            return -999;
-        }
-    }
-
-    return s_data->x;
-}
-
-int16_t
-MMA8X5X::getY(int bSampleData)
-{
-    if (bSampleData) {
-        if (sampleData() != 0) {
-            /* error in read values from reg */
-            return -999;
-        }
-    }
-
-    return s_data->y;
-}
-
-int16_t
-MMA8X5X::getZ(int bSampleData)
-{
-    if (bSampleData) {
-        if (sampleData() != 0) {
-            /* error in read values from reg */
-            return -999;
-        }
-    }
-
-    return s_data->z;
-}
-
-int
-MMA8X5X::getData(mma8x5x_data_t* data, int bSampleData)
-{
-    if (bSampleData) {
-        if (sampleData() != 0) {
-            /* error in read values from reg */
-            return -1;
-        }
-    }
-
-    data->x = s_data->x;
-    data->y = s_data->y;
-    data->z = s_data->z;
-
-    return 0;
-}
\ No newline at end of file
diff --git a/src/mma8x5x/mma8x5x.hpp b/src/mma8x5x/mma8x5x.hpp
deleted file mode 100644
index aa5f9e0..0000000
--- a/src/mma8x5x/mma8x5x.hpp
+++ /dev/null
@@ -1,473 +0,0 @@
-/*
- * Author: Norbert Wesp <nwesp@phytec.de>
- * Copyright (c) 2017 Phytec Messtechnik GmbH.
- *
- * based on: RIOT-driver mma8x5x by Johann Fischer <j.fischer@phytec.de>
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <string>
-#include <mraa/i2c.hpp>
-#include <stdint.h>
-#include <stdbool.h>
-
-/* Supported devices by this driver */
-#define MMA8X5X_DEVICE_ID_MMA8652 0x4a
-#define MMA8X5X_DEVICE_ID_MMA8653 0x5a
-#define MMA8X5X_DEVICE_ID_MMA8451 0x1a
-#define MMA8X5X_DEVICE_ID_MMA8452 0x2a
-#define MMA8X5X_DEVICE_ID_MMA8453 0x3a
-
-#define MMA8X5X_NAME_MMA8652 "MMA8652"
-#define MMA8X5X_NAME_MMA8653 "MMA8653"
-#define MMA8X5X_NAME_MMA8451 "MMA8451"
-#define MMA8X5X_NAME_MMA8452 "MMA8452"
-#define MMA8X5X_NAME_MMA8453 "MMA8453"
-
-/* MMA8x5x Fix settings of supported sensors */
-#define MMA8X5X_I2C_ADDRESS   0x1D
-#define MMA8X5X_DEVICE_ID_REG 0x0D
-
-/* MMA8x5x Register Map */
-#define MMA8X5X_STATUS           0x00 /* Data or FIFO Status */
-#define MMA8X5X_OUT_X_MSB        0x01 /* [7:0] are 8 MSBs of X data */
-#define MMA8X5X_OUT_X_LSB        0x02 /* [7:4] are 4 LSBs of X data */
-#define MMA8X5X_OUT_Y_MSB        0x03 /* [7:0] are 8 MSBs of Y data */
-#define MMA8X5X_OUT_Y_LSB        0x04 /* [7:4] are 4 LSBs of Y data */
-#define MMA8X5X_OUT_Z_MSB        0x05 /* [7:0] are 8 MSBs of Z data */
-#define MMA8X5X_OUT_Z_LSB        0x06 /* [7:4] are 8 LSBs of Z data */
-#define MMA8X5X_F_SETUP          0x09 /* FIFO setup */
-#define MMA8X5X_TRIG_CFG         0x0A /* Map of FIFO data capture events */
-#define MMA8X5X_SYSMOD           0x0B /* Current System mode */
-#define MMA8X5X_INT_SOURCE       0x0C /* Interrupt status */
-#define MMA8X5X_XYZ_DATA_CFG     0x0E /* Dynamic Range Settings */
-#define MMA8X5X_HP_FILTER_CUTOFF 0x0F /* High-Pass Filter Selection */
-#define MMA8X5X_PL_STATUS        0x10 /* Landscape/Portrait
-                                          orientation status */
-#define MMA8X5X_PL_CFG           0x11 /* Landscape/Portrait configuration */
-#define MMA8X5X_PL_COUNT         0x12 /* Landscape/Portrait debounce counter */
-#define MMA8X5X_PL_BF_ZCOMP      0x13 /* Back/Front, Z-Lock Trip threshold */
-#define MMA8X5X_P_L_THS_REG      0x14 /* Portrait/Landscape
-                                          Threshold and Hysteresis */
-#define MMA8X5X_FF_MT_CFG        0x15 /* Freefall/Motion
-                                          functional block configuration */
-#define MMA8X5X_FF_MT_SRC        0x16 /* Freefall/Motion
-                                          event source register */
-#define MMA8X5X_FF_MT_THS        0x17 /* Freefall/Motion threshold register */
-#define MMA8X5X_FF_MT_COUNT      0x18 /* Freefall/Motion debounce counter */
-#define MMA8X5X_TRANSIENT_CFG    0x1D /* Transient
-                                          functional block configuration */
-#define MMA8X5X_TRANSIENT_SRC    0x1E /* Transient event status register */
-#define MMA8X5X_TRANSIENT_THS    0x1F /* Transient event threshold */
-#define MMA8X5X_TRANSIENT_COUNT  0x20 /* Transient debounce counter */
-#define MMA8X5X_PULSE_CFG        0x21 /* Pulse enable configuration */
-#define MMA8X5X_PULSE_SRC        0x22 /* Pulse detection source */
-#define MMA8X5X_PULSE_THSX       0x23 /* X pulse threshold */
-#define MMA8X5X_PULSE_THSY       0x24 /* Y pulse threshold */
-#define MMA8X5X_PULSE_THSZ       0x25 /* Z pulse threshold */
-#define MMA8X5X_PULSE_TMLT       0x26 /* Time limit for pulse */
-#define MMA8X5X_PULSE_LTCY       0x27 /* Latency time for 2nd pulse */
-#define MMA8X5X_PULSE_WIND       0x28 /* Window time for 2nd pulse */
-#define MMA8X5X_ASLP_COUNT       0x29 /* Counter setting for Auto-SLEEP */
-#define MMA8X5X_CTRL_REG1        0x2A /* Data rates and modes setting */
-#define MMA8X5X_CTRL_REG2        0x2B /* Sleep Enable, OS modes, RST, ST */
-#define MMA8X5X_CTRL_REG3        0x2C /* Wake from Sleep, IPOL, PP_OD */
-#define MMA8X5X_CTRL_REG4        0x2D /* Interrupt enable register */
-#define MMA8X5X_CTRL_REG5        0x2E /* Interrupt pin (INT1/INT2) map */
-#define MMA8X5X_OFF_X            0x2F /* X-axis offset adjust */
-#define MMA8X5X_OFF_Y            0x30 /* Y-axis offset adjust */
-#define MMA8X5X_OFF_Z            0x31 /* Z-axis offset adjust */
-
-/* MMA8x5x Available sampling rates */
-#define MMA8X5X_RATE_800HZ (0 << 3)  /* 800  Hz Ouput Data Rate in WAKE mode */
-#define MMA8X5X_RATE_400HZ (1 << 3)  /* 400  Hz Ouput Data Rate in WAKE mode */
-#define MMA8X5X_RATE_200HZ (2 << 3)  /* 200  Hz Ouput Data Rate in WAKE mode */
-#define MMA8X5X_RATE_100HZ (3 << 3)  /* 100  Hz Ouput Data Rate in WAKE mode */
-#define MMA8X5X_RATE_50HZ  (4 << 3)  /* 50   Hz Ouput Data Rate in WAKE mode */
-#define MMA8X5X_RATE_1HZ25 (5 << 3)  /* 12.5 Hz Ouput Data Rate in WAKE mode */
-#define MMA8X5X_RATE_6HZ25 (6 << 3)  /* 6.25 Hz Ouput Data Rate in WAKE mode */
-#define MMA8X5X_RATE_1HZ56 (7 << 3)  /* 1.56 Hz Ouput Data Rate in WAKE mode */
-
-#define MMA8X5X_RATE_DEFAULT  MMA8X5X_RATE_200HZ
-
-/* MMA8x5x Available range options */
-#define MMA8X5X_RANGE_2G    0
-#define MMA8X5X_RANGE_4G    1
-#define MMA8X5X_RANGE_8G    2
-
-#define MMA8X5X_RANGE_DEFAULT MMA8X5X_RANGE_2G
-
-/* Named return values */
-#define MMA8X5X_OK          0  /* everything was fine */
-#define MMA8X5X_DATA_READY  1  /* new data ready to be read */
-#define MMA8X5X_NOI2C      -1  /* I2C communication failed */
-#define MMA8X5X_NODEV      -2  /* no MMA8X5X device found on the bus */
-#define MMA8X5X_NODATA     -3  /* no data available */
-
-/* MMA8x5x Register Bitfields */
-#define MMA8X5X_STATUS_XDR                  (1 << 0)
-#define MMA8X5X_STATUS_YDR                  (1 << 1)
-#define MMA8X5X_STATUS_ZDR                  (1 << 2)
-#define MMA8X5X_STATUS_ZYXDR                (1 << 3)
-#define MMA8X5X_STATUS_XOW                  (1 << 4)
-#define MMA8X5X_STATUS_YOW                  (1 << 5)
-#define MMA8X5X_STATUS_ZOW                  (1 << 6)
-#define MMA8X5X_STATUS_ZYXOW                (1 << 7)
-
-#define MMA8X5X_F_STATUS_F_CNT_MASK         0x3F
-#define MMA8X5X_F_STATUS_F_WMRK_FLAG        (1 << 6)
-#define MMA8X5X_F_STATUS_F_OVF              (1 << 7)
-
-#define MMA8X5X_F_SETUP_MODE_MASK           0xC0
-#define MMA8X5X_F_SETUP_MODE_DISABLED       0
-#define MMA8X5X_F_SETUP_MODE_CIRCULAR       1
-#define MMA8X5X_F_SETUP_MODE_STOP           2
-#define MMA8X5X_F_SETUP_MODE_TRIGGER        3
-#define MMA8X5X_F_SETUP_F_WMRK_MASK         0x3F
-
-#define MMA8X5X_TRIG_CFG_FF_MT              (1 << 2)
-#define MMA8X5X_TRIG_CFG_PULSE              (1 << 3)
-#define MMA8X5X_TRIG_CFG_LNDPRT             (1 << 4)
-#define MMA8X5X_TRIG_CFG_TRANS              (1 << 5)
-
-#define MMA8X5X_SYSMOD_MASK                 0x3
-#define MMA8X5X_SYSMOD_STANDBY              0
-#define MMA8X5X_SYSMOD_WAKE                 1
-#define MMA8X5X_SYSMOD_SLEEP                2
-#define MMA8X5X_SYSMOD_FGT_MASK             0x7C
-#define MMA8X5X_SYSMOD_FGERR                (1 << 7)
-
-#define MMA8X5X_INT_SOURCE_DRDY             (1 << 0)
-#define MMA8X5X_INT_SOURCE_FF_MT            (1 << 2)
-#define MMA8X5X_INT_SOURCE_PULSE            (1 << 3)
-#define MMA8X5X_INT_SOURCE_LNDPRT           (1 << 4)
-#define MMA8X5X_INT_SOURCE_TRANS            (1 << 5)
-#define MMA8X5X_INT_SOURCE_FIFO             (1 << 6)
-#define MMA8X5X_INT_SOURCE_ASLP             (1 << 7)
-
-#define MMA8X5X_XYZ_DATA_CFG_FS_MASK        0x3
-#define MMA8X5X_XYZ_DATA_CFG_HPF_OUT        (1 << 4)
-
-#define MMA8X5X_HP_FILTER_SEL_MASK          0x03
-#define MMA8X5X_HP_FILTER_LPF_EN            (1 << 4)
-#define MMA8X5X_HP_FILTER_HPF_BYP           (1 << 5)
-
-#define MMA8X5X_PL_STATUS_BAFRO             (1 << 0)
-#define MMA8X5X_PL_STATUS_LAPO_MASK         0x6
-#define MMA8X5X_PL_STATUS_LAPO_P_UP         0
-#define MMA8X5X_PL_STATUS_LAPO_P_DOWN       1
-#define MMA8X5X_PL_STATUS_LAPO_L_RIGHT      2
-#define MMA8X5X_PL_STATUS_LAPO_L_LEFT       3
-#define MMA8X5X_PL_STATUS_LO                (1 << 6)
-#define MMA8X5X_PL_STATUS_NEWLP             (1 << 7)
-
-#define MMA8X5X_PL_CFG_PL_EN                (1 << 6)
-#define MMA8X5X_PL_CFG_DBCNTM               (1 << 7)
-
-#define MMA8X5X_PL_BF_ZCOMP_ZLOCK_MASK      0x07
-#define MMA8X5X_PL_BF_ZCOMP_BKFR_MASK       0xC0
-
-#define MMA8X5X_P_L_HYS_MASK                0x07
-#define MMA8X5X_P_L_THS_MASK                0xF8
-
-#define MMA8X5X_FF_MT_CFG_XEFE              (1 << 3)
-#define MMA8X5X_FF_MT_CFG_YEFE              (1 << 4)
-#define MMA8X5X_FF_MT_CFG_ZEFE              (1 << 5)
-#define MMA8X5X_FF_MT_CFG_OAE               (1 << 6)
-#define MMA8X5X_FF_MT_CFG_ELE               (1 << 7)
-
-#define MMA8X5X_FF_MT_SRC_XHP               (1 << 0)
-#define MMA8X5X_FF_MT_SRC_XHE               (1 << 1)
-#define MMA8X5X_FF_MT_SRC_YHP               (1 << 2)
-#define MMA8X5X_FF_MT_SRC_YHE               (1 << 3)
-#define MMA8X5X_FF_MT_SRC_ZHP               (1 << 4)
-#define MMA8X5X_FF_MT_SRC_ZHE               (1 << 5)
-#define MMA8X5X_FF_MT_SRC_EA                (1 << 7)
-
-#define MMA8X5X_FF_MT_THS_MASK              0x7F
-#define MMA8X5X_FF_MT_THS_DBCNTM            (1 << 7)
-
-#define MMA8X5X_TRANSIENT_CFG_HPF_BYP       (1 << 0)
-#define MMA8X5X_TRANSIENT_CFG_XTEFE         (1 << 1)
-#define MMA8X5X_TRANSIENT_CFG_YTEFE         (1 << 2)
-#define MMA8X5X_TRANSIENT_CFG_ZTEFE         (1 << 3)
-#define MMA8X5X_TRANSIENT_CFG_ELE           (1 << 4)
-
-#define MMA8X5X_TRANSIENT_SRC_XTPOL         (1 << 0)
-#define MMA8X5X_TRANSIENT_SRC_XTEVENT       (1 << 1)
-#define MMA8X5X_TRANSIENT_SRC_YTPOL         (1 << 2)
-#define MMA8X5X_TRANSIENT_SRC_YTEVENT       (1 << 3)
-#define MMA8X5X_TRANSIENT_SRC_ZTPOL         (1 << 4)
-#define MMA8X5X_TRANSIENT_SRC_ZTEVENT       (1 << 5)
-#define MMA8X5X_TRANSIENT_SRC_EA            (1 << 6)
-
-#define MMA8X5X_TRANSIENT_THS_MASK          0x7F
-#define MMA8X5X_TRANSIENT_THS_DBCNTM        (1<< 7)
-
-#define MMA8X5X_PULSE_CFG_XSPEFE            (1 << 0)
-#define MMA8X5X_PULSE_CFG_XDPEFE            (1 << 1)
-#define MMA8X5X_PULSE_CFG_YSPEFE            (1 << 2)
-#define MMA8X5X_PULSE_CFG_YDPEFE            (1 << 3)
-#define MMA8X5X_PULSE_CFG_ZSPEFE            (1 << 4)
-#define MMA8X5X_PULSE_CFG_ZDPEFE            (1 << 5)
-#define MMA8X5X_PULSE_CFG_ELE               (1 << 6)
-#define MMA8X5X_PULSE_CFG_DPA               (1 << 7)
-
-#define MMA8X5X_PULSE_SRC_POLX              (1 << 0)
-#define MMA8X5X_PULSE_SRC_POLY              (1 << 1)
-#define MMA8X5X_PULSE_SRC_POLZ              (1 << 2)
-#define MMA8X5X_PULSE_SRC_DPE               (1 << 3)
-#define MMA8X5X_PULSE_SRC_AXX               (1 << 4)
-#define MMA8X5X_PULSE_SRC_AXY               (1 << 5)
-#define MMA8X5X_PULSE_SRC_AXZ               (1 << 6)
-#define MMA8X5X_PULSE_SRC_EA                (1 << 7)
-
-#define MMA8X5X_PULSE_THSX_MASK             0x7F
-#define MMA8X5X_PULSE_THSY_MASK             0x7F
-#define MMA8X5X_PULSE_THSZ_MASK             0x7F
-
-#define MMA8X5X_CTRL_REG1_ACTIVE            (1 << 0)
-#define MMA8X5X_CTRL_REG1_F_READ            (1 << 1)
-#define MMA8X5X_CTRL_REG1_DR_MASK           0x38
-#define MMA8X5X_CTRL_REG1_DR_SHIFT          3
-#define MMA8X5X_CTRL_REG1_DR(x)             (((uint8_t)(((uint8_t)(x))<<\
-                                            MMA8X5X_CTRL_REG1_DR_SHIFT))\
-                                            &MMA8X5X_CTRL_REG1_DR_MASK)
-#define MMA8X5X_CTRL_REG1_ASR_MASK          0xC0
-#define MMA8X5X_CTRL_REG1_ASR_50HZ          0
-#define MMA8X5X_CTRL_REG1_ASR_12HZ5         1
-#define MMA8X5X_CTRL_REG1_ASR_6HZ25         2
-#define MMA8X5X_CTRL_REG1_ASR_1HZ56         3
-
-#define MMA8X5X_CTRL_REG2_MODS_MASK         0x3
-#define MMA8X5X_CTRL_REG2_MODS_NORMAL           0
-#define MMA8X5X_CTRL_REG2_MODS_LNLP         1
-#define MMA8X5X_CTRL_REG2_MODS_HR           2
-#define MMA8X5X_CTRL_REG2_MODS_LP           3
-#define MMA8X5X_CTRL_REG2_SLPE              (1 << 2)
-#define MMA8X5X_CTRL_REG2_SMODS_MASK        0x18
-#define MMA8X5X_CTRL_REG2_SMODS_NORMAL      0
-#define MMA8X5X_CTRL_REG2_SMODS_LNLP        1
-#define MMA8X5X_CTRL_REG2_SMODS_HR          2
-#define MMA8X5X_CTRL_REG2_SMODS_LP          3
-#define MMA8X5X_CTRL_REG2_RST               (1 << 6)
-#define MMA8X5X_CTRL_REG2_ST                (1 << 7)
-
-#define MMA8X5X_CTRL_REG3_PP_OD             (1 << 0)
-#define MMA8X5X_CTRL_REG3_IPOL              (1 << 1)
-#define MMA8X5X_CTRL_REG3_WAKE_FF_MT        (1 << 3)
-#define MMA8X5X_CTRL_REG3_WAKE_PULSE        (1 << 4)
-#define MMA8X5X_CTRL_REG3_WAKE_LNDPRT       (1 << 5)
-#define MMA8X5X_CTRL_REG3_WAKE_TRANS        (1 << 6)
-#define MMA8X5X_CTRL_REG3_FIFO_GATE         (1 << 7)
-
-#define MMA8X5X_CTRL_REG4_INT_EN_DRDY       (1 << 0)
-#define MMA8X5X_CTRL_REG4_INT_EN_FF_MT      (1 << 2)
-#define MMA8X5X_CTRL_REG4_INT_EN_PULSE      (1 << 3)
-#define MMA8X5X_CTRL_REG4_INT_EN_LNDPRT     (1 << 4)
-#define MMA8X5X_CTRL_REG4_INT_EN_TRANS      (1 << 5)
-#define MMA8X5X_CTRL_REG4_INT_EN_FIFO       (1 << 6)
-#define MMA8X5X_CTRL_REG4_INT_EN_ASLP       (1 << 7)
-
-#define MMA8X5X_CTRL_REG5_INT_CFG_DRDY      (1 << 0)
-#define MMA8X5X_CTRL_REG5_INT_CFG_FF_MT     (1 << 2)
-#define MMA8X5X_CTRL_REG5_INT_CFG_PULSE     (1 << 3)
-#define MMA8X5X_CTRL_REG5_INT_CFG_LNDPRT    (1 << 4)
-#define MMA8X5X_CTRL_REG5_INT_CFG_TRANS     (1 << 5)
-#define MMA8X5X_CTRL_REG5_INT_CFG_FIFO      (1 << 6)
-#define MMA8X5X_CTRL_REG5_INT_CFG_ASLP      (1 << 7)
-
-namespace upm {
-
-typedef struct {
-    uint8_t type;
-    uint8_t rate;
-    uint8_t range;
-    uint8_t offsetX;
-    uint8_t offsetY;
-    uint8_t offsetZ;
-} mma8x5x_params_t;
-
-typedef struct {
-    int16_t x;
-    int16_t y;
-    int16_t z;
-} mma8x5x_data_t;
-
-/**
- * @brief MMA8X5X 3-Axis Accelerometer
- * @defgroup mma8x5x libupm-mma8x5x
- * @ingroup freescale i2c accelerometer compass
- */
-
-/**
- * @library mma8x5x
- * @sensor mma8x5x
- * @comname MMA8X5X Three-Axis Accelerometer
- * @altid mma8451 mma8452 mma8453 mma8652 mma8653
- * @type accelerometer compass
- * @man freescale
- * @web http://www.nxp.com/products/sensors/accelerometers:DRSNSAXLRTN
- * @con i2c
- *
- * @brief API for the MMA8X5X Three-Axis Accelerometer
- *
- * Description in web-link above:
- * The NXP MMA8X5X are low-power, three-axis capacitive micromachined
- * accelerometer with 10/12/14 bits of resolution. These accelerometer
- * are packed with embedded functions with flexible user-programmable
- * options configurable to two interrupt pins. The MMA8X5X have user-selectable
- * full scales of +-2g/+-4g/+-8g.
- *
- * @snippet mma8x5x.cxx Interesting
- */
-class MMA8X5X {
-    public:
-        /**
-         *
-         * Instantiates an MMA8X5X object
-         *
-         * @param bus Number of the used bus
-         * @params params Params of device
-         * @param devAddr Address of the used I2C device
-         */
-        MMA8X5X (int bus, mma8x5x_params_t* params=NULL,
-                         int devAddr=MMA8X5X_I2C_ADDRESS);
-
-        /**
-         * Set device name and type matching given type or
-         * read out devive_id to set name and type of device 
-         *
-         * @param type Type of device if set or
-         *             0 if needed to find out by it
-         * @return  0 on success
-         *         -1 on error
-         */
-        int setDeviceName(uint8_t type);
-
-        /**
-         * Set device params to given data or
-         * set default params and read out devive_id to set type of device 
-         *
-         * @param params Params of device if set by user
-         *               NULL if it is not set by user
-         * @return  0 on success
-         *         -1 on error
-         */
-        int setDeviceParams(mma8x5x_params_t* params);
-
-        /**
-         * Set user offset correction
-         * Offset correction register will be erased after accelerometer reset
-         *
-         * @param x Offset correction value for x-axis
-         * @param y Offset correction value for y-axis
-         * @param z Offset correction value for z-axis
-         *
-         * @return  0 on success
-         *         -1 on error
-         */
-        int setUserOffset(int8_t x, int8_t y, int8_t z);
-
-        /**
-         * Set active mode, this enables periodic measurements
-         *
-         * @return  0 on success
-         *         -1 on error
-         */
-        int setActive(void);
-
-        /**
-         * Set standby mode, this disables periodic measurements
-         *
-         * @return  0 on success
-         *         -1 on error
-         */
-        int setStandby(void);
-
-        /**
-         * Check for new set of measurement data.
-         *
-         * @return MMA8X5X_DATA_READY if new sample is ready
-         *         MMA8X5X_NODATA if nothing is available
-         */
-        int isReady(void);
-
-        /**
-         * Read & calculate accelerometer data in mg & saves them to variables
-         *
-         * @return  0 on success
-         *         -1 on error
-         */
-        int sampleData(void);
-
-        /**
-         * Get x-axis acceleration
-         *
-         * @param bSampleData Flag to read sensor
-         * @return The x-axis acceleration on success
-         *         -999 on error
-         */
-        int16_t getX(int bSampleData = 0);
-
-        /**
-         * Get y-axis acceleration
-         *
-         * @param bSampleData Flag to read sensor
-         * @return The y-axis acceleration on success
-         *         -999 on error
-         */
-        int16_t getY(int bSampleData = 0);
-
-        /**
-         * Get z-axis acceleration
-         *
-         * @param bSampleData Flag to read sensor
-         * @return The z-axis acceleration on success
-         *         -999 on error
-         */
-        int16_t getZ(int bSampleData = 0);
-
-        /**
-         * Get sensor values
-         *
-         * @param data Sensor values
-         * @param bSampleData Flag to read sensor
-         * @return  0 on success
-         *         -1 on error
-         */
-        int getData(mma8x5x_data_t* data, int bSampleData = 0);
-
-    private:
-
-        std::string m_name;
-
-        int m_controlAddr;
-        int m_bus;
-        mraa::I2c m_i2ControlCtx;
-
-        mma8x5x_params_t s_params[1];
-        mma8x5x_data_t s_data[1];
-};
-
-}
diff --git a/src/mma8x5x/mma8x5x.json b/src/mma8x5x/mma8x5x.json
deleted file mode 100644
index 19cd644..0000000
--- a/src/mma8x5x/mma8x5x.json
+++ /dev/null
@@ -1,281 +0,0 @@
-{
-    "Library": "mma8x5x",
-    "Description": "MMA8X5X Family Three-Axis Accelerometer Library",
-    "Sensor Class": {
-        "mma8451": {
-            "Name": "API for the Adafruit/Freescale MMA8451 Three-Axis Accelerometer",
-            "Description": "This is the UPM Module for the Adafruit/Freescale mma8451 three-axis accelerometer. This simple accelerometer and breakout board are a great starting point for working with accelerometers in general. This is the most percise of the mma8x5x series, offering a 14-bit analog to digital converter onboard. The Adafruit breakout board makes it easy to mount to breadboard or perfboard.",
-            "Aliases": ["mma8451", "mma8x5x", "Adafruit Triple-Axis Accelerometer - 2/4/8g"],
-            "Categories": ["accelerometer"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["Freescale", "Adafruit"],
-            "Examples": {
-                "Python": ["mma8x5x.py"],
-                "C++": ["mma8x5x.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.3,
-                    "max": 5.0
-                },
-                "Supply Current":{
-                    "unit": "uA",
-                    "min": 6,
-                    "max": 165
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Measurement Range": {
-                    "unit": "g",
-                    "min" : 2,
-                    "max" : 8
-                },
-                "Sensitivity": {
-                    "unit" : "LSB/g",
-                    "min" : 1024,
-                    "max" : 4096
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need pull up resistors"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.adafruit.com/product/2019"],
-                "Datasheets": ["https://cdn-shop.adafruit.com/datasheets/MMA8451Q-1.pdf"]
-            }
-        },
-        "mma8452q": {
-            "Name": "API for the Sparkfun/Freescale MMA8451Q Three-Axis Accelerometer",
-            "Description": "This is the UPM Module for the Sparkfun/Freescale mma8452 three-axis accelerometer. This breakout board makes it easy to use the tiny MMA8452Q accelerometer in your project. The MMA8452Q is a smart low-power, three-axis, capacitive MEMS accelerometer with 12 bits of resolution. The MMA8452Q has user-selectable full scales of 2g/4g/8g.",
-            "Aliases": ["mma8452q", "mma8x5x", "SparkFun Triple Axis Accelerometer Breakout - MMA8452Q"],
-            "Categories": ["accelerometer"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["Freescale", "Sparkfun"],
-            "Examples": {
-                "Python": ["mma8x5x.py"],
-                "C++": ["mma8x5x.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 1.95,
-                    "max": 3.6
-                },
-                "Supply Current":{
-                    "unit": "uA",
-                    "min": 6,
-                    "max": 165
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Measurement Range": {
-                    "unit": "g",
-                    "min" : 2,
-                    "max" : 8
-                },
-                "Sensitivity": {
-                    "unit" : "LSB/g",
-                    "min" : 256,
-                    "max" : 1024
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need pull up resistors"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.sparkfun.com/products/12756"],
-                "Datasheets": ["https://cdn.sparkfun.com/datasheets/Sensors/Accelerometers/MMA8452Q-rev8.1.pdf"]
-            }
-        },
-        "mma8453q": {
-            "Name": "API for the NXP MMA8453Q Three-Axis Accelerometer",
-            "Description": "This is the UPM Module for the NXP mma8453q three-axis accelerometer. This accelerometer is packed with embedded functions with flexible user-programmable options configurable to two interrupt pins. Embedded interrupt functions allow for overall power savings relieving the host processor from continuously polling data. The MMA8453Q has user-selectable full scales of 2g/4g/8g.",
-            "Aliases": ["mma8453q", "mma8x5x", "MMA8453Q: 2g/4g/8g, Low g, 10-bit Digital Accelerometer"],
-            "Categories": ["accelerometer"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["NXP"],
-            "Examples": {
-                "Python": ["mma8x5x.py"],
-                "C++": ["mma8x5x.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 1.95,
-                    "max": 3.6
-                },
-                "Supply Current":{
-                    "unit": "uA",
-                    "min": 6,
-                    "max": 165
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Measurement Range": {
-                    "unit": "g",
-                    "min" : 2,
-                    "max" : 8
-                },
-                "Sensitivity": {
-                    "unit" : "LSB/g",
-                    "min" : 64,
-                    "max" : 256
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need pull up resistors"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["http://www.nxp.com/products/sensors/accelerometers/3-axis-accelerometers/2g-4g-8g-low-g-10-bit-digital-accelerometer:MMA8453Q"],
-                "Datasheets": ["http://www.nxp.com/docs/en/data-sheet/MMA8453Q.pdf"]
-            }
-        },
-        "mma8652fc": {
-            "Name": "API for the NXP MMA8652FC Three-Axis Accelerometer",
-            "Description": "This is the UPM Module for the NXP mma8652fc three-axis accelerometer. This accelerometer is packed with embedded functions with flexible user-programmable options configurable to two interrupt pins. Embedded interrupt functions allow for overall power savings relieving the host processor from continuously polling data. The MMA8453Q has user-selectable full scales of 2g/4g/8g.",
-            "Aliases": ["mma8652fc", "mma8x5x", "MMA8652FC: 2g/4g/8g, Low g, 12-Bit Digital Accelerometer"],
-            "Categories": ["accelerometer"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["NXP"],
-            "Examples": {
-                "Python": ["mma8x5x.py"],
-                "C++": ["mma8x5x.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 1.95,
-                    "max": 3.6
-                },
-                "Supply Current":{
-                    "unit": "uA",
-                    "min": 6,
-                    "max": 165
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Measurement Range": {
-                    "unit": "g",
-                    "min" : 2,
-                    "max" : 8
-                },
-                "Sensitivity": {
-                    "unit" : "LSB/g",
-                    "min" : 256,
-                    "max" : 1024
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need pull up resistors"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["http://www.nxp.com/products/sensors/accelerometers/3-axis-accelerometers/2g-4g-8g-low-g-12-bit-digital-accelerometer:MMA8652FC"],
-                "Datasheets": ["http://www.nxp.com/docs/en/data-sheet/MMA8652FC.pdf"]
-            }
-        },
-        "mma8653fc": {
-            "Name": "API for the NXP MMA8653FC Three-Axis Accelerometer",
-            "Description": "This is the UPM Module for the NXP mma8653fc three-axis accelerometer. This accelerometer is packed with embedded functions with flexible user-programmable options configurable to two interrupt pins. Embedded interrupt functions allow for overall power savings relieving the host processor from continuously polling data. The MMA8453Q has user-selectable full scales of 2g/4g/8g.",
-            "Aliases": ["mma8653fc", "mma8x5x", "MMA8653FC: 2g/4g/8g, Low g, 12-Bit Digital Accelerometer"],
-            "Categories": ["accelerometer"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["NXP"],
-            "Examples": {
-                "Python": ["mma8x5x.py"],
-                "C++": ["mma8x5x.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 1.95,
-                    "max": 3.6
-                },
-                "Supply Current":{
-                    "unit": "uA",
-                    "min": 6,
-                    "max": 165
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Measurement Range": {
-                    "unit": "g",
-                    "min" : 2,
-                    "max" : 8
-                },
-                "Sensitivity": {
-                    "unit" : "LSB/g",
-                    "min" : 64,
-                    "max" : 256
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need pull up resistors"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["http://www.nxp.com/products/sensors/accelerometers/3-axis-accelerometers/2g-4g-8g-low-g-10-bit-digital-accelerometer:MMA8653FC"],
-                "Datasheets": ["http://www.nxp.com/docs/en/data-sheet/MMA8653FC.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/mmc35240/CMakeLists.txt b/src/mmc35240/CMakeLists.txt
deleted file mode 100644
index 838ca62..0000000
--- a/src/mmc35240/CMakeLists.txt
+++ /dev/null
@@ -1,7 +0,0 @@
-if (MRAA_IIO_FOUND)
-    set (libname "mmc35240")
-    set (libdescription "mmc35240 sensor module")
-    set (module_src ${libname}.cxx)
-    set (module_hpp ${libname}.hpp)
-    upm_module_init(mraa)
-endif (MRAA_IIO_FOUND)
diff --git a/src/mmc35240/mat.h b/src/mmc35240/mat.h
deleted file mode 100644
index cc5fc6d..0000000
--- a/src/mmc35240/mat.h
+++ /dev/null
@@ -1,406 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_MAT_H
-#define ANDROID_MAT_H
-
-#include "vec.h"
-#include "traits.h"
-
-// -----------------------------------------------------------------------
-
-namespace android {
-
-template <typename TYPE, size_t C, size_t R>
-class mat;
-
-namespace helpers {
-
-template <typename TYPE, size_t C, size_t R>
-mat<TYPE, C, R>& doAssign(
-        mat<TYPE, C, R>& lhs,
-        typename TypeTraits<TYPE>::ParameterType rhs) {
-    for (size_t i=0 ; i<C ; i++)
-        for (size_t j=0 ; j<R ; j++)
-            lhs[i][j] = (i==j) ? rhs : 0;
-    return lhs;
-}
-
-template <typename TYPE, size_t C, size_t R, size_t D>
-mat<TYPE, C, R> PURE doMul(
-        const mat<TYPE, D, R>& lhs,
-        const mat<TYPE, C, D>& rhs)
-{
-    mat<TYPE, C, R> res;
-    for (size_t c=0 ; c<C ; c++) {
-        for (size_t r=0 ; r<R ; r++) {
-            TYPE v(0);
-            for (size_t k=0 ; k<D ; k++) {
-                v += lhs[k][r] * rhs[c][k];
-            }
-            res[c][r] = v;
-        }
-    }
-    return res;
-}
-
-template <typename TYPE, size_t R, size_t D>
-vec<TYPE, R> PURE doMul(
-        const mat<TYPE, D, R>& lhs,
-        const vec<TYPE, D>& rhs)
-{
-    vec<TYPE, R> res;
-    for (size_t r=0 ; r<R ; r++) {
-        TYPE v(0);
-        for (size_t k=0 ; k<D ; k++) {
-            v += lhs[k][r] * rhs[k];
-        }
-        res[r] = v;
-    }
-    return res;
-}
-
-template <typename TYPE, size_t C, size_t R>
-mat<TYPE, C, R> PURE doMul(
-        const vec<TYPE, R>& lhs,
-        const mat<TYPE, C, 1>& rhs)
-{
-    mat<TYPE, C, R> res;
-    for (size_t c=0 ; c<C ; c++) {
-        for (size_t r=0 ; r<R ; r++) {
-            res[c][r] = lhs[r] * rhs[c][0];
-        }
-    }
-    return res;
-}
-
-template <typename TYPE, size_t C, size_t R>
-mat<TYPE, C, R> PURE doMul(
-        const mat<TYPE, C, R>& rhs,
-        typename TypeTraits<TYPE>::ParameterType v)
-{
-    mat<TYPE, C, R> res;
-    for (size_t c=0 ; c<C ; c++) {
-        for (size_t r=0 ; r<R ; r++) {
-            res[c][r] = rhs[c][r] * v;
-        }
-    }
-    return res;
-}
-
-template <typename TYPE, size_t C, size_t R>
-mat<TYPE, C, R> PURE doMul(
-        typename TypeTraits<TYPE>::ParameterType v,
-        const mat<TYPE, C, R>& rhs)
-{
-    mat<TYPE, C, R> res;
-    for (size_t c=0 ; c<C ; c++) {
-        for (size_t r=0 ; r<R ; r++) {
-            res[c][r] = v * rhs[c][r];
-        }
-    }
-    return res;
-}
-
-
-}; // namespace helpers
-
-// -----------------------------------------------------------------------
-
-template <typename TYPE, size_t C, size_t R>
-class mat : public vec< vec<TYPE, R>, C > {
-    typedef typename TypeTraits<TYPE>::ParameterType pTYPE;
-    typedef vec< vec<TYPE, R>, C > base;
-public:
-    // STL-like interface.
-    typedef TYPE value_type;
-    typedef TYPE& reference;
-    typedef TYPE const& const_reference;
-    typedef size_t size_type;
-    size_type size() const { return R*C; }
-    enum { ROWS = R, COLS = C };
-
-
-    // -----------------------------------------------------------------------
-    // default constructors
-
-    mat() { }
-    mat(const mat& rhs)  : base(rhs) { }
-    mat(const base& rhs) : base(rhs) { }
-
-    // -----------------------------------------------------------------------
-    // conversion constructors
-
-    // sets the diagonal to the value, off-diagonal to zero
-    mat(pTYPE rhs) {
-        helpers::doAssign(*this, rhs);
-    }
-
-    // -----------------------------------------------------------------------
-    // Assignment
-
-    mat& operator=(const mat& rhs) {
-        base::operator=(rhs);
-        return *this;
-    }
-
-    mat& operator=(const base& rhs) {
-        base::operator=(rhs);
-        return *this;
-    }
-
-    mat& operator=(pTYPE rhs) {
-        return helpers::doAssign(*this, rhs);
-    }
-
-    // -----------------------------------------------------------------------
-    // non-member function declaration and definition
-
-    friend inline mat PURE operator + (const mat& lhs, const mat& rhs) {
-        return helpers::doAdd(
-                static_cast<const base&>(lhs),
-                static_cast<const base&>(rhs));
-    }
-    friend inline mat PURE operator - (const mat& lhs, const mat& rhs) {
-        return helpers::doSub(
-                static_cast<const base&>(lhs),
-                static_cast<const base&>(rhs));
-    }
-
-    // matrix*matrix
-    template <size_t D>
-    friend mat PURE operator * (
-            const mat<TYPE, D, R>& lhs,
-            const mat<TYPE, C, D>& rhs) {
-        return helpers::doMul(lhs, rhs);
-    }
-
-    // matrix*vector
-    friend vec<TYPE, R> PURE operator * (
-            const mat& lhs, const vec<TYPE, C>& rhs) {
-        return helpers::doMul(lhs, rhs);
-    }
-
-    // vector*matrix
-    friend mat PURE operator * (
-            const vec<TYPE, R>& lhs, const mat<TYPE, C, 1>& rhs) {
-        return helpers::doMul(lhs, rhs);
-    }
-
-    // matrix*scalar
-    friend inline mat PURE operator * (const mat& lhs, pTYPE v) {
-        return helpers::doMul(lhs, v);
-    }
-
-    // scalar*matrix
-    friend inline mat PURE operator * (pTYPE v, const mat& rhs) {
-        return helpers::doMul(v, rhs);
-    }
-
-    // -----------------------------------------------------------------------
-    // streaming operator to set the columns of the matrix:
-    // example:
-    //    mat33_t m;
-    //    m << v0 << v1 << v2;
-
-    // column_builder<> stores the matrix and knows which column to set
-    template<size_t PREV_COLUMN>
-    struct column_builder {
-        mat& matrix;
-        column_builder(mat& matrix) : matrix(matrix) { }
-    };
-
-    // operator << is not a method of column_builder<> so we can
-    // overload it for unauthorized values (partial specialization
-    // not allowed in class-scope).
-    // we just set the column and return the next column_builder<>
-    template<size_t PREV_COLUMN>
-    friend column_builder<PREV_COLUMN+1> operator << (
-            const column_builder<PREV_COLUMN>& lhs,
-            const vec<TYPE, R>& rhs) {
-        lhs.matrix[PREV_COLUMN+1] = rhs;
-        return column_builder<PREV_COLUMN+1>(lhs.matrix);
-    }
-
-    // we return void here so we get a compile-time error if the
-    // user tries to set too many columns
-    friend void operator << (
-            const column_builder<C-2>& lhs,
-            const vec<TYPE, R>& rhs) {
-        lhs.matrix[C-1] = rhs;
-    }
-
-    // this is where the process starts. we set the first columns and
-    // return the next column_builder<>
-    column_builder<0> operator << (const vec<TYPE, R>& rhs) {
-        (*this)[0] = rhs;
-        return column_builder<0>(*this);
-    }
-};
-
-// Specialize column matrix so they're exactly equivalent to a vector
-template <typename TYPE, size_t R>
-class mat<TYPE, 1, R> : public vec<TYPE, R> {
-    typedef vec<TYPE, R> base;
-public:
-    // STL-like interface.
-    typedef TYPE value_type;
-    typedef TYPE& reference;
-    typedef TYPE const& const_reference;
-    typedef size_t size_type;
-    size_type size() const { return R; }
-    enum { ROWS = R, COLS = 1 };
-
-    mat() { }
-    mat(const base& rhs) : base(rhs) { }
-    mat(const mat& rhs) : base(rhs) { }
-    mat(const TYPE& rhs) { helpers::doAssign(*this, rhs); }
-    mat& operator=(const mat& rhs) { base::operator=(rhs); return *this; }
-    mat& operator=(const base& rhs) { base::operator=(rhs); return *this; }
-    mat& operator=(const TYPE& rhs) { return helpers::doAssign(*this, rhs); }
-    // we only have one column, so ignore the index
-    const base& operator[](size_t) const { return *this; }
-    base& operator[](size_t) { return *this; }
-    void operator << (const vec<TYPE, R>& rhs) { base::operator[](0) = rhs; }
-};
-
-// -----------------------------------------------------------------------
-// matrix functions
-
-// transpose. this handles matrices of matrices
-inline int     PURE transpose(int v)    { return v; }
-inline float   PURE transpose(float v)  { return v; }
-inline double  PURE transpose(double v) { return v; }
-
-// Transpose a matrix
-template <typename TYPE, size_t C, size_t R>
-mat<TYPE, R, C> PURE transpose(const mat<TYPE, C, R>& m) {
-    mat<TYPE, R, C> r;
-    for (size_t i=0 ; i<R ; i++)
-        for (size_t j=0 ; j<C ; j++)
-            r[i][j] = transpose(m[j][i]);
-    return r;
-}
-
-template <typename TYPE, size_t M, size_t N, size_t P>
-mat<TYPE, M, P> PURE multiply(const mat<TYPE, M, N>& m1, const mat<TYPE, N, P>& m2)
-{
-    mat<TYPE, M, P> r;
-    for (size_t i = 0; i < M; i++)
-        for (size_t k = 0; k < P; k++) {
-            r [i][k] = 0;
-            for (size_t j = 0; j < N; j++)
-                r [i][k] += m1[i][j] * m2 [j][k];
-    }
-    return r;
-}
-
-// Calculate the trace of a matrix
-template <typename TYPE, size_t C> static TYPE trace(const mat<TYPE, C, C>& m) {
-    TYPE t;
-    for (size_t i=0 ; i<C ; i++)
-        t += m[i][i];
-    return t;
-}
-
-// Test positive-semidefiniteness of a matrix
-template <typename TYPE, size_t C>
-static bool isPositiveSemidefinite(const mat<TYPE, C, C>& m, TYPE tolerance) {
-    for (size_t i=0 ; i<C ; i++)
-        if (m[i][i] < 0)
-            return false;
-
-    for (size_t i=0 ; i<C ; i++)
-      for (size_t j=i+1 ; j<C ; j++)
-          if (fabs(m[i][j] - m[j][i]) > tolerance)
-              return false;
-
-    return true;
-}
-
-// Transpose a vector
-template <
-    template<typename T, size_t S> class VEC,
-    typename TYPE,
-    size_t SIZE
->
-mat<TYPE, SIZE, 1> PURE transpose(const VEC<TYPE, SIZE>& v) {
-    mat<TYPE, SIZE, 1> r;
-    for (size_t i=0 ; i<SIZE ; i++)
-        r[i][0] = transpose(v[i]);
-    return r;
-}
-
-// -----------------------------------------------------------------------
-// "dumb" matrix inversion
-template<typename T, size_t N>
-mat<T, N, N> PURE invert(const mat<T, N, N>& src) {
-    T t;
-    size_t swap;
-    mat<T, N, N> tmp(src);
-    mat<T, N, N> inverse(1);
-
-    for (size_t i=0 ; i<N ; i++) {
-        // look for largest element in column
-        swap = i;
-        for (size_t j=i+1 ; j<N ; j++) {
-            if (fabs(tmp[j][i]) > fabs(tmp[i][i])) {
-                swap = j;
-            }
-        }
-
-        if (swap != i) {
-            /* swap rows. */
-            for (size_t k=0 ; k<N ; k++) {
-                t = tmp[i][k];
-                tmp[i][k] = tmp[swap][k];
-                tmp[swap][k] = t;
-
-                t = inverse[i][k];
-                inverse[i][k] = inverse[swap][k];
-                inverse[swap][k] = t;
-            }
-        }
-
-        t = 1 / tmp[i][i];
-        for (size_t k=0 ; k<N ; k++) {
-            tmp[i][k] *= t;
-            inverse[i][k] *= t;
-        }
-        for (size_t j=0 ; j<N ; j++) {
-            if (j != i) {
-                t = tmp[j][i];
-                for (size_t k=0 ; k<N ; k++) {
-                    tmp[j][k] -= tmp[i][k] * t;
-                    inverse[j][k] -= inverse[i][k] * t;
-                }
-            }
-        }
-    }
-    return inverse;
-}
-
-// -----------------------------------------------------------------------
-
-typedef mat<float, 2, 2> mat22_t;
-typedef mat<float, 3, 3> mat33_t;
-typedef mat<float, 4, 4> mat44_t;
-
-// -----------------------------------------------------------------------
-
-}; // namespace android
-
-#endif /* ANDROID_MAT_H */
diff --git a/src/mmc35240/mmc35240.cxx b/src/mmc35240/mmc35240.cxx
deleted file mode 100644
index 4e12dee..0000000
--- a/src/mmc35240/mmc35240.cxx
+++ /dev/null
@@ -1,811 +0,0 @@
-/*
- * Author: Lay, Kuan Loon <kuan.loon.lay@intel.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-#include <string.h>
-#include <math.h>
-#include "mmc35240.hpp"
-
-#define NUMBER_OF_BITS_IN_BYTE 8
-
-/* Compass defines */
-#define CONVERT_GAUSS_TO_MICROTESLA(x) ((x) *100)
-#define EPSILON 0.000000001
-#define MAGNETIC_LOW 960 /* 31 micro tesla squared */
-#define CAL_STEPS 5
-
-/* Filter defines */
-#define FILTER_MAX_SAMPLE 20
-#define FILTER_NUM_FILED 3
-
-using namespace upm;
-using namespace android;
-
-/* We'll have multiple calibration levels so that we can provide an estimation as fast as possible
- */
-static const float min_diffs[CAL_STEPS] = { 0.2, 0.25, 0.4, 0.6, 1.0 };
-static const float max_sqr_errs[CAL_STEPS] = { 10.0, 10.0, 8.0, 5.0, 3.5 };
-static const unsigned int lookback_counts[CAL_STEPS] = { 2, 3, 4, 5, 6 };
-
-MMC35240::MMC35240(int device)
-{
-    float mag_scale;
-    char trigger[64];
-
-    if (!(m_iio = mraa_iio_init(device))) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_iio_init() failed, invalid device?");
-        return;
-    }
-    m_scale = 1;
-    m_iio_device_num = device;
-    sprintf(trigger, "hrtimer-mmc35240-hr-dev%d", device);
-
-    if (mraa_iio_create_trigger(m_iio, trigger) != MRAA_SUCCESS)
-        fprintf(stderr, "Create trigger %s failed\n", trigger);
-
-    if (mraa_iio_get_mount_matrix(m_iio, "in_mount_matrix", m_mount_matrix) == MRAA_SUCCESS)
-        m_mount_matrix_exist = true;
-    else
-        m_mount_matrix_exist = false;
-
-    if (mraa_iio_read_float(m_iio, "in_magn_scale", &mag_scale) == MRAA_SUCCESS)
-        m_scale = mag_scale;
-
-    // calibration init data
-    initCalibrate();
-
-    // filter init data
-    memset(&m_filter, 0, sizeof(filter_average_t));
-    m_filter.max_samples = FILTER_MAX_SAMPLE;
-    m_filter.num_fields = FILTER_NUM_FILED;
-}
-
-MMC35240::~MMC35240()
-{
-    if (m_filter.history) {
-        free(m_filter.history);
-        m_filter.history = NULL;
-    }
-    if (m_filter.history_sum) {
-        free(m_filter.history_sum);
-        m_filter.history_sum = NULL;
-    }
-    if (m_iio)
-        mraa_iio_close(m_iio);
-}
-
-void
-MMC35240::installISR(void (*isr)(char*, void*), void* arg)
-{
-    mraa_iio_trigger_buffer(m_iio, isr, arg);
-}
-
-int64_t
-MMC35240::getChannelValue(unsigned char* input, mraa_iio_channel* chan)
-{
-    uint64_t u64 = 0;
-    int i;
-    int storagebits = chan->bytes * NUMBER_OF_BITS_IN_BYTE;
-    int realbits = chan->bits_used;
-    int zeroed_bits = storagebits - realbits;
-    uint64_t sign_mask;
-    uint64_t value_mask;
-
-    if (!chan->lendian)
-        for (i = 0; i < storagebits / NUMBER_OF_BITS_IN_BYTE; i++)
-            u64 = (u64 << 8) | input[i];
-    else
-        for (i = storagebits / NUMBER_OF_BITS_IN_BYTE - 1; i >= 0; i--)
-            u64 = (u64 << 8) | input[i];
-
-    u64 = (u64 >> chan->shift) & (~0ULL >> zeroed_bits);
-
-    if (!chan->signedd)
-        return (int64_t) u64; /* We don't handle unsigned 64 bits int */
-
-    /* Signed integer */
-
-    switch (realbits) {
-        case 0 ... 1:
-            return 0;
-
-        case 8:
-            return (int64_t)(int8_t) u64;
-
-        case 16:
-            return (int64_t)(int16_t) u64;
-
-        case 32:
-            return (int64_t)(int32_t) u64;
-
-        case 64:
-            return (int64_t) u64;
-
-        default:
-            sign_mask = 1 << (realbits - 1);
-            value_mask = sign_mask - 1;
-
-            if (u64 & sign_mask)
-                return -((~u64 & value_mask) + 1); /* Negative value: return 2-complement */
-            else
-                return (int64_t) u64; /* Positive value */
-    }
-}
-
-bool
-MMC35240::enableBuffer(int length)
-{
-    mraa_iio_write_int(m_iio, "buffer/length", length);
-    // enable must be last step, else will have error in writing above config
-    mraa_iio_write_int(m_iio, "buffer/enable", 1);
-    return true;
-}
-
-bool
-MMC35240::disableBuffer()
-{
-    mraa_iio_write_int(m_iio, "buffer/enable", 0);
-    return true;
-}
-
-bool
-MMC35240::setScale(float scale)
-{
-    m_scale = scale;
-    mraa_iio_write_float(m_iio, "in_magn_scale", scale);
-    return true;
-}
-
-bool
-MMC35240::setSamplingFrequency(float sampling_frequency)
-{
-    m_sampling_frequency = sampling_frequency;
-    mraa_iio_write_float(m_iio, "in_magn_sampling_frequency", sampling_frequency);
-    return true;
-}
-
-bool
-MMC35240::enable3AxisChannel()
-{
-    char trigger[64];
-    sprintf(trigger, "mmc35240-hr-dev%d", m_iio_device_num);
-
-    mraa_iio_write_string(m_iio, "trigger/current_trigger", trigger);
-    mraa_iio_write_int(m_iio, "scan_elements/in_magn_x_en", 1);
-    mraa_iio_write_int(m_iio, "scan_elements/in_magn_y_en", 1);
-    mraa_iio_write_int(m_iio, "scan_elements/in_magn_z_en", 1);
-
-    // need update channel data size after enable
-    mraa_iio_update_channels(m_iio);
-    return true;
-}
-
-void
-MMC35240::extract3Axis(char* data, float* x, float* y, float* z)
-{
-    mraa_iio_channel* channels = mraa_iio_get_channels(m_iio);
-    float tmp[3];
-    int64_t iio_x, iio_y, iio_z;
-
-    iio_x = getChannelValue((unsigned char*) (data), &channels[0]);
-    iio_y = getChannelValue((unsigned char*) (data + 4), &channels[1]);
-    iio_z = getChannelValue((unsigned char*) (data + 8), &channels[2]);
-
-    // Raw data is magnetic field along axis x, y, and z. Units after application of scale are Gauss
-    *x = CONVERT_GAUSS_TO_MICROTESLA(iio_x * m_scale);
-    *y = CONVERT_GAUSS_TO_MICROTESLA(iio_y * m_scale);
-    *z = CONVERT_GAUSS_TO_MICROTESLA(iio_z * m_scale);
-
-    if (m_mount_matrix_exist) {
-        tmp[0] = *x * m_mount_matrix[0] + *y * m_mount_matrix[1] + *z * m_mount_matrix[2];
-        tmp[1] = *x * m_mount_matrix[3] + *y * m_mount_matrix[4] + *z * m_mount_matrix[5];
-        tmp[2] = *x * m_mount_matrix[6] + *y * m_mount_matrix[7] + *z * m_mount_matrix[8];
-
-        *x = tmp[0];
-        *y = tmp[1];
-        *z = tmp[2];
-    }
-
-    calibrateCompass(x, y, z, &m_cal_data);
-    denoise_average(x, y, z);
-}
-
-int
-MMC35240::getCalibratedLevel()
-{
-    return m_cal_level;
-}
-
-void
-MMC35240::initCalibrate()
-{
-    m_cal_level = 0;
-    resetSample(&m_cal_data);
-
-    m_cal_data.offset[0][0] = 0;
-    m_cal_data.offset[1][0] = 0;
-    m_cal_data.offset[2][0] = 0;
-    m_cal_data.w_invert[0][0] = 1;
-    m_cal_data.w_invert[1][0] = 0;
-    m_cal_data.w_invert[2][0] = 0;
-    m_cal_data.w_invert[0][1] = 0;
-    m_cal_data.w_invert[1][1] = 1;
-    m_cal_data.w_invert[2][1] = 0;
-    m_cal_data.w_invert[0][2] = 0;
-    m_cal_data.w_invert[1][2] = 0;
-    m_cal_data.w_invert[2][2] = 1;
-    m_cal_data.bfield = 0;
-}
-
-void
-MMC35240::getCalibratedData(int* cal_level, double offset[3][1], double w_invert[3][3], double* bfield)
-{
-    *cal_level = m_cal_level;
-    offset[0][0] = m_cal_data.offset[0][0];
-    offset[1][0] = m_cal_data.offset[1][0];
-    offset[2][0] = m_cal_data.offset[2][0];
-    w_invert[0][0] = m_cal_data.w_invert[0][0];
-    w_invert[1][0] = m_cal_data.w_invert[1][0];
-    w_invert[2][0] = m_cal_data.w_invert[2][0];
-    w_invert[0][1] = m_cal_data.w_invert[0][1];
-    w_invert[1][1] = m_cal_data.w_invert[1][1];
-    w_invert[2][1] = m_cal_data.w_invert[2][1];
-    w_invert[0][2] = m_cal_data.w_invert[0][2];
-    w_invert[1][2] = m_cal_data.w_invert[1][2];
-    w_invert[2][2] = m_cal_data.w_invert[2][2];
-    *bfield = m_cal_data.bfield;
-}
-
-void
-MMC35240::loadCalibratedData(int cal_level, double offset[3][1], double w_invert[3][3], double bfield)
-{
-    m_cal_level = cal_level;
-    m_cal_data.offset[0][0] = offset[0][0];
-    m_cal_data.offset[1][0] = offset[1][0];
-    m_cal_data.offset[2][0] = offset[2][0];
-    m_cal_data.w_invert[0][0] = w_invert[0][0];
-    m_cal_data.w_invert[1][0] = w_invert[1][0];
-    m_cal_data.w_invert[2][0] = w_invert[2][0];
-    m_cal_data.w_invert[0][1] = w_invert[0][1];
-    m_cal_data.w_invert[1][1] = w_invert[1][1];
-    m_cal_data.w_invert[2][1] = w_invert[2][1];
-    m_cal_data.w_invert[0][2] = w_invert[0][2];
-    m_cal_data.w_invert[1][2] = w_invert[1][2];
-    m_cal_data.w_invert[2][2] = w_invert[2][2];
-    m_cal_data.bfield = bfield;
-}
-
-void
-MMC35240::resetSample(compass_cal_t* data)
-{
-    int i, j;
-    data->sample_count = 0;
-    for (i = 0; i < MAGN_DS_SIZE; i++)
-        for (j = 0; j < 3; j++)
-            data->sample[i][j] = 0;
-
-    data->average[0] = data->average[1] = data->average[2] = 0;
-}
-
-void
-MMC35240::calibrateCompass(float* x, float* y, float* z, compass_cal_t* cal_data)
-{
-    int cal_level;
-
-    /* Calibration is continuous */
-    compassCollect(x, y, z, cal_data);
-
-    cal_level = compassReady(cal_data);
-
-    switch (cal_level) {
-        case 0:
-            scale(x, y, z);
-            break;
-
-        default:
-            compassComputeCal(x, y, z, cal_data);
-            break;
-    }
-}
-
-int
-MMC35240::compassCollect(float* x, float* y, float* z, compass_cal_t* cal_data)
-{
-    float data[3] = { *x, *y, *z };
-    unsigned int index, j;
-    unsigned int lookback_count;
-    float min_diff;
-
-    /* Discard the point if not valid */
-    if (data[0] == 0 || data[1] == 0 || data[2] == 0)
-        return -1;
-
-    lookback_count = lookback_counts[m_cal_level];
-    min_diff = min_diffs[m_cal_level];
-
-    /* For the current point to be accepted, each x/y/z value must be different enough to the last
-     * several collected points */
-    if (cal_data->sample_count > 0 && cal_data->sample_count < MAGN_DS_SIZE) {
-        unsigned int lookback =
-        lookback_count < cal_data->sample_count ? lookback_count : cal_data->sample_count;
-        for (index = 0; index < lookback; index++)
-            for (j = 0; j < 3; j++)
-                if (fabsf(data[j] - cal_data->sample[cal_data->sample_count - 1 - index][j]) <
-                    min_diff) {
-#ifdef DEBUG
-                    printf("CompassCalibration:point reject: [%f,%f,%f], selected_count=%d\n",
-                           data[0],
-                           data[1],
-                           data[2],
-                           cal_data->sample_count);
-#endif
-                    return 0;
-                }
-    }
-
-    if (cal_data->sample_count < MAGN_DS_SIZE) {
-        memcpy(cal_data->sample[cal_data->sample_count], data, sizeof(float) * 3);
-        cal_data->sample_count++;
-        cal_data->average[0] += data[0];
-        cal_data->average[1] += data[1];
-        cal_data->average[2] += data[2];
-#ifdef DEBUG
-        printf("CompassCalibration:point collected [%f,%f,%f], selected_count=%d\n",
-               (double) data[0],
-               (double) data[1],
-               (double) data[2],
-               cal_data->sample_count);
-#endif
-    }
-    return 1;
-}
-
-int
-MMC35240::compassReady(compass_cal_t* cal_data)
-{
-    mat_input_t mat;
-    int i;
-    float max_sqr_err;
-
-    compass_cal_t new_cal_data;
-
-    /*
-     * Some sensors take unrealistically long to calibrate at higher levels. We'll use a
-     * max_cal_level if we have such a property setup,
-     * or go with the default settings if not.
-     */
-    int cal_steps = CAL_STEPS;
-
-    if (cal_data->sample_count < MAGN_DS_SIZE)
-        return m_cal_level;
-
-    max_sqr_err = max_sqr_errs[m_cal_level];
-
-    /* Enough points have been collected, do the ellipsoid calibration */
-
-    /* Compute average per axis */
-    cal_data->average[0] /= MAGN_DS_SIZE;
-    cal_data->average[1] /= MAGN_DS_SIZE;
-    cal_data->average[2] /= MAGN_DS_SIZE;
-
-    for (i = 0; i < MAGN_DS_SIZE; i++) {
-        mat[i][0] = cal_data->sample[i][0];
-        mat[i][1] = cal_data->sample[i][1];
-        mat[i][2] = cal_data->sample[i][2];
-    }
-
-    /* Check if result is good. The sample data must remain the same */
-    new_cal_data = *cal_data;
-
-    if (ellipsoidFit(mat, new_cal_data.offset, new_cal_data.w_invert, &new_cal_data.bfield)) {
-        double new_err = calcSquareErr(&new_cal_data);
-#ifdef DEBUG
-        printf("new err is %f, max sqr err id %f\n", new_err, max_sqr_err);
-#endif
-        if (new_err < max_sqr_err) {
-            double err = calcSquareErr(cal_data);
-            if (new_err < err) {
-                /* New cal data is better, so we switch to the new */
-                cal_data->offset = new_cal_data.offset;
-                cal_data->w_invert = new_cal_data.w_invert;
-                cal_data->bfield = new_cal_data.bfield;
-                if (m_cal_level < (cal_steps - 1))
-                    m_cal_level++;
-#ifdef DEBUG
-                printf("CompassCalibration: ready check success, caldata: %f %f %f %f %f %f %f %f "
-                       "%f %f %f %f %f, err %f\n",
-                       cal_data->offset[0][0],
-                       cal_data->offset[1][0],
-                       cal_data->offset[2][0],
-                       cal_data->w_invert[0][0],
-                       cal_data->w_invert[0][1],
-                       cal_data->w_invert[0][2],
-                       cal_data->w_invert[1][0],
-                       cal_data->w_invert[1][1],
-                       cal_data->w_invert[1][2],
-                       cal_data->w_invert[2][0],
-                       cal_data->w_invert[2][1],
-                       cal_data->w_invert[2][2],
-                       cal_data->bfield,
-                       new_err);
-#endif
-            }
-        }
-    }
-    resetSample(cal_data);
-    return m_cal_level;
-}
-
-double
-MMC35240::calcSquareErr(compass_cal_t* data)
-{
-    double err = 0;
-    mat<double, 3, 1> raw, result, mat_diff;
-    int i;
-    float stdev[3] = { 0, 0, 0 };
-    double diff;
-
-    for (i = 0; i < MAGN_DS_SIZE; i++) {
-        raw[0][0] = data->sample[i][0];
-        raw[1][0] = data->sample[i][1];
-        raw[2][0] = data->sample[i][2];
-
-
-        stdev[0] += (raw[0][0] - data->average[0]) * (raw[0][0] - data->average[0]);
-        stdev[1] += (raw[1][0] - data->average[1]) * (raw[1][0] - data->average[1]);
-        stdev[2] += (raw[2][0] - data->average[2]) * (raw[2][0] - data->average[2]);
-
-        mat_diff = raw - data->offset;
-        result = multiply(data->w_invert, mat_diff);
-
-        diff = sqrt(result[0][0] * result[0][0] + result[1][0] * result[1][0] +
-                    result[2][0] * result[2][0]) -
-               data->bfield;
-
-        err += diff * diff;
-    }
-
-    stdev[0] = sqrt(stdev[0] / MAGN_DS_SIZE);
-    stdev[1] = sqrt(stdev[1] / MAGN_DS_SIZE);
-    stdev[2] = sqrt(stdev[2] / MAGN_DS_SIZE);
-
-    /* A sanity check - if we have too little variation for an axis it's best to reject the
-     * calibration than risking a wrong calibration */
-    if (stdev[0] <= 1 || stdev[1] <= 1 || stdev[2] <= 1)
-        return max_sqr_errs[0];
-
-    err /= MAGN_DS_SIZE;
-    return err;
-}
-
-int
-MMC35240::ellipsoidFit(mat_input_t& m,
-                       mat<double, 3, 1>& offset,
-                       mat<double, 3, 3>& w_invert,
-                       double* bfield)
-{
-    int i;
-    mat<double, MAGN_DS_SIZE, 9> h;
-    mat<double, MAGN_DS_SIZE, 1> w;
-    mat<double, 9, MAGN_DS_SIZE> h_trans;
-    mat<double, 9, 9> p_temp1;
-    mat<double, 9, MAGN_DS_SIZE> p_temp2;
-    mat<double, 3, 3> temp1, temp;
-    mat<double, 3, 3> temp1_inv;
-    mat<double, 3, 1> temp2;
-    mat<double, 9, 9> result;
-    mat<double, 9, 1> p;
-    mat<double, 3, 3> a, sqrt_evals, evecs, evecs_trans;
-    mat<double, 3, 1> evec1, evec2, evec3;
-
-    for (i = 0; i < MAGN_DS_SIZE; i++) {
-        w[i][0] = m[i][0] * m[i][0];
-        h[i][0] = m[i][0];
-        h[i][1] = m[i][1];
-        h[i][2] = m[i][2];
-        h[i][3] = -1 * m[i][0] * m[i][1];
-        h[i][4] = -1 * m[i][0] * m[i][2];
-        h[i][5] = -1 * m[i][1] * m[i][2];
-        h[i][6] = -1 * m[i][1] * m[i][1];
-        h[i][7] = -1 * m[i][2] * m[i][2];
-        h[i][8] = 1;
-    }
-
-    h_trans = transpose(h);
-    result = multiply(h_trans, h);
-    p_temp1 = invert(result);
-    p_temp2 = multiply(p_temp1, h_trans);
-    p = multiply(p_temp2, w);
-
-    temp1[0][0] = 2;
-    temp1[0][1] = p[3][0];
-    temp1[0][2] = p[4][0];
-    temp1[1][0] = p[3][0];
-    temp1[1][1] = 2 * p[6][0];
-    temp1[1][2] = p[5][0];
-    temp1[2][0] = p[4][0];
-    temp1[2][1] = p[5][0];
-    temp1[2][2] = 2 * p[7][0];
-
-    temp2[0][0] = p[0][0];
-    temp2[1][0] = p[1][0];
-    temp2[2][0] = p[2][0];
-
-    temp1_inv = invert(temp1);
-    offset = multiply(temp1_inv, temp2);
-
-    double off_x = offset[0][0];
-    double off_y = offset[1][0];
-    double off_z = offset[2][0];
-
-    a[0][0] = 1.0 / (p[8][0] + off_x * off_x + p[6][0] * off_y * off_y + p[7][0] * off_z * off_z +
-                     p[3][0] * off_x * off_y + p[4][0] * off_x * off_z + p[5][0] * off_y * off_z);
-
-    a[0][1] = p[3][0] * a[0][0] / 2;
-    a[0][2] = p[4][0] * a[0][0] / 2;
-    a[1][2] = p[5][0] * a[0][0] / 2;
-    a[1][1] = p[6][0] * a[0][0];
-    a[2][2] = p[7][0] * a[0][0];
-    a[2][1] = a[1][2];
-    a[1][0] = a[0][1];
-    a[2][0] = a[0][2];
-
-    double eig1 = 0, eig2 = 0, eig3 = 0;
-    computeEigenvalues(a, &eig1, &eig2, &eig3);
-
-    if (eig1 <= 0 || eig2 <= 0 || eig3 <= 0)
-        return 0;
-
-    sqrt_evals[0][0] = sqrt(eig1);
-    sqrt_evals[1][0] = 0;
-    sqrt_evals[2][0] = 0;
-    sqrt_evals[0][1] = 0;
-    sqrt_evals[1][1] = sqrt(eig2);
-    sqrt_evals[2][1] = 0;
-    sqrt_evals[0][2] = 0;
-    sqrt_evals[1][2] = 0;
-    sqrt_evals[2][2] = sqrt(eig3);
-
-    calcEvector(a, eig1, evec1);
-    calcEvector(a, eig2, evec2);
-    calcEvector(a, eig3, evec3);
-
-    evecs[0][0] = evec1[0][0];
-    evecs[1][0] = evec1[1][0];
-    evecs[2][0] = evec1[2][0];
-    evecs[0][1] = evec2[0][0];
-    evecs[1][1] = evec2[1][0];
-    evecs[2][1] = evec2[2][0];
-    evecs[0][2] = evec3[0][0];
-    evecs[1][2] = evec3[1][0];
-    evecs[2][2] = evec3[2][0];
-
-    temp1 = multiply(evecs, sqrt_evals);
-    evecs_trans = transpose(evecs);
-    temp = multiply(temp1, evecs_trans);
-    w_invert = transpose(temp);
-
-    *bfield = pow(sqrt(1 / eig1) * sqrt(1 / eig2) * sqrt(1 / eig3), 1.0 / 3.0);
-    if (*bfield < 0)
-        return 0;
-
-    w_invert = w_invert * (*bfield);
-
-    return 1;
-}
-
-/* Given an real symmetric 3x3 matrix A, compute the eigenvalues */
-void
-MMC35240::computeEigenvalues(mat<double, 3, 3>& A, double* eig1, double* eig2, double* eig3)
-{
-    double p = A[0][1] * A[0][1] + A[0][2] * A[0][2] + A[1][2] * A[1][2];
-
-    if (p < EPSILON) {
-        *eig1 = A[0][0];
-        *eig2 = A[1][1];
-        *eig3 = A[2][2];
-        return;
-    }
-
-    double q = (A[0][0] + A[1][1] + A[2][2]) / 3;
-    double temp1 = A[0][0] - q;
-    double temp2 = A[1][1] - q;
-    double temp3 = A[2][2] - q;
-
-    p = temp1 * temp1 + temp2 * temp2 + temp3 * temp3 + 2 * p;
-    p = sqrt(p / 6);
-
-    mat<double, 3, 3> B = A;
-    B[0][0] -= q;
-    B[1][1] -= q;
-    B[2][2] -= q;
-    B = (1 / p) * B;
-
-    double r =
-    (B[0][0] * B[1][1] * B[2][2] + B[0][1] * B[1][2] * B[2][0] + B[0][2] * B[1][0] * B[2][1] -
-     B[0][2] * B[1][1] * B[2][0] - B[0][0] * B[1][2] * B[2][1] - B[0][1] * B[1][0] * B[2][2]) /
-    2;
-
-    double phi;
-    if (r <= -1.0)
-        phi = M_PI / 3;
-    else if (r >= 1.0)
-        phi = 0;
-    else
-        phi = acos(r) / 3;
-
-    *eig3 = q + 2 * p* cos(phi);
-    *eig1 = q + 2 * p* cos(phi + 2 * M_PI / 3);
-    *eig2 = 3 * q - *eig1 - *eig3;
-}
-
-void
-MMC35240::calcEvector(mat<double, 3, 3>& A, double eig, mat<double, 3, 1>& vec)
-{
-    mat<double, 3, 3> h;
-    mat<double, 2, 2> x_tmp;
-
-    h = A;
-    h[0][0] -= eig;
-    h[1][1] -= eig;
-    h[2][2] -= eig;
-
-    mat<double, 2, 2> x;
-    x[0][0] = h[1][1];
-    x[0][1] = h[1][2];
-    x[1][0] = h[2][1];
-    x[1][1] = h[2][2];
-
-    x_tmp = invert(x);
-    x = x_tmp;
-
-    double temp1 = x[0][0] * (-h[1][0]) + x[0][1] * (-h[2][0]);
-    double temp2 = x[1][0] * (-h[1][0]) + x[1][1] * (-h[2][0]);
-    double norm = sqrt(1 + temp1 * temp1 + temp2 * temp2);
-
-    vec[0][0] = 1.0 / norm;
-    vec[1][0] = temp1 / norm;
-    vec[2][0] = temp2 / norm;
-}
-
-void
-MMC35240::scale(float* x, float* y, float* z)
-{
-    float sqr_norm = 0;
-    float sanity_norm = 0;
-    float scale = 1;
-
-    sqr_norm = (*x * *x + *y * *y + *z * *z);
-
-    if (sqr_norm < MAGNETIC_LOW)
-        sanity_norm = MAGNETIC_LOW;
-
-    if (sanity_norm && sqr_norm) {
-        scale = sanity_norm / sqr_norm;
-        scale = sqrt(scale);
-        *x = *x* scale;
-        *y = *y* scale;
-        *z = *z* scale;
-    }
-}
-
-void
-MMC35240::compassComputeCal(float* x, float* y, float* z, compass_cal_t* cal_data)
-{
-    mat<double, 3, 1> result, raw, diff;
-
-    if (!m_cal_level)
-        return;
-
-    raw[0][0] = *x;
-    raw[1][0] = *y;
-    raw[2][0] = *z;
-
-    diff = raw - cal_data->offset;
-    result = multiply(cal_data->w_invert, diff);
-
-    *x = result[0][0];
-    *y = result[1][0];
-    *z = result[2][0];
-
-    scale(x, y, z);
-}
-
-void
-MMC35240::denoise_average(float* x, float* y, float* z)
-{
-    /*
-     * Smooth out incoming data using a moving average over a number of
-     * samples. We accumulate one second worth of samples, or max_samples,
-     * depending on which is lower.
-     */
-    float* data[3];
-    int f;
-    int history_size;
-    int history_full = 0;
-    filter_average_t* filter;
-
-    data[0] = x;
-    data[1] = y;
-    data[2] = z;
-
-    /* Don't denoise anything if we have less than two samples per second */
-    if (m_sampling_frequency < 2)
-        return;
-
-    filter = (filter_average_t*) &m_filter;
-
-    if (!filter)
-        return;
-
-    /* Restrict window size to the min of sampling_rate and max_samples */
-    if (m_sampling_frequency > filter->max_samples)
-        history_size = filter->max_samples;
-    else
-        history_size = m_sampling_frequency;
-
-    /* Reset history if we're operating on an incorrect window size */
-    if (filter->history_size != history_size) {
-        filter->history_size = history_size;
-        filter->history_entries = 0;
-        filter->history_index = 0;
-        filter->history =
-        (float*) realloc(filter->history, filter->history_size * filter->num_fields * sizeof(float));
-        if (filter->history) {
-            filter->history_sum =
-            (float*) realloc(filter->history_sum, filter->num_fields * sizeof(float));
-            if (filter->history_sum)
-                memset(filter->history_sum, 0, filter->num_fields * sizeof(float));
-        }
-    }
-
-    if (!filter->history || !filter->history_sum)
-        return; /* Unlikely, but still... */
-
-    /* Update initialized samples count */
-    if (filter->history_entries < filter->history_size)
-        filter->history_entries++;
-    else
-        history_full = 1;
-
-    /* Record new sample and calculate the moving sum */
-    for (f = 0; f < filter->num_fields; f++) {
-        /** A field is going to be overwritten if history is full, so decrease the history sum */
-        if (history_full)
-            filter->history_sum[f] -=
-            filter->history[filter->history_index * filter->num_fields + f];
-
-        filter->history[filter->history_index * filter->num_fields + f] = *data[f];
-        filter->history_sum[f] += *data[f];
-
-        /* For now simply compute a mobile mean for each field and output filtered data */
-        *data[f] = filter->history_sum[f] / filter->history_entries;
-    }
-
-    /* Update our rolling index (next evicted cell) */
-    filter->history_index = (filter->history_index + 1) % filter->history_size;
-}
diff --git a/src/mmc35240/mmc35240.hpp b/src/mmc35240/mmc35240.hpp
deleted file mode 100644
index 5109e6e..0000000
--- a/src/mmc35240/mmc35240.hpp
+++ /dev/null
@@ -1,212 +0,0 @@
-/*
- * Author: Lay, Kuan Loon <kuan.loon.lay@intel.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- * Thanks to https://github.com/01org/android-iio-sensors-hal for magnetometer
- * calibration and denoise algorithm.
- */
-#pragma once
-
-#include <string>
-#include <mraa/iio.h>
-
-// Adopt
-// https://android.googlesource.com/platform/frameworks/native/+/refs/heads/master/services/sensorservice/mat.h
-#include "mat.h"
-
-#define MAGN_DS_SIZE 32
-
-namespace upm
-{
-/**
- * @brief MMC35240 Tri-axis Magnetic Sensor
- * @defgroup mmc35240 libupm-mmc35240
- * @ingroup STMicroelectronics iio i2c tri-axis magnetic sensor
- */
-
-/**
- * @library mmc35240
- * @sensor mmc35240
- * @comname MMC35240 Tri-axis Magnetic Sensor
- * @type compass
- * @man Memsic
- * @con iio i2c
- *
- * @brief MMC35240 Tri-axis Magnetic Sensor API
- *
- * The MMC3524xPJ is a complete 3-axis magnetic sensor
- *
- * @snippet mmc35240.cxx Interesting
- */
-
-class MMC35240
-{
-  public:
-    typedef struct {
-        /* hard iron offsets */
-        android::mat<double, 3, 1> offset;
-
-        /* soft iron matrix */
-        android::mat<double, 3, 3> w_invert;
-
-        /* geomagnetic strength */
-        double bfield;
-
-        /* selection data */
-        float sample[MAGN_DS_SIZE][3];
-        unsigned int sample_count;
-        float average[3];
-    } compass_cal_t;
-
-    typedef double mat_input_t[MAGN_DS_SIZE][3];
-
-    typedef struct {
-        int max_samples;     /* Maximum averaging window size */
-        int num_fields;      /* Number of fields per sample (usually 3) */
-        float* history;      /* Working buffer containing recorded samples */
-        float* history_sum;  /* The current sum of the history elements */
-        int history_size;    /* Number of recorded samples */
-        int history_entries; /* How many of these are initialized */
-        int history_index;   /* Index of sample to evict next time */
-    } filter_average_t;
-
-    /**
-     * MMC35240 Tri-axis Magnetic Sensor
-     *
-     * @param device iio device number
-     */
-    MMC35240(int device);
-
-    /**
-     * MMC35240 destructor
-     */
-    ~MMC35240();
-
-    /**
-     * Installs an interrupt service routine (ISR) to be called when
-     * an interrupt occurs
-     *
-     * @param isr Pointer to a function to be called on interrupt
-     * @param arg Pointer to an object to be supplied as an
-     * argument to the ISR.
-     */
-    void installISR(void (*isr)(char*, void*), void* arg);
-
-    /**
-     * Extract the channel value based on channel type
-     * @param input Channel data
-     * @param chan MRAA iio-layer channel info
-     */
-    int64_t getChannelValue(unsigned char* input, mraa_iio_channel* chan);
-
-    /**
-     * Enable trigger buffer
-     * @param length buffer length in integer
-     */
-    bool enableBuffer(int length);
-
-    /**
-     * Disable trigger buffer
-     */
-    bool disableBuffer();
-
-    /**
-     * Set scale
-     * @param scale in float
-     * Kernel driver does not support changing the value of scale on run-time
-     * Default scale is 0.001000
-     */
-    bool setScale(const float scale);
-
-    /**
-     * Set sampling frequency
-     * @param sampling_frequency sampling frequency in float
-     * Available sampling frequency are 1.5, 13, 25, 50
-     * Default sampling frequency is 1.500000
-     */
-    bool setSamplingFrequency(const float sampling_frequency);
-
-    /**
-     * Enable 3 axis scan element
-     */
-    bool enable3AxisChannel();
-
-    /**
-     * Process enabled channel buffer and return x, y, z axis
-     * @param data Enabled channel data, 6 bytes, each axis 2 bytes
-     * @param x X-Axis
-     * @param y Y-Axis
-     * @param z Z-Axis
-     */
-    void extract3Axis(char* data, float* x, float* y, float* z);
-
-    /**
-     * Get calibrated level
-     */
-    int getCalibratedLevel();
-
-    /**
-     * Reset calibration data and start collect calibration data again
-     */
-    void initCalibrate();
-
-    /**
-     * Get calibrated data
-     */
-    void
-    getCalibratedData(int* cal_level, double offset[3][1], double w_invert[3][3], double* bfield);
-
-    /**
-     * Load calibrated data
-     */
-    void
-    loadCalibratedData(int cal_level, double offset[3][1], double w_invert[3][3], double bfield);
-
-  private:
-    /* Adopt https://github.com/01org/android-iio-sensors-hal/blob/master/compass-calibration.c */
-    void resetSample(compass_cal_t* data);
-    void calibrateCompass(float* x, float* y, float* z, compass_cal_t* cal_data);
-    int compassCollect(float* x, float* y, float* z, compass_cal_t* cal_data);
-    int compassReady(compass_cal_t* cal_data);
-    double calcSquareErr(compass_cal_t* data);
-    int ellipsoidFit(mat_input_t& m,
-                     android::mat<double, 3, 1>& offset,
-                     android::mat<double, 3, 3>& w_invert,
-                     double* bfield);
-    void computeEigenvalues(android::mat<double, 3, 3>& A, double* eig1, double* eig2, double* eig3);
-    void calcEvector(android::mat<double, 3, 3>& A, double eig, android::mat<double, 3, 1>& vec);
-    void scale(float* x, float* y, float* z);
-    void compassComputeCal(float* x, float* y, float* z, compass_cal_t* cal_data);
-
-    /* Adopt https://github.com/01org/android-iio-sensors-hal/blob/master/filtering.c */
-    void denoise_average(float* x, float* y, float* z);
-
-    mraa_iio_context m_iio;
-    int m_iio_device_num;
-    float m_sampling_frequency; // sampling frequency
-    bool m_mount_matrix_exist;  // is mount matrix exist
-    float m_mount_matrix[9];    // mount matrix
-    float m_scale;              // data scale
-    compass_cal_t m_cal_data;   // calibrate data
-    int m_cal_level;            // calibrated level
-    filter_average_t m_filter;  // filter data
-};
-}
diff --git a/src/mmc35240/mmc35240.json b/src/mmc35240/mmc35240.json
deleted file mode 100644
index e2f9ebc..0000000
--- a/src/mmc35240/mmc35240.json
+++ /dev/null
@@ -1,54 +0,0 @@
-{
-    "Library": "mmc35240",
-    "Description": "Memsic MMC35240 Tri-axis Magnetic Sensor Library",
-    "Sensor Class": {
-        "MMC35240": {
-            "Name": "Memsic MMC35240 Tri-axis Magnetic Sensor API",
-            "Description": "This is the UPM Module for the Memsic MMC35240 Tri-axis Magnetic Sensor. Fully integrated 3-axis magnetic sensor and electronic circuits requiring fewer external components.",
-            "Aliases": ["mmc35240", "MMC3530KJ"],
-            "Categories": ["compass"],
-            "Connections": ["i2c"],
-            "Project Type": ["industrial", "commercial"],
-            "Manufacturers": ["Memsic"],
-            "Examples": {
-                "C++": ["mmc35240.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 1.62,
-                    "max": 1.98
-                },
-                "Supply Current": {
-                    "unit": "uA",
-                    "typ" : "160"
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Sensitivity": {
-                    "unit": "mG/LSB",
-                    "min" : "1",
-                    "max" : "4"
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need pull up resistors"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.memsic.com/magnetic-sensors/MMC3530KJ"],
-                "Datasheets": ["https://www.memsic.com/magnetic-sensors/MMC3530KJ"]
-            }
-        }
-    }
-}
diff --git a/src/mmc35240/traits.h b/src/mmc35240/traits.h
deleted file mode 100644
index da4c599..0000000
--- a/src/mmc35240/traits.h
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_TRAITS_H
-#define ANDROID_TRAITS_H
-
-// -----------------------------------------------------------------------
-// Typelists
-
-namespace android {
-
-// end-of-list marker
-class NullType {};
-
-// type-list node
-template <typename T, typename U>
-struct TypeList {
-    typedef T Head;
-    typedef U Tail;
-};
-
-// helpers to build typelists
-#define TYPELIST_1(T1) TypeList<T1, NullType>
-#define TYPELIST_2(T1, T2) TypeList<T1, TYPELIST_1(T2)>
-#define TYPELIST_3(T1, T2, T3) TypeList<T1, TYPELIST_2(T2, T3)>
-#define TYPELIST_4(T1, T2, T3, T4) TypeList<T1, TYPELIST_3(T2, T3, T4)>
-
-// typelists algorithms
-namespace TL {
-template <typename TList, typename T> struct IndexOf;
-
-template <typename T>
-struct IndexOf<NullType, T> {
-    enum { value = -1 };
-};
-
-template <typename T, typename Tail>
-struct IndexOf<TypeList<T, Tail>, T> {
-    enum { value = 0 };
-};
-
-template <typename Head, typename Tail, typename T>
-struct IndexOf<TypeList<Head, Tail>, T> {
-private:
-    enum { temp = IndexOf<Tail, T>::value };
-public:
-    enum { value = temp == -1 ? -1 : 1 + temp };
-};
-
-}; // namespace TL
-
-// type selection based on a boolean
-template <bool flag, typename T, typename U>
-struct Select {
-    typedef T Result;
-};
-template <typename T, typename U>
-struct Select<false, T, U> {
-    typedef U Result;
-};
-
-// -----------------------------------------------------------------------
-// Type traits
-
-template <typename T>
-class TypeTraits {
-    typedef TYPELIST_4(
-            unsigned char, unsigned short,
-            unsigned int, unsigned long int) UnsignedInts;
-
-    typedef TYPELIST_4(
-            signed char, signed short,
-            signed int, signed long int) SignedInts;
-
-    typedef TYPELIST_1(
-            bool) OtherInts;
-
-    typedef TYPELIST_3(
-            float, double, long double) Floats;
-
-    template<typename U> struct PointerTraits {
-        enum { result = false };
-        typedef NullType PointeeType;
-    };
-    template<typename U> struct PointerTraits<U*> {
-        enum { result = true };
-        typedef U PointeeType;
-    };
-
-public:
-    enum { isStdUnsignedInt = TL::IndexOf<UnsignedInts, T>::value >= 0 };
-    enum { isStdSignedInt   = TL::IndexOf<SignedInts,   T>::value >= 0 };
-    enum { isStdIntegral    = TL::IndexOf<OtherInts,    T>::value >= 0 || isStdUnsignedInt || isStdSignedInt };
-    enum { isStdFloat       = TL::IndexOf<Floats,       T>::value >= 0 };
-    enum { isPointer        = PointerTraits<T>::result };
-    enum { isStdArith       = isStdIntegral || isStdFloat };
-
-    // best parameter type for given type
-    typedef typename Select<isStdArith || isPointer, T, const T&>::Result ParameterType;
-};
-
-// -----------------------------------------------------------------------
-}; // namespace android
-
-#endif /* ANDROID_TRAITS_H */
diff --git a/src/mmc35240/vec.h b/src/mmc35240/vec.h
deleted file mode 100644
index a142bad..0000000
--- a/src/mmc35240/vec.h
+++ /dev/null
@@ -1,438 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_VEC_H
-#define ANDROID_VEC_H
-
-#include <math.h>
-
-#include <stdint.h>
-#include <stddef.h>
-
-#include "traits.h"
-
-// -----------------------------------------------------------------------
-
-#define PURE __attribute__((pure))
-
-namespace android {
-
-// -----------------------------------------------------------------------
-// non-inline helpers
-
-template <typename TYPE, size_t SIZE>
-class vec;
-
-template <typename TYPE, size_t SIZE>
-struct vbase;
-
-namespace helpers {
-
-template <typename T> inline T min(T a, T b) { return a<b ? a : b; }
-template <typename T> inline T max(T a, T b) { return a>b ? a : b; }
-
-template < template<typename T, size_t S> class VEC,
-    typename TYPE, size_t SIZE, size_t S>
-vec<TYPE, SIZE>& doAssign(
-        vec<TYPE, SIZE>& lhs, const VEC<TYPE, S>& rhs) {
-    const size_t minSize = min(SIZE, S);
-    const size_t maxSize = max(SIZE, S);
-    for (size_t i=0 ; i<minSize ; i++)
-        lhs[i] = rhs[i];
-    for (size_t i=minSize ; i<maxSize ; i++)
-        lhs[i] = 0;
-    return lhs;
-}
-
-
-template <
-    template<typename T, size_t S> class VLHS,
-    template<typename T, size_t S> class VRHS,
-    typename TYPE,
-    size_t SIZE
->
-VLHS<TYPE, SIZE> PURE doAdd(
-        const VLHS<TYPE, SIZE>& lhs,
-        const VRHS<TYPE, SIZE>& rhs) {
-    VLHS<TYPE, SIZE> r;
-    for (size_t i=0 ; i<SIZE ; i++)
-        r[i] = lhs[i] + rhs[i];
-    return r;
-}
-
-template <
-    template<typename T, size_t S> class VLHS,
-    template<typename T, size_t S> class VRHS,
-    typename TYPE,
-    size_t SIZE
->
-VLHS<TYPE, SIZE> PURE doSub(
-        const VLHS<TYPE, SIZE>& lhs,
-        const VRHS<TYPE, SIZE>& rhs) {
-    VLHS<TYPE, SIZE> r;
-    for (size_t i=0 ; i<SIZE ; i++)
-        r[i] = lhs[i] - rhs[i];
-    return r;
-}
-
-template <
-    template<typename T, size_t S> class VEC,
-    typename TYPE,
-    size_t SIZE
->
-VEC<TYPE, SIZE> PURE doMulScalar(
-        const VEC<TYPE, SIZE>& lhs,
-        typename TypeTraits<TYPE>::ParameterType rhs) {
-    VEC<TYPE, SIZE> r;
-    for (size_t i=0 ; i<SIZE ; i++)
-        r[i] = lhs[i] * rhs;
-    return r;
-}
-
-template <
-    template<typename T, size_t S> class VEC,
-    typename TYPE,
-    size_t SIZE
->
-VEC<TYPE, SIZE> PURE doScalarMul(
-        typename TypeTraits<TYPE>::ParameterType lhs,
-        const VEC<TYPE, SIZE>& rhs) {
-    VEC<TYPE, SIZE> r;
-    for (size_t i=0 ; i<SIZE ; i++)
-        r[i] = lhs * rhs[i];
-    return r;
-}
-
-}; // namespace helpers
-
-// -----------------------------------------------------------------------
-// Below we define the mathematical operators for vectors.
-// We use template template arguments so we can generically
-// handle the case where the right-hand-size and left-hand-side are
-// different vector types (but with same value_type and size).
-// This is needed for performance when using ".xy{z}" element access
-// on vec<>. Without this, an extra conversion to vec<> would be needed.
-//
-// example:
-//      vec4_t a;
-//      vec3_t b;
-//      vec3_t c = a.xyz + b;
-//
-//  "a.xyz + b" is a mixed-operation between a vbase<> and a vec<>, requiring
-//  a conversion of vbase<> to vec<>. The template gunk below avoids this,
-// by allowing the addition on these different vector types directly
-//
-
-template <
-    template<typename T, size_t S> class VLHS,
-    template<typename T, size_t S> class VRHS,
-    typename TYPE,
-    size_t SIZE
->
-inline VLHS<TYPE, SIZE> PURE operator + (
-        const VLHS<TYPE, SIZE>& lhs,
-        const VRHS<TYPE, SIZE>& rhs) {
-    return helpers::doAdd(lhs, rhs);
-}
-
-template <
-    template<typename T, size_t S> class VLHS,
-    template<typename T, size_t S> class VRHS,
-    typename TYPE,
-    size_t SIZE
->
-inline VLHS<TYPE, SIZE> PURE operator - (
-        const VLHS<TYPE, SIZE>& lhs,
-        const VRHS<TYPE, SIZE>& rhs) {
-    return helpers::doSub(lhs, rhs);
-}
-
-template <
-    template<typename T, size_t S> class VEC,
-    typename TYPE,
-    size_t SIZE
->
-inline VEC<TYPE, SIZE> PURE operator * (
-        const VEC<TYPE, SIZE>& lhs,
-        typename TypeTraits<TYPE>::ParameterType rhs) {
-    return helpers::doMulScalar(lhs, rhs);
-}
-
-template <
-    template<typename T, size_t S> class VEC,
-    typename TYPE,
-    size_t SIZE
->
-inline VEC<TYPE, SIZE> PURE operator * (
-        typename TypeTraits<TYPE>::ParameterType lhs,
-        const VEC<TYPE, SIZE>& rhs) {
-    return helpers::doScalarMul(lhs, rhs);
-}
-
-
-template <
-    template<typename T, size_t S> class VLHS,
-    template<typename T, size_t S> class VRHS,
-    typename TYPE,
-    size_t SIZE
->
-TYPE PURE dot_product(
-        const VLHS<TYPE, SIZE>& lhs,
-        const VRHS<TYPE, SIZE>& rhs) {
-    TYPE r(0);
-    for (size_t i=0 ; i<SIZE ; i++)
-        r += lhs[i] * rhs[i];
-    return r;
-}
-
-template <
-    template<typename T, size_t S> class V,
-    typename TYPE,
-    size_t SIZE
->
-TYPE PURE length(const V<TYPE, SIZE>& v) {
-    return sqrt(dot_product(v, v));
-}
-
-template <
-    template<typename T, size_t S> class V,
-    typename TYPE,
-    size_t SIZE
->
-TYPE PURE length_squared(const V<TYPE, SIZE>& v) {
-    return dot_product(v, v);
-}
-
-template <
-    template<typename T, size_t S> class V,
-    typename TYPE,
-    size_t SIZE
->
-V<TYPE, SIZE> PURE normalize(const V<TYPE, SIZE>& v) {
-    return v * (1/length(v));
-}
-
-template <
-    template<typename T, size_t S> class VLHS,
-    template<typename T, size_t S> class VRHS,
-    typename TYPE
->
-VLHS<TYPE, 3> PURE cross_product(
-        const VLHS<TYPE, 3>& u,
-        const VRHS<TYPE, 3>& v) {
-    VLHS<TYPE, 3> r;
-    r.x = u.y*v.z - u.z*v.y;
-    r.y = u.z*v.x - u.x*v.z;
-    r.z = u.x*v.y - u.y*v.x;
-    return r;
-}
-
-
-template <typename TYPE, size_t SIZE>
-vec<TYPE, SIZE> PURE operator - (const vec<TYPE, SIZE>& lhs) {
-    vec<TYPE, SIZE> r;
-    for (size_t i=0 ; i<SIZE ; i++)
-        r[i] = -lhs[i];
-    return r;
-}
-
-// -----------------------------------------------------------------------
-
-// This our basic vector type, it just implements the data storage
-// and accessors.
-
-template <typename TYPE, size_t SIZE>
-struct vbase {
-    TYPE v[SIZE];
-    inline const TYPE& operator[](size_t i) const { return v[i]; }
-    inline       TYPE& operator[](size_t i)       { return v[i]; }
-};
-template<> struct vbase<float, 2> {
-    union {
-        float v[2];
-        struct { float x, y; };
-        struct { float s, t; };
-    };
-    inline const float& operator[](size_t i) const { return v[i]; }
-    inline       float& operator[](size_t i)       { return v[i]; }
-};
-template<> struct vbase<float, 3> {
-    union {
-        float v[3];
-        struct { float x, y, z; };
-        struct { float s, t, r; };
-        vbase<float, 2> xy;
-        vbase<float, 2> st;
-    };
-    inline const float& operator[](size_t i) const { return v[i]; }
-    inline       float& operator[](size_t i)       { return v[i]; }
-};
-template<> struct vbase<float, 4> {
-    union {
-        float v[4];
-        struct { float x, y, z, w; };
-        struct { float s, t, r, q; };
-        vbase<float, 3> xyz;
-        vbase<float, 3> str;
-        vbase<float, 2> xy;
-        vbase<float, 2> st;
-    };
-    inline const float& operator[](size_t i) const { return v[i]; }
-    inline       float& operator[](size_t i)       { return v[i]; }
-};
-
-// -----------------------------------------------------------------------
-
-template <typename TYPE, size_t SIZE>
-class vec : public vbase<TYPE, SIZE>
-{
-    typedef typename TypeTraits<TYPE>::ParameterType pTYPE;
-    typedef vbase<TYPE, SIZE> base;
-
-public:
-    // STL-like interface.
-    typedef TYPE value_type;
-    typedef TYPE& reference;
-    typedef TYPE const& const_reference;
-    typedef size_t size_type;
-
-    typedef TYPE* iterator;
-    typedef TYPE const* const_iterator;
-    iterator begin() { return base::v; }
-    iterator end() { return base::v + SIZE; }
-    const_iterator begin() const { return base::v; }
-    const_iterator end() const { return base::v + SIZE; }
-    size_type size() const { return SIZE; }
-
-    // -----------------------------------------------------------------------
-    // default constructors
-
-    vec() { }
-    vec(const vec& rhs)  : base(rhs) { }
-    vec(const base& rhs) : base(rhs) { }
-
-    // -----------------------------------------------------------------------
-    // conversion constructors
-
-    vec(pTYPE rhs) {
-        for (size_t i=0 ; i<SIZE ; i++)
-            base::operator[](i) = rhs;
-    }
-
-    template < template<typename T, size_t S> class VEC, size_t S>
-    explicit vec(const VEC<TYPE, S>& rhs) {
-        helpers::doAssign(*this, rhs);
-    }
-
-    explicit vec(TYPE const* array) {
-        for (size_t i=0 ; i<SIZE ; i++)
-            base::operator[](i) = array[i];
-    }
-
-    // -----------------------------------------------------------------------
-    // Assignment
-
-    vec& operator = (const vec& rhs) {
-        base::operator=(rhs);
-        return *this;
-    }
-
-    vec& operator = (const base& rhs) {
-        base::operator=(rhs);
-        return *this;
-    }
-
-    vec& operator = (pTYPE rhs) {
-        for (size_t i=0 ; i<SIZE ; i++)
-            base::operator[](i) = rhs;
-        return *this;
-    }
-
-    template < template<typename T, size_t S> class VEC, size_t S>
-    vec& operator = (const VEC<TYPE, S>& rhs) {
-        return helpers::doAssign(*this, rhs);
-    }
-
-    // -----------------------------------------------------------------------
-    // operation-assignment
-
-    vec& operator += (const vec& rhs);
-    vec& operator -= (const vec& rhs);
-    vec& operator *= (pTYPE rhs);
-
-    // -----------------------------------------------------------------------
-    // non-member function declaration and definition
-    // NOTE: we declare the non-member function as friend inside the class
-    // so that they are known to the compiler when the class is instantiated.
-    // This helps the compiler doing template argument deduction when the
-    // passed types are not identical. Essentially this helps with
-    // type conversion so that you can multiply a vec<float> by an scalar int
-    // (for instance).
-
-    friend inline vec PURE operator + (const vec& lhs, const vec& rhs) {
-        return helpers::doAdd(lhs, rhs);
-    }
-    friend inline vec PURE operator - (const vec& lhs, const vec& rhs) {
-        return helpers::doSub(lhs, rhs);
-    }
-    friend inline vec PURE operator * (const vec& lhs, pTYPE v) {
-        return helpers::doMulScalar(lhs, v);
-    }
-    friend inline vec PURE operator * (pTYPE v, const vec& rhs) {
-        return helpers::doScalarMul(v, rhs);
-    }
-    friend inline TYPE PURE dot_product(const vec& lhs, const vec& rhs) {
-        return android::dot_product(lhs, rhs);
-    }
-};
-
-// -----------------------------------------------------------------------
-
-template <typename TYPE, size_t SIZE>
-vec<TYPE, SIZE>& vec<TYPE, SIZE>::operator += (const vec<TYPE, SIZE>& rhs) {
-    vec<TYPE, SIZE>& lhs(*this);
-    for (size_t i=0 ; i<SIZE ; i++)
-        lhs[i] += rhs[i];
-    return lhs;
-}
-
-template <typename TYPE, size_t SIZE>
-vec<TYPE, SIZE>& vec<TYPE, SIZE>::operator -= (const vec<TYPE, SIZE>& rhs) {
-    vec<TYPE, SIZE>& lhs(*this);
-    for (size_t i=0 ; i<SIZE ; i++)
-        lhs[i] -= rhs[i];
-    return lhs;
-}
-
-template <typename TYPE, size_t SIZE>
-vec<TYPE, SIZE>& vec<TYPE, SIZE>::operator *= (vec<TYPE, SIZE>::pTYPE rhs) {
-    vec<TYPE, SIZE>& lhs(*this);
-    for (size_t i=0 ; i<SIZE ; i++)
-        lhs[i] *= rhs;
-    return lhs;
-}
-
-// -----------------------------------------------------------------------
-
-typedef vec<float, 2> vec2_t;
-typedef vec<float, 3> vec3_t;
-typedef vec<float, 4> vec4_t;
-
-// -----------------------------------------------------------------------
-
-}; // namespace android
-
-#endif /* ANDROID_VEC_H */
diff --git a/src/moisture/CMakeLists.txt b/src/moisture/CMakeLists.txt
deleted file mode 100644
index 814e9e8..0000000
--- a/src/moisture/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME moisture
-    DESCRIPTION "Analog Moisture Sensor"
-    C_HDR moisture.h
-    C_SRC moisture.c
-    CPP_HDR moisture.hpp
-    CPP_SRC moisture.cxx
-    FTI_SRC moisture_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa)
diff --git a/src/moisture/moisture.c b/src/moisture/moisture.c
deleted file mode 100644
index c401aed..0000000
--- a/src/moisture/moisture.c
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "moisture.h"
-
-moisture_context moisture_init(int pin) {
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        return NULL;
-    }
-
-    moisture_context dev =
-      (moisture_context) malloc(sizeof(struct _moisture_context));
-
-    if (dev == NULL) {
-        printf("Unable to allocate memory for device context\n");
-        return NULL;
-    }
-
-    dev->analog_pin = pin;
-    dev->aio = mraa_aio_init(dev->analog_pin);
-
-    if (dev->aio == NULL) {
-        printf("mraa_aio_init() failed.\n");
-        free(dev);
-
-        return NULL;
-    }
-
-    return dev;
-}
-
-void moisture_close(moisture_context dev) {
-    mraa_aio_close(dev->aio);
-    free(dev);
-}
-
-upm_result_t moisture_get_moisture(moisture_context dev,
-                                            int* moisture) {
-
-    *moisture = mraa_aio_read(dev->aio);
-
-    return UPM_SUCCESS;
-}
diff --git a/src/moisture/moisture.cxx b/src/moisture/moisture.cxx
deleted file mode 100644
index 9b1964c..0000000
--- a/src/moisture/moisture.cxx
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "moisture.hpp"
-
-using namespace upm;
-
-Moisture::Moisture(int pin)
-{
-  if ( !(m_aio = mraa_aio_init(pin)) )
-    throw std::invalid_argument(std::string(__FUNCTION__) +
-                                ": mraa_aio_init() failed, invalid pin?");
-}
-
-Moisture::~Moisture()
-{
-  mraa_aio_close(m_aio);
-}
-
-int Moisture::value()
-{
-  return mraa_aio_read(m_aio);
-}
diff --git a/src/moisture/moisture.h b/src/moisture/moisture.h
deleted file mode 100644
index 6b86095..0000000
--- a/src/moisture/moisture.h
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-
-#include "upm.h"
-#include "mraa/aio.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @file moisture.h
- * @library moisture
- * @brief C API for the Analog Moisture Sensor
- *
- * @include moisture.c
- */
-
-/**
- * device context
- */
-typedef struct _moisture_context {
-    mraa_aio_context    aio;
-    uint16_t            analog_pin;
-} *moisture_context;
-
-/**
- * Init function
- *
- * @param pin analog pin number
- * @return void* pointer to the sensor struct
- */
-moisture_context moisture_init(int pin);
-
-/**
- * Close function
- *
- * @param dev pointer to the sensor structure
- */
-void moisture_close(moisture_context dev);
-
-/**
- * Get Moisture function.
- *
- * @param dev pointer to the sensor struct
- * @param moisture pointer that will be used to store the
- * output value from the sensor
- */
-upm_result_t moisture_get_moisture(moisture_context dev,
-                                        int* moisture);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/moisture/moisture.hpp b/src/moisture/moisture.hpp
deleted file mode 100644
index bdb72dc..0000000
--- a/src/moisture/moisture.hpp
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/aio.h>
-
-namespace upm {
-  /**
-   * @brief Moisture Sensors Library
-   * @defgroup grovemoisture libupm-grovemoisture
-   * @ingroup seeed analog liquid eak hak
-   */
-
-  /**
-   * @library moisture
-   * @sensor moisture
-   * @comname Analog Moisture Sensor
-   * @altname Grove Moisture Sensor
-   * @type liquid
-   * @man seeed
-   * @con analog
-   * @kit eak hak
-   *
-   * @brief API for the Moisture Sensor
-   *
-   * UPM module for the Moisture Sensor.
-   * This sensor can be used to detect the moisture content
-   * of soil or whether there is water around the sensor.
-   * As the moisture content increases, so does the value that is read.
-   * Note: this sensor is not designed to be left in soil
-   * nor to be used outdoors.
-   *
-   * @image html moisture.jpg
-   * @snippet moisture.cxx Interesting
-   */
-  class Moisture {
-  public:
-    /**
-     * Analog moisture sensor constructor
-     *
-     * @param pin Analog pin to use
-     */
-    Moisture(int pin);
-    /**
-     * Moisture destructor
-     */
-    ~Moisture();
-    /**
-     * Gets the moisture value from the sensor
-     *
-     * @return Moisture reading
-     */
-    int value();
-
-  private:
-    mraa_aio_context m_aio;
-  };
-}
-
-
diff --git a/src/moisture/moisture.json b/src/moisture/moisture.json
deleted file mode 100644
index 0bf3993..0000000
--- a/src/moisture/moisture.json
+++ /dev/null
@@ -1,54 +0,0 @@
-{
-    "Library": "moisture",
-    "Description": "Moisture Sensor library",
-    "Sensor Class": {
-        "Moisture": {
-            "Name": "API for the Grove Moisture Sensor ",
-            "Description": "This is the UPM Module for the Grove moisture sensor. This sensor can be used to detect the moisture content of soil or whether there is water around the sensor. As the moisture content increases, so does the value that is read. Note: this sensor is not designed to be left in soil nor to be used outdoors.",
-            "Aliases": ["Grove Moisture Sensor"],
-            "Categories": ["liquid"],
-            "Connections": ["analog"],
-            "Project Type": ["prototyping"],
-            "Manufacturers": ["Seeed"],
-            "Kits": ["eak", "hak"],
-            "Image": "moisture.jpg",
-            "Examples": {
-                "Java": ["Moisture_Example.java"],
-                "Python": ["moisture.py"],
-                "Node.js": ["moisture.js"],
-                "C++": ["moisture.cxx"],
-                "C": ["moisture.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.3,
-                    "max": 5
-                },
-
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "min" : 0,
-                    "max" : 35
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need the Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need the Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-Moisture-Sensor-p-955.html"],
-                "Datasheets": ["http://wiki.seeed.cc/Grove-Moisture_Sensor/"]
-            }
-        }
-    }
-}
diff --git a/src/moisture/moisture_fti.c b/src/moisture/moisture_fti.c
deleted file mode 100644
index 9965559..0000000
--- a/src/moisture/moisture_fti.c
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "moisture.h"
-#include "upm_fti.h"
-
-/**
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_moisture_name[] = "Moisture";
-const char upm_moisture_description[] = "Analog Moisture Sensor";
-const upm_protocol_t upm_moisture_protocol[] = {UPM_ANALOG};
-const upm_sensor_t upm_moisture_category[] = {UPM_MOISTURE};
-
-// forward declarations
-const void* upm_moisture_get_ft(upm_sensor_t sensor_type);
-void* upm_moisture_init_name();
-void upm_moisture_close(void* dev);
-upm_result_t upm_moisture_get_moisture(void* dev, int* moisture);
-
-
-const upm_sensor_descriptor_t upm_moisture_get_descriptor (){
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_moisture_name;
-    usd.description = upm_moisture_description;
-    usd.protocol_size = 1;
-    usd.protocol = upm_moisture_protocol;
-    usd.category_size = 1;
-    usd.category = upm_moisture_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = &upm_moisture_init_name,
-    .upm_sensor_close = &upm_moisture_close,
-    .upm_sensor_get_descriptor = &upm_moisture_get_descriptor
-};
-
-static const upm_moisture_ft mft =
-{
-    .upm_moisture_sensor_get_moisture = &upm_moisture_get_moisture
-};
-
-const void* upm_moisture_get_ft(upm_sensor_t sensor_type){
-    if(sensor_type == UPM_MOISTURE){
-        return &mft;
-    }
-    if(sensor_type == UPM_SENSOR){
-        return &ft;
-    }
-    return NULL;
-}
-
-void* upm_moisture_init_name(){
-    return NULL;
-}
-
-void upm_moisture_close(void* dev){
-    moisture_close((moisture_context)dev);
-}
-
-upm_result_t upm_moisture_get_moisture(void* dev, int* moisture){
-    return moisture_get_moisture((moisture_context)dev, moisture);
-}
diff --git a/src/mpl3115a2/CMakeLists.txt b/src/mpl3115a2/CMakeLists.txt
deleted file mode 100644
index ec8d5e9..0000000
--- a/src/mpl3115a2/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "mpl3115a2")
-set (libdescription "I2C Precision Altimeter")
-set (module_src ${libname}.cpp)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/mpl3115a2/mpl3115a2.cpp b/src/mpl3115a2/mpl3115a2.cpp
deleted file mode 100644
index ab23e1b..0000000
--- a/src/mpl3115a2/mpl3115a2.cpp
+++ /dev/null
@@ -1,323 +0,0 @@
-/*
- * Author: William Penner <william.penner@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * This application code supports the mpl3115a2 digital barometric pressure
- * and temperature sensor from Freescale.  The datasheet is available
- * from their website:
- * http://cache.freescale.com/files/sensors/doc/data_sheet/MPL3115A2.pdf
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-#include <unistd.h>
-#include <stdlib.h>
-
-#include "mpl3115a2.hpp"
-
-using namespace upm;
-
-MPL3115A2::MPL3115A2 (int bus, int devAddr, uint8_t mode) : m_i2ControlCtx(bus)
-{
-    int id;
-
-    m_name = MPL3115A2_NAME;
-
-    m_controlAddr = devAddr;
-    m_bus = bus;
-
-    mraa::Result ret = m_i2ControlCtx.address(m_controlAddr);
-    if (ret != mraa::SUCCESS) {
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": mraa_i2c_address() failed");
-        return;
-    }
-
-    setOversampling(mode);
-
-    id = i2cReadReg_8(MPL3115A2_WHO_AM_I);
-    if (id != MPL3115A2_DEVICE_ID)  {
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": incorrect device id");
-        return;
-    }
-}
-
-/*
- * Function to test the device and verify that is appears operational
- * Typically functioning sensors will return "noisy" values and would
- * be expected to change a bit.  This fuction will check for this
- * variation.
- */
-
-int
-MPL3115A2::testSensor(void)
-{
-    int iTries;
-    float pressure, temperature;
-    float fPMin, fPMax, fTMin, fTMax;
-
-    fprintf(stdout, "Executing Sensor Test.\n" );
-
-    pressure    = getPressure(true);
-    temperature = getTemperature(false);
-    fPMin = fPMax = pressure;
-    fTMin = fTMax = temperature;
-
-    iTries = 20;
-    do {
-        sampleData();
-        pressure = getPressure(true);
-        temperature = getTemperature(false);
-        if (pressure < fPMin)    fPMin = pressure;
-        if (pressure > fPMax)    fPMax = pressure;
-        if (temperature < fTMin) fTMin = temperature;
-        if (temperature > fTMax) fTMax = temperature;
-    }
-    while(fPMin == fPMax && fTMin == fTMax && --iTries);
-
-    if (fPMin == fPMax && fTMin == fTMax) {
-        fprintf(stdout, "  Warning - sensor values not changing.\n" );
-        return -1;
-    }
-
-    fprintf(stdout, "  Test complete.\n");
-
-    return 0;
-}
-
-/*
- * Function to dump out the i2c register block to the screen
- */
-
-void
-MPL3115A2::dumpSensor(void)
-{
-    int i, j;
-
-    fprintf(stdout, "Dumping i2c block from %s\n", MPL3115A2_NAME);
-    for (i=0; i < 256; i+=16) {
-        fprintf(stdout, "  %02x: ", i);
-        for (j=i; j < i+16; j++) {
-            fprintf(stdout, "%02x ", i2cReadReg_8(j));
-        }
-        fprintf(stdout, "\n");
-    }
-}
-
-/*
- * Function used to soft RESET the MPL3115A2 device to ensure
- * it is in a known state.  This function can be used to reset
- * the min/max temperature and pressure values.
- */
-
-int
-MPL3115A2::resetSensor(void)
-{
-    fprintf(stdout, "Resetting MPL3115A2 device\n" );
-    i2cWriteReg(MPL3115A2_CTRL_REG1, MPL3115A2_CTRL_RESET);
-    usleep(50000);
-    i2cWriteReg(MPL3115A2_CTRL_REG1, MPL3115A2_CTRL_RESET |
-            MPL3115A2_SETOVERSAMPLE(m_oversampling));
-
-    return 0;
-}
-
-int
-MPL3115A2::sampleData(void)
-{
-    int val;
-    mraa::Result ret;
-    int tries = 15;
-    uint32_t us_delay;
-
-    // trigger measurement
-    ret = i2cWriteReg(MPL3115A2_CTRL_REG1,
-            MPL3115A2_CTRL_OST | MPL3115A2_SETOVERSAMPLE(m_oversampling));
-    if (mraa::SUCCESS != ret) {
-        fprintf(stdout, "Write to trigger measurement failed\n");
-        return -1;
-    }
-
-    // Calculate and delay the appopriate time for the measurement
-    us_delay = ((1 << m_oversampling) * 4 + 2) * 1000;
-    usleep(us_delay);
-
-    // Loop waiting for the ready bit to become active
-    while (tries-- > 0) {
-        val = i2cReadReg_8(MPL3115A2_CTRL_REG1);
-
-        /* wait for data ready, i.e. OST cleared */
-        if (!(val & MPL3115A2_CTRL_OST))
-            break;
-        usleep(20000);
-    }
-    if (tries < 0) {
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": timeout during measurement");
-        return -1;
-    }
-
-    return 0;
-}
-
-int32_t
-MPL3115A2::getPressureReg(int reg) {
-    return ((i2cReadReg_16(reg) << 8)|(uint32_t)i2cReadReg_8(reg+2))*100/64;
-}
-
-int32_t
-MPL3115A2::getTempReg(int reg) {
-    return (int32_t)((int16_t)i2cReadReg_16(reg)) * 1000 / 256;
-}
-
-float
-MPL3115A2::getPressure(int bSampleData) {
-    int ret;
-
-    // Trigger request to make a measurement
-    if (bSampleData) {
-        ret = sampleData();
-        if (ret < 0) {
-            fprintf(stdout, "Error sampling pressure\n");
-            return -1;
-        }
-    }
-    m_iPressure = getPressureReg(MPL3115A2_OUT_PRESS);
-
-    return (float)m_iPressure / 100;
-}
-
-float
-MPL3115A2::getTemperature(int bSampleData) {
-    int ret;
-
-    // Trigger request to make a measurement
-    if (bSampleData) {
-        ret = sampleData();
-        if (ret < 0) {
-            fprintf(stdout, "Error sampling temperature\n");
-            return -1;
-        }
-	}
-    m_iTemperature = getTempReg(MPL3115A2_OUT_TEMP);
-
-    return (float)m_iTemperature / 1000;
-}
-
-float
-MPL3115A2::getSealevelPressure(float altitudeMeters) {
-    float fPressure = (float)m_iPressure / 100.0;
-    return fPressure / pow(1.0-altitudeMeters/44330, 5.255);
-}
-
-float
-MPL3115A2::getAltitude (float sealevelPressure) {
-    float fPressure = (float)m_iPressure / 100.0;
-    return 44330 * (1.0 - pow(fPressure /sealevelPressure,0.1903));
-}
-
-void
-MPL3115A2::setOversampling(uint8_t oversampling)
-{
-    if (oversampling > MPL3115A2_MAXOVERSAMPLE)
-        oversampling = MPL3115A2_MAXOVERSAMPLE;
-    m_oversampling = oversampling;
-}
-
-uint8_t
-MPL3115A2::getOversampling(void)
-{
-    return m_oversampling;
-}
-
-float
-MPL3115A2::getTemperatureMax(void)
-{
-    return (float)getTempReg(MPL3115A2_T_MAX) / 1000;
-}
-
-float
-MPL3115A2::getTemperatureMin(void)
-{
-    return (float)getTempReg(MPL3115A2_T_MIN) / 1000;
-}
-
-float
-MPL3115A2::getPressureMax(void)
-{
-    return (float)getPressureReg(MPL3115A2_P_MAX) / 1000;
-}
-
-float
-MPL3115A2::getPressureMin(void)
-{
-    return (float)getPressureReg(MPL3115A2_P_MIN) / 1000;
-}
-
-float
-MPL3115A2::convertTempCtoF(float fTemp)
-{
-    return(fTemp * 9 / 5 + 32);
-}
-
-/*
- * This is set for 15degC (Pa = 0.0002961 in Hg)
- */
-float
-MPL3115A2::convertPaToinHg(float fPressure)
-{
-    return(fPressure * 0.0002961);
-}
-
-/*
- * Functions to read and write data to the i2c device
- */
-
-mraa::Result
-MPL3115A2::i2cWriteReg (uint8_t reg, uint8_t value) {
-    mraa::Result error = mraa::SUCCESS;
-
-    uint8_t data[2] = { reg, value };
-    error = m_i2ControlCtx.write (data, 2);
-
-    if (error != mraa::SUCCESS)
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ":mraa_i2c_write() failed");
-    return error;
-}
-
-uint16_t
-MPL3115A2::i2cReadReg_16 (int reg) {
-    uint16_t data;
-
-    data  = (uint16_t)m_i2ControlCtx.readReg(reg) << 8;
-    data |= (uint16_t)m_i2ControlCtx.readReg(reg+1);
-
-    return data;
-}
-
-uint8_t
-MPL3115A2::i2cReadReg_8 (int reg) {
-    return m_i2ControlCtx.readReg(reg);
-}
-
diff --git a/src/mpl3115a2/mpl3115a2.hpp b/src/mpl3115a2/mpl3115a2.hpp
deleted file mode 100644
index 406eeed..0000000
--- a/src/mpl3115a2/mpl3115a2.hpp
+++ /dev/null
@@ -1,256 +0,0 @@
-/*
- * Author: William Penner <william.penner@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-
-#pragma once
-
-#include <string>
-#include <mraa/i2c.hpp>
-#include <math.h>
-
-#define MPL3115A2_NAME        "mpl3115a2"
-
-#define MPL3115A2_I2C_ADDRESS   0x60
-#define MPL3115A2_DEVICE_ID     0xc4
-
-#define MPL3115A2_STATUS        0x00
-#define MPL3115A2_OUT_PRESS     0x01  /* MSB first, 20 bit */
-#define MPL3115A2_OUT_TEMP      0x04  /* MSB first, 12 bit */
-#define MPL3115A2_WHO_AM_I      0x0c
-#define MPL3115A2_PT_DATA_CFG   0x13
-#define MPL3115A2_P_MIN         0x1C
-#define MPL3115A2_T_MIN         0x1F
-#define MPL3115A2_P_MAX         0x21
-#define MPL3115A2_T_MAX         0x24
-#define MPL3115A2_CTRL_REG1     0x26
-
-// CTRL_REG1
-#define MPL3115A2_CTRL_SBYB     0x01  /* Standby (not) */
-#define MPL3115A2_CTRL_OST      0x02  /* One-shot trigger */
-#define MPL3115A2_CTRL_RESET    0x04  /* RESET device */
-#define MPL3115A2_CTRL_ALT_MODE 0x80  /* Altitude mode */
-
-#define MPL3115A2_SETOVERSAMPLE(a) ((a & 7) << 3)
-#define MPL3115A2_GETOVERSAMPLE(a) ((a >> 3) & 7)
-#define MPL3115A2_MAXOVERSAMPLE   7
-
-namespace upm {
-
-/**
- * @brief MPL3115A2 Atmospheric Pressure Sensor
- * @defgroup mpl3115a2 libupm-mpl3115a2
- * @ingroup freescale i2c pressure
- */
-/**
- * @library mpl3115a2
- * @sensor mpl3115a2
- * @comname I2C Precision Altimeter
- * @type pressure
- * @man freescale
- * @web http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=MPL3115A2
- * @con i2c
- *
- * @brief API for the MPL3115A2 Atmospheric Pressure Sensor
- *
- * Freescale Semiconductor* [MPL3115A2]
- * (http://cache.freescale.com/files/sensors/doc/data_sheet/MPL3115A2.pdf)
- * is a high-precision, ultra-low power consumption pressure sensor. Its operating
- * range is 50-110 kPa.
- *
- * @image html mpl3115a2.jpg
- * @snippet mpl3115a2.cxx Interesting
- */
-class MPL3115A2 {
-    public:
-        /**
-         * Instantiates an MPL3115A2 object
-         *
-         * @param bus Number of the used bus
-         * @param devAddr Address of the used I2C device
-         * @param mode MPL3115A2 oversampling (6 = 64x)
-         */
-        MPL3115A2(int bus, int devAddr=MPL3115A2_I2C_ADDRESS, uint8_t mode=6);
-
-        /**
-         * MPL3115A2 object destructor; basically, it closes the I2C connection.
-         * ~MPL3115A2();
-         * no need for this here, as the I2c connection will be closed when the
-         * m_i2ControlCtx variable will go out of scope
-         **/
-
-        /**
-         * Tests the sensor and tries to determine if the sensor is operating by looking
-         * for small variations in the value
-         */
-        int testSensor(void);
-
-        /**
-         * Performs a soft reset of the MPL3115A2 device to ensure
-         * it is in a known state. This function can be used to reset
-         * the min/max temperature and pressure values.
-         */
-        int resetSensor(void);
-
-        /**
-         * Dumps out the I2C register block to stdout
-         */
-        void dumpSensor(void);
-
-        /**
-         * Initiates a temperature/pressure mesasurement and waits for the function
-         * to complete. Temperature and pressure registers can be read
-         * after this call.
-         */
-        int sampleData(void);
-
-        /**
-         * Reads the pressure value from MPL3115A2 [Pa * 100]
-         *
-         * @param reg Base address of the pressure register
-         */
-        int32_t getPressureReg(int reg);
-
-        /**
-         * Reads the temperature value from MPL3115A2 [degC * 1000]
-         *
-         * @param reg Base address of the temperature register
-         */
-        int32_t getTempReg(int reg);
-
-        /**
-         * Reads the current pressure value from MPL3115A2 [Pa]
-         *
-         * @param bSampleData Sets non-zero to a sample reading
-         */
-        float getPressure(int bSampleData = true);
-
-        /**
-         * Reads the current temperature value from MPL3115A2 [degC]
-         *
-         * @param bSampleData Sets non-zero to a sample reading
-         */
-        float getTemperature(int bSampleData = true);
-
-        /**
-         * Reads the current pressure and, using a known altitude, calculates
-         * the sea level pressure value [Pa]
-         * This function should be preceded by the sampleData() call
-         *
-         * @param altitudeMeters Altitude in meters
-         */
-        float getSealevelPressure(float altitudeMeters = 0.0);
-
-        /**
-         * Reads the current pressure and, using a known sea level pressure,
-         * calculates the altitude value [m]
-         * This function should be preceded by the sampleData() call
-         *
-         * @param sealevelPressure Current sea level pressure
-         */
-        float getAltitude (float sealevelPressure = 101325.0);
-
-        /**
-         * Defines the oversampling setting (ranges from 0 to 7). The
-         * value represents 2^n samples (ranging from 1 to 128). The
-         * time to calculate a sample is approximately (2^n * 4 + 2) ms
-         *
-         * @param oversampling New oversampling value
-         */
-        void setOversampling(uint8_t oversampling);
-
-        /**
-         * Returns the current oversampling value
-         */
-        uint8_t getOversampling(void);
-
-        /**
-         * Reads the maximum measured temperature [degC]
-         */
-        float getTemperatureMax(void);
-
-        /**
-         * Reads the minimum measured temperature [degC]
-         */
-        float getTemperatureMin(void);
-
-        /**
-         * Reads the maximum measured pressure [Pa]
-         */
-        float getPressureMax (void);
-
-        /**
-         * Reads the minimum measured pressure [Pa]
-         */
-        float getPressureMin (void);
-
-        /**
-         * Converts temperature from degC*1000 to degF*1000
-         *
-         * @param fTemp Temperature in degC
-         */
-        float convertTempCtoF(float fTemp);
-
-        /**
-         * Converts pressure from Pa*100 to inHg*10000
-         * This is set for 15degC (Pa = 0.0002961 in Hg)
-         * TODO: Change the function to add temperature calibration
-         *
-         * @param fPressure Pressure in Pa
-         */
-        float convertPaToinHg(float fPressure);
-
-        /**
-         * Writes one byte to an I2C register
-         *
-         * @param reg Address of the register
-         * @param value Byte to be written
-         */
-        mraa::Result i2cWriteReg (uint8_t reg, uint8_t value);
-
-        /**
-         * Reads two bytes from an I2C register
-         *
-         * @param reg Address of the register
-         */
-        uint16_t i2cReadReg_16 (int reg);
-
-        /**
-         * Reads a one-byte register
-         *
-         * @param reg Address of the register
-         */
-        uint8_t i2cReadReg_8 (int reg);
-
-    private:
-        std::string m_name;
-
-        int m_controlAddr;
-        int m_bus;
-        mraa::I2c m_i2ControlCtx;
-
-        uint8_t m_oversampling;
-        int32_t m_iPressure;
-        int32_t m_iTemperature;
-};
-
-}
-
diff --git a/src/mpl3115a2/mpl3115a2.json b/src/mpl3115a2/mpl3115a2.json
deleted file mode 100644
index f52dd62..0000000
--- a/src/mpl3115a2/mpl3115a2.json
+++ /dev/null
@@ -1,69 +0,0 @@
-{
-    "Library": "mpl3115a2",
-    "Description": "NXP/Adafruit MPL3115A2 Atmospheric Pressure Sensor library",
-    "Sensor Class": {
-        "MPL3115A2": {
-            "Name": "NXP/Adafruit MPL3115A2 Atmospheric Pressure Sensor",
-            "Description": "This is the UPM Module for the NXP/Adafruit MPL3115A2 Atmospheric Pressure Sensor. This sensor is a compact absolute pressure sensor, with a wide operating range and high operating accuracy, offering a 24-bit ADC onboard. It also offers internal compensation, and a fast i2c interface.",
-            "Aliases": ["mpl3115a2", "MPL3115A2 - I2C Barometric Pressure/Altitude/Temperature Sensor"],
-            "Categories": ["pressure"],
-            "Connections": ["i2c"],
-            "Project Type": ["medical", "industrial", "commercial"],
-            "Manufacturers": ["NXP", "Adafruit"],
-            "Image": "mpl3115a2.jpg",
-            "Examples": {
-                "Java": ["MPL3115A2_Example.java"],
-                "C++": ["mpl3115a2.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3,
-                    "max": 5.5
-                },
-                "Supply Current": {
-                    "unit": "uA",
-                    "min" : "8.5",
-                    "max" : "265"
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Measurement Range":{
-                    "Calibrated Range": {
-                        "unit": "kPa",
-                        "min" : 50,
-                        "max" : 110
-                    },
-                    "Operational Range": {
-                        "unit": "kPa",
-                        "min" : 20,
-                        "max" : 110
-                    }
-                },
-                "Pressure Accuracy": {
-                    "unit": "kPa",
-                    "lower": "-0.4",
-                    "upper": "0.4"
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need pull up resistors"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.adafruit.com/product/1893"],
-                "Datasheets": ["http://www.nxp.com/docs/en/data-sheet/MPL3115A2.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/mpr121/CMakeLists.txt b/src/mpr121/CMakeLists.txt
deleted file mode 100644
index 8a2e86a..0000000
--- a/src/mpr121/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME mpr121
-    DESCRIPTION "Digital Capacitive Touch Sensor Controller"
-    C_HDR mpr121.h
-    C_SRC mpr121.c
-    CPP_HDR mpr121.hpp
-    CPP_SRC mpr121.cxx
-    FTI_SRC mpr121_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa)
diff --git a/src/mpr121/mpr121.c b/src/mpr121/mpr121.c
deleted file mode 100644
index 8527178..0000000
--- a/src/mpr121/mpr121.c
+++ /dev/null
@@ -1,208 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "mpr121.h"
-
-mpr121_context mpr121_init(int bus, uint8_t address) {
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        return NULL;
-    }
-
-    mpr121_context dev = (mpr121_context)malloc(sizeof(struct _mpr121_context));
-
-    if (!dev)
-      return NULL;
-
-    dev->bus = bus;
-    dev->address = address;
-    dev->i2c = mraa_i2c_init(dev->bus);
-
-    if(dev->i2c == NULL){
-        free(dev);
-        return NULL;
-    }
-
-    if (mraa_i2c_address(dev->i2c, dev->address) != MRAA_SUCCESS){
-        printf("error using i2c address: %x\n", dev->address);
-        free(dev);
-        return NULL;
-    }
-
-    dev->over_current_fault = false;
-    return dev;
-}
-
-void mpr121_close(mpr121_context dev){
-    mraa_i2c_stop(dev->i2c);
-    free(dev);
-}
-
-upm_result_t mpr121_write_bytes(mpr121_context dev, uint8_t reg,
-                                uint8_t *buffer, int len){
-    if(!len || !buffer)
-        return UPM_ERROR_INVALID_SIZE;
-
-    // create a buffer 1 byte larger than the supplied buffer,
-    // store the register in the first byte
-    uint8_t buf2[len + 1];
-    buf2[0] = reg;
-
-    // copy in the buffer after the reg byte
-
-    int i;
-    for(i=1; i<(len + 1); i++)
-        buf2[i] = buffer[i-1];
-
-    if(mraa_i2c_write(dev->i2c, buf2, len+1) != MRAA_SUCCESS){
-        printf("write byte error while writing\n");
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-    return UPM_SUCCESS;
-}
-
-upm_result_t mpr121_read_bytes(mpr121_context dev, uint8_t reg,
-                               uint8_t *buffer, int len){
-    if(!len || !buffer)
-        return UPM_ERROR_INVALID_SIZE;
-
-    // The usual m_i2c.read() does not work here, so we need to
-    // read each byte individually.
-    int i;
-    for (i=0; i<len; i++)
-        buffer[i] = mraa_i2c_read_byte_data(dev->i2c, reg+i);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t mpr121_read_buttons(mpr121_context dev, uint32_t* states,
-                                     int num){
-    int len = 2;
-    uint8_t buffer[2];
-
-    // read in the 2 bytes at register 0x00-0x01, and setup the member
-    // variables accordingly.
-    mpr121_read_bytes(dev, 0x00, buffer, len);
-
-    *states = (buffer[0] | ((buffer[1] & 0x1f) << 8));
-    if (buffer[1] & 0x80)
-        dev->over_current_fault = true;
-    else
-        dev->over_current_fault = false;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t mpr121_config_an3944(mpr121_context dev){
-    // Configure the mpr121 chip as recommended in the AN3944 MPR121
-    // Quick Start Guide
-    // First, turn off all electrodes by zeroing out the Electrode Configuration
-    // register.
-    // If this one fails, it's unlikely any of the others will succeed.
-    uint8_t eleConf = 0x00;
-    if (mpr121_write_bytes(dev, 0x5e, &eleConf, 1) != UPM_SUCCESS){
-        printf("write to electrode configuration register failed\n");
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // Section A
-    // Filtering when data is greater than baseline
-    // regs 0x2b-0x2e
-
-    uint8_t sectA[] = {0x01, 0x01, 0x00, 0x00};
-    if (mpr121_write_bytes(dev, 0x2b, sectA, 4) != UPM_SUCCESS){
-        printf("write to section a failed\n");
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // Section B
-    // Filtering when data is less than baseline
-    // regs 0x2f-0x32
-
-    uint8_t sectB[] = {0x01, 0x01, 0xff, 0x02};
-    if (mpr121_write_bytes(dev, 0x2f, sectB, 4) != UPM_SUCCESS){
-        printf("write to section b failed\n");
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // Section C
-    // Touch Threshold/Release registers, ELE0-ELE11
-    // regs 0x41-0x58
-    //                    __T_  __R_
-    uint8_t sectC[] =  {0x0f, 0x0a,
-        0x0f, 0x0a,
-        0x0f, 0x0a,
-        0x0f, 0x0a,
-        0x0f, 0x0a,
-        0x0f, 0x0a,
-        0x0f, 0x0a,
-        0x0f, 0x0a,
-        0x0f, 0x0a,
-        0x0f, 0x0a,
-        0x0f, 0x0a,
-        0x0f, 0x0a};
-
-    if (mpr121_write_bytes(dev, 0x41, sectC, 24) != UPM_SUCCESS){
-        printf("failed to configure touch threshold/release regs\n");
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // Section D
-    // Filter configuration
-    // reg 0x5d
-    uint8_t filterConf = 0x04;
-    if (mpr121_write_bytes(dev, 0x5d, &filterConf, 1) != UPM_SUCCESS){
-        printf("unable to configure filters\n");
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // Section F
-    // Autoconfiguration registers
-    // regs 0x7b-0x7f
-    uint8_t sectF0 = 0x0b;
-    if (mpr121_write_bytes(dev, 0x7b, &sectF0, 1) != UPM_SUCCESS){
-        printf("unable to configure auto config regs\n");
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    uint8_t sectF1[] = {0x9c, 0x65, 0x8c};
-    if (mpr121_write_bytes(dev, 0x7d, sectF1, 3) != UPM_SUCCESS){
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // Section E - this one must be set last, and switches to run mode
-    // Enable all 12 electrodes, and set a pre-calibration to avoid
-    // excessive calibration delay on startup.
-    // reg 0x5e
-    eleConf = 0x8c;
-    if (mpr121_write_bytes(dev, 0x5e, &eleConf, 3) != UPM_SUCCESS){
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
diff --git a/src/mpr121/mpr121.cxx b/src/mpr121/mpr121.cxx
deleted file mode 100644
index 8a3c9f8..0000000
--- a/src/mpr121/mpr121.cxx
+++ /dev/null
@@ -1,205 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "mpr121.hpp"
-
-using namespace upm;
-using namespace std;
-
-
-MPR121::MPR121(int bus, uint8_t address) : m_i2c(bus)
-{
-  m_addr = address;
-  mraa::Result ret = m_i2c.address(m_addr);
-
-  if (ret != mraa::SUCCESS) 
-    {
-      throw std::invalid_argument(std::string(__FUNCTION__) +
-                                  ": mraa_i2c_address() failed");
-      return;
-    }
-
-  m_buttonStates = 0;
-  m_overCurrentFault = false;
-}
-
-mraa::Result MPR121::writeBytes(uint8_t reg, uint8_t *buffer, int len)
-{
-  if (!len || !buffer)
-    return mraa::SUCCESS;
-
-  // create a buffer 1 byte larger than the supplied buffer,
-  // store the register in the first byte
-  uint8_t buf2[len + 1];
-
-  buf2[0] = reg;
-
-  // copy in the buffer after the reg byte
-  for (int i=1; i<(len + 1); i++)
-    buf2[i] = buffer[i-1];
-
-  return m_i2c.write(buf2, len + 1);
-}
-
-int MPR121::readBytes(uint8_t reg, uint8_t *buffer, int len)
-{
-  if (!len || !buffer)
-    return 0;
-
-  // The usual m_i2c.read() does not work here, so we need to
-  // read each byte individually.
-  for (int i=0; i<len; i++)
-    buffer[i] = m_i2c.readReg(reg + i);
-
-  return len;
-}
-
-bool MPR121::configAN3944()
-{
-  // Configure the mpr121 chip as recommended in the AN3944 MPR121
-  // Quick Start Guide
-
-  mraa::Result rv;
-
-  // First, turn off all electrodes by zeroing out the Electrode Configuration
-  // register.
-  // If this one fails, it's unlikely any of the others will succeed.
-  uint8_t eleConf = 0x00;
-  if ((rv = writeBytes(0x5e, &eleConf, 1)) != mraa::SUCCESS)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": writeBytes(0x5e) failed");
-      return false;
-    }
-
-  // Section A
-  // Filtering when data is greater than baseline
-  // regs 0x2b-0x2e
-  uint8_t sectA[] = { 0x01, 0x01, 0x00, 0x00 };
-  if ((rv = writeBytes(0x2b, sectA, 4)) != mraa::SUCCESS)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": writeBytes(0x2b) failed");
-      return false;
-    }
-
-  // Section B
-  // Filtering when data is less than baseline
-  // regs 0x2f-0x32
-  uint8_t sectB[] = { 0x01, 0x01, 0xff, 0x02 };
-  if ((rv = writeBytes(0x2f, sectB, 4)) != mraa::SUCCESS)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": writeBytes(0x2f) failed");
-      return false;
-    }
-
-  // Section C
-  // Touch Threshold/Release registers, ELE0-ELE11
-  // regs 0x41-0x58
-  //                __T_  __R_
-  uint8_t sectC[] = { 0x0f, 0x0a,
-                      0x0f, 0x0a,
-                      0x0f, 0x0a,
-                      0x0f, 0x0a,
-                      0x0f, 0x0a,
-                      0x0f, 0x0a,
-                      0x0f, 0x0a,
-                      0x0f, 0x0a,
-                      0x0f, 0x0a,
-                      0x0f, 0x0a,
-                      0x0f, 0x0a,
-                      0x0f, 0x0a };
-  if ((rv = writeBytes(0x41, sectC, 24)) != mraa::SUCCESS)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": writeBytes(0x41) failed");
-      return false;
-    }
-
-  // Section D
-  // Filter configuration
-  // reg 0x5d
-  uint8_t filterConf = 0x24;
-  if ((rv = writeBytes(0x5d, &filterConf, 1)) != mraa::SUCCESS)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": writeBytes(0x5d) failed");
-      return false;
-    }
-
-  // Section F
-  // Autoconfiguration registers
-  // regs 0x7b-0x7f
-  uint8_t sectF0 = 0x0b;
-  if ((rv = writeBytes(0x7b, &sectF0, 1)) != mraa::SUCCESS)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": writeBytes(0x7b) failed");
-      return false;
-    }
-  uint8_t sectF1[] = { 0x9c, 0x65, 0x8c };
-  if ((rv = writeBytes(0x7d, sectF1, 3)) != mraa::SUCCESS)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": writeBytes(0x7d) failed");
-      return false;
-    }
-
-  // Section E - this one must be set last, and switches to run mode
-  // Enable all 12 electrodes, and set a pre-calibration to avoid
-  // excessive calibration delay on startup.
-  // reg 0x5e
-  eleConf = 0x8c;
-  if ((rv = writeBytes(0x5e, &eleConf, 1)) != mraa::SUCCESS)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": writeBytes(0x5e) failed");
-      return false;
-    }
-
-  return true;
-}
-
-void MPR121::readButtons()
-{
-  uint8_t buffer[2];
-
-  // read in the 2 bytes at register 0x00-0x01, and setup the member
-  // variables accordingly.
-
-  readBytes(0x00, buffer, 2);
-
-  m_buttonStates = (buffer[0] | ((buffer[1] & 0x1f) << 8));
-  if (buffer[1] & 0x80)
-    m_overCurrentFault = true;
-  else
-    m_overCurrentFault = false;
-
-  return;
-}
diff --git a/src/mpr121/mpr121.h b/src/mpr121/mpr121.h
deleted file mode 100644
index 64f6f6a..0000000
--- a/src/mpr121/mpr121.h
+++ /dev/null
@@ -1,119 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef MPR121_H_
-#define MPR121_H_
-
-#include <stdint.h>
-#include "upm.h"
-#include "mraa/i2c.h"
-
-#define MPR121_I2C_BUS     0
-#define MPR121_DEFAULT_I2C_ADDR    0x5a
-
-/**
- * @file mpr121.h
- * @library mpr121
- * @brief C API for the MPR121 Touch Sensor
- *
- * @include mpr121.c
- */
-
-/**
- * device context
- */
-typedef struct _mpr121_context {
-    mraa_i2c_context    i2c;
-    int                 bus;
-    uint8_t             address;
-    uint8_t             over_current_fault;
-} *mpr121_context;
-
-/**
- * MPR121 Init function
- *
- * @param bus i2c bus
- * @param address i2c address of the sensor
- * @return void* pointer to the sensor struct
- */
-mpr121_context mpr121_init(int bus, uint8_t address);
-
-/**
- * MPR121 Close function
- *
- * @param dev pointer to sensor struct
- */
-void mpr121_close(mpr121_context dev);
-
-/**
- * Sets up a default configuration, based on Application Note 3944
- * (AN3944):
- * http://cache.freescale.com/files/sensors/doc/app_note/AN3944.pdf
- *
- * After configuration, the sensor is left in the run state.
- *
- * @param dev pointer to the sensor struct
- * @return upm_result_t UPM success/error code
- */
-upm_result_t mpr121_config_an3944(mpr121_context dev);
-
-/**
- * Function to read the individual button values
- *
- * @param dev pointer to the sensor struct
- * @param states Pointer to store the states of the individual buttons
- * @param num used to retrieve the state of a particular button
- * @return upm_result_t UPM success/error code
- */
-upm_result_t mpr121_read_buttons(mpr121_context dev, uint32_t* states, int num);
-
-/**
- * Function used to write multiple bytes to the i2c bus
- *
- * @param dev sensor struct
- * @param reg i2c register to read from
- * @param *buffer pointer that contains the values that have to be
- * written to the registers
- * @param len length of the values that have to be written to the regs
- * @return upm_result_t UPM success/error code
- */
-upm_result_t mpr121_write_bytes(mpr121_context dev, uint8_t reg,
-                                uint8_t *buffer, int len);
-
-/**
- * Function used to read multiple bytes from the i2c bus
- *
- * @param dev sensor struct
- * @param reg i2c register to read from
- * @param *buffer pointer that contains the values that have been
- * read from the registers
- * @param len length of the values that have to be read
- * @return upm_result_t UPM success/error code
- */
-
-upm_result_t mpr121_read_bytes(mpr121_context dev, uint8_t reg,
-                               uint8_t *buffer, int len);
-
-#endif /* MPR121_H_ */
diff --git a/src/mpr121/mpr121.hpp b/src/mpr121/mpr121.hpp
deleted file mode 100644
index 48ea254..0000000
--- a/src/mpr121/mpr121.hpp
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/i2c.hpp>
-
-#define MPR121_I2C_BUS     0
-#define MPR121_DEFAULT_I2C_ADDR    0x5a
-
-namespace upm {
-  /**
-   * @brief MPR121 Touch Sensor
-   * @defgroup mpr121 libupm-mpr121
-   * @ingroup seeed i2c touch tsk
-   */
-  /**
-   * @library mpr121
-   * @sensor mpr121
-   * @comname Digital Capacitive Touch Sensor Controller
-   * @altname Grove I2C Touch Sensor
-   * @type touch
-   * @man seeed
-   * @web http://www.seeedstudio.com/wiki/Grove_-_I2C_Touch_Sensor
-   * @con i2c
-   * @kit tsk
-   *
-   * @brief API for the MPR121 I2C Touch Sensor
-   *
-   * UPM module for the MPR121 touch sensor
-   *
-   * @image html mpr121.jpg
-   * @snippet mpr121.cxx Interesting
-   */
-  class MPR121 {
-  public:
-    /**
-     * MPR121 constructor
-     *
-     * @param bus I2C bus to use
-     */
-    MPR121(int bus, uint8_t address = MPR121_DEFAULT_I2C_ADDR);
-
-    /**
-     * MPR121 destructor
-     * ~MPR121();
-     * there is no need for the destructor
-     **/
-
-    /**
-     * Sets up a default configuration, based on Application Note 3944
-     * (AN3944):
-     * http://cache.freescale.com/files/sensors/doc/app_note/AN3944.pdf
-     *
-     * After configuration, the sensor is left in the run state.
-     *
-     * @return True if configuration is successful
-     */
-    bool configAN3944();
-
-    /**
-     * Reads button states in the m_buttonStates member variable. Also,
-     * sets the m_overCurrentFault variable if overcurrent is detected.
-     */
-    void readButtons();
-
-    /**
-     * Writes value(s) into registers
-     *
-     * @param reg Register location to start writing into
-     * @param buffer Buffer for data storage
-     * @param len Number of bytes to write
-     * @return mraa::Result
-     */
-    mraa::Result writeBytes(uint8_t reg, uint8_t *buffer, int len);
-
-    /**
-     * Reads value(s) from registers
-     *
-     * @param reg Register location to start reading from
-     * @param buffer Buffer for data storage
-     * @param len Number of bytes to read
-     */
-    int readBytes(uint8_t reg, uint8_t *buffer, int len);
-
-    /**
-     * Button states
-     */
-    uint16_t m_buttonStates;
-
-    /**
-     * Overcurrent detected
-     */
-    bool m_overCurrentFault;
-
-  private:
-    mraa::I2c m_i2c;
-    uint8_t m_addr;
-  };
-}
-
-
diff --git a/src/mpr121/mpr121.i b/src/mpr121/mpr121.i
deleted file mode 100644
index 308cc5d..0000000
--- a/src/mpr121/mpr121.i
+++ /dev/null
@@ -1,17 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "arrays_java.i";
-%include "../java_buffer.i"
-
-JAVA_JNI_LOADLIBRARY(javaupm_mpr121)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "mpr121.hpp"
-%}
-%include "mpr121.hpp"
-/* END Common SWIG syntax */
diff --git a/src/mpr121/mpr121.json b/src/mpr121/mpr121.json
deleted file mode 100644
index 865e88e..0000000
--- a/src/mpr121/mpr121.json
+++ /dev/null
@@ -1,53 +0,0 @@
-{
-    "Library": "mpr121",
-    "Description": "Seeed/FreeScale MPR121 Touch Sensor library",
-    "Sensor Class": {
-        "MPR121": {
-            "Name": "Seeed/FreeScale MPR121 Touch Sensor",
-            "Description": "This is the UPM Module for the Seeed/FreeScale MPR121 Touch Sensor. The MPR121 is a capacitive touch sensor controller,features internal intelligence, include an hardware configurable I2C address, an expended filtering system with debounce, and completely independent electrodes with auto-configuration built in. Note: Each touch sensor comes with 4 \"feelers\" that act as capacitive pads for touch detection.",
-            "Aliases": ["mpr121", "Grove - I2C Touch Sensor"],
-            "Categories": ["touch"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping"],
-            "Manufacturers": ["Seeed", "FreeScale"],
-            "Kits": ["tsk"],
-            "Image": "mpr121.jpg",
-            "Examples": {
-                "Java": ["MPR121_Example.java"],
-                "Python": ["mpr121.py"],
-                "Node.js": ["mpr121.js"],
-                "C++": ["mpr121.cxx"],
-                "C": ["mpr121.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.3,
-                    "max": 5.0
-                },
-                "Supply Current": {
-                    "unit": "uA",
-                    "min" : "2",
-                    "max" : "29"
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need the Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need the Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-I2C-Touch-Sensor-p-840.html"],
-                "Datasheets": ["https://www.sparkfun.com/datasheets/Components/MPR121.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/mpr121/mpr121_fti.c b/src/mpr121/mpr121_fti.c
deleted file mode 100644
index d6fc7b4..0000000
--- a/src/mpr121/mpr121_fti.c
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "mpr121.h"
-#include "upm_fti.h"
-
-/** 
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_mpr121_name[] = "MPR121";
-const char upm_mpr121_description[] = "MPR121 Touch Sensor";
-const upm_protocol_t upm_mpr121_protocol[] = {UPM_I2C};
-const upm_sensor_t upm_mpr121_category[] = {UPM_SWITCH};
-
-// forward declarationss
-const upm_sensor_descriptor_t upm_mpr121_get_descriptor ();
-const void* upm_mpr121_get_ft(upm_sensor_t sensor_type);
-void* upm_mpr121_init_name();
-void upm_mpr121_close(void* dev);
-
-const upm_sensor_descriptor_t upm_mpr121_get_descriptor (){
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_mpr121_name;
-    usd.description = upm_mpr121_description;
-    usd.protocol_size = 1;
-    usd.protocol = upm_mpr121_protocol;
-    usd.category_size = 1;
-    usd.category = upm_mpr121_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = &upm_mpr121_init_name,
-    .upm_sensor_close = &upm_mpr121_close,
-    .upm_sensor_get_descriptor = &upm_mpr121_get_descriptor
-};
-
-const void* upm_mpr121_get_ft(upm_sensor_t sensor_type){
-    if(sensor_type == UPM_SENSOR){
-        return &ft;
-    }
-    return NULL;
-}
-
-void* upm_mpr121_init_name(){
-    return NULL;
-}
-
-void upm_mpr121_close(void* dev){
-    mpr121_close((mpr121_context)dev);
-}
diff --git a/src/mpu9150/CMakeLists.txt b/src/mpu9150/CMakeLists.txt
deleted file mode 100644
index 7388344..0000000
--- a/src/mpu9150/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "mpu9150")
-set (libdescription "IMU Sensor Library Based On the Mpu9150")
-set (module_src ${libname}.cxx ak8975.cxx mpu60x0.cxx mpu9250.cxx)
-set (module_hpp ${libname}.hpp ak8975.hpp mpu60x0.hpp mpu9250.hpp)
-upm_module_init(mraa)
diff --git a/src/mpu9150/ak8975.cxx b/src/mpu9150/ak8975.cxx
deleted file mode 100644
index 83c80aa..0000000
--- a/src/mpu9150/ak8975.cxx
+++ /dev/null
@@ -1,239 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "ak8975.hpp"
-
-using namespace upm;
-using namespace std;
-
-
-AK8975::AK8975(int bus, uint8_t address):
-  m_i2c(bus)
-{
-  m_addr = address;
-  m_xCoeff = 0.0;
-  m_yCoeff = 0.0;
-  m_zCoeff = 0.0;
-
-  mraa::Result rv;
-  if ( (rv = m_i2c.address(m_addr)) != mraa::SUCCESS)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": I2c.address() failed");
-      return;
-    }
-}
-
-AK8975::~AK8975()
-{
-}
-
-bool AK8975::init()
-{
-  // we put the device in 'fuse mode', and then read the compensation
-  // coefficients and store them.
-
-  // first, set power down mode
-
-  if (!setMode(CNTL_PWRDWN))
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": Unable to set PWRDWN mode");
-      return false;
-    }
-
-  if (!setMode(CNTL_FUSE_ACCESS))
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": Unable to set FUSE mode");
-      return false;
-    }
-
-  // Read each byte and store
-  m_xCoeff = (float)m_i2c.readReg(REG_ASAX);
-  m_yCoeff = (float)m_i2c.readReg(REG_ASAY);
-  m_zCoeff = (float)m_i2c.readReg(REG_ASAZ);
-
-  // now, place back in power down mode
-  if (!setMode(CNTL_PWRDWN))
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": Unable to set reset PWRDWN mode");
-      return false;
-    }
-
-  return true;
-}
-
-bool AK8975::setMode(CNTL_MODES_T mode)
-{
-  mraa::Result rv;
-  if ((rv = m_i2c.writeReg(REG_CNTL, mode)) != mraa::SUCCESS)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": I2c.writeReg() failed");
-      return false;
-    } 
-
-  // sleep at least 100us for for mode transition to complete
-  usleep(150);
-
-  return true;
-}
-
-bool AK8975::isReady()
-{
-  uint8_t rdy = m_i2c.readReg(REG_ST1);
-  
-  if (rdy & ST1_DRDY)
-    return true;
-
-  return false;
-}
-
-bool AK8975::waitforDeviceReady()
-{
-  const int maxRetries = 20;
-
-  int retries = 0;
-
-  while (retries < maxRetries)
-    {
-      if (isReady())
-        return true;
-
-      usleep(5000);
-      retries++;
-    }
-  
-  throw std::runtime_error(std::string(__FUNCTION__) +
-                           ": timeout waiting for device to become ready");
-
-  return false;
-}
-
-bool AK8975::update(bool selfTest)
-{
-  // this flag (selfTest) is used so that we can read values without
-  // specifically taking a measurement.  For example, selfTest will
-  // pass true to this method so that the test results aren't
-  // overwritten by a measurement.
-  if (!selfTest)
-    {
-      // First set measurement mode (take a measurement)
-      if (!setMode(CNTL_MEASURE))
-        {
-          throw std::runtime_error(std::string(__FUNCTION__) +
-                                   ": Unable to set MEASURE mode");
-          return false;
-        }
-    }
-
-  if (!waitforDeviceReady())
-    return false;
-
-  // hope it worked.  Now read out the values and store them (uncompensated)
-  uint8_t data[6];
-  m_i2c.readBytesReg(REG_HXL, data, 6);
-
-  int16_t x, y, z;
-  x = ( (data[1] << 8) | data[0] );
-  y = ( (data[3] << 8) | data[2] );
-  z = ( (data[5] << 8) | data[4] );
-
-  m_xData = float(x);
-  m_yData = float(y);
-  m_zData = float(z);
-
-  return true;
-}
-
-bool AK8975::selfTest()
-{
-  mraa::Result rv;
-
-  // set power down first
-  if (!setMode(CNTL_PWRDWN))
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": Unable to set PWRDWN mode");
-      return false;
-    }
-
-  // enable self test bit
-  if ((rv = m_i2c.writeReg(REG_ASTC, ASTC_SELF)) != mraa::SUCCESS)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": failed to enable self test");
-      return false;
-    } 
-  
-  // now set self test mode
-  if (!setMode(CNTL_SELFTEST))
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": Unable to set SELFTEST mode");
-      return false;
-    }
-  
-  // now update current data (without enabling a measurement)
-  update(true);
-  
-  // Now, reset self test register
-  uint8_t reg = m_i2c.readReg(REG_ASTC);
-  reg &= ~ASTC_SELF;
-  if ((rv = m_i2c.writeReg(REG_ASTC, reg)) != mraa::SUCCESS)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": failed to disable self test");
-      return false;
-    } 
-
-  // after self-test measurement, device transitions to power down mode
-  return true;
-}
-
-float AK8975::adjustValue(float value, float adj)
-{
-  // apply the proper compensation to value.  This equation is taken
-  // from the AK8975 datasheet, section 8.3.11
-
-  return ( value * ((((adj - 128.0) * 0.5) / 128.0) + 1.0) );
-} 
-
-void AK8975::getMagnetometer(float *x, float *y, float *z)
-{
-  if (x)
-    *x = adjustValue(m_xData, m_xCoeff);
-  if (y)
-    *y = adjustValue(m_yData, m_yCoeff);
-  if (z)
-    *z = adjustValue(m_zData, m_zCoeff);
-}
-
diff --git a/src/mpu9150/ak8975.hpp b/src/mpu9150/ak8975.hpp
deleted file mode 100644
index fe0089f..0000000
--- a/src/mpu9150/ak8975.hpp
+++ /dev/null
@@ -1,235 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/common.hpp>
-#include <mraa/i2c.hpp>
-
-#define AK8975_I2C_BUS 0
-#define AK8975_DEFAULT_I2C_ADDR 0x0c
-
-namespace upm {
-
-  /**
-   * @library mpu9150
-   * @sensor ak8975
-   * @comname 3-axis Magnetometer
-   * @altname AK9875
-   * @type compass
-   * @man seeed
-   * @con i2c
-   * @web http://www.akm.com/akm/en/file/datasheet/AK8975.pdf
-   *
-   * @brief API for the AK8975 magnetometer
-   *
-   * This is a 3-axis magnetometer, which can be used alone, or
-   * coupled with another device (such as the mcu9150 9-axis motion
-   * sensor).
-   *
-   * @snippet mpu9150-ak8975.cxx Interesting
-   */
-  class AK8975 {
-  public:
-
-    /**
-     * AK8975 registers
-     */
-    typedef enum {
-      REG_WIA                   = 0x00, // device id
-
-      REG_INFO                  = 0x01, // undocumented (AK proprietary data)
-
-      REG_ST1                   = 0x02, // status 1
-
-      REG_HXL                   = 0x03, // magnetometer data, X axis low byte
-      REG_HXH                   = 0x04, // magnetometer data, X axis high byte
-      REG_HYL                   = 0x05,
-      REG_HYH                   = 0x06,
-      REG_HZL                   = 0x07,
-      REG_HZH                   = 0x08,
-
-      REG_ST2                   = 0x09, // status 2
-
-      REG_CNTL                  = 0x0a, // control
-
-      // REG_RSV 0x0b reserved
-
-      REG_ASTC                  = 0x0c, // self test (internal mag field)
-
-      // REG_TS1, REG_TS2 0x0d, 0x0e reserved/factory test
-
-      // REG_I2CDIS 0x0f, I2C disable.  Not a good idea to use or support.
-      //  write a 0x1b to disable i2c.  This requires a power cycle to undo.
-
-      // These registers hold factory calibrated co-efficients needed to
-      // properly compensate for production variations.  They can only be
-      // read when device is in fuse mode.  They are used to adjust the
-      // measured mag field values.
-      REG_ASAX                  = 0x10, // X calibration
-      REG_ASAY                  = 0x11,
-      REG_ASAZ                  = 0x12
-    } AK8975_REG_T;
-
-    /**
-     * ST1 bits
-     */
-    typedef enum {
-      ST1_DRDY                  = 0x01 // data ready bit
-    } ST1_BITS_T;
-
-    /**
-     * ST2 bits
-     */
-    typedef enum {
-      ST2_DERR                  = 0x04, // data error
-      ST2_HOFL                  = 0x08  // measurement overflow
-    } ST2_BITS_T;
-
-    /**
-     * CNTL register, operating mode values
-     */
-    typedef enum {
-      CNTL_PWRDWN               = 0x00, // power down
-      CNTL_MEASURE              = 0x01, // single measurement
-      CNTL_SELFTEST             = 0x08,
-      CNTL_FUSE_ACCESS          = 0x0f  // access fuse (coeff) registers
-    } CNTL_MODES_T;
-
-    /**
-     * ASTC (self test control) bits
-     */
-    typedef enum {
-      ASTC_SELF                 = 0x40 // enable self test
-    } ASTC_BITS_T;
-
-    /**
-     * ak8975 constructor
-     *
-     * @param bus i2c bus to use
-     * @param address the address for this device
-     */
-    AK8975(int bus=AK8975_I2C_BUS, uint8_t address=AK8975_DEFAULT_I2C_ADDR);
-
-    /**
-     * AK8975 Destructor
-     */
-    ~AK8975();
-
-    /**
-     * set up initial values and start operation
-     *
-     * @param dsr the data sampling rate: one of the DSR_BITS_T values
-     * @return true if successful
-     */
-    bool init();
-
-    /**
-     * put the chip into a specific mode
-     *
-     * @param mode one of the CNTL_MODES_T values
-     * @return true if successful
-     */
-    bool setMode(CNTL_MODES_T mode);
-
-    /**
-     * check to see if the ST1_DRDY bit is set, indicating the device
-     * can accept commands
-     *
-     * @return true if device is ready, false otherwise
-     */
-    bool isReady();
-
-    /**
-     * check to see if device is ready and sleep/retry if not.
-     * Returns once device indicates it's ready.
-     *
-     * @return true if device is ready, false if retries exhausted
-     */
-    bool waitforDeviceReady();
-
-    /**
-     * take a measurement
-     *
-     * @param selfTest true if we are running a self test, false
-     * (default) otherwise.
-     * @return true if successful, false otherwise
-     */
-    bool update(bool selfTest=false);
-
-    /**
-     * do a self test sequence.  When self test is executed, the
-     * device activates internal calibrated magnets, and measures
-     * them, updating the measurement registers.  Once complete, the
-     * data can be read as usual (getMagnetometer()) and the returned
-     * values compared against the following limits to determine
-     * correctness:
-     *
-     * -100 < X < +100; -100 < Y < +100; -1000 < Z < -300
-     *
-     * @return true if successful, false otherwise
-     */
-    bool selfTest();
-
-    /**
-     * return the compensated values for the x, y, and z axes.  The
-     * unit of measurement is in micro-teslas (uT).
-     *
-     * @param x pointer to returned X axis value
-     * @param y pointer to returned Y axis value
-     * @param z pointer to returned Z axis value
-     */
-    void getMagnetometer(float *x, float *y, float *z);
-
-
-  protected:
-    /**
-     * compute a compensated magnetometer axis value, based on the raw
-     * axis value and a per-device, per-axis adjustment coefficient
-     * that was read and stored at init() time.
-     *
-     * @param value the raw axis value to compensate
-     * @param adj the adjustment coefficient
-     * @return true if successful
-     */
-    float adjustValue(float value, float adj);
-
-    // compensation coefficients (factory set) for this device
-    float m_xCoeff;
-    float m_yCoeff;
-    float m_zCoeff;
-
-    // uncompensated magnetometer readings
-    float m_xData;
-    float m_yData;
-    float m_zData;
-
-  private:
-    mraa::I2c m_i2c;
-    uint8_t m_addr;
-
-  };
-}
-
-
diff --git a/src/mpu9150/mpu60x0.cxx b/src/mpu9150/mpu60x0.cxx
deleted file mode 100644
index 9ccde92..0000000
--- a/src/mpu9150/mpu60x0.cxx
+++ /dev/null
@@ -1,416 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <iostream>
-#include <string.h>
-
-#include "mpu60x0.hpp"
-
-using namespace upm;
-using namespace std;
-
-
-MPU60X0::MPU60X0(int bus, uint8_t address) :
-  m_i2c(bus), m_gpioIRQ(0)
-{
-  m_addr = address;
-
-  m_accelX = 0.0;
-  m_accelY = 0.0;
-  m_accelZ = 0.0;
-
-  m_gyroX = 0.0;
-  m_gyroY = 0.0;
-  m_gyroZ = 0.0;
-
-  m_temp = 0.0;
-
-  m_accelScale = 1.0;
-  m_gyroScale = 1.0;
-
-  mraa::Result rv;
-  if ( (rv = m_i2c.address(m_addr)) != mraa::SUCCESS)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": I2c.address() failed");
-      return;
-    }
-}
-
-MPU60X0::~MPU60X0()
-{
-  uninstallISR();
-}
-
-bool MPU60X0::init()
-{
-  // first, take the device out of sleep mode
-  if (!setSleep(false))
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": Unable to wake up device");
-      return false;
-    }
-
-  // set the clock source to use the gyroscope PLL rather than the
-  // internal clock for stability
-  if (!setClockSource(PLL_XG))
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": Unable to set clock source");
-      return false;
-    }
-
-  usleep(5000);
-
-  // enable temperature measurement (default on power up, but let's be sure)
-  enableTemperatureSensor(true);
-
-  // set the gyro and accel scale bits to reasonable values
-  setGyroscopeScale(FS_500);
-  setAccelerometerScale(AFS_2);
-
-  // enable the DLPF
-  setDigitalLowPassFilter(DLPF_94_98);
-
-  // let things stabilize...
-  usleep(100000);
-
-  return true;
-}
-
-
-void MPU60X0::update()
-{
-  // read all of the sensor registers - accel, gyro, and temp
-  uint8_t buffer[14];
-
-  memset(buffer, 0, 14);
-  readRegs(REG_ACCEL_XOUT_H, buffer, 14);
-
-  int16_t ax, ay, az;
-  int16_t temp;
-  int16_t gx, gy, gz;
-
-  ax =  ( (buffer[0] << 8) | buffer[1] );
-  ay =  ( (buffer[2] << 8) | buffer[3] );
-  az =  ( (buffer[4] << 8) | buffer[5] );
-
-  temp = ( (buffer[6] << 8) | buffer[7] );
-
-  gx =  ( (buffer[8] << 8) | buffer[9] );
-  gy =  ( (buffer[10] << 8) | buffer[11] );
-  gz =  ( (buffer[12] << 8) | buffer[13] );
-
-  // now stash them
-  m_accelX = float(ax);
-  m_accelY = float(ay);
-  m_accelZ = float(az);
-
-  m_temp = float(temp);
-
-  m_gyroX = float(gx);
-  m_gyroY = float(gy);
-  m_gyroZ = float(gz);
-}
-
-uint8_t MPU60X0::readReg(uint8_t reg)
-{
-  return m_i2c.readReg(reg);
-}
-
-void MPU60X0::readRegs(uint8_t reg, uint8_t *buffer, int len)
-{
-  m_i2c.readBytesReg(reg, buffer, len);
-}
-
-bool MPU60X0::writeReg(uint8_t reg, uint8_t val)
-{
-  mraa::Result rv;
-  if ((rv = m_i2c.writeReg(reg, val)) != mraa::SUCCESS)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": I2c.writeReg() failed");
-      return false;
-    }
-
-  return true;
-}
-
-bool MPU60X0::setSleep(bool enable)
-{
-  uint8_t reg = readReg(REG_PWR_MGMT_1);
-
-  if (enable)
-    reg |= PWR_SLEEP;
-  else
-    reg &= ~PWR_SLEEP;
-
-  return writeReg(REG_PWR_MGMT_1, reg);
-}
-
-bool MPU60X0::setClockSource(CLKSEL_T clk)
-{
-  uint8_t reg = readReg(REG_PWR_MGMT_1);
-
-  reg &= ~(_CLKSEL_MASK << _CLKSEL_SHIFT);
-
-  reg |= (clk << _CLKSEL_SHIFT);
-
-  return writeReg(REG_PWR_MGMT_1, reg);
-}
-
-bool MPU60X0::setGyroscopeScale(FS_SEL_T scale)
-{
-  uint8_t reg = readReg(REG_GYRO_CONFIG);
-
-  reg &= ~(_FS_SEL_MASK << _FS_SEL_SHIFT);
-
-  reg |= (scale << _FS_SEL_SHIFT);
-
-  if (!writeReg(REG_GYRO_CONFIG, reg))
-    {
-      return false;
-    }
-
-  // store scaling factor
-
-  switch (scale)
-    {
-    case FS_250:
-      m_gyroScale = 131.0;
-      break;
-
-    case FS_500:
-      m_gyroScale = 65.5;
-      break;
-
-    case FS_1000:
-      m_gyroScale = 32.8;
-      break;
-
-    case FS_2000:
-      m_gyroScale = 16.4;
-      break;
-
-    default: // should never occur, but...
-      m_gyroScale = 1.0;        // set a safe, though incorrect value
-      throw std::logic_error(string(__FUNCTION__) +
-                             ": internal error, unsupported scale");
-      break;
-    }
-
-  return true;
-}
-
-bool MPU60X0::setAccelerometerScale(AFS_SEL_T scale)
-{
-  uint8_t reg = readReg(REG_ACCEL_CONFIG);
-
-  reg &= ~(_AFS_SEL_MASK << _AFS_SEL_SHIFT);
-
-  reg |= (scale << _AFS_SEL_SHIFT);
-
-  if (!writeReg(REG_ACCEL_CONFIG, reg))
-    {
-      return false;
-    }
-
-  // store scaling factor
-
-  switch (scale)
-    {
-    case AFS_2:
-      m_accelScale = 16384.0;
-      break;
-
-    case AFS_4:
-      m_accelScale = 8192.0;
-      break;
-
-    case AFS_8:
-      m_accelScale = 4096.0;
-      break;
-
-    case AFS_16:
-      m_accelScale = 2048.0;
-      break;
-
-    default: // should never occur, but...
-      m_accelScale = 1.0;        // set a safe, though incorrect value
-      throw std::logic_error(string(__FUNCTION__) +
-                             ": internal error, unsupported scale");
-      break;
-    }
-
-  return true;
-}
-
-bool MPU60X0::setDigitalLowPassFilter(DLPF_CFG_T dlp)
-{
-  uint8_t reg = readReg(REG_CONFIG);
-
-  reg &= ~(_CONFIG_DLPF_MASK << _CONFIG_DLPF_SHIFT);
-
-  reg |= (dlp << _CONFIG_DLPF_SHIFT);
-
-  return writeReg(REG_CONFIG, reg);
-}
-
-bool MPU60X0::setSampleRateDivider(uint8_t div)
-{
-  return writeReg(REG_SMPLRT_DIV, div);
-}
-
-uint8_t MPU60X0::getSampleRateDivider()
-{
-  return readReg(REG_SMPLRT_DIV);
-}
-
-void MPU60X0::getAccelerometer(float *x, float *y, float *z)
-{
-  if (x)
-    *x = m_accelX / m_accelScale;
-
-  if (y)
-    *y = m_accelY / m_accelScale;
-
-  if (z)
-    *z = m_accelZ / m_accelScale;
-}
-
-void MPU60X0::getGyroscope(float *x, float *y, float *z)
-{
-  if (x)
-    *x = m_gyroX / m_gyroScale;
-
-  if (y)
-    *y = m_gyroY / m_gyroScale;
-
-  if (z)
-    *z = m_gyroZ / m_gyroScale;
-}
-
-float MPU60X0::getTemperature()
-{
-  // this equation is taken from the datasheet
-  return (m_temp / 340.0) + 36.53;
-}
-
-bool MPU60X0::enableTemperatureSensor(bool enable)
-{
-  uint8_t reg = readReg(REG_PWR_MGMT_1);
-
-  if (enable)
-    reg &= ~TEMP_DIS;
-  else
-    reg |= TEMP_DIS;
-
-  return writeReg(REG_PWR_MGMT_1, reg);
-}
-
-bool MPU60X0::setExternalSync(EXT_SYNC_SET_T val)
-{
-  uint8_t reg = readReg(REG_CONFIG);
-
-  reg &= ~(_CONFIG_EXT_SYNC_SET_MASK << _CONFIG_EXT_SYNC_SET_SHIFT);
-
-  reg |= (val << _CONFIG_EXT_SYNC_SET_SHIFT);
-
-  return writeReg(REG_CONFIG, reg);
-}
-
-bool MPU60X0::enableI2CBypass(bool enable)
-{
-  uint8_t reg = readReg(REG_INT_PIN_CFG);
-
-  if (enable)
-    reg |= I2C_BYPASS_ENABLE;
-  else
-    reg &= ~I2C_BYPASS_ENABLE;
-
-  return writeReg(REG_INT_PIN_CFG, reg);
-}
-
-bool MPU60X0::setMotionDetectionThreshold(uint8_t thr)
-{
-  return writeReg(REG_MOT_THR, thr);
-}
-
-uint8_t MPU60X0::getInterruptStatus()
-{
-  return readReg(REG_INT_STATUS);
-}
-
-bool MPU60X0::setInterruptEnables(uint8_t enables)
-{
-  return writeReg(REG_INT_ENABLE, enables);
-}
-
-uint8_t MPU60X0::getInterruptEnables()
-{
-  return readReg(REG_INT_ENABLE);
-}
-
-bool MPU60X0::setInterruptPinConfig(uint8_t cfg)
-{
-  return writeReg(REG_INT_PIN_CFG, cfg);
-}
-
-uint8_t MPU60X0::getInterruptPinConfig()
-{
-  return readReg(REG_INT_PIN_CFG);
-}
-
-
-void MPU60X0::installISR(int gpio, mraa::Edge level,
-                         void (*isr)(void *), void *arg)
-{
-  // delete any existing ISR and GPIO context
-  uninstallISR();
-
-  // greate gpio context
-  m_gpioIRQ = new mraa::Gpio(gpio);
-
-  m_gpioIRQ->dir(mraa::DIR_IN);
-  m_gpioIRQ->isr(level, isr, arg);
-}
-
-
-void MPU60X0::uninstallISR()
-{
-  if (m_gpioIRQ)
-    {
-      m_gpioIRQ->isrExit();
-      delete m_gpioIRQ;
-
-      m_gpioIRQ = 0;
-    }
-}
-
-  mraa::Gpio* MPU60X0::get_gpioIRQ()
-  {
-    return m_gpioIRQ;
-  }
diff --git a/src/mpu9150/mpu60x0.hpp b/src/mpu9150/mpu60x0.hpp
deleted file mode 100644
index 91d7aa0..0000000
--- a/src/mpu9150/mpu60x0.hpp
+++ /dev/null
@@ -1,943 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/common.hpp>
-#include <mraa/i2c.hpp>
-
-#include <mraa/gpio.hpp>
-
-#define MPU60X0_I2C_BUS 0
-#define MPU60X0_DEFAULT_I2C_ADDR 0x68
-
-namespace upm {
-
-  /**
-   * @library mpu9150
-   * @sensor mpu60x0
-   * @comname 3-axis Gyroscope and 3-axis Accelerometer
-   * @type accelerometer compass
-   * @man seeed
-   * @con i2c gpio
-   * @web https://www.invensense.com/products/motion-tracking/6-axis/mpu-6050/
-   *
-   * @brief API for the MPU60X0 3-axis Gyroscope and 3-axis Accelerometer
-   *
-   * The MPU60X0 devices provide the world's first integrated 6-axis
-   * motion processor solution that eliminates the package-level
-   * gyroscope and accelerometer cross-axis misalignment associated
-   * with discrete solutions. The devices combine a 3-axis gyroscope
-   * and a 3-axis accelerometer on the same silicon die.
-   *
-   * While not all of the functionality of this device is supported
-   * initially, methods and register definitions are provided that
-   * should allow an end user to implement whatever features are
-   * required.
-   *
-   * @image html mpu60x0.jpg
-   * @snippet mpu9150-mpu60x0.cxx Interesting
-   */
-  class MPU60X0 {
-  public:
-
-    // NOTE: These enums were composed from both the mpu6050 and
-    // mpu9150 register maps, since this driver was written using an
-    // mpu9150, but we'd like this module to be usable with a
-    // standalone mpu60x0.
-    //
-    // Registers and bitfields marked with an '*' in their
-    // comment indicate registers or bit fields present in the mpu9150
-    // register map, but not in the original mpu6050 register map.  If
-    // using this module on a standalone mpu6050, you should avoid
-    // using those registers or bitfields marked with an *.
-
-    /**
-     * MPU60X0 registers
-     */
-    typedef enum {
-      REG_SELF_TEST_X           = 0x0d,
-      REG_SELF_TEST_Y           = 0x0e,
-      REG_SELF_TEST_Z           = 0x0f,
-      REG_SELF_TEST_A           = 0x10,
-
-      REG_SMPLRT_DIV            = 0x19, // sample rate divider
-
-      REG_CONFIG                = 0x1a,
-      REG_GYRO_CONFIG           = 0x1b,
-      REG_ACCEL_CONFIG          = 0x1c,
-
-      REG_FF_THR                = 0x1d, // *freefall threshold
-      REG_FF_DUR                = 0x1e, // *freefall duration
-
-      REG_MOT_THR               = 0x1f, // motion threshold
-      REG_MOT_DUR               = 0x20, // *motion duration
-
-      REG_ZRMOT_THR             = 0x21, // *zero motion threshhold
-      REG_ZRMOT_DUR             = 0x22, // *zero motion duration
-
-      REG_FIFO_EN               = 0x23,
-
-      REG_I2C_MST_CTRL          = 0x24, // I2C master control
-
-      REG_I2C_SLV0_ADDR         = 0x25, // I2C slave 0
-      REG_I2C_SLV0_REG          = 0x26,
-      REG_I2C_SLV0_CTRL         = 0x27,
-
-      REG_I2C_SLV1_ADDR         = 0x28, // I2C slave 1
-      REG_I2C_SLV1_REG          = 0x29,
-      REG_I2C_SLV1_CTRL         = 0x2a,
-
-      REG_I2C_SLV2_ADDR         = 0x2b, // I2C slave 2
-      REG_I2C_SLV2_REG          = 0x2c,
-      REG_I2C_SLV2_CTRL         = 0x2d,
-
-      REG_I2C_SLV3_ADDR         = 0x2e, // I2C slave 3
-      REG_I2C_SLV3_REG          = 0x2f,
-      REG_I2C_SLV3_CTRL         = 0x30,
-
-      REG_I2C_SLV4_ADDR         = 0x31, // I2C slave 4
-      REG_I2C_SLV4_REG          = 0x32,
-      REG_I2C_SLV4_DO           = 0x33,
-      REG_I2C_SLV4_CTRL         = 0x34,
-      REG_I2C_SLV4_DI           = 0x35,
-
-      REG_I2C_MST_STATUS        = 0x36, // I2C master status
-
-      REG_INT_PIN_CFG           = 0x37, // interrupt pin config/i2c bypass
-      REG_INT_ENABLE            = 0x38,
-
-      // 0x39 reserved
-
-      REG_INT_STATUS            = 0x3a, // interrupt status
-
-      REG_ACCEL_XOUT_H          = 0x3b, // accelerometer outputs
-      REG_ACCEL_XOUT_L          = 0x3c,
-
-      REG_ACCEL_YOUT_H          = 0x3d,
-      REG_ACCEL_YOUT_L          = 0x3e,
-
-      REG_ACCEL_ZOUT_H          = 0x3f,
-      REG_ACCEL_ZOUT_L          = 0x40,
-
-      REG_TEMP_OUT_H            = 0x41, // temperature output
-      REG_TEMP_OUT_L            = 0x42,
-
-      REG_GYRO_XOUT_H           = 0x43, // gyro outputs
-      REG_GYRO_XOUT_L           = 0x44,
-
-      REG_GYRO_YOUT_H           = 0x45,
-      REG_GYRO_YOUT_L           = 0x46,
-
-      REG_GYRO_ZOUT_H           = 0x47,
-      REG_GYRO_ZOUT_L           = 0x48,
-
-      REG_EXT_SENS_DATA_00      = 0x49, // external sensor data
-      REG_EXT_SENS_DATA_01      = 0x4a,
-      REG_EXT_SENS_DATA_02      = 0x4b,
-      REG_EXT_SENS_DATA_03      = 0x4c,
-      REG_EXT_SENS_DATA_04      = 0x4d,
-      REG_EXT_SENS_DATA_05      = 0x4e,
-      REG_EXT_SENS_DATA_06      = 0x4f,
-      REG_EXT_SENS_DATA_07      = 0x50,
-      REG_EXT_SENS_DATA_08      = 0x51,
-      REG_EXT_SENS_DATA_09      = 0x52,
-      REG_EXT_SENS_DATA_10      = 0x53,
-      REG_EXT_SENS_DATA_11      = 0x54,
-      REG_EXT_SENS_DATA_12      = 0x55,
-      REG_EXT_SENS_DATA_13      = 0x56,
-      REG_EXT_SENS_DATA_14      = 0x57,
-      REG_EXT_SENS_DATA_15      = 0x58,
-      REG_EXT_SENS_DATA_16      = 0x59,
-      REG_EXT_SENS_DATA_17      = 0x5a,
-      REG_EXT_SENS_DATA_18      = 0x5b,
-      REG_EXT_SENS_DATA_19      = 0x5c,
-      REG_EXT_SENS_DATA_20      = 0x5d,
-      REG_EXT_SENS_DATA_21      = 0x5e,
-      REG_EXT_SENS_DATA_22      = 0x5f,
-      REG_EXT_SENS_DATA_23      = 0x60,
-
-      REG_MOT_DETECT_STATUS     = 0x61, // *
-
-      // 0x62 reserved
-
-      REG_I2C_SLV0_DO           = 0x63, // I2C slave data outs
-      REG_I2C_SLV1_DO           = 0x64,
-      REG_I2C_SLV2_DO           = 0x65,
-      REG_I2C_SLV3_DO           = 0x66,
-
-      REG_I2C_MST_DELAY_CTRL    = 0x67,
-
-      REG_SIGNAL_PATH_RESET     = 0x68, // signal path resets
-
-      REG_MOT_DETECT_CTRL       = 0x69,
-
-      REG_USER_CTRL             = 0x6a,
-
-      REG_PWR_MGMT_1            = 0x6b, // power management
-      REG_PWR_MGMT_2            = 0x6c,
-
-      // 0x6d-0x71 reserved
-
-      REG_FIFO_COUNTH           = 0x72,
-      REG_FIFO_COUNTL           = 0x73,
-
-      REG_FIFO_R_W              = 0x74,
-
-      REG_WHO_AM_I              = 0x75
-    } MPU60X0_REG_T;
-
-    /**
-     * CONFIG bits
-     */
-    typedef enum {
-      CONFIG_DLPF_CFG0            = 0x01, // digital low-pass filter config
-      CONFIG_DLPF_CFG1            = 0x02,
-      CONFIG_DLPF_CFG2            = 0x04,
-      _CONFIG_DLPF_SHIFT          = 0,
-      _CONFIG_DLPF_MASK           = 7,
-
-      CONFIG_EXT_SYNC_SET0        = 0x08, // FSYNC pin config
-      CONFIG_EXT_SYNC_SET1        = 0x10,
-      CONFIG_EXT_SYNC_SET2        = 0x20,
-      _CONFIG_EXT_SYNC_SET_SHIFT  = 3,
-      _CONFIG_EXT_SYNC_SET_MASK   = 7
-    } CONFIG_BITS_T;
-
-    /**
-     * CONFIG DLPF_CFG values
-     */
-    typedef enum {
-      DLPF_260_256                = 0, // accel/gyro bandwidth (Hz)
-      DLPF_184_188                = 1,
-      DLPF_94_98                  = 2,
-      DLPF_44_42                  = 3,
-      DLPF_21_20                  = 4,
-      DLPF_10_10                  = 5,
-      DLPF_5_5                    = 6,
-      DLPF_RESERVED               = 7
-    } DLPF_CFG_T;
-
-    /**
-     * CONFIG EXT_SYNC_SET values
-     */
-    typedef enum {
-      EXT_SYNC_DISABLED           = 0,
-      EXT_SYNC_TEMP_OUT           = 1,
-      EXT_SYNC_GYRO_XOUT          = 2,
-      EXT_SYNC_GYRO_YOUT          = 3,
-      EXT_SYNC_GYRO_ZOUT          = 4,
-      EXT_SYNC_ACCEL_XOUT         = 5,
-      EXT_SYNC_ACCEL_YOUT         = 6,
-      EXT_SYNC_ACCEL_ZOUT         = 7
-    } EXT_SYNC_SET_T;
-
-    /**
-     * GYRO_CONFIG bits
-     */
-    typedef enum {
-      // 0x01-0x04 reserved
-      FS_SEL0                          = 0x08, // gyro full scale range
-      FS_SEL1                          = 0x10,
-      _FS_SEL_SHIFT                    = 3,
-      _FS_SEL_MASK                     = 3,
-
-      ZG_ST                            = 0x20, // gyro self test bits
-      YG_ST                            = 0x40,
-      XG_ST                            = 0x80
-    } GRYO_CONFIG_BITS_T;
-
-    /**
-     * GYRO FS_SEL values
-     */
-    typedef enum {
-      FS_250                           = 0, // 250 deg/s, 131 LSB deg/s
-      FS_500                           = 1, // 500 deg/s, 65.5 LSB deg/s
-      FS_1000                          = 2, // 1000 deg/s, 32.8 LSB deg/s
-      FS_2000                          = 3  // 2000 deg/s, 16.4 LSB deg/s
-    } FS_SEL_T;
-
-    /**
-     * ACCEL_CONFIG bits
-     */
-    typedef enum {
-      // 0x01-0x04 reserved
-      AFS_SEL0                         = 0x08, // accel full scale range
-      AFS_SEL1                         = 0x10,
-      _AFS_SEL_SHIFT                   = 3,
-      _AFS_SEL_MASK                    = 3,
-
-      ZA_ST                            = 0x20, // gyro self test bits
-      YA_ST                            = 0x40,
-      XA_ST                            = 0x80
-    } ACCEL_CONFIG_BITS_T;
-
-    /**
-     * ACCEL AFS_SEL (full scaling) values
-     */
-    typedef enum {
-      AFS_2                            = 0, // 2g, 16384 LSB/g
-      AFS_4                            = 1, // 4g, 8192 LSB/g
-      AFS_8                            = 2, // 8g, 4096 LSB/g
-      AFS_16                           = 3  // 16g, 2048 LSB/g
-    } AFS_SEL_T;
-
-    /**
-     * REG_FIFO_EN bits
-     */
-    typedef enum {
-      SLV0_FIFO_EN                     = 0x01,
-      SLV1_FIFO_EN                     = 0x02,
-      SLV2_FIFO_EN                     = 0x04,
-
-      ACCEL_FIFO_EN                    = 0x08,
-
-      ZG_FIFO_EN                       = 0x10,
-      YG_FIFO_EN                       = 0x20,
-      XG_FIFO_EN                       = 0x40,
-
-      TEMP_FIFO_EN                     = 0x80
-    } FIFO_EN_BITS_T;
-
-    /**
-     * REG_I2C_MST_CTRL bits
-     */
-    typedef enum {
-      I2C_MST_CLK0                     = 0x01,
-      I2C_MST_CLK1                     = 0x02,
-      I2C_MST_CLK2                     = 0x04,
-      I2C_MST_CLK3                     = 0x08,
-      _I2C_MST_CLK_SHIFT               = 0,
-      _I2C_MST_CLK_MASK                = 15,
-
-      I2C_MST_P_NSR                    = 0x10,
-
-      SLV_3_FIFO_EN                    = 0x20,
-
-      WAIT_FOR_ES                      = 0x40,
-
-      MULT_MST_EN                      = 0x80
-    } I2C_MST_CTRL_BITS_T;
-
-    /**
-     * I2C_MST_CLK values
-     */
-    typedef enum {
-      MST_CLK_348                      = 0, // 348Khz
-      MST_CLK_333                      = 1,
-      MST_CLK_320                      = 2,
-      MST_CLK_308                      = 3,
-      MST_CLK_296                      = 4,
-      MST_CLK_286                      = 5,
-      MST_CLK_276                      = 6,
-      MST_CLK_267                      = 7,
-      MST_CLK_258                      = 8,
-      MST_CLK_500                      = 9,
-      MST_CLK_471                      = 10,
-      MST_CLK_444                      = 11,
-      MST_CLK_421                      = 12,
-      MST_CLK_400                      = 13,
-      MST_CLK_381                      = 14,
-      MST_CLK_364                      = 15
-    } I2C_MST_CLK_T;
-
-    /**
-     * REG_I2C SLV0-SLV4 _ADDR bits
-     */
-    typedef enum {
-      I2C_SLV_ADDR0                    = 0x01,
-      I2C_SLV_ADDR1                    = 0x02,
-      I2C_SLV_ADDR2                    = 0x04,
-      I2C_SLV_ADDR3                    = 0x08,
-      I2C_SLV_ADDR4                    = 0x10,
-      I2C_SLV_ADDR5                    = 0x20,
-      I2C_SLV_ADDR6                    = 0x40,
-      _I2C_SLV_ADDR_SHIFT              = 0,
-      _I2C_SLV_ADDR_MASK               = 127,
-
-      I2C_SLV_RW                       = 0x80
-    } I2C_SLV_ADDR_BITS_T;
-
-    /**
-     * REG_I2C SLV0-SLV3 _CTRL bits
-     */
-    typedef enum {
-      I2C_SLV_LEN0                     = 0x01,
-      I2C_SLV_LEN1                     = 0x02,
-      I2C_SLV_LEN2                     = 0x04,
-      I2C_SLV_LEN3                     = 0x08,
-      _I2C_SLV_LEN_SHIFT               = 0,
-      _I2C_SLV_LEN_MASK                = 15,
-
-      I2C_SLV_GRP                      = 0x10,
-      I2C_SLV_REG_DIS                  = 0x20,
-      I2C_SLV_BYTE_SW                  = 0x40,
-      I2C_SLV_EN                       = 0x80
-    } I2C_SLV_CTRL_BITS_T;
-
-    /**
-     * REG_I2C_SLV4_CTRL bits, these are different from the SLV0-SLV3
-     * CRTL bits.
-     *
-     * MST_DLY is not enumerated in the register map.  It configures
-     * the reduced access rate of i2c slaves relative to the sample
-     * rate. When a slave's access rate is decreased relative to the
-     * Sample Rate, the slave is accessed every
-     * 1 / (1 + I2C_MST_DLY) samples
-     */
-    typedef enum {
-      I2C_MST_DLY0                     = 0x01,
-      I2C_MST_DLY1                     = 0x02,
-      I2C_MST_DLY2                     = 0x04,
-      I2C_MST_DLY3                     = 0x08,
-      I2C_MST_DLY4                     = 0x10,
-      _I2C_MST_DLY_SHIFT               = 0,
-      _I2C_MST_DLY_MASK                = 31,
-
-      I2C_SLV4_REG_DIS                 = 0x20,
-      I2C_SLV4_INT_EN                  = 0x40,
-      I2C_SLV4_EN                      = 0x80
-    } I2C_SLV4_CTRL_BITS_T;
-
-    /**
-     * REG_I2C_MST_STATUS bits
-     */
-    typedef enum {
-      I2C_SLV0_NACK                    = 0x01,
-      I2C_SLV1_NACK                    = 0x02,
-      I2C_SLV2_NACK                    = 0x04,
-      I2C_SLV3_NACK                    = 0x08,
-      I2C_SLV4_NACK                    = 0x10,
-
-      I2C_LOST_ARB                     = 0x20,
-      I2C_SLV4_DONE                    = 0x40,
-      PASS_THROUGH                     = 0x80
-    } I2C_MST_STATUS_BITS_T;
-
-    /**
-     * REG_INT_PIN_CFG bits
-     */
-    typedef enum {
-      CLKOUT_EN                        = 0x01, // *
-
-      I2C_BYPASS_ENABLE                = 0x02,
-
-      FSYNC_INT_EN                     = 0x04,
-      FSYNC_INT_LEVEL                  = 0x08,
-
-      INT_RD_CLEAR                     = 0x10,
-
-      LATCH_INT_EN                     = 0x20,
-
-      INT_OPEN                         = 0x40,
-      INT_LEVEL                        = 0x80
-    } INT_PIN_CFG_BITS_T;
-
-    /**
-     * REG_INT_ENABLE bits
-     */
-    typedef enum {
-      DATA_RDY_EN                      = 0x01, // *
-
-      // 0x02, 0x04 reserved
-
-      I2C_MST_INT_EN                   = 0x08,
-
-      FIFO_OFLOW_EN                    = 0x10,
-
-      ZMOT_EN                          = 0x20, // *zero motion
-      MOT_EN                           = 0x40,
-      FF_EN                            = 0x80  // *freefall
-    } INT_ENABLE_BITS_T;
-
-    /**
-     * REG_INT_STATUS bits
-     */
-    typedef enum {
-      DATA_RDY_INT                     = 0x01,
-
-      // 0x02, 0x04 reserved
-
-      I2C_MST_INT                      = 0x08,
-
-      FIFO_OFLOW_INT                   = 0x10,
-
-      ZMOT_INT                         = 0x20, // *zero motion
-      MOT_INT                          = 0x40,
-      FF_INT                           = 0x80  // *freefall
-    } INT_STATUS_BITS_T;
-
-    /**
-     * REG_MOT_DETECT_STATUS bits (mpu9150 only)
-     */
-    typedef enum {
-      MOT_ZRMOT                        = 0x01, // *
-
-      // 0x02 reserved
-
-      MOT_ZPOS                         = 0x04, // *
-      MOT_ZNEG                         = 0x08, // *
-
-      MOT_YPOS                         = 0x10, // *
-      MOT_YNEG                         = 0x20, // *
-
-      MOT_XPOS                         = 0x40, // *
-      MOT_XNEG                         = 0x80, // *
-    } MOT_DETECT_STATUS_BITS_T;
-
-    /**
-     * REG_MST_DELAY_CTRL bits
-     */
-    typedef enum {
-      I2C_SLV0_DLY_EN                  = 0x01,
-      I2C_SLV1_DLY_EN                  = 0x02,
-      I2C_SLV2_DLY_EN                  = 0x04,
-      I2C_SLV3_DLY_EN                  = 0x08,
-      I2C_SLV4_DLY_EN                  = 0x10,
-
-      // 0x20, 0x40, reserved
-
-      DELAY_ES_SHADOW                  = 0x80
-    } MST_DELAY_CTRL_BITS_T;
-
-    /**
-     * REG_SIGNAL_PATH_RESET bits
-     */
-    typedef enum {
-      TEMP_RESET                       = 0x01,
-      ACCEL_RESET                      = 0x02,
-      GYRO_RESET                       = 0x04
-
-      // 0x08-0x80 reserved
-    } SIGNAL_PATH_RESET_BITS_T;
-
-    /**
-     * REG_MOT_DETECT_CTRL bits
-     */
-    typedef enum {
-      MOT_COUNT0                       = 0x01, // *
-      MOT_COUNT1                       = 0x02, // *
-      _MOT_COUNT_SHIFT                 = 0,
-      _MOT_COUNT_MASK                  = 3,
-
-      FF_COUNT0                        = 0x04, // *
-      FF_COUNT1                        = 0x08, // *
-      _FF_COUNT_SHIFT                  = 2,
-      _FF_COUNT_MASK                   = 3,
-
-      ACCEL_ON_DELAY0                  = 0x10,
-      ACCEL_ON_DELAY1                  = 0x20,
-      _ACCEL_ON_DELAY_SHIFT            = 4,
-      _ACCEL_ON_DELAY_MASK             = 3
-      // 0x40,0x80 reserved
-    } MOT_DETECT_CTRL_BITS_T;
-
-    /**
-     * MOT_COUNT or FF_COUNT values (mpu9150 only)
-     */
-    typedef enum {
-      COUNT_0                          = 0, // Reset
-      COUNT_1                          = 1, // counter decrement 1
-      COUNT_2                          = 2, // counter decrement 2
-      COUNT_4                          = 3  // counter decrement 4
-    } MOT_FF_COUNT_T;
-
-    /**
-     * ACCEL_ON_DELAY values
-     */
-    typedef enum {
-      ON_DELAY_0                       = 0, // no delay
-      ON_DELAY_1                       = 1, // add 1ms
-      ON_DELAY_2                       = 2, // add 2ms
-      ON_DELAY_3                       = 3  // add 3ms
-    } ACCEL_ON_DELAY_T;
-
-    /**
-     * REG_USER_CTRL bits
-     */
-    typedef enum {
-      SIG_COND_RESET                   = 0x01,
-      I2C_MST_RESET                    = 0x02,
-      FIFO_RESET                       = 0x04,
-
-      // 0x08 reserved
-
-      I2C_IF_DIS                       = 0x10,
-      I2C_MST_EN                       = 0x20,
-      FIFO_EN                          = 0x40
-
-      /// 0x80 reserved
-    } USER_CTRL_BITS_T;
-
-    /**
-     * REG_PWR_MGMT_1 bits
-     */
-    typedef enum {
-      CLKSEL0                          = 0x01,
-      CLKSEL1                          = 0x02,
-      CLKSEL2                          = 0x04,
-      _CLKSEL_SHIFT                    = 0,
-      _CLKSEL_MASK                     = 7,
-
-      TEMP_DIS                         = 0x08,
-
-      // 0x10 reserved
-
-      PWR_CYCLE                        = 0x20,
-      PWR_SLEEP                        = 0x40,
-      DEVICE_RESET                     = 0x80
-    } PWR_MGMT_1_BITS_T;
-
-    /**
-     * CLKSEL values
-     */
-    typedef enum {
-      INT_8MHZ                         = 0, // internal 8Mhz osc
-      PLL_XG                           = 1, // PLL X axis gyro
-      PLL_YG                           = 2, // PLL Y axis gyro
-      PLL_ZG                           = 3, // PLL Z axis gyro
-      PLL_EXT_32KHZ                    = 4, // PLL with external 32.768Khz ref
-      PLL_EXT_19MHZ                    = 5, // PLL with external 19.2Mhz ref
-      // 6 - reserved
-      CLK_STOP                         = 7  // stops clk
-    } CLKSEL_T;
-
-    /**
-     * REG_PWR_MGMT_2 bits
-     */
-    typedef enum {
-      STBY_ZG                          = 0x01,
-      STBY_YG                          = 0x02,
-      STBY_XG                          = 0x04,
-      STBY_ZA                          = 0x08,
-      STBY_YA                          = 0x10,
-      STBY_XA                          = 0x20,
-
-      LP_WAKE_CTRL0                    = 0x40,
-      LP_WAKE_CTRL1                    = 0x80,
-      _LP_WAKE_CTRL_SHIFT              = 6,
-      _LP_WAKE_CTRL_MASK               = 3
-    } PWR_MGMT_2_BITS_T;
-
-    /**
-     * LP_WAKE_CTRL values
-     */
-    typedef enum {
-      LP_WAKE_1_25                     = 0, // wakeup feq: 1.25hz
-      LP_WAKE_5                        = 1, // 5hz
-      LP_WAKE_20                       = 2, // 20hz
-      LP_WAKE_40                       = 3, // 40hz
-    } LP_WAKE_CRTL_T;
-
-
-    /**
-     * mpu60x0 constructor
-     *
-     * @param bus i2c bus to use
-     * @param address the address for this device
-     */
-    MPU60X0(int bus=MPU60X0_I2C_BUS, uint8_t address=MPU60X0_DEFAULT_I2C_ADDR);
-
-    /**
-     * MPU60X0 Destructor
-     */
-    virtual ~MPU60X0();
-
-    /**
-     * set up initial values and start operation
-     *
-     * @return true if successful
-     */
-    bool init();
-
-    /**
-     * take a measurement and store the current sensor values
-     * internally.  Note, these user facing registers are only updated
-     * from the internal device sensor values when the i2c serial
-     * traffic is 'idle'.  So, if you are reading the values too fast,
-     * the bus may never be idle, and you will just end up reading
-     * the same values over and over.
-     *
-     * Unfortunately, it is is not clear how long 'idle' actually
-     * means, so if you see this behavior, reduce the rate at which
-     * you are calling update().
-     *
-     */
-    void update();
-
-    /**
-     * read a register
-     *
-     * @param reg the register to read
-     * @return the value of the register
-     */
-    uint8_t readReg(uint8_t reg);
-
-    /**
-     * read contiguous refister into a buffer
-     *
-     * @param reg the register to start reading at
-     * @param buffer the buffer to store the results
-     * @param len the number of registers to read
-     * @return the value of the register
-     */
-    void readRegs(uint8_t reg, uint8_t *buffer, int len);
-
-    /**
-     * write to a register
-     *
-     * @param reg the register to write to
-     * @param val the value to write
-     * @return true if successful, false otherwise
-     */
-    bool writeReg(uint8_t reg, uint8_t val);
-
-    /**
-     * enable or disable device sleep
-     *
-     * @param enable true to put device to sleep, false to wake up
-     * @return true if successful, false otherwise
-     */
-    bool setSleep(bool enable);
-
-    /**
-     * specify the clock source for the device to use
-     *
-     * @param clk one of the CLKSEL_T values
-     * @return true if successful, false otherwise
-     */
-    bool setClockSource(CLKSEL_T clk);
-
-    /**
-     * set the scaling mode of the gyroscope
-     *
-     * @param scale one of the FS_SEL_T values
-     * @return true if successful, false otherwise
-     */
-    bool setGyroscopeScale(FS_SEL_T scale);
-
-    /**
-     * set the scaling mode of the accelerometer
-     *
-     * @param scale one of the AFS_SEL_T values
-     * @return true if successful, false otherwise
-     */
-    bool setAccelerometerScale(AFS_SEL_T scale);
-
-    /**
-     * set the Low Pass Digital filter.  This enables filtering (if
-     * non-0) of the accelerometer and gyro outputs.
-     *
-     * @param dlp one of the DLPF_CFG_T values
-     * @return true if successful, false otherwise
-     */
-    bool setDigitalLowPassFilter(DLPF_CFG_T dlp);
-
-    /**
-     * set the sample rate divider.  This register specifies the
-     * divider from the gyro output rate used to generate the Sample
-     * Rate.  The sensor registor output, FIFO output, DMP sampling
-     * and motion detection are all based on the Sample Rate.
-     *
-     * The Sample Rate is generated by dividing the gyro output rate
-     * by this register:
-     *
-     * Sample Rate = Gyro output rate / (1 + sample rate divider).
-     *
-     * The Gyro output rate is 8Khz when the Digital Low Pass Filter
-     * (DLPF) is 0 or 7 (DLPF_260_256 or DLPF_RESERVED), and 1Khz
-     * otherwise.
-     *
-     * @param div one of the DLPF_CFG_T values
-     * @return true if successful, false otherwise
-     */
-    bool setSampleRateDivider(uint8_t div);
-
-    /**
-     * get the current Sample Rate divider
-     *
-     * @return the current sample rate divider
-     */
-    uint8_t getSampleRateDivider();
-
-    /**
-     * get the accelerometer values
-     *
-     * @param x the returned x value, if arg is non-NULL
-     * @param y the returned y value, if arg is non-NULL
-     * @param z the returned z value, if arg is non-NULL
-     * @return true if successful, false otherwise
-     */
-    void getAccelerometer(float *x, float *y, float *z);
-
-    /**
-     * get the gyroscope values
-     *
-     * @param x the returned x value, if arg is non-NULL
-     * @param y the returned y value, if arg is non-NULL
-     * @param z the returned z value, if arg is non-NULL
-     * @return true if successful, false otherwise
-     */
-    void getGyroscope(float *x, float *y, float *z);
-
-    /**
-     * get the temperature value
-     *
-     * @return the temperature value in degrees Celsius
-     */
-    virtual float getTemperature();
-
-    /**
-     * enable onboard temperature measurement sensor
-     *
-     * @param enable true to enable temperature sensor, false to disable
-     * @return true if successful, false otherwise
-     */
-    bool enableTemperatureSensor(bool enable);
-
-    /**
-     * configure external sync.  An external signal connected to the
-     * FSYNC pin can be sampled by configuring EXT_SYNC_SET.  Signal
-     * changes to the FSYNC pin are latched so that short strobes may
-     * be captured. The latched FSYNC signal will be sampled at the
-     * Sampling Rate, as defined in register 25. After sampling, the
-     * latch will reset to the current FSYNC signal state.
-     *
-     * The sampled value will be reported in place of the least
-     * significant bit in a sensor data register determined by the
-     * value of EXT_SYNC_SET
-     *
-     * @param val one of the EXT_SYNC_SET_T values
-     * @return true if successful, false otherwise
-     */
-    bool setExternalSync(EXT_SYNC_SET_T val);
-
-    /**
-     * enable I2C Bypass.  Enabling this feature allows devices on the
-     * MPU60X0 auxiliary I2C bus to be visible on the MCU's I2C bus.
-     *
-     * @param enable true to I2C bypass
-     * @return true if successful, false otherwise
-     */
-    bool enableI2CBypass(bool enable);
-
-    /**
-     * set the motion detection threshold for interrupt generation.
-     * Motion is detected when the absolute value of any of the
-     * accelerometer measurements exceeds this Motion detection
-     * threshold.
-     *
-     * @param thr threshold
-     * @return true if successful, false otherwise
-     */
-    bool setMotionDetectionThreshold(uint8_t thr);
-
-    /**
-     * return the interrupt status register.
-     *
-     * @return the interrupt status word (see INT_STATUS_BITS_T)
-     */
-    uint8_t getInterruptStatus();
-
-    /**
-     * set the interrupt enables
-     *
-     * @param enables bitmask of INT_ENABLE_BITS_T values to enable
-     * @return true if successful, false otherwise
-     */
-    bool setInterruptEnables(uint8_t enables);
-
-    /**
-     * get the current interrupt enables register
-     *
-     * @return bitmask of INT_ENABLE_BITS_T values
-     */
-    uint8_t getInterruptEnables();
-
-    /**
-     * set the interrupt pin configuration
-     *
-     * @param cfg bitmask of INT_PIN_CFG_BITS_T values
-     * @return true if successful, false otherwise
-     */
-    bool setInterruptPinConfig(uint8_t cfg);
-
-    /**
-     * get the current interrupt pin configuration
-     *
-     * @return bitmask of INT_PIN_CFG_BITS_T values
-     */
-    uint8_t getInterruptPinConfig();
-
-    /**
-     * install an interrupt handler.
-     *
-     * @param gpio gpio pin to use as interrupt pin
-     * @param level the interrupt trigger level (one of mraa::Edge
-     * values).  Make sure that you have configured the interrupt pin
-     * (setInterruptPinConfig()) properly for whatever level you
-     * choose.
-     * @param isr the interrupt handler, accepting a void * argument
-     * @param arg the argument to pass the the interrupt handler
-     */
-
-    void installISR(int gpio, mraa::Edge level, void (*isr)(void *), void *arg);
-
-    /**
-     * uninstall a previously installed interrupt handler
-     *
-     */
-    void uninstallISR();
-
-    mraa::Gpio* get_gpioIRQ();
-
-  protected:
-    // uncompensated accelerometer and gyroscope values
-    float m_accelX;
-    float m_accelY;
-    float m_accelZ;
-
-    float m_gyroX;
-    float m_gyroY;
-    float m_gyroZ;
-
-    // uncompensated temperature value
-    float m_temp;
-
-    // accelerometer and gyro scaling factors, depending on their Full
-    // Scale settings.
-    float m_accelScale;
-    float m_gyroScale;
-
-  private:
-    /* Disable implicit copy and assignment operators */
-    MPU60X0(const MPU60X0&) = delete;
-    MPU60X0 &operator=(const MPU60X0&) = delete;
-
-    mraa::I2c m_i2c;
-    uint8_t m_addr;
-
-    mraa::Gpio *m_gpioIRQ;
-  };
-}
diff --git a/src/mpu9150/mpu9150.cxx b/src/mpu9150/mpu9150.cxx
deleted file mode 100644
index 6295328..0000000
--- a/src/mpu9150/mpu9150.cxx
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <unistd.h>
-#include <stdlib.h>
-
-#include "mpu9150.hpp"
-
-using namespace upm;
-using namespace std;
-
-MPU9150::MPU9150 (int bus, int address, int magAddress, bool enableAk8975) :
-  MPU60X0(bus, address), m_mag(0)
-{
-  m_magAddress = magAddress;
-  m_i2cBus = bus;
-  m_enableAk8975 = enableAk8975;
-}
-
-MPU9150::~MPU9150()
-{
-  if (m_mag)
-    delete m_mag;
-}
-
-bool MPU9150::init()
-{
-  // init the gyro/accel component
-  if (!MPU60X0::init())
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": Unable to init MPU60X0");
-      return false;
-    }
-
-  // Enabling I2C bypass will allow us to access the
-  // AK8975 Magnetometer on I2C addr 0x0c.
-  if (m_enableAk8975 == true)
-    {
-      if (!enableI2CBypass(true))
-        {
-          throw std::runtime_error(std::string(__FUNCTION__) +
-                                   ": Unable to enable I2C bypass");
-          return false;
-        }
-
-      // Now that we've done that, create an AK8975 instance and
-      // initialize it.
-
-      m_mag = new AK8975(m_i2cBus, m_magAddress);
-
-      if (!m_mag->init())
-        {
-          throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": Unable to init magnetometer");
-          delete m_mag;
-          m_mag = 0;
-          return false;
-        }
-    }
-
-  return true;
-}
-
-void MPU9150::update()
-{
-  MPU60X0::update();
-
-  if (m_mag)
-    m_mag->update();
-}
-
-void MPU9150::getMagnetometer(float *x, float *y, float *z)
-{
-  float mx, my, mz;
-
-  if (!m_mag)
-    mx = my = mz = 0.0;
-  else
-    m_mag->getMagnetometer(&mx, &my, &mz);
-  
-  if (x)
-    *x = mx;
-  if (y)
-    *y = my;
-  if (z)
-    *z = mz;
-}
-
-std::vector<float> MPU9150::getMagnetometer()
-{
-    std::vector<float> v(3);
-    getMagnetometer(&v[0], &v[1], &v[2]);
-    return v;
-}
diff --git a/src/mpu9150/mpu9150.hpp b/src/mpu9150/mpu9150.hpp
deleted file mode 100644
index 105e9c6..0000000
--- a/src/mpu9150/mpu9150.hpp
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-#include <vector>
-
-#include "mpu60x0.hpp"
-#include "ak8975.hpp"
-
-#define MPU9150_I2C_BUS 0
-#define MPU9150_DEFAULT_I2C_ADDR  MPU60X0_DEFAULT_I2C_ADDR
-
-
-namespace upm {
-
-  /**
-   * @brief MPU and AK Accelerometer/Compass/Gyro Library
-   * @defgroup mpu9150 libupm-mpu9150
-   * @ingroup seeed i2c gpio accelerometer compass
-   */
-
-  /**
-   * @library mpu9150
-   * @sensor mpu9150
-   * @comname Inertial Measurement Unit
-   * @altname Grove IMU 9DOF
-   * @type accelerometer compass
-   * @man seeed
-   * @web http://www.seeedstudio.com/wiki/Grove_-_IMU_9DOF_v1.0
-   * @con i2c gpio
-   *
-   * @brief API for MPU9150 chip (Accelerometer, Gyro and Magnetometer Sensor)
-   *
-   * This module defines the MPU9150 interface for libmpu9150
-   *
-   * @image html mpu9150.jpg
-   * @snippet mpu9150.cxx Interesting
-   */
-
-  class MPU9150: public MPU60X0
-  {
-  public:
-    /**
-     * MPU9150 constructor
-     *
-     * @param bus I2C bus to use
-     * @param address The address for this device
-     * @param magAddress The address of the connected magnetometer
-     * @param enableAk8975 Enables i2c bypass mode for magnetometer, default
-     * is true
-     */
-    MPU9150 (int bus=MPU9150_I2C_BUS, int address=MPU9150_DEFAULT_I2C_ADDR,
-             int magAddress=AK8975_DEFAULT_I2C_ADDR, bool enableAk8975=true);
-
-    /**
-     * MPU9150 destructor
-     */
-    virtual ~MPU9150 ();
-
-    /**
-     * Set up initial values and start operation
-     *
-     * @return true if successful
-     */
-    bool init();
-
-    /**
-     * Take a measurement and store the current sensor values
-     * internally.  Note, these user facing registers are only updated
-     * from the internal device sensor values when the i2c serial
-     * traffic is 'idle'.  So, if you are reading the values too fast,
-     * the bus may never be idle, and you will just end up reading
-     * the same values over and over.
-     *
-     * Unfortunately, it is is not clear how long 'idle' actually
-     * means, so if you see this behavior, reduce the rate at which
-     * you are calling update().
-     */
-    void update();
-
-    /**
-     * Return the compensated values for the x, y, and z axes.  The
-     * unit of measurement is in micro-teslas (uT).
-     *
-     * @param x Pointer to returned X axis value
-     * @param y Pointer to returned Y axis value
-     * @param z Pointer to returned Z axis value
-     */
-    void getMagnetometer(float *x, float *y, float *z);
-
-    /**
-     * Return the compensated values for the x, y, and z axes.  The
-     * unit of measurement is in micro-teslas (uT).
-     *
-     * @return std::vector containing X, Y, Z magnetometer values
-     */
-    std::vector<float> getMagnetometer();
-
-  protected:
-    // magnetometer instance
-    AK8975* m_mag;
-
-
-  private:
-      /* Disable implicit copy and assignment operators */
-      MPU9150(const MPU9150&) = delete;
-      MPU9150 &operator=(const MPU9150&) = delete;
-
-    int m_i2cBus;
-    uint8_t m_magAddress;
-    bool m_enableAk8975;
-  };
-
-}
diff --git a/src/mpu9150/mpu9150.i b/src/mpu9150/mpu9150.i
deleted file mode 100644
index 557c5dd..0000000
--- a/src/mpu9150/mpu9150.i
+++ /dev/null
@@ -1,47 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "std_vector.i"
-%include "arrays_java.i"
-%include "../java_buffer.i"
-
-%template(FloatVector) std::vector<float>;
-
-%apply int {mraa::Edge};
-
-%define GETTER get_gpioIRQ()
-%enddef
-
-JAVA_ADD_INSTALLISR_GPIO(upm::MPU60X0)
-
-JAVA_JNI_LOADLIBRARY(javaupm_mpu9150)
-#endif
-/* END Java syntax */
-
-/* BEGIN Javascript syntax  ------------------------------------------------- */
-#ifdef SWIGJAVASCRIPT
-%include "std_vector.i"
-%pointer_functions(float, floatp);
-#endif
-/* END Javascript syntax */
-
-/* BEGIN Python syntax  ----------------------------------------------------- */
-#ifdef SWIGPYTHON
-%include "std_vector.i"
-%pointer_functions(float, floatp);
-#endif
-/* END Python syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "ak8975.hpp"
-#include "mpu60x0.hpp"
-#include "mpu9150.hpp"
-#include "mpu9250.hpp"
-%}
-%include "ak8975.hpp"
-%include "mpu60x0.hpp"
-%include "mpu9150.hpp"
-%include "mpu9250.hpp"
-/* END Common SWIG syntax */
diff --git a/src/mpu9150/mpu9150.json b/src/mpu9150/mpu9150.json
deleted file mode 100644
index 78f0638..0000000
--- a/src/mpu9150/mpu9150.json
+++ /dev/null
@@ -1,59 +0,0 @@
-{
-    "Library": "mpu9150",
-    "Description": "InvenSense/Seeed MPU9150 accelerometer library",
-    "Sensor Class": {
-        "MPU9150": {
-            "Name": "InvenSense/Seeed MPU9150 accelerometer",
-            "Description": "This is the UPM Module for the InvenSense/Seeed MPU9150 accelerometer. The MPU-9150 is the world's first integrated 9-axis motion tracking device designed for the low power, low cost, and high performance requirements of consumer electronics equipment including smartphones, tablets and wearable sensors. MPU-9150 features three 16-bit ADC for digitizing the gyroscope outputs and three 16-bit ADCs for digitizing the accelerometer outputs and three 13-bit ADCs for digitizing the magnetometer outputs",
-            "Aliases": ["mpu9150", "Grove - IMU 9DOF v1.0"],
-            "Categories": ["accelerometer", "gyroscope", "compass"],
-            "Connections": ["i2c", "gpio"],
-            "Project Type": ["prototyping", "industrial", "commercial"],
-            "Manufacturers": ["InvenSense", "Seeed"],
-            "Image": "mpu9150.jpg",
-            "Examples": {
-                "Java": ["MPU9150_Example.java"],
-                "Python": ["mpu9150.py"],
-                "Node.js": ["mpu9150.js"],
-                "C++": ["mpu9150-ak8975.cxx", "mpu9150-mpu60x0.cxx", "mpu9150-mpu9250.cxx", "mpu9150.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "typ" : 5
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Communication Speed": {
-                    "unit": "kHz",
-                    "typ" : 400
-                },
-                "Gyroscope Range": {
-                    "unit": "/sec",
-                    "min": "-/+250",
-                    "max": "-/+2000"
-                },
-                "Accelerometer Range": {
-                    "unit": "g",
-                    "min": "-/+2",
-                    "max": "-/+16"
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["http://wiki.seeedstudio.com/wiki/Grove_-_IMU_9DOF_v1.0"],
-                "Datasheets": ["http://wiki.seeedstudio.com/images/5/51/MPU-9150.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/mpu9150/mpu9250.cxx b/src/mpu9150/mpu9250.cxx
deleted file mode 100644
index e0135a6..0000000
--- a/src/mpu9150/mpu9250.cxx
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <unistd.h>
-#include <stdlib.h>
-
-#include "mpu9250.hpp"
-
-using namespace upm;
-using namespace std;
-
-MPU9250::MPU9250 (int bus, int address, int magAddress, bool enableAk8975) :
-  MPU9150(bus, address, magAddress, enableAk8975)
-{
-}
-
-MPU9250::~MPU9250()
-{
-}
-
-float MPU9250::getTemperature()
-{
-  // this equation is taken from the datasheet.  The 333.87 value was
-  // taken from the adafruit code (it is referenced as
-  // Temp_Sensitivity in the datasheet, but no value is provided there).
-  return (m_temp / 333.87) + 21.0;
-}
-
diff --git a/src/mpu9150/mpu9250.hpp b/src/mpu9150/mpu9250.hpp
deleted file mode 100644
index 5934586..0000000
--- a/src/mpu9150/mpu9250.hpp
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include "mpu9150.hpp"
-
-#define MPU9250_I2C_BUS 0
-#define MPU9250_DEFAULT_I2C_ADDR  MPU9150_DEFAULT_I2C_ADDR
-
-
-namespace upm {
-
-  /**
-   * @library mpu9150
-   * @sensor mpu9250
-   * @comname Inertial Measurement Unit
-   * @altname Grove IMU 9DOF V2
-   * @type accelerometer compass
-   * @man seeed
-   * @web http://www.seeedstudio.com/wiki/Grove_-_IMU_9DOF_v2.0
-   * @con i2c gpio
-   *
-   * @brief API for MPU9250 chip (Accelerometer, Gyro and Magnetometer Sensor)
-   *
-   * This module defines the MPU9250 interface for libmpu9150
-   *
-   * @image html mpu9250.jpg
-   * @snippet mpu9150-mpu9250.cxx Interesting
-   */
-
-  class MPU9250: public MPU9150
-  {
-  public:
-    /**
-     * MPU9250 constructor
-     *
-     * @param bus I2C bus to use
-     * @param address The address for this device
-     * @param magAddress The address of the connected magnetometer
-     * @param enableAk8975 Enables i2c bypass mode for magnetometer, default
-     * is true
-     */
-    MPU9250 (int bus=MPU9250_I2C_BUS, int address=MPU9250_DEFAULT_I2C_ADDR,
-             int magAddress=AK8975_DEFAULT_I2C_ADDR, bool enableAk8975=true);
-
-    /**
-     * MPU9250 destructor
-     */
-    ~MPU9250 ();
-
-    /**
-     * get the temperature value
-     *
-     * @return the temperature value in degrees Celsius
-     */
-    float getTemperature();
-
-  protected:
-
-  private:
-  };
-
-}
diff --git a/src/mq303a/CMakeLists.txt b/src/mq303a/CMakeLists.txt
deleted file mode 100644
index 2df76fb..0000000
--- a/src/mq303a/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME mq303a
-    DESCRIPTION "Alcohol Detection Sensor"
-    C_HDR mq303a.h
-    C_SRC mq303a.c
-    CPP_HDR mq303a.hpp
-    CPP_SRC mq303a.cxx
-    FTI_SRC mq303a_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa)
diff --git a/src/mq303a/mq303a.c b/src/mq303a/mq303a.c
deleted file mode 100644
index 2bfe6cd..0000000
--- a/src/mq303a/mq303a.c
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "mq303a.h"
-#include <stdlib.h>
-
-mq303a_context mq303a_init(int pin, int heater_pin) {
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        return NULL;
-    }
-
-    mq303a_context dev =
-      (mq303a_context)malloc(sizeof(struct _mq303a_context));
-
-    if (!dev)
-      return NULL;
-
-    dev->aio = mraa_aio_init(pin);
-    dev->gpio = mraa_gpio_init(heater_pin);
-
-    if(mraa_gpio_dir(dev->gpio, MRAA_GPIO_OUT) != MRAA_SUCCESS)
-      {
-        free(dev);
-        return NULL;
-      }
-
-    return dev;
-}
-
-void mq303a_close(mq303a_context dev){
-    free(dev);
-}
-
-upm_result_t mq303a_heater_enable(mq303a_context dev, bool enable){
-    if(enable)
-        mraa_gpio_write(dev->gpio, 0);
-    else
-        mraa_gpio_write(dev->gpio, 1);
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t mq303a_get_value(mq303a_context dev, int* val){
-    *val = mraa_aio_read(dev->aio);
-
-    if (*val < 0)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    return UPM_SUCCESS;
-}
diff --git a/src/mq303a/mq303a.cxx b/src/mq303a/mq303a.cxx
deleted file mode 100644
index 0f5a959..0000000
--- a/src/mq303a/mq303a.cxx
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "mq303a.hpp"
-
-using namespace upm;
-
-MQ303A::MQ303A(int pin, int heaterPin)
-{
-  if ( !(m_aio = mraa_aio_init(pin)) ) 
-    {
-      throw std::invalid_argument(std::string(__FUNCTION__) +
-                                  ": mraa_aio_init() failed, invalid pin?");
-      return;
-    }
-
-  if ( !(m_gpio = mraa_gpio_init(heaterPin)) ) 
-    {
-      throw std::invalid_argument(std::string(__FUNCTION__) +
-                                  ": mraa_gpio_init() failed, invalid pin?");
-      return;
-    }
-  mraa_gpio_dir(m_gpio, MRAA_GPIO_OUT);
-}
-
-MQ303A::~MQ303A()
-{
-  heaterEnable(false);
-  mraa_aio_close(m_aio);
-  mraa_gpio_close(m_gpio);
-}
-
-int MQ303A::value()
-{
-  return (1023 - mraa_aio_read(m_aio));
-}
-
-void MQ303A::heaterEnable(bool enable)
-{
-  if (enable)
-    mraa_gpio_write(m_gpio, 0);  // 0 turns on the heater
-  else
-    mraa_gpio_write(m_gpio, 1);  // 1 turns off the heater
-}
diff --git a/src/mq303a/mq303a.h b/src/mq303a/mq303a.h
deleted file mode 100644
index fedaa14..0000000
--- a/src/mq303a/mq303a.h
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#ifndef MQ303A_MQ303A_H_
-#define MQ303A_MQ303A_H_
-
-#include "upm.h"
-#include "mraa/aio.h"
-#include "mraa/gpio.h"
-
-/**
- * @file mq303a.h
- * @library mq303
- * @brief C API for the MQ303A Alcohol Sensor
- *
- * @include mq303.c
- */
-
-/**
- * device context
- */
-typedef struct _mq303a_context {
-    mraa_gpio_context       gpio;
-    mraa_aio_context        aio;
-} *mq303a_context;
-
-/**
- * MQ303A Initialization function
- *
- * @param pin Analog pin to use
- * @param heaterPin Digital pin mapped to the analog pin to use
- * @return void* pointer to the sensor struct
- */
-mq303a_context mq303a_init(int pin, int heater_pin);
-
-/**
- * MQ303A Initialization function
- *
- * @param void* pointer to the sensor struct
- */
-void mq303a_close(mq303a_context dev);
-
-/**
- * This function gets the value of the alcohol content
- *
- * @param void* pointer to the sensor struct
- * @param *val pointer to store the reading
- * @return upm_result_t UPM success/error code
- */
-upm_result_t mq303a_get_value(mq303a_context dev, int* val);
-
-/**
- * This function enables/disables the heater
- * on board the sensor.
- *
- * @param void* pointer to the sensor struct
- * @param bool to turn on/off heater
- * @return upm_result_t UPM success/error code
- */
-upm_result_t mq303a_heater_enable(mq303a_context dev, bool enable);
-
-#endif /* MQ303A_MQ303A_H_ */
diff --git a/src/mq303a/mq303a.hpp b/src/mq303a/mq303a.hpp
deleted file mode 100644
index a2283f1..0000000
--- a/src/mq303a/mq303a.hpp
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/aio.h>
-
-namespace upm {
-
-  /**
-   * @brief MQ303A Alcohol Sensor
-   * @defgroup mq303a libupm-mq303a
-   * @ingroup seeed analog gpio gaseous tsk
-   */
-  /**
-   * @library mq303a
-   * @sensor mq303a
-   * @comname Alcohol Detection Sensor
-   * @altname Grove Alcohol Sensor
-   * @type gaseous
-   * @man seeed
-   * @web http://www.seeedstudio.com/wiki/Grove_-_Alcohol_Sensor
-   * @con analog gpio
-   * @kit tsk
-   *
-   * @brief API for the MQ303A Alcohol Sensor
-   *
-   * UPM module for the MQ303A alcohol sensor.
-   * This sensor needs to be warmed up before stable results are
-   * obtained. The higher the value returned from value(),
-   * the higher the amount of alcohol detected.
-   *
-   * @image html mq303a.jpg
-   * @snippet mq303a.cxx Interesting
-   */
-  class MQ303A {
-  public:
-    /**
-     * MQ303A constructor
-     *
-     * @param pin Analog pin to use
-     * @param heaterPin Digital pin mapped to the analog pin to use
-     */
-    MQ303A(int pin, int heaterPin);
-
-    /**
-     * MQ303A destructor
-     */
-    ~MQ303A();
-
-    /**
-     * Gets the alcohol reading from the sensor.  
-     * The value read from the analog pin is inverted.  
-     * A higher returned value means a higher amount of alcohol detected.
-     *
-     * @return Alcohol reading
-     */
-    int value();
-
-    /**
-     * Enables the heater
-     *
-     * @param enable Enables the heater if true; otherwise, disables it
-     */
-    void heaterEnable(bool enable);
-
-  private:
-    mraa_aio_context m_aio;
-    mraa_gpio_context m_gpio;
-  };
-}
-
-
diff --git a/src/mq303a/mq303a.json b/src/mq303a/mq303a.json
deleted file mode 100644
index e5bb1ee..0000000
--- a/src/mq303a/mq303a.json
+++ /dev/null
@@ -1,67 +0,0 @@
-{
-    "Library": "mq303a",
-    "Description": "Seeed MQ303A Alcohol Sensor library",
-    "Sensor Class": {
-        "MQ303A": {
-            "Name": "API for the Seeed MQ303A Alcohol Sensor",
-            "Description": "This is the UPM Module for the Seeed MQ303A Alcohol Sensor. It has good sensitivity and fast response to alcohol. It is suitable for making Breathalyzer. This Grove implements all the necessary circuitry for MQ303A like power conditioning and heater power supply. This sensor outputs a voltage inversely proportional to the alcohol concentration in air.",
-            "Aliases": ["mq303a", "Grove - Alcohol Sensor"],
-            "Categories": ["gaseous"],
-            "Connections": ["analog"],
-            "Project Type": ["medical", "prototyping"],
-            "Manufacturers": ["Seeed"],
-            "Kits": ["tsk"],
-            "Image": "mq303a.jpg",
-            "Examples": {
-                "Java": ["MQ303A_Example.java"],
-                "Python": ["mq303a.py"],
-                "Node.js": ["mq303a.js"],
-                "C++": ["mq303a.cxx"],
-                "C": ["mq303a.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "typ" : 5
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "min": 100,
-                    "max": 140
-                },
-                "Effective Range": {
-                    "unit": "ppm",
-                    "min": 20,
-                    "max": 1000
-                },
-                "Warm-up Time": {
-                    "unit": "hours",
-                    "min" : 2,
-                    "recommended" : 48
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": 18,
-                    "max": 22
-                },
-                "Operating Humidity": {
-                    "unit": "RH",
-                    "min": "60%",
-                    "max": "70%"
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-Alcohol-Sensor-p-764.html", "http://wiki.seeed.cc/Grove-Alcohol_Sensor/"],
-                "Datasheets": ["https://raw.githubusercontent.com/SeeedDocument/Grove-Alcohol_Sensor/master/res/MQ303A.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/mq303a/mq303a_fti.c b/src/mq303a/mq303a_fti.c
deleted file mode 100644
index 945e56f..0000000
--- a/src/mq303a/mq303a_fti.c
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#include "mq303a.h"
-#include "upm_fti.h"
-
-/** 
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_mq303a_name[] = "MQ303A";
-const char upm_mq303a_description[] = "MQ303A";
-const upm_protocol_t upm_mq303a_protocol[] = {UPM_GPIO, UPM_ANALOG};
-const upm_sensor_t upm_mq303a_category[] = {UPM_GAS};
-
-// forward declarations
-const upm_sensor_descriptor_t upm_mq303a_get_descriptor();
-const void* upm_mq303a_get_ft(upm_sensor_t sensor_type);
-void* upm_mq303a_init_name();
-void upm_mq303a_close(void* dev);
-upm_result_t upm_mq303a_get_value(void* dev, int* val);
-
-const upm_sensor_descriptor_t upm_mq303a_get_descriptor(){
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_mq303a_name;
-    usd.description = upm_mq303a_description;
-    usd.protocol_size = 1;
-    usd.protocol = upm_mq303a_protocol;
-    usd.category_size = 1;
-    usd.category = upm_mq303a_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = &upm_mq303a_init_name,
-    .upm_sensor_close = &upm_mq303a_close,
-    .upm_sensor_get_descriptor = &upm_mq303a_get_descriptor
-};
-
-const void* upm_mq303a_get_ft(upm_sensor_t sensor_type){
-    if (sensor_type == UPM_SENSOR){
-        return &ft;
-    }
-    return NULL;
-}
-
-void* upm_mq303a_init_name(){
-    return NULL;
-}
-
-void upm_mq303a_close(void* dev){
-    mq303a_close((mq303a_context)dev);
-}
-
-upm_result_t upm_mq303a_get_value(void* dev, int* val){
-    return mq303a_get_value((mq303a_context)dev, val);
-}
\ No newline at end of file
diff --git a/src/ms5611/CMakeLists.txt b/src/ms5611/CMakeLists.txt
deleted file mode 100644
index 14ec624..0000000
--- a/src/ms5611/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "ms5611")
-set (libdescription "Barometric Pressure and Temperature Sensor")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa interfaces)
diff --git a/src/ms5611/ms5611.cxx b/src/ms5611/ms5611.cxx
deleted file mode 100644
index b3b34c0..0000000
--- a/src/ms5611/ms5611.cxx
+++ /dev/null
@@ -1,210 +0,0 @@
-/*
- * Author: Henry Bruce <henry.bruce@intel.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <unistd.h>
-#include <string.h>
-#include <time.h>
-#include "ms5611.hpp"
-
-
-// Used to prevent silent failure in mraa_i2c_write()
-// Value come from I2C_SMBUS_I2C_BLOCK_MAX in i2c driver
-#define MAX_I2C_WRITE_SIZE 32
-
-#define MS5611_CMD_ADC_READ           (0x00)
-#define MS5611_CMD_RESET              (0x1E)
-#define MS5611_CMD_CONV_D1            (0x40)
-#define MS5611_CMD_CONV_D2            (0x50)
-#define MS5611_CMD_READ_PROM          (0xA0)
-
-#define MS5611_OSR_ULTRA_LOW_POWER    0x00
-#define MS5611_OSR_LOW_POWER          0x02
-#define MS5611_OSR_STANDARD           0x04
-#define MS5611_OSR_HIGH_RES           0x06
-#define MS5611_OSR_ULTRA_HIGH_RES     0x08
-
-#define MS5611_PROM_SIZE              8
-
-
-using namespace upm;
-
-
-MS5611::MS5611(int i2cBus, int address)
-{
-    i2c = new mraa::I2c(i2cBus);
-    this->address = address;
-    i2c->address(address);
-    prom = new uint16_t[MS5611_PROM_SIZE];
-    if (i2c->writeByte(MS5611_CMD_RESET != mraa::SUCCESS))
-        UPM_THROW("Reset failed.");
-    delayms(5);
-    for (int i = 0; i < MS5611_PROM_SIZE; ++i) {
-        uint8_t buf[2];
-        int bytesRead = i2c->readBytesReg(MS5611_CMD_READ_PROM + 2*i, buf, 2);
-        if (bytesRead != 2)
-           UPM_THROW("PROM address failed.");
-        prom[i] = buf[0] << 8;
-        prom[i] |= buf[1];
-        // printf("Read PROM entry %d = %04x\n", i, prom[i]);
-    }
-
-    // printf("CRC = %X\n", promCrc4());
-    if (promCrc4() != (prom[7] & 0x000F))
-        UPM_THROW("PROM checksum error.");
-    setOverSampling(ULTRA_HIGH_RES);
-}
-
-
-MS5611::~MS5611()
-{
-    delete[] prom;
-    delete i2c;
-}
-
-
-int MS5611::promCrc4() {
-    unsigned int n_rem;
-    unsigned int crc_read;
-    unsigned char n_bit;
-    n_rem = 0x00;
-    crc_read = prom[7];
-    prom[7]=(0xFF00 & (prom[7]));
-    for (int cnt = 0; cnt < 16; cnt++) {
-            if (cnt%2 == 1) {
-                n_rem ^= (unsigned short) ((prom[cnt>>1]) & 0x00FF);
-            } else {
-                n_rem ^= (unsigned short) (prom[cnt>>1]>>8);
-            }
-            for (n_bit = 8; n_bit > 0; n_bit--) {
-                if (n_rem & (0x8000)) {
-                    n_rem = (n_rem << 1) ^ 0x3000;
-                } else {
-                    n_rem = (n_rem << 1);
-                }
-            }
-        }
-    n_rem= (0x000F & (n_rem >> 12));
-    prom[7]=crc_read;
-    return (n_rem ^ 0x0);
-}
-
-
-// Set oversampling value
-void MS5611::setOverSampling(OsrMode osrMode)
-{
-    switch (osrMode)
-    {
-    case ULTRA_LOW_POWER:
-        osr = MS5611_OSR_ULTRA_LOW_POWER;
-        samplePeriod = 1;
-        break;
-    case LOW_POWER:
-        osr = MS5611_OSR_LOW_POWER;
-        samplePeriod = 2;
-        break;
-    case STANDARD:
-        osr = MS5611_OSR_STANDARD;
-        samplePeriod = 3;
-        break;
-    case HIGH_RES:
-        osr = MS5611_OSR_HIGH_RES;
-        samplePeriod = 5;
-        break;
-    case ULTRA_HIGH_RES:
-        osr = MS5611_OSR_ULTRA_HIGH_RES;
-        samplePeriod = 10;
-        break;
-     }
-}
-
-
-void MS5611::delayms(int millisecs)
-{
-   struct timespec sleepTime;
-   sleepTime.tv_sec = millisecs / 1000;
-   sleepTime.tv_nsec = (millisecs % 1000) * 1000000;
-   while ((nanosleep( &sleepTime, &sleepTime ) != 0 ) && ( errno == EINTR ) );
-}
-
-uint32_t MS5611::readADC(int adcReg)
-{
-    uint32_t value;
-    uint8_t buf[3];
-    if (i2c->writeByte(adcReg + osr) != mraa::SUCCESS)
-       UPM_THROW("Convert D2 failed");
-    delayms(100);
-    int bytesRead = i2c->readBytesReg(MS5611_CMD_ADC_READ, buf, 3);
-    if (bytesRead != 3)
-       UPM_THROW("ADC read failed");
-    // printf("%02X%02X%02X\n", buf[0], buf[1], buf[2]);
-    value = ((uint32_t)buf[0] << 16) | ((uint32_t)buf[1] << 8) | buf[2];
-    return value;
-}
-
-uint32_t MS5611::readRawTemperature()
-{
-    return readADC(MS5611_CMD_CONV_D2);
-}
-
-uint32_t MS5611::readRawPressure()
-{
-    return readADC(MS5611_CMD_CONV_D1);
-}
-
-int MS5611::getTemperatureCelsius()
-{
-    uint32_t D2 = readRawTemperature();
-    int64_t dT = D2 - ((uint64_t)prom[5] << 8);
-    int32_t temp = 2000 + ((int64_t)dT * (int64_t)prom[6]) / (int64_t)(1 << 23);
-    return (temp + 50) / 100;
-}
-
-
-int MS5611::getPressurePa()
-{
-    int32_t rawTemp = readRawTemperature();
-    int32_t rawPressure = readRawPressure();
-    int64_t dT = rawTemp - ((uint64_t)prom[5] << 8);
-    int64_t offset  = ((uint32_t)prom[2] << 16) + ((dT * (prom[4]) >> 7));     //was  OFF  = (C[2] << 17) + dT * C[4] / (1 << 6);
-    int64_t scaler = ((uint32_t)prom[1] << 15) + ((dT * (prom[3]) >> 8));     //was  SENS = (C[1] << 16) + dT * C[3] / (1 << 7);
-    int32_t temp = 2000 + (int64_t)dT * (int64_t)prom[6] / (int64_t)(1 << 23);
-
-    if(temp < 2000) {
-        float T1 = (temp - 2000) * (temp - 2000);
-        int64_t offsetDelta  = (5 * T1) / 2;
-        int64_t scalerDelta = (5 * T1) / 4;
-
-        if(temp < -1500) {
-            T1 = (temp + 1500) * (temp + 1500);
-            offsetDelta  += 7 * T1;
-            scalerDelta += 11 * T1 / 2;
-        }
-        offset -= offsetDelta;
-        scaler -= scalerDelta;
-    }
-    int pressure = ((((int64_t)rawPressure * scaler ) >> 21) - offset) / (double) (1 << 15);
-    return pressure;
-}
-
diff --git a/src/ms5611/ms5611.hpp b/src/ms5611/ms5611.hpp
deleted file mode 100644
index b202528..0000000
--- a/src/ms5611/ms5611.hpp
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Author: Henry Bruce <henry.bruce@intel.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "interfaces/iPressureSensor.hpp"
-#include "interfaces/iTemperatureSensor.hpp"
-#include "mraa/i2c.hpp"
-
-namespace upm
-{
-
-#define MS5611_ADDRESS 0x76
-/**
- * @brief MS5611 Barometric Pressure Sensor
- * @defgroup ms5611 libupm-ms5611
- * @ingroup meas i2c temp pressure ipressuresensor itemperaturesensor
- */
-
-/**
- * @library ms5611
- * @sensor ms5611
- * @comname Barometric Pressure and Temperature Sensor
- * @altname MS5611
- * @type temp pressure
- * @man meas
- * @con i2c
- * @web http://www.amsys.info/products/ms5611.htm
- * @if ipressuresensor itemperaturesensor
- *
- * @brief API for MS5611 Barometric Pressure Sensor library
- *
- * Measurement Specialties
- * [MS5611-01BA03](http://www.te.com/usa-en/product-CAT-BLPS0036.html)
- * The MS5611 is a new generation of high resolution altimeter sensors from
- * MEAS Switzerland with SPI and I2C bus interface. This module implements
- * I2C only.
- *
- * @snippet ms5611.cxx Interesting
- */
-
-class MS5611 : public IPressureSensor, public ITemperatureSensor
-{
-public:
-   enum OsrMode
-   {
-       ULTRA_LOW_POWER, LOW_POWER, STANDARD, ULTRA_HIGH_RES, HIGH_RES
-   };
-
-   MS5611(int i2cBus = 0, int address = MS5611_ADDRESS);
-   ~MS5611();
-   virtual const char* getModuleName() { return "ms5611"; }
-   void setOverSampling(OsrMode osrMode);
-   int getTemperatureCelsius();
-   int getPressurePa();
-
-private:
-   /* Disable implicit copy and assignment operators */
-   MS5611(const MS5611&) = delete;
-   MS5611 &operator=(const MS5611&) = delete;
-
-   int promCrc4();
-   uint32_t readADC(int adcReg);
-   void delayms(int millisecs);
-   uint32_t readRawPressure();
-   uint32_t readRawTemperature();
-
-   mraa::I2c* i2c;
-   int address;
-   uint16_t *prom;
-   int osr;
-   int samplePeriod;
-};
-
-
-}
-
diff --git a/src/ms5611/ms5611.i b/src/ms5611/ms5611.i
deleted file mode 100644
index e02dde1..0000000
--- a/src/ms5611/ms5611.i
+++ /dev/null
@@ -1,18 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%import "../interfaces/javaupm_iTemperatureSensor.i"
-%import "../interfaces/javaupm_iPressureSensor.i"
-%typemap(javaimports) SWIGTYPE %{import upm_interfaces.*;%}
-
-JAVA_JNI_LOADLIBRARY(javaupm_ms5611)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "ms5611.hpp"
-%}
-%include "ms5611.hpp"
-/* END Common SWIG syntax */
diff --git a/src/ms5611/ms5611.json b/src/ms5611/ms5611.json
deleted file mode 100644
index 8757122..0000000
--- a/src/ms5611/ms5611.json
+++ /dev/null
@@ -1,89 +0,0 @@
-{
-    "Library": "ms5611",
-    "Description": "Amsys ms5611 Barometric Pressure Sensor library",
-    "Sensor Class": {
-        "MS5611": {
-            "Name": "API for Amsys MS5611 Barometric Pressure Sensor library",
-            "Description": "This is the UPM Module for the Amsys ms5611 barometric pressure sensor. The MS5611 is a new generation of high resolution altimeter sensors from MEAS Switzerland with SPI and I2C bus interface. This module implements I2C only.",
-            "Aliases": ["ms5611", "MS5611 GY-63 Atmospheric Pressure Sensor Module IIC/SPI Communication"],
-            "Categories": ["pressure", "temperature"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping", "industrial", "commercial"],
-            "Manufacturers": ["Amsys"],
-            "Examples": {
-                "Node.js": ["ms5611.js"],
-                "C++": ["ms5611.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 1.8,
-                    "max": 3.6
-                },
-                "Supply Current": {
-                    "unit": "uA",
-                    "min": "0.9",
-                    "max": "12.5"
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Pressure Sensor": {
-                    "Effective Pressure Range": {
-                        "unit": "mbar",
-                        "min": 10,
-                        "max": 1200
-                    },
-                    "Resolution": {
-                        "unit": "mbar",
-                        "min": "0.012",
-                        "max": "0.065"
-                    },
-                    "Accuracy": {
-                        "unit": "mbar",
-                        "min": "-1.5",
-                        "max": "1.5"
-                    },
-                    "Response Time": {
-                        "unit": "ms",
-                        "min" : "0.5",
-                        "max" : "8.22"
-                    }
-                },
-                "Temperature Sensor": {
-                    "Effective Temperature Range": {
-                        "unit": "C",
-                        "min": -40,
-                        "max": 85
-                    },
-                    "Resolution": {
-                        "unit": "C",
-                        "typ": "<0.01"
-                    },
-                    "Accuracy": {
-                        "unit": "C",
-                        "min": -0.8,
-                        "max": 0.8
-                    }
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need pull up resistors"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.banggood.com/MS5611-GY-63-Atmospheric-Pressure-Sensor-Module-IICSPI-Communication-p-965980.html", "http://www.amsys.info/products/ms5611.htm"],
-                "Datasheets": ["http://www.amsys.info/sheets/amsys.en.ms5611_01ba03.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/ms5803/CMakeLists.txt b/src/ms5803/CMakeLists.txt
deleted file mode 100644
index e7ba6c4..0000000
--- a/src/ms5803/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME ms5803
-    DESCRIPTION "I2C Barometric Pressure and Temperature Sensor"
-    C_HDR ms5803.h ms5803_defs.h
-    C_SRC ms5803.c
-    CPP_HDR ms5803.hpp
-    CPP_SRC ms5803.cxx
-    FTI_SRC ms5803_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/ms5803/ms5803.c b/src/ms5803/ms5803.c
deleted file mode 100644
index f0189cd..0000000
--- a/src/ms5803/ms5803.c
+++ /dev/null
@@ -1,504 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <string.h>
-#include <assert.h>
-
-#include "ms5803.h"
-
-#include <upm_math.h>
-#include <upm_platform.h>
-#include <upm_utilities.h>
-
-// quick binary power of 2 function
-#define POWB(type, exp) ((type)1 << exp)
-
-// For SPI, these are our CS on/off functions, if needed
-static void ms5803_cs_on(const ms5803_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->gpio)
-        mraa_gpio_write(dev->gpio, 0);
-}
-
-static void ms5803_cs_off(const ms5803_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->gpio)
-        mraa_gpio_write(dev->gpio, 1);
-}
-
-static upm_result_t ms5803_get_adc_value(const ms5803_context dev,
-                                         MS5803_CMD_T cmd,
-                                         MS5803_OSR_T dly,
-                                         uint32_t *value)
-{
-    assert(dev != NULL);
-
-    uint8_t buf[3];
-
-    if (ms5803_bus_write(dev, cmd, NULL, 0))
-    {
-        printf("%s: ms5802_bus_write() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // need to delay for the appropriate time
-    upm_delay_ms(dly);
-
-    // now, get the 3 byte sample
-    if (ms5803_bus_read(dev, MS5803_CMD_ADC_READ, buf, 3))
-    {
-        printf("%s: ms5802_bus_read() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    *value = ((buf[0] << 16) | (buf[1] << 8) | buf[2]);
-
-    return UPM_SUCCESS;
-}
-
-ms5803_context ms5803_init(unsigned int bus, int address, int cs_pin)
-{
-    ms5803_context dev =
-        (ms5803_context)malloc(sizeof(struct _ms5803_context));
-
-    if (!dev)
-        return NULL;
-
-    // zero out context
-    memset((void *)dev, 0, sizeof(struct _ms5803_context));
-
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        ms5803_close(dev);
-        return NULL;
-    }
-
-    if (address > 0)
-    {
-        // we are doing I2C
-        dev->isSPI = false;
-
-        if (!(dev->i2c = mraa_i2c_init(bus)))
-        {
-            printf("%s: mraa_i2c_init() failed.\n", __FUNCTION__);
-            ms5803_close(dev);
-            return NULL;
-        }
-
-        if (mraa_i2c_address(dev->i2c, address) != MRAA_SUCCESS)
-        {
-            printf("%s: mraa_i2c_address() failed.\n", __FUNCTION__);
-            ms5803_close(dev);
-            return NULL;
-        }
-
-#if defined(UPM_PLATFORM_ZEPHYR)
-        // we seem to need to stick qith 100khz for some reason with
-        // this device on Zephyr.  Even at 100Khz, while calibration
-        // data is now read correctly, there are other issues yet to
-        // be determined.  But as a first step, 100Khz is a
-        // requirement for this driver on Zephyr.
-        if (mraa_i2c_frequency(dev->i2c, MRAA_I2C_STD))
-        {
-            printf("%s: mraa_i2c_frequency() failed.\n", __FUNCTION__);
-            ms5803_close(dev);
-            return NULL;
-        }
-#endif // UPM_PLATFORM_ZEPHYR
-
-    }
-    else
-    {
-        // we are doing SPI
-        dev->isSPI = true;
-
-        if (!(dev->spi = mraa_spi_init(bus)))
-        {
-            printf("%s: mraa_spi_init() failed.\n", __FUNCTION__);
-            ms5803_close(dev);
-            return NULL;
-        }
-
-        // Only create cs context if we are actually using a valid pin.
-        // A hardware controlled pin should specify cs as -1.
-        if (cs_pin >= 0)
-        {
-            if (!(dev->gpio = mraa_gpio_init(cs_pin)))
-            {
-                printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
-                ms5803_close(dev);
-                return NULL;
-            }
-
-            mraa_gpio_dir(dev->gpio, MRAA_GPIO_OUT);
-            ms5803_cs_off(dev);
-        }
-
-        if (mraa_spi_mode(dev->spi, MRAA_SPI_MODE0))
-        {
-            printf("%s: mraa_spi_mode() failed.\n", __FUNCTION__);
-            ms5803_close(dev);
-            return NULL;
-        }
-
-        if (mraa_spi_frequency(dev->spi, 10000000))
-        {
-            printf("%s: mraa_spi_frequency() failed.\n", __FUNCTION__);
-            ms5803_close(dev);
-            return NULL;
-        }
-    }
-
-    // read factory coefficients
-    if (ms5803_load_coefficients(dev))
-    {
-        printf("%s: ms5803_load_coefficients() failed.\n", __FUNCTION__);
-        ms5803_close(dev);
-        return NULL;
-    }
-
-    // set the default OSR to the highest resolution
-    ms5803_set_temperature_osr(dev, MS5803_OSR_4096);
-    ms5803_set_pressure_osr(dev, MS5803_OSR_4096);
-
-    return dev;
-}
-
-void ms5803_close(ms5803_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->i2c)
-        mraa_i2c_stop(dev->i2c);
-
-    if (dev->spi)
-        mraa_spi_stop(dev->spi);
-
-    if (dev->gpio)
-        mraa_gpio_close(dev->gpio);
-
-    free(dev);
-}
-
-upm_result_t ms5803_update(const ms5803_context dev)
-{
-    assert(dev != NULL);
-
-    // start by getting temperature and then pressure
-
-    uint32_t rawTemperature;
-    uint32_t rawPressure;
-
-    // temperature
-    if (ms5803_get_adc_value(dev, dev->temperatureCmd, dev->temperatureDelay,
-                             &rawTemperature))
-    {
-        printf("%s: ms5803_get_adc_value() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // pressure
-    if (ms5803_get_adc_value(dev, dev->pressureCmd, dev->pressureDelay,
-                             &rawPressure))
-    {
-        printf("%s: ms5803_get_adc_value() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-//    printf("raw T = %u P = %u\n", rawTemperature, rawPressure);
-
-    // This algorithm comes from the datasheet.
-
-    // calc 1st order compensated temperature
-    int32_t dT = rawTemperature - dev->C[5] * POWB(int32_t, 8);
-    int32_t TEMP = 2000 + (int64_t)dT * dev->C[6] / POWB(int32_t, 23);
-
-    // calc compensated temp and pressure
-    int64_t OFF, SENS;
-    int32_t P = 0;
-
-    // first order compensation
-    OFF = dev->C[2] * POWB(int64_t, 16) + (dev->C[4] * dT)/POWB(int64_t, 7);
-    SENS = dev->C[1] * POWB(int64_t, 15) + (dev->C[3] * dT)/POWB(int64_t, 8);
-
-    // second order compensation
-    int64_t T2 = 0, OFF2 = 0, SENS2 = 0;
-    if (TEMP >= 2000)
-    {
-        // >=20C
-        T2 = 7 * (((uint64_t)dT * dT) / POWB(int64_t, 37));
-        OFF2 =  ((TEMP - 2000) * (TEMP - 2000)) / POWB(int64_t, 4);
-        SENS2 = 0;
-    }
-    else
-    {
-        T2 = 3 * (((uint64_t)dT * dT) / POWB(int64_t, 33));
-        OFF2 = 3 * ((TEMP - 2000) * (TEMP - 2000)) / POWB(int64_t, 1);
-        SENS2 = 5 * ((TEMP - 2000) * (TEMP - 2000)) / POWB(int64_t, 3);
-
-        // further compensation for very low temps
-        if (TEMP < 1500)
-        {
-            // <15C
-            OFF2 = OFF2 + 7 * ((TEMP + 1500) * (TEMP + 1500));
-            SENS2 = SENS2 + 4 * ((TEMP + 1500) * (TEMP + 1500));
-        }
-    }
-
-    // final caculation
-    TEMP = TEMP - T2;
-    OFF = OFF - OFF2;
-    SENS = SENS - SENS2;
-    P = (rawPressure * SENS/POWB(int64_t, 21) - OFF)/POWB(int64_t, 15);
-
-    dev->temperature = (float)TEMP / 100.0;
-    dev->pressure = (float)P/10.0;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t ms5803_load_coefficients(const ms5803_context dev)
-{
-    assert(dev != NULL);
-
-    // we will load them all, even though only 6 of them are of use to us
-    uint8_t buffer[2];
-
-    for (int i=0; i<MS5803_MAX_COEFFICIENTS; i++)
-    {
-        uint8_t cmd = MS5803_CMD_PROM_READ | ((i & 7) << 1);
-        if (ms5803_bus_read(dev, cmd, buffer, 2))
-        {
-            printf("%s: ms5802_bus_read() failed.\n", __FUNCTION__);
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-
-        dev->C[i] = (buffer[0] << 8) | buffer[1];
-//        printf("C[%d] = %u\n", i, dev->C[i]);
-    }
-
-    return UPM_SUCCESS;
-}
-
-// i2c bus read and write functions
-upm_result_t ms5803_bus_read(const ms5803_context dev, uint8_t cmd,
-                             uint8_t *data, uint8_t len)
-{
-    assert(dev != NULL);
-
-    if (dev->isSPI)
-    {
-        // SPI
-
-        uint8_t sbuf[len + 1];
-        memset((void *)sbuf, 0, len + 1);
-        sbuf[0] = cmd;
-
-        ms5803_cs_on(dev);
-
-        if (mraa_spi_transfer_buf(dev->spi, sbuf, sbuf, len + 1))
-        {
-            ms5803_cs_off(dev);
-            printf("%s: mraa_spi_transfer_buf() failed.\n", __FUNCTION__);
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-        ms5803_cs_off(dev);
-
-        // now copy it into user buffer
-        for (int i=0; i<len; i++)
-            data[i] = sbuf[i + 1];
-    }
-    else
-    {
-        // I2C
-
-        if (mraa_i2c_read_bytes_data(dev->i2c, cmd, data, len) < 0)
-        {
-            printf("%s: mraa_i2c_read_bytes() failed.\n", __FUNCTION__);
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-    }
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t ms5803_bus_write(const ms5803_context dev, uint8_t cmd,
-                              uint8_t *data, uint8_t len)
-{
-    assert(dev != NULL);
-
-    if (dev->isSPI)
-    {
-        // SPI
-
-        uint8_t sbuf[len + 1];
-        memset((void *)sbuf, 0, len + 1);
-        sbuf[0] = cmd;
-
-        // copy in the data to write...
-        if (data && len)
-        {
-            for (int i=0; i<len; i++)
-                sbuf[i + 1] = data[i];
-        }
-
-        ms5803_cs_on(dev);
-
-        if (mraa_spi_transfer_buf(dev->spi, sbuf, sbuf, len + 1))
-        {
-            ms5803_cs_off(dev);
-            printf("%s: mraa_spi_transfer_buf() failed.\n", __FUNCTION__);
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-        ms5803_cs_off(dev);
-    }
-    else
-    {
-        // I2C...
-
-        uint8_t buffer[len + 1];
-
-        buffer[0] = cmd;
-
-        if (data && len)
-        {
-            for (int i=0; i<len; i++)
-                buffer[i+1] = data[i];
-        }
-
-        mraa_result_t rv = mraa_i2c_write(dev->i2c, buffer, len+1);
-
-        if (rv != MRAA_SUCCESS)
-        {
-            printf("%s: mraa_i2c_write() failed.\n", __FUNCTION__);
-            return UPM_ERROR_OPERATION_FAILED;
-        }
-    }
-
-    return UPM_SUCCESS;
-}
-
-void ms5803_set_temperature_osr(const ms5803_context dev, MS5803_OSR_T osr)
-{
-    assert(dev != NULL);
-
-    switch(osr)
-    {
-    case MS5803_OSR_256:
-        dev->temperatureCmd = MS5803_CMD_CONVERT_D2_OSR_256;
-        break;
-
-    case MS5803_OSR_512:
-        dev->temperatureCmd = MS5803_CMD_CONVERT_D2_OSR_512;
-        break;
-
-    case MS5803_OSR_1024:
-        dev->temperatureCmd = MS5803_CMD_CONVERT_D2_OSR_1024;
-        break;
-
-    case MS5803_OSR_2048:
-        dev->temperatureCmd = MS5803_CMD_CONVERT_D2_OSR_2048;
-        break;
-
-    case MS5803_OSR_4096:
-        dev->temperatureCmd = MS5803_CMD_CONVERT_D2_OSR_4096;
-        break;
-
-    default:
-        // can't happen in this universe
-        printf("%s: Internal error, invalid osr value %d\n", __FUNCTION__,
-               (int)osr);
-        return;
-    }
-
-    dev->temperatureDelay = osr;
-}
-
-void ms5803_set_pressure_osr(const ms5803_context dev, MS5803_OSR_T osr)
-{
-    assert(dev != NULL);
-
-    switch(osr)
-    {
-    case MS5803_OSR_256:
-        dev->pressureCmd = MS5803_CMD_CONVERT_D1_OSR_256;
-        break;
-
-    case MS5803_OSR_512:
-        dev->pressureCmd = MS5803_CMD_CONVERT_D1_OSR_512;
-        break;
-
-    case MS5803_OSR_1024:
-        dev->pressureCmd = MS5803_CMD_CONVERT_D1_OSR_1024;
-        break;
-
-    case MS5803_OSR_2048:
-        dev->pressureCmd = MS5803_CMD_CONVERT_D1_OSR_2048;
-        break;
-
-    case MS5803_OSR_4096:
-        dev->pressureCmd = MS5803_CMD_CONVERT_D1_OSR_4096;
-        break;
-
-    default:
-        // can't happen in this universe
-        printf("%s: Internal error, invalid osr value %d\n", __FUNCTION__,
-               (int)osr);
-        return;
-    }
-
-    dev->pressureDelay = osr;
-}
-
-upm_result_t ms5803_reset(const ms5803_context dev)
-{
-    assert(dev != NULL);
-
-    upm_result_t rv = ms5803_bus_write(dev, MS5803_CMD_RESET, NULL, 0);
-    upm_delay_ms(5);
-
-    return rv;
-}
-
-float ms5803_get_temperature(const ms5803_context dev)
-{
-    assert(dev != NULL);
-
-    return dev->temperature;
-}
-
-float ms5803_get_pressure(const ms5803_context dev)
-{
-    assert(dev != NULL);
-
-    return dev->pressure;
-}
diff --git a/src/ms5803/ms5803.cxx b/src/ms5803/ms5803.cxx
deleted file mode 100644
index 6cefa08..0000000
--- a/src/ms5803/ms5803.cxx
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <iostream>
-#include <stdexcept>
-#include <string>
-
-#include "ms5803.hpp"
-
-using namespace upm;
-using namespace std;
-
-MS5803::MS5803(int bus, int address, int csPin) :
-    m_ms5803(ms5803_init(bus, address, csPin))
-{
-    if (!m_ms5803)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": ms5803_init() failed");
-}
-
-MS5803::~MS5803()
-{
-    ms5803_close(m_ms5803);
-}
-
-void MS5803::update()
-{
-    if (ms5803_update(m_ms5803))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": ms5803_update() failed");
-}
-
-void MS5803::reset()
-{
-    if (ms5803_reset(m_ms5803))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": ms5803_reset() failed");
-}
-
-void MS5803::setTemperatureOSR(MS5803_OSR_T osr)
-{
-    ms5803_set_temperature_osr(m_ms5803, osr);
-}
-
-void MS5803::setPressureOSR(MS5803_OSR_T osr)
-{
-    ms5803_set_pressure_osr(m_ms5803, osr);
-}
-
-
-float MS5803::getTemperature()
-{
-    return ms5803_get_temperature(m_ms5803);
-}
-
-float MS5803::getPressure()
-{
-    return ms5803_get_pressure(m_ms5803);
-}
-
-void MS5803::loadCoefficients()
-{
-    if (ms5803_load_coefficients(m_ms5803))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": ms5803_load_coefficients() failed");
-}
-
-string MS5803::busRead(int cmd, int len)
-{
-    uint8_t ucmd = (uint8_t)(cmd & 0xff);
-    uint8_t ulen = (uint8_t)(len & 0xff);
-
-    uint8_t *data = new uint8_t[ulen];
-
-    if (ms5803_bus_read(m_ms5803, ucmd, data, ulen))
-    {
-        delete [] data;
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": ms5803_bus_read() failed");
-    }
-
-    string dataStr((char *)data, ulen);
-    delete [] data;
-
-    return dataStr;
-}
-
-void MS5803::busWrite(int cmd, string data)
-{
-    uint8_t ucmd = (uint8_t)(cmd & 0xff);
-
-    if (ms5803_bus_write(m_ms5803, ucmd, (uint8_t *)data.data(),
-                         (uint8_t)data.size()))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": ms5803_bus_write() failed");
-}
diff --git a/src/ms5803/ms5803.h b/src/ms5803/ms5803.h
deleted file mode 100644
index af30f58..0000000
--- a/src/ms5803/ms5803.h
+++ /dev/null
@@ -1,205 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <stdint.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <upm.h>
-
-#include <mraa/i2c.h>
-#include <mraa/spi.h>
-#include <mraa/gpio.h>
-
-#include "ms5803_defs.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    /**
-     * @file ms5803
-     * @library ms5803
-     * @brief C API for the MS5803 Pressure and Temperature sensor
-     *
-     * @include ms5803.c
-     */
-
-    /**
-     * Device context
-     */
-    typedef struct _ms5803_context {
-        mraa_i2c_context        i2c;
-        mraa_spi_context        spi;
-        // CS pin, if we are using one
-        mraa_gpio_context       gpio;
-
-        // whether we are doing I2C or SPI
-        bool                    isSPI;
-
-        // stored calibration coefficients
-        uint16_t                C[MS5803_MAX_COEFFICIENTS];
-
-        // the command sent to chip depending on OSR configuration for
-        // temperature and pressure measurement.
-        MS5803_CMD_T            temperatureCmd;
-        MS5803_OSR_T            temperatureDelay;
-
-        MS5803_CMD_T            pressureCmd;
-        MS5803_OSR_T            pressureDelay;
-
-        // compensated temperature in C
-        float                   temperature;
-        // compensated pressure in millibars
-        float                   pressure;
-    } *ms5803_context;
-
-    /**
-     * MS5803 initializer
-     *
-     * @param bus i2c/spi bus to use
-     * @param address The address for this device if using I2C.  If
-     * using SPI, supply -1 for this parameter.
-     * @param cs_pin The GPIO pin to use for Chip Select (CS).  This is
-     * only needed for SPI, and only if your SPI implementation
-     * requires it.  Otherwise, just pass -1 if not using SPI, or your
-     * CS is handled automatically by your SPI implementation.
-     * @return an initialized device context on success, NULL on error.
-     */
-    ms5803_context ms5803_init(unsigned int bus, int address, int cs_pin);
-
-    /**
-     * MS5803 close
-     *
-     * @param dev Device context.
-     */
-    void ms5803_close(ms5803_context dev);
-
-    /**
-     * Reset the device.
-     *
-     * @param dev Device context.
-     * @return UPM Status.
-     */
-    upm_result_t ms5803_reset(const ms5803_context dev);
-
-    /**
-     * Take measurements and store the current sensor values
-     * internally.  This function must be called prior to retrieving
-     * any sensor values, for example ms5803_get_temperature().
-     *
-     * @param dev Device context.
-     */
-    upm_result_t ms5803_update(const ms5803_context dev);
-
-    /**
-     * Set the output sampling resolution of the temperature
-     * measurement.  Higher values provide a more precise value.  In
-     * addition, more precise values require more time to measure.
-     * The default set at device intialization is the highest
-     * precision supported: MS5803_OSR_4096
-     *
-     * @param dev Device context.
-     * @param osr One of the MS5803_OSR_T values.
-     */
-    void ms5803_set_temperature_osr(const ms5803_context dev,
-                                    MS5803_OSR_T osr);
-
-    /**
-     * Set the output sampling resolution of the pressure
-     * measurement.  Higher values provide a more precise value.  In
-     * addition, more precise values require more time to measure.
-     * The default set at device intialization is the highest
-     * precision supported: MS5803_OSR_4096
-     *
-     * @param dev Device context.
-     * @param osr One of the MS5803_OSR_T values.
-     */
-    void ms5803_set_pressure_osr(const ms5803_context dev,
-                                 MS5803_OSR_T osr);
-
-    /**
-     * Return the latest measured temperature.  ms5803_update() must
-     * have been called prior to calling this function.  The returned
-     * value is in degrees Celsius.
-     *
-     * @param dev Device context.
-     * @return Temperature in degrees C
-     */
-    float ms5803_get_temperature(const ms5803_context dev);
-
-    /**
-     * Return the latest measured pressure.  ms5803_update() must have
-     * been called prior to calling this function.  The returned value
-     * is in millibars.
-     *
-     * @param dev Device context.
-     * @return Pressure in mbar
-     */
-    float ms5803_get_pressure(const ms5803_context dev);
-
-    /**
-     * Load a series of factory installed compensation coefficients.
-     * This function is called during ms5803_init(), so it should
-     * never need to be called again.  It is provided here anyway
-     * "just in case".
-     *
-     * @param dev Device context.
-     * @return UPM Status.
-     */
-    upm_result_t ms5803_load_coefficients(const ms5803_context dev);
-
-    /**
-     * Perform a bus read.  This function is bus agnostic.  It is
-     * exposed here for those users wishing to perform their own low
-     * level accesses.  This is a low level function, and should not
-     * be used unless you know what you are doing.
-     *
-     * @param dev Device context
-     * @param cmd The command to send.
-     * @param data A pointer to a buffer in which data will be read into.
-     * @param len The number of bytes to read.
-     * @return UPM Status
-     */
-    upm_result_t ms5803_bus_read(const ms5803_context dev, uint8_t cmd,
-                                 uint8_t *data, uint8_t len);
-
-    /**
-     * Perform a bus write.  This function is bus agnostic.  It is
-     * exposed here for those users wishing to perform their own low
-     * level accesses.  This is a low level function, and should not
-     * be used unless you know what you are doing.
-     *
-     * @param dev Device context
-     * @param cmd The command to send.
-     * @param data A pointer to a buffer containing data to write.
-     * @param len The number of bytes to write.
-     * @return UPM Status
-     */
-    upm_result_t ms5803_bus_write(const ms5803_context dev, uint8_t cmd,
-                                  uint8_t *data, uint8_t len);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/ms5803/ms5803.hpp b/src/ms5803/ms5803.hpp
deleted file mode 100644
index c314df8..0000000
--- a/src/ms5803/ms5803.hpp
+++ /dev/null
@@ -1,186 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-
-#include "ms5803.h"
-
-namespace upm {
-
-    /**
-     * @brief MS5803 Pressure and Temperature
-     * @defgroup ms5803 libupm-ms5803
-     * @ingroup i2c spi gpio temp pressure
-     */
-
-    /**
-     * @library ms5803
-     * @sensor ms5803
-     * @comname I2C Barometric Pressure and Temperature Sensor
-     * @type temperature pressure
-     * @man sparkfun
-     * @con i2c spi
-     * @web https://www.sparkfun.com/products/12909
-     *
-     * @brief UPM API for the MS5803 Pressure and Temperature sensor
-     *
-     * The MS5803-14BA is a new generation of high resolution pressure
-     * sensors with SPI and I2C bus interface. It is optimized for
-     * depth measurement systems with a water depth resolution of 1cm
-     * and below. The sensor module includes a high linear pressure
-     * sensor and an ultra low power 24 bit delta-sigma ADC with
-     * internal factory calibrated coefficients. It provides a precise
-     * digital 24 bit pressure and temperature value and different
-     * operation modes that allow the user to optimize for conversion
-     * speed and current consumption. A high resolution temperature
-     * output allows the implementation of a depth measurement systems
-     * and thermometer function without any additional sensor.
-     *
-     * The device is driven at 3.3vdc, and has a pressure range of
-     * between 0 and 14 Bar, and a temperature range of between -40
-     * and +85C.
-     *
-     * @snippet ms5803.cxx Interesting
-     */
-    class MS5803 {
-    public:
-
-        /**
-         * MS5803 constructor.  The default arguments inititialize I2C
-         * operation and the default I2C address.
-         *
-         * @param bus i2c/spi bus to use
-         * @param address The address for this device if using I2C.  If
-         * using SPI, supply -1 for this parameter.
-         * @param csPin The GPIO pin to use for Chip Select (CS).  This is
-         * only needed for SPI, and only if your SPI implementation
-         * requires it.  Otherwise, just pass -1 if not using SPI, or your
-         * CS is handled automatically by your SPI implementation.
-         */
-        MS5803(int bus, int address=MS5803_DEFAULT_I2C_ADDR,
-               int csPin=-1);
-
-        /**
-         * MS5803 Destructor
-         */
-        ~MS5803();
-
-        /**
-         * Reset the device.
-         *
-         */
-        void reset();
-
-        /**
-         * Take a measurement and store the current sensor values
-         * internally.  This function must be called prior to retrieving
-         * any sensor values, for example getTemperature().
-         *
-         */
-        void update();
-
-        /**
-         * Set the output sampling resolution of the temperature
-         * measurement.  Higher values provide a more precise value.  In
-         * addition, more precise values require more time to measure.
-         * The default set at device intialization is the highest
-         * precision supported: MS5803_OSR_4096
-         *
-         * @param osr One of the MS5803_OSR_T values.
-         */
-        void setTemperatureOSR(MS5803_OSR_T osr);
-
-        /**
-         * Set the output sampling resolution of the pressure
-         * measurement.  Higher values provide a more precise value.  In
-         * addition, more precise values require more time to measure.
-         * The default set at device intialization is the highest
-         * precision supported: MS5803_OSR_4096
-         *
-         * @param osr One of the MS5803_OSR_T values.
-         */
-        void setPressureOSR(MS5803_OSR_T osr);
-
-        /**
-         * Return the latest measured temperature.  update() must have
-         * been called prior to calling this function.  The returned
-         * value is in degrees Celsius.
-         *
-         * @return Temperature in degrees C
-         */
-        float getTemperature();
-
-        /**
-         * Return the latest measured pressure.  update() must have
-         * been called prior to calling this function.  The returned
-         * value is in millibars.
-         *
-         * @return Pressure in mbar
-         */
-        float getPressure();
-
-    protected:
-        ms5803_context m_ms5803;
-
-        /**
-         * Load a series of factory installed compensation coefficients.
-         * This function is called during ms5803_init(), so it should
-         * never need to be called again.  It is provided here anyway
-         * "just in case".
-         *
-         * @param dev Device context.
-         * @return UPM Status.
-         */
-        void loadCoefficients();
-
-        /**
-         * Perform a bus read.  This function is bus agnostic.  It is
-         * exposed here for those users wishing to perform their own low
-         * level accesses.  This is a low level function, and should not
-         * be used unless you know what you are doing.
-         *
-         * @param cmd The command or register to access.
-         * @param cnt The number of bytes to read.
-         * @return The data read
-         */
-        std::string busRead(int cmd, int len);
-
-        /**
-         * Perform a bus write.  This function is bus agnostic.  It is
-         * exposed here for those users wishing to perform their own low
-         * level accesses.  This is a low level function, and should not
-         * be used unless you know what you are doing.
-         *
-         * @param cmd The command or register to access.
-         * @param data The string containing the data to write
-         */
-        void busWrite(int cmd, std::string data);
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        MS5803(const MS5803&) = delete;
-        MS5803 &operator=(const MS5803&) = delete;
-    };
-}
diff --git a/src/ms5803/ms5803.i b/src/ms5803/ms5803.i
deleted file mode 100644
index 4fb325a..0000000
--- a/src/ms5803/ms5803.i
+++ /dev/null
@@ -1,21 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "arrays_java.i"
-%include "../java_buffer.i"
-
-JAVA_JNI_LOADLIBRARY(javaupm_ms5803)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%pointer_functions(float, floatp);
-
-%{
-#include "ms5803_defs.h"
-#include "ms5803.hpp"
-%}
-%include "ms5803_defs.h"
-%include "ms5803.hpp"
-/* END Common SWIG syntax */
diff --git a/src/ms5803/ms5803.json b/src/ms5803/ms5803.json
deleted file mode 100644
index 3fa79e0..0000000
--- a/src/ms5803/ms5803.json
+++ /dev/null
@@ -1,92 +0,0 @@
-{
-    "Library": "ms5803",
-    "Description": "Measurement Specialties/Sparkfun MS5803 Pressure and Temperature sensor Library",
-    "Sensor Class": {
-        "MS5803": {
-            "Name": "API for the Measurement Specialties/Sparkfun MS5803 Pressure and Temperature sensor",
-            "Description": "This is the UPM Module for the Measurement Specialties/Sparkfun MS5803 Pressure and Temperature sensor. The MS5803-14BA is a new generation of high resolution pressure sensors with SPI and I2C bus interface. It is optimized for depth measurement systems with a water depth resolution of 1cm and below. The sensor module includes a high linear pressure sensor and an ultra low power 24 bit delta-sigma ADC with internal factory calibrated coefficients. It provides a precise digital 24 bit pressure and temperature value and different operation modes that allow the user to optimize for conversion speed and current consumption. A high resolution temperature output allows the implementation of a depth measurement systems and thermometer function without any additional sensor.",
-            "Aliases": ["ms5803", "SparkFun Pressure Sensor Breakout - MS5803-14BA"],
-            "Categories": ["pressure", "temperature"],
-            "Connections": ["i2c", "spi"],
-            "Project Type": ["prototyping", "industrial", "commercial"],
-            "Manufacturers": ["Measurement Specialties", "SparkFun"],
-            "Examples": {
-                "Java": ["MS5803_Example.java"],
-                "Python": ["ms5803.py"],
-                "Node.js": ["ms5803.js"],
-                "C++": ["ms5803.cxx"],
-                "C": ["ms5803.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 1.8,
-                    "max": 3.6
-                },
-                "Supply Current": {
-                    "unit": "uA",
-                    "min": "0.9",
-                    "max": "12.5"
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Pressure Sensor":{
-                    "Effective Pressure Range":{
-                        "unit": "bar",
-                        "min": 0,
-                        "max": 14
-                    },
-                    "Resolution": {
-                        "unit": "mbar",
-                        "min": "0.2",
-                        "max": "1"
-                    },
-                    "Accuracy": {
-                        "unit": "mbar",
-                        "min": -40,
-                        "max": 40
-                    },
-                    "Response Time": {
-                        "unit": "ms",
-                        "min": 0.5,
-                        "max": 8.22
-                    }
-                },
-                "Temperature Sensor": {
-                    "Effective Temperature Range": {
-                        "unit": "C",
-                        "min": -40,
-                        "max": 85
-                    },
-                    "Resolution": {
-                        "unit": "C",
-                        "typ": "<0.01"
-                    },
-                    "Accuracy": {
-                        "unit": "C",
-                        "min": -0.8,
-                        "max": 0.8
-                    }
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need pull up resistors"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.sparkfun.com/products/12909"],
-                "Datasheets": ["https://cdn.sparkfun.com/datasheets/Sensors/Weather/ms5803_14ba.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/ms5803/ms5803_defs.h b/src/ms5803/ms5803_defs.h
deleted file mode 100644
index 825fce4..0000000
--- a/src/ms5803/ms5803_defs.h
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-// default I2C address
-#define MS5803_DEFAULT_I2C_ADDR 0x76
-
-#define MS5803_MAX_COEFFICIENTS (8)
-
-    // valid commands
-    typedef enum {
-        MS5803_CMD_RESET                = 0x1e,
-
-        // D1 = pressure
-        MS5803_CMD_CONVERT_D1_OSR_256   = 0x40,
-        MS5803_CMD_CONVERT_D1_OSR_512   = 0x42,
-        MS5803_CMD_CONVERT_D1_OSR_1024  = 0x44,
-        MS5803_CMD_CONVERT_D1_OSR_2048  = 0x46,
-        MS5803_CMD_CONVERT_D1_OSR_4096  = 0x48,
-
-        // D2 = temperature
-        MS5803_CMD_CONVERT_D2_OSR_256   = 0x50,
-        MS5803_CMD_CONVERT_D2_OSR_512   = 0x52,
-        MS5803_CMD_CONVERT_D2_OSR_1024  = 0x54,
-        MS5803_CMD_CONVERT_D2_OSR_2048  = 0x56,
-        MS5803_CMD_CONVERT_D2_OSR_4096  = 0x58,
-
-        // ADC read
-        MS5803_CMD_ADC_READ             = 0x00,
-
-        // PROM read.  Bits 1, 2, and 3 indicate the address. Bit 0 is
-        // always 0 (in all commands).  There are 7 PROM locations,
-        // each 2 bytes in length.  These locations store factory
-        // loaded compensation coefficients.
-        MS5803_CMD_PROM_READ            = 0xa0
-    } MS5803_CMD_T;
-
-    // output sampling resolution for temperature and pressure.  We
-    // set the numeric values here to indicate the required wait time
-    // for each in milliseconds (rounded up from the datasheet
-    // maximums), so do not change these numbers.
-    typedef enum {
-        MS5803_OSR_256                  = 1, // 1ms
-        MS5803_OSR_512                  = 2,
-        MS5803_OSR_1024                 = 3,
-        MS5803_OSR_2048                 = 5,
-        MS5803_OSR_4096                 = 10
-    } MS5803_OSR_T;
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/ms5803/ms5803_fti.c b/src/ms5803/ms5803_fti.c
deleted file mode 100644
index 6d6d6a2..0000000
--- a/src/ms5803/ms5803_fti.c
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "ms5803.h"
-#include "upm_fti.h"
-
-/**
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_ms5803_name[] = "MS5803";
-const char upm_ms5803_description[] = "MS5803 Pressure and Temperature Sensor";
-const upm_protocol_t upm_ms5803_protocol[] = {UPM_SPI, UPM_I2C, UPM_GPIO};
-const upm_sensor_t upm_ms5803_category[] = {UPM_TEMPERATURE, UPM_PRESSURE};
-
-// forward declarations
-const void* upm_ms5803_get_ft(upm_sensor_t sensor_type);
-void* upm_ms5803_init_name();
-void upm_ms5803_close(void *dev);
-upm_result_t upm_ms5803_get_pressure(void *dev, float *value);
-upm_result_t upm_ms5803_get_temperature(void *dev, float *value,
-                                        upm_temperature_u unit);
-
-static const upm_sensor_ft ft =
-{
-  .upm_sensor_init_name = upm_ms5803_init_name,
-  .upm_sensor_close = upm_ms5803_close,
-};
-
-static const upm_temperature_ft tft =
-{
-  .upm_temperature_get_value = upm_ms5803_get_temperature,
-};
-
-static const upm_pressure_ft pft =
-{
-  .upm_pressure_get_value = upm_ms5803_get_pressure,
-};
-
-const void* upm_ms5803_get_ft(upm_sensor_t sensor_type)
-{
-  switch(sensor_type)
-    {
-    case UPM_SENSOR:
-      return &ft;
-    case UPM_PRESSURE:
-      return &pft;
-    case UPM_TEMPERATURE:
-      return &tft;
-    default:
-      return NULL;
-    }
-}
-
-void* upm_ms5803_init_name()
-{
-  return NULL;
-}
-
-void upm_ms5803_close(void *dev)
-{
-  ms5803_close((ms5803_context)dev);
-}
-
-upm_result_t upm_ms5803_get_pressure(void *dev, float *value)
-{
-  upm_result_t rv;
-
-  if ((rv = ms5803_update((ms5803_context)dev)))
-    return rv;
-
-  *value = ms5803_get_pressure((ms5803_context)dev);
-
-  return UPM_SUCCESS;
-}
-
-upm_result_t upm_ms5803_get_temperature(void *dev, float *value,
-                                        upm_temperature_u unit)
-{
-  upm_result_t rv;
-
-  if ((rv = ms5803_update((ms5803_context)dev)))
-    return rv;
-
-  // always in C
-  float temp = ms5803_get_temperature((ms5803_context)dev);
-
-  switch (unit)
-    {
-    case CELSIUS:
-      *value = temp;
-      return UPM_SUCCESS;
-
-    case KELVIN:
-      *value = temp + 273.15;
-      return UPM_SUCCESS;
-
-    case FAHRENHEIT:
-      *value = temp * (9.0/5.0) + 32.0;
-      return UPM_SUCCESS;
-    }
-
-  return UPM_SUCCESS;
-}
diff --git a/src/my9221/CMakeLists.txt b/src/my9221/CMakeLists.txt
deleted file mode 100644
index 17daab7..0000000
--- a/src/my9221/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-upm_mixed_module_init (NAME my9221
-    DESCRIPTION "12-channel Constant Current LED Driver with Grayscale"
-    C_HDR my9221.h
-    C_SRC my9221.c
-    CPP_HDR my9221.hpp groveledbar.hpp grovecircularled.hpp
-    CPP_SRC my9221.cxx groveledbar.cxx grovecircularled.cxx
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/my9221/grovecircularled.cxx b/src/my9221/grovecircularled.cxx
deleted file mode 100644
index d5538fe..0000000
--- a/src/my9221/grovecircularled.cxx
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * These modules were rewritten, based on original work by:
- *
- * (original my9221/groveledbar driver)
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * (grovecircularled driver)
- * Author: Jun Kato and Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Contributions: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-#include <unistd.h>
-#include <stdlib.h>
-
-#include "grovecircularled.hpp"
-
-using namespace upm;
-using namespace std;
-
-GroveCircularLED::GroveCircularLED (int dataPin, int clockPin)
-    : MY9221(dataPin, clockPin, 2)
-{
-    // auto refresh by default
-    setAutoRefresh(true);
-    clearAll();
-}
-
-GroveCircularLED::~GroveCircularLED()
-{
-}
-
-void GroveCircularLED::setSpinner(uint8_t position)
-{
-    if (position > 23)
-        position = 23;
-
-    unsigned int ledsPerInstance = m_my9221->max_leds_per_instance;
-
-    for (uint8_t i=0; i<(ledsPerInstance * m_my9221->instances); i++)
-        m_my9221->bitStates[i] =
-            (i == position) ? m_my9221->highIntensity : m_my9221->lowIntensity;
-
-    if (m_my9221->autoRefresh)
-        refresh();
-
-    return;
-}
-
-void GroveCircularLED::setLevel(uint8_t level, bool direction)
-{
-    if (level > 23)
-        level = 23;
-
-    unsigned int ledsPerInstance = m_my9221->max_leds_per_instance;
-
-    if (!direction)
-    {
-        for (unsigned int i=0; i < (ledsPerInstance * m_my9221->instances); i++)
-            m_my9221->bitStates[i] =
-                (i < level) ? m_my9221->highIntensity : m_my9221->lowIntensity;
-    }
-    else
-    {
-        for (unsigned int i=0; i<(ledsPerInstance * m_my9221->instances); i++)
-            m_my9221->bitStates[i] =
-                (((ledsPerInstance * m_my9221->instances) - i) <= level)
-                ? m_my9221->highIntensity : m_my9221->lowIntensity;
-    }
-
-    if (m_my9221->autoRefresh)
-        refresh();
-
-    return;
-}
diff --git a/src/my9221/grovecircularled.hpp b/src/my9221/grovecircularled.hpp
deleted file mode 100644
index 87ba20b..0000000
--- a/src/my9221/grovecircularled.hpp
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * These modules were rewritten, based on original work by:
- *
- * (original my9221/groveledbar)
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * (grovecircularled)
- * Author: Jun Kato and Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Contributions: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/common.hpp>
-#include <mraa/gpio.hpp>
-#include "my9221.hpp"
-
-namespace upm {
-
-  /**
-   * @library my9221
-   * @sensor grovecircularled
-   * @comname Circular LED
-   * @type display
-   * @man seeed
-   * @web http://www.seeedstudio.com/wiki/Grove_-_Circular_LED
-   * @con gpio
-   *
-   * @brief API for the Grove Circular LED module
-   *
-   * This is a circular LED ring based on the MY9221 chip. It is often used
-   * with a rotary encoder and has 24 controllable LEDs.
-   *
-   * @image html grovecircularled.jpg
-   * @snippet my9221-grovecircularled.cxx Interesting
-   */
-
-  class GroveCircularLED : public MY9221 {
-  public:
-    /**
-     * Instantiates an GroveCircularLED object
-     *
-     * @param dataPin Data pin
-     * @param clockPin Clock pin
-     */
-    GroveCircularLED(int dataPin, int clockPin);
-
-    /**
-     * GroveCircularLED destructor
-     */
-    virtual ~GroveCircularLED();
-
-    /**
-     * Sets the spinner (turns off all LEDs but selected one)
-     *
-     * @param position Selected position for the spinner (0-23)
-     */
-    void setSpinner(uint8_t position);
-
-    /**
-     * Sets the lighting status
-     *
-     * @param level Selected level for the circular LED (0-23)
-     * @param direction Up or down; up is true and default
-     */
-    void setLevel(uint8_t level, bool direction=true);
-
-  protected:
-  private:
-  };
-
-}
diff --git a/src/my9221/groveledbar.cxx b/src/my9221/groveledbar.cxx
deleted file mode 100644
index 734f09a..0000000
--- a/src/my9221/groveledbar.cxx
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * These modules were rewritten, based on original work by:
- *
- * (original my9221/groveledbar driver)
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * (grovecircularled driver)
- * Author: Jun Kato and Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Contributions: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-#include <unistd.h>
-#include <stdlib.h>
-
-#include "groveledbar.hpp"
-
-using namespace upm;
-using namespace std;
-
-GroveLEDBar::GroveLEDBar (int dataPin, int clockPin, int instances)
-    : MY9221(dataPin, clockPin, instances)
-{
-    // auto refresh by default
-    setAutoRefresh(true);
-    clearAll();
-}
-
-GroveLEDBar::~GroveLEDBar()
-{
-}
-
-void GroveLEDBar::setBarLevel(uint8_t level, bool greenToRed,
-                              unsigned int barNumber)
-{
-    // here we manipulate the my9221 context struct directly
-    if (level > 10)
-        level = 10;
-
-    if (barNumber >= m_my9221->instances)
-        barNumber = m_my9221->instances - 1;
-
-    unsigned int ledsPerInstance = m_my9221->max_leds_per_instance;
-    unsigned int start = barNumber * ledsPerInstance;
-    unsigned int end = start + ledsPerInstance;
-
-    if (!greenToRed)
-    {
-        for (unsigned int i=start; i<end; i++)
-            m_my9221->bitStates[i] = (i < (level + start)) ?
-                m_my9221->highIntensity : m_my9221->lowIntensity;
-    }
-    else
-    {
-        for (unsigned int i=start; i<end; i++)
-            m_my9221->bitStates[i] = ( ((start + ledsPerInstance) - i) <=
-                               (level + 2 + start)) ?
-                m_my9221->highIntensity : m_my9221->lowIntensity;
-    }
-
-    if (m_my9221->autoRefresh)
-        refresh();
-
-    return;
-}
diff --git a/src/my9221/groveledbar.hpp b/src/my9221/groveledbar.hpp
deleted file mode 100644
index 3eebd72..0000000
--- a/src/my9221/groveledbar.hpp
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * These modules were rewritten, based on original work by:
- *
- * (original my9221/groveledbar)
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * (grovecircularled)
- * Author: Jun Kato and Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Contributions: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/common.hpp>
-#include <mraa/gpio.hpp>
-
-#include "my9221.hpp"
-
-namespace upm {
-
-  /**
-   * @library my9221
-   * @sensor groveledbar
-   * @comname LED Bar
-   * @altname MY9221 LED Bar
-   * @type display
-   * @man seeed
-   * @web http://www.seeedstudio.com/wiki/Grove_-_LED_Bar
-   * @con gpio
-   * @kit eak
-   *
-   * @brief API for Grove LED Bars base on the MY9221
-   *
-   * This is a 10-segment LED bar, with 8 green segments, 1 yellow
-   * segment, and one red segment.  They can be daisy chained together
-   * so that this module can control multiple LED bars.
-   *
-   * @image html my9221.jpg
-   * @snippet my9221-groveledbar.cxx Interesting
-   */
-
-  class GroveLEDBar : public MY9221 {
-  public:
-
-    /**
-     * Instantiates an GroveLEDBar object
-     *
-     * @param dataPin Data pin
-     * @param clockPin Clock pin
-     * @param instances Number of daisy-chained Grove LED Bars, default 1
-     */
-    GroveLEDBar(int dataPin, int clockPin, int instances=1);
-
-    /**
-     * GroveLEDBar destructor
-     */
-    virtual ~GroveLEDBar();
-
-    /**
-     * Sets the bar level
-     *
-     * @param level Selected level for the bar (0 - 10). 0 is off
-     * @param greenToRed true if you start the level on the first
-     * green LED, false otherwise
-     * @param barNumber If you have multiple LED bars chained
-     * together, this argument selects a specific bar starting at 0.
-     * The default is 0.
-     */
-    void setBarLevel(uint8_t level, bool greenToRed=true,
-                     unsigned int barNumber=0);
-
-  protected:
-  private:
-  };
-
-}
diff --git a/src/my9221/my9221.c b/src/my9221/my9221.c
deleted file mode 100644
index 3ccbcaa..0000000
--- a/src/my9221/my9221.c
+++ /dev/null
@@ -1,274 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * These modules were rewritten, based on original work by:
- *
- * (original my9221/groveledbar driver)
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * (grovecircularled driver)
- * Author: Jun Kato and Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Contributions: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <assert.h>
-#include <string.h>
-
-#include <upm_utilities.h>
-#include <upm_platform.h>
-
-#include "my9221.h"
-
-// 12 LED channels per chip (instance)
-#define LEDS_PER_INSTANCE (12)
-
-// forward declarations
-static void my9221_lock_data(const my9221_context dev);
-static void my9221_send_16bit_block(const my9221_context dev, uint16_t data);
-
-my9221_context my9221_init(int dataPin, int clockPin,
-                           int instances)
-{
-    if (instances < 1)
-        instances = 1;
-
-    my9221_context dev =
-        (my9221_context)malloc(sizeof(struct _my9221_context));
-
-    if (!dev)
-        return NULL;
-
-    memset((void *)dev, 0, sizeof(struct _my9221_context));
-    dev->gpioClk = NULL;
-    dev->gpioData = NULL;
-
-    // make sure MRAA is initialized
-    mraa_result_t mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        my9221_close(dev);
-        return NULL;
-    }
-
-    // MRAA contexts...
-    if ( !(dev->gpioClk = mraa_gpio_init(clockPin)) )
-    {
-        printf("%s: mraa_gpio_init(clk) failed\n",
-               __FUNCTION__);
-        my9221_close(dev);
-        return NULL;
-    }
-
-    mraa_gpio_dir(dev->gpioClk, MRAA_GPIO_OUT);
-
-
-    if ( !(dev->gpioData = mraa_gpio_init(dataPin)) )
-    {
-        printf("%s: mraa_gpio_init(data) failed\n",
-               __FUNCTION__);
-        my9221_close(dev);
-        return NULL;
-    }
-
-    mraa_gpio_dir(dev->gpioData, MRAA_GPIO_OUT);
-
-    my9221_set_low_intensity_value(dev, 0x00);   // full off
-    my9221_set_high_intensity_value(dev, 0xff);  // full bright
-
-    dev->commandWord = 0x0000;       // all defaults
-    dev->instances = instances;
-    dev->max_leds_per_instance = LEDS_PER_INSTANCE;
-
-    if ( !(dev->bitStates =
-           malloc(sizeof(uint16_t) * instances * LEDS_PER_INSTANCE) ) )
-    {
-        printf("%s: bit state allocation failed\n",
-               __FUNCTION__);
-        my9221_close(dev);
-        return NULL;
-    }
-
-    my9221_set_auto_refresh(dev, true);
-    my9221_clear_all(dev);
-
-
-    dev->maxLEDS = dev->instances * LEDS_PER_INSTANCE;
-    dev->initialized = true;
-    return dev;
-}
-
-void my9221_close(my9221_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->initialized)
-    {
-        my9221_clear_all(dev);
-
-        if (!dev->autoRefresh)
-            my9221_refresh(dev);
-    }
-
-    if (dev->bitStates)
-        free(dev->bitStates);
-
-    if (dev->gpioClk)
-        mraa_gpio_close(dev->gpioClk);
-    if (dev->gpioData)
-        mraa_gpio_close(dev->gpioData);
-
-    free(dev);
-}
-
-void my9221_set_led(const my9221_context dev, int led, bool on)
-{
-    assert(dev != NULL);
-
-    int maxLed = dev->maxLEDS - 1;
-
-    if (led > maxLed)
-        led = maxLed;
-    if (led < 0)
-        led = 0;
-
-    dev->bitStates[led] = (on) ? dev->highIntensity : dev->lowIntensity;
-
-    if (dev->autoRefresh)
-        my9221_refresh(dev);
-}
-
-void my9221_set_low_intensity_value(const my9221_context dev,
-                                    int intensity)
-{
-    assert(dev != NULL);
-
-    dev->lowIntensity = (intensity & 0xff);
-}
-
-void my9221_set_high_intensity_value(const my9221_context dev,
-                                     int intensity)
-{
-    assert(dev != NULL);
-
-    dev->highIntensity = (intensity & 0xff);
-}
-
-void my9221_set_all(const my9221_context dev)
-{
-    assert(dev != NULL);
-
-    for (unsigned int i=0; i<dev->maxLEDS; i++)
-        dev->bitStates[i] = dev->highIntensity;
-
-    if (dev->autoRefresh)
-        my9221_refresh(dev);
-}
-
-void my9221_clear_all(const my9221_context dev)
-{
-    assert(dev != NULL);
-
-    for (unsigned int i=0; i<dev->maxLEDS; i++)
-        dev->bitStates[i] = dev->lowIntensity;
-
-    if (dev->autoRefresh)
-        my9221_refresh(dev);
-}
-
-void my9221_refresh(const my9221_context dev)
-{
-    assert(dev != NULL);
-
-    for (unsigned int i=0; i<dev->maxLEDS; i++)
-    {
-        if (i % 12 == 0)
-        {
-            my9221_send_16bit_block(dev, dev->commandWord);
-        }
-        my9221_send_16bit_block(dev, dev->bitStates[i]);
-    }
-
-    my9221_lock_data(dev);
-}
-
-void my9221_set_auto_refresh(const my9221_context dev, bool enable)
-{
-    assert(dev != NULL);
-
-    dev->autoRefresh = enable;
-}
-
-int my9221_get_max_leds(const my9221_context dev)
-{
-    assert(dev != NULL);
-
-    return dev->maxLEDS;
-}
-
-static void my9221_lock_data(const my9221_context dev)
-{
-    assert(dev != NULL);
-
-    mraa_gpio_write(dev->gpioData, 0);
-    upm_delay_us(220);
-
-    for (int idx = 0; idx < 4; idx++)
-    {
-        mraa_gpio_write(dev->gpioData, 1);
-        mraa_gpio_write(dev->gpioData, 0);
-    }
-
-    // in reality, we only need > 200ns + (dev->instances * 10ns), so the
-    // following should be good for up to dev->instances < 80), if the
-    // datasheet is to be believed :)
-    upm_delay_us(1);
-
-    return;
-}
-
-static void my9221_send_16bit_block(const my9221_context dev, uint16_t data)
-{
-    assert(dev != NULL);
-
-    for (uint8_t bit_idx = 0; bit_idx < 16; bit_idx++)
-    {
-        uint32_t state = (data & 0x8000) ? 1 : 0;
-        mraa_gpio_write(dev->gpioData, state);
-
-        state = mraa_gpio_read(dev->gpioClk);
-
-        if (state)
-            state = 0;
-        else
-            state = 1;
-
-        mraa_gpio_write(dev->gpioClk, state);
-
-        data <<= 1;
-    }
-
-    return;
-}
diff --git a/src/my9221/my9221.cxx b/src/my9221/my9221.cxx
deleted file mode 100644
index c842b33..0000000
--- a/src/my9221/my9221.cxx
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * These modules were rewritten, based on original work by:
- *
- * (original my9221/groveledbar driver)
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * (grovecircularled driver)
- * Author: Jun Kato and Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Contributions: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-#include <unistd.h>
-#include <stdlib.h>
-
-#include "my9221.hpp"
-
-using namespace upm;
-using namespace std;
-
-MY9221::MY9221 (int dataPin, int clockPin, int instances) :
-    m_my9221(my9221_init(dataPin, clockPin, instances))
-{
-    if (!m_my9221)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": my9221_init() failed");
-
-}
-
-MY9221::~MY9221()
-{
-    my9221_close(m_my9221);
-}
-
-void MY9221::setLED(int led, bool on)
-{
-    my9221_set_led(m_my9221, led, on);
-}
-
-void MY9221::setLowIntensityValue(int intensity)
-{
-    my9221_set_low_intensity_value(m_my9221, intensity);
-}
-
-void MY9221::setHighIntensityValue(int intensity)
-{
-    my9221_set_high_intensity_value(m_my9221, intensity);
-}
-
-void MY9221::setAll()
-{
-    my9221_set_all(m_my9221);
-}
-
-void MY9221::clearAll()
-{
-    my9221_clear_all(m_my9221);
-}
-
-void MY9221::refresh()
-{
-    my9221_refresh(m_my9221);
-}
-
diff --git a/src/my9221/my9221.h b/src/my9221/my9221.h
deleted file mode 100644
index 24372f1..0000000
--- a/src/my9221/my9221.h
+++ /dev/null
@@ -1,183 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * These modules were rewritten, based on original work by:
- *
- * (original my9221/groveledbar)
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * (grovecircularled)
- * Author: Jun Kato and Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Contributions: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <upm.h>
-
-#include <mraa/gpio.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    /**
-     * @file my9221.h
-     * @library my9221
-     * @brief C API for the my9221 driver
-     *
-     * @include my9221.c
-     */
-
-    /**
-     * Device context
-     */
-    typedef struct _my9221_context {
-        mraa_gpio_context gpioClk;
-        mraa_gpio_context gpioData;
-
-        bool              autoRefresh;
-        // we're only doing 8-bit greyscale, so the high order bits are
-        // always 0
-        uint16_t          lowIntensity;
-        uint16_t          highIntensity;
-
-        unsigned int      instances;
-        unsigned int      maxLEDS;
-
-        // an array of uint16_t's representing our bit states (on/off)
-        // intensities.  Only the low 8 bits are used, but in the future
-        // 16bit support can work here as well.
-        uint16_t          *bitStates;
-
-        uint16_t          commandWord;
-
-        bool              initialized;
-
-        // A helper for the users of this driver
-        unsigned int      max_leds_per_instance;
-    } *my9221_context;
-
-
-    /**
-     * Instantiates an MY9221 object
-     *
-     * @param dataPin Data pin
-     * @param clockPin Clock pin
-     * @param instances Number of daisy-chained my9221s, must be at
-     * least 1
-     * @return Device context
-     */
-    my9221_context my9221_init(int dataPin, int clockPin,
-                               int instances);
-
-    /**
-     * MY9221 close
-     *
-     * @param dev Device context
-     */
-    void my9221_close(my9221_context dev);
-
-    /**
-     * Enable or disable auto refresh.  When auto refresh is enabled,
-     * update the LED display as soon as the internal state changes.
-     * When false, the display(s) will not be updated until the
-     * refresh() method is called.
-     *
-     * @param dev Device context
-     * @param enable true to enable auto refresh, false otherwise
-     */
-    void my9221_set_auto_refresh(const my9221_context dev, bool enable);
-
-    /**
-     * Set an LED to a specific on (high intensity) or off (low
-     * intensity) value.
-     *
-     * @param dev Device context
-     * @param led The LED whose state you wish to change
-     * @param on true to turn on the LED, false to turn the LED off
-     */
-    void my9221_set_led(const my9221_context dev, int led, bool on);
-
-    /**
-     * Set the greyscale intensity of an LED in the OFF state.  The
-     * intensity is a value from 0 (fully off) to 255 (fully on).
-     * This will take effect on any future LED set or clear
-     * operations.
-     *
-     * @param dev Device context
-     * @param intensity a value from 0 (fully off) to 255 (fully on)
-     */
-    void my9221_set_low_intensity_value(const my9221_context dev,
-                                        int intensity);
-
-    /**
-     * Set the greyscale intensity of an LED in the ON state.  The
-     * intensity is a value from 0 (fully off) to 255 (fully on).
-     * This will take effect on any future LED set or clear
-     * operations.
-     *
-     * @param dev Device context
-     * @param intensity a value from 0 (fully off) to 255 (fully on)
-     */
-    void my9221_set_high_intensity_value(const my9221_context dev,
-                                         int intensity);
-
-    /**
-     * Set all of the LEDS to the ON (high intensity value) state.
-     *
-     * @param dev Device context
-     */
-    void my9221_set_all(const my9221_context dev);
-
-    /**
-     * Set all of the LEDS to the OFF (low intensity value) state.
-     *
-     * @param dev Device context
-     */
-    void my9221_clear_all(const my9221_context dev);
-
-    /**
-     * Set the LED states to match the internal stored states.  This
-     * is useful when auto refresh (setAutoRefresh()) is false to
-     * update the display.
-     *
-     * @param dev Device context
-     */
-    void my9221_refresh(const my9221_context dev);
-
-    /**
-     * Return the maximum number of LEDs present, based on the number
-     * of instances specified when the device context was initialized.
-     *
-     * @param dev Device context
-     * @return The number of LEDs that can be controlled.
-     */
-    int my9221_get_max_leds(const my9221_context dev);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/my9221/my9221.hpp b/src/my9221/my9221.hpp
deleted file mode 100644
index ec104d2..0000000
--- a/src/my9221/my9221.hpp
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * These modules were rewritten, based on original work by:
- *
- * (original my9221/groveledbar)
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * (grovecircularled)
- * Author: Jun Kato and Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Contributions: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <my9221.h>
-
-namespace upm {
-
-    /**
-     * @brief MY9221 LED Controller Library
-     * @defgroup my9221 libupm-my9221
-     * @ingroup seeed display gpio eak
-     */
-    class MY9221 {
-    public:
-
-        /**
-         * Instantiates an MY9221 object
-         *
-         * @param dataPin Data pin
-         * @param clockPin Clock pin
-         * @param instances Number of daisy-chained my9221s, default 1
-         */
-        MY9221(int dataPin, int clockPin, int instances=1);
-
-        /**
-         * MY9221 destructor
-         */
-        virtual ~MY9221();
-
-        /**
-         * Enable or disable auto refresh.  When auto refresh is enabled,
-         * update the LED display as soon as the internal state changes.
-         * When false, the display(s) will not be updated until the
-         * refresh() method is called.
-         *
-         * @param enable true to enable auto refresh, false otherwise
-         */
-        void setAutoRefresh(bool enable)
-        {
-            my9221_set_auto_refresh(m_my9221, enable);
-        }
-
-        /**
-         * Set an LED to a specific on (high intensity) or off (low
-         * intensity) value.
-         *
-         * @param led The LED whose state you wish to change
-         * @param on true to turn on the LED, false to turn the LED off
-         */
-        void setLED(int led, bool on);
-
-        /**
-         * Set the greyscale intensity of an LED in the OFF state.  The
-         * intensity is a value from 0 (fully off) to 255 (fully on).
-         * This will take effect on any future LED set or clear
-         * operations.
-         *
-         * @param intensity a value from 0 (fully off) to 255 (fully on)
-         */
-        void setLowIntensityValue(int intensity);
-
-        /**
-         * Set the greyscale intensity of an LED in the ON state.  The
-         * intensity is a value from 0 (fully off) to 255 (fully on).
-         * This will take effect on any future LED set or clear
-         * operations.
-         *
-         * @param intensity a value from 0 (fully off) to 255 (fully on)
-         */
-        void setHighIntensityValue(int intensity);
-
-        /**
-         * Set all of the LEDS to the ON (high intensity value) state.
-         */
-        void setAll();
-
-        /**
-         * Set all of the LEDS to the OFF (low intensity value) state.
-         */
-        void clearAll();
-
-        /**
-         * Set the LED states to match the internal stored states.  This
-         * is useful when auto refresh (setAutoRefresh()) is false to
-         * update the display.
-         */
-        void refresh();
-
-    protected:
-
-        my9221_context m_my9221;
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        MY9221(const MY9221&) = delete;
-        MY9221 &operator=(const MY9221&) = delete;
-    };
-
-}
diff --git a/src/my9221/my9221.i b/src/my9221/my9221.i
deleted file mode 100644
index bd94718..0000000
--- a/src/my9221/my9221.i
+++ /dev/null
@@ -1,18 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_my9221)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "groveledbar.hpp"
-#include "my9221.hpp"
-#include "grovecircularled.hpp"
-%}
-%include "my9221.hpp"
-%include "groveledbar.hpp"
-%include "grovecircularled.hpp"
-/* END Common SWIG syntax */
diff --git a/src/my9221/my9221.json b/src/my9221/my9221.json
deleted file mode 100644
index a76670d..0000000
--- a/src/my9221/my9221.json
+++ /dev/null
@@ -1,148 +0,0 @@
-{
-    "Library": "my9221",
-    "Description": "My-semi MY9221 12-channel LED driver Library",
-    "Sensor Class": {
-        "GroveCircularLED": {
-            "Name": "API for the Grove Circular LED module/My-semi MY9221 12-channel LED driver",
-            "Description": "This is the UPM Module for the Grove Circular LED module/My-semi MY9221 12-channel LED driver. This is a circular LED ring based on the MY9221 chip. It is often used with a rotary encoder and has 24 controllable LEDs.",
-            "Aliases": ["my9221", "Grove - Circular LED", "MY9221 12-Channel LED Driver With Grayscale Adaptive Pulse Density Modulation Control"],
-            "Categories": ["display"],
-            "Connections": ["gpio"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["Seeed", "My-semi"],
-            "Image": "grovecircularled.jpg",
-            "Examples": {
-                "Python": ["grovecircularled.py"],
-                "Node.js": ["grovecircularled.js"],
-                "C++": ["my9221-grovecircularled.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 4.5,
-                    "max": 5.5
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "typ": "5.5 per LED"
-                },
-                "LEDs": {
-                    "unit": "LED",
-                    "leds": 24
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["http://wiki.seeedstudio.com/wiki/Grove_-_Circular_LED"],
-                "Datasheets": ["http://www.my-semi.com.tw/file/MY9221_BF_3.0.pdf"]
-            }
-        },
-        "GroveLEDBar": {
-            "Name": "API for the Grove - LED Bar/My-semi MY9221 12-channel LED driver",
-            "Description": "This is the UPM Module for the Grove - LED Bar/My-semi MY9221 12-channel LED driver. This is a 10-segment LED bar, with 8 green segments, 1 yellow segment, and one red segment.  They can be daisy chained together so that this module can control multiple LED bars.",
-            "Aliases": ["my9221", "Grove - LED Bar", "MY9221 12-Channel LED Driver With Grayscale Adaptive Pulse Density Modulation Control"],
-            "Categories": ["display"],
-            "Connections": ["gpio"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["Seeed", "My-semi"],
-            "Kits": ["eak"],
-            "Image": "my9221.jpg",
-            "Examples": {
-                "Java": ["GroveLEDBar_Example.java"],
-                "Python": ["groveledbar.py"],
-                "Node.js": ["groveledbar.js"],
-                "C++": ["my9221-groveledbar.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3,
-                    "max": 5.5
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "typ": "5.5 per LED"
-                },
-                "LEDs": {
-                    "unit": "LED",
-                    "leds": 10
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduinon 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-LED-Bar-p-1178.html", "http://wiki.seeed.cc/Grove-LED_Bar/"],
-                "Datasheets": ["http://www.my-semi.com.tw/file/MY9221_BF_3.0.pdf"]
-            }
-        },
-        "MY9221 ": {
-            "Name": "API for the My-semi MY9221 12-channel LED driver",
-            "Description": "This is the UPM Module for the My-semi MY9221 12-channel LED driver. This is the base for several grove LED modules, allowing finite control of individual LEDs",
-            "Aliases": ["my9221", "MY9221 12-Channel LED Driver With Grayscale Adaptive Pulse Density Modulation Control"],
-            "Categories": ["display"],
-            "Connections": ["gpio"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["My-semi"],
-            "Kits": ["eak"],
-            "Image": "my9221.jpg",
-            "Examples": {
-                "C++": ["my9221-grovecircularled.cxx","my9221-groveledbar.cxx"],
-                "C" : ["my9221.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3,
-                    "max": 5.5
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "typ": "5.5 per LED"
-                },
-                "Operating Temperature": {
-                    "unit": "C",
-                    "min": -40,
-                    "max": 85
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Arduinon 101": {
-                    "Notes": ["Might need pull up resistors"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-LED-Bar-p-1178.html", "http://wiki.seeed.cc/Grove-LED_Bar/"],
-                "Datasheets": ["http://www.my-semi.com.tw/file/MY9221_BF_3.0.pdf"]
-            }
-        }
-    }
-}
-- 
2.7.4

