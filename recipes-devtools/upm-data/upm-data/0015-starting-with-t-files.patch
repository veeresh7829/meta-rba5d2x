From 2b8c1743a975565e9984d73ccf546098986629c0 Mon Sep 17 00:00:00 2001
From: Ganesh K <ganesh.k@phytec.in>
Date: Mon, 24 Jun 2019 19:33:59 +0530
Subject: [PATCH 15/15] starting with t files

---
 src/t3311/CMakeLists.txt          |  10 -
 src/t3311/t3311.cxx               | 308 -----------------
 src/t3311/t3311.hpp               | 310 -----------------
 src/t3311/t3311.i                 |  19 --
 src/t3311/t3311.json              |  60 ----
 src/t6713/CMakeLists.txt          |   5 -
 src/t6713/t6713.cxx               | 244 --------------
 src/t6713/t6713.hpp               | 145 --------
 src/t6713/t6713.i                 |  25 --
 src/t6713/t6713.json              |  60 ----
 src/t8100/CMakeLists.txt          |   8 -
 src/t8100/t8100.cxx               | 254 --------------
 src/t8100/t8100.hpp               | 379 ---------------------
 src/t8100/t8100.i                 |  18 -
 src/t8100/t8100.json              |  83 -----
 src/ta12200/CMakeLists.txt        |   5 -
 src/ta12200/ta12200.cxx           | 119 -------
 src/ta12200/ta12200.hpp           | 112 ------
 src/ta12200/ta12200.json          |  59 ----
 src/tb7300/CMakeLists.txt         |   8 -
 src/tb7300/tb7300.cxx             | 108 ------
 src/tb7300/tb7300.hpp             | 258 --------------
 src/tb7300/tb7300.i               |  29 --
 src/tb7300/tb7300.json            |  46 ---
 src/tca9548a/CMakeLists.txt       |   5 -
 src/tca9548a/tca9548a.cxx         | 138 --------
 src/tca9548a/tca9548a.hpp         | 189 -----------
 src/tca9548a/tca9548a.json        |  56 ---
 src/tcs3414cs/CMakeLists.txt      |   5 -
 src/tcs3414cs/tcs3414cs.cxx       | 126 -------
 src/tcs3414cs/tcs3414cs.hpp       | 167 ---------
 src/tcs3414cs/tcs3414cs.json      |  50 ---
 src/tcs37727/CMakeLists.txt       |   5 -
 src/tcs37727/tcs37727.cpp         | 349 -------------------
 src/tcs37727/tcs37727.hpp         | 289 ----------------
 src/tcs37727/tcs37727.json        |  40 ---
 src/teams/CMakeLists.txt          |   5 -
 src/teams/teams.cxx               | 125 -------
 src/teams/teams.hpp               | 174 ----------
 src/teams/teams.i                 |  14 -
 src/teams/teams.json              |  47 ---
 src/temperature/CMakeLists.txt    |   8 -
 src/temperature/temperature.c     |  77 -----
 src/temperature/temperature.cxx   |  68 ----
 src/temperature/temperature.h     |  76 -----
 src/temperature/temperature.hpp   | 106 ------
 src/temperature/temperature.json  |  39 ---
 src/temperature/temperature_fti.c | 118 -------
 src/tex00/CMakeLists.txt          |   5 -
 src/tex00/tex00.cxx               | 693 --------------------------------------
 src/tex00/tex00.hpp               | 216 ------------
 src/tex00/tex00.i                 |  14 -
 src/tex00/tex00.json              |  52 ---
 src/th02/CMakeLists.txt           |   5 -
 src/th02/th02.cxx                 | 103 ------
 src/th02/th02.hpp                 | 113 -------
 src/th02/th02.json                |  77 -----
 src/tm1637/CMakeLists.txt         |   5 -
 src/tm1637/tm1637.cxx             | 200 -----------
 src/tm1637/tm1637.hpp             | 143 --------
 src/tm1637/tm1637.i               |  32 --
 src/tm1637/tm1637.json            |  52 ---
 src/tmp006/CMakeLists.txt         |   5 -
 src/tmp006/tmp006.cpp             | 278 ---------------
 src/tmp006/tmp006.hpp             | 214 ------------
 src/tmp006/tmp006.json            |  50 ---
 src/tsl2561/CMakeLists.txt        |   9 -
 src/tsl2561/tsl2561.c             | 245 --------------
 src/tsl2561/tsl2561.cxx           | 235 -------------
 src/tsl2561/tsl2561.h             | 164 ---------
 src/tsl2561/tsl2561.hpp           | 171 ----------
 src/tsl2561/tsl2561.json          |  64 ----
 src/tsl2561/tsl2561_fti.c         |  92 -----
 src/ttp223/CMakeLists.txt         |   9 -
 src/ttp223/ttp223.c               |  86 -----
 src/ttp223/ttp223.cxx             |  77 -----
 src/ttp223/ttp223.h               |  99 ------
 src/ttp223/ttp223.hpp             | 112 ------
 src/ttp223/ttp223.i               |  20 --
 src/ttp223/ttp223.json            |  58 ----
 src/ttp223/ttp223_fti.c           |  93 -----
 81 files changed, 8739 deletions(-)
 delete mode 100644 src/t3311/CMakeLists.txt
 delete mode 100644 src/t3311/t3311.cxx
 delete mode 100644 src/t3311/t3311.hpp
 delete mode 100644 src/t3311/t3311.i
 delete mode 100644 src/t3311/t3311.json
 delete mode 100644 src/t6713/CMakeLists.txt
 delete mode 100644 src/t6713/t6713.cxx
 delete mode 100644 src/t6713/t6713.hpp
 delete mode 100644 src/t6713/t6713.i
 delete mode 100644 src/t6713/t6713.json
 delete mode 100644 src/t8100/CMakeLists.txt
 delete mode 100644 src/t8100/t8100.cxx
 delete mode 100644 src/t8100/t8100.hpp
 delete mode 100644 src/t8100/t8100.i
 delete mode 100644 src/t8100/t8100.json
 delete mode 100644 src/ta12200/CMakeLists.txt
 delete mode 100644 src/ta12200/ta12200.cxx
 delete mode 100644 src/ta12200/ta12200.hpp
 delete mode 100644 src/ta12200/ta12200.json
 delete mode 100644 src/tb7300/CMakeLists.txt
 delete mode 100644 src/tb7300/tb7300.cxx
 delete mode 100644 src/tb7300/tb7300.hpp
 delete mode 100644 src/tb7300/tb7300.i
 delete mode 100644 src/tb7300/tb7300.json
 delete mode 100644 src/tca9548a/CMakeLists.txt
 delete mode 100644 src/tca9548a/tca9548a.cxx
 delete mode 100644 src/tca9548a/tca9548a.hpp
 delete mode 100644 src/tca9548a/tca9548a.json
 delete mode 100644 src/tcs3414cs/CMakeLists.txt
 delete mode 100644 src/tcs3414cs/tcs3414cs.cxx
 delete mode 100644 src/tcs3414cs/tcs3414cs.hpp
 delete mode 100644 src/tcs3414cs/tcs3414cs.json
 delete mode 100644 src/tcs37727/CMakeLists.txt
 delete mode 100644 src/tcs37727/tcs37727.cpp
 delete mode 100644 src/tcs37727/tcs37727.hpp
 delete mode 100644 src/tcs37727/tcs37727.json
 delete mode 100644 src/teams/CMakeLists.txt
 delete mode 100644 src/teams/teams.cxx
 delete mode 100644 src/teams/teams.hpp
 delete mode 100644 src/teams/teams.i
 delete mode 100644 src/teams/teams.json
 delete mode 100644 src/temperature/CMakeLists.txt
 delete mode 100644 src/temperature/temperature.c
 delete mode 100644 src/temperature/temperature.cxx
 delete mode 100644 src/temperature/temperature.h
 delete mode 100644 src/temperature/temperature.hpp
 delete mode 100644 src/temperature/temperature.json
 delete mode 100644 src/temperature/temperature_fti.c
 delete mode 100644 src/tex00/CMakeLists.txt
 delete mode 100644 src/tex00/tex00.cxx
 delete mode 100644 src/tex00/tex00.hpp
 delete mode 100644 src/tex00/tex00.i
 delete mode 100644 src/tex00/tex00.json
 delete mode 100644 src/th02/CMakeLists.txt
 delete mode 100644 src/th02/th02.cxx
 delete mode 100644 src/th02/th02.hpp
 delete mode 100644 src/th02/th02.json
 delete mode 100644 src/tm1637/CMakeLists.txt
 delete mode 100644 src/tm1637/tm1637.cxx
 delete mode 100644 src/tm1637/tm1637.hpp
 delete mode 100644 src/tm1637/tm1637.i
 delete mode 100644 src/tm1637/tm1637.json
 delete mode 100644 src/tmp006/CMakeLists.txt
 delete mode 100644 src/tmp006/tmp006.cpp
 delete mode 100644 src/tmp006/tmp006.hpp
 delete mode 100644 src/tmp006/tmp006.json
 delete mode 100644 src/tsl2561/CMakeLists.txt
 delete mode 100644 src/tsl2561/tsl2561.c
 delete mode 100644 src/tsl2561/tsl2561.cxx
 delete mode 100644 src/tsl2561/tsl2561.h
 delete mode 100644 src/tsl2561/tsl2561.hpp
 delete mode 100644 src/tsl2561/tsl2561.json
 delete mode 100644 src/tsl2561/tsl2561_fti.c
 delete mode 100644 src/ttp223/CMakeLists.txt
 delete mode 100644 src/ttp223/ttp223.c
 delete mode 100644 src/ttp223/ttp223.cxx
 delete mode 100644 src/ttp223/ttp223.h
 delete mode 100644 src/ttp223/ttp223.hpp
 delete mode 100644 src/ttp223/ttp223.i
 delete mode 100644 src/ttp223/ttp223.json
 delete mode 100644 src/ttp223/ttp223_fti.c

diff --git a/src/t3311/CMakeLists.txt b/src/t3311/CMakeLists.txt
deleted file mode 100644
index 3650c99..0000000
--- a/src/t3311/CMakeLists.txt
+++ /dev/null
@@ -1,10 +0,0 @@
-if (MODBUS_FOUND)
-  set (libname "t3311")
-  set (libdescription "Temperature and Humidity Probe")
-  set (module_src ${libname}.cxx)
-  set (module_hpp ${libname}.hpp)
-
-  set (reqlibname "libmodbus")
-  upm_module_init(${MODBUS_LIBRARIES})
-  target_include_directories(${libname} PUBLIC ${MODBUS_INCLUDE_DIRS})
-endif ()
diff --git a/src/t3311/t3311.cxx b/src/t3311/t3311.cxx
deleted file mode 100644
index e660815..0000000
--- a/src/t3311/t3311.cxx
+++ /dev/null
@@ -1,308 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <iostream>
-#include <stdexcept>
-#include <string>
-#include <sstream>
-
-#include "t3311.hpp"
-
-using namespace upm;
-using namespace std;
-
-// conversion from fahrenheit to celsius and back
-
-static float f2c(float f)
-{
-  return ((f - 32.0) / (9.0 / 5.0));
-}
-
-static float c2f(float c)
-{
-  return (c * (9.0 / 5.0) + 32.0);
-}
-
-// conversion from 1-byte BCD to decimal
-static uint8_t bcd2dec(uint8_t bcd)
-{
-  return (bcd / 16 * 10) + (bcd % 16);
-}
-
-T3311::T3311(std::string device, int address, int baud, int bits, char parity,
-             int stopBits) :
-  m_mbContext(0)
-{
-  // check some of the parameters
-  if (!(bits == 7 || bits == 8))
-    {
-      throw std::out_of_range(std::string(__FUNCTION__) +
-                              ": bits must be 7 or 8");
-    }
-
-  if (!(parity == 'N' || parity == 'E' || parity == 'O'))
-    {
-      throw std::out_of_range(std::string(__FUNCTION__) +
-                              ": parity must be 'N', 'O', or 'E'");
-    }
-
-  if (!(stopBits == 1 || stopBits == 2))
-    {
-      throw std::out_of_range(std::string(__FUNCTION__) +
-                              ": stopBits must be 1 or 2");
-    }
-
-  m_temperature = 0.0;
-  m_humidity = 0.0;
-  m_computedValue = 0.0;
-  m_dewPointTemperature = 0.0;
-  m_absoluteHumidity = 0.0;
-  m_specificHumidity = 0.0;
-  m_mixingRatio = 0.0;
-  m_specificEnthalpy = 0.0;
-
-  // addresses are only 8bits wide
-  address &= 0xff;
-
-  // now, open/init the device and modbus context
-
-  if (!(m_mbContext = modbus_new_rtu(device.c_str(), baud, parity, bits,
-                                     stopBits)))
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": modbus_new_rtu() failed");
-    }
-
-  // set the slave address of the device we want to talk to
-  if (modbus_set_slave(m_mbContext, address))
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": modbus_set_slave() failed");
-    }
-
-  // set the serial mode
-  modbus_rtu_set_serial_mode(m_mbContext, MODBUS_RTU_RS232);
-
-  // now connect..
-  if (modbus_connect(m_mbContext))
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": modbus_connect() failed");
-    }
-
-  // This is a bit of a hack.  The device uses bus power, which isn't
-  // provided unless the device has been opened and accessed.  As a
-  // result, register reads will usually fail the first time the
-  // device is accessed after a power cycle.  Here, we read the
-  // temperature value (which will most likely fail), then sleep,
-  // allowing the sensor to "boot".  The datasheet says it takes at
-  // about 2 seconds to boot, we will wait for 5.
-  uint16_t tmp;
-  modbus_read_input_registers(m_mbContext, REG_TEMPERATURE, 1, &tmp);
-
-  // sleep for 5 seconds to give time for device to powerup and boot
-  sleep(5);
-
-  // turn off debugging
-  setDebug(false);
-
-  // now read the UNIT_SETTING reg to see what units we are getting
-  // our temperature data in.
-  tmp = readInputReg(REG_UNIT_SETTINGS);
-  if (tmp & 0x0001)
-    m_isCelsius = false;
-  else
-    m_isCelsius = true;
-
-  // read in the the FW_LO register (BCD encoded) and convert
-  tmp = readInputReg(REG_FW_LO);
-
-  // HI byte (major)
-  m_fwRevHi = (tmp >> 8) & 0xff;
-  m_fwRevHi = bcd2dec(m_fwRevHi);
-
-  // LO byte (minor)
-  m_fwRevLo = (tmp & 0xff);
-  m_fwRevLo = bcd2dec(m_fwRevLo);
-
-  if (m_fwRevHi >= 2 && m_fwRevLo >= 44)
-    m_isExtendedDataAvailable = true;
-  else
-    m_isExtendedDataAvailable = false;
-
-  // now get the serial number (BCD encoded 4-byte value, which we
-  // will pack into a string)
-  stringstream preformat;
-  uint8_t b;
-  // LO (but really HI)
-  tmp = readInputReg(REG_SERIAL_LO);
-  b = bcd2dec((tmp & 0xff00) >> 8);
-  preformat << int(b);
-
-  b = bcd2dec(tmp & 0x00ff);
-  preformat << int(b);
-
-  // HI (but really LO)
-  tmp = readInputReg(REG_SERIAL_HI);
-
-  b = bcd2dec((tmp & 0xff00) >> 8);
-  preformat << int(b);
-  b = bcd2dec(tmp & 0x00ff);
-  preformat << int(b);
-
-  m_serialNumber = preformat.str();
-}
-
-T3311::~T3311()
-{
-  if (m_mbContext)
-    {
-      modbus_close(m_mbContext);
-      modbus_free(m_mbContext);
-    }
-}
-
-uint16_t T3311::readInputReg(int reg)
-{
-  uint16_t val;
-
-  if (modbus_read_input_registers(m_mbContext, reg, 1, &val) <= 0)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": modbus_read_input_registers() failed");
-    }
-
-  return val;
-}
-
-int T3311::readInputRegs(int reg, int len, uint16_t *buf)
-{
-  int rv;
-
-  if ((rv = modbus_read_input_registers(m_mbContext, reg, len, buf)) < 0)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": modbus_read_input_registers() failed");
-    }
-
-  return rv;
-}
-
-void T3311::update()
-{
-  static const int dataLen = 9;
-  uint16_t data[dataLen];
-
-  // we read the 9 registers starting at the temperature
-  if (readInputRegs(REG_TEMPERATURE, dataLen, data) != dataLen)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": read less than the expected 9 registers");
-    }
-
-  // temperature first, we always store as C
-  float tmpF = float((int16_t)data[0]) / 10.0;
-  if (m_isCelsius)
-    m_temperature = tmpF;
-  else
-    m_temperature = f2c(tmpF);
-
-  m_humidity = float((int16_t)data[1]) / 10.0;
-  m_computedValue = float((int16_t)data[2]) / 10.0;
-
-  // skip data[3], (pressure) as this device does not support it
-
-  // if extended info is supported, grab those too
-  if (extendedDataAvailable())
-    {
-      // we always store temps in C
-      tmpF = float((int16_t)data[4]) / 10.0;
-      if (m_isCelsius)
-        m_dewPointTemperature = tmpF;
-      else
-        m_dewPointTemperature = f2c(tmpF);
-
-      m_absoluteHumidity = float((int16_t)data[5]) / 10.0;
-      m_specificHumidity = float((int16_t)data[6]) / 10.0;
-      m_mixingRatio = float((int16_t)data[7]) / 10.0;
-      m_specificEnthalpy = float((int16_t)data[8]) / 10.0;
-    }
-}
-
-float T3311::getTemperature(bool fahrenheit)
-{
-  if (fahrenheit)
-    return c2f(m_temperature);
-  else
-    return m_temperature;
-}
-
-float T3311::getHumidity()
-{
-  return m_humidity;
-}
-
-float T3311::getComputedValue()
-{
-  return m_computedValue;
-}
-
-float T3311::getDewPointTemperature(bool fahrenheit)
-{
-  if (fahrenheit)
-    return c2f(m_dewPointTemperature);
-  else
-    return m_dewPointTemperature;
-}
-
-float T3311::getAbsoluteHumidity()
-{
-  return m_absoluteHumidity;
-}
-
-float T3311::getSpecificHumidity()
-{
-  return m_specificHumidity;
-}
-
-float T3311::getMixingRatio()
-{
-  return m_mixingRatio;
-}
-
-float T3311::getSpecificEnthalpy()
-{
-  return m_specificEnthalpy;
-}
-
-void T3311::setDebug(bool enable)
-{
-  m_debugging = enable;
-
-  if (enable)
-    modbus_set_debug(m_mbContext, 1);
-  else
-    modbus_set_debug(m_mbContext, 0);
-}
diff --git a/src/t3311/t3311.hpp b/src/t3311/t3311.hpp
deleted file mode 100644
index d519ae7..0000000
--- a/src/t3311/t3311.hpp
+++ /dev/null
@@ -1,310 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-
-#include <modbus/modbus.h>
-
-namespace upm {
-
-  /**
-   * @brief T3311 Temperature and Humidity Sensor
-   * @defgroup t3311 libupm-t3311
-   * @ingroup uart temp
-   */
-
-  /**
-   * @library t3311
-   * @sensor t3311
-   * @comname Temperature and Humidity Probe
-   * @type temp
-   * @man comet
-   * @con uart
-   * @web http://www.cometsystem.com/products/reg-T3311
-   *
-   * @brief UPM API for the T3311 MODBUS Temperature and Humidity Sensor
-   *
-   * This module implements support for the Comet System T3311
-   * Temperature and Humidity transmitter.  It uses MODBUS over an
-   * RS232 serial port.  You must have libmodbus v3.1.2 (or greater)
-   * installed to compile and use this driver.
-   *
-   * This module was developed using libmodbus 3.1.2, and T3311
-   * Firmware revison 2.66 connected via a Prolific RS232 Serial to
-   * USB adaptor. You cannot use the built in TTL UART pins for
-   * accessing this device -- you must use a full serial RS232
-   * interface connected via USB.
-   *
-   * @snippet t3311.cxx Interesting
-   */
-
-  class T3311 {
-  public:
-
-    // MODBUS input registers
-    typedef enum {
-      REG_TEMPERATURE                       = 0x0030,
-      REG_HUMIDITY                          = 0x0031,
-
-      // This value is configured in the device itself.  By default,
-      // it represents the Dew Point Temperature.  Use the
-      // configuration utility from Comet to adjust the configuration.
-      REG_COMPUTED                          = 0x0032,
-
-      // available in devices with FW > 2.44
-      REG_DEW_POINT                         = 0x0034,
-      REG_ABS_HUMIDITY                      = 0x0035,
-      REG_SPECIFIC_HUMIDITY                 = 0x0036,
-      REG_MIXING_RATIO                      = 0x0037,
-      REG_SPECIFIC_ENTHALPY                 = 0x0038,
-
-      // 32 bit serial number.  These appear to be reversed when
-      // comparing against the TSensor config utility, so the
-      // datasheet is probably wrong.
-      REG_SERIAL_HI                         = 0x1034,
-      REG_SERIAL_LO                         = 0x1035,
-
-      // this is 'somewhat' documented (middle of page 15 in the
-      // Advantech-ADAM standard section) in the "Description of
-      // communications protocols of TXXXX series" document.  We use
-      // it to simply detect whether the device is configured for
-      // Celsius or Fahrenheit data and compensate internally.
-
-      REG_UNIT_SETTINGS                     = 0x203F,
-
-      // firmware revision, BCD byte encoded. We only care about the
-      // LO word - the HI word just contains the manufacturing date.
-      REG_FW_HI                             = 0x3000,
-      REG_FW_LO                             = 0x3001
-    } REGS_T;
-
-
-    /**
-     * T3311 constructor
-     *
-     * @param device Path to the serial device
-     * @param address The MODBUS slave address
-     * @param baud The baudrate of the device.  Default: 9600
-     * @param bits The number of bits per byte.  Default: 8
-     * @param parity The parity of the connection, 'N' for None, 'E'
-     * for Even, 'O' for Odd.  Default: 'N'
-     * @param stopBits The number of stop bits.  Default: 2
-     */
-    T3311(std::string device, int address, int baud=9600, int bits=8,
-          char parity='N', int stopBits=2);
-
-    /**
-     * T3311 Destructor
-     */
-    ~T3311();
-
-    /**
-     * Indicate whether the attached sensor supports extended Computed
-     * Data registers.  Firmware versions at, or higher than 2.44
-     * provide this data.
-     *
-     * @return true if Extended Data is available, false otherwise
-     */
-    bool extendedDataAvailable()
-    {
-      return m_isExtendedDataAvailable;
-    };
-
-    /**
-     * Read current values from the sensor and update internal stored
-     * values.  This method must be called prior to querying any
-     * values, such as temperature or humidity.
-     */
-    void update();
-
-    /**
-     * Get the current temperature.  update() must have been called
-     * prior to calling this method.
-     *
-     * @param fahrenheit true to return the temperature in degrees
-     * fahrenheit, false to return the temperature in degrees celsius.
-     * The default is false (degrees Celsius).
-     * @return The last temperature reading in Celsius or Fahrenheit
-     */
-    float getTemperature(bool fahrenheit=false);
-
-    /**
-     * Get the current relative humidity.  update() must have been called
-     * prior to calling this method.
-     *
-     * @return The last humidity reading
-     */
-    float getHumidity();
-
-    /**
-     * Get the current computed value.  update() must have been
-     * called prior to calling this method.  This value is configured
-     * via the configuration of the sensor using the sensors
-     * configuration utility, and can represent several different
-     * computed values.  The default value from the factory is the
-     * current Dew Point Temperature.
-     *
-     * Since the actual value configured is unknown (and unknowable)
-     * to this driver, the units represented depend on how you have
-     * configured the device. This function simply returns the value
-     * without any conversion or interpretation, other than the
-     * default scaling.
-     *
-     * @return The last Computed Value
-     */
-    float getComputedValue();
-
-    /**
-     * Get the current dew point temperature.  update() must have been
-     * called prior to calling this method.  This information is only
-     * available if the sensor supports Extended Data (ie:
-     * extendedDataAvailable() returns true).
-     *
-     * @param fahrenheit true to return the temperature in degrees
-     * fahrenheit, false to return the temperature in degrees celsius.
-     * The default is false (degrees Celsius).
-     * @return The last dew point temperature reading in Celsius or
-     * Fahrenheit
-     */
-    float getDewPointTemperature(bool fahrenheit=false);
-
-    /**
-     * Get the current absolute humidity.  update() must have been
-     * called prior to calling this method.  This information is only
-     * available if the sensor supports Extended Data (ie:
-     * extendedDataAvailable() returns true).
-     *
-     * @return The last absolute humidity reading in g/m3 (grams per
-     * cubic meter).
-     */
-    float getAbsoluteHumidity();
-
-    /**
-     * Get the current specific humidity.  update() must have been
-     * called prior to calling this method.  This information is only
-     * available if the sensor supports Extended Data (ie:
-     * extendedDataAvailable() returns true).
-     *
-     * @return The last specific humidity reading in g/kg (grams per
-     * kilogram).
-     */
-    float getSpecificHumidity();
-
-    /**
-     * Get the current mixing ratio.  update() must have been
-     * called prior to calling this method.  This information is only
-     * available if the sensor supports Extended Data (ie:
-     * extendedDataAvailable() returns true).
-     *
-     * @return The last mixing ratio reading in g/kg (grams per
-     * kilogram).
-     */
-    float getMixingRatio();
-
-    /**
-     * Get the current specific enthalopy, a measure of energy
-     * density.  update() must have been called prior to calling this
-     * method.  This information is only available if the sensor
-     * supports Extended Data (ie: extendedDataAvailable() returns
-     * true).
-     *
-     * @return The last specific enthalopy reading in kJ/kg
-     * (kilojoules per kilogram).
-     */
-    float getSpecificEnthalpy();
-
-    /**
-     * Get the serial number of the sensor.
-     *
-     * @return The serial number
-     */
-    std::string getSerialNumber()
-    {
-      return m_serialNumber;
-    };
-
-    /**
-     * Get the firmware revision major number.
-     *
-     * @return The firmware revsion major number.
-     */
-    int getFirmwareMajor()
-    {
-      return m_fwRevHi;
-    };
-
-    /**
-     * Get the firmware revision minor number.
-     *
-     * @return The firmware revsion minor number.
-     */
-    int getFirmwareMinor()
-    {
-      return m_fwRevLo;
-    };
-
-    /**
-     * Enable or disable debugging output.  This primarily enables and
-     * disables libmodbus debugging output.
-     *
-     * @param enable true to enable debugging, false otherwise
-     */
-    void setDebug(bool enable);
-
-  protected:
-    uint16_t readInputReg(int reg);
-    int readInputRegs(int reg, int len, uint16_t *buf);
-
-    // MODBUS context
-    modbus_t *m_mbContext;
-
-    // is the device reporting in C or F?
-    bool m_isCelsius;
-
-    // Is the device FW > than 2.44?
-    bool m_isExtendedDataAvailable;
-
-    int m_fwRevHi;
-    int m_fwRevLo;
-
-    std::string m_serialNumber;
-
-  private:
-    bool m_debugging;
-
-    // data
-    float m_temperature;
-    float m_humidity; // relative
-    float m_computedValue;
-
-    // with FW versions > 2.44, these other computed values are
-    // available.
-    float m_dewPointTemperature;
-    float m_absoluteHumidity;
-    float m_specificHumidity;
-    float m_mixingRatio;
-    float m_specificEnthalpy;
-  };
-}
diff --git a/src/t3311/t3311.i b/src/t3311/t3311.i
deleted file mode 100644
index 6b76f8d..0000000
--- a/src/t3311/t3311.i
+++ /dev/null
@@ -1,19 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "arrays_java.i";
-%include "../java_buffer.i"
-
-JAVA_JNI_LOADLIBRARY(javaupm_t3311)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%pointer_functions(float, floatp);
-
-%{
-#include "t3311.hpp"
-%}
-%include "t3311.hpp"
-/* END Common SWIG syntax */
diff --git a/src/t3311/t3311.json b/src/t3311/t3311.json
deleted file mode 100644
index 5435185..0000000
--- a/src/t3311/t3311.json
+++ /dev/null
@@ -1,60 +0,0 @@
-{
-    "Library": "t3311",
-    "Description": "T3311 Temperature and Humidity Sensor Library",
-    "Sensor Class": {
-        "T3311": {
-            "Name": "API for the T3311 MODBUS Temperature and Humidity Sensor",
-            "Description": "This is the UPM Module for the T3311 MODBUS Temperature and Humidity Sensor. This module implements support for the Comet System T3311 Temperature and Humidity transmitter.  It uses MODBUS over an RS232 serial port.  You must have libmodbus v3.1.2 (or greater) installed to compile and use this driver. This module was developed using libmodbus 3.1.2, and T3311 Firmware revison 2.66 connected via a Prolific RS232 Serial to USB adaptor. You cannot use the built in TTL UART pins for accessing this device -- you must use a full serial RS232 interface connected via USB.",
-            "Aliases": ["t3311", "T3311 Temperature and humidity probe with RS232 output, internal sensors"],
-            "Categories": ["humidity", "temperature"],
-            "Connections": ["uart"],
-            "Project Type": ["industrial"],
-            "Manufacturers": ["Comet"],
-            "Examples": {
-                "Python": ["t3311.py"],
-                "Node.js": ["t3311.js"],
-                "C++": ["t3311.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 9,
-                    "max": 30
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -30,
-                    "max": 85
-                },
-                "Temperature Sensor": {
-                    "Effective Range": {
-                        "unit": "°C",
-                        "min" : -30,
-                        "max" : 80
-                    },
-                    "Accuracy": {
-                        "unit": "°C",
-                        "min" : -0.4,
-                        "max" : 0.4
-                    }
-                },
-                "Humidity Sensor": {
-                    "Effective Range": {
-                        "unit": "RH",
-                        "min" : "0%",
-                        "max" : "100%"
-                    },
-                    "Accuracy": {
-                        "unit": "RH",
-                        "min" : "-2.5%",
-                        "max" : "2.5%"
-                    }
-                }
-            },
-            "Urls": {
-                "Product Pages": ["http://www.cometsystem.com/products/reg-T3311"],
-                "Datasheets": ["http://www.cometsystem.com/products/reg-T3311#technical_dataa"]
-            }
-        }
-    }
-}
diff --git a/src/t6713/CMakeLists.txt b/src/t6713/CMakeLists.txt
deleted file mode 100644
index 339ad91..0000000
--- a/src/t6713/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "t6713")
-set (libdescription "I2C/UART High Accuracy CO2 Sensor")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa interfaces)
diff --git a/src/t6713/t6713.cxx b/src/t6713/t6713.cxx
deleted file mode 100644
index eb23f5c..0000000
--- a/src/t6713/t6713.cxx
+++ /dev/null
@@ -1,244 +0,0 @@
-/*
- * Author: Henry Bruce <henry.bruce@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <errno.h>
-#include <iostream>
-#include <math.h>
-#include <stdlib.h>
-#include <syslog.h>
-#include <unistd.h>
-
-#include "t6713.hpp"
-
-#define T6713_ADDR                                0x15
-
-/* REGISTER ADDRESSES */
-#define T6713_REG_FIRMWARE_REVISION               0x1389
-
-#define T6713_REG_STATUS                          0x138A
-
-#define T6713_REG_GAS_PPM                         0x138B
-
-#define T6713_REG_RESET_DEVICE                    0x03E8
-
-#define T6713_REG_START_SINGLE_POINT_CAL          0x03EC
-
-#define T6713_REG_CHANGE_SLAVE_ADDRESS            0x0FA5
-
-#define T6713_REG_ABC_LOGIC_ENABLE_DISABLE        0x03EE
-
-using namespace upm;
-using namespace upm::t6713_co2;
-
-T6713::T6713 (int bus) : i2c(bus)
-{
-    status = i2c.address(T6713_ADDR);
-    uint16_t firmwareRevision = getFirmwareRevision();
-    if (firmwareRevision != mraa::SUCCESS)
-        UPM_THROW("config failure");
-}
-
-uint16_t T6713::getFirmwareRevision()
-{
-    return(getSensorData(T6713_COMMAND_GET_FIRMWARE_REVISION));
-}
-
-uint16_t T6713::getPpm ()
-{
-    return(getSensorData(T6713_COMMAND_GET_GAS_PPM));
-}
-
-uint16_t T6713::getSensorData (MODBUS_COMMANDS cmd)
-{
-    uint16_t data ,readBytes ;
-    STATUS currStatus ;
-    switch(currStatus = getStatus()) /* handle error conditions */
-    {
-        case ERROR_CONDITION:
-            UPM_THROW ("error condition");
-            break;
-        case FLASH_ERROR:
-            UPM_THROW ("flash error");
-            break;
-        case CALIBRATION_ERROR:
-            UPM_THROW ("calibration error");
-            break;
-        case WARMUP_MODE:
-            //UPM_THROW ("warmup mode");
-            break;
-        case RS232:
-            //printf("\nRS232 mode set\n ");
-            break;
-        case RS485:
-            //printf("\nRS485 mode set\n ");
-            break;
-        case I2C:
-            {
-                //printf("\nI2C mode set\n");
-                data = 0;
-                runCommand(cmd);
-                RESPONSE response;
-                if((readBytes = i2c.read((uint8_t*)(&response), sizeof(RESPONSE) ) != sizeof(RESPONSE)))
-                {
-                    UPM_THROW("I2C read failed");
-                    // TODO
-                }
-                if(response.function_code == READ_INPUT_REGISTERS)
-                {
-                    if(response.byte_count == 2)
-                    {
-                        data = (response.status_msb << 8 | response.status_lsb);
-                    }
-                }
-                return(data);
-                break;
-            }
-        default:
-            syslog(LOG_WARNING, "%s: switch case not defined",
-                    std::string(__FUNCTION__).c_str());
-    }
-    return 0;
-
-}
-
-
-mraa::Result T6713::runCommand(MODBUS_COMMANDS cmd)
-{
-    COMMAND cmdPacket;
-    mraa::Result ret = mraa::SUCCESS;
-
-    switch(cmd)
-    {
-        case T6713_COMMAND_RESET:
-            cmdPacket.function_code = WRITE_SINGLE_COIL;
-            cmdPacket.register_address_msb = (T6713_REG_RESET_DEVICE >> 8);
-            cmdPacket.register_address_lsb = (T6713_REG_RESET_DEVICE & 0xff);
-            cmdPacket.input_registers_to_read_msb = 0xff;
-            cmdPacket.input_registers_to_read_lsb = 0x00;
-            ret = i2c.write((const uint8_t*) (&cmdPacket), sizeof(COMMAND));
-            /*no response from the slave */
-            break;
-        case T6713_COMMAND_STATUS:
-            /*created the modbus status command packet*/
-            cmdPacket.function_code = READ_INPUT_REGISTERS;
-            cmdPacket.register_address_msb = (T6713_REG_STATUS >> 8);
-            cmdPacket.register_address_lsb = (T6713_REG_STATUS & 0xff);
-            cmdPacket.input_registers_to_read_msb = 0;
-            cmdPacket.input_registers_to_read_lsb = 1;
-
-            if((ret = i2c.write((const uint8_t*) (&cmdPacket), sizeof(COMMAND))) != mraa::SUCCESS)
-            {
-                UPM_THROW("I2C write failed");
-            }
-
-
-            break;
-        case T6713_COMMAND_GET_FIRMWARE_REVISION:
-            cmdPacket.function_code = READ_INPUT_REGISTERS;
-            cmdPacket.register_address_msb = (T6713_REG_FIRMWARE_REVISION >> 8);
-            cmdPacket.register_address_lsb = (T6713_REG_FIRMWARE_REVISION & 0xff);
-            cmdPacket.input_registers_to_read_msb = 0;
-            cmdPacket.input_registers_to_read_lsb = 1;
-            ret = i2c.write((const uint8_t*) (&cmdPacket), sizeof(COMMAND));
-            break;
-        case T6713_COMMAND_GET_GAS_PPM:
-            cmdPacket.function_code = READ_INPUT_REGISTERS;
-            cmdPacket.register_address_msb = (T6713_REG_GAS_PPM >> 8);
-            cmdPacket.register_address_lsb = (T6713_REG_GAS_PPM & 0xff);
-
-            cmdPacket.input_registers_to_read_msb = 0;
-            cmdPacket.input_registers_to_read_lsb = 1;
-
-            if((ret = i2c.write((const uint8_t*) (&cmdPacket), sizeof(COMMAND))) != mraa::SUCCESS)
-            {
-                UPM_THROW("I2C write failed");
-            }
-
-            break;
-    }
-
-    return ret;
-}
-
-
-STATUS T6713::getStatus()
-{
-    uint16_t responseStatus = 0, readBytes = 0;
-    RESPONSE response;
-    runCommand(T6713_COMMAND_STATUS);
-    if((readBytes = i2c.read((uint8_t*) (&response), sizeof(RESPONSE)) != sizeof(RESPONSE)))
-    {
-        UPM_THROW("I2C read failed");
-
-    }
-    if(response.function_code == READ_INPUT_REGISTERS)
-    {
-        if(response.byte_count == 2)
-        {
-            responseStatus = (response.status_msb << 8 | response.status_lsb);
-        }
-        else
-        {
-            UPM_THROW("I2C read failed");
-
-        }
-    }
-    else
-    {
-        UPM_THROW("MODBUS function code failed");
-    }
-
-    if(responseStatus & 0x0001)
-    {
-        return ERROR_CONDITION;
-    }
-    if(responseStatus & 0x0002)
-    {
-        return FLASH_ERROR;
-    }
-    if(responseStatus & 0x0004)
-    {
-        return CALIBRATION_ERROR;
-    }
-    if(responseStatus & 0x0800)
-    {
-        return WARMUP_MODE;
-    }
-    if(responseStatus & 0x8000)
-    {
-        return SINGLE_POINT_CALIBRATION;
-    }
-    if(responseStatus & 0x0100)
-    {
-        return RS232;
-    }
-    if(responseStatus & 0x0400)
-    {
-        return RS485;
-    }
-    else
-    {
-        return I2C;
-    }
-}
diff --git a/src/t6713/t6713.hpp b/src/t6713/t6713.hpp
deleted file mode 100644
index 9f4533d..0000000
--- a/src/t6713/t6713.hpp
+++ /dev/null
@@ -1,145 +0,0 @@
-/*
- * Author: Henry Bruce <henry.bruce@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-
-#include "mraa/i2c.hpp"
-#include "interfaces/iCO2Sensor.hpp"
-
-namespace upm {
-/**
- * @brief Amphenol Telaire 6713 Series CO2 Module
- * @defgroup t6713 libupm-t6713
- * @ingroup i2c amphenol gaseous ico2sensor
- */
-
-/**
- * @library t6713
- * @sensor t6713
- * @comname I2C/UART High Accuracy CO2 Sensor
- * @altname T6713
- * @type gaseous
- * @man amphenol
- * @web http://amphenol-sensors.com/en/products/co2/co2-modules/3215-t6700
- * @con i2c
- * @if ico2sensor
- *
- * @brief C++ API for Amphenol Telaire 6713 Series CO2 Module
- *
- * The Telaire 6713 Series CO2 Module
- * [6713](http://amphenol-sensors.com/en/products/co2/co2-modules/3215-t6700#specifications-t6713)
- * is a CO2 Module sensor.
- *
- * @snippet t6713.cxx Interesting
- * @snippet t6713-co2-sensor.cxx Interesting
- */
-
-namespace t6713_co2
-{
-    /* COMMAND VALUES */
-    typedef enum
-    {
-        T6713_COMMAND_RESET,
-        T6713_COMMAND_STATUS,
-        T6713_COMMAND_GET_FIRMWARE_REVISION,
-        T6713_COMMAND_GET_GAS_PPM
-    }MODBUS_COMMANDS;
-
-    typedef enum
-    {
-        ERROR_CONDITION,
-        FLASH_ERROR,
-        CALIBRATION_ERROR,
-        WARMUP_MODE,
-        SINGLE_POINT_CALIBRATION,
-        RS232,
-        I2C,
-        RS485
-    }STATUS;
-
-    typedef struct
-    {
-        uint8_t function_code;
-        uint8_t register_address_msb;
-        uint8_t register_address_lsb;
-        uint8_t input_registers_to_read_msb;
-        uint8_t input_registers_to_read_lsb;
-
-    }COMMAND;
-
-    typedef struct
-    {
-        uint8_t function_code;
-        uint8_t byte_count;
-        uint8_t status_msb;
-        uint8_t status_lsb;
-
-    }RESPONSE;
-
-    typedef enum
-    {
-        READ_INPUT_REGISTERS = 4,
-        WRITE_SINGLE_COIL,
-        WRITE_SINGLE_HOLDING_REGISTER
-    }FUNCTION_CODES;
-}//namespace t6713_co2
-
-class T6713 : public ICO2Sensor {
-    public:
-        /**
-        * Instantiates a T6713 object
-        *
-        * @param bus number of used bus
-        */
-        T6713 (int bus);
-
-        /**
-        * T6713 object destructor.
-        */
-        virtual ~T6713 () {};
-
-        /**
-        * Returns sensor module name
-        */
-        virtual const char* getModuleName() { return "t6713"; }
-
-        /**
-        * Get relative humidity measurement.
-        */
-        uint16_t getPpm ();
-        /**
-        * Get the firmware version
-        */
-        uint16_t getFirmwareRevision();
-
-
-    private:
-        mraa::Result runCommand(t6713_co2::MODBUS_COMMANDS command);
-        uint16_t getSensorData(t6713_co2::MODBUS_COMMANDS cmd);
-        t6713_co2::STATUS getStatus();
-
-        mraa::I2c i2c;
-        mraa::Result status;
-};
-
-}//namespace upm
diff --git a/src/t6713/t6713.i b/src/t6713/t6713.i
deleted file mode 100644
index 56db974..0000000
--- a/src/t6713/t6713.i
+++ /dev/null
@@ -1,25 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "arrays_java.i";
-%include "../java_buffer.i"
-%typemap(javaimports) SWIGTYPE %{import upm_interfaces.*;%}
-%import "../interfaces/javaupm_iCO2Sensor.i"
-
-JAVA_JNI_LOADLIBRARY(javaupm_t6713)
-#endif
-/* END Java syntax */
-
-/* BEGIN Javascript syntax  ------------------------------------------------- */
-#ifdef SWIGJAVASCRIPT
-%include "../carrays_uint16_t.i"
-#endif
-/* END Javascript syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "t6713.hpp"
-%}
-%include "t6713.hpp"
-/* END Common SWIG syntax */
diff --git a/src/t6713/t6713.json b/src/t6713/t6713.json
deleted file mode 100644
index 4ee3f3c..0000000
--- a/src/t6713/t6713.json
+++ /dev/null
@@ -1,60 +0,0 @@
-{
-    "Library": "t6713",
-    "Description": "Amphenol Telaire 6713 Series CO2 Module Sensor Library",
-    "Sensor Class": {
-        "T6713": {
-            "Name": "API for the Amphenol Telaire 6713 Series CO2 Module",
-            "Description": "This is the UPM Module for the Amphenol Telaire 6713 Series CO2 Module. The new T6700 series is a miniature NDIR CO2 sensor that has accuracy and reliability of many larger sensors. The new small size allows OEM’s to integrate in to smaller enclosures and equipment and uses significantly less power than many other devices on the market.",
-            "Aliases": ["t6713", "Miniature CO2 Module Series T6700"],
-            "Categories": ["gaseous"],
-            "Connections": ["i2c"],
-            "Project Type": ["industrial", "commercial"],
-            "Manufacturers": ["Amphenol"],
-            "Examples": {
-                "C++": ["t6713-co2-sensor.cxx", "t6713.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 4.4,
-                    "max": 5.5
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "min" : 25,
-                    "max" : 200
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -10,
-                    "max": 60
-                },
-                "Detection Range": {
-                    "unit": "ppm",
-                    "min" : 400,
-                    "max" : 5000
-                },
-                "Accuracy": {
-                    "unit": "ppm",
-                    "min" : -75,
-                    "max" : 75
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need pull up resistors"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["http://amphenol-sensors.com/en/products/co2/co2-modules/3215-t6700"],
-                "Datasheets": ["http://amphenol-sensors.com/en/products/co2/co2-modules/3215-t6700#specifications-t6703"]
-            }
-        }
-    }
-}
diff --git a/src/t8100/CMakeLists.txt b/src/t8100/CMakeLists.txt
deleted file mode 100644
index 97d9b31..0000000
--- a/src/t8100/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-if (BACNET_FOUND)
-    set (libname "t8100")
-    set (libdescription "Wall Mount CO2, Humidity and Temperature Transmitter")
-    set (module_src ${libname}.cxx)
-    set (module_hpp ${libname}.hpp)
-
-    upm_module_init(bacnetmstp)
-endif ()
diff --git a/src/t8100/t8100.cxx b/src/t8100/t8100.cxx
deleted file mode 100644
index 78e5c83..0000000
--- a/src/t8100/t8100.cxx
+++ /dev/null
@@ -1,254 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <assert.h>
-#include <errno.h>
-#include <iostream>
-#include <stdexcept>
-#include <string>
-
-#include "t8100.hpp"
-
-using namespace upm;
-using namespace std;
-
-// conversion from fahrenheit to celsius and back
-
-static float f2c(float f)
-{
-  return ((f - 32.0) / (9.0 / 5.0));
-}
-
-static float c2f(float c)
-{
-  return (c * (9.0 / 5.0) + 32.0);
-}
-
-
-T8100::T8100(uint32_t targetDeviceObjectID) :
-  BACNETUTIL(targetDeviceObjectID)
-{
-  setDebug(false);
-
-  // we disable this by default for performance reasons
-  checkReliability(false);
-
-  m_isTempInitialized = false;
-  m_isCelsius = false;
-
-  m_humidity = 0.0;
-  m_temperature = 0.0;
-  m_co2 = 0.0;
-  m_relayState = false;
-}
-
-T8100::~T8100()
-{
-}
-
-void T8100::update()
-{
-  if (!m_isTempInitialized)
-    {
-      // this will update internals so conversions work properly
-      getTemperatureScale();
-    }
-
-  float tmpF = getAnalogInput(AI_Temperature_Thermistor);
-
-  if (m_isCelsius)
-    m_temperature = tmpF;
-  else
-    m_temperature = f2c(tmpF);
-
-  m_humidity = getAnalogInput(AI_Relative_Humidity);
-  m_co2 = getAnalogInput(AI_CO2);
-  m_relayState = getBinaryInput(BI_Relay_State);
-}
-
-float T8100::getTemperature(bool fahrenheit)
-{
-  if (fahrenheit)
-    return c2f(m_temperature);
-  else
-    return m_temperature;
-}
-
-void T8100::setTemperatureScale(bool fahrenheit)
-{
-  setBinaryValue(BV_Temperature_Units, fahrenheit);
-
-  m_isTempInitialized = true;
-  m_isCelsius = (fahrenheit) ? false : true;
-}
-
-bool T8100::getTemperatureScale()
-{
-  bool scale = getBinaryValue(BV_Temperature_Units);
-
-  m_isTempInitialized = true;
-  m_isCelsius = !scale;
-
-  return scale;
-}
-
-float T8100::getTemperatureOffset()
-{
-  return getAnalogValue(AV_Temperature_Offset);
-}
-
-void T8100::setTemperatureOffset(float value)
-{
-  // Always in C...
-  if (value < -50.0 || value > 50.0)
-    {
-      throw std::out_of_range(std::string(__FUNCTION__)
-                              + ": value must be between -50 and 50,"
-                              + " in degrees Celsius");
-
-    }
-
-  setAnalogValue(AV_Temperature_Offset, value);
-}
-
-float T8100::getHumidityOffset()
-{
-  return getAnalogValue(AV_RH_Offset);
-}
-
-void T8100::setHumidityOffset(float value)
-{
-  if (value < -100.0 || value > 100.0)
-    {
-      throw std::out_of_range(std::string(__FUNCTION__)
-                              + ": value must be between -100 and 100");
-    }
-
-  setAnalogValue(AV_RH_Offset, value);
-}
-
-float T8100::getRelaySetPoint()
-{
-  return getAnalogValue(AV_Relay_Set_Point);
-}
-
-void T8100::setRelaySetPoint(float value)
-{
-  if (value < 0.00 || value > 65535.0)
-    {
-      throw std::out_of_range(std::string(__FUNCTION__)
-                              + ": value must be between 0 and 65535");
-    }
-
-  setAnalogValue(AV_Relay_Set_Point, value);
-}
-
-float T8100::getRelayHysteresis()
-{
-  return getAnalogValue(AV_Relay_Hysteresis);
-}
-
-void T8100::setRelayHysteresis(float value)
-{
-  if (value < 0.00 || value > 65535.0)
-    {
-      throw std::out_of_range(std::string(__FUNCTION__)
-                              + ": value must be between 0 and 65535");
-    }
-
-  setAnalogValue(AV_Relay_Hysteresis, value);
-}
-
-float T8100::getElevation()
-{
-  return getAnalogValue(AV_Elevation);
-}
-
-void T8100::setElevation(float value)
-{
-  if (value < 0.00 || value > 65535.0)
-    {
-      throw std::out_of_range(std::string(__FUNCTION__)
-                              + ": value must be between 0 and 65535");
-    }
-
-  setAnalogValue(AV_Elevation, value);
-}
-
-float T8100::getCalibrationSinglePoint()
-{
-  return getAnalogValue(AV_Calibration_Single_Point);
-}
-
-void T8100::setCalibrationSinglePoint(float value)
-{
-  if (value < 0.00 || value > 65535.0)
-    {
-      throw std::out_of_range(std::string(__FUNCTION__)
-                              + ": value must be between 0 and 65535");
-    }
-
-  setAnalogValue(AV_Calibration_Single_Point, value);
-}
-
-float T8100::getBaudRate()
-{
-  return getAnalogValue(AV_Baud_Rate);
-}
-
-float T8100::getMACAddress()
-{
-  return getAnalogValue(AV_MAC_Address);
-}
-
-bool T8100::getABCLogicState()
-{
-  return getBinaryValue(BV_ABC_Logic_State);
-}
-
-void T8100::setABCLogicState(bool value)
-{
-  setBinaryValue(BV_ABC_Logic_State, value);
-}
-
-bool T8100::getABCLogicReset()
-{
-  return getBinaryValue(BV_ABC_Logic_Reset);
-}
-
-void T8100::setABCLogicReset(bool value)
-{
-  setBinaryValue(BV_ABC_Logic_Reset, value);
-}
-
-bool T8100::getCO2Calibration()
-{
-  return getBinaryValue(BV_CO2_Calibration);
-}
-
-void T8100::setCO2Calibration(bool value)
-{
-  setBinaryValue(BV_CO2_Calibration, value);
-}
diff --git a/src/t8100/t8100.hpp b/src/t8100/t8100.hpp
deleted file mode 100644
index 9725636..0000000
--- a/src/t8100/t8100.hpp
+++ /dev/null
@@ -1,379 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <map>
-
-#include "bacnetmstp.hpp"
-#include "bacnetutil.hpp"
-
-namespace upm {
-
-  /**
-   * @brief Amphenol Telaire Ventostat 8100 Ventilation Controller
-   * @defgroup t8100 libupm-t8100
-   * @ingroup uart temp gaseous
-   */
-
-  /**
-   * @library t8100
-   * @sensor t8100
-   * @comname Wall Mount CO2, Humidity and Temperature Transmitter
-   * Ventilation Controller
-   * @type gaseous temp
-   * @man amphenol
-   * @con uart
-   * @web https://www.instrumart.com/products/configure/18180?quantity=1
-   *
-   * @brief UPM API for the Amphenol Telaire Ventostat T8100
-   * Ventilation Controller
-   *
-   * This module implements support for the Amphenol Telaire Ventostat
-   * T8100 Ventilation Controller with BACnet interface.  It may also
-   * support the T8200 and T8300 models, but they have not been
-   * tested.
-   *
-   * The Telaire Ventostat T8100 reports Temperature, Humidity and CO2
-   * concentrations.  It supports an optional relay with a settable
-   * trigger point.  The unit this driver was tested under did not
-   * support the optional relay.  The temperature range supported is
-   * 0-50C, humidity is 0-100% non-condensing, and CO2 range is
-   * appoximately 0-2000 PPM for the T8100.  Other sensors in this
-   * family support wider ranges.
-   *
-   * This module was developed using the upm::BACNETMSTP library,
-   * based on libbacnet-stack 0.8.3.  Both libbacnet 0.8.3 and the
-   * upm::BACNETMSTP libraries must be present in order to build this
-   * module.
-   *
-   * It was connected using an RS232->RS485 interface.  You cannot use
-   * the built in MCU TTL UART pins for accessing this device -- you
-   * must use a full Serial RS232->RS485 or USB-RS485 interface
-   * connected via USB.
-   *
-   * @snippet t8100.cxx Interesting
-   */
-
-  class T8100 : public BACNETUTIL {
-  public:
-
-    // Supported Analog Value Objects.  These are readable and writable.
-    typedef enum : uint32_t {
-      AV_Temperature_Offset                   = 1,
-      AV_RH_Offset                            = 2,
-      AV_Relay_Set_Point                      = 3,
-      AV_Relay_Hysteresis                     = 4,
-      AV_Elevation                            = 5,
-      AV_Calibration_Single_Point             = 6,
-      AV_Baud_Rate                            = 7,
-      AV_MAC_Address                          = 8
-    } ANALOG_VALUES_T;
-
-    // Supported Analog Input Objects.  These are read only.
-    typedef enum : uint32_t {
-      AI_CO2                                  = 1,
-      AI_Relative_Humidity                    = 2,
-      AI_Temperature_ChipCap                  = 3,
-      AI_Temperature_Thermistor               = 4
-    } ANALOG_INPUTS_T;
-
-    // Supported Binary Value Objects.  These are readable and writable.
-    typedef enum : uint32_t {
-      BV_Temperature_Units                    = 1,
-      BV_ABC_Logic_State                      = 2,
-      BV_ABC_Logic_Reset                      = 3,
-      BV_CO2_Calibration                      = 4
-    } BINARY_VALUES_T;
-
-    // Supported Binary Input Objects.  These are read only.
-    typedef enum : uint32_t {
-      BI_Relay_State                          = 1
-    } BINARY_INPUTS_T;
-
-
-    /**
-     * T8100 constructor
-     *
-     * @param targetDeviceObjectID the unique Instance ID of the
-     * Device Object.  This number is used to uniquely identify
-     * devices on the BACnet network, and ranges from 1 to 4194302.
-     * This is not the device's MAC address, though on some devices,
-     * the MAC address may be used as part of this number.  On the
-     * T8100, this number is 568XXX, where XXX are the 3 digits of the
-     * set MAC address.  The MAC address is configured via DIP switches
-     * within the device.
-     */
-    T8100(uint32_t targetDeviceObjectID);
-
-    /**
-     * T8100 Destructor
-     */
-    ~T8100();
-
-    /**
-     * Read current values from the sensor and update internal stored
-     * values for temperature, humidity, CO2 concentration and relay
-     * state.  This method must be called prior to querying any
-     * of the aforementioned values.
-     */
-    void update();
-
-    /**
-     * Get the current relative humidity.  update() must have been
-     * called prior to calling this method.
-     *
-     * @return The last humidity reading
-     */
-    float getHumidity()
-    {
-      return m_humidity;
-    }
-
-    /**
-     * Get the current CO2 concentration in Parts per Million (PPM).
-     * update() must have been called prior to calling this method.
-     *
-     * @return The last CO2 reading
-     */
-    float getCO2()
-    {
-      return m_co2;
-    }
-
-    /**
-     * Get the current temperature.  update() must have been called
-     * prior to calling this method.
-     *
-     * @param fahrenheit true to return the temperature in degrees
-     * fahrenheit, false to return the temperature in degrees celsius.
-     * The default is false (degrees Celsius).
-     * @return The last temperature reading in Celsius or Fahrenheit.
-     */
-    float getTemperature(bool fahrenheit=false);
-
-    /**
-     * Return the current state of the relay.  This function will
-     * always return false if the relay option is not installed.
-     * update() must have been called prior to calling this method.
-     *
-     * @return true if the relay is active, false if inactive.
-     */
-    bool getRelayState()
-    {
-      return m_relayState;
-    }
-
-    /**
-     * Set the device temperature scale to Celsius of Fahrenheit.  For
-     * devices with an LCD display, this will affect which scale is
-     * displayed.  When changing the scale, it may take several
-     * seconds for the setting to take effect.
-     *
-     * @param fahrenheit true to set the scale to fahrenheit, false
-     * for celsius.
-     */
-    void setTemperatureScale(bool fahrenheit);
-
-    /**
-     * Get the device temperature scale.
-     *
-     * @return true if scale is fahrenheit, false for celsius.
-     */
-    bool getTemperatureScale();
-
-    /**
-     * Get the current temperature offset.
-     *
-     * @return The configured temperature offset.
-     */
-    float getTemperatureOffset();
-
-    /**
-     * Set the device temperature offset.  The offset is applied by
-     * the device internally to the temperature reading.  The offset
-     * must always be specified in degrees Celsius.  Valid values must
-     * be between -50 and 50.
-     *
-     * @param value The temperature offset to configure.
-     */
-    void setTemperatureOffset(float value);
-
-    /**
-     * Get the current humidity offset.
-     *
-     * @return The configured humidity offset.
-     */
-    float getHumidityOffset();
-
-    /**
-     * Set the device humidity offset.  The offset is applied by the
-     * device internally to the humidity reading.  Valid values must
-     * be between -100 and 100.
-     *
-     * @param value The humidity offset to configure.
-     */
-    void setHumidityOffset(float value);
-
-    /**
-     * Return the current relay set point (in PPM).  This set point is
-     * the CO2 concentration point in PPM that causes the relay to
-     * trigger.
-     *
-     * @return The relay set point value.
-     */
-    float getRelaySetPoint();
-
-    /**
-     * Set the relay set point in PPM.  This set point is the CO2
-     * concentration point in PPM that causes the relay to trigger.
-     * Valid values are between 0-65535.
-     *
-     * @param value The desired relay set point value.
-     */
-    void setRelaySetPoint(float value);
-
-    /**
-     * Return the current relay hysteresis.
-     *
-     * @return The relay hysteresis value.
-     */
-    float getRelayHysteresis();
-
-    /**
-     * Set the relay hysteresis.  Valid values are between 0-65535.
-     *
-     * @param value The desired relay set point value.
-     */
-    void setRelayHysteresis(float value);
-
-    /**
-     * Return the current elevation setting (in meters).
-     *
-     * @return The current elevation setting.
-     */
-    float getElevation();
-
-    /**
-     * Set the elevation setting in meters.  Valid values are between
-     * 0-65535.
-     *
-     * @param value The desired elevation setting in meters.
-     */
-    void setElevation(float value);
-
-    /**
-     * Return the current calibration single point value (in PPM).
-     *
-     * @return The current calibration single point value.
-     */
-    float getCalibrationSinglePoint();
-
-    /**
-     * Set the calibration single point value in PPM.  Valid values
-     * are between 0-65535.
-     *
-     * @param value The desired calibration single point value in PPM.
-     */
-    void setCalibrationSinglePoint(float value);
-
-    /**
-     * Return the current baud rate.
-     *
-     * @return The current baud rate.
-     */
-    float getBaudRate();
-
-    /**
-     * Return the current MAC address.  The MAC address is configured
-     * via DIP switches within the device.
-     *
-     * @return The current MAC address.
-     */
-    float getMACAddress();
-
-    /**
-     * Return the current ABC (Automatic Background Calibration)
-     * logic state.  See the datasheet for details.
-     *
-     * @return The current ABC logic state.
-     */
-    bool getABCLogicState();
-
-    /**
-     * Set the ABC (Automatic Background Calibration) logic state.
-     * Valid values are true for ON, false for OFF.
-     *
-     * @param value The desired ABC logic state.
-     */
-    void setABCLogicState(bool value);
-
-    /**
-     * Return the current ABC (Automatic Background Calibration)
-     * reset state.  See the datasheet for details.
-     *
-     * @return The current ABC reset state.
-     */
-    bool getABCLogicReset();
-
-    /**
-     * Set the ABC (Automatic Background Calibration) reset state.
-     * Valid values are true for Reset, false for Normal.
-     *
-     * @param value The desired ABC reset state.
-     */
-    void setABCLogicReset(bool value);
-
-    /**
-     * Return the current CO2 calibration state.  See the datasheet
-     * for details.
-     *
-     * @return The current CO2 calibration state.
-     */
-    bool getCO2Calibration();
-
-    /**
-     * Set the CO2 calibration state.
-     * Valid values are true for Calibrate, false for Normal.
-     *
-     * @param value The desired ABC reset state.
-     */
-    void setCO2Calibration(bool value);
-
-
-  protected:
-    float m_humidity;
-    // always stored in C
-    float m_temperature;
-    float m_co2;
-    bool m_relayState;
-
-  private:
-    // Have we checked the device's temperature unit setting yet
-    bool m_isTempInitialized;
-
-    // Is the device configured for Celsius?
-    bool m_isCelsius;
-  };
-}
diff --git a/src/t8100/t8100.i b/src/t8100/t8100.i
deleted file mode 100644
index da75752..0000000
--- a/src/t8100/t8100.i
+++ /dev/null
@@ -1,18 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_t8100)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "bacnetmstp.hpp"
-#include "bacnetutil.hpp"
-#include "t8100.hpp"
-%}
-%include "bacnetmstp.hpp"
-%include "bacnetutil.hpp"
-%include "t8100.hpp"
-/* END Common SWIG syntax */
diff --git a/src/t8100/t8100.json b/src/t8100/t8100.json
deleted file mode 100644
index 723d8fd..0000000
--- a/src/t8100/t8100.json
+++ /dev/null
@@ -1,83 +0,0 @@
-{
-    "Library": "t8100",
-    "Description": "Amphenol Telaire Ventostat T8100 Ventilation Controller Library",
-    "Sensor Class": {
-        "T8100": {
-            "Name": "API for the Amphenol Telaire Ventostat T8100 Ventilation Controller",
-            "Description": "This is the UPM Module for the Amphenol Telaire Ventostat T8100 Ventilation Controller. This module implements support for the Amphenol Telaire Ventostat T8100 Ventilation Controller with BACnet interface.  It may also support the T8200 and T8300 models, but they have not been tested. The Telaire Ventostat T8100 reports Temperature, Humidity and CO2 concentrations.  It supports an optional relay with a settable trigger point.  The unit this driver was tested under did not support the optional relay.",
-            "Aliases": ["t8100", "Telaire Ventostat Series CO2 Monitor"],
-            "Categories": ["gaseous", "temperature", "humidity"],
-            "Connections": ["uart"],
-            "Project Type": ["industrial", "commercial"],
-            "Manufacturers": ["Amphenol"],
-            "Examples": {
-                "Java": ["T8100_Example.java"],
-                "Python": ["t8100.py"],
-                "Node.js": ["t8100.js"],
-                "C++": ["t8100.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 0,
-                    "max": 10
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "min" : 4,
-                    "max" : 20
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": 0,
-                    "max": 50
-                },
-                "Temperature Sensor": {
-                    "Effective Range": {
-                        "unit": "°C",
-                        "min" : 0,
-                        "max" : 50
-                    },
-                    "Accuracy": {
-                        "unit": "°C",
-                        "min" : -0.8,
-                        "max" : 0.8
-                    }
-                },
-                "Humidity Sensor": {
-                    "Effective Range": {
-                        "unit": "RH",
-                        "min" : "0%",
-                        "max" : "99%"
-                    },
-                    "Accuracy": {
-                        "unit": "RH",
-                        "min" : "-3.5%",
-                        "max" : "3.5%"
-                    }
-                },
-                "CO2 Sensor": {
-                    "Effective Range": {
-                        "unit": "ppm",
-                        "min" : 0,
-                        "max" : 5000
-                    },
-                    "Accuracy": {
-                        "unit": "ppm",
-                        "min" : -30,
-                        "max" : 30
-                    },
-                    "Warm-up Time": {
-                        "unit": "minutes",
-                        "min" : 2,
-                        "max" : 10
-                    }
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.instrumart.com/products/18180/telaire-ventostat-series-co2-monitor"],
-                "Datasheets": ["https://www.instrumart.com/assets/Telaire_Ventostat_Wall_Mount-datasheet.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/ta12200/CMakeLists.txt b/src/ta12200/CMakeLists.txt
deleted file mode 100644
index 1ef987e..0000000
--- a/src/ta12200/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "ta12200")
-set (libdescription "AC Current Sensor")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/ta12200/ta12200.cxx b/src/ta12200/ta12200.cxx
deleted file mode 100644
index bc29c90..0000000
--- a/src/ta12200/ta12200.cxx
+++ /dev/null
@@ -1,119 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "ta12200.hpp"
-
-using namespace upm;
-using namespace std;
-
-TA12200::TA12200(int pin)
-{
-  initClock();
-
-  if ( !(m_aio = mraa_aio_init(pin)) )
-    {
-      throw std::invalid_argument(std::string(__FUNCTION__) +
-                                  ": mraa_aio_init() failed, invalid pin?");
-      return;
-    }
-}
-
-TA12200::~TA12200()
-{
-  mraa_aio_close(m_aio);
-}
-
-void TA12200::initClock()
-{
-  gettimeofday(&m_startTime, NULL);
-}
-
-uint32_t TA12200::getMillis()
-{
-  struct timeval elapsed, now;
-  uint32_t elapse;
-
-  // get current time
-  gettimeofday(&now, NULL);
-
-  // compute the delta since m_startTime
-  if( (elapsed.tv_usec = now.tv_usec - m_startTime.tv_usec) < 0 ) 
-    {
-      elapsed.tv_usec += 1000000;
-      elapsed.tv_sec = now.tv_sec - m_startTime.tv_sec - 1;
-    } 
-  else 
-    {
-      elapsed.tv_sec = now.tv_sec - m_startTime.tv_sec;
-    }
-
-  elapse = (uint32_t)((elapsed.tv_sec * 1000) + (elapsed.tv_usec / 1000));
-
-  // never return 0
-  if (elapse == 0)
-    elapse = 1;
-
-  return elapse;
-}
-
-
-int TA12200::highestValue()
-{
-  int hiVal = 0;
-  int val;
-  uint32_t start = getMillis();
-
-  // 1 second
-  while (getMillis() < (start + 1000))
-    {
-      val = mraa_aio_read(m_aio);
-      if (val == -1) {
-        return -1;
-      }
-      if (val > hiVal) {
-        hiVal = val;
-      }
-    }
-        
-  return hiVal;
-}
-
-float TA12200::milliAmps(unsigned int val, int res)
-{
-  float ampCurrent;
-  float effectiveVal;
-
-  // From grove wiki page:
-  // minimum_current=1/1024*5/800*2000000/1.414=8.6(mA) 
-  // Only for sinusoidal alternating current
-  //ampCurrent = float(val) / float(res) * 5.0 / 800.0 * 2000000.0;
-  ampCurrent = float(val) / float(res) * 12500.0;
-  effectiveVal = ampCurrent/1.414;
-  return (effectiveVal);
-}
-
diff --git a/src/ta12200/ta12200.hpp b/src/ta12200/ta12200.hpp
deleted file mode 100644
index 5e3f014..0000000
--- a/src/ta12200/ta12200.hpp
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <iostream>
-#include <stdint.h>
-#include <sys/time.h>
-#include <mraa/aio.h>
-
-// default ADC resolution. 
-#define TA12200_ADC_RES 1024
-
-namespace upm {
-/**
- * @brief TA12-200 Current Transformer
- * @defgroup ta12200 libupm-ta12200
- * @ingroup seeed analog electric
- */
-/**
- * @library ta12200
- * @sensor ta12200
- * @comname AC Current Sensor
- * @altname Grove Electricity Sensor
- * @type electric
- * @man seeed
- * @web http://www.seeedstudio.com/wiki/Grove_-_Electricity_Sensor
- * @con analog
- *
- * @brief API for the TA12-200 Current Transformer
- * 
- *   UPM module for the TA12-200 current transformer found,
- *   for instance, in the Grove Electricity Sensor. 
- *   This module can measure AC moving through a wire at up 
- *   to 5 A.
- *
- * @image html ta12200.jpg
- * @snippet ta12200.cxx Interesting
- */
-  class TA12200 {
-  public:
-    /**
-     * TA12200 constructor
-     *
-     * @param pin Analog pin to use
-     */
-    TA12200(int pin);
-
-    /**
-     * TA12200 destructor
-     */
-    ~TA12200();
-
-    /**
-     * Returns the number of milliseconds elapsed since initClock()
-     * was last called.
-     *
-     * @return Elapsed milliseconds
-     */
-    uint32_t getMillis();
-
-    /**
-     * Resets the clock
-     *
-     */
-    void initClock();
-
-    /**
-     * Gets the conversion value from the sensor
-     *
-     * @return Highest value obtained over 1 second of measuring or -1 if error
-     */
-    int highestValue();
-
-    /**
-     * Computes the measured voltage
-     *
-     * @param val Value measured by highestValue()
-     * @param res ADC resolution
-     *
-     * @return Measured current in mA
-     */
-    float milliAmps(unsigned int val, int res=TA12200_ADC_RES);
-
-  private:
-    struct timeval m_startTime;
-    mraa_aio_context m_aio;
-  };
-}
-
-
diff --git a/src/ta12200/ta12200.json b/src/ta12200/ta12200.json
deleted file mode 100644
index 300a8f0..0000000
--- a/src/ta12200/ta12200.json
+++ /dev/null
@@ -1,59 +0,0 @@
-{
-    "Library": "ta12200",
-    "Description": "Seeed TA12-200 Current Transformer library",
-    "Sensor Class": {
-        "TA12200": {
-            "Name": "API for the Seeed TA12-200 Current Transformer",
-            "Description": "This is the UPM Module for the Seeed TA12-200 Current Transformer. The Electricity sensor module is based on the TA12-200 current transformer which can change large alternating current into a small amplitude. You can use it to test large alternating current upto 5A.",
-            "Aliases": ["ta12200", "Grove - Electricity Sensor"],
-            "Categories": ["electric"],
-            "Connections": ["analog"],
-            "Project Type": ["prototyping"],
-            "Manufacturers": ["Seeed"],
-            "Image": "ta12200.jpg",
-            "Examples": {
-                "Python": ["ta12200.py"],
-                "Node.js": ["ta12200.js"],
-                "C++": ["ta12200.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min" : 3.3,
-                    "max" : 5.0
-                },
-                "Sampling Voltage": {
-                    "unit": "V",
-                    "min": 0,
-                    "max": 2
-                },
-                "Supply Current": {
-                    "unit": "A",
-                    "min" : 0,
-                    "max" : 5
-                },
-                "Output Current": {
-                    "unit": "mA",
-                    "min" : 0,
-                    "max" : 2.5
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -55,
-                    "max": 85
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-Electricity-Sensor-p-777.html", "http://wiki.seeed.cc/Grove-Electricity_Sensor/"]
-            }
-        }
-    }
-}
diff --git a/src/tb7300/CMakeLists.txt b/src/tb7300/CMakeLists.txt
deleted file mode 100644
index 2f37d68..0000000
--- a/src/tb7300/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-if (BACNET_FOUND)
-  set (libname "tb7300")
-  set (libdescription "Communicating Fan Coil Thermostat")
-  set (module_src ${libname}.cxx)
-  set (module_hpp ${libname}.hpp)
-
-  upm_module_init(bacnetmstp)
-endif ()
diff --git a/src/tb7300/tb7300.cxx b/src/tb7300/tb7300.cxx
deleted file mode 100644
index 7d11488..0000000
--- a/src/tb7300/tb7300.cxx
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <errno.h>
-#include <iostream>
-#include <stdexcept>
-#include <string>
-
-#include "tb7300.hpp"
-
-using namespace upm;
-using namespace std;
-
-// conversion from fahrenheit to celsius and back
-
-static float f2c(float f)
-{
-  return ((f - 32.0) / (9.0 / 5.0));
-}
-
-static float c2f(float c)
-{
-  return (c * (9.0 / 5.0) + 32.0);
-}
-
-
-TB7300::TB7300(uint32_t targetDeviceObjectID) :
-  BACNETUTIL(targetDeviceObjectID)
-{
-  setDebug(false);
-
-  // we disable this by default for performance reasons
-  checkReliability(false);
-
-  m_isTempInitialized = false;
-  m_isCelsius = false;
-
-  // room temperature only
-  m_temperature = 0.0;
-}
-
-TB7300::~TB7300()
-{
-}
-
-void TB7300::update()
-{
-  if (!m_isTempInitialized)
-    {
-      // this will update internals so conversions work properly
-      getTemperatureScale();
-    }
-
-  float tmpF = getAnalogValue(AV_Room_Temperature);
-
-  if (m_isCelsius)
-    m_temperature = tmpF;
-  else
-    m_temperature = f2c(tmpF);
-}
-
-float TB7300::getTemperature(bool fahrenheit)
-{
-  if (fahrenheit)
-    return c2f(m_temperature);
-  else
-    return m_temperature;
-}
-
-void TB7300::setTemperatureScale(bool fahrenheit)
-{
-  setBinaryValue(BV_Temperature_Scale, fahrenheit);
-
-  m_isTempInitialized = true;
-  m_isCelsius = (fahrenheit) ? false : true;
-}
-
-bool TB7300::getTemperatureScale()
-{
-  bool scale = getBinaryValue(BV_Temperature_Scale);
-
-  m_isTempInitialized = true;
-  m_isCelsius = !scale;
-
-  return scale;
-}
diff --git a/src/tb7300/tb7300.hpp b/src/tb7300/tb7300.hpp
deleted file mode 100644
index 4108f40..0000000
--- a/src/tb7300/tb7300.hpp
+++ /dev/null
@@ -1,258 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <map>
-
-#include "bacnetmstp.hpp"
-#include "bacnetutil.hpp"
-
-namespace upm {
-
-  /**
-   * @brief Honeywell TB7300 Communicating Fan Coil Thermostat
-   * @defgroup tb7300 libupm-tb7300
-   * @ingroup uart temp
-   */
-
-  /**
-   * @library tb7300
-   * @sensor tb7300
-   * @comname Communicating Fan Coil Thermostat
-   * Thermostat
-   * @type temp
-   * @man honeywell
-   * @con uart
-   * @web https://parts-hvac.com/tb7300c5014b.html
-   *
-   * @brief Honeywell TB7300 Communicating Fan Coil Thermostat
-   *
-   * This module implements support for the Honeywell TB7300
-   * Communicating Fan Coil Thermostat.  It may also support the
-   * TB7200, though only the TB7300 was available for development of
-   * this driver.
-   *
-   * The TB7200 Series PI thermostats are designed for zoning
-   * applications, and the TB7300 Series PI thermostats are designed
-   * for fan coil control. Both Series are communicating thermostats
-   * with models available in BACnet(r) MS/TP protocol and can be easily
-   * integrated into a WEBs-AX building automation system based on the
-   * NiagaraAX(r) platform.
-   *
-   * TB7200 and TB7300 Series thermostats are compatible with the
-   * Honeywell Occupancy Sensor Cover. Thermostats equipped with an
-   * occupancy sensor cover provide advanced active occupancy logic,
-   * which will automatically switch occupancy levels from Occupied to
-   * Stand-By and Unoccupied as required by local activity being
-   * present or not. This advanced occupancy functionality provides
-   * advantageous energy savings during occupied hours without
-   * sacrificing occupant comfort. All thermostats can be ordered with
-   * or without a factory installed PIR cover.
-   *
-   * If you intend to work with this device and driver, it is
-   * strongly suggested you get the BACnet Intergration Guide document
-   * for this device: 63-4524.pdf as recommended in the device
-   * documentation.
-   *
-   * This module was developed using the upm::BACNETMSTP library,
-   * based on libbacnet-stack 0.8.3.  Both libbacnet 0.8.3 and the
-   * upm::BACNETMSTP libraries must be present in order to build this
-   * module.
-   *
-   * It was connected using an RS232->RS485 interface.  You cannot use
-   * the built in MCU TTL UART pins for accessing this device -- you
-   * must use a full Serial RS232->RS485 or USB-RS485 interface
-   * connected via USB.
-   *
-   * @snippet tb7300.cxx Interesting
-   */
-
-  class TB7300 : public BACNETUTIL {
-  public:
-
-    // Supported Analog Value Objects.  These are readable and writable.
-    typedef enum : uint32_t {
-      AV_Room_Temperature                     = 7,
-
-      // GRP 20 Control Output
-      AV_PI_Heating_Demand                    = 21,
-      AV_PI_Cooling_Demand                    = 22,
-
-      // GRP 38 Temperature Setpoints
-      AV_Occupied_Heat_Setpoint               = 39,
-      AV_Occupied_Cool_Setpoint               = 40,
-      AV_Standby_Heat_Setpoint                = 41,
-      AV_Standby_Cool_Setpoint                = 42,
-      AV_Unoccupied_Heat_Setpoint             = 43,
-      AV_Unoccupied_Cool_Setpoint             = 44,
-
-      // GRP 55 General Options 2
-      AV_Password_Value                       = 56,
-      AV_Heating_Setpoint_Limit               = 58,
-      AV_Cooling_Setpoint_Limit               = 59,
-      AV_Deadband                             = 63,
-      AV_Standby_Time                         = 67,
-      AV_Unoccupied_Time                      = 68
-    } ANALOG_VALUES_T;
-
-    // Supported Analog Input Objects.  These are read only.
-    typedef enum : uint32_t {
-      AI_Supply_Temperature                   = 12
-    } ANALOG_INPUTS_T;
-
-    // Supported Binary Value Objects.  These are readable and writable.
-    typedef enum : uint32_t {
-      BV_Temp_Override                        = 8,
-      BV_Aux_Command                          = 14,
-
-      // GRP 45 General Options 1
-      BV_Menu_Scroll                          = 49,
-      BV_Auto_Mode_Enable                     = 50,
-      BV_Temperature_Scale                    = 51,
-
-      // GRP 55 General Option 2
-      BV_Setpoint_Type                        = 60,
-      BV_Setpoint_Function                    = 61,
-      BV_Reheat_Timebase                      = 64,
-      BV_Auto_Fan                             = 66,
-
-      // GRP 74 Output Configuration Options
-      BV_Control_type                         = 75,
-      BV_Direct_Reverse_Acting                = 78
-    } BINARY_VALUES_T;
-
-    // Supported Binary Input Objects.  These are read only.
-    typedef enum : uint32_t {
-      // GRP 24 Controller Status
-      BI_AUX_Status                           = 25,
-      BI_BI1_Status                           = 29,
-      BI_BI2_Status                           = 30,
-      BI_UI3_Status                           = 31,
-      BI_Local_Motion                         = 32,
-
-      // GRP 34 Controller Alarms
-      BI_Window_Alarm                         = 35,
-      BI_Filter_Alarm                         = 36,
-      BI_Service_Alarm                        = 37
-    } BINARY_INPUTS_T;
-
-    // Supported Multi-State Value Objects.  These are readable and
-    // writable.
-    typedef enum : uint32_t {
-      MV_Sequence_of_Operation                = 15,
-      MV_System_Mode                          = 16,
-      MV_Fan_Mode                             = 17,
-      MV_Occupancy_Command                    = 18,
-      MV_Keypad_Lockout                       = 19,
-
-      // GRP 24 Controller Status
-      MV_Heating_Valve_Status                 = 26,
-      MV_Cooling_Valve_Status                 = 27,
-      MV_Fan_Status                           = 28,
-      MV_Effective_Occupancy                  = 33,
-
-      // GRP 45 General Options 1
-      MV_BI1_Configuration                    = 46,
-      MV_BI2_Configuration                    = 47,
-      MV_UI1_Configuration                    = 48,
-      MV_Pipe_Number                          = 52,
-      MV_Out1_Config                          = 53,
-      MV_AUX_Configuration                    = 54,
-
-      // GRP 55 General Option 2
-      MV_Fan_Mode_Sequence                    = 58,
-      MV_Temporary_Occupancy_Time             = 62,
-      MV_Proportional_Band                    = 65,
-
-      // GRP 74 Output Configuration Options
-      MV_Floating_Motor_Timing                = 76,
-      MV_On_Off_Control_CPH                   = 77
-    } MULTISTATE_VALUES_T;
-
-    /**
-     * TB7300 constructor
-     *
-     * @param targetDeviceObjectID the unique Instance ID of the
-     * Device Object.  This number is used to uniquely identify
-     * devices on the BACnet network, and ranges from 1 to 4194302.
-     * This is not the device's MAC address, though on some devices,
-     * the MAC address may be used as part of this number.  On the
-     * TB7300, this number depends on the model and the MAC address.
-     */
-    TB7300(uint32_t targetDeviceObjectID);
-
-    /**
-     * TB7300 Destructor
-     */
-    ~TB7300();
-
-    /**
-     * Read current temperature from the sensor and update internal
-     * stored value.  This method must be called prior to querying the
-     * temperature.  All other values in the device must be queried
-     * directly via the appropriate BACNETUTIL::get*() methods
-     * depending on the object of interest.
-     */
-    void update();
-
-    /**
-     * Get the current temperature.  update() must have been called
-     * prior to calling this method.
-     *
-     * @param fahrenheit true to return the temperature in degrees
-     * fahrenheit, false to return the temperature in degrees celsius.
-     * The default is false (degrees Celsius).
-     * @return The last temperature reading in Celsius or Fahrenheit.
-     */
-    float getTemperature(bool fahrenheit=false);
-
-    /**
-     * Set the device temperature scale to Celsius of Fahrenheit.  For
-     * devices with an LCD display, this will affect which scale is
-     * displayed.  When changing the scale, it may take several
-     * seconds for the setting to take effect.
-     *
-     * @param fahrenheit true to set the scale to fahrenheit, false
-     * for celsius.
-     */
-    void setTemperatureScale(bool fahrenheit);
-
-    /**
-     * Get the device temperature scale.
-     *
-     * @return true if scale is fahrenheit, false for celsius.
-     */
-    bool getTemperatureScale();
-
-  protected:
-    // always stored in C
-    float m_temperature;
-
-    bool m_isTempInitialized;
-    bool m_isCelsius;
-
-  private:
-  };
-}
diff --git a/src/tb7300/tb7300.i b/src/tb7300/tb7300.i
deleted file mode 100644
index 1f1b7f6..0000000
--- a/src/tb7300/tb7300.i
+++ /dev/null
@@ -1,29 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-/* We need to use this method for enum wrapping since the enum typedefs used
- * by the derived classes (like ANALOG_VALUES_T) are passed to methods
- * in the base class which expect a uint32_t.  This is fine, and
- * works everywhere except Java.  It's type safety is a little too
- * stringent in these cases.  %javaconst(1) is generally recommended
- * as it avoids JNI calls to determine the enumerant values at
- * runtime.
- */
-%include "enumtypeunsafe.swg"
-%javaconst(1);
-
-JAVA_JNI_LOADLIBRARY(javaupm_tb7300)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "bacnetmstp.hpp"
-#include "bacnetutil.hpp"
-#include "tb7300.hpp"
-%}
-%include "bacnetmstp.hpp"
-%include "bacnetutil.hpp"
-%include "tb7300.hpp"
-/* END Common SWIG syntax */
diff --git a/src/tb7300/tb7300.json b/src/tb7300/tb7300.json
deleted file mode 100644
index 045744b..0000000
--- a/src/tb7300/tb7300.json
+++ /dev/null
@@ -1,46 +0,0 @@
-{
-    "Library": "tb7300",
-    "Description": "Honeywell TB7300 Communicating Fan Coil Thermostat Library",
-    "Sensor Class": {
-        "TB7300": {
-            "Name": "API for the Honeywell TB7300 Communicating Fan Coil Thermostat",
-            "Description": "This is the UPM Module for the Honeywell TB7300 Communicating Fan Coil Thermostat. It may also support the TB7200, though only the TB7300 was available for development of this driver. The TB7200 Series PI thermostats are designed for zoning applications, and the TB7300 Series PI thermostats are designed for fan coil control. Both Series are communicating thermostats with models available in BACnet(r) MS/TP protocol and can be easily integrated into a WEBs-AX building automation system based on the NiagaraAX(r) platform. TB7200 and TB7300 Series thermostats are compatible with the Honeywell Occupancy Sensor Cover. Thermostats equipped with an occupancy sensor cover provide advanced active occupancy logic, which will automatically switch occupancy levels from Occupied to Stand-By and Unoccupied as required by local activity being present or not. This advanced occupancy functionality provides advantageous energy savings during occupied hours without sacrificing occupant comfort. All thermostats can be ordered with or without a factory installed PIR cover.",
-            "Aliases": ["tb7300", "TB7300C5014B"],
-            "Categories": ["temperature"],
-            "Connections": ["uart"],
-            "Project Type": ["industrial", "commercial"],
-            "Manufacturers": ["honeywell"],
-            "Examples": {
-                "Java": ["TB7300_Example.java"],
-                "Python": ["tb7300.py"],
-                "Node.js": ["tb7300.js"],
-                "C++": ["tb7300.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 19,
-                    "max": 30
-                },
-                "Supply Current": {
-                    "unit": "A",
-                    "min" : 1,
-                    "max" : 3
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": 0,
-                    "max": 50
-                },
-                "Operating Humidity": {
-                    "unit": "RH",
-                    "min" : "0%",
-                    "max" : "95%"
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://parts-hvac.com/tb7300c5014b.html"]
-            }
-        }
-    }
-}
diff --git a/src/tca9548a/CMakeLists.txt b/src/tca9548a/CMakeLists.txt
deleted file mode 100644
index c4e091f..0000000
--- a/src/tca9548a/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "tca9548a")
-set (libdescription "tca9548a i2c multiplexer 8 channels")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/tca9548a/tca9548a.cxx b/src/tca9548a/tca9548a.cxx
deleted file mode 100644
index 2c02de8..0000000
--- a/src/tca9548a/tca9548a.cxx
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Author: Gerard Vidal <gerard.vidal@ens-lyon.fr>
- * Copyright (c) 2017 IFE-ENS-Lyon
- * Author: Keelan Lightfoot <keelanlightfoot@gmail.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "tca9548a.hpp"
-#include <syslog.h>
-
-#include <unistd.h>
-#include <stdexcept>
-#include <string>
-#include <string.h>
-#include <math.h>
-
-using namespace upm;
-
-TCA9548A::TCA9548A (int bus, uint8_t address){
-    m_name = "tca9548a";
-    if(!(i2c = new mraa::I2c(bus))){
-        throw std::invalid_argument(std::string(__FUNCTION__)
-                                    +": I2c.init() failed");
-        return;
-    }
-
-    if((i2c->address(address) != mraa::SUCCESS)){
-        throw std::invalid_argument(std::string(__FUNCTION__)
-                                    + ": I2c.address() failed");
-        return;
-    }
-
-    if(i2c->frequency( mraa::I2C_FAST) != mraa::SUCCESS){
-        syslog(LOG_WARNING,
-               "%s: I2c.frequency(I2C_FAST) failed, using default speed",
-               std::string(__FUNCTION__).c_str());
-    }
-}
-
-TCA9548A::~TCA9548A (){
-    delete i2c;
-}
-
-
-bool
-TCA9548A::getPort(int port) {
-    uint8_t config;
-    // Check range
-    if (!validPort(port)) {
-        throw std::invalid_argument(std::string(__FUNCTION__)
-                                    + ": port index out of range");
-        return false;
-    }
-    // Get current port configuration
-    config = getPortConfig();
-    // Check if the bit is set
-    return (config & (0x01 << port));
-}
-
-void
-TCA9548A::setPort(int port, TCA9548A_PORT_STATE state,
-                  TCA9548A_PORT_MODE mode) {
-    uint8_t config;
-    // Check range
-    if (!validPort(port)) {
-        throw std::invalid_argument(std::string(__FUNCTION__)
-                                    + ": port index out of range");
-        return;
-    }
-    // If we're enabling more than one port at a time, we need to do a
-    // read-modify-write.
-    if (mode == INCLUSIVE) {
-        config = getPortConfig();
-    } else {
-        config = TCA9548A_NO_PORTS;
-    }
-
-    // Convert port number to control byte
-    if (state == ENABLED) {
-        config |= (0x01 << port);
-    } else {
-        config &= ~(0x01 << port);
-    }
-    // Set port
-    setPortConfig(config);
-}
-
-void
-TCA9548A::disableAllPorts() {
-    // Turn off all ports
-    setPortConfig(TCA9548A_NO_PORTS);
-}
-
-void
-TCA9548A::enableAllPorts() {
-    // Turn on all ports
-    setPortConfig(TCA9548A_ALL_PORTS);
-}
-
-//Private functions
-
-uint8_t
-TCA9548A::getPortConfig() {
-    return i2c->readByte();
-}
-
-void
-TCA9548A::setPortConfig(uint8_t config) {
-    if(i2c->writeByte(config) != mraa::SUCCESS) {
-        throw std::runtime_error(std::string(__FUNCTION__)
-                                 + ": I2c.write() failed");
-        return;
-    }
-}
-
-bool
-TCA9548A::validPort(int port) {
-    return (port >= TCA9548A_MIN_PORT && port <= TCA9548A_MAX_PORT);
-}
diff --git a/src/tca9548a/tca9548a.hpp b/src/tca9548a/tca9548a.hpp
deleted file mode 100644
index ed31438..0000000
--- a/src/tca9548a/tca9548a.hpp
+++ /dev/null
@@ -1,189 +0,0 @@
-/*
- * Author: Gerard Vidal <gerard.vidal@ens-lyon.fr>
- * Copyright (c) 2017 IFE-ENS-Lyon
- * Author: Keelan Lightfoot <keelanlightfoot@gmail.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <iostream>
-#include <string>
-#include "mraa.hpp"
-#include "mraa/i2c.hpp"
-
-#define TCA9548A_I2C_BUS 0
-#define TCA9548A_DEFAULT_ADDR 0x70
-#define TCA9548A_NO_PORTS 0x00
-#define TCA9548A_ALL_PORTS 0xFF
-
-#define TCA9548A_MIN_PORT 0
-#define TCA9548A_MAX_PORT 7
-
-namespace upm {
-    /**
-     * @brief TCA9548A I2C Multiplexer
-     * @defgroup tca9548a libupm-tca9548a
-     * @ingroup adafruit i2c
-     */
-    /**
-     * @library tca9548a
-     * @sensor TCA9548A
-     * @comname 1-to-8 I2C Multiplexer Breakout
-     * @type multiplexer
-     * @man adafruit
-     * @con i2c
-     * @web https://learn.adafruit.com/adafruit-tca9548a-1-to-8-i2c-multiplexer-breakout/overview
-     *
-     * @brief API TCA9548A Multiplexer Breakout
-     *
-     * The TCA9548A device has eight bidirectional translating switches
-     * that can be controlled through the I2C bus. The SCL/SDA upstream
-     * pair fans out to eight downstream pairs, or channels. Any
-     * individual SCn/SDn channel or combination of channels can be
-     * selected, determined by the contents of the programmable control
-     * register.
-     *
-     * The TCA9548A Multiplexer Breakout enables to get - up to 8
-     * same-address I2C devices hooked up to one microcontroller - or up
-     * to 8 independent I2C buses. This multiplexer acts as a
-     * gatekeeper, shuttling the commands to the selected set of I2C
-     * pins with your command. The TCA9548A multiplexer is interesting
-     * in that it has an I2C address (0x70 by default) - and you
-     * basically send it a command to tell it which I2C multiplexed
-     * output you want to talk to, then you can address the board you
-     * want to address. You simply write a single byte with the desired
-     * multiplexed output number to that port, and bam - any future I2C
-     * packets will get sent to that port.
-     *
-     * The TCA9548A Multiplexer provides three pins (A0-A1-A2) that
-     * enable to change its address in case 0x70 address is used by
-     * another sensor on the same bus. By connecting one of the Ax pin
-     * to Vin you change its value from 0 to 1, these values change the
-     * value of the three first bits of the address :
-     *
-     * Address 0b01110-A2-A1-A0
-     *    No wiring  A2=0 A1=0 A0=0  Address 0b01110000 0x70
-     *    A0 wired   A2=0 A1=0 A0=1  Address 0b01110000 0x71
-     *    A2 wired   A2=1 A1=0 A0=0  Address 0b01110100 0x74
-     * Any address between 0x70 and 0x77 can be selected.
-     *
-     * Tested with Adafriut TCA9548A board.
-     *
-     * @image html tca9548a.jpg
-     * @snippet tca9548.cxx Interesting
-     */
-    class TCA9548A {
-
-    public:
-        /**
-         * @enum TCA9548A_PORT_STATE
-         * @brief boolean enum containing port state
-         *
-         * @var TCA9548A_PORT_STATE::DISABLED = 0
-         * @var TCA9548A_PORT_STATE::ENABLED = 1
-         */
-        typedef enum {
-            DISABLED = 0,
-            ENABLED = 1
-        } TCA9548A_PORT_STATE;
-
-        /**
-         * @enum TCA9548A_PORT_MODE
-         * @brief boolean enum containing port access mode
-         *
-         * @var TCA9548A_PORT_MODE::EXCLUSIVE = 0
-         * @var TCA9548A_PORT_MODE::INCLUSIVE = 1
-         */
-        typedef enum {
-            EXCLUSIVE = 0,
-            INCLUSIVE = 1
-        } TCA9548A_PORT_MODE;
-
-
-        /**
-         * TCA9548A constructor
-         *
-         * @param address. Device address. Default is 0x70.
-         */
-        TCA9548A (int bus, uint8_t address = 0x70);
-
-        /**
-         * TCA9548A destructor
-         */
-        ~TCA9548A();
-
-        /**
-         * Returns the name of the switch
-         */
-        std::string name() {
-            return m_name;
-        }
-
-        /**
-         * Returns the status of a port as configured in the multiplexer.
-         *
-         *  @param port Switch port to check
-         */
-        bool getPort(int port);
-
-        /**
-         *  Configure an individual port on the multiplexer
-         *
-         *  @param port Port to configure
-         *  @param enabled Set to true to enable the port, false to
-         *  disable the port.
-         *  @param exclusive Set to true to disable all other
-         *  ports, false to leave existing port config
-         *  untouched. When exclusive is set to false, an
-         *  additional i2c read is required to read the current
-         *  port setting.
-         */
-        void setPort(int port, TCA9548A_PORT_STATE state,
-                     TCA9548A_PORT_MODE mode);
-
-        /**
-         *  Disables all ports on the multiplexer.
-         */
-        void disableAllPorts();
-
-        /**
-         *  Enables all ports on the multiplexer. Useful when the
-         *  multiplexer is used to electrically extend the bus
-         *  rather than resolve address conflicts.
-         */
-        void enableAllPorts();
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        TCA9548A(const TCA9548A&) = delete;
-        TCA9548A &operator=(const TCA9548A&) = delete;
-
-        std::string m_name;
-
-        mraa::I2c* i2c;
-
-        uint8_t getPortConfig();
-        void setPortConfig(uint8_t config);
-        bool validPort(int port);
-    };
-}
diff --git a/src/tca9548a/tca9548a.json b/src/tca9548a/tca9548a.json
deleted file mode 100644
index d13da8b..0000000
--- a/src/tca9548a/tca9548a.json
+++ /dev/null
@@ -1,56 +0,0 @@
-{
-    "Library": "tca9548",
-    "Description": "TI tca9548a multiplexer library",
-    "Sensor Class": {
-        "TCA9548A": {
-            "Name": "API for the TI TCA9548A Multiplexer Breakout",
-            "Description": "This is the UPM Module for the Texas Instruments TCA9548A Multiplexer Breakout.",
-            "Aliases": ["TCA9548A", "TCA9548A I2C Multiplexer"],
-            "Categories": ["multiplexer"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["Adafruit", "Texas Instruments"],
-            "Image": "tca9548a.jpg",
-            "Examples": {
-                "Node.js": ["tca9548.js"],
-                "C++": ["tca9548a.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 1.65,
-                    "max": 5.5
-                },
-                "Supply Current": {
-                    "unit": "uA",
-                    "min" : 2,
-                    "max" : 80
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Supported Same Address i2c Devices": {
-                    "unit": "Devices",
-                    "devices": 8
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need pull up resistors"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.adafruit.com/product/2717", "https://learn.adafruit.com/adafruit-tca9548a-1-to-8-i2c-multiplexer-breakout/overview"],
-                "Datasheets": ["https://cdn-shop.adafruit.com/datasheets/tca9548a.pdf"]
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/tcs3414cs/CMakeLists.txt b/src/tcs3414cs/CMakeLists.txt
deleted file mode 100644
index 8eeed97..0000000
--- a/src/tcs3414cs/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "tcs3414cs")
-set (libdescription "I2C Color Sensor")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/tcs3414cs/tcs3414cs.cxx b/src/tcs3414cs/tcs3414cs.cxx
deleted file mode 100644
index 5894f62..0000000
--- a/src/tcs3414cs/tcs3414cs.cxx
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Credits to Seeed Studeo.
- * Based on Seeed Studeo code example,
- * http://www.seeedstudio.com/wiki/index.php?title=Twig_-_I2C_Color_Sensor_v0.9b.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <unistd.h>
-#include <stdlib.h>
-#include <stdexcept>
-
-#include "tcs3414cs.hpp"
-
-using namespace upm;
-
-TCS3414CS::TCS3414CS (int bus, int addr) : m_i2Ctx(bus) {
-    m_name = "TCS3414CS";
-
-    mraa::Result ret = m_i2Ctx.address(addr);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) + 
-                                    ": m_i2Ctx.address() failed");
-    }
-
-    // Set timing register
-    i2cWriteReg (REG_TIMING, INTEG_MODE_FREE);
-    usleep (100000);
-
-    // Set interrupt source register
-    i2cWriteReg (REG_INT_SOURCE, INT_SOURCE_GREEN);
-    usleep (100000);
-
-    // Set interrupt control register
-    i2cWriteReg (REG_INT, INTR_LEVEL | INTR_PERSIST_EVERY);
-    usleep (100000);
-
-    // Set gain
-    i2cWriteReg (REG_GAIN, GAIN_1 | PRESCALER_4);
-    usleep (100000);
-
-    // Enable ADC
-    i2cWriteReg (REG_CTL, CTL_DAT_INIITIATE);
-    usleep (100000);
-}
-
-void
-TCS3414CS::readRGB (tcs3414sc_rgb_t * rgb) {
-    uint8_t buffer[8];
-
-    // We need 7 bytes of data.
-    if (i2cReadReg_N (REG_BLOCK_READ, 8, buffer) > 7) {
-        rgb->g = buffer[1] * 256 + buffer[0];
-        rgb->r = buffer[3] * 256 + buffer[2];
-        rgb->b = buffer[5] * 256 + buffer[4];
-        rgb->clr = buffer[7] * 256 + buffer[6];
-    }
-}
-
-void
-TCS3414CS::clearInterrupt () {
-    mraa::Result error = mraa::SUCCESS;
-
-    error = m_i2Ctx.writeByte (CLR_INT);
-
-    if (error != mraa::SUCCESS) {
-        throw std::runtime_error(std::string(__FUNCTION__) + 
-                                 ": Couldn't clear interrupt");
-    }
-}
-
-/*
- * **************
- *  private area
- * **************
- */
-uint16_t
-TCS3414CS::i2cReadReg_N (int reg, unsigned int len, uint8_t * buffer) {
-    int readByte = 0;
-
-    m_i2Ctx.writeByte(reg);
-
-    readByte = m_i2Ctx.read(buffer, len);
-    return readByte;
-}
-
-mraa::Result
-TCS3414CS::i2cWriteReg_N (uint8_t reg, unsigned int len, uint8_t * buffer) {
-    mraa::Result error = mraa::SUCCESS;
-
-    error = m_i2Ctx.writeByte (reg);
-    error = m_i2Ctx.write (buffer, len);
-
-    return error;
-}
-
-mraa::Result
-TCS3414CS::i2cWriteReg (uint8_t reg, uint8_t data) {
-    mraa::Result error = mraa::SUCCESS;
-
-    error = m_i2Ctx.writeByte (reg);
-    error = m_i2Ctx.writeByte (data);
-
-    return error;
-}
diff --git a/src/tcs3414cs/tcs3414cs.hpp b/src/tcs3414cs/tcs3414cs.hpp
deleted file mode 100644
index d1bbd56..0000000
--- a/src/tcs3414cs/tcs3414cs.hpp
+++ /dev/null
@@ -1,167 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Credits to Seeed Studeo.
- * Based on Seeed Studeo code example,
- * http://www.seeedstudio.com/wiki/index.php?title=Twig_-_I2C_Color_Sensor_v0.9b.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/i2c.hpp>
-
-#define DEFAULT_ADDR                0x39 // device address
-
-#define REG_CTL                     0x80
-#define REG_TIMING                  0x81
-#define REG_INT                     0x82
-#define REG_INT_SOURCE              0x83
-#define REG_ID                      0x84
-#define REG_GAIN                    0x87
-#define REG_LOW_THRESH_LOW_BYTE     0x88
-#define REG_LOW_THRESH_HIGH_BYTE    0x89
-#define REG_HIGH_THRESH_LOW_BYTE    0x8A
-#define REG_HIGH_THRESH_HIGH_BYTE   0x8B
-#define REG_BLOCK_READ              0xCF
-#define REG_GREEN_LOW               0xD0
-#define REG_GREEN_HIGH              0xD1
-#define REG_RED_LOW                 0xD2
-#define REG_RED_HIGH                0xD3
-#define REG_BLUE_LOW                0xD4
-#define REG_BLUE_HIGH               0xD5
-#define REG_CLEAR_LOW               0xD6
-#define REG_CLEAR_HIGH              0xD7
-#define CTL_DAT_INIITIATE           0x03
-#define CLR_INT                     0xE0
-
-/* Timing Register */
-#define SYNC_EDGE                   0x40
-#define INTEG_MODE_FREE             0x00
-#define INTEG_MODE_MANUAL           0x10
-#define INTEG_MODE_SYN_SINGLE       0x20
-#define INTEG_MODE_SYN_MULTI        0x30
-
-#define INTEG_PARAM_PULSE_COUNT1    0x00
-#define INTEG_PARAM_PULSE_COUNT2    0x01
-#define INTEG_PARAM_PULSE_COUNT4    0x02
-#define INTEG_PARAM_PULSE_COUNT8    0x03
-
-/* Interrupt Control Register */
-#define INTR_STOP                   40
-#define INTR_DISABLE                0x00
-#define INTR_LEVEL                  0x10
-#define INTR_PERSIST_EVERY          0x00
-#define INTR_PERSIST_SINGLE         0x01
-
-/* Interrupt Souce Register */
-#define INT_SOURCE_GREEN            0x00
-#define INT_SOURCE_RED              0x01
-#define INT_SOURCE_BLUE             0x10
-#define INT_SOURCE_CLEAR            0x03
-
-/* Gain Register */
-#define GAIN_1                      0x00
-#define GAIN_4                      0x10
-#define GAIN_16                     0x20
-#define GANI_64                     0x30
-#define PRESCALER_1                 0x00
-#define PRESCALER_2                 0x01
-#define PRESCALER_4                 0x02
-#define PRESCALER_8                 0x03
-#define PRESCALER_16                0x04
-#define PRESCALER_32                0x05
-#define PRESCALER_64                0x06
-
-#define HIGH                        1
-#define LOW                         0
-
-namespace upm {
-
-typedef struct {
-    uint16_t r;
-    uint16_t g;
-    uint16_t b;
-    uint16_t clr;
-} tcs3414sc_rgb_t;
-
-/**
- * @brief TCS3414CS Color Sensor
- * @defgroup tcs3414cs libupm-tcs3414cs
- * @ingroup seeed i2c color
- */
-/**
- * @library tcs3414cs
- * @sensor tcs3414cs
- * @comname I2C Color Sensor
- * @altname Grove Color Sensor
- * @type color
- * @man seeed
- * @web http://www.seeedstudio.com/wiki/Grove_-_I2C_Color_Sensor
- * @con i2c
- *
- * @brief API for the TCS3414CS Color Sensor
- * 
- * This module defines the TCS3414CS interface for the color sensor
- *
- * @image html tcs3414cs.jpg
- * @snippet tcs3414cs.cxx Interesting
- */
-class TCS3414CS {
-    public:
-        /**
-         * Instantiates a TCS3414CS object
-         *
-         * @param bus Number of the used bus
-         * @param addr I2C address of the device
-         */
-        TCS3414CS (int bus = 0, int addr = DEFAULT_ADDR);
-
-        /**
-         * Gets the RGB value from the sensor.
-         *
-         * @param rgb Color values
-         */
-        void readRGB (tcs3414sc_rgb_t * rgb);
-
-        /**
-         * Clears interrupts.
-         */
-        void clearInterrupt ();
-
-        /**
-         * Returns the name of the component
-         */
-        std::string name()
-        {
-            return m_name;
-        }
-    private:
-        std::string m_name;
-        mraa::I2c m_i2Ctx;
-
-        uint16_t i2cReadReg_N (int reg, unsigned int len, uint8_t * buffer);
-        mraa::Result i2cWriteReg_N (uint8_t reg, unsigned int len, uint8_t * buffer);
-        mraa::Result i2cWriteReg (uint8_t reg, uint8_t data);
-};
-
-}
diff --git a/src/tcs3414cs/tcs3414cs.json b/src/tcs3414cs/tcs3414cs.json
deleted file mode 100644
index 2dd644c..0000000
--- a/src/tcs3414cs/tcs3414cs.json
+++ /dev/null
@@ -1,50 +0,0 @@
-{
-    "Library": "tcs3414cs",
-    "Description": "Seeed TCS3414CS Color Sensor library",
-    "Sensor Class": {
-        "TCS3414CS": {
-            "Name": "API for the Seeed TCS3414CS Color Sensor",
-            "Description": "This is the UPM Module for the Seeed TCS3414CS Color Sensor. This module is based on the color sensor TCS3414CS with digital output I2C. Based on the 8*2 array of filtered photodiodes and 16-bit analog-to-digital converters, you can measure the color chromaticity of ambient light or the color of objects. Of the 16 photodiodes, 4 have red filters, 4 have green filters, 4 have blue filters and 4 have no filter(clear). With the synchronization input pin, an external pulsed light source can provide precise synchronous conversion control.",
-            "Aliases": ["tcs3414cs"],
-            "Categories": ["light"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping"],
-            "Manufacturers": ["Seeed", "TAOS", "ams"],
-            "Image": "tcs3414cs.jpg",
-            "Examples": {
-                "Python": ["tcs3414cs.py"],
-                "Node.js": ["tcs3414cs.js"],
-                "C++": ["tcs3414cs.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.3,
-                    "max": 6.0
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "min" : 1,
-                    "max" : 12
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -30,
-                    "max": 70
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["http://wiki.seeed.cc/Grove-I2C_Color_Sensor/"],
-                "Datasheets": ["https://raw.githubusercontent.com/SeeedDocument/Grove-I2C_Color_Sensor/master/res/TCS3404_TCS3414-A.pdf", "https://github.com/SeeedDocument/Grove-I2C_Color_Sensor/raw/master/res/TCS3472%20Datasheet.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/tcs37727/CMakeLists.txt b/src/tcs37727/CMakeLists.txt
deleted file mode 100644
index 9596a70..0000000
--- a/src/tcs37727/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "tcs37727")
-set (libdescription "Color Sensor")
-set (module_src ${libname}.cpp)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/tcs37727/tcs37727.cpp b/src/tcs37727/tcs37727.cpp
deleted file mode 100644
index ff3a55e..0000000
--- a/src/tcs37727/tcs37727.cpp
+++ /dev/null
@@ -1,349 +0,0 @@
-/*
- * Author: Norbert Wesp <nwesp@phytec.de>
- * Copyright (c) 2017 Phytec Messtechnik GmbH.
- *
- * based on: RIOT-driver tcs37727 by Johann Fischer <j.fischer@phytec.de>
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include <unistd.h>
-#include <stdlib.h>
-#include <endian.h>
-
-#include "tcs37727.hpp"
-
-using namespace upm;
-
-TCS37727::TCS37727(int bus, int atime_us, int devAddr) : m_i2ControlCtx(bus) {
-    s_data->red = 0;
-    s_data->green = 0;
-    s_data->blue = 0;
-    s_data->clear = 0;
-    s_data->lux = 0;
-    s_data->ct = 0;
-    s_again = 4;
-
-    m_name = TCS37727_NAME;
-
-    m_controlAddr = devAddr;
-    m_bus = bus;
-
-    mraa::Result ret = m_i2ControlCtx.address(m_controlAddr);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_address() failed");
-    }
-
-    if (checkID() != 0) {
-        /* sensor_id does not match! maybe wrong sensor chosen? */
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": checkID() failed");
-    }
-
-    ret = m_i2ControlCtx.writeReg(TCS37727_CONTROL, TCS37727_CONTROL_AGAIN_4);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_byte_data() failed");
-    }
-
-    ret = m_i2ControlCtx.writeReg(TCS37727_ATIME,
-                                             TCS37727_ATIME_TO_REG(atime_us));
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_byte_data() failed");
-    }
-
-    s_atime_us = atime_us;
-}
-
-int
-TCS37727::checkID(void)
-{
-    uint8_t id;
-
-    id = m_i2ControlCtx.readReg(TCS37727_DEVICE_ID_REG);
-
-    if (id != TCS37727_DEVICE_ID) {
-        return -1;
-    }
-
-    return 0;
-}
-
-int
-TCS37727::setActive(void)
-{
-    uint8_t reg;
-
-    reg = m_i2ControlCtx.readReg(TCS37727_ENABLE);
-
-    reg |= (TCS37727_ENABLE_AEN | TCS37727_ENABLE_PON);
-
-    mraa::Result ret = m_i2ControlCtx.writeReg(TCS37727_ENABLE, reg);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_byte_data() failed");
-        return -1;
-    }
-    return 0;
-}
-
-int
-TCS37727::setStandby(void)
-{
-    uint8_t reg;
-
-    reg = m_i2ControlCtx.readReg(TCS37727_ENABLE);
-
-    reg &= ~TCS37727_ENABLE_AEN;
-    if (!(reg & TCS37727_ENABLE_PEN)) {
-        reg &= ~TCS37727_ENABLE_PON;
-    }
-
-    mraa::Result ret = m_i2ControlCtx.writeReg(TCS37727_ENABLE, reg);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_byte_data() failed");
-        return -1;
-    }
-    return 0;
-}
-
-uint8_t
-TCS37727::trimGain(int rawc)
-{
-    uint8_t reg_again = 0;
-    int val_again = s_again;
-    uint8_t reg;
-
-    if (rawc < TCS37727_AG_THRESHOLD_LOW) {
-        switch (val_again) {
-            case 1:
-                reg_again = TCS37727_CONTROL_AGAIN_4;
-                val_again = 4;
-                break;
-
-            case 4:
-                reg_again = TCS37727_CONTROL_AGAIN_16;
-                val_again = 16;
-                break;
-
-            case 16:
-                reg_again = TCS37727_CONTROL_AGAIN_60;
-                val_again = 60;
-                break;
-
-            case 60:
-            default:
-                return -1;
-        }
-    }
-    else if (rawc > TCS37727_AG_THRESHOLD_HIGH) {
-        switch (val_again) {
-            case 60:
-                reg_again = TCS37727_CONTROL_AGAIN_16;
-                val_again = 16;
-                break;
-
-            case 16:
-                reg_again = TCS37727_CONTROL_AGAIN_4;
-                val_again = 4;
-                break;
-
-            case 4:
-                reg_again = TCS37727_CONTROL_AGAIN_1;
-                val_again = 1;
-                break;
-
-            case 1:
-            default:
-                return -1;
-        }
-    }
-    else {
-        return 0;
-    }
-
-    reg = m_i2ControlCtx.readReg(TCS37727_CONTROL);
-
-    reg &= ~TCS37727_CONTROL_AGAIN_MASK;
-    reg |= reg_again;
-
-    mraa::Result ret = m_i2ControlCtx.writeReg(TCS37727_CONTROL, reg);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_byte_data() failed");
-        return -1;
-    }
-
-    s_again = val_again;
-
-    return 0;
-
-}
-
-int
-TCS37727::sampleData(void)
-{
-    uint8_t buf[8];
-    int num = 0;
-
-    num = m_i2ControlCtx.readBytesReg((TCS37727_INC_TRANS | TCS37727_CDATA),
-                                                                      buf, 8);
-    if (num != 8) {
-        /* not enough values were read */
-        return -1;
-    }
-
-    int32_t tmpc = ((uint16_t)buf[1] << 8) | buf[0];
-    int32_t tmpr = ((uint16_t)buf[3] << 8) | buf[2];
-    int32_t tmpg = ((uint16_t)buf[5] << 8) | buf[4];
-    int32_t tmpb = ((uint16_t)buf[7] << 8) | buf[6];
-
-    /* Remove IR component as described in the DN40.  */
-    int32_t ir = (tmpr + tmpg + tmpb - tmpc) >> 1;
-    tmpr -= ir;
-    tmpg -= ir;
-    tmpb -= ir;
-
-    /* Color temperature calculation as described in the DN40. */
-    int32_t ct = (CT_COEF_IF * tmpb) / tmpr + CT_OFFSET_IF;
-
-    /* Lux calculation as described in the DN40.  */
-    int32_t gi = R_COEF_IF * tmpr + G_COEF_IF * tmpg + B_COEF_IF * tmpb;
-    /* TODO: add Glass Attenuation Factor GA compensation */
-    int32_t cpl = (s_atime_us * s_again) / DGF_IF;
-    int32_t lux = gi / cpl;
-
-    /* Autogain */
-    trimGain(tmpc);
-
-    s_data->red = (tmpr < 0) ? 0 : (tmpr * 1000) / cpl;
-    s_data->green = (tmpg < 0) ? 0 : (tmpg * 1000) / cpl;
-    s_data->blue = (tmpb < 0) ? 0 : (tmpb * 1000) / cpl;
-    s_data->clear = (tmpb < 0) ? 0 : (tmpc * 1000) / cpl;
-    s_data->lux = (lux < 0) ? 0 : lux;
-    s_data->ct = (ct < 0) ? 0 : ct;
-
-    return 0;
-}
-
-uint32_t
-TCS37727::getChannelRed(int bSampleData)
-{
-    if (bSampleData) {
-        if (sampleData() != 0) {
-            /* error in read values from reg */
-            return 999;
-        }
-    }
-
-    return s_data->red;
-}
-
-uint32_t
-TCS37727::getChannelGreen(int bSampleData)
-{
-    if (bSampleData) {
-        if (sampleData() != 0) {
-            /* error in read values from reg */
-            return 999;
-        }
-    }
-
-    return s_data->green;
-}
-
-uint32_t
-TCS37727::getChannelBlue(int bSampleData)
-{
-    if (bSampleData) {
-        if (sampleData() != 0) {
-            /* error in read values from reg */
-            return 999;
-        }
-    }
-
-    return s_data->blue;
-}
-
-uint32_t
-TCS37727::getChannelClear(int bSampleData)
-{
-    if (bSampleData) {
-        if (sampleData() != 0) {
-            /* error in read values from reg */
-            return 999;
-        }
-    }
-
-    return s_data->clear;
-}
-
-uint32_t
-TCS37727::getLux(int bSampleData)
-{
-    if (bSampleData) {
-        if (sampleData() != 0) {
-            /* error in read values from reg */
-            return 999;
-        }
-    }
-
-    return s_data->lux;
-}
-
-uint32_t
-TCS37727::getColorTemperature(int bSampleData)
-{
-    if (bSampleData) {
-        if (sampleData() != 0) {
-            /* error in read values from reg */
-            return 999;
-        }
-    }
-
-    return s_data->ct;
-}
-
-int
-TCS37727::getData(tcs37727_data_t* data, int bSampleData)
-{
-    if (bSampleData) {
-        if (sampleData() != 0) {
-            /* error in read values from reg */
-            return -1;
-        }
-    }
-
-    data->red = s_data->red;
-    data->green = s_data->green;
-    data->blue = s_data->blue;
-    data->clear = s_data->clear;
-    data->lux = s_data->lux;
-    data->ct = s_data->ct;
-
-    return 0;
-}
diff --git a/src/tcs37727/tcs37727.hpp b/src/tcs37727/tcs37727.hpp
deleted file mode 100644
index 32b116a..0000000
--- a/src/tcs37727/tcs37727.hpp
+++ /dev/null
@@ -1,289 +0,0 @@
-/*
- * Author: Norbert Wesp <nwesp@phytec.de>
- * Copyright (c) 2017 Phytec Messtechnik GmbH.
- *
- * based on: RIOT-driver tcs37727 by Johann Fischer <j.fischer@phytec.de>
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <string>
-#include <mraa/i2c.hpp>
-#include <stdint.h>
-#include <stdbool.h>
-
-#define TCS37727_NAME "TCS37727"
-#define TCS37727_I2C_ADDRESS   0x29
-#define TCS37727_DEVICE_ID     0x49
-#define TCS37727_DEVICE_ID_REG 0x92
-
-#define TCS37727_ATIME_DEFAULT     200000  /* Default RGBC integration time */
-#define TCS37727_AG_THRESHOLD_LOW  200
-#define TCS37727_AG_THRESHOLD_HIGH (65535 - TCS37727_AG_THRESHOLD_LOW)
-
-
-/* TCS37727 Register Map */
-#define TCS37727_ENABLE  0x80 /* Enables states and interrupts */
-#define TCS37727_ATIME   0x81 /* RGBC time */
-#define TCS37727_PTIME   0x82 /* Proximity time */
-#define TCS37727_WTIME   0x83 /* Wait time */
-#define TCS37727_AILTL   0x04 /* Clear interrupt low threshold low byte */
-#define TCS37727_AILTH   0x05 /* Clear interrupt low threshold high byte */
-#define TCS37727_AIHTL   0x06 /* Clear interrupt high threshold low byte */
-#define TCS37727_AIHTH   0x07 /* Clear interrupt high threshold high byte */
-#define TCS37727_PILTL   0x08 /* Proximity inter. low threshold low byte */
-#define TCS37727_PILTH   0x09 /* Proximity inter. low threshold high byte */
-#define TCS37727_PIHTL   0x0A /* Proximity inter. high threshold low byte */
-#define TCS37727_PIHTH   0x0B /* Proximity inter. high threshold high byte */
-#define TCS37727_PERS    0x8C /* Interrupt persistence filters */
-#define TCS37727_CONFIG  0x8D /* Configuration */
-#define TCS37727_PPULSE  0x8E /* Proximity pulse count */
-#define TCS37727_CONTROL 0x8F /* Gain control register */
-#define TCS37727_STATUS  0x93 /* Device status */
-#define TCS37727_CDATA   0x14 /* Clear ADC data low byte */
-#define TCS37727_CDATAH  0x15 /* Clear ADC data high byte */
-#define TCS37727_RDATA   0x16 /* Red ADC data low byte */
-#define TCS37727_RDATAH  0x17 /* Red ADC data high byte */
-#define TCS37727_GDATA   0x18 /* Green ADC data low byte */
-#define TCS37727_GDATAH  0x19 /* Green ADC data high byte */
-#define TCS37727_BDATA   0x1A /* Blue ADC data low byte */
-#define TCS37727_BDATAH  0x1B /* Blue ADC data high byte */
-#define TCS37727_PDATA   0x1C /* Proximity ADC data low byte */
-#define TCS37727_PDATAH  0x1D /* Proximity ADC data high byte */
-
-/* TCS37727 Command Register */
-#define TCS37727_BYTE_TRANS 0x80 /* Repeated byte protocol transaction */
-#define TCS37727_INC_TRANS  0xA0 /* Auto-increment protocol transaction */
-#define TCS37727_SF_PICLR   0xE5 /* Proximity interrupt clear */
-#define TCS37727_SF_CICLR   0xE6 /* Clear channel interrupt clear */
-#define TCS37727_SF_PCICLR  0xE7 /* Proximity & Clear channel inter. clear */
-
-/* TCS37727 Enable Register */
-#define TCS37727_ENABLE_PIEN (1 << 5) /* Proximity interrupt enable */
-#define TCS37727_ENABLE_AIEN (1 << 4) /* Clear channel interrupt enable */
-#define TCS37727_ENABLE_WEN  (1 << 3) /* Wait enable */
-#define TCS37727_ENABLE_PEN  (1 << 2) /* Proximity enable */
-#define TCS37727_ENABLE_AEN  (1 << 1) /* RGBC enable, actives 2-channel ADC */
-#define TCS37727_ENABLE_PON  (1 << 0) /* Power ON */
-
-/* TCS37727 Control Register */
-#define TCS37727_CONTROL_PDRIVE_100  0x00 /* 100 mA LED Drive Strength */
-#define TCS37727_CONTROL_PDRIVE_50   0x04 /* 50 mA LED Drive Strength */
-#define TCS37727_CONTROL_PDRIVE_25   0x08 /* 25 mA LED Drive Strength */
-#define TCS37727_CONTROL_PDRIVE_12   0x0C /* 12.5 mA LED Drive Strength */
-#define TCS37727_CONTROL_PDRIVE_MASK 0x0C /* PDRIVE Mask */
-#define TCS37727_CONTROL_AGAIN_1     0x00 /* 1 x gain RGBC Gain Value */
-#define TCS37727_CONTROL_AGAIN_4     0x01 /* 4 x gain RGBC Gain Value */
-#define TCS37727_CONTROL_AGAIN_16    0x02 /* 16 x gain RGBC Gain Value */
-#define TCS37727_CONTROL_AGAIN_60    0x03 /* 60 x gain RGBC Gain Value */
-#define TCS37727_CONTROL_AGAIN_MASK  0x03 /* AGAIN Mask */
-
-/* TCS37727 ATIME register values */
-#define TCS37727_ATIME_MIN 2400   /* 2.4ms integr. time, max count 1024 */
-#define TCS37727_ATIME_MAX 614000 /* 614ms integr. time, max count 0xffff */
-
-#define TCS37727_ATIME_TO_REG(val) (256 - (uint8_t)((val) / 2400))
-#define TCS37727_ATIME_TO_US(reg)  ((256 - (uint8_t)(reg)) * 2400)
-
-/* Coefficients for Lux and CT Equations (DN40) */
-/* Coefficients in integer format, multiplied by 1000 */
-#define DGF_IF        310
-#define R_COEF_IF     136
-#define G_COEF_IF    1000
-#define B_COEF_IF    -444
-#define CT_COEF_IF   3810
-#define CT_OFFSET_IF 1391
-
-namespace upm {
-
-typedef struct {
-    uint32_t red;           /**< IR compensated channels red */
-    uint32_t green;         /**< IR compensated channels green */
-    uint32_t blue;          /**< IR compensated channels blue */
-    uint32_t clear;         /**< channels clear */
-    uint32_t lux;           /**< Lux */
-    uint32_t ct;            /**< Color temperature */
-} tcs37727_data_t;
-
-/**
- * @brief TCS37727 Color Light-To-Digital Converter
- * @defgroup tcs37727 libupm-tcs37727
- * @ingroup ams i2c color
- */
-
-/**
- * @library tcs37727
- * @sensor tcs37727
- * @comname TCS37727 Color Light-To-Digital Converter
- * @type color
- * @man ams
- * @web http://ams.com/eng/Products/Light-Sensors
- * @con i2c
- *
- * @brief API for the TCS37727 Color Light-To-Digital Converter
- *
- * Description in web-link above:
- * The TCS3772 device family provides red, green, blue, and clear (RGBC) light
- * sensing and, when coupled with an external IR LED, proximity detection.
- * These devices detect light intensity under a variety of lighting conditions
- * and through a variety of attenuation materials, including dark glass. The
- * proximity detection feature allows a large dynamic range of operation for
- * accurate short distance detection, such as in a cell phone, for detecting
- * when the user positions the phone close to their ear. An internal state
- * machine provides the ability to put the device into a low power state in
- * between proximity and RGBC measurements providing very low average power
- * consumption.
- *
- * @snippet tcs37727.cxx Interesting
- */
-class TCS37727 {
-    public:
-        /**
-         *
-         * Instantiates an TCS37727 object
-         * Settings: Gain 4x, Proximity Detection off
-         *
-         * @param bus Number of the used bus
-         * @param atime_us RGBC integration time
-         * @param devAddr Address of the used I2C device
-         */
-        TCS37727 (int bus, int atime_us=TCS37727_ATIME_DEFAULT,
-                               int devAddr=TCS37727_I2C_ADDRESS);
-
-        /**
-         * Check device_id of sensor
-         *
-         * @return  0 on success
-         *         -1 on error
-         */
-        int checkID(void);
-
-        /**
-         * Set active mode, this enables periodic RGBC measurements
-         *
-         * @return  0 on success
-         *         -1 on error
-         */
-        int setActive(void);
-
-        /**
-         * Set standby mode, this disables periodic RGBC measurements
-         * Also turns off the sensor when proximity measurement is disabled
-         *
-         * @return  0 on success
-         *         -1 on error
-         */
-        int setStandby(void);
-
-        /**
-         *
-         */
-        uint8_t trimGain(int rawc);
-
-        /**
-         * Read out data of regs and call further function
-         * Also saves converted values to variables
-         *
-         * @return  0 on success
-         *         -1 on error
-         */
-        int sampleData(void);
-
-        /**
-         * Get the calculated channel red color
-         *
-         * @param bSampleData Flag to read sensor
-         * @return The channel red color on success
-         *         999 on error
-         */
-        uint32_t getChannelRed(int bSampleData = 0);
-
-        /**
-         * Get the calculated channel green color
-         *
-         * @param bSampleData Flag to read sensor
-         * @return The channel green color on success
-         *         999 on error
-         */
-        uint32_t getChannelGreen(int bSampleData = 0);
-
-        /**
-         * Get the calculated channel blue color
-         *
-         * @param bSampleData Flag to read sensor
-         * @return The channel blue color on success
-         *         999 on error
-         */
-        uint32_t getChannelBlue(int bSampleData = 0);
-
-        /**
-         * Get the calculated channel clear color
-         *
-         * @param bSampleData Flag to read sensor
-         * @return The channel clear color on success
-         *         999 on error
-         */
-        uint32_t getChannelClear(int bSampleData = 0);
-
-        /**
-         * Get the calculated lux value
-         *
-         * @param bSampleData Flag to read sensor
-         * @return The lux value on success
-         *         999 on error
-         */
-        uint32_t getLux(int bSampleData = 0);
-
-        /**
-         * Get the calculated color temperature
-         *
-         * @param bSampleData Flag to read sensor
-         * @return The color temperature on success
-         *         999 on error
-         */
-        uint32_t getColorTemperature(int bSampleData = 0);
-
-        /**
-         * Get calculated sensor values
-         *
-         * @param data Calculated sensor values
-         * @param bSampleData Flag to read sensor
-         * @return  0 on success
-         *         -1 on error
-         */
-        int getData(tcs37727_data_t* data, int bSampleData = 0);
-
-    private:
-
-        std::string m_name;
-
-        int m_controlAddr;
-        int m_bus;
-        mraa::I2c m_i2ControlCtx;
-
-        int s_atime_us;              /* atime value conveted to microseconds */
-        int s_again;                 /* amount of gain */
-
-        tcs37727_data_t s_data[1];
-    };
-
-}
diff --git a/src/tcs37727/tcs37727.json b/src/tcs37727/tcs37727.json
deleted file mode 100644
index 434c6d7..0000000
--- a/src/tcs37727/tcs37727.json
+++ /dev/null
@@ -1,40 +0,0 @@
-{
-    "Library": "tcs37727",
-    "Description": "AMS TCS37727 Color Light-To-Digital Converter Library",
-    "Sensor Class": {
-        "TCS37727": {
-            "Name": "API for the AMS TCS37727 Color Light-To-Digital Converter",
-            "Description": "This is the UPM Module for the AMS TCS37727 Color Light-To-Digital Converter. The TCS3772 device family provides red, green, blue, and clear (RGBC) light sensing and, when coupled with an external IR LED, proximity detection. These devices detect light intensity under a variety of lighting conditions and through a variety of attenuation materials, including dark glass. The proximity detection feature allows a large dynamic range of operation for accurate short distance detection, such as in a cell phone, for detecting when the user positions the phone close to their ear. An internal state machine provides the ability to put the device into a low power state in between proximity and RGBC measurements providing very low average power consumption.",
-            "Aliases": ["tcs37727"],
-            "Categories": ["color", "light"],
-            "Connections": ["i2c"],
-            "Project Type": ["industrial", "commercial"],
-            "Manufacturers": ["AMS"],
-            "Examples": {
-                "Python": ["tcs37727.py"],
-                "C++": ["tcs37727.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 2.7,
-                    "max": 3.6
-                },
-                "Supply Current": {
-                    "unit": "uA",
-                    "min" : 2.5,
-                    "max" : 330
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -30,
-                    "max": 70
-                }
-            },
-            "Urls": {
-                "Product Pages": ["http://ams.com/eng/Products/Light-Sensors"],
-                "Datasheets": ["http://ams.com/eng/content/download/291143/1065677/file/TCS3772_DS000175_2-00.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/teams/CMakeLists.txt b/src/teams/CMakeLists.txt
deleted file mode 100644
index c469a92..0000000
--- a/src/teams/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "teams")
-set (libdescription "Veris TEAMS Temperature Transmitter")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/teams/teams.cxx b/src/teams/teams.cxx
deleted file mode 100644
index e8e8fbc..0000000
--- a/src/teams/teams.cxx
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-
-#include "teams.hpp"
-
-using namespace upm;
-using namespace std;
-
-// for current loop reads that seems a little noisy, we average over
-// several aio reads.
-static const int maxSamples = 50;
-
-// conversion from celsius to fahrenheit
-
-static float c2f(float c)
-{
-  return (c * (9.0 / 5.0) + 32.0);
-}
-
-
-TEAMS::TEAMS(int tPin, float rResistor, float aref) :
-  m_aioTemp(tPin)
-{
-  if (rResistor < 0.0)
-    {
-      throw std::out_of_range(std::string(__FUNCTION__) +
-                              ": rResistor must be >= 0.0");
-    }
-
-  m_aResTemp = (1 << m_aioTemp.getBit());
-
-  m_temperature = 0.0;
-
-  m_aref = aref;
-  m_rResistor = rResistor;
-  m_connected = false;
-
-  // this will only be non-zero when using a direct 4-20ma interface
-  // like libelium
-  m_rawMilliamps = 0.0;
-
-  m_offset = 0.0;
-}
-
-TEAMS::~TEAMS()
-{
-}
-
-void TEAMS::update()
-{
-  float milliamps = 0.0;
-
-  int val = average(maxSamples);
-  float volts = (float(val) * (m_aref / m_aResTemp));
-
-  // valid temp range is 25.0 (35C - 10C), current loop range is 16ma
-  // (20ma - 4ma)
-  if (m_rResistor)
-    {
-      // direct 4-20 current loop interface
-      milliamps = (volts / m_rResistor * 1000.0) + m_offset;
-      m_rawMilliamps = milliamps;
-
-      // subtract 0 (4ma) value
-      milliamps -= 4.0;
-      if (milliamps < 0.0) // not connected
-        {
-          milliamps = 0.0;
-          m_connected = false;
-        }
-      else
-        m_connected = true;
-
-      m_temperature = (milliamps * (25.0 / 16.0)) + 10.0;
-    }
-  else
-    {
-      // normal analog read, already scaled to 0-5v, always connected
-      m_temperature = ((volts / m_aref) * 25.0) + 10.0;
-      m_connected = true;
-    }
-}
-
-float TEAMS::getTemperature(bool fahrenheit)
-{
-  if (fahrenheit)
-    return c2f(m_temperature);
-  else
-    return m_temperature;
-}
-
-int TEAMS::average(int samples)
-{
-  if (samples <= 0)
-    samples = 1;
-
-  int avg = 0;
-  for (int i=0; i<samples; i++)
-    avg += m_aioTemp.read();
-
-  return (avg / samples);
-}
diff --git a/src/teams/teams.hpp b/src/teams/teams.hpp
deleted file mode 100644
index cd31dd6..0000000
--- a/src/teams/teams.hpp
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <iostream>
-
-#include <mraa/aio.hpp>
-
-// Unlikey to be changable
-#define TEAMS_DEFAULT_AREF 5.0
-
-namespace upm {
-    /**
-     * @brief Veris TEAMS Temperature Transmitter
-     * @defgroup teams libupm-teams
-     * @ingroup veris analog temp
-     */
-
-    /**
-     * @library teams
-     * @sensor teams
-     * @comname Veris TEAMS Temperature Transmitter
-     * @type temp
-     * @man veris
-     * @con analog
-     * @web http://www.veris.com/Item/TEAMS.aspx
-     *
-     * @brief API for the Veris TEAMS Temperature Transmitter
-     *
-     * The Veris TEAMS temperature sensor provides it's output via a
-     * 4-20ma current loop.  The supported temperature range is 10C to
-     * 35C.
-     *
-     * This sensor was developed with a Cooking Hacks (Libelium)
-     * 4-channel 4-20ma Arduino interface shield.  For this interface,
-     * the receiver resistance (rResistor) was specified as 165.0
-     * ohms.
-     *
-     * When using a 4-20ma current loop interface which scales the
-     * sensors' values to a 0-5vdc range, you can supply 0.0 as the
-     * rResistor value in the constructor (default), and it will act
-     * just like a normal analog input.
-     *
-     * @snippet teams.cxx Interesting
-     */
-
-  class TEAMS {
-  public:
-
-    /**
-     * TEAMS object constructor
-     *
-     * @param tPin Analog pin to use for temperature.
-     * @param rResistor The receiver resistance in ohms, when using a
-     * 4-20ma current loop interface.  When specified, this value will
-     * be used in computing the current based on the voltage read when
-     * scaling the return values.  Default is 0.0, for standard
-     * scaling based on voltage output rather than current (4-20ma
-     * mode).
-     * @param aref The analog reference voltage, default 5.0
-     */
-    TEAMS(int tPin, float rResistor=0.0, float aref=TEAMS_DEFAULT_AREF);
-
-    /**
-     * TEAMS object destructor
-     */
-    ~TEAMS();
-
-    /**
-     * Read current values from the sensor and update internal stored
-     * values.  This method must be called prior to querying any
-     * values, such as temperature.
-     */
-    void update();
-
-    /**
-     * Get the current temperature.  update() must have been called
-     * prior to calling this method.
-     *
-     * @param fahrenheit true to return the temperature in degrees
-     * fahrenheit, false to return the temperature in degrees celsius.
-     * The default is false (degrees Celsius).
-     * @return The last temperature reading in Celsius or Fahrenheit
-     */
-    float getTemperature(bool fahrenheit=false);
-
-    /**
-     * When using a direct 4-20ma interface (rResistor supplied in the
-     * constructor is >0.0), this function will return false when the
-     * computed milliamps falls below 4ma, indicating that the sensor
-     * is not connected.  If rResistor was specified as 0.0 in the
-     * constructor, this function will always return true.
-     *
-     * @return true if the sensor is connected, false otherwise.
-     */
-    bool isConnected()
-    {
-      return m_connected;
-    };
-
-    /**
-     * When using a direct 4-20ma interface (rResistor supplied in the
-     * constructor is >0.0), this function will return the computed
-     * milliamps (after the offset has been applied).  If rResistor was
-     * specified as 0.0 in the constructor, this function will always
-     * return 0.0.
-     *
-     * @return The last measured current in milliamps after any offset
-     * has been applied.
-     */
-    float getRawMilliamps()
-    {
-      return m_rawMilliamps;
-    };
-
-    /**
-     * Specify an offset in milliamps to be applied to the computed
-     * current prior to scaling and conversion.  This can be used to
-     * 'adjust' the computed value.  If rResistor was specified as 0.0
-     * in the constructor, this function will have no effect.
-     *
-     * @param offset a positive or negative value that will be applied
-     * to the computed current measured.
-     */
-    void setOffsetMilliamps(float offset)
-    {
-      m_offset = offset;
-    };
-
-  protected:
-    mraa::Aio m_aioTemp;
-
-  private:
-    float m_aref;
-    float m_rResistor;
-    int m_aResTemp;
-
-    // for a 4-20 ma loop
-    bool m_connected;
-    float m_rawMilliamps;
-
-    // in Celsius
-    float m_temperature;
-
-    // in case an offset should be applied to the cumputed current
-    float m_offset;
-
-    int average(int samples);
-  };
-}
-
-
diff --git a/src/teams/teams.i b/src/teams/teams.i
deleted file mode 100644
index a3cfc2f..0000000
--- a/src/teams/teams.i
+++ /dev/null
@@ -1,14 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_teams)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "teams.hpp"
-%}
-%include "teams.hpp"
-/* END Common SWIG syntax */
diff --git a/src/teams/teams.json b/src/teams/teams.json
deleted file mode 100644
index 7318624..0000000
--- a/src/teams/teams.json
+++ /dev/null
@@ -1,47 +0,0 @@
-{
-    "Library": "teams",
-    "Description": "Veris TEAMS Temperature Transmitter Library",
-    "Sensor Class": {
-        "TEAMS": {
-            "Name": "API for the Veris TEAMS Temperature Transmitter",
-            "Description": "This is the UPM Module for the Veris TEAMS Temperature Transmitter. The Veris TEAMS temperature sensor provides it's output via a 4-20ma current loop. The supported temperature range is 10C to 35C. This sensor was developed with a Cooking Hacks (Libelium) 4-channel 4-20ma Arduino interface shield.  For this interface, the receiver resistance (rResistor) was specified as 165.0 ohms. When using a 4-20ma current loop interface which scales the sensors' values to a 0-5vdc range, you can supply 0.0 as the rResistor value in the constructor (default), and it will act just like a normal analog input.",
-            "Aliases": ["teams"],
-            "Categories": ["temperature"],
-            "Connections": ["ainput"],
-            "Project Type": ["industrial", "commercial"],
-            "Manufacturers": ["Veris"],
-            "Examples": {
-                "Java": ["TEAMS_Example.java"],
-                "Python": ["teams.py"],
-                "Node.js": ["teams.js"],
-                "C++": ["teams.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 5,
-                    "max": 30
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "min" : 4,
-                    "max" : 20
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -25,
-                    "max": 105
-                },
-                "Accuracy": {
-                    "unit": "°C",
-                    "min" : -0.3,
-                    "max" : 0.3
-                }
-            },
-            "Urls": {
-                "Product Pages": ["http://www.veris.com/Item/TEAMS.aspx"],
-                "Datasheets": ["http://www.veris.com/docs/Datasheets/TW_TE_d0117.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/temperature/CMakeLists.txt b/src/temperature/CMakeLists.txt
deleted file mode 100644
index 6172b42..0000000
--- a/src/temperature/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-upm_mixed_module_init (NAME temperature
-    DESCRIPTION "Analog Temperature Sensor"
-    C_HDR temperature.h
-    C_SRC temperature.c
-    CPP_HDR temperature.hpp
-    CPP_SRC temperature.cxx
-    FTI_SRC temperature_fti.c
-    REQUIRES mraa)
diff --git a/src/temperature/temperature.c b/src/temperature/temperature.c
deleted file mode 100644
index 19e1a78..0000000
--- a/src/temperature/temperature.c
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Author: Sisinty Sasmita Patra <sisinty.s.patra@intel.com>
- *
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-
-#include <stdio.h>
-#include <stdlib.h>
-
-#include "temperature.h"
-#include "upm.h"
-
-temperature_context temperature_init(int pin)
-{
-    temperature_context dev =
-      (temperature_context)malloc(sizeof(struct _temperature_context));
-
-    if (dev == NULL) return NULL;
-
-    dev->aio = mraa_aio_init(pin);
-    if(dev->aio == NULL)
-    {
-        free(dev);
-        return NULL;
-    }
-
-    dev->m_aRes = (1 << mraa_aio_get_bit(dev->aio));
-
-    return dev;
-}
-
-void temperature_close(temperature_context dev)
-{
-    mraa_aio_close(dev->aio);
-    free(dev);
-}
-
-upm_result_t temperature_get_value(temperature_context dev,
-                                   float* tempval)
-{
-    float val = 0.0;
-    val = (float)mraa_aio_read(dev->aio);
-
-    if (val == -1.0)
-    {
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // From old C++ UPM code, needs rework!!!
-    float r = ((float)dev->m_aRes - val) * 10000.0 / val;
-    float t = 1.0 / (log(r / 10000.0) / 3975.0 + 1.0 / 298.15) -273.15;
-
-    // Celsius
-    *tempval = t;
-
-    return UPM_SUCCESS;
-}
diff --git a/src/temperature/temperature.cxx b/src/temperature/temperature.cxx
deleted file mode 100644
index 0938a23..0000000
--- a/src/temperature/temperature.cxx
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Authors: Brendan Le Foll <brendan.le.foll@intel.com>
- *          Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- *          Sarah Knepper <sarah.knepper@intel.com>
- * Copyright (c) 2014 - 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "temperature.hpp"
-#include "math.h"
-
-using namespace std;
-using namespace upm;
-
-Temperature::Temperature(unsigned int pin, float scale, int r0, int b)
-{
-    if ( !(m_aio = mraa_aio_init(pin)) ) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_aio_init() failed, invalid pin?");
-        return;
-    }
-    m_scale = scale;
-    m_r0 = r0;
-    m_b = b;
-}
-
-Temperature::~Temperature()
-{
-    mraa_aio_close(m_aio);
-}
-
-int Temperature::value ()
-{
-    float a = (float) mraa_aio_read(m_aio);
-    if (a == -1.0) return -1;
-    // Apply scale factor after error check
-    a *= m_scale;
-    float r = (float)(1023.0-a)*(float)m_r0/a;
-    float t = 1.0/(log(r/(float)m_r0)/(float)m_b + 1.0/298.15)-273.15;
-    return (int) round(t);
-}
-
-float Temperature::raw_value()
-{
-    return (float) mraa_aio_read(m_aio);
-}
diff --git a/src/temperature/temperature.h b/src/temperature/temperature.h
deleted file mode 100644
index b95ec6c..0000000
--- a/src/temperature/temperature.h
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Author: Sisinty Sasmita Patra <sisinty.s.patra@intel.com>
- *
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef TEMPERATURE_H_
-#define TEMPERATURE_H_
-
-#include <stdlib.h>
-#include <unistd.h>
-
-#include "upm.h"
-#include "mraa/aio.h"
-
-/**
- * @file temperature.h
- * @library temperature
- * @brief C API for Analog Temperature (NTC) Sensors
- *
- * @include temperature.c
- */
-
-/**
- * driver context
- */
-typedef struct _temperature_context {
-    mraa_aio_context aio;
-    int16_t m_aRes;
-} *temperature_context;
-
-/**
- * Analog temperature sensor initialization function
- *
- * @param pin analog pin to use
- * @return sensor context
- */
-temperature_context temperature_init(int pin);
-
-/**
- * Analog temperature sensor destructor
- *
- * @param dev sensor context pointer
- */
-void temperature_close(temperature_context dev);
-
-/**
- * Gets the temperature in Celsius from the sensor
- *
- * @param dev sensor context pointer
- * @param tempval temperature value in Celsius
- * @return result of the operation
- */
-upm_result_t temperature_get_value(temperature_context dev,
-                                   float* tempval);
-
-#endif /* TEMPERATURE_H_ */
diff --git a/src/temperature/temperature.hpp b/src/temperature/temperature.hpp
deleted file mode 100644
index 17a3a4d..0000000
--- a/src/temperature/temperature.hpp
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Authors: Brendan Le Foll <brendan.le.foll@intel.com>
- *          Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- *          Sarah Knepper <sarah.knepper@intel.com>
- * Copyright (c) 2014 - 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <string>
-#include <mraa/aio.hpp>
-
-namespace upm {
-/**
- * @brief NTC Temperature Sensors Library
- * @defgroup temperature libupm-temperature
- * @ingroup seeed analog temp gsk
- */
-/**
- * @library temperature
- * @sensor temperature
- * @comname Analog Temperature Sensor
- * @altname Grove Temperature Sensor
- * @type temp
- * @man seeed
- * @web http://wiki.seeed.cc/Grove-Temperature_Sensor_V1.2/
- * @con analog
- * @kit gsk
- *
- * @brief API for NTC Temperature Sensors
- *
- * Basic UPM module for analog temperature sensors. These sensors use a NTC
- * thermistor to measure ambient temperature. This driver was developed using
- * the Grove Temperature Sensor. The conversion formula has been updated
- * to work with versions 1.1 and 1.2 of the sensor. For the older v1.0
- * sensor you will have to specify R0 and B values when initializing the
- * device. The range of this sensor is -40 to 125 C and accuracy is +/- 1.5 C.
- *
- * @image html temp.jpg
- * @snippet temperature.cxx Interesting
- */
-class Temperature {
-    public:
-        /**
-         * Analog temperature sensor constructor
-         *
-         * @param pin Analog pin to use
-         * @param scale Scaling factor for raw analog value from the ADC,
-         * useful for mixed 3.3V/5V boards, default 1.0
-         * @param r0 zero power resistance, this is 100K (default) for
-         * v1.1-v1.2 and 10K for v1.0 of the sensor
-         * @param b thermistor nominal B constant, this is 4275 (default) for
-         * v1.1-v1.2 and 3975 for v1.0 of the sensor
-         */
-        Temperature(unsigned int pin, float scale = 1.0, int r0 = 100000, int b = 4275);
-        /**
-         * Analog temperature sensor destructor
-         */
-        ~Temperature();
-        /**
-         * Gets the raw value from the AIO pin
-         *
-         * @return Raw value from the ADC
-         */
-        float raw_value();
-        /** Provided for compatibility with old grove base class
-         *
-         * @return Sensor name
-         */
-        std::string name()
-        {
-            return "Temperature sensor";
-        }
-        /**
-         * Gets the temperature in Celsius from the sensor
-         *
-         * @return Normalized temperature in Celsius
-         */
-        int value();
-    private:
-        mraa_aio_context m_aio;
-        float m_scale;
-        int m_r0;
-        int m_b;
-
-};
-}
diff --git a/src/temperature/temperature.json b/src/temperature/temperature.json
deleted file mode 100644
index 6826934..0000000
--- a/src/temperature/temperature.json
+++ /dev/null
@@ -1,39 +0,0 @@
-{
-    "Library": "temperature",
-    "Description": "Temperature sensor library",
-    "Sensor Class":
-    {
-        "Temperature":
-        {
-            "Name": "Analog Temperature Sensor",
-            "Description": "Basic UPM module for analog temperature sensors. These sensors use a NTC thermistor to measure ambient temperature. This driver was developed using the Grove Temperature Sensor. The conversion formula has been updated to work with versions 1.1 and 1.2 of the sensor. For the older v1.0 sensor you will have to specify R0 and B values when initializing the device. The range of this sensor is -40 to 125 C and accuracy is +/- 1.5 C.",
-            "Aliases": ["Grove - Temperature Sensor"],
-            "Categories": ["temp"],
-            "Connections": ["analog"],
-            "Project Type": ["prototyping", "industrial"],
-            "Manufacturers": ["seeed", "dfrobot", "sparkfun", "adafruit", "generic"],
-            "Kits": ["gsk"],
-            "Image": "temp.jpg",
-            "Examples":
-            {
-                "Java": ["Temperature_Example.java"],
-                "Python": ["temperature.py"],
-                "Node.js": ["temperature.js"],
-                "C++": ["temperature.cxx"]
-            },
-            "Platforms":
-            {
-                "Arduino 101":
-                {
-                    "Notes": ["Will need to adjust ADC scale when used with Grove Base Shield (see API documentation)."]
-                }
-            },
-            "Urls" :
-            {
-                "Product Pages": ["http://wiki.seeed.cc/Grove-Temperature_Sensor_V1.2/"],
-                "Datasheets": ["https://github.com/SeeedDocument/Grove-Temperature_Sensor_V1.2/raw/master/res/NCP18WF104F03RC.pdf"],
-                "Schematics": ["https://easyeda.com/Seeed/Grove_Temperature_sensor_v1_2-ed433e462f14455e9aa38ae1a06e4680"]
-            }
-        }
-    }
-}
diff --git a/src/temperature/temperature_fti.c b/src/temperature/temperature_fti.c
deleted file mode 100644
index 19ddd52..0000000
--- a/src/temperature/temperature_fti.c
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Author: Sisinty Sasmita Patra <sisinty.s.patra@intel.com>
- *
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-
-#include<stdio.h>
-#include <stdlib.h>
-
-#include "temperature.h"
-#include "upm_fti.h"
-#include "fti/upm_sensor.h"
-
-/** 
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_temperature_name[] = "Temperature Sensor";
-const char upm_temperature_description[] = "Analog Temperature Sensor";
-const upm_protocol_t upm_temperature_protocol[] = {UPM_ANALOG};
-const upm_sensor_t upm_temperature_category[] = {UPM_TEMPERATURE};
-
-// forward declarations
-const upm_sensor_descriptor_t upm_temperature_get_descriptor();
-const void* upm_temperature_get_ft(upm_sensor_t sensor_type);
-upm_result_t upm_temperature_get_value_temperature(void* dev, float* tempval,
-                                                   upm_temperature_u unit);
-void* upm_temperature_init_name();
-void upm_temperature_close(void* dev);
-
-const upm_sensor_descriptor_t upm_temperature_get_descriptor() {
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_temperature_name;
-    usd.description = upm_temperature_description;
-    usd.protocol_size = 1;
-    usd.protocol = upm_temperature_protocol;
-    usd.category_size = 1;
-    usd.category = upm_temperature_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = &upm_temperature_init_name,
-    .upm_sensor_close = &upm_temperature_close,
-    .upm_sensor_get_descriptor = &upm_temperature_get_descriptor
-};
-
-static const upm_temperature_ft tft =
-{
-    .upm_temperature_get_value = &upm_temperature_get_value_temperature
-};
-
-const void* upm_temperature_get_ft(upm_sensor_t sensor_type) {
-    if(sensor_type == UPM_SENSOR) {
-        return &ft;
-    }
-    if(sensor_type == UPM_TEMPERATURE) {
-        return &tft;
-    }
-    return NULL;
-}
-
-void* upm_temperature_init_name(){
-    return NULL;
-}
-
-void upm_temperature_close(void* dev)
-{
-    temperature_close((temperature_context)dev);
-}
-
-upm_result_t upm_temperature_get_value_temperature(void* dev, float* tempval,
-                                                   upm_temperature_u unit)
-{
-    float temp = 0.0;
-    upm_result_t rv = temperature_get_value((temperature_context)dev, &temp);
-
-    if (rv != UPM_SUCCESS)
-        return rv;
-
-    switch (unit)
-        {
-        case CELSIUS:
-            *tempval = temp;
-            return UPM_SUCCESS;
-
-        case KELVIN:
-            *tempval = temp + 273.15;
-            return UPM_SUCCESS;
-
-        case FAHRENHEIT:
-            *tempval = temp * (9.0/5.0) + 32.0;
-            return UPM_SUCCESS;
-        }
-
-    return UPM_ERROR_INVALID_PARAMETER;
-}
diff --git a/src/tex00/CMakeLists.txt b/src/tex00/CMakeLists.txt
deleted file mode 100644
index 57d3e12..0000000
--- a/src/tex00/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "tex00")
-set (libdescription "Veris TEX00 Temperature Sensors")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/tex00/tex00.cxx b/src/tex00/tex00.cxx
deleted file mode 100644
index 95e31c6..0000000
--- a/src/tex00/tex00.cxx
+++ /dev/null
@@ -1,693 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <math.h>
-#include "tex00.hpp"
-
-using namespace upm;
-using namespace std;
-
-// we average over several aio reads.
-static const int maxSamples = 10;
-
-// conversion from celsius to fahrenheit
-
-static float c2f(float c)
-{
-  return (c * (9.0 / 5.0) + 32.0);
-}
-
-
-TEX00::TEX00(int tPin, float balanceResistor, SENSOR_TYPES_T stype, 
-             float aref) :
-  m_aioTemp(tPin)
-{
-  m_aResTemp = (1 << m_aioTemp.getBit());
-
-  m_temperature = 0.0;
-  m_outOfRange = false;
-
-  m_aref = aref;
-  m_balanceResistor = balanceResistor;
-
-  // set default to NTC, however per-sensor init functions should set
-  // properly for the relevant sensor
-  m_isNTC = true;
-  
-  switch (stype)
-    {
-    case STYPE_THERMISTOR_TED:
-      initThermistorTED();
-      break;
-
-    case STYPE_THERMISTOR_TEB:
-      initThermistorTEB();
-      break;
-
-    case STYPE_THERMISTOR_TEC:
-      initThermistorTEC();
-      break;
-
-    case STYPE_THERMISTOR_TEI:
-      initThermistorTEI();
-      break;
-
-    case STYPE_THERMISTOR_TEE:
-      initThermistorTEE();
-      break;
-
-    case STYPE_THERMISTOR_TEF:
-      initThermistorTEF();
-      break;
-
-    case STYPE_THERMISTOR_TEH:
-      initThermistorTEH();
-      break;
-
-    case STYPE_THERMISTOR_TEJ:
-      initThermistorTEJ();
-      break;
-
-    case STYPE_THERMISTOR_TES:
-      initThermistorTES();
-      break;
-
-    case STYPE_THERMISTOR_TER:
-      initThermistorTER();
-      break;
-
-    case STYPE_THERMISTOR_TEM:
-      initThermistorTEM();
-      break;
-
-    case STYPE_THERMISTOR_TEU:
-      initThermistorTEU();
-      break;
-
-    case STYPE_THERMISTOR_TET:
-      initThermistorTET();
-      break;
-
-    default:
-      throw std::logic_error(std::string(__FUNCTION__) +
-                             ": internal error: invalid stype");
-    }
-}
-
-TEX00::~TEX00()
-{
-}
-
-void TEX00::update()
-{
-  int val = average(maxSamples);
-
-  // now determine the resistance of the sensor (this is a voltage divider)
-  float resistance = m_balanceResistor / 
-    ((float(m_aResTemp - 1) / float(val)) - 1.0);
-  
-  //  cerr << "Val = " << val << ", resistance = " << resistance << endl;
-
-  m_temperature = thermistor(resistance);
-}
-
-float TEX00::getTemperature(bool fahrenheit)
-{
-  if (fahrenheit)
-    return c2f(m_temperature);
-  else
-    return m_temperature;
-}
-
-int TEX00::average(int samples)
-{
-  if (samples <= 0)
-    samples = 1;
-  
-  int avg = 0;
-  for (int i=0; i<samples; i++)
-    avg += m_aioTemp.read();
-  
-  return (avg / samples);
-}
-
-float TEX00::thermistor(float ohms)
-{
-  // sanity check
-  if (m_tempVector.empty())
-    {
-      throw std::logic_error(std::string(__FUNCTION__) +
-                             ": internal error: temperature table is empty");
-    }
-
-  int found = -1;
-  int next = -1;
-  
-  if (m_isNTC)
-    {
-      // reverse search
-      for (int i=m_tempVector.size() - 1; i>=0; i--)
-        if (ohms < m_tempVector[i].ohms)
-          {
-            found = i;
-            next = found + 1;
-            break;
-          }
-    }
-  else
-    {
-      // PTC
-      for (size_t i=0; i<m_tempVector.size(); i++)
-        if (ohms < m_tempVector[i].ohms)
-          {
-            found = i;
-            next = found - 1;
-            break;
-          }
-    }
-
-  if (found < 0 || next < 0 || 
-      found >= static_cast<int>(m_tempVector.size()) ||
-      next >= static_cast<int>(m_tempVector.size()))
-    {
-      m_outOfRange = true;
-      // return last measured temperature
-      return m_temperature;
-    }
-  else
-    m_outOfRange = false;
-  
-  // calculate the percentages of ohms and temp
-  float diffO = m_tempVector[found].ohms - m_tempVector[next].ohms;
-  ohms -= m_tempVector[next].ohms;
-  
-  diffO = ohms / diffO;
-  
-  float diffT;
-  if (m_isNTC)
-    diffT = m_tempVector[next].temp - m_tempVector[found].temp;
-  else
-    diffT = m_tempVector[found].temp - m_tempVector[next].temp;
-
-  // compute offset
-  float tempOffset = fabs(diffT * diffO);
-
-  // apply according to NTC or PTC
-  if (m_isNTC)
-    return m_tempVector[next].temp - tempOffset;
-  else
-    return m_tempVector[next].temp + tempOffset;
-}
-
-float TEX00::getTemperatureRangeMin()
-{
-  if (m_tempVector.empty())
-    {
-      throw std::logic_error(std::string(__FUNCTION__) +
-                             ": internal error: temperature table is empty");
-    }
-
-  return m_tempVector[0].temp;
-}
-
-float TEX00::getTemperatureRangeMax()
-{
-  if (m_tempVector.empty())
-    {
-      throw std::logic_error(std::string(__FUNCTION__) +
-                             ": internal error: temperature table is empty");
-    }
-
-  return m_tempVector[m_tempVector.size() - 1].temp;
-}
-
-
-void TEX00::initThermistorTED()
-{
-  // this is an NTC type thermistor
-  m_isNTC = true;
-
-  // This data comes from the Veris TW_TE_d0116.pdf datasheet for the
-  // "D" (10K type 2) column
-
-  // clear and initialize the vector, ordered from lowest to highest
-  // temperature
-  m_tempVector.clear();
-
-  //                               ohms      temperature (C)
-  m_tempVector.push_back(tempEntry(692700,   -50));
-  m_tempVector.push_back(tempEntry(344700,   -40));
-  m_tempVector.push_back(tempEntry(180100,   -30));
-  m_tempVector.push_back(tempEntry(98320,    -20));
-  m_tempVector.push_back(tempEntry(55790,    -10));
-  m_tempVector.push_back(tempEntry(32770,    0));
-  m_tempVector.push_back(tempEntry(19930,    10));
-  m_tempVector.push_back(tempEntry(12500,    20));
-  m_tempVector.push_back(tempEntry(10000,    25));
-  m_tempVector.push_back(tempEntry(8055,     30));
-  m_tempVector.push_back(tempEntry(5323,     40));
-  m_tempVector.push_back(tempEntry(3599,     50));
-  m_tempVector.push_back(tempEntry(2486,     60));
-  m_tempVector.push_back(tempEntry(1753,     70));
-  m_tempVector.push_back(tempEntry(1258,     80));
-  m_tempVector.push_back(tempEntry(919,      90));
-  m_tempVector.push_back(tempEntry(682,      100));
-  m_tempVector.push_back(tempEntry(513,      110));
-  m_tempVector.push_back(tempEntry(392,      120));
-  m_tempVector.push_back(tempEntry(303,      130));
-}
-
-void TEX00::initThermistorTEB()
-{
-  // this is a PTC type thermistor
-  m_isNTC = false;
-
-  // This data comes from the Veris TW_TE_d0116.pdf datasheet for the
-  // "B" (100 Ohm) column
-
-  // clear and initialize the vector, ordered from lowest to highest
-  // temperature
-  m_tempVector.clear();
-
-  //                               ohms        temperature (C)
-  m_tempVector.push_back(tempEntry(80.306,     -50));
-  m_tempVector.push_back(tempEntry(84.271,     -40));
-  m_tempVector.push_back(tempEntry(88.222,     -30));
-  m_tempVector.push_back(tempEntry(92.160,     -20));
-  m_tempVector.push_back(tempEntry(96.086,     -10));
-  m_tempVector.push_back(tempEntry(100,        0));
-  m_tempVector.push_back(tempEntry(103.903,    10));
-  m_tempVector.push_back(tempEntry(107.794,    20));
-  m_tempVector.push_back(tempEntry(109.735,    25));
-  m_tempVector.push_back(tempEntry(111.673,    30));
-  m_tempVector.push_back(tempEntry(115.541,    40));
-  m_tempVector.push_back(tempEntry(119.397,    50));
-  m_tempVector.push_back(tempEntry(123.242,    60));
-  m_tempVector.push_back(tempEntry(127.075,    70));
-  m_tempVector.push_back(tempEntry(130.897,    80));
-  m_tempVector.push_back(tempEntry(134.707,    90));
-  m_tempVector.push_back(tempEntry(138.506,    100));
-  m_tempVector.push_back(tempEntry(142.293,    110));
-  m_tempVector.push_back(tempEntry(146.068,    120));
-  m_tempVector.push_back(tempEntry(149.332,    130));
-}
-
-void TEX00::initThermistorTEC()
-{
-  // this is a PTC type thermistor
-  m_isNTC = false;
-
-  // This data comes from the Veris TW_TE_d0116.pdf datasheet for the
-  // "C" (1000 Ohm) column
-
-  // clear and initialize the vector, ordered from lowest to highest
-  // temperature
-  m_tempVector.clear();
-
-  //                               ohms        temperature (C)
-  m_tempVector.push_back(tempEntry(803.06,     -50));
-  m_tempVector.push_back(tempEntry(842.71,     -40));
-  m_tempVector.push_back(tempEntry(882.22,     -30));
-  m_tempVector.push_back(tempEntry(921.60,     -20));
-  m_tempVector.push_back(tempEntry(960.86,     -10));
-  m_tempVector.push_back(tempEntry(1000,       0));
-  m_tempVector.push_back(tempEntry(1039.03,    10));
-  m_tempVector.push_back(tempEntry(1077.94,    20));
-  m_tempVector.push_back(tempEntry(1097.35,    25));
-  m_tempVector.push_back(tempEntry(1116.73,    30));
-  m_tempVector.push_back(tempEntry(1155.41,    40));
-  m_tempVector.push_back(tempEntry(1193.97,    50));
-  m_tempVector.push_back(tempEntry(1232.42,    60));
-  m_tempVector.push_back(tempEntry(1270.75,    70));
-  m_tempVector.push_back(tempEntry(1308.97,    80));
-  m_tempVector.push_back(tempEntry(1347.07,    90));
-  m_tempVector.push_back(tempEntry(1385.06,    100));
-  m_tempVector.push_back(tempEntry(1422.93,    110));
-  m_tempVector.push_back(tempEntry(1460.68,    120));
-  m_tempVector.push_back(tempEntry(1493.32,    130));
-}
-
-void TEX00::initThermistorTEI()
-{
-  // this is a PTC type thermistor
-  m_isNTC = false;
-
-  // This data comes from the Veris TW_TE_d0116.pdf datasheet for the
-  // "I" (1000 Ohm) column
-
-  // clear and initialize the vector, ordered from lowest to highest
-  // temperature
-  m_tempVector.clear();
-
-  //                               ohms        temperature (C)
-  m_tempVector.push_back(tempEntry(740.46,     -50));
-  m_tempVector.push_back(tempEntry(773.99,     -40));
-  m_tempVector.push_back(tempEntry(806.02,     -30));
-  m_tempVector.push_back(tempEntry(841,        -20));
-  m_tempVector.push_back(tempEntry(877.76,     -10));
-  m_tempVector.push_back(tempEntry(913.66,     0));
-  m_tempVector.push_back(tempEntry(952.25,     10));
-  m_tempVector.push_back(tempEntry(991.82,     20));
-  m_tempVector.push_back(tempEntry(1013.50,    25));
-  m_tempVector.push_back(tempEntry(1035.18,    30));
-  m_tempVector.push_back(tempEntry(1077.68,    40));
-  m_tempVector.push_back(tempEntry(1120.52,    50));
-  m_tempVector.push_back(tempEntry(1166.13,    60));
-  m_tempVector.push_back(tempEntry(1210.75,    70));
-  m_tempVector.push_back(tempEntry(1254.55,    80));
-  m_tempVector.push_back(tempEntry(1301.17,    90));
-  m_tempVector.push_back(tempEntry(1348.38,    100));
-  m_tempVector.push_back(tempEntry(1397.13,    110));
-  m_tempVector.push_back(tempEntry(1447.44,    120));
-  m_tempVector.push_back(tempEntry(1496.28,    130));
-}
-
-void TEX00::initThermistorTEE()
-{
-  // this is an NTC type thermistor
-  m_isNTC = true;
-
-  // This data comes from the Veris TW_TE_d0116.pdf datasheet for the
-  // "E" (2.2k Ohm) column
-
-  // clear and initialize the vector, ordered from lowest to highest
-  // temperature
-  m_tempVector.clear();
-
-  //                               ohms        temperature (C)
-  m_tempVector.push_back(tempEntry(154464,     -50));
-  m_tempVector.push_back(tempEntry(77081,      -40));
-  m_tempVector.push_back(tempEntry(40330,      -30));
-  m_tempVector.push_back(tempEntry(22032,      -20));
-  m_tempVector.push_back(tempEntry(12519,      -10));
-  m_tempVector.push_back(tempEntry(7373,       0));
-  m_tempVector.push_back(tempEntry(4487,       10));
-  m_tempVector.push_back(tempEntry(2814,       20));
-  m_tempVector.push_back(tempEntry(2252,       25));
-  m_tempVector.push_back(tempEntry(1814,       30));
-  m_tempVector.push_back(tempEntry(1199,       40));
-  m_tempVector.push_back(tempEntry(811.5,      50));
-  m_tempVector.push_back(tempEntry(561,        60));
-  m_tempVector.push_back(tempEntry(395.5,      70));
-  m_tempVector.push_back(tempEntry(284,        80));
-  m_tempVector.push_back(tempEntry(207.4,      90));
-  m_tempVector.push_back(tempEntry(153.8,      100));
-  m_tempVector.push_back(tempEntry(115.8,      110));
-  m_tempVector.push_back(tempEntry(88.3,       120));
-  m_tempVector.push_back(tempEntry(68.3,       130));
-}
-
-void TEX00::initThermistorTEF()
-{
-  // this is an NTC type thermistor
-  m_isNTC = true;
-
-  // This data comes from the Veris TW_TE_d0116.pdf datasheet for the
-  // "F" (3k Ohm) column
-
-  // clear and initialize the vector, ordered from lowest to highest
-  // temperature
-  m_tempVector.clear();
-
-  //                               ohms        temperature (C)
-  m_tempVector.push_back(tempEntry(205800,     -50));
-  m_tempVector.push_back(tempEntry(102690,     -40));
-  m_tempVector.push_back(tempEntry(53730,      -30));
-  m_tempVector.push_back(tempEntry(29346,      -20));
-  m_tempVector.push_back(tempEntry(16674,      -10));
-  m_tempVector.push_back(tempEntry(9822,       0));
-  m_tempVector.push_back(tempEntry(5976,       10));
-  m_tempVector.push_back(tempEntry(3750,       20));
-  m_tempVector.push_back(tempEntry(3000,       25));
-  m_tempVector.push_back(tempEntry(2417,       30));
-  m_tempVector.push_back(tempEntry(1598,       40));
-  m_tempVector.push_back(tempEntry(1081,       50));
-  m_tempVector.push_back(tempEntry(747,        60));
-  m_tempVector.push_back(tempEntry(527,        70));
-  m_tempVector.push_back(tempEntry(378,        80));
-}
-
-void TEX00::initThermistorTEH()
-{
-  // this is an NTC type thermistor
-  m_isNTC = true;
-
-  // This data comes from the Veris TW_TE_d0116.pdf datasheet for the
-  // "H" (10k Type 3) column
-
-  // clear and initialize the vector, ordered from lowest to highest
-  // temperature
-  m_tempVector.clear();
-
-  //                               ohms        temperature (C)
-  m_tempVector.push_back(tempEntry(454910,     -50));
-  m_tempVector.push_back(tempEntry(245089,     -40));
-  m_tempVector.push_back(tempEntry(137307,     -30));
-  m_tempVector.push_back(tempEntry(79729,      -20));
-  m_tempVector.push_back(tempEntry(47843,      -10));
-  m_tempVector.push_back(tempEntry(29588,      0));
-  m_tempVector.push_back(tempEntry(18813,      10));
-  m_tempVector.push_back(tempEntry(12272,      20));
-  m_tempVector.push_back(tempEntry(10000,      25));
-  m_tempVector.push_back(tempEntry(8195,       30));
-  m_tempVector.push_back(tempEntry(5593,       40));
-  m_tempVector.push_back(tempEntry(3894,       50));
-  m_tempVector.push_back(tempEntry(2763,       60));
-  m_tempVector.push_back(tempEntry(1994,       70));
-  m_tempVector.push_back(tempEntry(1462,       80));
-  m_tempVector.push_back(tempEntry(1088,       90));
-  m_tempVector.push_back(tempEntry(821,        100));
-  m_tempVector.push_back(tempEntry(628,        110));
-  m_tempVector.push_back(tempEntry(486,        120));
-  m_tempVector.push_back(tempEntry(380,        130));
-}
-
-void TEX00::initThermistorTEJ()
-{
-  // this is an NTC type thermistor
-  m_isNTC = true;
-
-  // This data comes from the Veris TW_TE_d0116.pdf datasheet for the
-  // "J" (10k Dale) column
-
-  // clear and initialize the vector, ordered from lowest to highest
-  // temperature
-  m_tempVector.clear();
-
-  //                               ohms        temperature (C)
-  m_tempVector.push_back(tempEntry(672300,     -50));
-  m_tempVector.push_back(tempEntry(337200,     -40));
-  m_tempVector.push_back(tempEntry(177200,     -30));
-  m_tempVector.push_back(tempEntry(97130,      -20));
-  m_tempVector.push_back(tempEntry(55340,      -10));
-  m_tempVector.push_back(tempEntry(32660,      0));
-  m_tempVector.push_back(tempEntry(19900,      10));
-  m_tempVector.push_back(tempEntry(12490,      20));
-  m_tempVector.push_back(tempEntry(10000,      25));
-  m_tempVector.push_back(tempEntry(8056,       30));
-  m_tempVector.push_back(tempEntry(5326,       40));
-  m_tempVector.push_back(tempEntry(3602,       50));
-  m_tempVector.push_back(tempEntry(2489,       60));
-  m_tempVector.push_back(tempEntry(1753,       70));
-  m_tempVector.push_back(tempEntry(1258,       80));
-  m_tempVector.push_back(tempEntry(917,        90));
-  m_tempVector.push_back(tempEntry(679,        100));
-  m_tempVector.push_back(tempEntry(511,        110));
-  m_tempVector.push_back(tempEntry(389,        120));
-  m_tempVector.push_back(tempEntry(301,        130));
-}
-
-void TEX00::initThermistorTES()
-{
-  // this is an NTC type thermistor
-  m_isNTC = true;
-
-  // This data comes from the Veris TW_TE_d0116.pdf datasheet for the
-  // "S" (10k 3A221) column
-
-  // clear and initialize the vector, ordered from lowest to highest
-  // temperature
-  m_tempVector.clear();
-
-  //                               ohms        temperature (C)
-  m_tempVector.push_back(tempEntry(333562,     -40));
-  m_tempVector.push_back(tempEntry(176081,     -30));
-  m_tempVector.push_back(tempEntry(96807,      -20));
-  m_tempVector.push_back(tempEntry(55252,      -10));
-  m_tempVector.push_back(tempEntry(32639,      0));
-  m_tempVector.push_back(tempEntry(19901,      10));
-  m_tempVector.push_back(tempEntry(12493,      20));
-  m_tempVector.push_back(tempEntry(10000,      25));
-  m_tempVector.push_back(tempEntry(8055,       30));
-  m_tempVector.push_back(tempEntry(5324,       40));
-  m_tempVector.push_back(tempEntry(3600,       50));
-  m_tempVector.push_back(tempEntry(2486,       60));
-  m_tempVector.push_back(tempEntry(1751,       70));
-  m_tempVector.push_back(tempEntry(1255,       80));
-  m_tempVector.push_back(tempEntry(915,        90));
-  m_tempVector.push_back(tempEntry(678,        100));
-  m_tempVector.push_back(tempEntry(509,        110));
-  m_tempVector.push_back(tempEntry(388,        120));
-  m_tempVector.push_back(tempEntry(299,        130));
-}
-
-void TEX00::initThermistorTER()
-{
-  // this is an NTC type thermistor
-  m_isNTC = true;
-
-  // This data comes from the Veris TW_TE_d0116.pdf datasheet for the
-  // "R" (10k "G" US) column
-
-  // clear and initialize the vector, ordered from lowest to highest
-  // temperature
-  m_tempVector.clear();
-
-  //                               ohms        temperature (C)
-  m_tempVector.push_back(tempEntry(441200,     -50));
-  m_tempVector.push_back(tempEntry(239700,     -40));
-  m_tempVector.push_back(tempEntry(135300,     -30));
-  m_tempVector.push_back(tempEntry(78910,      -20));
-  m_tempVector.push_back(tempEntry(47540,      -10));
-  m_tempVector.push_back(tempEntry(29490,      0));
-  m_tempVector.push_back(tempEntry(18780,      10));
-  m_tempVector.push_back(tempEntry(12260,      20));
-  m_tempVector.push_back(tempEntry(10000,      25));
-  m_tempVector.push_back(tempEntry(8194,       30));
-  m_tempVector.push_back(tempEntry(5592,       40));
-  m_tempVector.push_back(tempEntry(3893,       50));
-  m_tempVector.push_back(tempEntry(2760,       60));
-  m_tempVector.push_back(tempEntry(1990,       70));
-  m_tempVector.push_back(tempEntry(1458,       80));
-  m_tempVector.push_back(tempEntry(1084,       90));
-  m_tempVector.push_back(tempEntry(816.8,      100));
-  m_tempVector.push_back(tempEntry(623.6,      110));
-  m_tempVector.push_back(tempEntry(481.8,      120));
-  m_tempVector.push_back(tempEntry(376.4,      130));
-}
-
-void TEX00::initThermistorTEM()
-{
-  // this is an NTC type thermistor
-  m_isNTC = true;
-
-  // This data comes from the Veris TW_TE_d0116.pdf datasheet for the
-  // "M" (20k NTC) column
-
-  // clear and initialize the vector, ordered from lowest to highest
-  // temperature
-  m_tempVector.clear();
-
-  //                               ohms        temperature (C)
-  m_tempVector.push_back(tempEntry(1267600,    -50));
-  m_tempVector.push_back(tempEntry(643800,     -40));
-  m_tempVector.push_back(tempEntry(342000,     -30));
-  m_tempVector.push_back(tempEntry(189080,     -20));
-  m_tempVector.push_back(tempEntry(108380,     -10));
-  m_tempVector.push_back(tempEntry(64160,      0));
-  m_tempVector.push_back(tempEntry(38440,      10));
-  m_tempVector.push_back(tempEntry(24920,      20));
-  m_tempVector.push_back(tempEntry(20000,      25));
-  m_tempVector.push_back(tempEntry(16144,      30));
-  m_tempVector.push_back(tempEntry(10696,      40));
-  m_tempVector.push_back(tempEntry(7234,       50));
-  m_tempVector.push_back(tempEntry(4992,       60));
-  m_tempVector.push_back(tempEntry(3512,       70));
-  m_tempVector.push_back(tempEntry(2516,       80));
-  m_tempVector.push_back(tempEntry(1833,       90));
-  m_tempVector.push_back(tempEntry(1356,       100));
-  m_tempVector.push_back(tempEntry(1016,       110));
-  m_tempVector.push_back(tempEntry(770,        120));
-  m_tempVector.push_back(tempEntry(591,        130));
-}
-
-void TEX00::initThermistorTEU()
-{
-  // this is an NTC type thermistor
-  m_isNTC = true;
-
-  // This data comes from the Veris TW_TE_d0116.pdf datasheet for the
-  // "U" (20k "D") column
-
-  // clear and initialize the vector, ordered from lowest to highest
-  // temperature
-  m_tempVector.clear();
-
-  //                               ohms        temperature (C)
-  m_tempVector.push_back(tempEntry(803200,     -40));
-  m_tempVector.push_back(tempEntry(412800,     -30));
-  m_tempVector.push_back(tempEntry(220600,     -20));
-  m_tempVector.push_back(tempEntry(112400,     -10));
-  m_tempVector.push_back(tempEntry(70200,      0));
-  m_tempVector.push_back(tempEntry(41600,      10));
-  m_tempVector.push_back(tempEntry(25340,      20));
-  m_tempVector.push_back(tempEntry(20000,      25));
-  m_tempVector.push_back(tempEntry(15884,      30));
-  m_tempVector.push_back(tempEntry(10210,      40));
-  m_tempVector.push_back(tempEntry(6718,       50));
-  m_tempVector.push_back(tempEntry(4518,       60));
-  m_tempVector.push_back(tempEntry(3100,       70));
-  m_tempVector.push_back(tempEntry(2168,       80));
-  m_tempVector.push_back(tempEntry(1542,       90));
-  m_tempVector.push_back(tempEntry(1134,       100));
-  m_tempVector.push_back(tempEntry(816,        110));
-  m_tempVector.push_back(tempEntry(606,        120));
-  m_tempVector.push_back(tempEntry(456,        130));
-}
-
-void TEX00::initThermistorTET()
-{
-  // this is an NTC type thermistor
-  m_isNTC = true;
-
-  // This data comes from the Veris TW_TE_d0116.pdf datasheet for the
-  // "T" (100k) column
-
-  // clear and initialize the vector, ordered from lowest to highest
-  // temperature
-  m_tempVector.clear();
-
-  //                               ohms        temperature (C)
-  m_tempVector.push_back(tempEntry(3366000,    -40));
-  m_tempVector.push_back(tempEntry(1770000,    -30));
-  m_tempVector.push_back(tempEntry(971200,     -20));
-  m_tempVector.push_back(tempEntry(553400,     -10));
-  m_tempVector.push_back(tempEntry(326600,     0));
-  m_tempVector.push_back(tempEntry(199000,     10));
-  m_tempVector.push_back(tempEntry(124900,     20));
-  m_tempVector.push_back(tempEntry(100000,     25));
-  m_tempVector.push_back(tempEntry(80580,      30));
-  m_tempVector.push_back(tempEntry(53260,      40));
-  m_tempVector.push_back(tempEntry(36020,      50));
-  m_tempVector.push_back(tempEntry(24880,      60));
-  m_tempVector.push_back(tempEntry(17510,      70));
-  m_tempVector.push_back(tempEntry(12560,      80));
-  m_tempVector.push_back(tempEntry(9164,       90));
-  m_tempVector.push_back(tempEntry(6792,       100));
-  m_tempVector.push_back(tempEntry(5108,       110));
-  m_tempVector.push_back(tempEntry(3894,       120));
-  m_tempVector.push_back(tempEntry(3006,       130));
-}
-
diff --git a/src/tex00/tex00.hpp b/src/tex00/tex00.hpp
deleted file mode 100644
index 2bcc6db..0000000
--- a/src/tex00/tex00.hpp
+++ /dev/null
@@ -1,216 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <iostream>
-#include <vector>
-
-#include <mraa/aio.hpp>
-
-#define TEX00_DEFAULT_AREF 5.0
-
-namespace upm {
-    /**
-     * @brief Veris TEX00 Temperature Sensor
-     * @defgroup tex00 libupm-tex00
-     * @ingroup veris analog temp 
-     */
-
-    /**
-     * @library tex00
-     * @sensor tex00
-     * @comname Veris TEX00 Temperature Sensors
-     * @type temp
-     * @man veris
-     * @con analog
-     * @web http://www.veris.com/Item/TED00.aspx
-     *
-     * @brief API for the Veris TEX00 Temperature Sensor
-     *
-     * The Veris TEX00 temperature sensor family is made up of a
-     * series of RTD thermistors in wall mount packaging.  
-     * 
-     * This driver was developed using the TED00, which utilizes a 10K
-     * Ohm Type 2 thermistor.  However, this driver can support the
-     * other 12 variants of the TE series as well by providing the
-     * correct sensor type to the class constructor.  These other
-     * sensor types have not been tested.  Only the TED00 was tested
-     * with this driver.
-     *
-     * This sensor must be connected as part of a voltage divider,
-     * with the balancing resistor ideally matched to the sensor's 25C
-     * detection range.  For the TED00 (10kt2), a 10K Ohm (1%
-     * tolerance) resistor was used in a circuit like the following:
-     *
-     * GND o----|TED00(10k2)|----o----|balanceResistor(10K)|----o VCC (+5vdc)
-     *                           |
-     *                           |
-     *                           |----o A0 (analog input to MCU)
-     *
-     * A 3.3vdc voltage can be used as well if desired.
-     *
-     * @snippet tex00.cxx Interesting
-     */
-
-  class TEX00 {
-  public:
-
-    typedef enum {
-      STYPE_THERMISTOR_TED               = 0, // 10k type 2
-      STYPE_THERMISTOR_TEB,                   // 100 Ohm
-      STYPE_THERMISTOR_TEC,                   // 1000 Ohm
-      STYPE_THERMISTOR_TEI,                   // 1000 Ohm
-      STYPE_THERMISTOR_TEE,                   // 2.2k
-      STYPE_THERMISTOR_TEF,                   // 3k
-      STYPE_THERMISTOR_TEH,                   // 10k type 3
-      STYPE_THERMISTOR_TEJ,                   // 10k Dale
-      STYPE_THERMISTOR_TES,                   // 10k 3A221
-      STYPE_THERMISTOR_TER,                   // 10k "G" US
-      STYPE_THERMISTOR_TEM,                   // 20k NTC
-      STYPE_THERMISTOR_TEU,                   // 20k "D"
-      STYPE_THERMISTOR_TET                    // 100k
-    } SENSOR_TYPES_T;
-
-    /**
-     * TEX00 object constructor
-     *
-     * @param tPin Analog pin to use for temperature.
-     * @param balanceResistor Resistance (in Ohms) of the balance
-     * resistor used in your voltage divider.
-     * @param stype The sensor type.  One of the SENSOR_TYPES_T values.
-     * @param aref The analog reference voltage, default 5.0
-     */
-    TEX00(int tPin, float balanceResistor, SENSOR_TYPES_T stype,
-          float aref=TEX00_DEFAULT_AREF);
-
-    /**
-     * TEX00 object destructor
-     */
-    ~TEX00();
-
-    /**
-     * Read current values from the sensor and update internal stored
-     * values.  This method must be called prior to querying any
-     * values, such as temperature.
-     */
-    void update();
-
-    /**
-     * Get the current temperature.  update() must have been called
-     * prior to calling this method.
-     *
-     * @param fahrenheit true to return the temperature in degrees
-     * fahrenheit, false to return the temperature in degrees celsius.
-     * The default is false (degrees Celsius).
-     * @return The last temperature reading in Celsius or Fahrenheit
-     */
-    float getTemperature(bool fahrenheit=false);
-
-    /**
-     * Return the smallest temperature that can be measured by the
-     * current sensor.
-     *
-     * @return The smallest detectable temperature this sensor can
-     * measure, in C.
-     */
-    float getTemperatureRangeMin();
-
-    /**
-     * Return the largest temperature that can be measured by the
-     * current sensor.  
-     *
-     * @return The largest detectable temperature this sensor can
-     * measure, in C.
-     */
-    float getTemperatureRangeMax();
-
-    /**
-     * Detect whether the last measurement exceeded the sensors
-     * detection range.  update() must have been called prior to
-     * calling this method.
-     *
-     * @return true if the last measurement was out of range, false
-     * otherwise.
-     */
-    bool isOutOfRange()
-    {
-      return m_outOfRange;
-    }
-
-  protected:
-    mraa::Aio m_aioTemp;
-
-    // compute the temperature based on the resistance of the thermistor
-    float thermistor(float ohms);
-
-  private:
-    float m_aref;
-    int m_aResTemp;
-
-    // in Celsius
-    float m_temperature;
-    // temp reading out of range
-    bool m_outOfRange;
-
-    // resistance of the other half of our voltage divider
-    float m_balanceResistor;
-
-    int average(int samples);
-
-    // Negative Temperature Coefficient (NTC) or Positive Temperature
-    // Coefficient (PTC)
-    bool m_isNTC;
-
-    // This may generate a SWIG warning.  It can be safely ignored
-    // since this structure is never exposed outside the class.
-    struct tempEntry
-    {
-      tempEntry(float o, float t) : ohms(o), temp(t) {};
-      
-      float ohms;
-      float temp; // in C
-    };
-
-    // ohms/temperature table store
-    std::vector<tempEntry> m_tempVector;
-
-    // table temperature init functions
-    void initThermistorTED();
-    void initThermistorTEB();
-    void initThermistorTEC();
-    void initThermistorTEI();
-    void initThermistorTEE();
-    void initThermistorTEF();
-    void initThermistorTEH();
-    void initThermistorTEJ();
-    void initThermistorTES();
-    void initThermistorTER();
-    void initThermistorTEM();
-    void initThermistorTEU();
-    void initThermistorTET();
-  };
-}
-
-
diff --git a/src/tex00/tex00.i b/src/tex00/tex00.i
deleted file mode 100644
index 1497f2a..0000000
--- a/src/tex00/tex00.i
+++ /dev/null
@@ -1,14 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_tex00)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "tex00.hpp"
-%}
-%include "tex00.hpp"
-/* END Common SWIG syntax */
diff --git a/src/tex00/tex00.json b/src/tex00/tex00.json
deleted file mode 100644
index 629bda5..0000000
--- a/src/tex00/tex00.json
+++ /dev/null
@@ -1,52 +0,0 @@
-{
-    "Library": "tex00",
-    "Description": "Veris TEX00 Temperature Sensor Library",
-    "Sensor Class": {
-        "TEX00": {
-            "Name": "API for the Veris TEX00 Temperature Sensor",
-            "Description": "This is the UPM Module for the Veris TEX00 Temperature Sensor. The Veris TEX00 temperature sensor family is made up of a series of RTD thermistors in wall mount packaging.    This driver was developed using the TED00, which utilizes a 10K Ohm Type 2 thermistor.  However, this driver can support the other 12 variants of the TE series as well by providing the correct sensor type to the class constructor.  These other sensor types have not been tested.  Only the TED00 was tested with this driver.",
-            "Aliases": ["tex00", "TED00"],
-            "Categories": ["temperature"],
-            "Connections": ["ainput"],
-            "Project Type": ["industrial", "commercial"],
-            "Manufacturers": ["Veris"],
-            "Examples": {
-                "Java": ["TEX00_Example.java"],
-                "Python": ["tex00.py"],
-                "Node.js": ["tex00.js"],
-                "C++": ["tex00.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 5,
-                    "max": 30
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "min" : 4,
-                    "max" : 20
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -25,
-                    "max": 105
-                },
-                "Effective Range": {
-                    "unit": "°C",
-                    "min" : 10,
-                    "max" : 35
-                },
-                "Offset Temperature": {
-                    "unit": "+/-°C",
-                    "min" : 1.8,
-                    "max" : 3.0
-                }
-            },
-            "Urls": {
-                "Product Pages": ["http://www.veris.com/Item/TED00.aspx"],
-                "Datasheets": ["http://www.veris.com/docs/Datasheets/TW_TE_d0117.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/th02/CMakeLists.txt b/src/th02/CMakeLists.txt
deleted file mode 100644
index 5ac30bf..0000000
--- a/src/th02/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "th02")
-set (libdescription "Temperature and Humidity Sensor Pro")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/th02/th02.cxx b/src/th02/th02.cxx
deleted file mode 100644
index 5e79e06..0000000
--- a/src/th02/th02.cxx
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Contributions: Jon Trulson <jtlulson@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Credits to Seeed Studeo.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <unistd.h>
-#include <stdlib.h>
-#include <stdexcept>
-
-#include "th02.hpp"
-
-using namespace std;
-using namespace upm;
-
-TH02::TH02 (int bus, uint8_t addr) : m_i2c(bus) {
-    m_addr = addr;
-    m_name = "TH02";
-
-    mraa::Result ret = m_i2c.address(m_addr);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) + 
-                                    ": mraa_i2c_address() failed");
-    }
-}
-
-TH02::~TH02 () {
-}
-
-float
-TH02::getTemperature () {
-    uint16_t temperature = 0;
-
-    /* Start a new temperature conversion */
-    if (m_i2c.writeReg(TH02_REG_CONFIG, TH02_CMD_MEASURE_TEMP)) {
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": I2c.writeReg() failed");
-        return 0.0;
-    }
-
-    /* Wait until conversion is done */
-    while (getStatus() == false);
-
-    temperature = m_i2c.readReg(TH02_REG_DATA_H) << 8;
-    temperature |= m_i2c.readReg(TH02_REG_DATA_L);
-    temperature >>= 2;
-
-    return ((float(temperature) / 32.0) - 50.0);
-}
-
-float
-TH02::getHumidity () {
-    uint16_t humidity = 0;
-
-    /* Start a new humidity conversion */
-    if (m_i2c.writeReg(TH02_REG_CONFIG, TH02_CMD_MEASURE_HUMI)) {
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": I2c.writeReg() failed");
-        return 0.0;
-    }
-
-    /* Wait until conversion is done */
-    while (getStatus() == false);
-
-    humidity = m_i2c.readReg(TH02_REG_DATA_H) << 8;
-    humidity |= m_i2c.readReg(TH02_REG_DATA_L);
-    humidity >>= 4;
-
-    return ((float(humidity) / 16.0) - 24.0);
-}
-
-bool
-TH02::getStatus () {
-    uint8_t status = m_i2c.readReg(TH02_REG_STATUS);
-
-    if (status & TH02_STATUS_RDY_MASK)
-        return false;           // NOT ready
-    else
-        return true;            // ready
-}
-
diff --git a/src/th02/th02.hpp b/src/th02/th02.hpp
deleted file mode 100644
index 45a0f1d..0000000
--- a/src/th02/th02.hpp
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Contributions: Jon Trulson <jtlulson@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Credits to Seeed Studeo.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/i2c.hpp>
-
-#define TH02_ADDR                0x40 // device address
-
-#define TH02_REG_STATUS          0x00
-#define TH02_REG_DATA_H          0x01
-#define TH02_REG_DATA_L          0x02
-#define TH02_REG_CONFIG          0x03
-#define TH02_REG_ID              0x11
-
-#define TH02_STATUS_RDY_MASK     0x01
-
-#define TH02_CMD_MEASURE_HUMI    0x01
-#define TH02_CMD_MEASURE_TEMP    0x11
-
-namespace upm {
-
-/**
- * @brief TH02 Temperature & Humidity Sensor
- * @defgroup th02 libupm-th02
- * @ingroup seeed i2c temp
- */
-/**
- * @library th02
- * @sensor th02
- * @comname Temperature and Humidity Sensor Pro
- * @altname Grove Temperature & Humidity Sensor (High-Accuracy & Mini)
- * @type temp
- * @man seeed
- * @web http://www.seeedstudio.com/wiki/Grove_-_Tempture%26Humidity_Sensor_(High-Accuracy_%26Mini)_v1.0
- * @con i2c
- *
- * @brief API for the TH02 Temperature & Humidity Sensor
- * 
- *   This module defines the TH02 interface for libth02 
- *
- *   Note: For use on Intel(R) Edison with an Arduino* breakout board, Intel
- *   Edison must be set to 3 V rather than 5 V.
- *
- * @image html th02.jpg
- * @snippet th02.cxx Interesting
- */
-class TH02 {
-    public:
-        /**
-         * Instantiates a TH02 object
-         */
-        TH02 (int bus=0, uint8_t addr=TH02_ADDR);
-
-        /**
-         * TH02 object destructor; basically, it closes the I2C connection.
-         */
-        ~TH02 ();
-
-        /**
-         * Gets the temperature value from the sensor.
-         */
-        float getTemperature ();
-
-        /**
-         * Gets the humidity value from the sensor.
-         */
-        float getHumidity ();
-
-        /**
-         * Gets the sensor status.
-         */
-        bool getStatus ();
-
-        /**
-         * Returns the name of the component
-         */
-        std::string name()
-        {
-            return m_name;
-        }
-
-    private:
-        std::string m_name;
-        mraa::I2c m_i2c;
-        uint8_t m_addr;
-};
-
-}
diff --git a/src/th02/th02.json b/src/th02/th02.json
deleted file mode 100644
index 97c399e..0000000
--- a/src/th02/th02.json
+++ /dev/null
@@ -1,77 +0,0 @@
-{
-    "Library": "th02",
-    "Description": "Seeed TH02 Temperature & Humidity Sensor Library",
-    "Sensor Class": {
-        "TH02": {
-            "Name": "API for the Seeed TH02 Temperature & Humidity Sensor",
-            "Description": "This is the UPM Module for the Seeed TH02 Temperature & Humidity Sensor. This is a multifunctional sensor that gives you temperature and relative humidity information at the same time. It utilizes a TH02 sensor that can meet measurement needs of general purposes. It provides reliable readings when environment humidity condition inbetween 0-80% RH, and temperature condition inbetween 0-70°C, covering needs in most home and daily applications that don't contain extreme conditions.",
-            "Aliases": ["th02", "Grove - Temperature&Humidity Sensor (High-Accuracy & Mini)"],
-            "Categories": ["humidity", "temperature"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["Seeed"],
-            "Image": "th02.jpg",
-            "Examples": {
-                "Java": ["Th02_Example.java"],
-                "C++": ["th02.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.3,
-                    "max": 5.0
-                },
-                "Supply Current": {
-                    "unit": "uA",
-                    "min" : 24,
-                    "max" : 565
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Humidity Sensor": {
-                    "Effective Range": {
-                        "unit": "%RH",
-                        "min" : 20,
-                        "max" : 80
-                    },
-                    "Accuracy": {
-                        "unit": "-/+ %RH",
-                        "min" : 3.0,
-                        "max" : 4.5
-                    }
-                },
-                "Temperature Sensor": {
-                    "Effective Range": {
-                        "unit": "°C",
-                        "min" : 0,
-                        "max" : 70
-                    },
-                    "Resolution": {
-                        "unit": "°C",
-                        "resolution": "1/32"
-                    },
-                    "Accuracy": {
-                        "unit": "+/- °C",
-                        "min" : 0.5,
-                        "max" : 1.0
-                    }
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield", "Must be set to 3 V rather than 5 V."]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-Temperature%26Humidity-Sensor-(High-Accuracy-%26-Mini)-p-1921.html", "http://wiki.seeed.cc/Grove-TemptureAndHumidity_Sensor-High-Accuracy_AndMini-v1.0/"],
-                "Datasheets": ["https://raw.githubusercontent.com/SeeedDocument/Grove-TemptureAndHumidity_Sensor-High-Accuracy_AndMini-v1.0/master/res/TH02_SENSOR.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/tm1637/CMakeLists.txt b/src/tm1637/CMakeLists.txt
deleted file mode 100644
index 337c521..0000000
--- a/src/tm1637/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "tm1637")
-set (libdescription "C++ API for the TM1637 7-segment Display")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/tm1637/tm1637.cxx b/src/tm1637/tm1637.cxx
deleted file mode 100644
index ef895da..0000000
--- a/src/tm1637/tm1637.cxx
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- * Author: Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string>
-#include <stdexcept>
-#include "tm1637.hpp"
-#include <stdarg.h>
-
-const uint8_t m_brkt[2]  = {0x39, 0x0f};
-const uint8_t m_nums[10] = {0x3f, 0x06, 0x5b, 0x4f, 0x66,
-                            0x6d, 0x7d, 0x07, 0x7f, 0x6f};
-const uint8_t m_char[26] = {0x77, 0x7c, 0x39, 0x5e, 0x79,
-                            0x71, 0x6f, 0x76, 0x30, 0x1e,
-                            0x00, 0x38, 0x00, 0x00, 0x5c,
-                            0x73, 0x67, 0x50, 0x5b, 0x78,
-                            0x3e, 0x1c, 0x00, 0x00, 0x6e,
-                            0x5b};
-
-using namespace std;
-using namespace upm;
-
-upm::TM1637::TM1637(int clk_pin, int dio_pin, int bright) {
-
-    if((m_clk = mraa_gpio_init(clk_pin)) == NULL){
-       throw std::invalid_argument(std::string(__FUNCTION__) +
-                                   ": mraa_gpio_init(clk) failed, invalid pin?");
-       return;
-    }
-
-    if((m_dio = mraa_gpio_init(dio_pin)) == NULL){
-       throw std::invalid_argument(std::string(__FUNCTION__) +
-                                   ": mraa_gpio_init(dio) failed, invalid pin?");
-       return;
-    }
-
-    mraa_gpio_dir(m_clk, MRAA_GPIO_OUT);
-    mraa_gpio_dir(m_dio, MRAA_GPIO_OUT);
-
-    // Let the resistors pull the lines high
-    mraa_gpio_mode(m_clk, MRAA_GPIO_PULLUP);
-    mraa_gpio_mode(m_dio, MRAA_GPIO_PULLUP);
-
-    mraa_gpio_write(m_clk, 0);
-    mraa_gpio_write(m_dio, 0);
-
-    for (int i = 0; i < M_DISPLAY_DIGITS; i++) {
-        m_digits[i] = 0x00;
-    }
-    setBrightness(bright);
-}
-upm::TM1637::~TM1637() {
-    for (int i = 0; i < M_DISPLAY_DIGITS; i++) {
-        m_digits[i] = 0x00;
-    }
-    update();
-
-    mraa_gpio_close(m_clk);
-    mraa_gpio_close(m_dio);
-}
-mraa_result_t upm::TM1637::write(uint8_t *digits) {
-    for (int i = 0; i < M_DISPLAY_DIGITS; i++) {
-        m_digits[i] = digits[i];
-    }
-    update();
-    return MRAA_SUCCESS;
-}
-mraa_result_t upm::TM1637::write(int d, ...) {
-    va_list args;
-    va_start(args, d);
-    m_digits[0] = (uint8_t)d;
-
-    for (int i = 1; i < M_DISPLAY_DIGITS; i++) {
-        m_digits[i] = (uint8_t)va_arg(args, int);
-        d++;
-    }
-    va_end(args);
-    update();
-    return MRAA_SUCCESS;
-}
-mraa_result_t upm::TM1637::writeAt(int index, char symbol) {
-    if(index < 0 || index >= M_DISPLAY_DIGITS){
-        cerr << "TM1637: invalid index in " << __FUNCTION__ << endl;
-        return MRAA_ERROR_INVALID_PARAMETER;
-    }
-    m_digits[index] = encode(symbol);
-    update();
-    return MRAA_SUCCESS;
-}
-mraa_result_t upm::TM1637::write(std::string digits) {
-    int len = digits.length();
-    if( len > M_DISPLAY_DIGITS){
-        len = M_DISPLAY_DIGITS;
-    }
-    for (int i = 0; i < len; i++) {
-        m_digits[i] = encode(digits[i]);
-    }
-    update();
-    return MRAA_SUCCESS;
-}
-void upm::TM1637::setColon(bool value) {
-    if(value){
-       m_digits[1] |= 0x80;
-    }
-    else{
-       m_digits[1] &= 0x7f;
-    }
-    update();
-}
-void upm::TM1637::setBrightness(int value) {
-    m_brightness = value & 0x07;
-    update();
-}
-void upm::TM1637::i2c_start() {
-    mraa_gpio_write(m_clk, 1);
-    mraa_gpio_write(m_dio, 1);
-    mraa_gpio_write(m_dio, 0);
-}
-void upm::TM1637::i2c_stop() {
-    mraa_gpio_write(m_clk, 0);
-    mraa_gpio_write(m_dio, 0);
-    mraa_gpio_write(m_clk, 1);
-    mraa_gpio_write(m_dio, 1);
-}
-void upm::TM1637::i2c_writeByte(uint8_t value) {
-    for(uint8_t i = 0; i < 8; i++)
-    {
-        mraa_gpio_write(m_clk, 0);
-        if(value & 0x01)
-            mraa_gpio_write(m_dio, 1);
-        else
-            mraa_gpio_write(m_dio, 0);
-        value >>= 1;
-        mraa_gpio_write(m_clk, 1);
-    }
-
-    // Ack clock without skew, TM1637 is fast enough
-    mraa_gpio_write(m_clk, 0);
-    mraa_gpio_write(m_clk, 1);
-    mraa_gpio_write(m_clk, 0);
-}
-void upm::TM1637::update() {
-    i2c_start();
-    i2c_writeByte(TM1637_ADDR);
-    i2c_stop();
-
-    i2c_start();
-    i2c_writeByte(TM1637_REG);
-    for (int i = 0; i < M_DISPLAY_DIGITS; i++) {
-        i2c_writeByte(m_digits[i]);
-    }
-    i2c_stop();
-
-    i2c_start();
-    i2c_writeByte(TM1637_CMD | m_brightness);
-    i2c_stop();
-}
-uint8_t upm::TM1637::encode(char c) {
-    if(c >= '0' && c <= '9')
-        return m_nums[(int)c - 48];
-    if(c >= 'a' && c <= 'z')
-        return m_char[(int)c - 97];
-    if(c >= 'A' && c <= 'Z')
-        return m_char[(int)c - 65];
-    if(c == '[')
-        return m_brkt[0];
-    if(c == ']')
-        return m_brkt[1];
-    if(c == '(' || c == ')')
-        return m_brkt[(int)c - 40];
-    if(c == '-')
-        return 0x40;
-    if(c == '_')
-        return 0x08;
-    if(c == '}')
-        return 0x70;
-    if(c == '{')
-        return 0x46;
-    return 0x00;
-}
diff --git a/src/tm1637/tm1637.hpp b/src/tm1637/tm1637.hpp
deleted file mode 100644
index b56cd43..0000000
--- a/src/tm1637/tm1637.hpp
+++ /dev/null
@@ -1,143 +0,0 @@
-/*
- * Author: Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <unistd.h>
-#include <stdint.h>
-#include <string>
-#include <iostream>
-
-#include <mraa/gpio.h>
-
-
-// TM1637-specific register addresses for writing all digits at a time
-#define TM1637_ADDR    0x40
-#define TM1637_REG     0xC0
-#define TM1637_CMD     0x88
-
-// Display-specific values
-#define M_DISPLAY_DIGITS  4
-
-namespace upm
-{
-
-/**
- * @brief TM1637 7-Segment Display
- * @defgroup tm1637 libupm-tm1637
- * @ingroup seeed gpio display
- */
-
-/**
- * @library tm1637
- * @sensor tm1637
- * @comname 7-segment Display
- * @altname Grove 4-Digit Display
- * @type display
- * @man seeed
- * @web http://wiki.seeed.cc/Grove-4-Digit_Display/
- * @con gpio
- *
- * @brief API for the TM1637 7-Segment Display
- *
- * TM1637 is a display controller for LED-based 7-segment displays.
- * It can be used to address and write data to multiple display digits. This
- * driver is based on the Grove version of the TM1637 display that uses 4
- * digits, thus making it ideal for clock displays, timers, counters, or even
- * score displays in a two-player arcade game.
- *
- * @image html tm1637.jpeg
- * @snippet tm1637.cxx Interesting
- */
-
-  class TM1637
-  {
-  public:
-      /**
-       * TM1637 constructor
-       *
-       * @param clk_pin Clock pin the sensor is connected to
-       * @param dio_pin Data pin the sensor is connected to
-       * @param bright Initial brightness, from 0 (dark) to 7 (bright) (default is 3)
-       */
-      TM1637(int clk_pin, int dio_pin, int bright = 3);
-      /**
-       * TM1637 destructor
-       */
-      ~TM1637();
-      /**
-       * Writes digits to the display in a 7-segment encoding
-       *
-       * @param digits Array of digits to send to the display
-       * @return 0 if successful, error code otherwise
-       */
-      mraa_result_t write(uint8_t *digits);
-      /**
-       * Writes digits to the display in a 7-segment encoding
-       *
-       * @param d List of multiple arguments to send to the display
-       * @return 0 if successful, error code otherwise
-       */
-      mraa_result_t write(int d, ...);
-      /**
-       * Writes a symbol (digit or letter) to the display in a specified index
-       *
-       * @param index 0-based index of the digit to change from the left
-       * @param symbol Digit or letter to display
-       * @return 0 if successful, error code otherwise
-       */
-      mraa_result_t writeAt(int index, char symbol);
-      /**
-       * Writes all the digits or letters to the display as a string
-       *
-       * @param digits String of symbols to display
-       * @return 0 if successful, error code otherwise
-       */
-      mraa_result_t write(std::string digits);
-      /**
-       * Toggles the colon between digits on the display
-       *
-       * @param value True to turn the colon on, false to turn it off
-       */
-      void setColon(bool value);
-      /**
-       * Controls the brightness of the display
-       *
-       * @param value Brightness, from 0 (darkest) to 7 (brightest)
-       */
-      void setBrightness(int value);
-
-  private:
-      void i2c_start();
-      void i2c_stop();
-      void i2c_writeByte(uint8_t value);
-      void update();
-      uint8_t encode(char c);
-
-      mraa_gpio_context m_clk, m_dio;
-      std::string m_name;
-      uint8_t m_digits[4];
-      uint8_t m_brightness;
-  };
-}
diff --git a/src/tm1637/tm1637.i b/src/tm1637/tm1637.i
deleted file mode 100644
index c7a4142..0000000
--- a/src/tm1637/tm1637.i
+++ /dev/null
@@ -1,32 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_tm1637)
-#endif
-/* END Java syntax */
-
-/* BEGIN Javascript syntax  ------------------------------------------------- */
-#ifdef SWIGJAVASCRIPT
-%include "../carrays_uint8_t.i"
-#endif
-/* END Javascript syntax */
-
-/* BEGIN Python syntax  ----------------------------------------------------- */
-#ifdef SWIGPYTHON
-%include "../carrays_uint8_t.i"
-#endif
-/* END Python syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%rename("writeArray")  write(uint8_t *digits);
-%rename("writeString") write(std::string digits);
-
-%varargs(4, int digit = 0) write;
-%apply uint8_t *INPUT { uint8_t *digits }
-
-%{
-#include "tm1637.hpp"
-%}
-%include "tm1637.hpp"
-/* END Common SWIG syntax */
diff --git a/src/tm1637/tm1637.json b/src/tm1637/tm1637.json
deleted file mode 100644
index 10e0c92..0000000
--- a/src/tm1637/tm1637.json
+++ /dev/null
@@ -1,52 +0,0 @@
-{
-    "Library": "tm1637",
-    "Description": "Seeed TM1637 based 7-Segment Display Library",
-    "Sensor Class": {
-        "TM1637": {
-            "Name": "API for the Seeed TM1637 based 7-Segment Display",
-            "Description": "This is the UPM Module for the Seeed TM1637 based 7-Segment Display. It can be used to address and write data to multiple display digits. This driver is based on the Grove version of the TM1637 display that uses 4 digits, thus making it ideal for clock displays, timers, counters, or even score displays in a two-player arcade game.",
-            "Aliases": ["tm1637", "Grove - 4-Digit Display"],
-            "Categories": ["display"],
-            "Connections": ["gpio"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["Seeed", "Titan Micro Electronics"],
-            "Image": "tm1637.jpeg",
-            "Examples": {
-                "Java": ["TM1637_Example.java"],
-                "Python": ["tm1637.py"],
-                "Node.js": ["tm1637.js"],
-                "C++": ["tm1637.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.3,
-                    "max": 5.5
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "min" : 0.2,
-                    "max" : 80
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -40,
-                    "max": 85
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/grove-4digital-display-p-1198.html", "http://wiki.seeed.cc/Grove-4-Digit_Display/"],
-                "Datasheets": ["https://raw.githubusercontent.com/SeeedDocument/Grove-4-Digit_Display/master/res/TM1637_datasheet.pdf"],
-                "Schematics": ["https://raw.githubusercontent.com/SeeedDocument/Grove-4-Digit_Display/master/res/Grove_4-Digit_Display_V1.0.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/tmp006/CMakeLists.txt b/src/tmp006/CMakeLists.txt
deleted file mode 100644
index 7bb9221..0000000
--- a/src/tmp006/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "tmp006")
-set (libdescription "IR-Termopile Sensor")
-set (module_src ${libname}.cpp)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/tmp006/tmp006.cpp b/src/tmp006/tmp006.cpp
deleted file mode 100644
index bae9456..0000000
--- a/src/tmp006/tmp006.cpp
+++ /dev/null
@@ -1,278 +0,0 @@
-/*
- * Author: Norbert Wesp <nwesp@phytec.de>
- * Copyright (c) 2017 Phytec Messtechnik GmbH.
- *
- * based on: RIOT-driver tmp006 by Johann Fischer <j.fischer@phytec.de>
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include <unistd.h>
-#include <stdlib.h>
-#include <endian.h>
-
-#include "tmp006.hpp"
-
-using namespace upm;
-
-TMP006::TMP006(int bus, uint8_t conv_rate, int devAddr) : m_i2ControlCtx(bus) {
-    uint8_t reg[2];
-    uint16_t tmp;
-
-    m_temperature = 0;
-
-    m_name = TMP006_NAME;
-
-    m_controlAddr = devAddr;
-
-    sensorType = TMP006_SEN;
-    m_bus = bus;
-
-    if (conv_rate > TMP006_CONFIG_CR_AS16) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_conv_rate() failed");
-    }
-
-    mraa::Result ret = m_i2ControlCtx.address(m_controlAddr);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_address() failed");
-    }
-
-    if (checkID() != 0) {
-        /* sensor_id does not match! maybe wrong sensor chosen? */
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": checkID() failed");
-    }
-
-    tmp = m_i2ControlCtx.readWordReg(TMP006_CONFIGURATION);
-    reg[0] = (tmp >> 8);
-
-    tmp = TMP006_CONFIG_CR(conv_rate);
-    reg[1] = (tmp >> 8);
-
-    tmp = ((uint16_t)reg[1] << 8) | reg[0];
-
-    ret = m_i2ControlCtx.writeWordReg(TMP006_CONFIGURATION, tmp);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_word_data() failed");
-    }
-}
-
-int
-TMP006::checkID(void)
-{
-    uint8_t tmp[2];
-    uint16_t id;
-    int re = 0;
-    int ret = 0;
-
-    tmp[0] = 0;tmp[1] = 0;
-    // Checking if TMP006
-    re = m_i2ControlCtx.readBytesReg(TMP006_DEVICE_ID_REG, tmp, 2);
-    if (re != 2) {
-        /* not enough bytes were read! */
-        //return -1;
-        ret = -1;
-    }
-
-    id = ((uint16_t)tmp[0] << 8) | tmp[1];
-
-    if (id != TMP006_DEVICE_ID) {
-        //return -1;
-        ret = -1;
-    } else {
-        sensorType = TMP006_SEN;
-        return 0;
-    }
-
-    // Checking if TMP007
-    re = m_i2ControlCtx.readBytesReg(TMP007_DEVICE_ID_REG, tmp, 2);
-    if (re != 2) {
-        /* not enough bytes were read! */
-        //return -1;
-        ret = -1;
-    }
-
-    id = ((uint16_t)tmp[0] << 8) | tmp[1];
-
-    if (id != TMP007_DEVICE_ID) {
-        //return -1;
-        ret = -1;
-    } else {
-        sensorType = TMP007_SEN;
-        return 0;
-    }
-
-    return ret;
-}
-
-void
-TMP006::resetSensor(void)
-{
-    uint8_t reg[2];
-    uint16_t tmp = TMP006_RST_SOFT;
-    reg[0] = (tmp >> 8);
-    reg[1] = (tmp & 0x00ff);
-    tmp = ((uint16_t)reg[1] << 8) | reg[0];
-
-    mraa::Result ret = m_i2ControlCtx.writeWordReg(TMP006_CONFIGURATION, tmp);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_word_data() failed");
-    }
-}
-
-void
-TMP006::setActive(void)
-{
-    uint8_t reg[2];
-    uint16_t tmp;
-
-    tmp = m_i2ControlCtx.readWordReg(TMP006_CONFIGURATION);
-    reg[0] = (tmp >> 8);
-    reg[1] = (tmp & 0x00ff);
-    reg[1] |= (TMP006_CONFIG_MOD(TMP006_CONFIG_MOD_CC) >> 8);
-
-    tmp = ((uint16_t)reg[0] << 8) | reg[1];
-
-    mraa::Result ret = m_i2ControlCtx.writeWordReg(TMP006_CONFIGURATION, tmp);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_word_data() failed");
-    }
-}
-
-void
-TMP006::setStandby(void)
-{
-    uint8_t reg[2];
-    uint16_t tmp;
-
-    tmp = m_i2ControlCtx.readWordReg(TMP006_CONFIGURATION);
-    reg[0] = (tmp >> 8);
-    reg[1] = (tmp & 0x00ff);
-    reg[1] &= ~(TMP006_CONFIG_MOD(TMP006_CONFIG_MOD_CC) >> 8);
-
-    tmp = ((uint16_t)reg[0] << 8) | reg[1];
-
-    mraa::Result ret = m_i2ControlCtx.writeWordReg(TMP006_CONFIGURATION, tmp);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_word_data() failed");
-    }
-}
-
-int
-TMP006::sampleData(void)
-{
-    uint8_t buf[2];
-    uint16_t rawVolt;
-    uint16_t rawTemp;
-    float tamb[1];
-    float tobj[1];
-    uint16_t tmp;
-    uint8_t drdy[1];
-
-    tmp = m_i2ControlCtx.readWordReg(TMP006_CONFIGURATION);
-    buf[0] = (tmp >> 8);
-    buf[1] = (tmp & 0x00ff);
-
-    *drdy = buf[0] & (TMP006_DRDY_DATA_RDY);
-
-    if(sensorType == TMP006_SEN) {
-        if(! (*drdy)) {
-            /* conversation in progress */
-            return -1;
-        }
-    }
-
-    tmp = m_i2ControlCtx.readWordReg(TMP006_SENSOR_VOLTAGE);
-    buf[0] = (tmp >> 8);
-    buf[1] = (tmp & 0x00ff);
-    rawVolt = ((uint16_t)buf[1] << 8) | buf[0];
-
-    tmp = m_i2ControlCtx.readWordReg(TMP006_LOCAL_TEMPERATURE);
-    buf[0] = (tmp >> 8);
-    buf[1] = (tmp & 0x00ff);
-    rawTemp = ((uint16_t)buf[1] << 8) | buf[0];
-
-    convert_data(rawVolt, rawTemp, tamb, tobj);
-    m_temperature = (uint16_t)*tobj;
-
-    return 0;
-}
-
-void
-TMP006::convert_data(int16_t rawv,int16_t rawt, float *tamb, float *tobj)
-{
-    /* calculate die temperature */
-    *tamb = (double)rawt / 128.0;
-    /* die temperature in Kelvin */
-    double tdie_k = *tamb + 273.15;
-
-    /* calculate sensor voltage */
-    double sens_v = (double)rawv * TMP006_CCONST_LSB_SIZE;
-
-    double tdiff = tdie_k - TMP006_CCONST_TREF;
-    double tdiff_pow2 = pow(tdiff, 2);
-
-    double s = TMP006_CCONST_S0 * (1 + TMP006_CCONST_A1 * tdiff
-                                   + TMP006_CCONST_A2 * tdiff_pow2);
-
-    double v_os = TMP006_CCONST_B0 + TMP006_CCONST_B1 * tdiff
-                  + TMP006_CCONST_B2 * tdiff_pow2;
-
-    double f_obj = (sens_v-v_os) + TMP006_CCONST_C2 * pow((sens_v-v_os), 2);
-
-    double t = pow(pow(tdie_k, 4) + (f_obj / s), 0.25);
-    /* calculate object temperature in Celsius */
-    *tobj = (t - 273.15);
-}
-
-float
-TMP006::getTemperature(int bSampleData)
-{
-    if (bSampleData) {
-        if( (sampleData()) == -1) {
-            /* conversation in progress */
-            return (-273.2);
-        }
-    }
-    return (float) m_temperature;
-}
-
-uint16_t
-TMP006::getConfig(void)
-{
-    uint8_t buf[2];
-    uint16_t tmp;
-
-    tmp = m_i2ControlCtx.readWordReg(TMP006_CONFIGURATION);
-    buf[0] = (tmp >> 8);
-    buf[1] = (tmp & 0x00ff);
-
-    return ((uint16_t)buf[1] << 8) | buf[0];
-}
diff --git a/src/tmp006/tmp006.hpp b/src/tmp006/tmp006.hpp
deleted file mode 100644
index 2fff3eb..0000000
--- a/src/tmp006/tmp006.hpp
+++ /dev/null
@@ -1,214 +0,0 @@
-/*
- * Author: Norbert Wesp <nwesp@phytec.de>
- * Copyright (c) 2017 Phytec Messtechnik GmbH.
- *
- * based on: RIOT-driver tmp006 by Johann Fischer <j.fischer@phytec.de>
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <string>
-#include <mraa/i2c.hpp>
-#include <math.h>
-
-#define TMP006_NAME "TMP006"
-#define TMP006_I2C_ADDRESS     0x41
-#define TMP006_MANUFACTURER_ID 0x5449
-#define TMP006_DEVICE_ID       0x0067
-
-#define TMP007_I2C_ADDRESS     0x40
-// this should actually be split
-#define TMP007_DEVICE_ID       0x0078
-
-#ifndef TMP006_CONVERSION_TIME
-#define TMP006_CONVERSION_TIME 1E6 /**< Default Conversion Time in us */
-#endif
-
-/* TMP006 Register Map */
-#define TMP006_SENSOR_VOLTAGE      0x00   /* Sensor voltage register */
-#define TMP006_LOCAL_TEMPERATURE   0x01   /* Ambient temperature register */
-#define TMP006_CONFIGURATION       0x02
-#define TMP006_MANUFACTURER_ID_REG 0xFE
-#define TMP006_DEVICE_ID_REG       0xFF
-
-/* TMP007 Register Map */
-#define TMP007_DEVICE_ID_REG       0x1F
-
-/* TMP006 configuration register bitmap */
-#define TMP006_RST_SOFT         (1 << 15)
-
-#define TMP006_CONFIG_MOD_SHIFT 12
-#define TMP006_CONFIG_MOD_MASK  0x7000
-#define TMP006_CONFIG_MOD(x)    (((uint16_t)(((uint16_t)(x))<<\
-                                TMP006_CONFIG_MOD_SHIFT))\
-                                &TMP006_CONFIG_MOD_MASK)
-#define TMP006_CONFIG_MOD_CC    0x07
-#define TMP006_CONFIG_MOD_OFF   0x00
-
-#define TMP006_CONFIG_CR_SHIFT  9
-#define TMP006_CONFIG_CR_MASK   0x0E00
-#define TMP006_CONFIG_CR(x)     (((uint16_t)(((uint16_t)(x))<<\
-                                TMP006_CONFIG_CR_SHIFT))\
-                                &TMP006_CONFIG_CR_MASK)
-#define TMP006_CONFIG_CR_AS1  0x00 /* Conversion Time 0.25 s, AVG Samples: 1 */
-#define TMP006_CONFIG_CR_AS2  0x01 /* Conversion Time 0.5 s, AVG Samples: 2 */
-#define TMP006_CONFIG_CR_AS4  0x02 /* Conversion Time 1 s, AVG Samples: 4 */
-#define TMP006_CONFIG_CR_AS8  0x03 /* Conversion Time 2 s, AVG Samples: 8 */
-#define TMP006_CONFIG_CR_AS16 0x04 /* Conversion Time 4 s, AVG Samples: 16 */
-#define TMP006_CONFIG_CR_DEF  TMP006_CONFIG_CR_AS4 /**< Default for Testing */
-
-#define TMP006_DRDY_EN          (1 << 8)
-#define TMP006_DRDY_DATA_RDY    (1 << 7)
-
-/* constant values for data conversion */
-#ifndef TMP006_CCONST_S0
-#define TMP006_CCONST_S0       6.4E-14    /* Calibration Factor */
-#endif
-
-#define TMP006_CCONST_A1       1.75E-3   /* Constant \f$a_{\mathrm{1}}\f$ */
-#define TMP006_CCONST_A2       -1.678E-5 /* Constant \f$a_{\mathrm{2}}\f$ */
-#define TMP006_CCONST_TREF     298.15    /* Constant \f$T_{\mathrm{REF}}\f$ */
-#define TMP006_CCONST_B0       -2.94E-5  /* Constant \f$b_{\mathrm{0}}\f$ */
-#define TMP006_CCONST_B1       -5.7E-7   /* Constant \f$b_{\mathrm{1}}\f$ */
-#define TMP006_CCONST_B2       4.63E-9   /* Constant \f$b_{\mathrm{2}}\f$ */
-#define TMP006_CCONST_C2       13.4      /* Constant \f$c_{\mathrm{2}}\f$ */
-#define TMP006_CCONST_LSB_SIZE 156.25E-9 /* Sensor Voltage Register LSB Size */
-
-typedef enum {
-    TMP006_SEN,
-    TMP007_SEN } tmp_t;
-
-namespace upm {
-
-/**
- * @brief TMP006 Infrared-Thermopile Sensor
- * @defgroup tmp006 libupm-tmp006
- * @ingroup ti i2c temp
- */
-
-/**
- * @library tmp006
- * @sensor tmp006
- * @comname TMP006 IR-Thermopile Sensor
- * @type temp
- * @man ti
- * @web http://www.ti.com/product/TMP006/datasheet/abstract#SBOS5183423
- * @con i2c
- *
- * @brief API for the TMP006 IR-Thermopile Sensor
- *
- * Description in web-link above:
- * The TMP006 and TMP006B are fully integrated MEMs thermopile sensors that
- * measure the temperature of an object without having to be in direct contact.
- * The thermopile absorbs passive infrared energy from an object at wavelengths
- * between 4 um to 16 um within the end-user defined field of view.
- * The corresponding change in voltage across the thermopile is digitized and
- * reported with the on-chip die thermal sensor measurement through an I2C- and
- * SMBus-compatible interface. With this data, the target object temperature
- * can be calculated by an external processor.
- * The Infrared thermopile sensor is specified to operate from 
- * -40 to +125 [degC]. It is possible to measure an object temperature beyond
- * the device operating range as long as the device itself does not exceed the
- * operating temperature range (-40 to +125 [degC]).
- *
- * @snippet tmp006.cxx Interesting
- */
-class TMP006 {
-    public:
-        /**
-         *
-         * Instantiates an TMP006 object
-         *
-         * @param bus Number of the used bus
-         * @param conv_rate Conversation rate (allowed between 0 and 4)
-         * @param devAddr Address of the used I2C device
-         */
-        TMP006 (int bus, uint8_t conv_rate=TMP006_CONFIG_CR_DEF,
-                                  int devAddr=TMP006_I2C_ADDRESS);
-
-        /**
-         * Check device_id of sensor
-         *
-         * @return  0 on succes
-         *         -1 on error
-         */
-        int checkID(void);
-
-        /**
-         * Performs a soft reset of the TMP006 device to ensure
-         * it is in a known state.
-         */
-        void resetSensor(void);
-
-        /**
-         * Set active mode, this enables periodic measurements.
-         */
-        void setActive(void);
-
-        /**
-         * Set standby mode, this disables periodic measurements.
-         */
-        void setStandby(void);
-
-        /**
-         * Read out data of regs and call further function
-         * Also saves converted value to variable
-         */
-        int sampleData(void);
-
-        /**
-         * Convert raw sensor values to temperature.
-         *
-         * @param rawv Object voltage value
-         * @param rawt Raw die temperature value
-         * @param tamb Converted ambient temperature
-         * @param tobj Converted object temperature
-         */
-        void convert_data(int16_t rawv,int16_t rawt, float *tamb, float *tobj);
-
-        /**
-         * Get the calculated object temperature [degC]
-         *
-         * @param bSampleData Flag to read sensor
-         * @return The object temp in degC on success
-         *         and -273.2 on 'conversation in progress'
-         */
-        float getTemperature(int bSampleData = 0);
-
-        /**
-         * Get value of configuration reg
-         */
-        uint16_t getConfig(void);
-
-    private:
-
-        std::string m_name;
-
-        int m_controlAddr;
-        int m_bus;
-        mraa::I2c m_i2ControlCtx;
-        tmp_t sensorType;
-
-        int32_t m_temperature;
-};
-
-}
diff --git a/src/tmp006/tmp006.json b/src/tmp006/tmp006.json
deleted file mode 100644
index 7b8b856..0000000
--- a/src/tmp006/tmp006.json
+++ /dev/null
@@ -1,50 +0,0 @@
-{
-    "Library": "tmp006",
-    "Description": "Texas Instruments TMP006 Infrared-Thermopile Sensor Library",
-    "Sensor Class": {
-        "TMP006": {
-            "Name": "API for the Texas Instruments TMP006 IR-Thermopile Sensor",
-            "Description": "This is the UPM Module for the Texas Instruments TMP006 IR-Thermopile Sensor. The TMP006 and TMP006B are fully integrated MEMs thermopile sensors that measure the temperature of an object without having to be in direct contact. The thermopile absorbs passive infrared energy from an object at wavelengths between 4 um to 16 um within the end-user defined field of view. The corresponding change in voltage across the thermopile is digitized and reported with the on-chip die thermal sensor measurement through an I2C- and SMBus-compatible interface. With this data, the target object temperature can be calculated by an external processor.",
-            "Aliases": ["tmp006", "TMP006 Infrared Thermopile Contactless Temperature Sensor in WCSP Package"],
-            "Categories": ["temperature"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping", "industrial", "commercial"],
-            "Manufacturers": ["Texas Instruments"],
-            "Examples": {
-                "Python": ["tmp006.py"],
-                "C++": ["tmp006.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 2.5,
-                    "max": 5.5
-                },
-                "Supply Current": {
-                    "unit": "uA",
-                    "min" : 1.0,
-                    "max" : 325.0
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -40,
-                    "max": 125
-                },
-                "Effective Range": {
-                    "unit": "°C",
-                    "min" : 0,
-                    "max" : 60
-                },
-                "Accuracy": {
-                    "unit": "-/+ °C",
-                    "min" : 0.5,
-                    "max" : 1.0
-                }
-            },
-            "Urls": {
-                "Product Pages": ["http://www.ti.com/product/TMP006/datasheet/abstract#SBOS5183423"],
-                "Datasheets": ["http://www.ti.com/lit/ds/symlink/tmp006.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/tsl2561/CMakeLists.txt b/src/tsl2561/CMakeLists.txt
deleted file mode 100644
index 9fe0d99..0000000
--- a/src/tsl2561/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME tsl2561
-    DESCRIPTION "Digital Light Sensor"
-    C_HDR tsl2561.h
-    C_SRC tsl2561.c
-    CPP_HDR tsl2561.hpp
-    CPP_SRC tsl2561.cxx
-    FTI_SRC tsl2561_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/tsl2561/tsl2561.c b/src/tsl2561/tsl2561.c
deleted file mode 100644
index 0b67137..0000000
--- a/src/tsl2561/tsl2561.c
+++ /dev/null
@@ -1,245 +0,0 @@
-/*
- * Author: Nandkishor Sonar <Nandkishor.Sonar@intel.com>,
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * LIGHT-TO-DIGITAL CONVERTER [TAOS-TSL2561]
- *   Inspiration and lux calculation formulas from data sheet
- *   URL: http://www.adafruit.com/datasheets/TSL2561.pdf
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "tsl2561.h"
-#include "upm_utilities.h"
-
-// forward declaration
-upm_result_t tsl2561_compute_lux(const tsl2561_context dev, int *int_data);
-
-tsl2561_context tsl2561_init(int bus, uint8_t dev_address, uint8_t gain,
-                             uint8_t integration_time){
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        return NULL;
-    }
-
-    tsl2561_context dev =
-      (tsl2561_context)malloc(sizeof(struct _tsl2561_context));
-
-    if (!dev)
-        return NULL;
-
-    dev->bus = bus;
-    dev->address = dev_address;
-    dev->gain = gain;
-    dev->integration_time = integration_time;
-
-    dev->i2c = mraa_i2c_init(dev->bus);
-    if(dev->i2c == NULL){
-        free(dev);
-        return NULL;
-    }
-
-    if (mraa_i2c_address(dev->i2c, dev->address) != MRAA_SUCCESS)
-        {
-            mraa_i2c_stop(dev->i2c);
-            free(dev);
-            return NULL;
-        }
-
-    // POWER UP.
-    if(mraa_i2c_write_byte_data(dev->i2c, CONTROL_POWERON, REGISTER_Control) != MRAA_SUCCESS){
-        mraa_i2c_stop(dev->i2c);
-        free(dev);
-        return NULL;
-    }
-
-    // Power on Settling time
-    upm_delay_us(1000);
-
-    // Gain & Integration time.
-    if(mraa_i2c_write_byte_data(dev->i2c, (dev->gain | dev->integration_time), REGISTER_Timing) != MRAA_SUCCESS){
-        mraa_i2c_stop(dev->i2c);
-        free(dev);
-        return NULL;
-    }
-
-    // Set interrupt threshold to default.
-    if(mraa_i2c_write_byte_data(dev->i2c, 0x00, REGISTER_Interrupt) != MRAA_SUCCESS){
-        mraa_i2c_stop(dev->i2c);
-        free(dev);
-        return NULL;
-    }
-
-    return dev;
-}
-
-void tsl2561_close(tsl2561_context dev){
-    if (mraa_i2c_write_byte_data(dev->i2c, CONTROL_POWEROFF,
-                                 REGISTER_Control) != MRAA_SUCCESS){
-        printf("Unable turn off device\n");
-    }
-
-    mraa_i2c_stop(dev->i2c);
-    free(dev);
-}
-
-upm_result_t tsl2561_get_lux(const tsl2561_context dev, float* lux){
-    int lux_val=0;
-
-    tsl2561_compute_lux(dev, &lux_val);
-
-    *lux = (float) lux_val;
-    return UPM_SUCCESS;
-}
-
-upm_result_t tsl2561_i2c_write_reg(tsl2561_context dev, uint8_t reg,
-                                   uint8_t value){
-    // Write register to I2C
-    if(mraa_i2c_write_byte(dev->i2c, reg) != MRAA_SUCCESS){
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // Write value to I2C
-    if(mraa_i2c_write_byte(dev->i2c, value) != MRAA_SUCCESS){
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    upm_delay_ms(100);
-    return UPM_SUCCESS;
-}
-
-upm_result_t tsl2561_i2c_read_reg(tsl2561_context dev, uint8_t reg,
-                                  uint8_t* data){
-    // Send address of register to be read.
-    if(mraa_i2c_write_byte(dev->i2c, reg) != MRAA_SUCCESS){
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // Read byte.
-    *data = mraa_i2c_read_byte(dev->i2c);
-
-    //upm_delay(1);
-    return UPM_SUCCESS;
-}
-
-upm_result_t tsl2561_compute_lux(const tsl2561_context dev, int *int_data) {
-    int lux;
-    uint16_t raw_lux_ch_0;
-    uint16_t raw_lux_ch_1;
-    uint8_t ch0_low, ch0_high, ch1_low, ch1_high;
-
-    if (tsl2561_i2c_read_reg(dev, REGISTER_Channal0L, &ch0_low) != UPM_SUCCESS){
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    if(tsl2561_i2c_read_reg(dev, REGISTER_Channal0H, &ch0_high) != UPM_SUCCESS){
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-    raw_lux_ch_0 = ch0_high*256 + ch0_low;
-
-    if(tsl2561_i2c_read_reg(dev, REGISTER_Channal1L, &ch1_low) != UPM_SUCCESS){
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    if(tsl2561_i2c_read_reg(dev, REGISTER_Channal1H, &ch1_high) != UPM_SUCCESS){
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-    raw_lux_ch_1 = ch1_high*256 + ch1_low;
-
-    uint64_t scale = 0;
-
-    switch(dev->integration_time){
-        case 0: // 13.7 msec
-            scale = LUX_CHSCALE_TINT0;
-            break;
-        case 1: // 101 msec
-            scale = LUX_CHSCALE_TINT1;
-            break;
-        case 2: // assume no scaling
-            scale = (1 << LUX_CHSCALE);
-            break;
-    }
-
-    // scale if gain is NOT 16X
-    if(!dev->gain)
-        scale = scale << 4;
-
-    uint64_t channel1 = 0;
-    uint64_t channel0 = 0;
-
-    // scale the channel values
-    channel0 = (raw_lux_ch_0 * scale) >> LUX_CHSCALE;
-    channel1 = (raw_lux_ch_1 * scale) >> LUX_CHSCALE;
-
-    // find the ratio of the channel values (Channel1/Channel0)
-    // protect against divide by zero
-    uint64_t ratio_1 = 0;
-    if (channel0 != 0)
-        ratio_1 = (channel1 << (LUX_RATIOSCALE+1)) / channel0;
-
-    // round the ratio value
-    int64_t ratio = (ratio_1 + 1) >> 1;
-    unsigned int b = 0, m = 0;
-
-    // CS package
-    // Check if ratio <= eachBreak ?
-    if ((ratio >= 0) && (ratio <= LUX_K1C)){
-        b=LUX_B1C; m=LUX_M1C;
-    }
-    else if (ratio <= LUX_K2C){
-        b=LUX_B2C; m=LUX_M2C;
-    }
-    else if (ratio <= LUX_K3C){
-        b=LUX_B3C; m=LUX_M3C;
-    }
-    else if (ratio <= LUX_K4C){
-        b=LUX_B4C; m=LUX_M4C;
-    }
-    else if (ratio <= LUX_K5C){
-        b=LUX_B5C; m=LUX_M5C;
-    }
-    else if (ratio <= LUX_K6C){
-        b=LUX_B6C; m=LUX_M6C;
-    }
-    else if (ratio <= LUX_K7C){
-        b=LUX_B7C; m=LUX_M7C;
-    }
-    else if (ratio > LUX_K8C){
-        b=LUX_B8C; m=LUX_M8C;
-    }
-    int64_t temp_lux = 0;
-    temp_lux = ((channel0 * b) - (channel1 * m));
-    // do not allow negative lux value
-    if (temp_lux < 0) temp_lux = 0;
-
-    // round lsb (2^(LUX_SCALE-1))
-    temp_lux += (1 << (LUX_SCALE-1));
-
-    // strip off fractional portion
-    lux = temp_lux >> LUX_SCALE;
-
-    *int_data = lux;
-
-    return UPM_SUCCESS;
-}
diff --git a/src/tsl2561/tsl2561.cxx b/src/tsl2561/tsl2561.cxx
deleted file mode 100644
index 0876a92..0000000
--- a/src/tsl2561/tsl2561.cxx
+++ /dev/null
@@ -1,235 +0,0 @@
-/*
- * Author: Nandkishor Sonar <Nandkishor.Sonar@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * LIGHT-TO-DIGITAL CONVERTER [TAOS-TSL2561]
- *   Inspiration and lux calculation formulas from data sheet
- *   URL: http://www.adafruit.com/datasheets/TSL2561.pdf
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-
-#include <string>
-#include <stdexcept>
-#include <unistd.h>
-#include "tsl2561.hpp"
-
-using namespace upm;
-
-
-TSL2561::TSL2561(int bus, uint8_t devAddr, uint8_t gain, uint8_t integrationTime)
-                                                : m_i2ControlCtx(bus)
-{
-    m_controlAddr = devAddr;
-    m_bus = bus;
-    m_gain = gain ;
-    m_integrationTime = integrationTime;
-
-    m_name = "TSL2561- Digital Light Sensor";
-
-    mraa::Result error = m_i2ControlCtx.address(m_controlAddr);
-    if (error != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_address() failed");
-        return;
-    }
-
-    // POWER UP.
-    error = m_i2ControlCtx.writeReg(REGISTER_Control, CONTROL_POWERON);
-    if (error != mraa::SUCCESS) {
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": Unable to power up TSL2561");
-        return;
-    }
-    // Power on Settling time
-    usleep(1000);
-
-    // Gain & Integration time .
-    error = m_i2ControlCtx.writeReg(REGISTER_Timing, m_gain | m_integrationTime);
-    if (error != mraa::SUCCESS) {
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": Unable to set gain/time");
-        return;
-    }
-
-    // Set interrupt threshold to default.
-    error = m_i2ControlCtx.writeReg(REGISTER_Interrupt, 0x00);
-    if (error != mraa::SUCCESS) {
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": Unable to set interrupt threshold");
-        return;
-    }
-}
-
-TSL2561::~TSL2561()
-{
-    // POWER DOWN
-    m_i2ControlCtx.writeReg(REGISTER_Control, CONTROL_POWEROFF);
-}
-
-int
-TSL2561::getLux()
-{
-    mraa::Result error = mraa::SUCCESS;
-    int lux;
-    uint16_t rawLuxCh0;
-    uint16_t rawLuxCh1;
-    uint8_t ch0_low, ch0_high, ch1_low, ch1_high;
-
-    error = i2cReadReg(REGISTER_Channal0L, ch0_low);
-    if (error != mraa::SUCCESS) {
-        fprintf(stderr, "Error: Unable to read channel0L in getRawLux()\n");
-        return error;
-    }
-
-    error = i2cReadReg(REGISTER_Channal0H, ch0_high);
-    if (error != mraa::SUCCESS) {
-        fprintf(stderr, "Error: Unable to read channel0H in getRawLux()\n");
-        return error;
-    }
-
-    rawLuxCh0 = ch0_high*256+ch0_low;
-
-    error= i2cReadReg(REGISTER_Channal1L, ch1_low);
-    if (error != mraa::SUCCESS) {
-        fprintf(stderr, "Error: Unable to read channel1L in getRawLux()\n");
-        return error;
-    }
-
-    error = i2cReadReg(REGISTER_Channal1H, ch1_high);
-    if (error != mraa::SUCCESS) {
-        fprintf(stderr, "Error: Unable to read channel1H in getRawLux()\n");
-        return error;
-    }
-
-    rawLuxCh1 = ch1_high*256+ch1_low;
-
-    uint64_t scale = 0;
-
-    switch (m_integrationTime)
-    {
-      case 0: // 13.7 msec
-         scale = LUX_CHSCALE_TINT0;
-      break;
-      case 1: // 101 msec
-         scale = LUX_CHSCALE_TINT1;
-      break;
-      default: // assume no scaling
-         scale = (1 << LUX_CHSCALE);
-      break;
-    }
-
-    // scale if gain is NOT 16X
-    if (!m_gain) scale = scale << 4;
-
-    uint64_t channel1 = 0;
-    uint64_t channel0 = 0;
-    // scale the channel values
-    channel0 = (rawLuxCh0 * scale) >> LUX_CHSCALE;
-    channel1 = (rawLuxCh1 * scale) >> LUX_CHSCALE;
-
-    // find the ratio of the channel values (Channel1/Channel0)
-    // protect against divide by zero
-    unsigned long ratio1 = 0;
-    if (channel0 != 0) ratio1 = (channel1 << (LUX_RATIOSCALE+1)) / channel0;
-
-    // round the ratio value
-    int64_t ratio = (ratio1 + 1) >> 1;
-
-    unsigned int b = 0, m = 0;
-
-    // CS package
-    // Check if ratio <= eachBreak ?
-    if ((ratio >= 0) && (ratio <= LUX_K1C))
-       {b=LUX_B1C; m=LUX_M1C;}
-    else if (ratio <= LUX_K2C)
-       {b=LUX_B2C; m=LUX_M2C;}
-    else if (ratio <= LUX_K3C)
-       {b=LUX_B3C; m=LUX_M3C;}
-    else if (ratio <= LUX_K4C)
-       {b=LUX_B4C; m=LUX_M4C;}
-    else if (ratio <= LUX_K5C)
-       {b=LUX_B5C; m=LUX_M5C;}
-    else if (ratio <= LUX_K6C)
-       {b=LUX_B6C; m=LUX_M6C;}
-    else if (ratio <= LUX_K7C)
-       {b=LUX_B7C; m=LUX_M7C;}
-    else if (ratio > LUX_K8C)
-       {b=LUX_B8C; m=LUX_M8C;}
-
-    int64_t tempLux = 0;
-    tempLux = ((channel0 * b) - (channel1 * m));
-    // do not allow negative lux value
-    if (tempLux < 0) tempLux = 0;
-
-    // round lsb (2^(LUX_SCALE-1))
-    tempLux += (1 << (LUX_SCALE-1));
-
-    // strip off fractional portion
-    lux = tempLux >> LUX_SCALE;
-
-    return lux;
-}
-
-
-mraa::Result
-TSL2561::i2cWriteReg (uint8_t reg, uint8_t value)
-{
-    mraa::Result error = mraa::SUCCESS;
-
-    // Write register to I2C
-    error = m_i2ControlCtx.writeByte (reg);
-    if (error != mraa::SUCCESS) {
-        fprintf(stderr, "Error: on i2c bus write reg in i2cWriteReg()\n");
-        return error;
-    }
-
-    // Write value to I2C
-    error = m_i2ControlCtx.writeByte (value);
-    if (error != mraa::SUCCESS) {
-        fprintf(stderr, "Error: on i2c bus write value in i2cWriteReg()\n");
-        return error;
-    }
-
-    usleep(100000);
-
-    return error;
-}
-
-mraa::Result
-TSL2561::i2cReadReg(uint8_t reg, uint8_t &data)
-{
-    mraa::Result error = mraa::SUCCESS;
-
-    // Send address of register to be read.
-    error = m_i2ControlCtx.writeByte(reg);
-    if (error != mraa::SUCCESS) {
-        fprintf(stderr, "Error: on i2c bus write in i2cReadReg()\n");
-        return error;
-    }
-
-    // Read byte.
-    data = m_i2ControlCtx.readByte();
-
-    usleep(10000);
-
-    return error;
-}
diff --git a/src/tsl2561/tsl2561.h b/src/tsl2561/tsl2561.h
deleted file mode 100644
index 856ac4b..0000000
--- a/src/tsl2561/tsl2561.h
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
- * Author: Nandkishor Sonar <Nandkishor.Sonar@intel.com>,
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * LIGHT-TO-DIGITAL CONVERTER [TAOS-TSL2561]
- *   Inspiration and lux calculation formulas from data sheet
- *   URL: http://www.adafruit.com/datasheets/TSL2561.pdf
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef TSL2561_H_
-#define TSL2561_H_
-
-#include <stdint.h>
-#include <upm.h>
-#include <mraa/i2c.h>
-
-#define TSL2561_Address          (0x29)  //Device address
-
-// Integration time
-#define  INTEGRATION_TIME0_13MS  (0x00)  // 13.7ms
-#define  INTEGRATION_TIME1_101MS (0x01)  // 101ms
-#define  INTEGRATION_TIME2_402MS (0x02)  // 402ms
-
-// Integration time
-#define  GAIN_0X  (0x00)                // No gain - Low
-#define  GAIN_16X (0x10)                // 16x gain - High
-
-// Power control bits
-#define CONTROL_POWERON   (0x03)        // ON
-#define CONTROL_POWEROFF  (0x00)        // OFF
-
-// TSL2561 registers
-#define  REGISTER_Control   (0x80)
-#define  REGISTER_Timing    (0x81)
-#define  REGISTER_Interrupt (0x86)
-#define  REGISTER_Channal0L (0x8C)
-#define  REGISTER_Channal0H (0x8D)
-#define  REGISTER_Channal1L (0x8E)
-#define  REGISTER_Channal1H (0x8F)
-
-// Lux calculations differ slightly for CS package
-#define LUX_SCALE         (14)      // Scale by 2^14
-#define LUX_RATIOSCALE    (9)       // Scale ratio by 2^9
-#define LUX_CHSCALE       (10)      // Scale channel values by 2^10
-#define LUX_CHSCALE_TINT0 (0x7517)  // 322/11 * 2^TSL2561_LUX_CHSCALE
-#define LUX_CHSCALE_TINT1 (0x0FE7)  // 322/81 * 2^TSL2561_LUX_CHSCALE
-
-// CS package Coefficients
-#define LUX_K1C           (0x0043)  // 0.130 * 2^RATIO_SCALE
-#define LUX_B1C           (0x0204)  // 0.0315 * 2^LUX_SCALE
-#define LUX_M1C           (0x01ad)  // 0.0262 * 2^LUX_SCALE
-#define LUX_K2C           (0x0085)  // 0.260 * 2^RATIO_SCALE
-#define LUX_B2C           (0x0228)  // 0.0337 * 2^LUX_SCALE
-#define LUX_M2C           (0x02c1)  // 0.0430 * 2^LUX_SCALE
-#define LUX_K3C           (0x00c8)  // 0.390 * 2^RATIO_SCALE
-#define LUX_B3C           (0x0253)  // 0.0363 * 2^LUX_SCALE
-#define LUX_M3C           (0x0363)  // 0.0529 * 2^LUX_SCALE
-#define LUX_K4C           (0x010a)  // 0.520 * 2^RATIO_SCALE
-#define LUX_B4C           (0x0282)  // 0.0392 * 2^LUX_SCALE
-#define LUX_M4C           (0x03df)  // 0.0605 * 2^LUX_SCALE
-#define LUX_K5C           (0x014d)  // 0.65 * 2^RATIO_SCALE
-#define LUX_B5C           (0x0177)  // 0.0229 * 2^LUX_SCALE
-#define LUX_M5C           (0x01dd)  // 0.0291 * 2^LUX_SCALE
-#define LUX_K6C           (0x019a)  // 0.80 * 2^RATIO_SCALE
-#define LUX_B6C           (0x0101)  // 0.0157 * 2^LUX_SCALE
-#define LUX_M6C           (0x0127)  // 0.0180 * 2^LUX_SCALE
-#define LUX_K7C           (0x029a)  // 1.3 * 2^RATIO_SCALE
-#define LUX_B7C           (0x0037)  // 0.00338 * 2^LUX_SCALE
-#define LUX_M7C           (0x002b)  // 0.00260 * 2^LUX_SCALE
-#define LUX_K8C           (0x029a)  // 1.3 * 2^RATIO_SCALE
-#define LUX_B8C           (0x0000)  // 0.000 * 2^LUX_SCALE
-#define LUX_M8C           (0x0000)  // 0.000 * 2^LUX_SCALE
-
-/**
- * @file tsl2561.h
- * @library tsl2561
- * @brief C API for the TSL2561 Digital Light Sensor
- *
- * @include tsl2561.c
- */
-
-/**
- * device context
- */
-typedef struct _tsl2561_context {
-    mraa_i2c_context    i2c;
-    int                 bus;
-    uint8_t             address;
-    uint8_t             gain;
-    uint8_t             integration_time;
-} *tsl2561_context;
-
-/**
- * Sensor Init Function
- *
- * @param bus I2C bus
- * @param dev_address I2C address
- * @param gain Gain associated with the driver
- * @param integration_time Time to keep the shutter open
- * @return void* pointer to the sensor struct
- */
-tsl2561_context tsl2561_init(int bus, uint8_t dev_address, uint8_t gain,
-                             uint8_t integration_time);
-
-/**
- * Closes the sensor module
- *
- * @param dev pointer to the sensor struct
- */
-void tsl2561_close(tsl2561_context dev);
-
-/**
- * Gets the Lux value
- *
- * @param dev pointer to the sensor struct
- * @param lux pointer to store the lux value
- * @return upm_result_t UPM success/error code
- */
-upm_result_t tsl2561_get_lux(const tsl2561_context, float* lux);
-
-/**
- * Write I2C register on the device
- *
- * @param dev pointer to the sensor struct
- * @param reg register to write value to
- * @param value the value to be written
- * @return upm_result_t UPM success/error code
- */
-upm_result_t tsl2561_i2c_write_reg(tsl2561_context dev, uint8_t reg,
-                                   uint8_t value);
-
-/**
- * Read from an I2C register from the device
- *
- * @param dev pointer to the sensor struct
- * @param reg register to write value to
- * @param data Data read in  from the register
- * @return upm_result_t UPM success/error code
- */
-upm_result_t tsl2561_i2c_read_reg(tsl2561_context dev, uint8_t reg,
-                                  uint8_t* data);
-
-
-#endif /* TSL2561_H_ */
diff --git a/src/tsl2561/tsl2561.hpp b/src/tsl2561/tsl2561.hpp
deleted file mode 100644
index 498d4f7..0000000
--- a/src/tsl2561/tsl2561.hpp
+++ /dev/null
@@ -1,171 +0,0 @@
-/*
- * Author: Nandkishor Sonar <Nandkishor.Sonar@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * LIGHT-TO-DIGITAL CONVERTER [TAOS-TSL2561]
- *   Inspiration and lux calculation formulas from data sheet
- *   URL: http://www.adafruit.com/datasheets/TSL2561.pdf
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <string>
-#include <mraa/i2c.hpp>
-#include <math.h>
-
-namespace upm {
-
-#define TSL2561_Address          (0x29)  //Device address
-
-// Integration time
-#define  INTEGRATION_TIME0_13MS  (0x00)  // 13.7ms
-#define  INTEGRATION_TIME1_101MS (0x01)  // 101ms
-#define  INTEGRATION_TIME2_402MS (0x02)  // 402ms
-
-// Integration time
-#define  GAIN_0X  (0x00)                // No gain - Low
-#define  GAIN_16X (0x10)                // 16x gain - High
-
-// Power control bits
-#define CONTROL_POWERON   (0x03)        // ON
-#define CONTROL_POWEROFF  (0x00)        // OFF
-
-// TSL2561 registers
-#define  REGISTER_Control   (0x80)
-#define  REGISTER_Timing    (0x81)
-#define  REGISTER_Interrupt (0x86)
-#define  REGISTER_Channal0L (0x8C)
-#define  REGISTER_Channal0H (0x8D)
-#define  REGISTER_Channal1L (0x8E)
-#define  REGISTER_Channal1H (0x8F)
-
-// Lux calculations differ slightly for CS package
-#define LUX_SCALE         (14)      // Scale by 2^14
-#define LUX_RATIOSCALE    (9)       // Scale ratio by 2^9
-#define LUX_CHSCALE       (10)      // Scale channel values by 2^10
-#define LUX_CHSCALE_TINT0 (0x7517)  // 322/11 * 2^TSL2561_LUX_CHSCALE
-#define LUX_CHSCALE_TINT1 (0x0FE7)  // 322/81 * 2^TSL2561_LUX_CHSCALE
-
-// CS package Coefficients
-#define LUX_K1C           (0x0043)  // 0.130 * 2^RATIO_SCALE
-#define LUX_B1C           (0x0204)  // 0.0315 * 2^LUX_SCALE
-#define LUX_M1C           (0x01ad)  // 0.0262 * 2^LUX_SCALE
-#define LUX_K2C           (0x0085)  // 0.260 * 2^RATIO_SCALE
-#define LUX_B2C           (0x0228)  // 0.0337 * 2^LUX_SCALE
-#define LUX_M2C           (0x02c1)  // 0.0430 * 2^LUX_SCALE
-#define LUX_K3C           (0x00c8)  // 0.390 * 2^RATIO_SCALE
-#define LUX_B3C           (0x0253)  // 0.0363 * 2^LUX_SCALE
-#define LUX_M3C           (0x0363)  // 0.0529 * 2^LUX_SCALE
-#define LUX_K4C           (0x010a)  // 0.520 * 2^RATIO_SCALE
-#define LUX_B4C           (0x0282)  // 0.0392 * 2^LUX_SCALE
-#define LUX_M4C           (0x03df)  // 0.0605 * 2^LUX_SCALE
-#define LUX_K5C           (0x014d)  // 0.65 * 2^RATIO_SCALE
-#define LUX_B5C           (0x0177)  // 0.0229 * 2^LUX_SCALE
-#define LUX_M5C           (0x01dd)  // 0.0291 * 2^LUX_SCALE
-#define LUX_K6C           (0x019a)  // 0.80 * 2^RATIO_SCALE
-#define LUX_B6C           (0x0101)  // 0.0157 * 2^LUX_SCALE
-#define LUX_M6C           (0x0127)  // 0.0180 * 2^LUX_SCALE
-#define LUX_K7C           (0x029a)  // 1.3 * 2^RATIO_SCALE
-#define LUX_B7C           (0x0037)  // 0.00338 * 2^LUX_SCALE
-#define LUX_M7C           (0x002b)  // 0.00260 * 2^LUX_SCALE
-#define LUX_K8C           (0x029a)  // 1.3 * 2^RATIO_SCALE
-#define LUX_B8C           (0x0000)  // 0.000 * 2^LUX_SCALE
-#define LUX_M8C           (0x0000)  // 0.000 * 2^LUX_SCALE
-
- /**
- * @brief TSL2561 Digital Light Sensor
- * @defgroup tsl2561 libupm-tsl2561
- * @ingroup seeed i2c light eak
- */
-/**
- * @library tsl2561
- * @sensor tsl2561
- * @comname Digital Light Sensor
- * @altname Grove Digital Light Sensor
- * @type light
- * @man seeed
- * @web http://www.seeedstudio.com/wiki/Grove_-_Digital_Light_Sensor
- * @con i2c
- * @kit eak
- *
- * @brief API for the TSL2561 Digital Light Sensor
- * 
- *   TSL2560 and TSL2561 are light-to-digital converters that transform
- *   light intensity to a digital signal output capable of a direct I2C (TSL2561) interface
- *
- * @image html tsl2561.jpg
- * @snippet tsl2561.cxx Interesting
- */
-class TSL2561{
-    public:
-       /**
-        * Instantiates a TSL2561 object
-        *
-        * @param bus Number of the used bus
-        * @param devAddr Address of the used I2C device
-        * @param gain Correct gain to use
-        * @param integrationTime Time to keep the shutter open
-        */
-        TSL2561(int bus=0, uint8_t devAddr=TSL2561_Address, uint8_t gain=GAIN_0X, uint8_t integrationTime=INTEGRATION_TIME1_101MS);
-
-       /**
-        * GY65 object destructor; powers down TSL2561 and closes the I2C connection.
-        */
-        ~TSL2561();
-
-       /**
-        * Gets the calculated lux reading from TSL2561
-        *
-        * @return Calculated lux value from the sensor
-        */
-        int getLux();
-
-    private:
-       /**
-        * Writes to a TSL2561 register
-        *
-        * @param reg Addess to write
-        * @param Value to write
-        * @return mraa::Result
-        */
-        mraa::Result i2cWriteReg(uint8_t reg, uint8_t value);
-
-       /**
-        * Reads from a TSL2561 register
-        *
-        * @param reg Addess to read
-        * @param data Byte read from the register
-        * @return mraa::Result
-        */
-        mraa::Result i2cReadReg(uint8_t reg, uint8_t &data);
-
-        int m_bus;
-        std::string m_name;
-        int m_controlAddr;
-        mraa::I2c m_i2ControlCtx;
-
-        uint8_t m_gain;
-        uint8_t m_integrationTime;
-};
-
-}
-
diff --git a/src/tsl2561/tsl2561.json b/src/tsl2561/tsl2561.json
deleted file mode 100644
index cb5d4cf..0000000
--- a/src/tsl2561/tsl2561.json
+++ /dev/null
@@ -1,64 +0,0 @@
-{
-    "Library": "tsl2561",
-    "Description": "TSL2561 Digital Light Sensor library",
-    "Sensor Class": {
-        "TSL2561": {
-            "Name": "API for the TSL2561 Digital Light Sensor",
-            "Description": "This is the UPM Module for the TSL2561 Digital Light Sensor. TSL2560 and TSL2561 are light-to-digital converters that transform light intensity to a digital signal output capable of a direct I2C (TSL2561) interface",
-            "Aliases": ["tsl2561", "Grove - Digital Light Sensor"],
-            "Categories": ["light"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["Seeed", "TAOS"],
-            "Kits": ["eak"],
-            "Image": "tsl2561.jpg",
-            "Examples": {
-                "Java": ["TSL2561_Example.java"],
-                "Python": ["tsl2561.py"],
-                "Node.js": ["tsl2561.js"],
-                "C++": ["tsl2561.cxx"],
-                "C": ["tsl2561.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.3,
-                    "max": 5.1
-                },
-                "Supply Current": {
-                    "unit": "uA",
-                    "min" : 240,
-                    "max" : 600
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -30,
-                    "max": 70
-                },
-                "Effective Range": {
-                    "unit": "Lux",
-                    "min" : 0.1,
-                    "max" : 40000
-                },
-                "Conversion Time": {
-                    "unit": "ms",
-                    "min" : 12,
-                    "max" : 400
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-Digital-Light-Sensor-p-1281.html", "http://wiki.seeed.cc/Grove-Digital_Light_Sensor/"],
-                "Datasheets": ["https://raw.githubusercontent.com/SeeedDocument/Grove-Digital_Light_Sensor/master/res/TSL2561T.pdf"],
-                "Schematics": ["https://github.com/SeeedDocument/Grove-Digital_Light_Sensor/raw/master/res/Digital%20light%20sensor%20v1.0%20Sch.pdf", "https://github.com/SeeedDocument/Grove-Digital_Light_Sensor/raw/master/res/Digital%20light%20sensor%20v1.0%20PCB.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/tsl2561/tsl2561_fti.c b/src/tsl2561/tsl2561_fti.c
deleted file mode 100644
index b3a6026..0000000
--- a/src/tsl2561/tsl2561_fti.c
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Author: Nandkishor Sonar <Nandkishor.Sonar@intel.com>,
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * LIGHT-TO-DIGITAL CONVERTER [TAOS-TSL2561]
- *   Inspiration and lux calculation formulas from data sheet
- *   URL: http://www.adafruit.com/datasheets/TSL2561.pdf
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "tsl2561.h"
-#include "upm_fti.h"
-
-/** 
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_tsl2561_name[] = "TSL2561";
-const char upm_tsl2561_description[] = "Grove Digital Light Sensor";
-const upm_protocol_t upm_tsl2561_protocol[] = {UPM_I2C};
-const upm_sensor_t upm_tsl2561_category[] = {UPM_LIGHT};
-
-// forward declarations
-const upm_sensor_descriptor_t upm_tsl2561_get_descriptor ();
-const void* upm_tsl2561_get_ft(upm_sensor_t sensor_type);
-void* upm_tsl2561_init_name();
-void upm_tsl2561_close(void* dev);
-upm_result_t upm_tsl2561_get_lux(const void* dev, float* lux);
-
-const upm_sensor_descriptor_t upm_tsl2561_get_descriptor (){
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_tsl2561_name;
-    usd.description = upm_tsl2561_description;
-    usd.protocol_size = 1;
-    usd.protocol = upm_tsl2561_protocol;
-    usd.category_size = 1;
-    usd.category = upm_tsl2561_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = &upm_tsl2561_init_name,
-    .upm_sensor_close = &upm_tsl2561_close,
-    .upm_sensor_get_descriptor = &upm_tsl2561_get_descriptor
-};
-
-static const upm_light_ft lft =
-{
-    .upm_light_get_value = &upm_tsl2561_get_lux
-};
-
-const void* upm_tsl2561_get_ft(upm_sensor_t sensor_type){
-    if(sensor_type == UPM_LIGHT){
-        return &lft;
-    }
-    else if(sensor_type == UPM_SENSOR){
-        return &ft;
-    }
-    return NULL;
-}
-
-void* upm_tsl2561_init_name(){
-    return NULL;
-}
-
-void upm_tsl2561_close(void* dev){
-    tsl2561_close((tsl2561_context)dev);
-}
-
-upm_result_t upm_tsl2561_get_lux(const void* dev, float* lux){
-    return tsl2561_get_lux((tsl2561_context)dev, lux);
-}
diff --git a/src/ttp223/CMakeLists.txt b/src/ttp223/CMakeLists.txt
deleted file mode 100644
index dc0450b..0000000
--- a/src/ttp223/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME ttp223
-    DESCRIPTION "Capacitive Touch Sensor"
-    C_HDR ttp223.h
-    C_SRC ttp223.c
-    CPP_HDR ttp223.hpp
-    CPP_SRC ttp223.cxx
-    FTI_SRC ttp223_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa)
diff --git a/src/ttp223/ttp223.c b/src/ttp223/ttp223.c
deleted file mode 100644
index 60761de..0000000
--- a/src/ttp223/ttp223.c
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Author: Sarah Knepper <sarah.knepper@intel.com>
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "ttp223.h"
-
-ttp223_context ttp223_init(int pin) {
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        return NULL;
-    }
-
-    ttp223_context dev = 
-      (ttp223_context) malloc(sizeof(struct _ttp223_context));
-
-    if (dev == NULL) {
-        printf("Unable to allocate space for the sensor struct\n");
-        return NULL;
-    }
-
-    dev->gpio = mraa_gpio_init(pin);
-    mraa_gpio_dir(dev->gpio, MRAA_GPIO_IN);
-    dev->isr_installed = false;
-
-    return dev;
-}
-
-void ttp223_close(ttp223_context dev){
-  mraa_gpio_close(dev->gpio);
-  free(dev);
-}
-
-upm_result_t ttp223_is_pressed(ttp223_context dev, bool* value) {
-    int ret = mraa_gpio_read(dev->gpio);
-
-    if (ret > 0)
-        *value = true;
-    else
-        *value = false;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t upm_ttp223_install_isr(ttp223_context dev,
-                                    mraa_gpio_edge_t edge_level,
-                                    void (*isr)(void *), void *arg){
-    ttp223_uninstall_isr(dev);
-
-    mraa_gpio_isr(dev->gpio, edge_level, isr, arg);
-    dev->isr_installed = true;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t ttp223_uninstall_isr(ttp223_context dev){
-    if (dev->isr_installed)
-        mraa_gpio_isr_exit(dev->gpio);
-
-    dev->isr_installed = false;
-
-    return UPM_SUCCESS;
-}
diff --git a/src/ttp223/ttp223.cxx b/src/ttp223/ttp223.cxx
deleted file mode 100644
index 94cef4e..0000000
--- a/src/ttp223/ttp223.cxx
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Author: Sarah Knepper <sarah.knepper@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string>
-#include <stdexcept>
-
-#include "ttp223.hpp"
-
-using namespace upm;
-
-TTP223::TTP223(unsigned int pin) {
-    // initialize gpio input
-    if ( !(m_gpio = mraa_gpio_init(pin)) )
-      {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_gpio_init() failed, invalid pin?");
-        return;
-      }
-    mraa_gpio_dir(m_gpio, MRAA_GPIO_IN);
-    m_name = "ttp223";
-    m_isrInstalled = false;
-}
-
-TTP223::~TTP223() {
-    // close gpio input
-    mraa_gpio_close(m_gpio);
-}
-
-std::string TTP223::name() {
-    return m_name;
-}
-
-int TTP223::value() {
-    return mraa_gpio_read(m_gpio);
-}
-
-bool TTP223::isPressed() {
-    return this->value() == 1;
-}
-
-
-void TTP223::installISR(mraa::Edge level, void (*isr)(void *), void *arg)
-{
-  if (m_isrInstalled)
-    uninstallISR();
-
-  // install our interrupt handler
-  mraa_gpio_isr(m_gpio, (mraa_gpio_edge_t) level, isr, arg);
-  m_isrInstalled = true;
-}
-
-void TTP223::uninstallISR()
-{
-  mraa_gpio_isr_exit(m_gpio);
-  m_isrInstalled = false;
-}
diff --git a/src/ttp223/ttp223.h b/src/ttp223/ttp223.h
deleted file mode 100644
index c82b0c8..0000000
--- a/src/ttp223/ttp223.h
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Author: Sarah Knepper <sarah.knepper@intel.com>
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef TTP223_H_
-#define TTP223_H_
-
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-
-#include "upm.h"
-#include "mraa/gpio.h"
-
-/**
- * @file ttp223.h
- * @library ttp223
- * @brief C API for the TTP223 Touch Detector Sensor
- *
- * @include ttp223.c
- */
-
-/**
- * device context
- */
-typedef struct _ttp223_context {
-    mraa_gpio_context       gpio;
-    bool                    isr_installed;
-} *ttp223_context;
-
-/**
- * Sensor Init function
- *
- * @param pin The pin number the sensor is attached to
- * @return void* pointer to the sensor struct
- */
-ttp223_context ttp223_init(int pin);
-
-/**
- * Sensor Module close function
- *
- * @param dev pointer to the sensor struct
- */
-void ttp223_close(ttp223_context dev);
-
-/**
- * Function to tell if the sensor is pressed
- *
- * @param dev pointer to the sensor struct
- * @param value pointer to store whether the sensor is pressed or not
- * @result upm_result_t UPM success/error code
- */
-upm_result_t ttp223_is_pressed(ttp223_context dev, bool* value);
-
-/**
- * Installs an interrupt service routine (ISR) to be called when
- * the button is activated or deactivated.
- *
- * @param dev pointer to the sensor struct
- * @param edge_level one of mraa_gpio_edge_t values
- * @param isr pointer to a function to be called on interrupt
- * @param arg pointer to an object to be supplied as an
- * argument to the ISR.
- * @result upm_result_t UPM success/error code
- */
-upm_result_t ttp223_install_isr(ttp223_context dev,
-                                mraa_gpio_edge_t edge_level,
-                                void (*isr)(void *), void *arg);
-
-/**
- * Uninstall a previously installed interrupt handler
- *
- * @param dev pointer to the sensor struct
- * @result upm_result_t UPM success/error code
- */
-upm_result_t ttp223_uninstall_isr(ttp223_context dev);
-
-#endif /* TTP223_H_ */
diff --git a/src/ttp223/ttp223.hpp b/src/ttp223/ttp223.hpp
deleted file mode 100644
index bae7766..0000000
--- a/src/ttp223/ttp223.hpp
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- * Author: Sarah Knepper <sarah.knepper@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/gpio.hpp>
-
-namespace upm {
-/**
- * @brief TTP223 Touch Detector Sensor
- * @defgroup ttp223 libupm-ttp223
- * @ingroup seeed gpio touch
- */
-/**
- * @library ttp223
- * @sensor ttp223
- * @comname Capacitive Touch Sensor
- * @altname Grove Touch Sensor
- * @type touch
- * @man seeed
- * @web http://www.seeedstudio.com/depot/Grove-Touch-Sensor-p-747.html
- * @con gpio
- *
- * @brief API for the TTP223 Touch Sensor
- *
- *   This touch sensor detects when a finger is near the metallic pad
- *   by the change in capacitance. It can replace a more traditional push
- *   button. The touch sensor can still function when placed under a
- *   non-metallic surface like glass or plastic.
- *
- * @image html ttp223.jpg
- * @snippet ttp223.cxx Interesting
- */
-class TTP223 {
-    public:
-        /**
-         * TTP223 constructor
-         *
-         * @param pin GPIO pin where the sensor is connected
-         */
-        TTP223(unsigned int pin);
-
-        /**
-         * TTP223 destructor
-         */
-        ~TTP223();
-
-        /**
-         * Returns the name of this sensor
-         *
-         * @return Name of this sensor
-         */
-        std::string name();
-
-        /**
-         * Gets the value from the GPIO pin
-         *
-         * @return Value from the GPIO pin
-         */
-        int value();
-
-        /**
-         * Determines whether the touch sensor is being touched
-         *
-         * @return True if touched, false otherwise
-         */
-        bool isPressed();
-
-        /**
-         * Installs an interrupt service routine (ISR) to be called when
-         * the button is activated or deactivated.
-         *
-         * @param isr Pointer to a function to be called on interrupt
-         * @param arg Pointer to an object to be supplied as an
-         * argument to the ISR.
-         */
-
-        void installISR(mraa::Edge level, void (*isr)(void *), void *arg);
-        /**
-         * Uninstalls the previously installed ISR
-         *
-         */
-        void uninstallISR();
-
-    protected:
-        std::string         m_name; //!< name of this sensor
-        mraa_gpio_context   m_gpio; //!< GPIO pin
-        bool                m_isrInstalled;
-};
-
-}
diff --git a/src/ttp223/ttp223.i b/src/ttp223/ttp223.i
deleted file mode 100644
index bba2a34..0000000
--- a/src/ttp223/ttp223.i
+++ /dev/null
@@ -1,20 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%module (docstring="TTP223 Touch Sensor") javaupm_ttp223
-
-%apply int {mraa::Edge}
-
-JAVA_ADD_INSTALLISR_EDGE(upm::TTP223)
-
-JAVA_JNI_LOADLIBRARY(javaupm_ttp223)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "ttp223.hpp"
-%}
-%include "ttp223.hpp"
-/* END Common SWIG syntax */
diff --git a/src/ttp223/ttp223.json b/src/ttp223/ttp223.json
deleted file mode 100644
index 6b89b8a..0000000
--- a/src/ttp223/ttp223.json
+++ /dev/null
@@ -1,58 +0,0 @@
-{
-    "Library": "ttp223",
-    "Description": "Seeed TTP223 Touch Detector Sensor library",
-    "Sensor Class": {
-        "TTP223": {
-            "Name": "API for the Seeed TTP223 Touch Sensor",
-            "Description": "This is the UPM Module for the Seeed TTP223 Touch Sensor. This touch sensor detects when a finger is near the metallic pad by the change in capacitance. It can replace a more traditional push button. The touch sensor can still function when placed under a  non-metallic surface like glass or plastic.",
-            "Aliases": ["ttp223", "Grove - Touch Sensor"],
-            "Categories": ["touch"],
-            "Connections": ["gpio"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["Seeed"],
-            "Image": "ttp223.jpg",
-            "Examples": {
-                "Java": ["TTP223_Example.java"],
-                "Python": ["ttp223.py"],
-                "Node.js": ["ttp223.js"],
-                "C++": ["ttp223.cxx"],
-                "C": ["ttp223.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 2.0,
-                    "max": 5.5
-                },
-                "Supply Current": {
-                    "unit": "uA",
-                    "min" : 1.5,
-                    "max" : 7.0
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -20,
-                    "max": 70
-                },
-                "Response Time": {
-                    "unit": "ms",
-                    "min" : 60,
-                    "max" : 220
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-Touch-Sensor-p-747.html", "http://wiki.seeed.cc/Grove-Touch_Sensor/"],
-                "Datasheets": ["https://raw.githubusercontent.com/SeeedDocument/Grove-Touch_Sensor/master/res/TTP223.pdf"],
-                "Schematics": ["https://raw.githubusercontent.com/SeeedDocument/Grove-Touch_Sensor/master/res/Touch_sensor_Eagle_File.zip"]
-            }
-        }
-    }
-}
diff --git a/src/ttp223/ttp223_fti.c b/src/ttp223/ttp223_fti.c
deleted file mode 100644
index fb7e7db..0000000
--- a/src/ttp223/ttp223_fti.c
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * Author: Sarah Knepper <sarah.knepper@intel.com>
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "ttp223.h"
-#include "upm_fti.h"
-
-/** 
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_ttp223_name[] = "TTP223";
-const char upm_ttp223_description[] = "TTP223 Touch Detector Sensor";
-const upm_protocol_t upm_ttp223_protocol[] = {UPM_GPIO};
-const upm_sensor_t upm_ttp223_category[] = {UPM_SWITCH};
-
-// forward declarations
-const upm_sensor_descriptor_t upm_ttp223_get_descriptor();
-const void* upm_ttp223_get_ft(upm_sensor_t sensor_type);
-void* upm_ttp223_init_name();
-void upm_ttp223_close(void* dev);
-upm_result_t upm_ttp223_is_pressed(void* dev, bool* value, int num);
-
-const upm_sensor_descriptor_t upm_ttp223_get_descriptor(){
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_ttp223_name;
-    usd.description = upm_ttp223_description;
-    usd.protocol_size = 1;
-    usd.protocol = upm_ttp223_protocol;
-    usd.category_size = 1;
-    usd.category = upm_ttp223_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = &upm_ttp223_init_name,
-    .upm_sensor_close = &upm_ttp223_close,
-    .upm_sensor_get_descriptor = &upm_ttp223_get_descriptor
-};
-
-static const upm_switch_ft sft =
-{
-    .upm_switch_get_value = &upm_ttp223_is_pressed
-};
-
-const void* upm_ttp223_get_ft(upm_sensor_t sensor_type){
-    if(sensor_type == UPM_SWITCH){
-        return &sft;
-    }
-    else if(sensor_type == UPM_SENSOR){
-        return &ft;
-    }
-    return NULL;
-}
-
-void* upm_ttp223_init_name(){
-    return NULL;
-}
-
-void upm_ttp223_close(void* dev){
-    ttp223_close((ttp223_context)dev);
-}
-
-upm_result_t upm_ttp223_is_pressed(void* dev, bool* value, int num) {
-    if(num != 1){
-        printf("Sorry this sensor driver supports only one touch pad\n");
-        return UPM_ERROR_OUT_OF_RANGE;
-    }
-
-    return ttp223_is_pressed((ttp223_context)dev, value);
-}
\ No newline at end of file
-- 
2.7.4

