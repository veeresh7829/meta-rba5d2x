From a785e63b5ded112baf7783ce24f35d11d5fcb15a Mon Sep 17 00:00:00 2001
From: Ganesh K <ganesh.k@phytec.in>
Date: Mon, 24 Jun 2019 19:02:04 +0530
Subject: [PATCH 13/13] starting with t-z files

---
 src/t3311/CMakeLists.txt           |  10 -
 src/t3311/t3311.cxx                | 308 -----------------
 src/t3311/t3311.hpp                | 310 -----------------
 src/t3311/t3311.i                  |  19 -
 src/t3311/t3311.json               |  60 ----
 src/t6713/CMakeLists.txt           |   5 -
 src/t6713/t6713.cxx                | 244 -------------
 src/t6713/t6713.hpp                | 145 --------
 src/t6713/t6713.i                  |  25 --
 src/t6713/t6713.json               |  60 ----
 src/t8100/CMakeLists.txt           |   8 -
 src/t8100/t8100.cxx                | 254 --------------
 src/t8100/t8100.hpp                | 379 --------------------
 src/t8100/t8100.i                  |  18 -
 src/t8100/t8100.json               |  83 -----
 src/ta12200/CMakeLists.txt         |   5 -
 src/ta12200/ta12200.cxx            | 119 -------
 src/ta12200/ta12200.hpp            | 112 ------
 src/ta12200/ta12200.json           |  59 ----
 src/tb7300/CMakeLists.txt          |   8 -
 src/tb7300/tb7300.cxx              | 108 ------
 src/tb7300/tb7300.hpp              | 258 --------------
 src/tb7300/tb7300.i                |  29 --
 src/tb7300/tb7300.json             |  46 ---
 src/tca9548a/CMakeLists.txt        |   5 -
 src/tca9548a/tca9548a.cxx          | 138 --------
 src/tca9548a/tca9548a.hpp          | 189 ----------
 src/tca9548a/tca9548a.json         |  56 ---
 src/tcs3414cs/CMakeLists.txt       |   5 -
 src/tcs3414cs/tcs3414cs.cxx        | 126 -------
 src/tcs3414cs/tcs3414cs.hpp        | 167 ---------
 src/tcs3414cs/tcs3414cs.json       |  50 ---
 src/tcs37727/CMakeLists.txt        |   5 -
 src/tcs37727/tcs37727.cpp          | 349 -------------------
 src/tcs37727/tcs37727.hpp          | 289 ----------------
 src/tcs37727/tcs37727.json         |  40 ---
 src/teams/CMakeLists.txt           |   5 -
 src/teams/teams.cxx                | 125 -------
 src/teams/teams.hpp                | 174 ----------
 src/teams/teams.i                  |  14 -
 src/teams/teams.json               |  47 ---
 src/temperature/CMakeLists.txt     |   8 -
 src/temperature/temperature.c      |  77 -----
 src/temperature/temperature.cxx    |  68 ----
 src/temperature/temperature.h      |  76 ----
 src/temperature/temperature.hpp    | 106 ------
 src/temperature/temperature.json   |  39 ---
 src/temperature/temperature_fti.c  | 118 -------
 src/tex00/CMakeLists.txt           |   5 -
 src/tex00/tex00.cxx                | 693 -------------------------------------
 src/tex00/tex00.hpp                | 216 ------------
 src/tex00/tex00.i                  |  14 -
 src/tex00/tex00.json               |  52 ---
 src/th02/CMakeLists.txt            |   5 -
 src/th02/th02.cxx                  | 103 ------
 src/th02/th02.hpp                  | 113 ------
 src/th02/th02.json                 |  77 -----
 src/tm1637/CMakeLists.txt          |   5 -
 src/tm1637/tm1637.cxx              | 200 -----------
 src/tm1637/tm1637.hpp              | 143 --------
 src/tm1637/tm1637.i                |  32 --
 src/tm1637/tm1637.json             |  52 ---
 src/tmp006/CMakeLists.txt          |   5 -
 src/tmp006/tmp006.cpp              | 278 ---------------
 src/tmp006/tmp006.hpp              | 214 ------------
 src/tmp006/tmp006.json             |  50 ---
 src/tsl2561/CMakeLists.txt         |   9 -
 src/tsl2561/tsl2561.c              | 245 -------------
 src/tsl2561/tsl2561.cxx            | 235 -------------
 src/tsl2561/tsl2561.h              | 164 ---------
 src/tsl2561/tsl2561.hpp            | 171 ---------
 src/tsl2561/tsl2561.json           |  64 ----
 src/tsl2561/tsl2561_fti.c          |  92 -----
 src/ttp223/CMakeLists.txt          |   9 -
 src/ttp223/ttp223.c                |  86 -----
 src/ttp223/ttp223.cxx              |  77 -----
 src/ttp223/ttp223.h                |  99 ------
 src/ttp223/ttp223.hpp              | 112 ------
 src/ttp223/ttp223.i                |  20 --
 src/ttp223/ttp223.json             |  58 ----
 src/ttp223/ttp223_fti.c            |  93 -----
 src/uartat/CMakeLists.txt          |   8 -
 src/uartat/uartat.c                | 410 ----------------------
 src/uartat/uartat.cxx              | 173 ---------
 src/uartat/uartat.h                | 282 ---------------
 src/uartat/uartat.hpp              | 265 --------------
 src/uartat/uartat.i                |  16 -
 src/uartat/uartat.json             |  25 --
 src/uartat/uartat_defs.h           |  54 ---
 src/uln200xa/CMakeLists.txt        |   8 -
 src/uln200xa/uln200xa.c            | 260 --------------
 src/uln200xa/uln200xa.cxx          |  66 ----
 src/uln200xa/uln200xa.h            | 116 -------
 src/uln200xa/uln200xa.hpp          | 116 -------
 src/uln200xa/uln200xa.i            |  15 -
 src/uln200xa/uln200xa.json         |  53 ---
 src/uln200xa/uln200xa_defs.h       |  41 ---
 src/ultrasonic/CMakeLists.txt      |   5 -
 src/ultrasonic/ultrasonic.cxx      | 102 ------
 src/ultrasonic/ultrasonic.hpp      | 122 -------
 src/ultrasonic/ultrasonic.i        |  16 -
 src/ultrasonic/ultrasonic.json     |  61 ----
 src/urm37/CMakeLists.txt           |   9 -
 src/urm37/urm37.c                  | 393 ---------------------
 src/urm37/urm37.cxx                |  98 ------
 src/urm37/urm37.h                  | 159 ---------
 src/urm37/urm37.hpp                | 159 ---------
 src/urm37/urm37.i                  |  14 -
 src/urm37/urm37.json               |  50 ---
 src/urm37/urm37_fti.c              | 109 ------
 src/vcap/CMakeLists.txt            |  10 -
 src/vcap/vcap.cxx                  | 524 ----------------------------
 src/vcap/vcap.hpp                  | 215 ------------
 src/vcap/vcap.i                    |  14 -
 src/vcap/vcap.json                 |  24 --
 src/vdiv/CMakeLists.txt            |   8 -
 src/vdiv/vdiv.c                    | 130 -------
 src/vdiv/vdiv.cxx                  |  68 ----
 src/vdiv/vdiv.h                    | 147 --------
 src/vdiv/vdiv.hpp                  |  99 ------
 src/vdiv/vdiv.json                 |  70 ----
 src/vdiv/vdiv_fti.c                | 118 -------
 src/veml6070/CMakeLists.txt        |   8 -
 src/veml6070/veml6070.c            | 108 ------
 src/veml6070/veml6070.cxx          |  55 ---
 src/veml6070/veml6070.h            | 101 ------
 src/veml6070/veml6070.hpp          | 112 ------
 src/veml6070/veml6070.i            |  14 -
 src/veml6070/veml6070.json         |  55 ---
 src/water/CMakeLists.txt           |   9 -
 src/water/water.c                  |  79 -----
 src/water/water.cxx                |  50 ---
 src/water/water.h                  |  70 ----
 src/water/water.hpp                |  78 -----
 src/water/water.json               |  57 ---
 src/water/water_fti.c              |  82 -----
 src/waterlevel/CMakeLists.txt      |   5 -
 src/waterlevel/waterlevel.cxx      |  51 ---
 src/waterlevel/waterlevel.hpp      |  70 ----
 src/waterlevel/waterlevel.json     |  41 ---
 src/wfs/CMakeLists.txt             |   8 -
 src/wfs/wfs.c                      | 152 --------
 src/wfs/wfs.cxx                    |  72 ----
 src/wfs/wfs.h                      | 134 -------
 src/wfs/wfs.hpp                    | 136 --------
 src/wfs/wfs.i                      |  16 -
 src/wfs/wfs.json                   |  75 ----
 src/wheelencoder/CMakeLists.txt    |   5 -
 src/wheelencoder/wheelencoder.cxx  | 106 ------
 src/wheelencoder/wheelencoder.hpp  | 132 -------
 src/wheelencoder/wheelencoder.json |  53 ---
 src/wt5001/CMakeLists.txt          |   5 -
 src/wt5001/wt5001.cxx              | 632 ---------------------------------
 src/wt5001/wt5001.hpp              | 383 --------------------
 src/wt5001/wt5001.i                |  58 ----
 src/wt5001/wt5001.json             |  51 ---
 src/xbee/CMakeLists.txt            |   5 -
 src/xbee/xbee.cxx                  | 102 ------
 src/xbee/xbee.hpp                  | 193 -----------
 src/xbee/xbee.i                    |  16 -
 src/xbee/xbee.json                 |  61 ----
 src/yg1006/CMakeLists.txt          |   9 -
 src/yg1006/yg1006.c                |  77 -----
 src/yg1006/yg1006.cxx              |  50 ---
 src/yg1006/yg1006.h                |  73 ----
 src/yg1006/yg1006.hpp              |  87 -----
 src/yg1006/yg1006.json             |  67 ----
 src/yg1006/yg1006_fti.c            |  82 -----
 src/zfm20/CMakeLists.txt           |   5 -
 src/zfm20/zfm20.cxx                | 458 ------------------------
 src/zfm20/zfm20.hpp                | 373 --------------------
 src/zfm20/zfm20.i                  |  24 --
 src/zfm20/zfm20.json               |  66 ----
 173 files changed, 18182 deletions(-)
 delete mode 100644 src/t3311/CMakeLists.txt
 delete mode 100644 src/t3311/t3311.cxx
 delete mode 100644 src/t3311/t3311.hpp
 delete mode 100644 src/t3311/t3311.i
 delete mode 100644 src/t3311/t3311.json
 delete mode 100644 src/t6713/CMakeLists.txt
 delete mode 100644 src/t6713/t6713.cxx
 delete mode 100644 src/t6713/t6713.hpp
 delete mode 100644 src/t6713/t6713.i
 delete mode 100644 src/t6713/t6713.json
 delete mode 100644 src/t8100/CMakeLists.txt
 delete mode 100644 src/t8100/t8100.cxx
 delete mode 100644 src/t8100/t8100.hpp
 delete mode 100644 src/t8100/t8100.i
 delete mode 100644 src/t8100/t8100.json
 delete mode 100644 src/ta12200/CMakeLists.txt
 delete mode 100644 src/ta12200/ta12200.cxx
 delete mode 100644 src/ta12200/ta12200.hpp
 delete mode 100644 src/ta12200/ta12200.json
 delete mode 100644 src/tb7300/CMakeLists.txt
 delete mode 100644 src/tb7300/tb7300.cxx
 delete mode 100644 src/tb7300/tb7300.hpp
 delete mode 100644 src/tb7300/tb7300.i
 delete mode 100644 src/tb7300/tb7300.json
 delete mode 100644 src/tca9548a/CMakeLists.txt
 delete mode 100644 src/tca9548a/tca9548a.cxx
 delete mode 100644 src/tca9548a/tca9548a.hpp
 delete mode 100644 src/tca9548a/tca9548a.json
 delete mode 100644 src/tcs3414cs/CMakeLists.txt
 delete mode 100644 src/tcs3414cs/tcs3414cs.cxx
 delete mode 100644 src/tcs3414cs/tcs3414cs.hpp
 delete mode 100644 src/tcs3414cs/tcs3414cs.json
 delete mode 100644 src/tcs37727/CMakeLists.txt
 delete mode 100644 src/tcs37727/tcs37727.cpp
 delete mode 100644 src/tcs37727/tcs37727.hpp
 delete mode 100644 src/tcs37727/tcs37727.json
 delete mode 100644 src/teams/CMakeLists.txt
 delete mode 100644 src/teams/teams.cxx
 delete mode 100644 src/teams/teams.hpp
 delete mode 100644 src/teams/teams.i
 delete mode 100644 src/teams/teams.json
 delete mode 100644 src/temperature/CMakeLists.txt
 delete mode 100644 src/temperature/temperature.c
 delete mode 100644 src/temperature/temperature.cxx
 delete mode 100644 src/temperature/temperature.h
 delete mode 100644 src/temperature/temperature.hpp
 delete mode 100644 src/temperature/temperature.json
 delete mode 100644 src/temperature/temperature_fti.c
 delete mode 100644 src/tex00/CMakeLists.txt
 delete mode 100644 src/tex00/tex00.cxx
 delete mode 100644 src/tex00/tex00.hpp
 delete mode 100644 src/tex00/tex00.i
 delete mode 100644 src/tex00/tex00.json
 delete mode 100644 src/th02/CMakeLists.txt
 delete mode 100644 src/th02/th02.cxx
 delete mode 100644 src/th02/th02.hpp
 delete mode 100644 src/th02/th02.json
 delete mode 100644 src/tm1637/CMakeLists.txt
 delete mode 100644 src/tm1637/tm1637.cxx
 delete mode 100644 src/tm1637/tm1637.hpp
 delete mode 100644 src/tm1637/tm1637.i
 delete mode 100644 src/tm1637/tm1637.json
 delete mode 100644 src/tmp006/CMakeLists.txt
 delete mode 100644 src/tmp006/tmp006.cpp
 delete mode 100644 src/tmp006/tmp006.hpp
 delete mode 100644 src/tmp006/tmp006.json
 delete mode 100644 src/tsl2561/CMakeLists.txt
 delete mode 100644 src/tsl2561/tsl2561.c
 delete mode 100644 src/tsl2561/tsl2561.cxx
 delete mode 100644 src/tsl2561/tsl2561.h
 delete mode 100644 src/tsl2561/tsl2561.hpp
 delete mode 100644 src/tsl2561/tsl2561.json
 delete mode 100644 src/tsl2561/tsl2561_fti.c
 delete mode 100644 src/ttp223/CMakeLists.txt
 delete mode 100644 src/ttp223/ttp223.c
 delete mode 100644 src/ttp223/ttp223.cxx
 delete mode 100644 src/ttp223/ttp223.h
 delete mode 100644 src/ttp223/ttp223.hpp
 delete mode 100644 src/ttp223/ttp223.i
 delete mode 100644 src/ttp223/ttp223.json
 delete mode 100644 src/ttp223/ttp223_fti.c
 delete mode 100644 src/uartat/CMakeLists.txt
 delete mode 100644 src/uartat/uartat.c
 delete mode 100644 src/uartat/uartat.cxx
 delete mode 100644 src/uartat/uartat.h
 delete mode 100644 src/uartat/uartat.hpp
 delete mode 100644 src/uartat/uartat.i
 delete mode 100644 src/uartat/uartat.json
 delete mode 100644 src/uartat/uartat_defs.h
 delete mode 100644 src/uln200xa/CMakeLists.txt
 delete mode 100644 src/uln200xa/uln200xa.c
 delete mode 100644 src/uln200xa/uln200xa.cxx
 delete mode 100644 src/uln200xa/uln200xa.h
 delete mode 100644 src/uln200xa/uln200xa.hpp
 delete mode 100644 src/uln200xa/uln200xa.i
 delete mode 100644 src/uln200xa/uln200xa.json
 delete mode 100644 src/uln200xa/uln200xa_defs.h
 delete mode 100644 src/ultrasonic/CMakeLists.txt
 delete mode 100644 src/ultrasonic/ultrasonic.cxx
 delete mode 100644 src/ultrasonic/ultrasonic.hpp
 delete mode 100644 src/ultrasonic/ultrasonic.i
 delete mode 100644 src/ultrasonic/ultrasonic.json
 delete mode 100644 src/urm37/CMakeLists.txt
 delete mode 100644 src/urm37/urm37.c
 delete mode 100644 src/urm37/urm37.cxx
 delete mode 100644 src/urm37/urm37.h
 delete mode 100644 src/urm37/urm37.hpp
 delete mode 100644 src/urm37/urm37.i
 delete mode 100644 src/urm37/urm37.json
 delete mode 100644 src/urm37/urm37_fti.c
 delete mode 100644 src/vcap/CMakeLists.txt
 delete mode 100644 src/vcap/vcap.cxx
 delete mode 100644 src/vcap/vcap.hpp
 delete mode 100644 src/vcap/vcap.i
 delete mode 100644 src/vcap/vcap.json
 delete mode 100644 src/vdiv/CMakeLists.txt
 delete mode 100644 src/vdiv/vdiv.c
 delete mode 100644 src/vdiv/vdiv.cxx
 delete mode 100644 src/vdiv/vdiv.h
 delete mode 100644 src/vdiv/vdiv.hpp
 delete mode 100644 src/vdiv/vdiv.json
 delete mode 100644 src/vdiv/vdiv_fti.c
 delete mode 100644 src/veml6070/CMakeLists.txt
 delete mode 100644 src/veml6070/veml6070.c
 delete mode 100644 src/veml6070/veml6070.cxx
 delete mode 100644 src/veml6070/veml6070.h
 delete mode 100644 src/veml6070/veml6070.hpp
 delete mode 100644 src/veml6070/veml6070.i
 delete mode 100644 src/veml6070/veml6070.json
 delete mode 100644 src/water/CMakeLists.txt
 delete mode 100644 src/water/water.c
 delete mode 100644 src/water/water.cxx
 delete mode 100644 src/water/water.h
 delete mode 100644 src/water/water.hpp
 delete mode 100644 src/water/water.json
 delete mode 100644 src/water/water_fti.c
 delete mode 100644 src/waterlevel/CMakeLists.txt
 delete mode 100644 src/waterlevel/waterlevel.cxx
 delete mode 100644 src/waterlevel/waterlevel.hpp
 delete mode 100644 src/waterlevel/waterlevel.json
 delete mode 100644 src/wfs/CMakeLists.txt
 delete mode 100644 src/wfs/wfs.c
 delete mode 100644 src/wfs/wfs.cxx
 delete mode 100644 src/wfs/wfs.h
 delete mode 100644 src/wfs/wfs.hpp
 delete mode 100644 src/wfs/wfs.i
 delete mode 100644 src/wfs/wfs.json
 delete mode 100644 src/wheelencoder/CMakeLists.txt
 delete mode 100644 src/wheelencoder/wheelencoder.cxx
 delete mode 100644 src/wheelencoder/wheelencoder.hpp
 delete mode 100644 src/wheelencoder/wheelencoder.json
 delete mode 100644 src/wt5001/CMakeLists.txt
 delete mode 100644 src/wt5001/wt5001.cxx
 delete mode 100644 src/wt5001/wt5001.hpp
 delete mode 100644 src/wt5001/wt5001.i
 delete mode 100644 src/wt5001/wt5001.json
 delete mode 100644 src/xbee/CMakeLists.txt
 delete mode 100644 src/xbee/xbee.cxx
 delete mode 100644 src/xbee/xbee.hpp
 delete mode 100644 src/xbee/xbee.i
 delete mode 100644 src/xbee/xbee.json
 delete mode 100644 src/yg1006/CMakeLists.txt
 delete mode 100644 src/yg1006/yg1006.c
 delete mode 100644 src/yg1006/yg1006.cxx
 delete mode 100644 src/yg1006/yg1006.h
 delete mode 100644 src/yg1006/yg1006.hpp
 delete mode 100644 src/yg1006/yg1006.json
 delete mode 100644 src/yg1006/yg1006_fti.c
 delete mode 100644 src/zfm20/CMakeLists.txt
 delete mode 100644 src/zfm20/zfm20.cxx
 delete mode 100644 src/zfm20/zfm20.hpp
 delete mode 100644 src/zfm20/zfm20.i
 delete mode 100644 src/zfm20/zfm20.json

diff --git a/src/t3311/CMakeLists.txt b/src/t3311/CMakeLists.txt
deleted file mode 100644
index 3650c99..0000000
--- a/src/t3311/CMakeLists.txt
+++ /dev/null
@@ -1,10 +0,0 @@
-if (MODBUS_FOUND)
-  set (libname "t3311")
-  set (libdescription "Temperature and Humidity Probe")
-  set (module_src ${libname}.cxx)
-  set (module_hpp ${libname}.hpp)
-
-  set (reqlibname "libmodbus")
-  upm_module_init(${MODBUS_LIBRARIES})
-  target_include_directories(${libname} PUBLIC ${MODBUS_INCLUDE_DIRS})
-endif ()
diff --git a/src/t3311/t3311.cxx b/src/t3311/t3311.cxx
deleted file mode 100644
index e660815..0000000
--- a/src/t3311/t3311.cxx
+++ /dev/null
@@ -1,308 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <iostream>
-#include <stdexcept>
-#include <string>
-#include <sstream>
-
-#include "t3311.hpp"
-
-using namespace upm;
-using namespace std;
-
-// conversion from fahrenheit to celsius and back
-
-static float f2c(float f)
-{
-  return ((f - 32.0) / (9.0 / 5.0));
-}
-
-static float c2f(float c)
-{
-  return (c * (9.0 / 5.0) + 32.0);
-}
-
-// conversion from 1-byte BCD to decimal
-static uint8_t bcd2dec(uint8_t bcd)
-{
-  return (bcd / 16 * 10) + (bcd % 16);
-}
-
-T3311::T3311(std::string device, int address, int baud, int bits, char parity,
-             int stopBits) :
-  m_mbContext(0)
-{
-  // check some of the parameters
-  if (!(bits == 7 || bits == 8))
-    {
-      throw std::out_of_range(std::string(__FUNCTION__) +
-                              ": bits must be 7 or 8");
-    }
-
-  if (!(parity == 'N' || parity == 'E' || parity == 'O'))
-    {
-      throw std::out_of_range(std::string(__FUNCTION__) +
-                              ": parity must be 'N', 'O', or 'E'");
-    }
-
-  if (!(stopBits == 1 || stopBits == 2))
-    {
-      throw std::out_of_range(std::string(__FUNCTION__) +
-                              ": stopBits must be 1 or 2");
-    }
-
-  m_temperature = 0.0;
-  m_humidity = 0.0;
-  m_computedValue = 0.0;
-  m_dewPointTemperature = 0.0;
-  m_absoluteHumidity = 0.0;
-  m_specificHumidity = 0.0;
-  m_mixingRatio = 0.0;
-  m_specificEnthalpy = 0.0;
-
-  // addresses are only 8bits wide
-  address &= 0xff;
-
-  // now, open/init the device and modbus context
-
-  if (!(m_mbContext = modbus_new_rtu(device.c_str(), baud, parity, bits,
-                                     stopBits)))
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": modbus_new_rtu() failed");
-    }
-
-  // set the slave address of the device we want to talk to
-  if (modbus_set_slave(m_mbContext, address))
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": modbus_set_slave() failed");
-    }
-
-  // set the serial mode
-  modbus_rtu_set_serial_mode(m_mbContext, MODBUS_RTU_RS232);
-
-  // now connect..
-  if (modbus_connect(m_mbContext))
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": modbus_connect() failed");
-    }
-
-  // This is a bit of a hack.  The device uses bus power, which isn't
-  // provided unless the device has been opened and accessed.  As a
-  // result, register reads will usually fail the first time the
-  // device is accessed after a power cycle.  Here, we read the
-  // temperature value (which will most likely fail), then sleep,
-  // allowing the sensor to "boot".  The datasheet says it takes at
-  // about 2 seconds to boot, we will wait for 5.
-  uint16_t tmp;
-  modbus_read_input_registers(m_mbContext, REG_TEMPERATURE, 1, &tmp);
-
-  // sleep for 5 seconds to give time for device to powerup and boot
-  sleep(5);
-
-  // turn off debugging
-  setDebug(false);
-
-  // now read the UNIT_SETTING reg to see what units we are getting
-  // our temperature data in.
-  tmp = readInputReg(REG_UNIT_SETTINGS);
-  if (tmp & 0x0001)
-    m_isCelsius = false;
-  else
-    m_isCelsius = true;
-
-  // read in the the FW_LO register (BCD encoded) and convert
-  tmp = readInputReg(REG_FW_LO);
-
-  // HI byte (major)
-  m_fwRevHi = (tmp >> 8) & 0xff;
-  m_fwRevHi = bcd2dec(m_fwRevHi);
-
-  // LO byte (minor)
-  m_fwRevLo = (tmp & 0xff);
-  m_fwRevLo = bcd2dec(m_fwRevLo);
-
-  if (m_fwRevHi >= 2 && m_fwRevLo >= 44)
-    m_isExtendedDataAvailable = true;
-  else
-    m_isExtendedDataAvailable = false;
-
-  // now get the serial number (BCD encoded 4-byte value, which we
-  // will pack into a string)
-  stringstream preformat;
-  uint8_t b;
-  // LO (but really HI)
-  tmp = readInputReg(REG_SERIAL_LO);
-  b = bcd2dec((tmp & 0xff00) >> 8);
-  preformat << int(b);
-
-  b = bcd2dec(tmp & 0x00ff);
-  preformat << int(b);
-
-  // HI (but really LO)
-  tmp = readInputReg(REG_SERIAL_HI);
-
-  b = bcd2dec((tmp & 0xff00) >> 8);
-  preformat << int(b);
-  b = bcd2dec(tmp & 0x00ff);
-  preformat << int(b);
-
-  m_serialNumber = preformat.str();
-}
-
-T3311::~T3311()
-{
-  if (m_mbContext)
-    {
-      modbus_close(m_mbContext);
-      modbus_free(m_mbContext);
-    }
-}
-
-uint16_t T3311::readInputReg(int reg)
-{
-  uint16_t val;
-
-  if (modbus_read_input_registers(m_mbContext, reg, 1, &val) <= 0)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": modbus_read_input_registers() failed");
-    }
-
-  return val;
-}
-
-int T3311::readInputRegs(int reg, int len, uint16_t *buf)
-{
-  int rv;
-
-  if ((rv = modbus_read_input_registers(m_mbContext, reg, len, buf)) < 0)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": modbus_read_input_registers() failed");
-    }
-
-  return rv;
-}
-
-void T3311::update()
-{
-  static const int dataLen = 9;
-  uint16_t data[dataLen];
-
-  // we read the 9 registers starting at the temperature
-  if (readInputRegs(REG_TEMPERATURE, dataLen, data) != dataLen)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": read less than the expected 9 registers");
-    }
-
-  // temperature first, we always store as C
-  float tmpF = float((int16_t)data[0]) / 10.0;
-  if (m_isCelsius)
-    m_temperature = tmpF;
-  else
-    m_temperature = f2c(tmpF);
-
-  m_humidity = float((int16_t)data[1]) / 10.0;
-  m_computedValue = float((int16_t)data[2]) / 10.0;
-
-  // skip data[3], (pressure) as this device does not support it
-
-  // if extended info is supported, grab those too
-  if (extendedDataAvailable())
-    {
-      // we always store temps in C
-      tmpF = float((int16_t)data[4]) / 10.0;
-      if (m_isCelsius)
-        m_dewPointTemperature = tmpF;
-      else
-        m_dewPointTemperature = f2c(tmpF);
-
-      m_absoluteHumidity = float((int16_t)data[5]) / 10.0;
-      m_specificHumidity = float((int16_t)data[6]) / 10.0;
-      m_mixingRatio = float((int16_t)data[7]) / 10.0;
-      m_specificEnthalpy = float((int16_t)data[8]) / 10.0;
-    }
-}
-
-float T3311::getTemperature(bool fahrenheit)
-{
-  if (fahrenheit)
-    return c2f(m_temperature);
-  else
-    return m_temperature;
-}
-
-float T3311::getHumidity()
-{
-  return m_humidity;
-}
-
-float T3311::getComputedValue()
-{
-  return m_computedValue;
-}
-
-float T3311::getDewPointTemperature(bool fahrenheit)
-{
-  if (fahrenheit)
-    return c2f(m_dewPointTemperature);
-  else
-    return m_dewPointTemperature;
-}
-
-float T3311::getAbsoluteHumidity()
-{
-  return m_absoluteHumidity;
-}
-
-float T3311::getSpecificHumidity()
-{
-  return m_specificHumidity;
-}
-
-float T3311::getMixingRatio()
-{
-  return m_mixingRatio;
-}
-
-float T3311::getSpecificEnthalpy()
-{
-  return m_specificEnthalpy;
-}
-
-void T3311::setDebug(bool enable)
-{
-  m_debugging = enable;
-
-  if (enable)
-    modbus_set_debug(m_mbContext, 1);
-  else
-    modbus_set_debug(m_mbContext, 0);
-}
diff --git a/src/t3311/t3311.hpp b/src/t3311/t3311.hpp
deleted file mode 100644
index d519ae7..0000000
--- a/src/t3311/t3311.hpp
+++ /dev/null
@@ -1,310 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-
-#include <modbus/modbus.h>
-
-namespace upm {
-
-  /**
-   * @brief T3311 Temperature and Humidity Sensor
-   * @defgroup t3311 libupm-t3311
-   * @ingroup uart temp
-   */
-
-  /**
-   * @library t3311
-   * @sensor t3311
-   * @comname Temperature and Humidity Probe
-   * @type temp
-   * @man comet
-   * @con uart
-   * @web http://www.cometsystem.com/products/reg-T3311
-   *
-   * @brief UPM API for the T3311 MODBUS Temperature and Humidity Sensor
-   *
-   * This module implements support for the Comet System T3311
-   * Temperature and Humidity transmitter.  It uses MODBUS over an
-   * RS232 serial port.  You must have libmodbus v3.1.2 (or greater)
-   * installed to compile and use this driver.
-   *
-   * This module was developed using libmodbus 3.1.2, and T3311
-   * Firmware revison 2.66 connected via a Prolific RS232 Serial to
-   * USB adaptor. You cannot use the built in TTL UART pins for
-   * accessing this device -- you must use a full serial RS232
-   * interface connected via USB.
-   *
-   * @snippet t3311.cxx Interesting
-   */
-
-  class T3311 {
-  public:
-
-    // MODBUS input registers
-    typedef enum {
-      REG_TEMPERATURE                       = 0x0030,
-      REG_HUMIDITY                          = 0x0031,
-
-      // This value is configured in the device itself.  By default,
-      // it represents the Dew Point Temperature.  Use the
-      // configuration utility from Comet to adjust the configuration.
-      REG_COMPUTED                          = 0x0032,
-
-      // available in devices with FW > 2.44
-      REG_DEW_POINT                         = 0x0034,
-      REG_ABS_HUMIDITY                      = 0x0035,
-      REG_SPECIFIC_HUMIDITY                 = 0x0036,
-      REG_MIXING_RATIO                      = 0x0037,
-      REG_SPECIFIC_ENTHALPY                 = 0x0038,
-
-      // 32 bit serial number.  These appear to be reversed when
-      // comparing against the TSensor config utility, so the
-      // datasheet is probably wrong.
-      REG_SERIAL_HI                         = 0x1034,
-      REG_SERIAL_LO                         = 0x1035,
-
-      // this is 'somewhat' documented (middle of page 15 in the
-      // Advantech-ADAM standard section) in the "Description of
-      // communications protocols of TXXXX series" document.  We use
-      // it to simply detect whether the device is configured for
-      // Celsius or Fahrenheit data and compensate internally.
-
-      REG_UNIT_SETTINGS                     = 0x203F,
-
-      // firmware revision, BCD byte encoded. We only care about the
-      // LO word - the HI word just contains the manufacturing date.
-      REG_FW_HI                             = 0x3000,
-      REG_FW_LO                             = 0x3001
-    } REGS_T;
-
-
-    /**
-     * T3311 constructor
-     *
-     * @param device Path to the serial device
-     * @param address The MODBUS slave address
-     * @param baud The baudrate of the device.  Default: 9600
-     * @param bits The number of bits per byte.  Default: 8
-     * @param parity The parity of the connection, 'N' for None, 'E'
-     * for Even, 'O' for Odd.  Default: 'N'
-     * @param stopBits The number of stop bits.  Default: 2
-     */
-    T3311(std::string device, int address, int baud=9600, int bits=8,
-          char parity='N', int stopBits=2);
-
-    /**
-     * T3311 Destructor
-     */
-    ~T3311();
-
-    /**
-     * Indicate whether the attached sensor supports extended Computed
-     * Data registers.  Firmware versions at, or higher than 2.44
-     * provide this data.
-     *
-     * @return true if Extended Data is available, false otherwise
-     */
-    bool extendedDataAvailable()
-    {
-      return m_isExtendedDataAvailable;
-    };
-
-    /**
-     * Read current values from the sensor and update internal stored
-     * values.  This method must be called prior to querying any
-     * values, such as temperature or humidity.
-     */
-    void update();
-
-    /**
-     * Get the current temperature.  update() must have been called
-     * prior to calling this method.
-     *
-     * @param fahrenheit true to return the temperature in degrees
-     * fahrenheit, false to return the temperature in degrees celsius.
-     * The default is false (degrees Celsius).
-     * @return The last temperature reading in Celsius or Fahrenheit
-     */
-    float getTemperature(bool fahrenheit=false);
-
-    /**
-     * Get the current relative humidity.  update() must have been called
-     * prior to calling this method.
-     *
-     * @return The last humidity reading
-     */
-    float getHumidity();
-
-    /**
-     * Get the current computed value.  update() must have been
-     * called prior to calling this method.  This value is configured
-     * via the configuration of the sensor using the sensors
-     * configuration utility, and can represent several different
-     * computed values.  The default value from the factory is the
-     * current Dew Point Temperature.
-     *
-     * Since the actual value configured is unknown (and unknowable)
-     * to this driver, the units represented depend on how you have
-     * configured the device. This function simply returns the value
-     * without any conversion or interpretation, other than the
-     * default scaling.
-     *
-     * @return The last Computed Value
-     */
-    float getComputedValue();
-
-    /**
-     * Get the current dew point temperature.  update() must have been
-     * called prior to calling this method.  This information is only
-     * available if the sensor supports Extended Data (ie:
-     * extendedDataAvailable() returns true).
-     *
-     * @param fahrenheit true to return the temperature in degrees
-     * fahrenheit, false to return the temperature in degrees celsius.
-     * The default is false (degrees Celsius).
-     * @return The last dew point temperature reading in Celsius or
-     * Fahrenheit
-     */
-    float getDewPointTemperature(bool fahrenheit=false);
-
-    /**
-     * Get the current absolute humidity.  update() must have been
-     * called prior to calling this method.  This information is only
-     * available if the sensor supports Extended Data (ie:
-     * extendedDataAvailable() returns true).
-     *
-     * @return The last absolute humidity reading in g/m3 (grams per
-     * cubic meter).
-     */
-    float getAbsoluteHumidity();
-
-    /**
-     * Get the current specific humidity.  update() must have been
-     * called prior to calling this method.  This information is only
-     * available if the sensor supports Extended Data (ie:
-     * extendedDataAvailable() returns true).
-     *
-     * @return The last specific humidity reading in g/kg (grams per
-     * kilogram).
-     */
-    float getSpecificHumidity();
-
-    /**
-     * Get the current mixing ratio.  update() must have been
-     * called prior to calling this method.  This information is only
-     * available if the sensor supports Extended Data (ie:
-     * extendedDataAvailable() returns true).
-     *
-     * @return The last mixing ratio reading in g/kg (grams per
-     * kilogram).
-     */
-    float getMixingRatio();
-
-    /**
-     * Get the current specific enthalopy, a measure of energy
-     * density.  update() must have been called prior to calling this
-     * method.  This information is only available if the sensor
-     * supports Extended Data (ie: extendedDataAvailable() returns
-     * true).
-     *
-     * @return The last specific enthalopy reading in kJ/kg
-     * (kilojoules per kilogram).
-     */
-    float getSpecificEnthalpy();
-
-    /**
-     * Get the serial number of the sensor.
-     *
-     * @return The serial number
-     */
-    std::string getSerialNumber()
-    {
-      return m_serialNumber;
-    };
-
-    /**
-     * Get the firmware revision major number.
-     *
-     * @return The firmware revsion major number.
-     */
-    int getFirmwareMajor()
-    {
-      return m_fwRevHi;
-    };
-
-    /**
-     * Get the firmware revision minor number.
-     *
-     * @return The firmware revsion minor number.
-     */
-    int getFirmwareMinor()
-    {
-      return m_fwRevLo;
-    };
-
-    /**
-     * Enable or disable debugging output.  This primarily enables and
-     * disables libmodbus debugging output.
-     *
-     * @param enable true to enable debugging, false otherwise
-     */
-    void setDebug(bool enable);
-
-  protected:
-    uint16_t readInputReg(int reg);
-    int readInputRegs(int reg, int len, uint16_t *buf);
-
-    // MODBUS context
-    modbus_t *m_mbContext;
-
-    // is the device reporting in C or F?
-    bool m_isCelsius;
-
-    // Is the device FW > than 2.44?
-    bool m_isExtendedDataAvailable;
-
-    int m_fwRevHi;
-    int m_fwRevLo;
-
-    std::string m_serialNumber;
-
-  private:
-    bool m_debugging;
-
-    // data
-    float m_temperature;
-    float m_humidity; // relative
-    float m_computedValue;
-
-    // with FW versions > 2.44, these other computed values are
-    // available.
-    float m_dewPointTemperature;
-    float m_absoluteHumidity;
-    float m_specificHumidity;
-    float m_mixingRatio;
-    float m_specificEnthalpy;
-  };
-}
diff --git a/src/t3311/t3311.i b/src/t3311/t3311.i
deleted file mode 100644
index 6b76f8d..0000000
--- a/src/t3311/t3311.i
+++ /dev/null
@@ -1,19 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "arrays_java.i";
-%include "../java_buffer.i"
-
-JAVA_JNI_LOADLIBRARY(javaupm_t3311)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%pointer_functions(float, floatp);
-
-%{
-#include "t3311.hpp"
-%}
-%include "t3311.hpp"
-/* END Common SWIG syntax */
diff --git a/src/t3311/t3311.json b/src/t3311/t3311.json
deleted file mode 100644
index 5435185..0000000
--- a/src/t3311/t3311.json
+++ /dev/null
@@ -1,60 +0,0 @@
-{
-    "Library": "t3311",
-    "Description": "T3311 Temperature and Humidity Sensor Library",
-    "Sensor Class": {
-        "T3311": {
-            "Name": "API for the T3311 MODBUS Temperature and Humidity Sensor",
-            "Description": "This is the UPM Module for the T3311 MODBUS Temperature and Humidity Sensor. This module implements support for the Comet System T3311 Temperature and Humidity transmitter.  It uses MODBUS over an RS232 serial port.  You must have libmodbus v3.1.2 (or greater) installed to compile and use this driver. This module was developed using libmodbus 3.1.2, and T3311 Firmware revison 2.66 connected via a Prolific RS232 Serial to USB adaptor. You cannot use the built in TTL UART pins for accessing this device -- you must use a full serial RS232 interface connected via USB.",
-            "Aliases": ["t3311", "T3311 Temperature and humidity probe with RS232 output, internal sensors"],
-            "Categories": ["humidity", "temperature"],
-            "Connections": ["uart"],
-            "Project Type": ["industrial"],
-            "Manufacturers": ["Comet"],
-            "Examples": {
-                "Python": ["t3311.py"],
-                "Node.js": ["t3311.js"],
-                "C++": ["t3311.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 9,
-                    "max": 30
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -30,
-                    "max": 85
-                },
-                "Temperature Sensor": {
-                    "Effective Range": {
-                        "unit": "°C",
-                        "min" : -30,
-                        "max" : 80
-                    },
-                    "Accuracy": {
-                        "unit": "°C",
-                        "min" : -0.4,
-                        "max" : 0.4
-                    }
-                },
-                "Humidity Sensor": {
-                    "Effective Range": {
-                        "unit": "RH",
-                        "min" : "0%",
-                        "max" : "100%"
-                    },
-                    "Accuracy": {
-                        "unit": "RH",
-                        "min" : "-2.5%",
-                        "max" : "2.5%"
-                    }
-                }
-            },
-            "Urls": {
-                "Product Pages": ["http://www.cometsystem.com/products/reg-T3311"],
-                "Datasheets": ["http://www.cometsystem.com/products/reg-T3311#technical_dataa"]
-            }
-        }
-    }
-}
diff --git a/src/t6713/CMakeLists.txt b/src/t6713/CMakeLists.txt
deleted file mode 100644
index 339ad91..0000000
--- a/src/t6713/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "t6713")
-set (libdescription "I2C/UART High Accuracy CO2 Sensor")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa interfaces)
diff --git a/src/t6713/t6713.cxx b/src/t6713/t6713.cxx
deleted file mode 100644
index eb23f5c..0000000
--- a/src/t6713/t6713.cxx
+++ /dev/null
@@ -1,244 +0,0 @@
-/*
- * Author: Henry Bruce <henry.bruce@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <errno.h>
-#include <iostream>
-#include <math.h>
-#include <stdlib.h>
-#include <syslog.h>
-#include <unistd.h>
-
-#include "t6713.hpp"
-
-#define T6713_ADDR                                0x15
-
-/* REGISTER ADDRESSES */
-#define T6713_REG_FIRMWARE_REVISION               0x1389
-
-#define T6713_REG_STATUS                          0x138A
-
-#define T6713_REG_GAS_PPM                         0x138B
-
-#define T6713_REG_RESET_DEVICE                    0x03E8
-
-#define T6713_REG_START_SINGLE_POINT_CAL          0x03EC
-
-#define T6713_REG_CHANGE_SLAVE_ADDRESS            0x0FA5
-
-#define T6713_REG_ABC_LOGIC_ENABLE_DISABLE        0x03EE
-
-using namespace upm;
-using namespace upm::t6713_co2;
-
-T6713::T6713 (int bus) : i2c(bus)
-{
-    status = i2c.address(T6713_ADDR);
-    uint16_t firmwareRevision = getFirmwareRevision();
-    if (firmwareRevision != mraa::SUCCESS)
-        UPM_THROW("config failure");
-}
-
-uint16_t T6713::getFirmwareRevision()
-{
-    return(getSensorData(T6713_COMMAND_GET_FIRMWARE_REVISION));
-}
-
-uint16_t T6713::getPpm ()
-{
-    return(getSensorData(T6713_COMMAND_GET_GAS_PPM));
-}
-
-uint16_t T6713::getSensorData (MODBUS_COMMANDS cmd)
-{
-    uint16_t data ,readBytes ;
-    STATUS currStatus ;
-    switch(currStatus = getStatus()) /* handle error conditions */
-    {
-        case ERROR_CONDITION:
-            UPM_THROW ("error condition");
-            break;
-        case FLASH_ERROR:
-            UPM_THROW ("flash error");
-            break;
-        case CALIBRATION_ERROR:
-            UPM_THROW ("calibration error");
-            break;
-        case WARMUP_MODE:
-            //UPM_THROW ("warmup mode");
-            break;
-        case RS232:
-            //printf("\nRS232 mode set\n ");
-            break;
-        case RS485:
-            //printf("\nRS485 mode set\n ");
-            break;
-        case I2C:
-            {
-                //printf("\nI2C mode set\n");
-                data = 0;
-                runCommand(cmd);
-                RESPONSE response;
-                if((readBytes = i2c.read((uint8_t*)(&response), sizeof(RESPONSE) ) != sizeof(RESPONSE)))
-                {
-                    UPM_THROW("I2C read failed");
-                    // TODO
-                }
-                if(response.function_code == READ_INPUT_REGISTERS)
-                {
-                    if(response.byte_count == 2)
-                    {
-                        data = (response.status_msb << 8 | response.status_lsb);
-                    }
-                }
-                return(data);
-                break;
-            }
-        default:
-            syslog(LOG_WARNING, "%s: switch case not defined",
-                    std::string(__FUNCTION__).c_str());
-    }
-    return 0;
-
-}
-
-
-mraa::Result T6713::runCommand(MODBUS_COMMANDS cmd)
-{
-    COMMAND cmdPacket;
-    mraa::Result ret = mraa::SUCCESS;
-
-    switch(cmd)
-    {
-        case T6713_COMMAND_RESET:
-            cmdPacket.function_code = WRITE_SINGLE_COIL;
-            cmdPacket.register_address_msb = (T6713_REG_RESET_DEVICE >> 8);
-            cmdPacket.register_address_lsb = (T6713_REG_RESET_DEVICE & 0xff);
-            cmdPacket.input_registers_to_read_msb = 0xff;
-            cmdPacket.input_registers_to_read_lsb = 0x00;
-            ret = i2c.write((const uint8_t*) (&cmdPacket), sizeof(COMMAND));
-            /*no response from the slave */
-            break;
-        case T6713_COMMAND_STATUS:
-            /*created the modbus status command packet*/
-            cmdPacket.function_code = READ_INPUT_REGISTERS;
-            cmdPacket.register_address_msb = (T6713_REG_STATUS >> 8);
-            cmdPacket.register_address_lsb = (T6713_REG_STATUS & 0xff);
-            cmdPacket.input_registers_to_read_msb = 0;
-            cmdPacket.input_registers_to_read_lsb = 1;
-
-            if((ret = i2c.write((const uint8_t*) (&cmdPacket), sizeof(COMMAND))) != mraa::SUCCESS)
-            {
-                UPM_THROW("I2C write failed");
-            }
-
-
-            break;
-        case T6713_COMMAND_GET_FIRMWARE_REVISION:
-            cmdPacket.function_code = READ_INPUT_REGISTERS;
-            cmdPacket.register_address_msb = (T6713_REG_FIRMWARE_REVISION >> 8);
-            cmdPacket.register_address_lsb = (T6713_REG_FIRMWARE_REVISION & 0xff);
-            cmdPacket.input_registers_to_read_msb = 0;
-            cmdPacket.input_registers_to_read_lsb = 1;
-            ret = i2c.write((const uint8_t*) (&cmdPacket), sizeof(COMMAND));
-            break;
-        case T6713_COMMAND_GET_GAS_PPM:
-            cmdPacket.function_code = READ_INPUT_REGISTERS;
-            cmdPacket.register_address_msb = (T6713_REG_GAS_PPM >> 8);
-            cmdPacket.register_address_lsb = (T6713_REG_GAS_PPM & 0xff);
-
-            cmdPacket.input_registers_to_read_msb = 0;
-            cmdPacket.input_registers_to_read_lsb = 1;
-
-            if((ret = i2c.write((const uint8_t*) (&cmdPacket), sizeof(COMMAND))) != mraa::SUCCESS)
-            {
-                UPM_THROW("I2C write failed");
-            }
-
-            break;
-    }
-
-    return ret;
-}
-
-
-STATUS T6713::getStatus()
-{
-    uint16_t responseStatus = 0, readBytes = 0;
-    RESPONSE response;
-    runCommand(T6713_COMMAND_STATUS);
-    if((readBytes = i2c.read((uint8_t*) (&response), sizeof(RESPONSE)) != sizeof(RESPONSE)))
-    {
-        UPM_THROW("I2C read failed");
-
-    }
-    if(response.function_code == READ_INPUT_REGISTERS)
-    {
-        if(response.byte_count == 2)
-        {
-            responseStatus = (response.status_msb << 8 | response.status_lsb);
-        }
-        else
-        {
-            UPM_THROW("I2C read failed");
-
-        }
-    }
-    else
-    {
-        UPM_THROW("MODBUS function code failed");
-    }
-
-    if(responseStatus & 0x0001)
-    {
-        return ERROR_CONDITION;
-    }
-    if(responseStatus & 0x0002)
-    {
-        return FLASH_ERROR;
-    }
-    if(responseStatus & 0x0004)
-    {
-        return CALIBRATION_ERROR;
-    }
-    if(responseStatus & 0x0800)
-    {
-        return WARMUP_MODE;
-    }
-    if(responseStatus & 0x8000)
-    {
-        return SINGLE_POINT_CALIBRATION;
-    }
-    if(responseStatus & 0x0100)
-    {
-        return RS232;
-    }
-    if(responseStatus & 0x0400)
-    {
-        return RS485;
-    }
-    else
-    {
-        return I2C;
-    }
-}
diff --git a/src/t6713/t6713.hpp b/src/t6713/t6713.hpp
deleted file mode 100644
index 9f4533d..0000000
--- a/src/t6713/t6713.hpp
+++ /dev/null
@@ -1,145 +0,0 @@
-/*
- * Author: Henry Bruce <henry.bruce@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-
-#include "mraa/i2c.hpp"
-#include "interfaces/iCO2Sensor.hpp"
-
-namespace upm {
-/**
- * @brief Amphenol Telaire 6713 Series CO2 Module
- * @defgroup t6713 libupm-t6713
- * @ingroup i2c amphenol gaseous ico2sensor
- */
-
-/**
- * @library t6713
- * @sensor t6713
- * @comname I2C/UART High Accuracy CO2 Sensor
- * @altname T6713
- * @type gaseous
- * @man amphenol
- * @web http://amphenol-sensors.com/en/products/co2/co2-modules/3215-t6700
- * @con i2c
- * @if ico2sensor
- *
- * @brief C++ API for Amphenol Telaire 6713 Series CO2 Module
- *
- * The Telaire 6713 Series CO2 Module
- * [6713](http://amphenol-sensors.com/en/products/co2/co2-modules/3215-t6700#specifications-t6713)
- * is a CO2 Module sensor.
- *
- * @snippet t6713.cxx Interesting
- * @snippet t6713-co2-sensor.cxx Interesting
- */
-
-namespace t6713_co2
-{
-    /* COMMAND VALUES */
-    typedef enum
-    {
-        T6713_COMMAND_RESET,
-        T6713_COMMAND_STATUS,
-        T6713_COMMAND_GET_FIRMWARE_REVISION,
-        T6713_COMMAND_GET_GAS_PPM
-    }MODBUS_COMMANDS;
-
-    typedef enum
-    {
-        ERROR_CONDITION,
-        FLASH_ERROR,
-        CALIBRATION_ERROR,
-        WARMUP_MODE,
-        SINGLE_POINT_CALIBRATION,
-        RS232,
-        I2C,
-        RS485
-    }STATUS;
-
-    typedef struct
-    {
-        uint8_t function_code;
-        uint8_t register_address_msb;
-        uint8_t register_address_lsb;
-        uint8_t input_registers_to_read_msb;
-        uint8_t input_registers_to_read_lsb;
-
-    }COMMAND;
-
-    typedef struct
-    {
-        uint8_t function_code;
-        uint8_t byte_count;
-        uint8_t status_msb;
-        uint8_t status_lsb;
-
-    }RESPONSE;
-
-    typedef enum
-    {
-        READ_INPUT_REGISTERS = 4,
-        WRITE_SINGLE_COIL,
-        WRITE_SINGLE_HOLDING_REGISTER
-    }FUNCTION_CODES;
-}//namespace t6713_co2
-
-class T6713 : public ICO2Sensor {
-    public:
-        /**
-        * Instantiates a T6713 object
-        *
-        * @param bus number of used bus
-        */
-        T6713 (int bus);
-
-        /**
-        * T6713 object destructor.
-        */
-        virtual ~T6713 () {};
-
-        /**
-        * Returns sensor module name
-        */
-        virtual const char* getModuleName() { return "t6713"; }
-
-        /**
-        * Get relative humidity measurement.
-        */
-        uint16_t getPpm ();
-        /**
-        * Get the firmware version
-        */
-        uint16_t getFirmwareRevision();
-
-
-    private:
-        mraa::Result runCommand(t6713_co2::MODBUS_COMMANDS command);
-        uint16_t getSensorData(t6713_co2::MODBUS_COMMANDS cmd);
-        t6713_co2::STATUS getStatus();
-
-        mraa::I2c i2c;
-        mraa::Result status;
-};
-
-}//namespace upm
diff --git a/src/t6713/t6713.i b/src/t6713/t6713.i
deleted file mode 100644
index 56db974..0000000
--- a/src/t6713/t6713.i
+++ /dev/null
@@ -1,25 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "arrays_java.i";
-%include "../java_buffer.i"
-%typemap(javaimports) SWIGTYPE %{import upm_interfaces.*;%}
-%import "../interfaces/javaupm_iCO2Sensor.i"
-
-JAVA_JNI_LOADLIBRARY(javaupm_t6713)
-#endif
-/* END Java syntax */
-
-/* BEGIN Javascript syntax  ------------------------------------------------- */
-#ifdef SWIGJAVASCRIPT
-%include "../carrays_uint16_t.i"
-#endif
-/* END Javascript syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "t6713.hpp"
-%}
-%include "t6713.hpp"
-/* END Common SWIG syntax */
diff --git a/src/t6713/t6713.json b/src/t6713/t6713.json
deleted file mode 100644
index 4ee3f3c..0000000
--- a/src/t6713/t6713.json
+++ /dev/null
@@ -1,60 +0,0 @@
-{
-    "Library": "t6713",
-    "Description": "Amphenol Telaire 6713 Series CO2 Module Sensor Library",
-    "Sensor Class": {
-        "T6713": {
-            "Name": "API for the Amphenol Telaire 6713 Series CO2 Module",
-            "Description": "This is the UPM Module for the Amphenol Telaire 6713 Series CO2 Module. The new T6700 series is a miniature NDIR CO2 sensor that has accuracy and reliability of many larger sensors. The new small size allows OEM’s to integrate in to smaller enclosures and equipment and uses significantly less power than many other devices on the market.",
-            "Aliases": ["t6713", "Miniature CO2 Module Series T6700"],
-            "Categories": ["gaseous"],
-            "Connections": ["i2c"],
-            "Project Type": ["industrial", "commercial"],
-            "Manufacturers": ["Amphenol"],
-            "Examples": {
-                "C++": ["t6713-co2-sensor.cxx", "t6713.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 4.4,
-                    "max": 5.5
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "min" : 25,
-                    "max" : 200
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -10,
-                    "max": 60
-                },
-                "Detection Range": {
-                    "unit": "ppm",
-                    "min" : 400,
-                    "max" : 5000
-                },
-                "Accuracy": {
-                    "unit": "ppm",
-                    "min" : -75,
-                    "max" : 75
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need pull up resistors"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["http://amphenol-sensors.com/en/products/co2/co2-modules/3215-t6700"],
-                "Datasheets": ["http://amphenol-sensors.com/en/products/co2/co2-modules/3215-t6700#specifications-t6703"]
-            }
-        }
-    }
-}
diff --git a/src/t8100/CMakeLists.txt b/src/t8100/CMakeLists.txt
deleted file mode 100644
index 97d9b31..0000000
--- a/src/t8100/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-if (BACNET_FOUND)
-    set (libname "t8100")
-    set (libdescription "Wall Mount CO2, Humidity and Temperature Transmitter")
-    set (module_src ${libname}.cxx)
-    set (module_hpp ${libname}.hpp)
-
-    upm_module_init(bacnetmstp)
-endif ()
diff --git a/src/t8100/t8100.cxx b/src/t8100/t8100.cxx
deleted file mode 100644
index 78e5c83..0000000
--- a/src/t8100/t8100.cxx
+++ /dev/null
@@ -1,254 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <assert.h>
-#include <errno.h>
-#include <iostream>
-#include <stdexcept>
-#include <string>
-
-#include "t8100.hpp"
-
-using namespace upm;
-using namespace std;
-
-// conversion from fahrenheit to celsius and back
-
-static float f2c(float f)
-{
-  return ((f - 32.0) / (9.0 / 5.0));
-}
-
-static float c2f(float c)
-{
-  return (c * (9.0 / 5.0) + 32.0);
-}
-
-
-T8100::T8100(uint32_t targetDeviceObjectID) :
-  BACNETUTIL(targetDeviceObjectID)
-{
-  setDebug(false);
-
-  // we disable this by default for performance reasons
-  checkReliability(false);
-
-  m_isTempInitialized = false;
-  m_isCelsius = false;
-
-  m_humidity = 0.0;
-  m_temperature = 0.0;
-  m_co2 = 0.0;
-  m_relayState = false;
-}
-
-T8100::~T8100()
-{
-}
-
-void T8100::update()
-{
-  if (!m_isTempInitialized)
-    {
-      // this will update internals so conversions work properly
-      getTemperatureScale();
-    }
-
-  float tmpF = getAnalogInput(AI_Temperature_Thermistor);
-
-  if (m_isCelsius)
-    m_temperature = tmpF;
-  else
-    m_temperature = f2c(tmpF);
-
-  m_humidity = getAnalogInput(AI_Relative_Humidity);
-  m_co2 = getAnalogInput(AI_CO2);
-  m_relayState = getBinaryInput(BI_Relay_State);
-}
-
-float T8100::getTemperature(bool fahrenheit)
-{
-  if (fahrenheit)
-    return c2f(m_temperature);
-  else
-    return m_temperature;
-}
-
-void T8100::setTemperatureScale(bool fahrenheit)
-{
-  setBinaryValue(BV_Temperature_Units, fahrenheit);
-
-  m_isTempInitialized = true;
-  m_isCelsius = (fahrenheit) ? false : true;
-}
-
-bool T8100::getTemperatureScale()
-{
-  bool scale = getBinaryValue(BV_Temperature_Units);
-
-  m_isTempInitialized = true;
-  m_isCelsius = !scale;
-
-  return scale;
-}
-
-float T8100::getTemperatureOffset()
-{
-  return getAnalogValue(AV_Temperature_Offset);
-}
-
-void T8100::setTemperatureOffset(float value)
-{
-  // Always in C...
-  if (value < -50.0 || value > 50.0)
-    {
-      throw std::out_of_range(std::string(__FUNCTION__)
-                              + ": value must be between -50 and 50,"
-                              + " in degrees Celsius");
-
-    }
-
-  setAnalogValue(AV_Temperature_Offset, value);
-}
-
-float T8100::getHumidityOffset()
-{
-  return getAnalogValue(AV_RH_Offset);
-}
-
-void T8100::setHumidityOffset(float value)
-{
-  if (value < -100.0 || value > 100.0)
-    {
-      throw std::out_of_range(std::string(__FUNCTION__)
-                              + ": value must be between -100 and 100");
-    }
-
-  setAnalogValue(AV_RH_Offset, value);
-}
-
-float T8100::getRelaySetPoint()
-{
-  return getAnalogValue(AV_Relay_Set_Point);
-}
-
-void T8100::setRelaySetPoint(float value)
-{
-  if (value < 0.00 || value > 65535.0)
-    {
-      throw std::out_of_range(std::string(__FUNCTION__)
-                              + ": value must be between 0 and 65535");
-    }
-
-  setAnalogValue(AV_Relay_Set_Point, value);
-}
-
-float T8100::getRelayHysteresis()
-{
-  return getAnalogValue(AV_Relay_Hysteresis);
-}
-
-void T8100::setRelayHysteresis(float value)
-{
-  if (value < 0.00 || value > 65535.0)
-    {
-      throw std::out_of_range(std::string(__FUNCTION__)
-                              + ": value must be between 0 and 65535");
-    }
-
-  setAnalogValue(AV_Relay_Hysteresis, value);
-}
-
-float T8100::getElevation()
-{
-  return getAnalogValue(AV_Elevation);
-}
-
-void T8100::setElevation(float value)
-{
-  if (value < 0.00 || value > 65535.0)
-    {
-      throw std::out_of_range(std::string(__FUNCTION__)
-                              + ": value must be between 0 and 65535");
-    }
-
-  setAnalogValue(AV_Elevation, value);
-}
-
-float T8100::getCalibrationSinglePoint()
-{
-  return getAnalogValue(AV_Calibration_Single_Point);
-}
-
-void T8100::setCalibrationSinglePoint(float value)
-{
-  if (value < 0.00 || value > 65535.0)
-    {
-      throw std::out_of_range(std::string(__FUNCTION__)
-                              + ": value must be between 0 and 65535");
-    }
-
-  setAnalogValue(AV_Calibration_Single_Point, value);
-}
-
-float T8100::getBaudRate()
-{
-  return getAnalogValue(AV_Baud_Rate);
-}
-
-float T8100::getMACAddress()
-{
-  return getAnalogValue(AV_MAC_Address);
-}
-
-bool T8100::getABCLogicState()
-{
-  return getBinaryValue(BV_ABC_Logic_State);
-}
-
-void T8100::setABCLogicState(bool value)
-{
-  setBinaryValue(BV_ABC_Logic_State, value);
-}
-
-bool T8100::getABCLogicReset()
-{
-  return getBinaryValue(BV_ABC_Logic_Reset);
-}
-
-void T8100::setABCLogicReset(bool value)
-{
-  setBinaryValue(BV_ABC_Logic_Reset, value);
-}
-
-bool T8100::getCO2Calibration()
-{
-  return getBinaryValue(BV_CO2_Calibration);
-}
-
-void T8100::setCO2Calibration(bool value)
-{
-  setBinaryValue(BV_CO2_Calibration, value);
-}
diff --git a/src/t8100/t8100.hpp b/src/t8100/t8100.hpp
deleted file mode 100644
index 9725636..0000000
--- a/src/t8100/t8100.hpp
+++ /dev/null
@@ -1,379 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <map>
-
-#include "bacnetmstp.hpp"
-#include "bacnetutil.hpp"
-
-namespace upm {
-
-  /**
-   * @brief Amphenol Telaire Ventostat 8100 Ventilation Controller
-   * @defgroup t8100 libupm-t8100
-   * @ingroup uart temp gaseous
-   */
-
-  /**
-   * @library t8100
-   * @sensor t8100
-   * @comname Wall Mount CO2, Humidity and Temperature Transmitter
-   * Ventilation Controller
-   * @type gaseous temp
-   * @man amphenol
-   * @con uart
-   * @web https://www.instrumart.com/products/configure/18180?quantity=1
-   *
-   * @brief UPM API for the Amphenol Telaire Ventostat T8100
-   * Ventilation Controller
-   *
-   * This module implements support for the Amphenol Telaire Ventostat
-   * T8100 Ventilation Controller with BACnet interface.  It may also
-   * support the T8200 and T8300 models, but they have not been
-   * tested.
-   *
-   * The Telaire Ventostat T8100 reports Temperature, Humidity and CO2
-   * concentrations.  It supports an optional relay with a settable
-   * trigger point.  The unit this driver was tested under did not
-   * support the optional relay.  The temperature range supported is
-   * 0-50C, humidity is 0-100% non-condensing, and CO2 range is
-   * appoximately 0-2000 PPM for the T8100.  Other sensors in this
-   * family support wider ranges.
-   *
-   * This module was developed using the upm::BACNETMSTP library,
-   * based on libbacnet-stack 0.8.3.  Both libbacnet 0.8.3 and the
-   * upm::BACNETMSTP libraries must be present in order to build this
-   * module.
-   *
-   * It was connected using an RS232->RS485 interface.  You cannot use
-   * the built in MCU TTL UART pins for accessing this device -- you
-   * must use a full Serial RS232->RS485 or USB-RS485 interface
-   * connected via USB.
-   *
-   * @snippet t8100.cxx Interesting
-   */
-
-  class T8100 : public BACNETUTIL {
-  public:
-
-    // Supported Analog Value Objects.  These are readable and writable.
-    typedef enum : uint32_t {
-      AV_Temperature_Offset                   = 1,
-      AV_RH_Offset                            = 2,
-      AV_Relay_Set_Point                      = 3,
-      AV_Relay_Hysteresis                     = 4,
-      AV_Elevation                            = 5,
-      AV_Calibration_Single_Point             = 6,
-      AV_Baud_Rate                            = 7,
-      AV_MAC_Address                          = 8
-    } ANALOG_VALUES_T;
-
-    // Supported Analog Input Objects.  These are read only.
-    typedef enum : uint32_t {
-      AI_CO2                                  = 1,
-      AI_Relative_Humidity                    = 2,
-      AI_Temperature_ChipCap                  = 3,
-      AI_Temperature_Thermistor               = 4
-    } ANALOG_INPUTS_T;
-
-    // Supported Binary Value Objects.  These are readable and writable.
-    typedef enum : uint32_t {
-      BV_Temperature_Units                    = 1,
-      BV_ABC_Logic_State                      = 2,
-      BV_ABC_Logic_Reset                      = 3,
-      BV_CO2_Calibration                      = 4
-    } BINARY_VALUES_T;
-
-    // Supported Binary Input Objects.  These are read only.
-    typedef enum : uint32_t {
-      BI_Relay_State                          = 1
-    } BINARY_INPUTS_T;
-
-
-    /**
-     * T8100 constructor
-     *
-     * @param targetDeviceObjectID the unique Instance ID of the
-     * Device Object.  This number is used to uniquely identify
-     * devices on the BACnet network, and ranges from 1 to 4194302.
-     * This is not the device's MAC address, though on some devices,
-     * the MAC address may be used as part of this number.  On the
-     * T8100, this number is 568XXX, where XXX are the 3 digits of the
-     * set MAC address.  The MAC address is configured via DIP switches
-     * within the device.
-     */
-    T8100(uint32_t targetDeviceObjectID);
-
-    /**
-     * T8100 Destructor
-     */
-    ~T8100();
-
-    /**
-     * Read current values from the sensor and update internal stored
-     * values for temperature, humidity, CO2 concentration and relay
-     * state.  This method must be called prior to querying any
-     * of the aforementioned values.
-     */
-    void update();
-
-    /**
-     * Get the current relative humidity.  update() must have been
-     * called prior to calling this method.
-     *
-     * @return The last humidity reading
-     */
-    float getHumidity()
-    {
-      return m_humidity;
-    }
-
-    /**
-     * Get the current CO2 concentration in Parts per Million (PPM).
-     * update() must have been called prior to calling this method.
-     *
-     * @return The last CO2 reading
-     */
-    float getCO2()
-    {
-      return m_co2;
-    }
-
-    /**
-     * Get the current temperature.  update() must have been called
-     * prior to calling this method.
-     *
-     * @param fahrenheit true to return the temperature in degrees
-     * fahrenheit, false to return the temperature in degrees celsius.
-     * The default is false (degrees Celsius).
-     * @return The last temperature reading in Celsius or Fahrenheit.
-     */
-    float getTemperature(bool fahrenheit=false);
-
-    /**
-     * Return the current state of the relay.  This function will
-     * always return false if the relay option is not installed.
-     * update() must have been called prior to calling this method.
-     *
-     * @return true if the relay is active, false if inactive.
-     */
-    bool getRelayState()
-    {
-      return m_relayState;
-    }
-
-    /**
-     * Set the device temperature scale to Celsius of Fahrenheit.  For
-     * devices with an LCD display, this will affect which scale is
-     * displayed.  When changing the scale, it may take several
-     * seconds for the setting to take effect.
-     *
-     * @param fahrenheit true to set the scale to fahrenheit, false
-     * for celsius.
-     */
-    void setTemperatureScale(bool fahrenheit);
-
-    /**
-     * Get the device temperature scale.
-     *
-     * @return true if scale is fahrenheit, false for celsius.
-     */
-    bool getTemperatureScale();
-
-    /**
-     * Get the current temperature offset.
-     *
-     * @return The configured temperature offset.
-     */
-    float getTemperatureOffset();
-
-    /**
-     * Set the device temperature offset.  The offset is applied by
-     * the device internally to the temperature reading.  The offset
-     * must always be specified in degrees Celsius.  Valid values must
-     * be between -50 and 50.
-     *
-     * @param value The temperature offset to configure.
-     */
-    void setTemperatureOffset(float value);
-
-    /**
-     * Get the current humidity offset.
-     *
-     * @return The configured humidity offset.
-     */
-    float getHumidityOffset();
-
-    /**
-     * Set the device humidity offset.  The offset is applied by the
-     * device internally to the humidity reading.  Valid values must
-     * be between -100 and 100.
-     *
-     * @param value The humidity offset to configure.
-     */
-    void setHumidityOffset(float value);
-
-    /**
-     * Return the current relay set point (in PPM).  This set point is
-     * the CO2 concentration point in PPM that causes the relay to
-     * trigger.
-     *
-     * @return The relay set point value.
-     */
-    float getRelaySetPoint();
-
-    /**
-     * Set the relay set point in PPM.  This set point is the CO2
-     * concentration point in PPM that causes the relay to trigger.
-     * Valid values are between 0-65535.
-     *
-     * @param value The desired relay set point value.
-     */
-    void setRelaySetPoint(float value);
-
-    /**
-     * Return the current relay hysteresis.
-     *
-     * @return The relay hysteresis value.
-     */
-    float getRelayHysteresis();
-
-    /**
-     * Set the relay hysteresis.  Valid values are between 0-65535.
-     *
-     * @param value The desired relay set point value.
-     */
-    void setRelayHysteresis(float value);
-
-    /**
-     * Return the current elevation setting (in meters).
-     *
-     * @return The current elevation setting.
-     */
-    float getElevation();
-
-    /**
-     * Set the elevation setting in meters.  Valid values are between
-     * 0-65535.
-     *
-     * @param value The desired elevation setting in meters.
-     */
-    void setElevation(float value);
-
-    /**
-     * Return the current calibration single point value (in PPM).
-     *
-     * @return The current calibration single point value.
-     */
-    float getCalibrationSinglePoint();
-
-    /**
-     * Set the calibration single point value in PPM.  Valid values
-     * are between 0-65535.
-     *
-     * @param value The desired calibration single point value in PPM.
-     */
-    void setCalibrationSinglePoint(float value);
-
-    /**
-     * Return the current baud rate.
-     *
-     * @return The current baud rate.
-     */
-    float getBaudRate();
-
-    /**
-     * Return the current MAC address.  The MAC address is configured
-     * via DIP switches within the device.
-     *
-     * @return The current MAC address.
-     */
-    float getMACAddress();
-
-    /**
-     * Return the current ABC (Automatic Background Calibration)
-     * logic state.  See the datasheet for details.
-     *
-     * @return The current ABC logic state.
-     */
-    bool getABCLogicState();
-
-    /**
-     * Set the ABC (Automatic Background Calibration) logic state.
-     * Valid values are true for ON, false for OFF.
-     *
-     * @param value The desired ABC logic state.
-     */
-    void setABCLogicState(bool value);
-
-    /**
-     * Return the current ABC (Automatic Background Calibration)
-     * reset state.  See the datasheet for details.
-     *
-     * @return The current ABC reset state.
-     */
-    bool getABCLogicReset();
-
-    /**
-     * Set the ABC (Automatic Background Calibration) reset state.
-     * Valid values are true for Reset, false for Normal.
-     *
-     * @param value The desired ABC reset state.
-     */
-    void setABCLogicReset(bool value);
-
-    /**
-     * Return the current CO2 calibration state.  See the datasheet
-     * for details.
-     *
-     * @return The current CO2 calibration state.
-     */
-    bool getCO2Calibration();
-
-    /**
-     * Set the CO2 calibration state.
-     * Valid values are true for Calibrate, false for Normal.
-     *
-     * @param value The desired ABC reset state.
-     */
-    void setCO2Calibration(bool value);
-
-
-  protected:
-    float m_humidity;
-    // always stored in C
-    float m_temperature;
-    float m_co2;
-    bool m_relayState;
-
-  private:
-    // Have we checked the device's temperature unit setting yet
-    bool m_isTempInitialized;
-
-    // Is the device configured for Celsius?
-    bool m_isCelsius;
-  };
-}
diff --git a/src/t8100/t8100.i b/src/t8100/t8100.i
deleted file mode 100644
index da75752..0000000
--- a/src/t8100/t8100.i
+++ /dev/null
@@ -1,18 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_t8100)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "bacnetmstp.hpp"
-#include "bacnetutil.hpp"
-#include "t8100.hpp"
-%}
-%include "bacnetmstp.hpp"
-%include "bacnetutil.hpp"
-%include "t8100.hpp"
-/* END Common SWIG syntax */
diff --git a/src/t8100/t8100.json b/src/t8100/t8100.json
deleted file mode 100644
index 723d8fd..0000000
--- a/src/t8100/t8100.json
+++ /dev/null
@@ -1,83 +0,0 @@
-{
-    "Library": "t8100",
-    "Description": "Amphenol Telaire Ventostat T8100 Ventilation Controller Library",
-    "Sensor Class": {
-        "T8100": {
-            "Name": "API for the Amphenol Telaire Ventostat T8100 Ventilation Controller",
-            "Description": "This is the UPM Module for the Amphenol Telaire Ventostat T8100 Ventilation Controller. This module implements support for the Amphenol Telaire Ventostat T8100 Ventilation Controller with BACnet interface.  It may also support the T8200 and T8300 models, but they have not been tested. The Telaire Ventostat T8100 reports Temperature, Humidity and CO2 concentrations.  It supports an optional relay with a settable trigger point.  The unit this driver was tested under did not support the optional relay.",
-            "Aliases": ["t8100", "Telaire Ventostat Series CO2 Monitor"],
-            "Categories": ["gaseous", "temperature", "humidity"],
-            "Connections": ["uart"],
-            "Project Type": ["industrial", "commercial"],
-            "Manufacturers": ["Amphenol"],
-            "Examples": {
-                "Java": ["T8100_Example.java"],
-                "Python": ["t8100.py"],
-                "Node.js": ["t8100.js"],
-                "C++": ["t8100.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 0,
-                    "max": 10
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "min" : 4,
-                    "max" : 20
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": 0,
-                    "max": 50
-                },
-                "Temperature Sensor": {
-                    "Effective Range": {
-                        "unit": "°C",
-                        "min" : 0,
-                        "max" : 50
-                    },
-                    "Accuracy": {
-                        "unit": "°C",
-                        "min" : -0.8,
-                        "max" : 0.8
-                    }
-                },
-                "Humidity Sensor": {
-                    "Effective Range": {
-                        "unit": "RH",
-                        "min" : "0%",
-                        "max" : "99%"
-                    },
-                    "Accuracy": {
-                        "unit": "RH",
-                        "min" : "-3.5%",
-                        "max" : "3.5%"
-                    }
-                },
-                "CO2 Sensor": {
-                    "Effective Range": {
-                        "unit": "ppm",
-                        "min" : 0,
-                        "max" : 5000
-                    },
-                    "Accuracy": {
-                        "unit": "ppm",
-                        "min" : -30,
-                        "max" : 30
-                    },
-                    "Warm-up Time": {
-                        "unit": "minutes",
-                        "min" : 2,
-                        "max" : 10
-                    }
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.instrumart.com/products/18180/telaire-ventostat-series-co2-monitor"],
-                "Datasheets": ["https://www.instrumart.com/assets/Telaire_Ventostat_Wall_Mount-datasheet.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/ta12200/CMakeLists.txt b/src/ta12200/CMakeLists.txt
deleted file mode 100644
index 1ef987e..0000000
--- a/src/ta12200/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "ta12200")
-set (libdescription "AC Current Sensor")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/ta12200/ta12200.cxx b/src/ta12200/ta12200.cxx
deleted file mode 100644
index bc29c90..0000000
--- a/src/ta12200/ta12200.cxx
+++ /dev/null
@@ -1,119 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "ta12200.hpp"
-
-using namespace upm;
-using namespace std;
-
-TA12200::TA12200(int pin)
-{
-  initClock();
-
-  if ( !(m_aio = mraa_aio_init(pin)) )
-    {
-      throw std::invalid_argument(std::string(__FUNCTION__) +
-                                  ": mraa_aio_init() failed, invalid pin?");
-      return;
-    }
-}
-
-TA12200::~TA12200()
-{
-  mraa_aio_close(m_aio);
-}
-
-void TA12200::initClock()
-{
-  gettimeofday(&m_startTime, NULL);
-}
-
-uint32_t TA12200::getMillis()
-{
-  struct timeval elapsed, now;
-  uint32_t elapse;
-
-  // get current time
-  gettimeofday(&now, NULL);
-
-  // compute the delta since m_startTime
-  if( (elapsed.tv_usec = now.tv_usec - m_startTime.tv_usec) < 0 ) 
-    {
-      elapsed.tv_usec += 1000000;
-      elapsed.tv_sec = now.tv_sec - m_startTime.tv_sec - 1;
-    } 
-  else 
-    {
-      elapsed.tv_sec = now.tv_sec - m_startTime.tv_sec;
-    }
-
-  elapse = (uint32_t)((elapsed.tv_sec * 1000) + (elapsed.tv_usec / 1000));
-
-  // never return 0
-  if (elapse == 0)
-    elapse = 1;
-
-  return elapse;
-}
-
-
-int TA12200::highestValue()
-{
-  int hiVal = 0;
-  int val;
-  uint32_t start = getMillis();
-
-  // 1 second
-  while (getMillis() < (start + 1000))
-    {
-      val = mraa_aio_read(m_aio);
-      if (val == -1) {
-        return -1;
-      }
-      if (val > hiVal) {
-        hiVal = val;
-      }
-    }
-        
-  return hiVal;
-}
-
-float TA12200::milliAmps(unsigned int val, int res)
-{
-  float ampCurrent;
-  float effectiveVal;
-
-  // From grove wiki page:
-  // minimum_current=1/1024*5/800*2000000/1.414=8.6(mA) 
-  // Only for sinusoidal alternating current
-  //ampCurrent = float(val) / float(res) * 5.0 / 800.0 * 2000000.0;
-  ampCurrent = float(val) / float(res) * 12500.0;
-  effectiveVal = ampCurrent/1.414;
-  return (effectiveVal);
-}
-
diff --git a/src/ta12200/ta12200.hpp b/src/ta12200/ta12200.hpp
deleted file mode 100644
index 5e3f014..0000000
--- a/src/ta12200/ta12200.hpp
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <iostream>
-#include <stdint.h>
-#include <sys/time.h>
-#include <mraa/aio.h>
-
-// default ADC resolution. 
-#define TA12200_ADC_RES 1024
-
-namespace upm {
-/**
- * @brief TA12-200 Current Transformer
- * @defgroup ta12200 libupm-ta12200
- * @ingroup seeed analog electric
- */
-/**
- * @library ta12200
- * @sensor ta12200
- * @comname AC Current Sensor
- * @altname Grove Electricity Sensor
- * @type electric
- * @man seeed
- * @web http://www.seeedstudio.com/wiki/Grove_-_Electricity_Sensor
- * @con analog
- *
- * @brief API for the TA12-200 Current Transformer
- * 
- *   UPM module for the TA12-200 current transformer found,
- *   for instance, in the Grove Electricity Sensor. 
- *   This module can measure AC moving through a wire at up 
- *   to 5 A.
- *
- * @image html ta12200.jpg
- * @snippet ta12200.cxx Interesting
- */
-  class TA12200 {
-  public:
-    /**
-     * TA12200 constructor
-     *
-     * @param pin Analog pin to use
-     */
-    TA12200(int pin);
-
-    /**
-     * TA12200 destructor
-     */
-    ~TA12200();
-
-    /**
-     * Returns the number of milliseconds elapsed since initClock()
-     * was last called.
-     *
-     * @return Elapsed milliseconds
-     */
-    uint32_t getMillis();
-
-    /**
-     * Resets the clock
-     *
-     */
-    void initClock();
-
-    /**
-     * Gets the conversion value from the sensor
-     *
-     * @return Highest value obtained over 1 second of measuring or -1 if error
-     */
-    int highestValue();
-
-    /**
-     * Computes the measured voltage
-     *
-     * @param val Value measured by highestValue()
-     * @param res ADC resolution
-     *
-     * @return Measured current in mA
-     */
-    float milliAmps(unsigned int val, int res=TA12200_ADC_RES);
-
-  private:
-    struct timeval m_startTime;
-    mraa_aio_context m_aio;
-  };
-}
-
-
diff --git a/src/ta12200/ta12200.json b/src/ta12200/ta12200.json
deleted file mode 100644
index 300a8f0..0000000
--- a/src/ta12200/ta12200.json
+++ /dev/null
@@ -1,59 +0,0 @@
-{
-    "Library": "ta12200",
-    "Description": "Seeed TA12-200 Current Transformer library",
-    "Sensor Class": {
-        "TA12200": {
-            "Name": "API for the Seeed TA12-200 Current Transformer",
-            "Description": "This is the UPM Module for the Seeed TA12-200 Current Transformer. The Electricity sensor module is based on the TA12-200 current transformer which can change large alternating current into a small amplitude. You can use it to test large alternating current upto 5A.",
-            "Aliases": ["ta12200", "Grove - Electricity Sensor"],
-            "Categories": ["electric"],
-            "Connections": ["analog"],
-            "Project Type": ["prototyping"],
-            "Manufacturers": ["Seeed"],
-            "Image": "ta12200.jpg",
-            "Examples": {
-                "Python": ["ta12200.py"],
-                "Node.js": ["ta12200.js"],
-                "C++": ["ta12200.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min" : 3.3,
-                    "max" : 5.0
-                },
-                "Sampling Voltage": {
-                    "unit": "V",
-                    "min": 0,
-                    "max": 2
-                },
-                "Supply Current": {
-                    "unit": "A",
-                    "min" : 0,
-                    "max" : 5
-                },
-                "Output Current": {
-                    "unit": "mA",
-                    "min" : 0,
-                    "max" : 2.5
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -55,
-                    "max": 85
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-Electricity-Sensor-p-777.html", "http://wiki.seeed.cc/Grove-Electricity_Sensor/"]
-            }
-        }
-    }
-}
diff --git a/src/tb7300/CMakeLists.txt b/src/tb7300/CMakeLists.txt
deleted file mode 100644
index 2f37d68..0000000
--- a/src/tb7300/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-if (BACNET_FOUND)
-  set (libname "tb7300")
-  set (libdescription "Communicating Fan Coil Thermostat")
-  set (module_src ${libname}.cxx)
-  set (module_hpp ${libname}.hpp)
-
-  upm_module_init(bacnetmstp)
-endif ()
diff --git a/src/tb7300/tb7300.cxx b/src/tb7300/tb7300.cxx
deleted file mode 100644
index 7d11488..0000000
--- a/src/tb7300/tb7300.cxx
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <unistd.h>
-#include <errno.h>
-#include <iostream>
-#include <stdexcept>
-#include <string>
-
-#include "tb7300.hpp"
-
-using namespace upm;
-using namespace std;
-
-// conversion from fahrenheit to celsius and back
-
-static float f2c(float f)
-{
-  return ((f - 32.0) / (9.0 / 5.0));
-}
-
-static float c2f(float c)
-{
-  return (c * (9.0 / 5.0) + 32.0);
-}
-
-
-TB7300::TB7300(uint32_t targetDeviceObjectID) :
-  BACNETUTIL(targetDeviceObjectID)
-{
-  setDebug(false);
-
-  // we disable this by default for performance reasons
-  checkReliability(false);
-
-  m_isTempInitialized = false;
-  m_isCelsius = false;
-
-  // room temperature only
-  m_temperature = 0.0;
-}
-
-TB7300::~TB7300()
-{
-}
-
-void TB7300::update()
-{
-  if (!m_isTempInitialized)
-    {
-      // this will update internals so conversions work properly
-      getTemperatureScale();
-    }
-
-  float tmpF = getAnalogValue(AV_Room_Temperature);
-
-  if (m_isCelsius)
-    m_temperature = tmpF;
-  else
-    m_temperature = f2c(tmpF);
-}
-
-float TB7300::getTemperature(bool fahrenheit)
-{
-  if (fahrenheit)
-    return c2f(m_temperature);
-  else
-    return m_temperature;
-}
-
-void TB7300::setTemperatureScale(bool fahrenheit)
-{
-  setBinaryValue(BV_Temperature_Scale, fahrenheit);
-
-  m_isTempInitialized = true;
-  m_isCelsius = (fahrenheit) ? false : true;
-}
-
-bool TB7300::getTemperatureScale()
-{
-  bool scale = getBinaryValue(BV_Temperature_Scale);
-
-  m_isTempInitialized = true;
-  m_isCelsius = !scale;
-
-  return scale;
-}
diff --git a/src/tb7300/tb7300.hpp b/src/tb7300/tb7300.hpp
deleted file mode 100644
index 4108f40..0000000
--- a/src/tb7300/tb7300.hpp
+++ /dev/null
@@ -1,258 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <map>
-
-#include "bacnetmstp.hpp"
-#include "bacnetutil.hpp"
-
-namespace upm {
-
-  /**
-   * @brief Honeywell TB7300 Communicating Fan Coil Thermostat
-   * @defgroup tb7300 libupm-tb7300
-   * @ingroup uart temp
-   */
-
-  /**
-   * @library tb7300
-   * @sensor tb7300
-   * @comname Communicating Fan Coil Thermostat
-   * Thermostat
-   * @type temp
-   * @man honeywell
-   * @con uart
-   * @web https://parts-hvac.com/tb7300c5014b.html
-   *
-   * @brief Honeywell TB7300 Communicating Fan Coil Thermostat
-   *
-   * This module implements support for the Honeywell TB7300
-   * Communicating Fan Coil Thermostat.  It may also support the
-   * TB7200, though only the TB7300 was available for development of
-   * this driver.
-   *
-   * The TB7200 Series PI thermostats are designed for zoning
-   * applications, and the TB7300 Series PI thermostats are designed
-   * for fan coil control. Both Series are communicating thermostats
-   * with models available in BACnet(r) MS/TP protocol and can be easily
-   * integrated into a WEBs-AX building automation system based on the
-   * NiagaraAX(r) platform.
-   *
-   * TB7200 and TB7300 Series thermostats are compatible with the
-   * Honeywell Occupancy Sensor Cover. Thermostats equipped with an
-   * occupancy sensor cover provide advanced active occupancy logic,
-   * which will automatically switch occupancy levels from Occupied to
-   * Stand-By and Unoccupied as required by local activity being
-   * present or not. This advanced occupancy functionality provides
-   * advantageous energy savings during occupied hours without
-   * sacrificing occupant comfort. All thermostats can be ordered with
-   * or without a factory installed PIR cover.
-   *
-   * If you intend to work with this device and driver, it is
-   * strongly suggested you get the BACnet Intergration Guide document
-   * for this device: 63-4524.pdf as recommended in the device
-   * documentation.
-   *
-   * This module was developed using the upm::BACNETMSTP library,
-   * based on libbacnet-stack 0.8.3.  Both libbacnet 0.8.3 and the
-   * upm::BACNETMSTP libraries must be present in order to build this
-   * module.
-   *
-   * It was connected using an RS232->RS485 interface.  You cannot use
-   * the built in MCU TTL UART pins for accessing this device -- you
-   * must use a full Serial RS232->RS485 or USB-RS485 interface
-   * connected via USB.
-   *
-   * @snippet tb7300.cxx Interesting
-   */
-
-  class TB7300 : public BACNETUTIL {
-  public:
-
-    // Supported Analog Value Objects.  These are readable and writable.
-    typedef enum : uint32_t {
-      AV_Room_Temperature                     = 7,
-
-      // GRP 20 Control Output
-      AV_PI_Heating_Demand                    = 21,
-      AV_PI_Cooling_Demand                    = 22,
-
-      // GRP 38 Temperature Setpoints
-      AV_Occupied_Heat_Setpoint               = 39,
-      AV_Occupied_Cool_Setpoint               = 40,
-      AV_Standby_Heat_Setpoint                = 41,
-      AV_Standby_Cool_Setpoint                = 42,
-      AV_Unoccupied_Heat_Setpoint             = 43,
-      AV_Unoccupied_Cool_Setpoint             = 44,
-
-      // GRP 55 General Options 2
-      AV_Password_Value                       = 56,
-      AV_Heating_Setpoint_Limit               = 58,
-      AV_Cooling_Setpoint_Limit               = 59,
-      AV_Deadband                             = 63,
-      AV_Standby_Time                         = 67,
-      AV_Unoccupied_Time                      = 68
-    } ANALOG_VALUES_T;
-
-    // Supported Analog Input Objects.  These are read only.
-    typedef enum : uint32_t {
-      AI_Supply_Temperature                   = 12
-    } ANALOG_INPUTS_T;
-
-    // Supported Binary Value Objects.  These are readable and writable.
-    typedef enum : uint32_t {
-      BV_Temp_Override                        = 8,
-      BV_Aux_Command                          = 14,
-
-      // GRP 45 General Options 1
-      BV_Menu_Scroll                          = 49,
-      BV_Auto_Mode_Enable                     = 50,
-      BV_Temperature_Scale                    = 51,
-
-      // GRP 55 General Option 2
-      BV_Setpoint_Type                        = 60,
-      BV_Setpoint_Function                    = 61,
-      BV_Reheat_Timebase                      = 64,
-      BV_Auto_Fan                             = 66,
-
-      // GRP 74 Output Configuration Options
-      BV_Control_type                         = 75,
-      BV_Direct_Reverse_Acting                = 78
-    } BINARY_VALUES_T;
-
-    // Supported Binary Input Objects.  These are read only.
-    typedef enum : uint32_t {
-      // GRP 24 Controller Status
-      BI_AUX_Status                           = 25,
-      BI_BI1_Status                           = 29,
-      BI_BI2_Status                           = 30,
-      BI_UI3_Status                           = 31,
-      BI_Local_Motion                         = 32,
-
-      // GRP 34 Controller Alarms
-      BI_Window_Alarm                         = 35,
-      BI_Filter_Alarm                         = 36,
-      BI_Service_Alarm                        = 37
-    } BINARY_INPUTS_T;
-
-    // Supported Multi-State Value Objects.  These are readable and
-    // writable.
-    typedef enum : uint32_t {
-      MV_Sequence_of_Operation                = 15,
-      MV_System_Mode                          = 16,
-      MV_Fan_Mode                             = 17,
-      MV_Occupancy_Command                    = 18,
-      MV_Keypad_Lockout                       = 19,
-
-      // GRP 24 Controller Status
-      MV_Heating_Valve_Status                 = 26,
-      MV_Cooling_Valve_Status                 = 27,
-      MV_Fan_Status                           = 28,
-      MV_Effective_Occupancy                  = 33,
-
-      // GRP 45 General Options 1
-      MV_BI1_Configuration                    = 46,
-      MV_BI2_Configuration                    = 47,
-      MV_UI1_Configuration                    = 48,
-      MV_Pipe_Number                          = 52,
-      MV_Out1_Config                          = 53,
-      MV_AUX_Configuration                    = 54,
-
-      // GRP 55 General Option 2
-      MV_Fan_Mode_Sequence                    = 58,
-      MV_Temporary_Occupancy_Time             = 62,
-      MV_Proportional_Band                    = 65,
-
-      // GRP 74 Output Configuration Options
-      MV_Floating_Motor_Timing                = 76,
-      MV_On_Off_Control_CPH                   = 77
-    } MULTISTATE_VALUES_T;
-
-    /**
-     * TB7300 constructor
-     *
-     * @param targetDeviceObjectID the unique Instance ID of the
-     * Device Object.  This number is used to uniquely identify
-     * devices on the BACnet network, and ranges from 1 to 4194302.
-     * This is not the device's MAC address, though on some devices,
-     * the MAC address may be used as part of this number.  On the
-     * TB7300, this number depends on the model and the MAC address.
-     */
-    TB7300(uint32_t targetDeviceObjectID);
-
-    /**
-     * TB7300 Destructor
-     */
-    ~TB7300();
-
-    /**
-     * Read current temperature from the sensor and update internal
-     * stored value.  This method must be called prior to querying the
-     * temperature.  All other values in the device must be queried
-     * directly via the appropriate BACNETUTIL::get*() methods
-     * depending on the object of interest.
-     */
-    void update();
-
-    /**
-     * Get the current temperature.  update() must have been called
-     * prior to calling this method.
-     *
-     * @param fahrenheit true to return the temperature in degrees
-     * fahrenheit, false to return the temperature in degrees celsius.
-     * The default is false (degrees Celsius).
-     * @return The last temperature reading in Celsius or Fahrenheit.
-     */
-    float getTemperature(bool fahrenheit=false);
-
-    /**
-     * Set the device temperature scale to Celsius of Fahrenheit.  For
-     * devices with an LCD display, this will affect which scale is
-     * displayed.  When changing the scale, it may take several
-     * seconds for the setting to take effect.
-     *
-     * @param fahrenheit true to set the scale to fahrenheit, false
-     * for celsius.
-     */
-    void setTemperatureScale(bool fahrenheit);
-
-    /**
-     * Get the device temperature scale.
-     *
-     * @return true if scale is fahrenheit, false for celsius.
-     */
-    bool getTemperatureScale();
-
-  protected:
-    // always stored in C
-    float m_temperature;
-
-    bool m_isTempInitialized;
-    bool m_isCelsius;
-
-  private:
-  };
-}
diff --git a/src/tb7300/tb7300.i b/src/tb7300/tb7300.i
deleted file mode 100644
index 1f1b7f6..0000000
--- a/src/tb7300/tb7300.i
+++ /dev/null
@@ -1,29 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-/* We need to use this method for enum wrapping since the enum typedefs used
- * by the derived classes (like ANALOG_VALUES_T) are passed to methods
- * in the base class which expect a uint32_t.  This is fine, and
- * works everywhere except Java.  It's type safety is a little too
- * stringent in these cases.  %javaconst(1) is generally recommended
- * as it avoids JNI calls to determine the enumerant values at
- * runtime.
- */
-%include "enumtypeunsafe.swg"
-%javaconst(1);
-
-JAVA_JNI_LOADLIBRARY(javaupm_tb7300)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "bacnetmstp.hpp"
-#include "bacnetutil.hpp"
-#include "tb7300.hpp"
-%}
-%include "bacnetmstp.hpp"
-%include "bacnetutil.hpp"
-%include "tb7300.hpp"
-/* END Common SWIG syntax */
diff --git a/src/tb7300/tb7300.json b/src/tb7300/tb7300.json
deleted file mode 100644
index 045744b..0000000
--- a/src/tb7300/tb7300.json
+++ /dev/null
@@ -1,46 +0,0 @@
-{
-    "Library": "tb7300",
-    "Description": "Honeywell TB7300 Communicating Fan Coil Thermostat Library",
-    "Sensor Class": {
-        "TB7300": {
-            "Name": "API for the Honeywell TB7300 Communicating Fan Coil Thermostat",
-            "Description": "This is the UPM Module for the Honeywell TB7300 Communicating Fan Coil Thermostat. It may also support the TB7200, though only the TB7300 was available for development of this driver. The TB7200 Series PI thermostats are designed for zoning applications, and the TB7300 Series PI thermostats are designed for fan coil control. Both Series are communicating thermostats with models available in BACnet(r) MS/TP protocol and can be easily integrated into a WEBs-AX building automation system based on the NiagaraAX(r) platform. TB7200 and TB7300 Series thermostats are compatible with the Honeywell Occupancy Sensor Cover. Thermostats equipped with an occupancy sensor cover provide advanced active occupancy logic, which will automatically switch occupancy levels from Occupied to Stand-By and Unoccupied as required by local activity being present or not. This advanced occupancy functionality provides advantageous energy savings during occupied hours without sacrificing occupant comfort. All thermostats can be ordered with or without a factory installed PIR cover.",
-            "Aliases": ["tb7300", "TB7300C5014B"],
-            "Categories": ["temperature"],
-            "Connections": ["uart"],
-            "Project Type": ["industrial", "commercial"],
-            "Manufacturers": ["honeywell"],
-            "Examples": {
-                "Java": ["TB7300_Example.java"],
-                "Python": ["tb7300.py"],
-                "Node.js": ["tb7300.js"],
-                "C++": ["tb7300.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 19,
-                    "max": 30
-                },
-                "Supply Current": {
-                    "unit": "A",
-                    "min" : 1,
-                    "max" : 3
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": 0,
-                    "max": 50
-                },
-                "Operating Humidity": {
-                    "unit": "RH",
-                    "min" : "0%",
-                    "max" : "95%"
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://parts-hvac.com/tb7300c5014b.html"]
-            }
-        }
-    }
-}
diff --git a/src/tca9548a/CMakeLists.txt b/src/tca9548a/CMakeLists.txt
deleted file mode 100644
index c4e091f..0000000
--- a/src/tca9548a/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "tca9548a")
-set (libdescription "tca9548a i2c multiplexer 8 channels")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/tca9548a/tca9548a.cxx b/src/tca9548a/tca9548a.cxx
deleted file mode 100644
index 2c02de8..0000000
--- a/src/tca9548a/tca9548a.cxx
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Author: Gerard Vidal <gerard.vidal@ens-lyon.fr>
- * Copyright (c) 2017 IFE-ENS-Lyon
- * Author: Keelan Lightfoot <keelanlightfoot@gmail.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "tca9548a.hpp"
-#include <syslog.h>
-
-#include <unistd.h>
-#include <stdexcept>
-#include <string>
-#include <string.h>
-#include <math.h>
-
-using namespace upm;
-
-TCA9548A::TCA9548A (int bus, uint8_t address){
-    m_name = "tca9548a";
-    if(!(i2c = new mraa::I2c(bus))){
-        throw std::invalid_argument(std::string(__FUNCTION__)
-                                    +": I2c.init() failed");
-        return;
-    }
-
-    if((i2c->address(address) != mraa::SUCCESS)){
-        throw std::invalid_argument(std::string(__FUNCTION__)
-                                    + ": I2c.address() failed");
-        return;
-    }
-
-    if(i2c->frequency( mraa::I2C_FAST) != mraa::SUCCESS){
-        syslog(LOG_WARNING,
-               "%s: I2c.frequency(I2C_FAST) failed, using default speed",
-               std::string(__FUNCTION__).c_str());
-    }
-}
-
-TCA9548A::~TCA9548A (){
-    delete i2c;
-}
-
-
-bool
-TCA9548A::getPort(int port) {
-    uint8_t config;
-    // Check range
-    if (!validPort(port)) {
-        throw std::invalid_argument(std::string(__FUNCTION__)
-                                    + ": port index out of range");
-        return false;
-    }
-    // Get current port configuration
-    config = getPortConfig();
-    // Check if the bit is set
-    return (config & (0x01 << port));
-}
-
-void
-TCA9548A::setPort(int port, TCA9548A_PORT_STATE state,
-                  TCA9548A_PORT_MODE mode) {
-    uint8_t config;
-    // Check range
-    if (!validPort(port)) {
-        throw std::invalid_argument(std::string(__FUNCTION__)
-                                    + ": port index out of range");
-        return;
-    }
-    // If we're enabling more than one port at a time, we need to do a
-    // read-modify-write.
-    if (mode == INCLUSIVE) {
-        config = getPortConfig();
-    } else {
-        config = TCA9548A_NO_PORTS;
-    }
-
-    // Convert port number to control byte
-    if (state == ENABLED) {
-        config |= (0x01 << port);
-    } else {
-        config &= ~(0x01 << port);
-    }
-    // Set port
-    setPortConfig(config);
-}
-
-void
-TCA9548A::disableAllPorts() {
-    // Turn off all ports
-    setPortConfig(TCA9548A_NO_PORTS);
-}
-
-void
-TCA9548A::enableAllPorts() {
-    // Turn on all ports
-    setPortConfig(TCA9548A_ALL_PORTS);
-}
-
-//Private functions
-
-uint8_t
-TCA9548A::getPortConfig() {
-    return i2c->readByte();
-}
-
-void
-TCA9548A::setPortConfig(uint8_t config) {
-    if(i2c->writeByte(config) != mraa::SUCCESS) {
-        throw std::runtime_error(std::string(__FUNCTION__)
-                                 + ": I2c.write() failed");
-        return;
-    }
-}
-
-bool
-TCA9548A::validPort(int port) {
-    return (port >= TCA9548A_MIN_PORT && port <= TCA9548A_MAX_PORT);
-}
diff --git a/src/tca9548a/tca9548a.hpp b/src/tca9548a/tca9548a.hpp
deleted file mode 100644
index ed31438..0000000
--- a/src/tca9548a/tca9548a.hpp
+++ /dev/null
@@ -1,189 +0,0 @@
-/*
- * Author: Gerard Vidal <gerard.vidal@ens-lyon.fr>
- * Copyright (c) 2017 IFE-ENS-Lyon
- * Author: Keelan Lightfoot <keelanlightfoot@gmail.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <iostream>
-#include <string>
-#include "mraa.hpp"
-#include "mraa/i2c.hpp"
-
-#define TCA9548A_I2C_BUS 0
-#define TCA9548A_DEFAULT_ADDR 0x70
-#define TCA9548A_NO_PORTS 0x00
-#define TCA9548A_ALL_PORTS 0xFF
-
-#define TCA9548A_MIN_PORT 0
-#define TCA9548A_MAX_PORT 7
-
-namespace upm {
-    /**
-     * @brief TCA9548A I2C Multiplexer
-     * @defgroup tca9548a libupm-tca9548a
-     * @ingroup adafruit i2c
-     */
-    /**
-     * @library tca9548a
-     * @sensor TCA9548A
-     * @comname 1-to-8 I2C Multiplexer Breakout
-     * @type multiplexer
-     * @man adafruit
-     * @con i2c
-     * @web https://learn.adafruit.com/adafruit-tca9548a-1-to-8-i2c-multiplexer-breakout/overview
-     *
-     * @brief API TCA9548A Multiplexer Breakout
-     *
-     * The TCA9548A device has eight bidirectional translating switches
-     * that can be controlled through the I2C bus. The SCL/SDA upstream
-     * pair fans out to eight downstream pairs, or channels. Any
-     * individual SCn/SDn channel or combination of channels can be
-     * selected, determined by the contents of the programmable control
-     * register.
-     *
-     * The TCA9548A Multiplexer Breakout enables to get - up to 8
-     * same-address I2C devices hooked up to one microcontroller - or up
-     * to 8 independent I2C buses. This multiplexer acts as a
-     * gatekeeper, shuttling the commands to the selected set of I2C
-     * pins with your command. The TCA9548A multiplexer is interesting
-     * in that it has an I2C address (0x70 by default) - and you
-     * basically send it a command to tell it which I2C multiplexed
-     * output you want to talk to, then you can address the board you
-     * want to address. You simply write a single byte with the desired
-     * multiplexed output number to that port, and bam - any future I2C
-     * packets will get sent to that port.
-     *
-     * The TCA9548A Multiplexer provides three pins (A0-A1-A2) that
-     * enable to change its address in case 0x70 address is used by
-     * another sensor on the same bus. By connecting one of the Ax pin
-     * to Vin you change its value from 0 to 1, these values change the
-     * value of the three first bits of the address :
-     *
-     * Address 0b01110-A2-A1-A0
-     *    No wiring  A2=0 A1=0 A0=0  Address 0b01110000 0x70
-     *    A0 wired   A2=0 A1=0 A0=1  Address 0b01110000 0x71
-     *    A2 wired   A2=1 A1=0 A0=0  Address 0b01110100 0x74
-     * Any address between 0x70 and 0x77 can be selected.
-     *
-     * Tested with Adafriut TCA9548A board.
-     *
-     * @image html tca9548a.jpg
-     * @snippet tca9548.cxx Interesting
-     */
-    class TCA9548A {
-
-    public:
-        /**
-         * @enum TCA9548A_PORT_STATE
-         * @brief boolean enum containing port state
-         *
-         * @var TCA9548A_PORT_STATE::DISABLED = 0
-         * @var TCA9548A_PORT_STATE::ENABLED = 1
-         */
-        typedef enum {
-            DISABLED = 0,
-            ENABLED = 1
-        } TCA9548A_PORT_STATE;
-
-        /**
-         * @enum TCA9548A_PORT_MODE
-         * @brief boolean enum containing port access mode
-         *
-         * @var TCA9548A_PORT_MODE::EXCLUSIVE = 0
-         * @var TCA9548A_PORT_MODE::INCLUSIVE = 1
-         */
-        typedef enum {
-            EXCLUSIVE = 0,
-            INCLUSIVE = 1
-        } TCA9548A_PORT_MODE;
-
-
-        /**
-         * TCA9548A constructor
-         *
-         * @param address. Device address. Default is 0x70.
-         */
-        TCA9548A (int bus, uint8_t address = 0x70);
-
-        /**
-         * TCA9548A destructor
-         */
-        ~TCA9548A();
-
-        /**
-         * Returns the name of the switch
-         */
-        std::string name() {
-            return m_name;
-        }
-
-        /**
-         * Returns the status of a port as configured in the multiplexer.
-         *
-         *  @param port Switch port to check
-         */
-        bool getPort(int port);
-
-        /**
-         *  Configure an individual port on the multiplexer
-         *
-         *  @param port Port to configure
-         *  @param enabled Set to true to enable the port, false to
-         *  disable the port.
-         *  @param exclusive Set to true to disable all other
-         *  ports, false to leave existing port config
-         *  untouched. When exclusive is set to false, an
-         *  additional i2c read is required to read the current
-         *  port setting.
-         */
-        void setPort(int port, TCA9548A_PORT_STATE state,
-                     TCA9548A_PORT_MODE mode);
-
-        /**
-         *  Disables all ports on the multiplexer.
-         */
-        void disableAllPorts();
-
-        /**
-         *  Enables all ports on the multiplexer. Useful when the
-         *  multiplexer is used to electrically extend the bus
-         *  rather than resolve address conflicts.
-         */
-        void enableAllPorts();
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        TCA9548A(const TCA9548A&) = delete;
-        TCA9548A &operator=(const TCA9548A&) = delete;
-
-        std::string m_name;
-
-        mraa::I2c* i2c;
-
-        uint8_t getPortConfig();
-        void setPortConfig(uint8_t config);
-        bool validPort(int port);
-    };
-}
diff --git a/src/tca9548a/tca9548a.json b/src/tca9548a/tca9548a.json
deleted file mode 100644
index d13da8b..0000000
--- a/src/tca9548a/tca9548a.json
+++ /dev/null
@@ -1,56 +0,0 @@
-{
-    "Library": "tca9548",
-    "Description": "TI tca9548a multiplexer library",
-    "Sensor Class": {
-        "TCA9548A": {
-            "Name": "API for the TI TCA9548A Multiplexer Breakout",
-            "Description": "This is the UPM Module for the Texas Instruments TCA9548A Multiplexer Breakout.",
-            "Aliases": ["TCA9548A", "TCA9548A I2C Multiplexer"],
-            "Categories": ["multiplexer"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["Adafruit", "Texas Instruments"],
-            "Image": "tca9548a.jpg",
-            "Examples": {
-                "Node.js": ["tca9548.js"],
-                "C++": ["tca9548a.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 1.65,
-                    "max": 5.5
-                },
-                "Supply Current": {
-                    "unit": "uA",
-                    "min" : 2,
-                    "max" : 80
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Supported Same Address i2c Devices": {
-                    "unit": "Devices",
-                    "devices": 8
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need pull up resistors"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.adafruit.com/product/2717", "https://learn.adafruit.com/adafruit-tca9548a-1-to-8-i2c-multiplexer-breakout/overview"],
-                "Datasheets": ["https://cdn-shop.adafruit.com/datasheets/tca9548a.pdf"]
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/tcs3414cs/CMakeLists.txt b/src/tcs3414cs/CMakeLists.txt
deleted file mode 100644
index 8eeed97..0000000
--- a/src/tcs3414cs/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "tcs3414cs")
-set (libdescription "I2C Color Sensor")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/tcs3414cs/tcs3414cs.cxx b/src/tcs3414cs/tcs3414cs.cxx
deleted file mode 100644
index 5894f62..0000000
--- a/src/tcs3414cs/tcs3414cs.cxx
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Credits to Seeed Studeo.
- * Based on Seeed Studeo code example,
- * http://www.seeedstudio.com/wiki/index.php?title=Twig_-_I2C_Color_Sensor_v0.9b.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <unistd.h>
-#include <stdlib.h>
-#include <stdexcept>
-
-#include "tcs3414cs.hpp"
-
-using namespace upm;
-
-TCS3414CS::TCS3414CS (int bus, int addr) : m_i2Ctx(bus) {
-    m_name = "TCS3414CS";
-
-    mraa::Result ret = m_i2Ctx.address(addr);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) + 
-                                    ": m_i2Ctx.address() failed");
-    }
-
-    // Set timing register
-    i2cWriteReg (REG_TIMING, INTEG_MODE_FREE);
-    usleep (100000);
-
-    // Set interrupt source register
-    i2cWriteReg (REG_INT_SOURCE, INT_SOURCE_GREEN);
-    usleep (100000);
-
-    // Set interrupt control register
-    i2cWriteReg (REG_INT, INTR_LEVEL | INTR_PERSIST_EVERY);
-    usleep (100000);
-
-    // Set gain
-    i2cWriteReg (REG_GAIN, GAIN_1 | PRESCALER_4);
-    usleep (100000);
-
-    // Enable ADC
-    i2cWriteReg (REG_CTL, CTL_DAT_INIITIATE);
-    usleep (100000);
-}
-
-void
-TCS3414CS::readRGB (tcs3414sc_rgb_t * rgb) {
-    uint8_t buffer[8];
-
-    // We need 7 bytes of data.
-    if (i2cReadReg_N (REG_BLOCK_READ, 8, buffer) > 7) {
-        rgb->g = buffer[1] * 256 + buffer[0];
-        rgb->r = buffer[3] * 256 + buffer[2];
-        rgb->b = buffer[5] * 256 + buffer[4];
-        rgb->clr = buffer[7] * 256 + buffer[6];
-    }
-}
-
-void
-TCS3414CS::clearInterrupt () {
-    mraa::Result error = mraa::SUCCESS;
-
-    error = m_i2Ctx.writeByte (CLR_INT);
-
-    if (error != mraa::SUCCESS) {
-        throw std::runtime_error(std::string(__FUNCTION__) + 
-                                 ": Couldn't clear interrupt");
-    }
-}
-
-/*
- * **************
- *  private area
- * **************
- */
-uint16_t
-TCS3414CS::i2cReadReg_N (int reg, unsigned int len, uint8_t * buffer) {
-    int readByte = 0;
-
-    m_i2Ctx.writeByte(reg);
-
-    readByte = m_i2Ctx.read(buffer, len);
-    return readByte;
-}
-
-mraa::Result
-TCS3414CS::i2cWriteReg_N (uint8_t reg, unsigned int len, uint8_t * buffer) {
-    mraa::Result error = mraa::SUCCESS;
-
-    error = m_i2Ctx.writeByte (reg);
-    error = m_i2Ctx.write (buffer, len);
-
-    return error;
-}
-
-mraa::Result
-TCS3414CS::i2cWriteReg (uint8_t reg, uint8_t data) {
-    mraa::Result error = mraa::SUCCESS;
-
-    error = m_i2Ctx.writeByte (reg);
-    error = m_i2Ctx.writeByte (data);
-
-    return error;
-}
diff --git a/src/tcs3414cs/tcs3414cs.hpp b/src/tcs3414cs/tcs3414cs.hpp
deleted file mode 100644
index d1bbd56..0000000
--- a/src/tcs3414cs/tcs3414cs.hpp
+++ /dev/null
@@ -1,167 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Credits to Seeed Studeo.
- * Based on Seeed Studeo code example,
- * http://www.seeedstudio.com/wiki/index.php?title=Twig_-_I2C_Color_Sensor_v0.9b.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/i2c.hpp>
-
-#define DEFAULT_ADDR                0x39 // device address
-
-#define REG_CTL                     0x80
-#define REG_TIMING                  0x81
-#define REG_INT                     0x82
-#define REG_INT_SOURCE              0x83
-#define REG_ID                      0x84
-#define REG_GAIN                    0x87
-#define REG_LOW_THRESH_LOW_BYTE     0x88
-#define REG_LOW_THRESH_HIGH_BYTE    0x89
-#define REG_HIGH_THRESH_LOW_BYTE    0x8A
-#define REG_HIGH_THRESH_HIGH_BYTE   0x8B
-#define REG_BLOCK_READ              0xCF
-#define REG_GREEN_LOW               0xD0
-#define REG_GREEN_HIGH              0xD1
-#define REG_RED_LOW                 0xD2
-#define REG_RED_HIGH                0xD3
-#define REG_BLUE_LOW                0xD4
-#define REG_BLUE_HIGH               0xD5
-#define REG_CLEAR_LOW               0xD6
-#define REG_CLEAR_HIGH              0xD7
-#define CTL_DAT_INIITIATE           0x03
-#define CLR_INT                     0xE0
-
-/* Timing Register */
-#define SYNC_EDGE                   0x40
-#define INTEG_MODE_FREE             0x00
-#define INTEG_MODE_MANUAL           0x10
-#define INTEG_MODE_SYN_SINGLE       0x20
-#define INTEG_MODE_SYN_MULTI        0x30
-
-#define INTEG_PARAM_PULSE_COUNT1    0x00
-#define INTEG_PARAM_PULSE_COUNT2    0x01
-#define INTEG_PARAM_PULSE_COUNT4    0x02
-#define INTEG_PARAM_PULSE_COUNT8    0x03
-
-/* Interrupt Control Register */
-#define INTR_STOP                   40
-#define INTR_DISABLE                0x00
-#define INTR_LEVEL                  0x10
-#define INTR_PERSIST_EVERY          0x00
-#define INTR_PERSIST_SINGLE         0x01
-
-/* Interrupt Souce Register */
-#define INT_SOURCE_GREEN            0x00
-#define INT_SOURCE_RED              0x01
-#define INT_SOURCE_BLUE             0x10
-#define INT_SOURCE_CLEAR            0x03
-
-/* Gain Register */
-#define GAIN_1                      0x00
-#define GAIN_4                      0x10
-#define GAIN_16                     0x20
-#define GANI_64                     0x30
-#define PRESCALER_1                 0x00
-#define PRESCALER_2                 0x01
-#define PRESCALER_4                 0x02
-#define PRESCALER_8                 0x03
-#define PRESCALER_16                0x04
-#define PRESCALER_32                0x05
-#define PRESCALER_64                0x06
-
-#define HIGH                        1
-#define LOW                         0
-
-namespace upm {
-
-typedef struct {
-    uint16_t r;
-    uint16_t g;
-    uint16_t b;
-    uint16_t clr;
-} tcs3414sc_rgb_t;
-
-/**
- * @brief TCS3414CS Color Sensor
- * @defgroup tcs3414cs libupm-tcs3414cs
- * @ingroup seeed i2c color
- */
-/**
- * @library tcs3414cs
- * @sensor tcs3414cs
- * @comname I2C Color Sensor
- * @altname Grove Color Sensor
- * @type color
- * @man seeed
- * @web http://www.seeedstudio.com/wiki/Grove_-_I2C_Color_Sensor
- * @con i2c
- *
- * @brief API for the TCS3414CS Color Sensor
- * 
- * This module defines the TCS3414CS interface for the color sensor
- *
- * @image html tcs3414cs.jpg
- * @snippet tcs3414cs.cxx Interesting
- */
-class TCS3414CS {
-    public:
-        /**
-         * Instantiates a TCS3414CS object
-         *
-         * @param bus Number of the used bus
-         * @param addr I2C address of the device
-         */
-        TCS3414CS (int bus = 0, int addr = DEFAULT_ADDR);
-
-        /**
-         * Gets the RGB value from the sensor.
-         *
-         * @param rgb Color values
-         */
-        void readRGB (tcs3414sc_rgb_t * rgb);
-
-        /**
-         * Clears interrupts.
-         */
-        void clearInterrupt ();
-
-        /**
-         * Returns the name of the component
-         */
-        std::string name()
-        {
-            return m_name;
-        }
-    private:
-        std::string m_name;
-        mraa::I2c m_i2Ctx;
-
-        uint16_t i2cReadReg_N (int reg, unsigned int len, uint8_t * buffer);
-        mraa::Result i2cWriteReg_N (uint8_t reg, unsigned int len, uint8_t * buffer);
-        mraa::Result i2cWriteReg (uint8_t reg, uint8_t data);
-};
-
-}
diff --git a/src/tcs3414cs/tcs3414cs.json b/src/tcs3414cs/tcs3414cs.json
deleted file mode 100644
index 2dd644c..0000000
--- a/src/tcs3414cs/tcs3414cs.json
+++ /dev/null
@@ -1,50 +0,0 @@
-{
-    "Library": "tcs3414cs",
-    "Description": "Seeed TCS3414CS Color Sensor library",
-    "Sensor Class": {
-        "TCS3414CS": {
-            "Name": "API for the Seeed TCS3414CS Color Sensor",
-            "Description": "This is the UPM Module for the Seeed TCS3414CS Color Sensor. This module is based on the color sensor TCS3414CS with digital output I2C. Based on the 8*2 array of filtered photodiodes and 16-bit analog-to-digital converters, you can measure the color chromaticity of ambient light or the color of objects. Of the 16 photodiodes, 4 have red filters, 4 have green filters, 4 have blue filters and 4 have no filter(clear). With the synchronization input pin, an external pulsed light source can provide precise synchronous conversion control.",
-            "Aliases": ["tcs3414cs"],
-            "Categories": ["light"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping"],
-            "Manufacturers": ["Seeed", "TAOS", "ams"],
-            "Image": "tcs3414cs.jpg",
-            "Examples": {
-                "Python": ["tcs3414cs.py"],
-                "Node.js": ["tcs3414cs.js"],
-                "C++": ["tcs3414cs.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.3,
-                    "max": 6.0
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "min" : 1,
-                    "max" : 12
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -30,
-                    "max": 70
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["http://wiki.seeed.cc/Grove-I2C_Color_Sensor/"],
-                "Datasheets": ["https://raw.githubusercontent.com/SeeedDocument/Grove-I2C_Color_Sensor/master/res/TCS3404_TCS3414-A.pdf", "https://github.com/SeeedDocument/Grove-I2C_Color_Sensor/raw/master/res/TCS3472%20Datasheet.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/tcs37727/CMakeLists.txt b/src/tcs37727/CMakeLists.txt
deleted file mode 100644
index 9596a70..0000000
--- a/src/tcs37727/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "tcs37727")
-set (libdescription "Color Sensor")
-set (module_src ${libname}.cpp)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/tcs37727/tcs37727.cpp b/src/tcs37727/tcs37727.cpp
deleted file mode 100644
index ff3a55e..0000000
--- a/src/tcs37727/tcs37727.cpp
+++ /dev/null
@@ -1,349 +0,0 @@
-/*
- * Author: Norbert Wesp <nwesp@phytec.de>
- * Copyright (c) 2017 Phytec Messtechnik GmbH.
- *
- * based on: RIOT-driver tcs37727 by Johann Fischer <j.fischer@phytec.de>
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include <unistd.h>
-#include <stdlib.h>
-#include <endian.h>
-
-#include "tcs37727.hpp"
-
-using namespace upm;
-
-TCS37727::TCS37727(int bus, int atime_us, int devAddr) : m_i2ControlCtx(bus) {
-    s_data->red = 0;
-    s_data->green = 0;
-    s_data->blue = 0;
-    s_data->clear = 0;
-    s_data->lux = 0;
-    s_data->ct = 0;
-    s_again = 4;
-
-    m_name = TCS37727_NAME;
-
-    m_controlAddr = devAddr;
-    m_bus = bus;
-
-    mraa::Result ret = m_i2ControlCtx.address(m_controlAddr);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_address() failed");
-    }
-
-    if (checkID() != 0) {
-        /* sensor_id does not match! maybe wrong sensor chosen? */
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": checkID() failed");
-    }
-
-    ret = m_i2ControlCtx.writeReg(TCS37727_CONTROL, TCS37727_CONTROL_AGAIN_4);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_byte_data() failed");
-    }
-
-    ret = m_i2ControlCtx.writeReg(TCS37727_ATIME,
-                                             TCS37727_ATIME_TO_REG(atime_us));
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_byte_data() failed");
-    }
-
-    s_atime_us = atime_us;
-}
-
-int
-TCS37727::checkID(void)
-{
-    uint8_t id;
-
-    id = m_i2ControlCtx.readReg(TCS37727_DEVICE_ID_REG);
-
-    if (id != TCS37727_DEVICE_ID) {
-        return -1;
-    }
-
-    return 0;
-}
-
-int
-TCS37727::setActive(void)
-{
-    uint8_t reg;
-
-    reg = m_i2ControlCtx.readReg(TCS37727_ENABLE);
-
-    reg |= (TCS37727_ENABLE_AEN | TCS37727_ENABLE_PON);
-
-    mraa::Result ret = m_i2ControlCtx.writeReg(TCS37727_ENABLE, reg);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_byte_data() failed");
-        return -1;
-    }
-    return 0;
-}
-
-int
-TCS37727::setStandby(void)
-{
-    uint8_t reg;
-
-    reg = m_i2ControlCtx.readReg(TCS37727_ENABLE);
-
-    reg &= ~TCS37727_ENABLE_AEN;
-    if (!(reg & TCS37727_ENABLE_PEN)) {
-        reg &= ~TCS37727_ENABLE_PON;
-    }
-
-    mraa::Result ret = m_i2ControlCtx.writeReg(TCS37727_ENABLE, reg);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_byte_data() failed");
-        return -1;
-    }
-    return 0;
-}
-
-uint8_t
-TCS37727::trimGain(int rawc)
-{
-    uint8_t reg_again = 0;
-    int val_again = s_again;
-    uint8_t reg;
-
-    if (rawc < TCS37727_AG_THRESHOLD_LOW) {
-        switch (val_again) {
-            case 1:
-                reg_again = TCS37727_CONTROL_AGAIN_4;
-                val_again = 4;
-                break;
-
-            case 4:
-                reg_again = TCS37727_CONTROL_AGAIN_16;
-                val_again = 16;
-                break;
-
-            case 16:
-                reg_again = TCS37727_CONTROL_AGAIN_60;
-                val_again = 60;
-                break;
-
-            case 60:
-            default:
-                return -1;
-        }
-    }
-    else if (rawc > TCS37727_AG_THRESHOLD_HIGH) {
-        switch (val_again) {
-            case 60:
-                reg_again = TCS37727_CONTROL_AGAIN_16;
-                val_again = 16;
-                break;
-
-            case 16:
-                reg_again = TCS37727_CONTROL_AGAIN_4;
-                val_again = 4;
-                break;
-
-            case 4:
-                reg_again = TCS37727_CONTROL_AGAIN_1;
-                val_again = 1;
-                break;
-
-            case 1:
-            default:
-                return -1;
-        }
-    }
-    else {
-        return 0;
-    }
-
-    reg = m_i2ControlCtx.readReg(TCS37727_CONTROL);
-
-    reg &= ~TCS37727_CONTROL_AGAIN_MASK;
-    reg |= reg_again;
-
-    mraa::Result ret = m_i2ControlCtx.writeReg(TCS37727_CONTROL, reg);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_byte_data() failed");
-        return -1;
-    }
-
-    s_again = val_again;
-
-    return 0;
-
-}
-
-int
-TCS37727::sampleData(void)
-{
-    uint8_t buf[8];
-    int num = 0;
-
-    num = m_i2ControlCtx.readBytesReg((TCS37727_INC_TRANS | TCS37727_CDATA),
-                                                                      buf, 8);
-    if (num != 8) {
-        /* not enough values were read */
-        return -1;
-    }
-
-    int32_t tmpc = ((uint16_t)buf[1] << 8) | buf[0];
-    int32_t tmpr = ((uint16_t)buf[3] << 8) | buf[2];
-    int32_t tmpg = ((uint16_t)buf[5] << 8) | buf[4];
-    int32_t tmpb = ((uint16_t)buf[7] << 8) | buf[6];
-
-    /* Remove IR component as described in the DN40.  */
-    int32_t ir = (tmpr + tmpg + tmpb - tmpc) >> 1;
-    tmpr -= ir;
-    tmpg -= ir;
-    tmpb -= ir;
-
-    /* Color temperature calculation as described in the DN40. */
-    int32_t ct = (CT_COEF_IF * tmpb) / tmpr + CT_OFFSET_IF;
-
-    /* Lux calculation as described in the DN40.  */
-    int32_t gi = R_COEF_IF * tmpr + G_COEF_IF * tmpg + B_COEF_IF * tmpb;
-    /* TODO: add Glass Attenuation Factor GA compensation */
-    int32_t cpl = (s_atime_us * s_again) / DGF_IF;
-    int32_t lux = gi / cpl;
-
-    /* Autogain */
-    trimGain(tmpc);
-
-    s_data->red = (tmpr < 0) ? 0 : (tmpr * 1000) / cpl;
-    s_data->green = (tmpg < 0) ? 0 : (tmpg * 1000) / cpl;
-    s_data->blue = (tmpb < 0) ? 0 : (tmpb * 1000) / cpl;
-    s_data->clear = (tmpb < 0) ? 0 : (tmpc * 1000) / cpl;
-    s_data->lux = (lux < 0) ? 0 : lux;
-    s_data->ct = (ct < 0) ? 0 : ct;
-
-    return 0;
-}
-
-uint32_t
-TCS37727::getChannelRed(int bSampleData)
-{
-    if (bSampleData) {
-        if (sampleData() != 0) {
-            /* error in read values from reg */
-            return 999;
-        }
-    }
-
-    return s_data->red;
-}
-
-uint32_t
-TCS37727::getChannelGreen(int bSampleData)
-{
-    if (bSampleData) {
-        if (sampleData() != 0) {
-            /* error in read values from reg */
-            return 999;
-        }
-    }
-
-    return s_data->green;
-}
-
-uint32_t
-TCS37727::getChannelBlue(int bSampleData)
-{
-    if (bSampleData) {
-        if (sampleData() != 0) {
-            /* error in read values from reg */
-            return 999;
-        }
-    }
-
-    return s_data->blue;
-}
-
-uint32_t
-TCS37727::getChannelClear(int bSampleData)
-{
-    if (bSampleData) {
-        if (sampleData() != 0) {
-            /* error in read values from reg */
-            return 999;
-        }
-    }
-
-    return s_data->clear;
-}
-
-uint32_t
-TCS37727::getLux(int bSampleData)
-{
-    if (bSampleData) {
-        if (sampleData() != 0) {
-            /* error in read values from reg */
-            return 999;
-        }
-    }
-
-    return s_data->lux;
-}
-
-uint32_t
-TCS37727::getColorTemperature(int bSampleData)
-{
-    if (bSampleData) {
-        if (sampleData() != 0) {
-            /* error in read values from reg */
-            return 999;
-        }
-    }
-
-    return s_data->ct;
-}
-
-int
-TCS37727::getData(tcs37727_data_t* data, int bSampleData)
-{
-    if (bSampleData) {
-        if (sampleData() != 0) {
-            /* error in read values from reg */
-            return -1;
-        }
-    }
-
-    data->red = s_data->red;
-    data->green = s_data->green;
-    data->blue = s_data->blue;
-    data->clear = s_data->clear;
-    data->lux = s_data->lux;
-    data->ct = s_data->ct;
-
-    return 0;
-}
diff --git a/src/tcs37727/tcs37727.hpp b/src/tcs37727/tcs37727.hpp
deleted file mode 100644
index 32b116a..0000000
--- a/src/tcs37727/tcs37727.hpp
+++ /dev/null
@@ -1,289 +0,0 @@
-/*
- * Author: Norbert Wesp <nwesp@phytec.de>
- * Copyright (c) 2017 Phytec Messtechnik GmbH.
- *
- * based on: RIOT-driver tcs37727 by Johann Fischer <j.fischer@phytec.de>
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <string>
-#include <mraa/i2c.hpp>
-#include <stdint.h>
-#include <stdbool.h>
-
-#define TCS37727_NAME "TCS37727"
-#define TCS37727_I2C_ADDRESS   0x29
-#define TCS37727_DEVICE_ID     0x49
-#define TCS37727_DEVICE_ID_REG 0x92
-
-#define TCS37727_ATIME_DEFAULT     200000  /* Default RGBC integration time */
-#define TCS37727_AG_THRESHOLD_LOW  200
-#define TCS37727_AG_THRESHOLD_HIGH (65535 - TCS37727_AG_THRESHOLD_LOW)
-
-
-/* TCS37727 Register Map */
-#define TCS37727_ENABLE  0x80 /* Enables states and interrupts */
-#define TCS37727_ATIME   0x81 /* RGBC time */
-#define TCS37727_PTIME   0x82 /* Proximity time */
-#define TCS37727_WTIME   0x83 /* Wait time */
-#define TCS37727_AILTL   0x04 /* Clear interrupt low threshold low byte */
-#define TCS37727_AILTH   0x05 /* Clear interrupt low threshold high byte */
-#define TCS37727_AIHTL   0x06 /* Clear interrupt high threshold low byte */
-#define TCS37727_AIHTH   0x07 /* Clear interrupt high threshold high byte */
-#define TCS37727_PILTL   0x08 /* Proximity inter. low threshold low byte */
-#define TCS37727_PILTH   0x09 /* Proximity inter. low threshold high byte */
-#define TCS37727_PIHTL   0x0A /* Proximity inter. high threshold low byte */
-#define TCS37727_PIHTH   0x0B /* Proximity inter. high threshold high byte */
-#define TCS37727_PERS    0x8C /* Interrupt persistence filters */
-#define TCS37727_CONFIG  0x8D /* Configuration */
-#define TCS37727_PPULSE  0x8E /* Proximity pulse count */
-#define TCS37727_CONTROL 0x8F /* Gain control register */
-#define TCS37727_STATUS  0x93 /* Device status */
-#define TCS37727_CDATA   0x14 /* Clear ADC data low byte */
-#define TCS37727_CDATAH  0x15 /* Clear ADC data high byte */
-#define TCS37727_RDATA   0x16 /* Red ADC data low byte */
-#define TCS37727_RDATAH  0x17 /* Red ADC data high byte */
-#define TCS37727_GDATA   0x18 /* Green ADC data low byte */
-#define TCS37727_GDATAH  0x19 /* Green ADC data high byte */
-#define TCS37727_BDATA   0x1A /* Blue ADC data low byte */
-#define TCS37727_BDATAH  0x1B /* Blue ADC data high byte */
-#define TCS37727_PDATA   0x1C /* Proximity ADC data low byte */
-#define TCS37727_PDATAH  0x1D /* Proximity ADC data high byte */
-
-/* TCS37727 Command Register */
-#define TCS37727_BYTE_TRANS 0x80 /* Repeated byte protocol transaction */
-#define TCS37727_INC_TRANS  0xA0 /* Auto-increment protocol transaction */
-#define TCS37727_SF_PICLR   0xE5 /* Proximity interrupt clear */
-#define TCS37727_SF_CICLR   0xE6 /* Clear channel interrupt clear */
-#define TCS37727_SF_PCICLR  0xE7 /* Proximity & Clear channel inter. clear */
-
-/* TCS37727 Enable Register */
-#define TCS37727_ENABLE_PIEN (1 << 5) /* Proximity interrupt enable */
-#define TCS37727_ENABLE_AIEN (1 << 4) /* Clear channel interrupt enable */
-#define TCS37727_ENABLE_WEN  (1 << 3) /* Wait enable */
-#define TCS37727_ENABLE_PEN  (1 << 2) /* Proximity enable */
-#define TCS37727_ENABLE_AEN  (1 << 1) /* RGBC enable, actives 2-channel ADC */
-#define TCS37727_ENABLE_PON  (1 << 0) /* Power ON */
-
-/* TCS37727 Control Register */
-#define TCS37727_CONTROL_PDRIVE_100  0x00 /* 100 mA LED Drive Strength */
-#define TCS37727_CONTROL_PDRIVE_50   0x04 /* 50 mA LED Drive Strength */
-#define TCS37727_CONTROL_PDRIVE_25   0x08 /* 25 mA LED Drive Strength */
-#define TCS37727_CONTROL_PDRIVE_12   0x0C /* 12.5 mA LED Drive Strength */
-#define TCS37727_CONTROL_PDRIVE_MASK 0x0C /* PDRIVE Mask */
-#define TCS37727_CONTROL_AGAIN_1     0x00 /* 1 x gain RGBC Gain Value */
-#define TCS37727_CONTROL_AGAIN_4     0x01 /* 4 x gain RGBC Gain Value */
-#define TCS37727_CONTROL_AGAIN_16    0x02 /* 16 x gain RGBC Gain Value */
-#define TCS37727_CONTROL_AGAIN_60    0x03 /* 60 x gain RGBC Gain Value */
-#define TCS37727_CONTROL_AGAIN_MASK  0x03 /* AGAIN Mask */
-
-/* TCS37727 ATIME register values */
-#define TCS37727_ATIME_MIN 2400   /* 2.4ms integr. time, max count 1024 */
-#define TCS37727_ATIME_MAX 614000 /* 614ms integr. time, max count 0xffff */
-
-#define TCS37727_ATIME_TO_REG(val) (256 - (uint8_t)((val) / 2400))
-#define TCS37727_ATIME_TO_US(reg)  ((256 - (uint8_t)(reg)) * 2400)
-
-/* Coefficients for Lux and CT Equations (DN40) */
-/* Coefficients in integer format, multiplied by 1000 */
-#define DGF_IF        310
-#define R_COEF_IF     136
-#define G_COEF_IF    1000
-#define B_COEF_IF    -444
-#define CT_COEF_IF   3810
-#define CT_OFFSET_IF 1391
-
-namespace upm {
-
-typedef struct {
-    uint32_t red;           /**< IR compensated channels red */
-    uint32_t green;         /**< IR compensated channels green */
-    uint32_t blue;          /**< IR compensated channels blue */
-    uint32_t clear;         /**< channels clear */
-    uint32_t lux;           /**< Lux */
-    uint32_t ct;            /**< Color temperature */
-} tcs37727_data_t;
-
-/**
- * @brief TCS37727 Color Light-To-Digital Converter
- * @defgroup tcs37727 libupm-tcs37727
- * @ingroup ams i2c color
- */
-
-/**
- * @library tcs37727
- * @sensor tcs37727
- * @comname TCS37727 Color Light-To-Digital Converter
- * @type color
- * @man ams
- * @web http://ams.com/eng/Products/Light-Sensors
- * @con i2c
- *
- * @brief API for the TCS37727 Color Light-To-Digital Converter
- *
- * Description in web-link above:
- * The TCS3772 device family provides red, green, blue, and clear (RGBC) light
- * sensing and, when coupled with an external IR LED, proximity detection.
- * These devices detect light intensity under a variety of lighting conditions
- * and through a variety of attenuation materials, including dark glass. The
- * proximity detection feature allows a large dynamic range of operation for
- * accurate short distance detection, such as in a cell phone, for detecting
- * when the user positions the phone close to their ear. An internal state
- * machine provides the ability to put the device into a low power state in
- * between proximity and RGBC measurements providing very low average power
- * consumption.
- *
- * @snippet tcs37727.cxx Interesting
- */
-class TCS37727 {
-    public:
-        /**
-         *
-         * Instantiates an TCS37727 object
-         * Settings: Gain 4x, Proximity Detection off
-         *
-         * @param bus Number of the used bus
-         * @param atime_us RGBC integration time
-         * @param devAddr Address of the used I2C device
-         */
-        TCS37727 (int bus, int atime_us=TCS37727_ATIME_DEFAULT,
-                               int devAddr=TCS37727_I2C_ADDRESS);
-
-        /**
-         * Check device_id of sensor
-         *
-         * @return  0 on success
-         *         -1 on error
-         */
-        int checkID(void);
-
-        /**
-         * Set active mode, this enables periodic RGBC measurements
-         *
-         * @return  0 on success
-         *         -1 on error
-         */
-        int setActive(void);
-
-        /**
-         * Set standby mode, this disables periodic RGBC measurements
-         * Also turns off the sensor when proximity measurement is disabled
-         *
-         * @return  0 on success
-         *         -1 on error
-         */
-        int setStandby(void);
-
-        /**
-         *
-         */
-        uint8_t trimGain(int rawc);
-
-        /**
-         * Read out data of regs and call further function
-         * Also saves converted values to variables
-         *
-         * @return  0 on success
-         *         -1 on error
-         */
-        int sampleData(void);
-
-        /**
-         * Get the calculated channel red color
-         *
-         * @param bSampleData Flag to read sensor
-         * @return The channel red color on success
-         *         999 on error
-         */
-        uint32_t getChannelRed(int bSampleData = 0);
-
-        /**
-         * Get the calculated channel green color
-         *
-         * @param bSampleData Flag to read sensor
-         * @return The channel green color on success
-         *         999 on error
-         */
-        uint32_t getChannelGreen(int bSampleData = 0);
-
-        /**
-         * Get the calculated channel blue color
-         *
-         * @param bSampleData Flag to read sensor
-         * @return The channel blue color on success
-         *         999 on error
-         */
-        uint32_t getChannelBlue(int bSampleData = 0);
-
-        /**
-         * Get the calculated channel clear color
-         *
-         * @param bSampleData Flag to read sensor
-         * @return The channel clear color on success
-         *         999 on error
-         */
-        uint32_t getChannelClear(int bSampleData = 0);
-
-        /**
-         * Get the calculated lux value
-         *
-         * @param bSampleData Flag to read sensor
-         * @return The lux value on success
-         *         999 on error
-         */
-        uint32_t getLux(int bSampleData = 0);
-
-        /**
-         * Get the calculated color temperature
-         *
-         * @param bSampleData Flag to read sensor
-         * @return The color temperature on success
-         *         999 on error
-         */
-        uint32_t getColorTemperature(int bSampleData = 0);
-
-        /**
-         * Get calculated sensor values
-         *
-         * @param data Calculated sensor values
-         * @param bSampleData Flag to read sensor
-         * @return  0 on success
-         *         -1 on error
-         */
-        int getData(tcs37727_data_t* data, int bSampleData = 0);
-
-    private:
-
-        std::string m_name;
-
-        int m_controlAddr;
-        int m_bus;
-        mraa::I2c m_i2ControlCtx;
-
-        int s_atime_us;              /* atime value conveted to microseconds */
-        int s_again;                 /* amount of gain */
-
-        tcs37727_data_t s_data[1];
-    };
-
-}
diff --git a/src/tcs37727/tcs37727.json b/src/tcs37727/tcs37727.json
deleted file mode 100644
index 434c6d7..0000000
--- a/src/tcs37727/tcs37727.json
+++ /dev/null
@@ -1,40 +0,0 @@
-{
-    "Library": "tcs37727",
-    "Description": "AMS TCS37727 Color Light-To-Digital Converter Library",
-    "Sensor Class": {
-        "TCS37727": {
-            "Name": "API for the AMS TCS37727 Color Light-To-Digital Converter",
-            "Description": "This is the UPM Module for the AMS TCS37727 Color Light-To-Digital Converter. The TCS3772 device family provides red, green, blue, and clear (RGBC) light sensing and, when coupled with an external IR LED, proximity detection. These devices detect light intensity under a variety of lighting conditions and through a variety of attenuation materials, including dark glass. The proximity detection feature allows a large dynamic range of operation for accurate short distance detection, such as in a cell phone, for detecting when the user positions the phone close to their ear. An internal state machine provides the ability to put the device into a low power state in between proximity and RGBC measurements providing very low average power consumption.",
-            "Aliases": ["tcs37727"],
-            "Categories": ["color", "light"],
-            "Connections": ["i2c"],
-            "Project Type": ["industrial", "commercial"],
-            "Manufacturers": ["AMS"],
-            "Examples": {
-                "Python": ["tcs37727.py"],
-                "C++": ["tcs37727.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 2.7,
-                    "max": 3.6
-                },
-                "Supply Current": {
-                    "unit": "uA",
-                    "min" : 2.5,
-                    "max" : 330
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -30,
-                    "max": 70
-                }
-            },
-            "Urls": {
-                "Product Pages": ["http://ams.com/eng/Products/Light-Sensors"],
-                "Datasheets": ["http://ams.com/eng/content/download/291143/1065677/file/TCS3772_DS000175_2-00.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/teams/CMakeLists.txt b/src/teams/CMakeLists.txt
deleted file mode 100644
index c469a92..0000000
--- a/src/teams/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "teams")
-set (libdescription "Veris TEAMS Temperature Transmitter")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/teams/teams.cxx b/src/teams/teams.cxx
deleted file mode 100644
index e8e8fbc..0000000
--- a/src/teams/teams.cxx
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-
-#include "teams.hpp"
-
-using namespace upm;
-using namespace std;
-
-// for current loop reads that seems a little noisy, we average over
-// several aio reads.
-static const int maxSamples = 50;
-
-// conversion from celsius to fahrenheit
-
-static float c2f(float c)
-{
-  return (c * (9.0 / 5.0) + 32.0);
-}
-
-
-TEAMS::TEAMS(int tPin, float rResistor, float aref) :
-  m_aioTemp(tPin)
-{
-  if (rResistor < 0.0)
-    {
-      throw std::out_of_range(std::string(__FUNCTION__) +
-                              ": rResistor must be >= 0.0");
-    }
-
-  m_aResTemp = (1 << m_aioTemp.getBit());
-
-  m_temperature = 0.0;
-
-  m_aref = aref;
-  m_rResistor = rResistor;
-  m_connected = false;
-
-  // this will only be non-zero when using a direct 4-20ma interface
-  // like libelium
-  m_rawMilliamps = 0.0;
-
-  m_offset = 0.0;
-}
-
-TEAMS::~TEAMS()
-{
-}
-
-void TEAMS::update()
-{
-  float milliamps = 0.0;
-
-  int val = average(maxSamples);
-  float volts = (float(val) * (m_aref / m_aResTemp));
-
-  // valid temp range is 25.0 (35C - 10C), current loop range is 16ma
-  // (20ma - 4ma)
-  if (m_rResistor)
-    {
-      // direct 4-20 current loop interface
-      milliamps = (volts / m_rResistor * 1000.0) + m_offset;
-      m_rawMilliamps = milliamps;
-
-      // subtract 0 (4ma) value
-      milliamps -= 4.0;
-      if (milliamps < 0.0) // not connected
-        {
-          milliamps = 0.0;
-          m_connected = false;
-        }
-      else
-        m_connected = true;
-
-      m_temperature = (milliamps * (25.0 / 16.0)) + 10.0;
-    }
-  else
-    {
-      // normal analog read, already scaled to 0-5v, always connected
-      m_temperature = ((volts / m_aref) * 25.0) + 10.0;
-      m_connected = true;
-    }
-}
-
-float TEAMS::getTemperature(bool fahrenheit)
-{
-  if (fahrenheit)
-    return c2f(m_temperature);
-  else
-    return m_temperature;
-}
-
-int TEAMS::average(int samples)
-{
-  if (samples <= 0)
-    samples = 1;
-
-  int avg = 0;
-  for (int i=0; i<samples; i++)
-    avg += m_aioTemp.read();
-
-  return (avg / samples);
-}
diff --git a/src/teams/teams.hpp b/src/teams/teams.hpp
deleted file mode 100644
index cd31dd6..0000000
--- a/src/teams/teams.hpp
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <iostream>
-
-#include <mraa/aio.hpp>
-
-// Unlikey to be changable
-#define TEAMS_DEFAULT_AREF 5.0
-
-namespace upm {
-    /**
-     * @brief Veris TEAMS Temperature Transmitter
-     * @defgroup teams libupm-teams
-     * @ingroup veris analog temp
-     */
-
-    /**
-     * @library teams
-     * @sensor teams
-     * @comname Veris TEAMS Temperature Transmitter
-     * @type temp
-     * @man veris
-     * @con analog
-     * @web http://www.veris.com/Item/TEAMS.aspx
-     *
-     * @brief API for the Veris TEAMS Temperature Transmitter
-     *
-     * The Veris TEAMS temperature sensor provides it's output via a
-     * 4-20ma current loop.  The supported temperature range is 10C to
-     * 35C.
-     *
-     * This sensor was developed with a Cooking Hacks (Libelium)
-     * 4-channel 4-20ma Arduino interface shield.  For this interface,
-     * the receiver resistance (rResistor) was specified as 165.0
-     * ohms.
-     *
-     * When using a 4-20ma current loop interface which scales the
-     * sensors' values to a 0-5vdc range, you can supply 0.0 as the
-     * rResistor value in the constructor (default), and it will act
-     * just like a normal analog input.
-     *
-     * @snippet teams.cxx Interesting
-     */
-
-  class TEAMS {
-  public:
-
-    /**
-     * TEAMS object constructor
-     *
-     * @param tPin Analog pin to use for temperature.
-     * @param rResistor The receiver resistance in ohms, when using a
-     * 4-20ma current loop interface.  When specified, this value will
-     * be used in computing the current based on the voltage read when
-     * scaling the return values.  Default is 0.0, for standard
-     * scaling based on voltage output rather than current (4-20ma
-     * mode).
-     * @param aref The analog reference voltage, default 5.0
-     */
-    TEAMS(int tPin, float rResistor=0.0, float aref=TEAMS_DEFAULT_AREF);
-
-    /**
-     * TEAMS object destructor
-     */
-    ~TEAMS();
-
-    /**
-     * Read current values from the sensor and update internal stored
-     * values.  This method must be called prior to querying any
-     * values, such as temperature.
-     */
-    void update();
-
-    /**
-     * Get the current temperature.  update() must have been called
-     * prior to calling this method.
-     *
-     * @param fahrenheit true to return the temperature in degrees
-     * fahrenheit, false to return the temperature in degrees celsius.
-     * The default is false (degrees Celsius).
-     * @return The last temperature reading in Celsius or Fahrenheit
-     */
-    float getTemperature(bool fahrenheit=false);
-
-    /**
-     * When using a direct 4-20ma interface (rResistor supplied in the
-     * constructor is >0.0), this function will return false when the
-     * computed milliamps falls below 4ma, indicating that the sensor
-     * is not connected.  If rResistor was specified as 0.0 in the
-     * constructor, this function will always return true.
-     *
-     * @return true if the sensor is connected, false otherwise.
-     */
-    bool isConnected()
-    {
-      return m_connected;
-    };
-
-    /**
-     * When using a direct 4-20ma interface (rResistor supplied in the
-     * constructor is >0.0), this function will return the computed
-     * milliamps (after the offset has been applied).  If rResistor was
-     * specified as 0.0 in the constructor, this function will always
-     * return 0.0.
-     *
-     * @return The last measured current in milliamps after any offset
-     * has been applied.
-     */
-    float getRawMilliamps()
-    {
-      return m_rawMilliamps;
-    };
-
-    /**
-     * Specify an offset in milliamps to be applied to the computed
-     * current prior to scaling and conversion.  This can be used to
-     * 'adjust' the computed value.  If rResistor was specified as 0.0
-     * in the constructor, this function will have no effect.
-     *
-     * @param offset a positive or negative value that will be applied
-     * to the computed current measured.
-     */
-    void setOffsetMilliamps(float offset)
-    {
-      m_offset = offset;
-    };
-
-  protected:
-    mraa::Aio m_aioTemp;
-
-  private:
-    float m_aref;
-    float m_rResistor;
-    int m_aResTemp;
-
-    // for a 4-20 ma loop
-    bool m_connected;
-    float m_rawMilliamps;
-
-    // in Celsius
-    float m_temperature;
-
-    // in case an offset should be applied to the cumputed current
-    float m_offset;
-
-    int average(int samples);
-  };
-}
-
-
diff --git a/src/teams/teams.i b/src/teams/teams.i
deleted file mode 100644
index a3cfc2f..0000000
--- a/src/teams/teams.i
+++ /dev/null
@@ -1,14 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_teams)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "teams.hpp"
-%}
-%include "teams.hpp"
-/* END Common SWIG syntax */
diff --git a/src/teams/teams.json b/src/teams/teams.json
deleted file mode 100644
index 7318624..0000000
--- a/src/teams/teams.json
+++ /dev/null
@@ -1,47 +0,0 @@
-{
-    "Library": "teams",
-    "Description": "Veris TEAMS Temperature Transmitter Library",
-    "Sensor Class": {
-        "TEAMS": {
-            "Name": "API for the Veris TEAMS Temperature Transmitter",
-            "Description": "This is the UPM Module for the Veris TEAMS Temperature Transmitter. The Veris TEAMS temperature sensor provides it's output via a 4-20ma current loop. The supported temperature range is 10C to 35C. This sensor was developed with a Cooking Hacks (Libelium) 4-channel 4-20ma Arduino interface shield.  For this interface, the receiver resistance (rResistor) was specified as 165.0 ohms. When using a 4-20ma current loop interface which scales the sensors' values to a 0-5vdc range, you can supply 0.0 as the rResistor value in the constructor (default), and it will act just like a normal analog input.",
-            "Aliases": ["teams"],
-            "Categories": ["temperature"],
-            "Connections": ["ainput"],
-            "Project Type": ["industrial", "commercial"],
-            "Manufacturers": ["Veris"],
-            "Examples": {
-                "Java": ["TEAMS_Example.java"],
-                "Python": ["teams.py"],
-                "Node.js": ["teams.js"],
-                "C++": ["teams.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 5,
-                    "max": 30
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "min" : 4,
-                    "max" : 20
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -25,
-                    "max": 105
-                },
-                "Accuracy": {
-                    "unit": "°C",
-                    "min" : -0.3,
-                    "max" : 0.3
-                }
-            },
-            "Urls": {
-                "Product Pages": ["http://www.veris.com/Item/TEAMS.aspx"],
-                "Datasheets": ["http://www.veris.com/docs/Datasheets/TW_TE_d0117.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/temperature/CMakeLists.txt b/src/temperature/CMakeLists.txt
deleted file mode 100644
index 6172b42..0000000
--- a/src/temperature/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-upm_mixed_module_init (NAME temperature
-    DESCRIPTION "Analog Temperature Sensor"
-    C_HDR temperature.h
-    C_SRC temperature.c
-    CPP_HDR temperature.hpp
-    CPP_SRC temperature.cxx
-    FTI_SRC temperature_fti.c
-    REQUIRES mraa)
diff --git a/src/temperature/temperature.c b/src/temperature/temperature.c
deleted file mode 100644
index 19e1a78..0000000
--- a/src/temperature/temperature.c
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Author: Sisinty Sasmita Patra <sisinty.s.patra@intel.com>
- *
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-
-#include <stdio.h>
-#include <stdlib.h>
-
-#include "temperature.h"
-#include "upm.h"
-
-temperature_context temperature_init(int pin)
-{
-    temperature_context dev =
-      (temperature_context)malloc(sizeof(struct _temperature_context));
-
-    if (dev == NULL) return NULL;
-
-    dev->aio = mraa_aio_init(pin);
-    if(dev->aio == NULL)
-    {
-        free(dev);
-        return NULL;
-    }
-
-    dev->m_aRes = (1 << mraa_aio_get_bit(dev->aio));
-
-    return dev;
-}
-
-void temperature_close(temperature_context dev)
-{
-    mraa_aio_close(dev->aio);
-    free(dev);
-}
-
-upm_result_t temperature_get_value(temperature_context dev,
-                                   float* tempval)
-{
-    float val = 0.0;
-    val = (float)mraa_aio_read(dev->aio);
-
-    if (val == -1.0)
-    {
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // From old C++ UPM code, needs rework!!!
-    float r = ((float)dev->m_aRes - val) * 10000.0 / val;
-    float t = 1.0 / (log(r / 10000.0) / 3975.0 + 1.0 / 298.15) -273.15;
-
-    // Celsius
-    *tempval = t;
-
-    return UPM_SUCCESS;
-}
diff --git a/src/temperature/temperature.cxx b/src/temperature/temperature.cxx
deleted file mode 100644
index 0938a23..0000000
--- a/src/temperature/temperature.cxx
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Authors: Brendan Le Foll <brendan.le.foll@intel.com>
- *          Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- *          Sarah Knepper <sarah.knepper@intel.com>
- * Copyright (c) 2014 - 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "temperature.hpp"
-#include "math.h"
-
-using namespace std;
-using namespace upm;
-
-Temperature::Temperature(unsigned int pin, float scale, int r0, int b)
-{
-    if ( !(m_aio = mraa_aio_init(pin)) ) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_aio_init() failed, invalid pin?");
-        return;
-    }
-    m_scale = scale;
-    m_r0 = r0;
-    m_b = b;
-}
-
-Temperature::~Temperature()
-{
-    mraa_aio_close(m_aio);
-}
-
-int Temperature::value ()
-{
-    float a = (float) mraa_aio_read(m_aio);
-    if (a == -1.0) return -1;
-    // Apply scale factor after error check
-    a *= m_scale;
-    float r = (float)(1023.0-a)*(float)m_r0/a;
-    float t = 1.0/(log(r/(float)m_r0)/(float)m_b + 1.0/298.15)-273.15;
-    return (int) round(t);
-}
-
-float Temperature::raw_value()
-{
-    return (float) mraa_aio_read(m_aio);
-}
diff --git a/src/temperature/temperature.h b/src/temperature/temperature.h
deleted file mode 100644
index b95ec6c..0000000
--- a/src/temperature/temperature.h
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Author: Sisinty Sasmita Patra <sisinty.s.patra@intel.com>
- *
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef TEMPERATURE_H_
-#define TEMPERATURE_H_
-
-#include <stdlib.h>
-#include <unistd.h>
-
-#include "upm.h"
-#include "mraa/aio.h"
-
-/**
- * @file temperature.h
- * @library temperature
- * @brief C API for Analog Temperature (NTC) Sensors
- *
- * @include temperature.c
- */
-
-/**
- * driver context
- */
-typedef struct _temperature_context {
-    mraa_aio_context aio;
-    int16_t m_aRes;
-} *temperature_context;
-
-/**
- * Analog temperature sensor initialization function
- *
- * @param pin analog pin to use
- * @return sensor context
- */
-temperature_context temperature_init(int pin);
-
-/**
- * Analog temperature sensor destructor
- *
- * @param dev sensor context pointer
- */
-void temperature_close(temperature_context dev);
-
-/**
- * Gets the temperature in Celsius from the sensor
- *
- * @param dev sensor context pointer
- * @param tempval temperature value in Celsius
- * @return result of the operation
- */
-upm_result_t temperature_get_value(temperature_context dev,
-                                   float* tempval);
-
-#endif /* TEMPERATURE_H_ */
diff --git a/src/temperature/temperature.hpp b/src/temperature/temperature.hpp
deleted file mode 100644
index 17a3a4d..0000000
--- a/src/temperature/temperature.hpp
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Authors: Brendan Le Foll <brendan.le.foll@intel.com>
- *          Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- *          Sarah Knepper <sarah.knepper@intel.com>
- * Copyright (c) 2014 - 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <string>
-#include <mraa/aio.hpp>
-
-namespace upm {
-/**
- * @brief NTC Temperature Sensors Library
- * @defgroup temperature libupm-temperature
- * @ingroup seeed analog temp gsk
- */
-/**
- * @library temperature
- * @sensor temperature
- * @comname Analog Temperature Sensor
- * @altname Grove Temperature Sensor
- * @type temp
- * @man seeed
- * @web http://wiki.seeed.cc/Grove-Temperature_Sensor_V1.2/
- * @con analog
- * @kit gsk
- *
- * @brief API for NTC Temperature Sensors
- *
- * Basic UPM module for analog temperature sensors. These sensors use a NTC
- * thermistor to measure ambient temperature. This driver was developed using
- * the Grove Temperature Sensor. The conversion formula has been updated
- * to work with versions 1.1 and 1.2 of the sensor. For the older v1.0
- * sensor you will have to specify R0 and B values when initializing the
- * device. The range of this sensor is -40 to 125 C and accuracy is +/- 1.5 C.
- *
- * @image html temp.jpg
- * @snippet temperature.cxx Interesting
- */
-class Temperature {
-    public:
-        /**
-         * Analog temperature sensor constructor
-         *
-         * @param pin Analog pin to use
-         * @param scale Scaling factor for raw analog value from the ADC,
-         * useful for mixed 3.3V/5V boards, default 1.0
-         * @param r0 zero power resistance, this is 100K (default) for
-         * v1.1-v1.2 and 10K for v1.0 of the sensor
-         * @param b thermistor nominal B constant, this is 4275 (default) for
-         * v1.1-v1.2 and 3975 for v1.0 of the sensor
-         */
-        Temperature(unsigned int pin, float scale = 1.0, int r0 = 100000, int b = 4275);
-        /**
-         * Analog temperature sensor destructor
-         */
-        ~Temperature();
-        /**
-         * Gets the raw value from the AIO pin
-         *
-         * @return Raw value from the ADC
-         */
-        float raw_value();
-        /** Provided for compatibility with old grove base class
-         *
-         * @return Sensor name
-         */
-        std::string name()
-        {
-            return "Temperature sensor";
-        }
-        /**
-         * Gets the temperature in Celsius from the sensor
-         *
-         * @return Normalized temperature in Celsius
-         */
-        int value();
-    private:
-        mraa_aio_context m_aio;
-        float m_scale;
-        int m_r0;
-        int m_b;
-
-};
-}
diff --git a/src/temperature/temperature.json b/src/temperature/temperature.json
deleted file mode 100644
index 6826934..0000000
--- a/src/temperature/temperature.json
+++ /dev/null
@@ -1,39 +0,0 @@
-{
-    "Library": "temperature",
-    "Description": "Temperature sensor library",
-    "Sensor Class":
-    {
-        "Temperature":
-        {
-            "Name": "Analog Temperature Sensor",
-            "Description": "Basic UPM module for analog temperature sensors. These sensors use a NTC thermistor to measure ambient temperature. This driver was developed using the Grove Temperature Sensor. The conversion formula has been updated to work with versions 1.1 and 1.2 of the sensor. For the older v1.0 sensor you will have to specify R0 and B values when initializing the device. The range of this sensor is -40 to 125 C and accuracy is +/- 1.5 C.",
-            "Aliases": ["Grove - Temperature Sensor"],
-            "Categories": ["temp"],
-            "Connections": ["analog"],
-            "Project Type": ["prototyping", "industrial"],
-            "Manufacturers": ["seeed", "dfrobot", "sparkfun", "adafruit", "generic"],
-            "Kits": ["gsk"],
-            "Image": "temp.jpg",
-            "Examples":
-            {
-                "Java": ["Temperature_Example.java"],
-                "Python": ["temperature.py"],
-                "Node.js": ["temperature.js"],
-                "C++": ["temperature.cxx"]
-            },
-            "Platforms":
-            {
-                "Arduino 101":
-                {
-                    "Notes": ["Will need to adjust ADC scale when used with Grove Base Shield (see API documentation)."]
-                }
-            },
-            "Urls" :
-            {
-                "Product Pages": ["http://wiki.seeed.cc/Grove-Temperature_Sensor_V1.2/"],
-                "Datasheets": ["https://github.com/SeeedDocument/Grove-Temperature_Sensor_V1.2/raw/master/res/NCP18WF104F03RC.pdf"],
-                "Schematics": ["https://easyeda.com/Seeed/Grove_Temperature_sensor_v1_2-ed433e462f14455e9aa38ae1a06e4680"]
-            }
-        }
-    }
-}
diff --git a/src/temperature/temperature_fti.c b/src/temperature/temperature_fti.c
deleted file mode 100644
index 19ddd52..0000000
--- a/src/temperature/temperature_fti.c
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Author: Sisinty Sasmita Patra <sisinty.s.patra@intel.com>
- *
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-
-#include<stdio.h>
-#include <stdlib.h>
-
-#include "temperature.h"
-#include "upm_fti.h"
-#include "fti/upm_sensor.h"
-
-/** 
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_temperature_name[] = "Temperature Sensor";
-const char upm_temperature_description[] = "Analog Temperature Sensor";
-const upm_protocol_t upm_temperature_protocol[] = {UPM_ANALOG};
-const upm_sensor_t upm_temperature_category[] = {UPM_TEMPERATURE};
-
-// forward declarations
-const upm_sensor_descriptor_t upm_temperature_get_descriptor();
-const void* upm_temperature_get_ft(upm_sensor_t sensor_type);
-upm_result_t upm_temperature_get_value_temperature(void* dev, float* tempval,
-                                                   upm_temperature_u unit);
-void* upm_temperature_init_name();
-void upm_temperature_close(void* dev);
-
-const upm_sensor_descriptor_t upm_temperature_get_descriptor() {
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_temperature_name;
-    usd.description = upm_temperature_description;
-    usd.protocol_size = 1;
-    usd.protocol = upm_temperature_protocol;
-    usd.category_size = 1;
-    usd.category = upm_temperature_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = &upm_temperature_init_name,
-    .upm_sensor_close = &upm_temperature_close,
-    .upm_sensor_get_descriptor = &upm_temperature_get_descriptor
-};
-
-static const upm_temperature_ft tft =
-{
-    .upm_temperature_get_value = &upm_temperature_get_value_temperature
-};
-
-const void* upm_temperature_get_ft(upm_sensor_t sensor_type) {
-    if(sensor_type == UPM_SENSOR) {
-        return &ft;
-    }
-    if(sensor_type == UPM_TEMPERATURE) {
-        return &tft;
-    }
-    return NULL;
-}
-
-void* upm_temperature_init_name(){
-    return NULL;
-}
-
-void upm_temperature_close(void* dev)
-{
-    temperature_close((temperature_context)dev);
-}
-
-upm_result_t upm_temperature_get_value_temperature(void* dev, float* tempval,
-                                                   upm_temperature_u unit)
-{
-    float temp = 0.0;
-    upm_result_t rv = temperature_get_value((temperature_context)dev, &temp);
-
-    if (rv != UPM_SUCCESS)
-        return rv;
-
-    switch (unit)
-        {
-        case CELSIUS:
-            *tempval = temp;
-            return UPM_SUCCESS;
-
-        case KELVIN:
-            *tempval = temp + 273.15;
-            return UPM_SUCCESS;
-
-        case FAHRENHEIT:
-            *tempval = temp * (9.0/5.0) + 32.0;
-            return UPM_SUCCESS;
-        }
-
-    return UPM_ERROR_INVALID_PARAMETER;
-}
diff --git a/src/tex00/CMakeLists.txt b/src/tex00/CMakeLists.txt
deleted file mode 100644
index 57d3e12..0000000
--- a/src/tex00/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "tex00")
-set (libdescription "Veris TEX00 Temperature Sensors")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/tex00/tex00.cxx b/src/tex00/tex00.cxx
deleted file mode 100644
index 95e31c6..0000000
--- a/src/tex00/tex00.cxx
+++ /dev/null
@@ -1,693 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <math.h>
-#include "tex00.hpp"
-
-using namespace upm;
-using namespace std;
-
-// we average over several aio reads.
-static const int maxSamples = 10;
-
-// conversion from celsius to fahrenheit
-
-static float c2f(float c)
-{
-  return (c * (9.0 / 5.0) + 32.0);
-}
-
-
-TEX00::TEX00(int tPin, float balanceResistor, SENSOR_TYPES_T stype, 
-             float aref) :
-  m_aioTemp(tPin)
-{
-  m_aResTemp = (1 << m_aioTemp.getBit());
-
-  m_temperature = 0.0;
-  m_outOfRange = false;
-
-  m_aref = aref;
-  m_balanceResistor = balanceResistor;
-
-  // set default to NTC, however per-sensor init functions should set
-  // properly for the relevant sensor
-  m_isNTC = true;
-  
-  switch (stype)
-    {
-    case STYPE_THERMISTOR_TED:
-      initThermistorTED();
-      break;
-
-    case STYPE_THERMISTOR_TEB:
-      initThermistorTEB();
-      break;
-
-    case STYPE_THERMISTOR_TEC:
-      initThermistorTEC();
-      break;
-
-    case STYPE_THERMISTOR_TEI:
-      initThermistorTEI();
-      break;
-
-    case STYPE_THERMISTOR_TEE:
-      initThermistorTEE();
-      break;
-
-    case STYPE_THERMISTOR_TEF:
-      initThermistorTEF();
-      break;
-
-    case STYPE_THERMISTOR_TEH:
-      initThermistorTEH();
-      break;
-
-    case STYPE_THERMISTOR_TEJ:
-      initThermistorTEJ();
-      break;
-
-    case STYPE_THERMISTOR_TES:
-      initThermistorTES();
-      break;
-
-    case STYPE_THERMISTOR_TER:
-      initThermistorTER();
-      break;
-
-    case STYPE_THERMISTOR_TEM:
-      initThermistorTEM();
-      break;
-
-    case STYPE_THERMISTOR_TEU:
-      initThermistorTEU();
-      break;
-
-    case STYPE_THERMISTOR_TET:
-      initThermistorTET();
-      break;
-
-    default:
-      throw std::logic_error(std::string(__FUNCTION__) +
-                             ": internal error: invalid stype");
-    }
-}
-
-TEX00::~TEX00()
-{
-}
-
-void TEX00::update()
-{
-  int val = average(maxSamples);
-
-  // now determine the resistance of the sensor (this is a voltage divider)
-  float resistance = m_balanceResistor / 
-    ((float(m_aResTemp - 1) / float(val)) - 1.0);
-  
-  //  cerr << "Val = " << val << ", resistance = " << resistance << endl;
-
-  m_temperature = thermistor(resistance);
-}
-
-float TEX00::getTemperature(bool fahrenheit)
-{
-  if (fahrenheit)
-    return c2f(m_temperature);
-  else
-    return m_temperature;
-}
-
-int TEX00::average(int samples)
-{
-  if (samples <= 0)
-    samples = 1;
-  
-  int avg = 0;
-  for (int i=0; i<samples; i++)
-    avg += m_aioTemp.read();
-  
-  return (avg / samples);
-}
-
-float TEX00::thermistor(float ohms)
-{
-  // sanity check
-  if (m_tempVector.empty())
-    {
-      throw std::logic_error(std::string(__FUNCTION__) +
-                             ": internal error: temperature table is empty");
-    }
-
-  int found = -1;
-  int next = -1;
-  
-  if (m_isNTC)
-    {
-      // reverse search
-      for (int i=m_tempVector.size() - 1; i>=0; i--)
-        if (ohms < m_tempVector[i].ohms)
-          {
-            found = i;
-            next = found + 1;
-            break;
-          }
-    }
-  else
-    {
-      // PTC
-      for (size_t i=0; i<m_tempVector.size(); i++)
-        if (ohms < m_tempVector[i].ohms)
-          {
-            found = i;
-            next = found - 1;
-            break;
-          }
-    }
-
-  if (found < 0 || next < 0 || 
-      found >= static_cast<int>(m_tempVector.size()) ||
-      next >= static_cast<int>(m_tempVector.size()))
-    {
-      m_outOfRange = true;
-      // return last measured temperature
-      return m_temperature;
-    }
-  else
-    m_outOfRange = false;
-  
-  // calculate the percentages of ohms and temp
-  float diffO = m_tempVector[found].ohms - m_tempVector[next].ohms;
-  ohms -= m_tempVector[next].ohms;
-  
-  diffO = ohms / diffO;
-  
-  float diffT;
-  if (m_isNTC)
-    diffT = m_tempVector[next].temp - m_tempVector[found].temp;
-  else
-    diffT = m_tempVector[found].temp - m_tempVector[next].temp;
-
-  // compute offset
-  float tempOffset = fabs(diffT * diffO);
-
-  // apply according to NTC or PTC
-  if (m_isNTC)
-    return m_tempVector[next].temp - tempOffset;
-  else
-    return m_tempVector[next].temp + tempOffset;
-}
-
-float TEX00::getTemperatureRangeMin()
-{
-  if (m_tempVector.empty())
-    {
-      throw std::logic_error(std::string(__FUNCTION__) +
-                             ": internal error: temperature table is empty");
-    }
-
-  return m_tempVector[0].temp;
-}
-
-float TEX00::getTemperatureRangeMax()
-{
-  if (m_tempVector.empty())
-    {
-      throw std::logic_error(std::string(__FUNCTION__) +
-                             ": internal error: temperature table is empty");
-    }
-
-  return m_tempVector[m_tempVector.size() - 1].temp;
-}
-
-
-void TEX00::initThermistorTED()
-{
-  // this is an NTC type thermistor
-  m_isNTC = true;
-
-  // This data comes from the Veris TW_TE_d0116.pdf datasheet for the
-  // "D" (10K type 2) column
-
-  // clear and initialize the vector, ordered from lowest to highest
-  // temperature
-  m_tempVector.clear();
-
-  //                               ohms      temperature (C)
-  m_tempVector.push_back(tempEntry(692700,   -50));
-  m_tempVector.push_back(tempEntry(344700,   -40));
-  m_tempVector.push_back(tempEntry(180100,   -30));
-  m_tempVector.push_back(tempEntry(98320,    -20));
-  m_tempVector.push_back(tempEntry(55790,    -10));
-  m_tempVector.push_back(tempEntry(32770,    0));
-  m_tempVector.push_back(tempEntry(19930,    10));
-  m_tempVector.push_back(tempEntry(12500,    20));
-  m_tempVector.push_back(tempEntry(10000,    25));
-  m_tempVector.push_back(tempEntry(8055,     30));
-  m_tempVector.push_back(tempEntry(5323,     40));
-  m_tempVector.push_back(tempEntry(3599,     50));
-  m_tempVector.push_back(tempEntry(2486,     60));
-  m_tempVector.push_back(tempEntry(1753,     70));
-  m_tempVector.push_back(tempEntry(1258,     80));
-  m_tempVector.push_back(tempEntry(919,      90));
-  m_tempVector.push_back(tempEntry(682,      100));
-  m_tempVector.push_back(tempEntry(513,      110));
-  m_tempVector.push_back(tempEntry(392,      120));
-  m_tempVector.push_back(tempEntry(303,      130));
-}
-
-void TEX00::initThermistorTEB()
-{
-  // this is a PTC type thermistor
-  m_isNTC = false;
-
-  // This data comes from the Veris TW_TE_d0116.pdf datasheet for the
-  // "B" (100 Ohm) column
-
-  // clear and initialize the vector, ordered from lowest to highest
-  // temperature
-  m_tempVector.clear();
-
-  //                               ohms        temperature (C)
-  m_tempVector.push_back(tempEntry(80.306,     -50));
-  m_tempVector.push_back(tempEntry(84.271,     -40));
-  m_tempVector.push_back(tempEntry(88.222,     -30));
-  m_tempVector.push_back(tempEntry(92.160,     -20));
-  m_tempVector.push_back(tempEntry(96.086,     -10));
-  m_tempVector.push_back(tempEntry(100,        0));
-  m_tempVector.push_back(tempEntry(103.903,    10));
-  m_tempVector.push_back(tempEntry(107.794,    20));
-  m_tempVector.push_back(tempEntry(109.735,    25));
-  m_tempVector.push_back(tempEntry(111.673,    30));
-  m_tempVector.push_back(tempEntry(115.541,    40));
-  m_tempVector.push_back(tempEntry(119.397,    50));
-  m_tempVector.push_back(tempEntry(123.242,    60));
-  m_tempVector.push_back(tempEntry(127.075,    70));
-  m_tempVector.push_back(tempEntry(130.897,    80));
-  m_tempVector.push_back(tempEntry(134.707,    90));
-  m_tempVector.push_back(tempEntry(138.506,    100));
-  m_tempVector.push_back(tempEntry(142.293,    110));
-  m_tempVector.push_back(tempEntry(146.068,    120));
-  m_tempVector.push_back(tempEntry(149.332,    130));
-}
-
-void TEX00::initThermistorTEC()
-{
-  // this is a PTC type thermistor
-  m_isNTC = false;
-
-  // This data comes from the Veris TW_TE_d0116.pdf datasheet for the
-  // "C" (1000 Ohm) column
-
-  // clear and initialize the vector, ordered from lowest to highest
-  // temperature
-  m_tempVector.clear();
-
-  //                               ohms        temperature (C)
-  m_tempVector.push_back(tempEntry(803.06,     -50));
-  m_tempVector.push_back(tempEntry(842.71,     -40));
-  m_tempVector.push_back(tempEntry(882.22,     -30));
-  m_tempVector.push_back(tempEntry(921.60,     -20));
-  m_tempVector.push_back(tempEntry(960.86,     -10));
-  m_tempVector.push_back(tempEntry(1000,       0));
-  m_tempVector.push_back(tempEntry(1039.03,    10));
-  m_tempVector.push_back(tempEntry(1077.94,    20));
-  m_tempVector.push_back(tempEntry(1097.35,    25));
-  m_tempVector.push_back(tempEntry(1116.73,    30));
-  m_tempVector.push_back(tempEntry(1155.41,    40));
-  m_tempVector.push_back(tempEntry(1193.97,    50));
-  m_tempVector.push_back(tempEntry(1232.42,    60));
-  m_tempVector.push_back(tempEntry(1270.75,    70));
-  m_tempVector.push_back(tempEntry(1308.97,    80));
-  m_tempVector.push_back(tempEntry(1347.07,    90));
-  m_tempVector.push_back(tempEntry(1385.06,    100));
-  m_tempVector.push_back(tempEntry(1422.93,    110));
-  m_tempVector.push_back(tempEntry(1460.68,    120));
-  m_tempVector.push_back(tempEntry(1493.32,    130));
-}
-
-void TEX00::initThermistorTEI()
-{
-  // this is a PTC type thermistor
-  m_isNTC = false;
-
-  // This data comes from the Veris TW_TE_d0116.pdf datasheet for the
-  // "I" (1000 Ohm) column
-
-  // clear and initialize the vector, ordered from lowest to highest
-  // temperature
-  m_tempVector.clear();
-
-  //                               ohms        temperature (C)
-  m_tempVector.push_back(tempEntry(740.46,     -50));
-  m_tempVector.push_back(tempEntry(773.99,     -40));
-  m_tempVector.push_back(tempEntry(806.02,     -30));
-  m_tempVector.push_back(tempEntry(841,        -20));
-  m_tempVector.push_back(tempEntry(877.76,     -10));
-  m_tempVector.push_back(tempEntry(913.66,     0));
-  m_tempVector.push_back(tempEntry(952.25,     10));
-  m_tempVector.push_back(tempEntry(991.82,     20));
-  m_tempVector.push_back(tempEntry(1013.50,    25));
-  m_tempVector.push_back(tempEntry(1035.18,    30));
-  m_tempVector.push_back(tempEntry(1077.68,    40));
-  m_tempVector.push_back(tempEntry(1120.52,    50));
-  m_tempVector.push_back(tempEntry(1166.13,    60));
-  m_tempVector.push_back(tempEntry(1210.75,    70));
-  m_tempVector.push_back(tempEntry(1254.55,    80));
-  m_tempVector.push_back(tempEntry(1301.17,    90));
-  m_tempVector.push_back(tempEntry(1348.38,    100));
-  m_tempVector.push_back(tempEntry(1397.13,    110));
-  m_tempVector.push_back(tempEntry(1447.44,    120));
-  m_tempVector.push_back(tempEntry(1496.28,    130));
-}
-
-void TEX00::initThermistorTEE()
-{
-  // this is an NTC type thermistor
-  m_isNTC = true;
-
-  // This data comes from the Veris TW_TE_d0116.pdf datasheet for the
-  // "E" (2.2k Ohm) column
-
-  // clear and initialize the vector, ordered from lowest to highest
-  // temperature
-  m_tempVector.clear();
-
-  //                               ohms        temperature (C)
-  m_tempVector.push_back(tempEntry(154464,     -50));
-  m_tempVector.push_back(tempEntry(77081,      -40));
-  m_tempVector.push_back(tempEntry(40330,      -30));
-  m_tempVector.push_back(tempEntry(22032,      -20));
-  m_tempVector.push_back(tempEntry(12519,      -10));
-  m_tempVector.push_back(tempEntry(7373,       0));
-  m_tempVector.push_back(tempEntry(4487,       10));
-  m_tempVector.push_back(tempEntry(2814,       20));
-  m_tempVector.push_back(tempEntry(2252,       25));
-  m_tempVector.push_back(tempEntry(1814,       30));
-  m_tempVector.push_back(tempEntry(1199,       40));
-  m_tempVector.push_back(tempEntry(811.5,      50));
-  m_tempVector.push_back(tempEntry(561,        60));
-  m_tempVector.push_back(tempEntry(395.5,      70));
-  m_tempVector.push_back(tempEntry(284,        80));
-  m_tempVector.push_back(tempEntry(207.4,      90));
-  m_tempVector.push_back(tempEntry(153.8,      100));
-  m_tempVector.push_back(tempEntry(115.8,      110));
-  m_tempVector.push_back(tempEntry(88.3,       120));
-  m_tempVector.push_back(tempEntry(68.3,       130));
-}
-
-void TEX00::initThermistorTEF()
-{
-  // this is an NTC type thermistor
-  m_isNTC = true;
-
-  // This data comes from the Veris TW_TE_d0116.pdf datasheet for the
-  // "F" (3k Ohm) column
-
-  // clear and initialize the vector, ordered from lowest to highest
-  // temperature
-  m_tempVector.clear();
-
-  //                               ohms        temperature (C)
-  m_tempVector.push_back(tempEntry(205800,     -50));
-  m_tempVector.push_back(tempEntry(102690,     -40));
-  m_tempVector.push_back(tempEntry(53730,      -30));
-  m_tempVector.push_back(tempEntry(29346,      -20));
-  m_tempVector.push_back(tempEntry(16674,      -10));
-  m_tempVector.push_back(tempEntry(9822,       0));
-  m_tempVector.push_back(tempEntry(5976,       10));
-  m_tempVector.push_back(tempEntry(3750,       20));
-  m_tempVector.push_back(tempEntry(3000,       25));
-  m_tempVector.push_back(tempEntry(2417,       30));
-  m_tempVector.push_back(tempEntry(1598,       40));
-  m_tempVector.push_back(tempEntry(1081,       50));
-  m_tempVector.push_back(tempEntry(747,        60));
-  m_tempVector.push_back(tempEntry(527,        70));
-  m_tempVector.push_back(tempEntry(378,        80));
-}
-
-void TEX00::initThermistorTEH()
-{
-  // this is an NTC type thermistor
-  m_isNTC = true;
-
-  // This data comes from the Veris TW_TE_d0116.pdf datasheet for the
-  // "H" (10k Type 3) column
-
-  // clear and initialize the vector, ordered from lowest to highest
-  // temperature
-  m_tempVector.clear();
-
-  //                               ohms        temperature (C)
-  m_tempVector.push_back(tempEntry(454910,     -50));
-  m_tempVector.push_back(tempEntry(245089,     -40));
-  m_tempVector.push_back(tempEntry(137307,     -30));
-  m_tempVector.push_back(tempEntry(79729,      -20));
-  m_tempVector.push_back(tempEntry(47843,      -10));
-  m_tempVector.push_back(tempEntry(29588,      0));
-  m_tempVector.push_back(tempEntry(18813,      10));
-  m_tempVector.push_back(tempEntry(12272,      20));
-  m_tempVector.push_back(tempEntry(10000,      25));
-  m_tempVector.push_back(tempEntry(8195,       30));
-  m_tempVector.push_back(tempEntry(5593,       40));
-  m_tempVector.push_back(tempEntry(3894,       50));
-  m_tempVector.push_back(tempEntry(2763,       60));
-  m_tempVector.push_back(tempEntry(1994,       70));
-  m_tempVector.push_back(tempEntry(1462,       80));
-  m_tempVector.push_back(tempEntry(1088,       90));
-  m_tempVector.push_back(tempEntry(821,        100));
-  m_tempVector.push_back(tempEntry(628,        110));
-  m_tempVector.push_back(tempEntry(486,        120));
-  m_tempVector.push_back(tempEntry(380,        130));
-}
-
-void TEX00::initThermistorTEJ()
-{
-  // this is an NTC type thermistor
-  m_isNTC = true;
-
-  // This data comes from the Veris TW_TE_d0116.pdf datasheet for the
-  // "J" (10k Dale) column
-
-  // clear and initialize the vector, ordered from lowest to highest
-  // temperature
-  m_tempVector.clear();
-
-  //                               ohms        temperature (C)
-  m_tempVector.push_back(tempEntry(672300,     -50));
-  m_tempVector.push_back(tempEntry(337200,     -40));
-  m_tempVector.push_back(tempEntry(177200,     -30));
-  m_tempVector.push_back(tempEntry(97130,      -20));
-  m_tempVector.push_back(tempEntry(55340,      -10));
-  m_tempVector.push_back(tempEntry(32660,      0));
-  m_tempVector.push_back(tempEntry(19900,      10));
-  m_tempVector.push_back(tempEntry(12490,      20));
-  m_tempVector.push_back(tempEntry(10000,      25));
-  m_tempVector.push_back(tempEntry(8056,       30));
-  m_tempVector.push_back(tempEntry(5326,       40));
-  m_tempVector.push_back(tempEntry(3602,       50));
-  m_tempVector.push_back(tempEntry(2489,       60));
-  m_tempVector.push_back(tempEntry(1753,       70));
-  m_tempVector.push_back(tempEntry(1258,       80));
-  m_tempVector.push_back(tempEntry(917,        90));
-  m_tempVector.push_back(tempEntry(679,        100));
-  m_tempVector.push_back(tempEntry(511,        110));
-  m_tempVector.push_back(tempEntry(389,        120));
-  m_tempVector.push_back(tempEntry(301,        130));
-}
-
-void TEX00::initThermistorTES()
-{
-  // this is an NTC type thermistor
-  m_isNTC = true;
-
-  // This data comes from the Veris TW_TE_d0116.pdf datasheet for the
-  // "S" (10k 3A221) column
-
-  // clear and initialize the vector, ordered from lowest to highest
-  // temperature
-  m_tempVector.clear();
-
-  //                               ohms        temperature (C)
-  m_tempVector.push_back(tempEntry(333562,     -40));
-  m_tempVector.push_back(tempEntry(176081,     -30));
-  m_tempVector.push_back(tempEntry(96807,      -20));
-  m_tempVector.push_back(tempEntry(55252,      -10));
-  m_tempVector.push_back(tempEntry(32639,      0));
-  m_tempVector.push_back(tempEntry(19901,      10));
-  m_tempVector.push_back(tempEntry(12493,      20));
-  m_tempVector.push_back(tempEntry(10000,      25));
-  m_tempVector.push_back(tempEntry(8055,       30));
-  m_tempVector.push_back(tempEntry(5324,       40));
-  m_tempVector.push_back(tempEntry(3600,       50));
-  m_tempVector.push_back(tempEntry(2486,       60));
-  m_tempVector.push_back(tempEntry(1751,       70));
-  m_tempVector.push_back(tempEntry(1255,       80));
-  m_tempVector.push_back(tempEntry(915,        90));
-  m_tempVector.push_back(tempEntry(678,        100));
-  m_tempVector.push_back(tempEntry(509,        110));
-  m_tempVector.push_back(tempEntry(388,        120));
-  m_tempVector.push_back(tempEntry(299,        130));
-}
-
-void TEX00::initThermistorTER()
-{
-  // this is an NTC type thermistor
-  m_isNTC = true;
-
-  // This data comes from the Veris TW_TE_d0116.pdf datasheet for the
-  // "R" (10k "G" US) column
-
-  // clear and initialize the vector, ordered from lowest to highest
-  // temperature
-  m_tempVector.clear();
-
-  //                               ohms        temperature (C)
-  m_tempVector.push_back(tempEntry(441200,     -50));
-  m_tempVector.push_back(tempEntry(239700,     -40));
-  m_tempVector.push_back(tempEntry(135300,     -30));
-  m_tempVector.push_back(tempEntry(78910,      -20));
-  m_tempVector.push_back(tempEntry(47540,      -10));
-  m_tempVector.push_back(tempEntry(29490,      0));
-  m_tempVector.push_back(tempEntry(18780,      10));
-  m_tempVector.push_back(tempEntry(12260,      20));
-  m_tempVector.push_back(tempEntry(10000,      25));
-  m_tempVector.push_back(tempEntry(8194,       30));
-  m_tempVector.push_back(tempEntry(5592,       40));
-  m_tempVector.push_back(tempEntry(3893,       50));
-  m_tempVector.push_back(tempEntry(2760,       60));
-  m_tempVector.push_back(tempEntry(1990,       70));
-  m_tempVector.push_back(tempEntry(1458,       80));
-  m_tempVector.push_back(tempEntry(1084,       90));
-  m_tempVector.push_back(tempEntry(816.8,      100));
-  m_tempVector.push_back(tempEntry(623.6,      110));
-  m_tempVector.push_back(tempEntry(481.8,      120));
-  m_tempVector.push_back(tempEntry(376.4,      130));
-}
-
-void TEX00::initThermistorTEM()
-{
-  // this is an NTC type thermistor
-  m_isNTC = true;
-
-  // This data comes from the Veris TW_TE_d0116.pdf datasheet for the
-  // "M" (20k NTC) column
-
-  // clear and initialize the vector, ordered from lowest to highest
-  // temperature
-  m_tempVector.clear();
-
-  //                               ohms        temperature (C)
-  m_tempVector.push_back(tempEntry(1267600,    -50));
-  m_tempVector.push_back(tempEntry(643800,     -40));
-  m_tempVector.push_back(tempEntry(342000,     -30));
-  m_tempVector.push_back(tempEntry(189080,     -20));
-  m_tempVector.push_back(tempEntry(108380,     -10));
-  m_tempVector.push_back(tempEntry(64160,      0));
-  m_tempVector.push_back(tempEntry(38440,      10));
-  m_tempVector.push_back(tempEntry(24920,      20));
-  m_tempVector.push_back(tempEntry(20000,      25));
-  m_tempVector.push_back(tempEntry(16144,      30));
-  m_tempVector.push_back(tempEntry(10696,      40));
-  m_tempVector.push_back(tempEntry(7234,       50));
-  m_tempVector.push_back(tempEntry(4992,       60));
-  m_tempVector.push_back(tempEntry(3512,       70));
-  m_tempVector.push_back(tempEntry(2516,       80));
-  m_tempVector.push_back(tempEntry(1833,       90));
-  m_tempVector.push_back(tempEntry(1356,       100));
-  m_tempVector.push_back(tempEntry(1016,       110));
-  m_tempVector.push_back(tempEntry(770,        120));
-  m_tempVector.push_back(tempEntry(591,        130));
-}
-
-void TEX00::initThermistorTEU()
-{
-  // this is an NTC type thermistor
-  m_isNTC = true;
-
-  // This data comes from the Veris TW_TE_d0116.pdf datasheet for the
-  // "U" (20k "D") column
-
-  // clear and initialize the vector, ordered from lowest to highest
-  // temperature
-  m_tempVector.clear();
-
-  //                               ohms        temperature (C)
-  m_tempVector.push_back(tempEntry(803200,     -40));
-  m_tempVector.push_back(tempEntry(412800,     -30));
-  m_tempVector.push_back(tempEntry(220600,     -20));
-  m_tempVector.push_back(tempEntry(112400,     -10));
-  m_tempVector.push_back(tempEntry(70200,      0));
-  m_tempVector.push_back(tempEntry(41600,      10));
-  m_tempVector.push_back(tempEntry(25340,      20));
-  m_tempVector.push_back(tempEntry(20000,      25));
-  m_tempVector.push_back(tempEntry(15884,      30));
-  m_tempVector.push_back(tempEntry(10210,      40));
-  m_tempVector.push_back(tempEntry(6718,       50));
-  m_tempVector.push_back(tempEntry(4518,       60));
-  m_tempVector.push_back(tempEntry(3100,       70));
-  m_tempVector.push_back(tempEntry(2168,       80));
-  m_tempVector.push_back(tempEntry(1542,       90));
-  m_tempVector.push_back(tempEntry(1134,       100));
-  m_tempVector.push_back(tempEntry(816,        110));
-  m_tempVector.push_back(tempEntry(606,        120));
-  m_tempVector.push_back(tempEntry(456,        130));
-}
-
-void TEX00::initThermistorTET()
-{
-  // this is an NTC type thermistor
-  m_isNTC = true;
-
-  // This data comes from the Veris TW_TE_d0116.pdf datasheet for the
-  // "T" (100k) column
-
-  // clear and initialize the vector, ordered from lowest to highest
-  // temperature
-  m_tempVector.clear();
-
-  //                               ohms        temperature (C)
-  m_tempVector.push_back(tempEntry(3366000,    -40));
-  m_tempVector.push_back(tempEntry(1770000,    -30));
-  m_tempVector.push_back(tempEntry(971200,     -20));
-  m_tempVector.push_back(tempEntry(553400,     -10));
-  m_tempVector.push_back(tempEntry(326600,     0));
-  m_tempVector.push_back(tempEntry(199000,     10));
-  m_tempVector.push_back(tempEntry(124900,     20));
-  m_tempVector.push_back(tempEntry(100000,     25));
-  m_tempVector.push_back(tempEntry(80580,      30));
-  m_tempVector.push_back(tempEntry(53260,      40));
-  m_tempVector.push_back(tempEntry(36020,      50));
-  m_tempVector.push_back(tempEntry(24880,      60));
-  m_tempVector.push_back(tempEntry(17510,      70));
-  m_tempVector.push_back(tempEntry(12560,      80));
-  m_tempVector.push_back(tempEntry(9164,       90));
-  m_tempVector.push_back(tempEntry(6792,       100));
-  m_tempVector.push_back(tempEntry(5108,       110));
-  m_tempVector.push_back(tempEntry(3894,       120));
-  m_tempVector.push_back(tempEntry(3006,       130));
-}
-
diff --git a/src/tex00/tex00.hpp b/src/tex00/tex00.hpp
deleted file mode 100644
index 2bcc6db..0000000
--- a/src/tex00/tex00.hpp
+++ /dev/null
@@ -1,216 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <iostream>
-#include <vector>
-
-#include <mraa/aio.hpp>
-
-#define TEX00_DEFAULT_AREF 5.0
-
-namespace upm {
-    /**
-     * @brief Veris TEX00 Temperature Sensor
-     * @defgroup tex00 libupm-tex00
-     * @ingroup veris analog temp 
-     */
-
-    /**
-     * @library tex00
-     * @sensor tex00
-     * @comname Veris TEX00 Temperature Sensors
-     * @type temp
-     * @man veris
-     * @con analog
-     * @web http://www.veris.com/Item/TED00.aspx
-     *
-     * @brief API for the Veris TEX00 Temperature Sensor
-     *
-     * The Veris TEX00 temperature sensor family is made up of a
-     * series of RTD thermistors in wall mount packaging.  
-     * 
-     * This driver was developed using the TED00, which utilizes a 10K
-     * Ohm Type 2 thermistor.  However, this driver can support the
-     * other 12 variants of the TE series as well by providing the
-     * correct sensor type to the class constructor.  These other
-     * sensor types have not been tested.  Only the TED00 was tested
-     * with this driver.
-     *
-     * This sensor must be connected as part of a voltage divider,
-     * with the balancing resistor ideally matched to the sensor's 25C
-     * detection range.  For the TED00 (10kt2), a 10K Ohm (1%
-     * tolerance) resistor was used in a circuit like the following:
-     *
-     * GND o----|TED00(10k2)|----o----|balanceResistor(10K)|----o VCC (+5vdc)
-     *                           |
-     *                           |
-     *                           |----o A0 (analog input to MCU)
-     *
-     * A 3.3vdc voltage can be used as well if desired.
-     *
-     * @snippet tex00.cxx Interesting
-     */
-
-  class TEX00 {
-  public:
-
-    typedef enum {
-      STYPE_THERMISTOR_TED               = 0, // 10k type 2
-      STYPE_THERMISTOR_TEB,                   // 100 Ohm
-      STYPE_THERMISTOR_TEC,                   // 1000 Ohm
-      STYPE_THERMISTOR_TEI,                   // 1000 Ohm
-      STYPE_THERMISTOR_TEE,                   // 2.2k
-      STYPE_THERMISTOR_TEF,                   // 3k
-      STYPE_THERMISTOR_TEH,                   // 10k type 3
-      STYPE_THERMISTOR_TEJ,                   // 10k Dale
-      STYPE_THERMISTOR_TES,                   // 10k 3A221
-      STYPE_THERMISTOR_TER,                   // 10k "G" US
-      STYPE_THERMISTOR_TEM,                   // 20k NTC
-      STYPE_THERMISTOR_TEU,                   // 20k "D"
-      STYPE_THERMISTOR_TET                    // 100k
-    } SENSOR_TYPES_T;
-
-    /**
-     * TEX00 object constructor
-     *
-     * @param tPin Analog pin to use for temperature.
-     * @param balanceResistor Resistance (in Ohms) of the balance
-     * resistor used in your voltage divider.
-     * @param stype The sensor type.  One of the SENSOR_TYPES_T values.
-     * @param aref The analog reference voltage, default 5.0
-     */
-    TEX00(int tPin, float balanceResistor, SENSOR_TYPES_T stype,
-          float aref=TEX00_DEFAULT_AREF);
-
-    /**
-     * TEX00 object destructor
-     */
-    ~TEX00();
-
-    /**
-     * Read current values from the sensor and update internal stored
-     * values.  This method must be called prior to querying any
-     * values, such as temperature.
-     */
-    void update();
-
-    /**
-     * Get the current temperature.  update() must have been called
-     * prior to calling this method.
-     *
-     * @param fahrenheit true to return the temperature in degrees
-     * fahrenheit, false to return the temperature in degrees celsius.
-     * The default is false (degrees Celsius).
-     * @return The last temperature reading in Celsius or Fahrenheit
-     */
-    float getTemperature(bool fahrenheit=false);
-
-    /**
-     * Return the smallest temperature that can be measured by the
-     * current sensor.
-     *
-     * @return The smallest detectable temperature this sensor can
-     * measure, in C.
-     */
-    float getTemperatureRangeMin();
-
-    /**
-     * Return the largest temperature that can be measured by the
-     * current sensor.  
-     *
-     * @return The largest detectable temperature this sensor can
-     * measure, in C.
-     */
-    float getTemperatureRangeMax();
-
-    /**
-     * Detect whether the last measurement exceeded the sensors
-     * detection range.  update() must have been called prior to
-     * calling this method.
-     *
-     * @return true if the last measurement was out of range, false
-     * otherwise.
-     */
-    bool isOutOfRange()
-    {
-      return m_outOfRange;
-    }
-
-  protected:
-    mraa::Aio m_aioTemp;
-
-    // compute the temperature based on the resistance of the thermistor
-    float thermistor(float ohms);
-
-  private:
-    float m_aref;
-    int m_aResTemp;
-
-    // in Celsius
-    float m_temperature;
-    // temp reading out of range
-    bool m_outOfRange;
-
-    // resistance of the other half of our voltage divider
-    float m_balanceResistor;
-
-    int average(int samples);
-
-    // Negative Temperature Coefficient (NTC) or Positive Temperature
-    // Coefficient (PTC)
-    bool m_isNTC;
-
-    // This may generate a SWIG warning.  It can be safely ignored
-    // since this structure is never exposed outside the class.
-    struct tempEntry
-    {
-      tempEntry(float o, float t) : ohms(o), temp(t) {};
-      
-      float ohms;
-      float temp; // in C
-    };
-
-    // ohms/temperature table store
-    std::vector<tempEntry> m_tempVector;
-
-    // table temperature init functions
-    void initThermistorTED();
-    void initThermistorTEB();
-    void initThermistorTEC();
-    void initThermistorTEI();
-    void initThermistorTEE();
-    void initThermistorTEF();
-    void initThermistorTEH();
-    void initThermistorTEJ();
-    void initThermistorTES();
-    void initThermistorTER();
-    void initThermistorTEM();
-    void initThermistorTEU();
-    void initThermistorTET();
-  };
-}
-
-
diff --git a/src/tex00/tex00.i b/src/tex00/tex00.i
deleted file mode 100644
index 1497f2a..0000000
--- a/src/tex00/tex00.i
+++ /dev/null
@@ -1,14 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_tex00)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "tex00.hpp"
-%}
-%include "tex00.hpp"
-/* END Common SWIG syntax */
diff --git a/src/tex00/tex00.json b/src/tex00/tex00.json
deleted file mode 100644
index 629bda5..0000000
--- a/src/tex00/tex00.json
+++ /dev/null
@@ -1,52 +0,0 @@
-{
-    "Library": "tex00",
-    "Description": "Veris TEX00 Temperature Sensor Library",
-    "Sensor Class": {
-        "TEX00": {
-            "Name": "API for the Veris TEX00 Temperature Sensor",
-            "Description": "This is the UPM Module for the Veris TEX00 Temperature Sensor. The Veris TEX00 temperature sensor family is made up of a series of RTD thermistors in wall mount packaging.    This driver was developed using the TED00, which utilizes a 10K Ohm Type 2 thermistor.  However, this driver can support the other 12 variants of the TE series as well by providing the correct sensor type to the class constructor.  These other sensor types have not been tested.  Only the TED00 was tested with this driver.",
-            "Aliases": ["tex00", "TED00"],
-            "Categories": ["temperature"],
-            "Connections": ["ainput"],
-            "Project Type": ["industrial", "commercial"],
-            "Manufacturers": ["Veris"],
-            "Examples": {
-                "Java": ["TEX00_Example.java"],
-                "Python": ["tex00.py"],
-                "Node.js": ["tex00.js"],
-                "C++": ["tex00.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 5,
-                    "max": 30
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "min" : 4,
-                    "max" : 20
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -25,
-                    "max": 105
-                },
-                "Effective Range": {
-                    "unit": "°C",
-                    "min" : 10,
-                    "max" : 35
-                },
-                "Offset Temperature": {
-                    "unit": "+/-°C",
-                    "min" : 1.8,
-                    "max" : 3.0
-                }
-            },
-            "Urls": {
-                "Product Pages": ["http://www.veris.com/Item/TED00.aspx"],
-                "Datasheets": ["http://www.veris.com/docs/Datasheets/TW_TE_d0117.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/th02/CMakeLists.txt b/src/th02/CMakeLists.txt
deleted file mode 100644
index 5ac30bf..0000000
--- a/src/th02/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "th02")
-set (libdescription "Temperature and Humidity Sensor Pro")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/th02/th02.cxx b/src/th02/th02.cxx
deleted file mode 100644
index 5e79e06..0000000
--- a/src/th02/th02.cxx
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Contributions: Jon Trulson <jtlulson@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Credits to Seeed Studeo.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <unistd.h>
-#include <stdlib.h>
-#include <stdexcept>
-
-#include "th02.hpp"
-
-using namespace std;
-using namespace upm;
-
-TH02::TH02 (int bus, uint8_t addr) : m_i2c(bus) {
-    m_addr = addr;
-    m_name = "TH02";
-
-    mraa::Result ret = m_i2c.address(m_addr);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) + 
-                                    ": mraa_i2c_address() failed");
-    }
-}
-
-TH02::~TH02 () {
-}
-
-float
-TH02::getTemperature () {
-    uint16_t temperature = 0;
-
-    /* Start a new temperature conversion */
-    if (m_i2c.writeReg(TH02_REG_CONFIG, TH02_CMD_MEASURE_TEMP)) {
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": I2c.writeReg() failed");
-        return 0.0;
-    }
-
-    /* Wait until conversion is done */
-    while (getStatus() == false);
-
-    temperature = m_i2c.readReg(TH02_REG_DATA_H) << 8;
-    temperature |= m_i2c.readReg(TH02_REG_DATA_L);
-    temperature >>= 2;
-
-    return ((float(temperature) / 32.0) - 50.0);
-}
-
-float
-TH02::getHumidity () {
-    uint16_t humidity = 0;
-
-    /* Start a new humidity conversion */
-    if (m_i2c.writeReg(TH02_REG_CONFIG, TH02_CMD_MEASURE_HUMI)) {
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": I2c.writeReg() failed");
-        return 0.0;
-    }
-
-    /* Wait until conversion is done */
-    while (getStatus() == false);
-
-    humidity = m_i2c.readReg(TH02_REG_DATA_H) << 8;
-    humidity |= m_i2c.readReg(TH02_REG_DATA_L);
-    humidity >>= 4;
-
-    return ((float(humidity) / 16.0) - 24.0);
-}
-
-bool
-TH02::getStatus () {
-    uint8_t status = m_i2c.readReg(TH02_REG_STATUS);
-
-    if (status & TH02_STATUS_RDY_MASK)
-        return false;           // NOT ready
-    else
-        return true;            // ready
-}
-
diff --git a/src/th02/th02.hpp b/src/th02/th02.hpp
deleted file mode 100644
index 45a0f1d..0000000
--- a/src/th02/th02.hpp
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
- * Contributions: Jon Trulson <jtlulson@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Credits to Seeed Studeo.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/i2c.hpp>
-
-#define TH02_ADDR                0x40 // device address
-
-#define TH02_REG_STATUS          0x00
-#define TH02_REG_DATA_H          0x01
-#define TH02_REG_DATA_L          0x02
-#define TH02_REG_CONFIG          0x03
-#define TH02_REG_ID              0x11
-
-#define TH02_STATUS_RDY_MASK     0x01
-
-#define TH02_CMD_MEASURE_HUMI    0x01
-#define TH02_CMD_MEASURE_TEMP    0x11
-
-namespace upm {
-
-/**
- * @brief TH02 Temperature & Humidity Sensor
- * @defgroup th02 libupm-th02
- * @ingroup seeed i2c temp
- */
-/**
- * @library th02
- * @sensor th02
- * @comname Temperature and Humidity Sensor Pro
- * @altname Grove Temperature & Humidity Sensor (High-Accuracy & Mini)
- * @type temp
- * @man seeed
- * @web http://www.seeedstudio.com/wiki/Grove_-_Tempture%26Humidity_Sensor_(High-Accuracy_%26Mini)_v1.0
- * @con i2c
- *
- * @brief API for the TH02 Temperature & Humidity Sensor
- * 
- *   This module defines the TH02 interface for libth02 
- *
- *   Note: For use on Intel(R) Edison with an Arduino* breakout board, Intel
- *   Edison must be set to 3 V rather than 5 V.
- *
- * @image html th02.jpg
- * @snippet th02.cxx Interesting
- */
-class TH02 {
-    public:
-        /**
-         * Instantiates a TH02 object
-         */
-        TH02 (int bus=0, uint8_t addr=TH02_ADDR);
-
-        /**
-         * TH02 object destructor; basically, it closes the I2C connection.
-         */
-        ~TH02 ();
-
-        /**
-         * Gets the temperature value from the sensor.
-         */
-        float getTemperature ();
-
-        /**
-         * Gets the humidity value from the sensor.
-         */
-        float getHumidity ();
-
-        /**
-         * Gets the sensor status.
-         */
-        bool getStatus ();
-
-        /**
-         * Returns the name of the component
-         */
-        std::string name()
-        {
-            return m_name;
-        }
-
-    private:
-        std::string m_name;
-        mraa::I2c m_i2c;
-        uint8_t m_addr;
-};
-
-}
diff --git a/src/th02/th02.json b/src/th02/th02.json
deleted file mode 100644
index 97c399e..0000000
--- a/src/th02/th02.json
+++ /dev/null
@@ -1,77 +0,0 @@
-{
-    "Library": "th02",
-    "Description": "Seeed TH02 Temperature & Humidity Sensor Library",
-    "Sensor Class": {
-        "TH02": {
-            "Name": "API for the Seeed TH02 Temperature & Humidity Sensor",
-            "Description": "This is the UPM Module for the Seeed TH02 Temperature & Humidity Sensor. This is a multifunctional sensor that gives you temperature and relative humidity information at the same time. It utilizes a TH02 sensor that can meet measurement needs of general purposes. It provides reliable readings when environment humidity condition inbetween 0-80% RH, and temperature condition inbetween 0-70°C, covering needs in most home and daily applications that don't contain extreme conditions.",
-            "Aliases": ["th02", "Grove - Temperature&Humidity Sensor (High-Accuracy & Mini)"],
-            "Categories": ["humidity", "temperature"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["Seeed"],
-            "Image": "th02.jpg",
-            "Examples": {
-                "Java": ["Th02_Example.java"],
-                "C++": ["th02.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.3,
-                    "max": 5.0
-                },
-                "Supply Current": {
-                    "unit": "uA",
-                    "min" : 24,
-                    "max" : 565
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Humidity Sensor": {
-                    "Effective Range": {
-                        "unit": "%RH",
-                        "min" : 20,
-                        "max" : 80
-                    },
-                    "Accuracy": {
-                        "unit": "-/+ %RH",
-                        "min" : 3.0,
-                        "max" : 4.5
-                    }
-                },
-                "Temperature Sensor": {
-                    "Effective Range": {
-                        "unit": "°C",
-                        "min" : 0,
-                        "max" : 70
-                    },
-                    "Resolution": {
-                        "unit": "°C",
-                        "resolution": "1/32"
-                    },
-                    "Accuracy": {
-                        "unit": "+/- °C",
-                        "min" : 0.5,
-                        "max" : 1.0
-                    }
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield", "Must be set to 3 V rather than 5 V."]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-Temperature%26Humidity-Sensor-(High-Accuracy-%26-Mini)-p-1921.html", "http://wiki.seeed.cc/Grove-TemptureAndHumidity_Sensor-High-Accuracy_AndMini-v1.0/"],
-                "Datasheets": ["https://raw.githubusercontent.com/SeeedDocument/Grove-TemptureAndHumidity_Sensor-High-Accuracy_AndMini-v1.0/master/res/TH02_SENSOR.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/tm1637/CMakeLists.txt b/src/tm1637/CMakeLists.txt
deleted file mode 100644
index 337c521..0000000
--- a/src/tm1637/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "tm1637")
-set (libdescription "C++ API for the TM1637 7-segment Display")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/tm1637/tm1637.cxx b/src/tm1637/tm1637.cxx
deleted file mode 100644
index ef895da..0000000
--- a/src/tm1637/tm1637.cxx
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- * Author: Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string>
-#include <stdexcept>
-#include "tm1637.hpp"
-#include <stdarg.h>
-
-const uint8_t m_brkt[2]  = {0x39, 0x0f};
-const uint8_t m_nums[10] = {0x3f, 0x06, 0x5b, 0x4f, 0x66,
-                            0x6d, 0x7d, 0x07, 0x7f, 0x6f};
-const uint8_t m_char[26] = {0x77, 0x7c, 0x39, 0x5e, 0x79,
-                            0x71, 0x6f, 0x76, 0x30, 0x1e,
-                            0x00, 0x38, 0x00, 0x00, 0x5c,
-                            0x73, 0x67, 0x50, 0x5b, 0x78,
-                            0x3e, 0x1c, 0x00, 0x00, 0x6e,
-                            0x5b};
-
-using namespace std;
-using namespace upm;
-
-upm::TM1637::TM1637(int clk_pin, int dio_pin, int bright) {
-
-    if((m_clk = mraa_gpio_init(clk_pin)) == NULL){
-       throw std::invalid_argument(std::string(__FUNCTION__) +
-                                   ": mraa_gpio_init(clk) failed, invalid pin?");
-       return;
-    }
-
-    if((m_dio = mraa_gpio_init(dio_pin)) == NULL){
-       throw std::invalid_argument(std::string(__FUNCTION__) +
-                                   ": mraa_gpio_init(dio) failed, invalid pin?");
-       return;
-    }
-
-    mraa_gpio_dir(m_clk, MRAA_GPIO_OUT);
-    mraa_gpio_dir(m_dio, MRAA_GPIO_OUT);
-
-    // Let the resistors pull the lines high
-    mraa_gpio_mode(m_clk, MRAA_GPIO_PULLUP);
-    mraa_gpio_mode(m_dio, MRAA_GPIO_PULLUP);
-
-    mraa_gpio_write(m_clk, 0);
-    mraa_gpio_write(m_dio, 0);
-
-    for (int i = 0; i < M_DISPLAY_DIGITS; i++) {
-        m_digits[i] = 0x00;
-    }
-    setBrightness(bright);
-}
-upm::TM1637::~TM1637() {
-    for (int i = 0; i < M_DISPLAY_DIGITS; i++) {
-        m_digits[i] = 0x00;
-    }
-    update();
-
-    mraa_gpio_close(m_clk);
-    mraa_gpio_close(m_dio);
-}
-mraa_result_t upm::TM1637::write(uint8_t *digits) {
-    for (int i = 0; i < M_DISPLAY_DIGITS; i++) {
-        m_digits[i] = digits[i];
-    }
-    update();
-    return MRAA_SUCCESS;
-}
-mraa_result_t upm::TM1637::write(int d, ...) {
-    va_list args;
-    va_start(args, d);
-    m_digits[0] = (uint8_t)d;
-
-    for (int i = 1; i < M_DISPLAY_DIGITS; i++) {
-        m_digits[i] = (uint8_t)va_arg(args, int);
-        d++;
-    }
-    va_end(args);
-    update();
-    return MRAA_SUCCESS;
-}
-mraa_result_t upm::TM1637::writeAt(int index, char symbol) {
-    if(index < 0 || index >= M_DISPLAY_DIGITS){
-        cerr << "TM1637: invalid index in " << __FUNCTION__ << endl;
-        return MRAA_ERROR_INVALID_PARAMETER;
-    }
-    m_digits[index] = encode(symbol);
-    update();
-    return MRAA_SUCCESS;
-}
-mraa_result_t upm::TM1637::write(std::string digits) {
-    int len = digits.length();
-    if( len > M_DISPLAY_DIGITS){
-        len = M_DISPLAY_DIGITS;
-    }
-    for (int i = 0; i < len; i++) {
-        m_digits[i] = encode(digits[i]);
-    }
-    update();
-    return MRAA_SUCCESS;
-}
-void upm::TM1637::setColon(bool value) {
-    if(value){
-       m_digits[1] |= 0x80;
-    }
-    else{
-       m_digits[1] &= 0x7f;
-    }
-    update();
-}
-void upm::TM1637::setBrightness(int value) {
-    m_brightness = value & 0x07;
-    update();
-}
-void upm::TM1637::i2c_start() {
-    mraa_gpio_write(m_clk, 1);
-    mraa_gpio_write(m_dio, 1);
-    mraa_gpio_write(m_dio, 0);
-}
-void upm::TM1637::i2c_stop() {
-    mraa_gpio_write(m_clk, 0);
-    mraa_gpio_write(m_dio, 0);
-    mraa_gpio_write(m_clk, 1);
-    mraa_gpio_write(m_dio, 1);
-}
-void upm::TM1637::i2c_writeByte(uint8_t value) {
-    for(uint8_t i = 0; i < 8; i++)
-    {
-        mraa_gpio_write(m_clk, 0);
-        if(value & 0x01)
-            mraa_gpio_write(m_dio, 1);
-        else
-            mraa_gpio_write(m_dio, 0);
-        value >>= 1;
-        mraa_gpio_write(m_clk, 1);
-    }
-
-    // Ack clock without skew, TM1637 is fast enough
-    mraa_gpio_write(m_clk, 0);
-    mraa_gpio_write(m_clk, 1);
-    mraa_gpio_write(m_clk, 0);
-}
-void upm::TM1637::update() {
-    i2c_start();
-    i2c_writeByte(TM1637_ADDR);
-    i2c_stop();
-
-    i2c_start();
-    i2c_writeByte(TM1637_REG);
-    for (int i = 0; i < M_DISPLAY_DIGITS; i++) {
-        i2c_writeByte(m_digits[i]);
-    }
-    i2c_stop();
-
-    i2c_start();
-    i2c_writeByte(TM1637_CMD | m_brightness);
-    i2c_stop();
-}
-uint8_t upm::TM1637::encode(char c) {
-    if(c >= '0' && c <= '9')
-        return m_nums[(int)c - 48];
-    if(c >= 'a' && c <= 'z')
-        return m_char[(int)c - 97];
-    if(c >= 'A' && c <= 'Z')
-        return m_char[(int)c - 65];
-    if(c == '[')
-        return m_brkt[0];
-    if(c == ']')
-        return m_brkt[1];
-    if(c == '(' || c == ')')
-        return m_brkt[(int)c - 40];
-    if(c == '-')
-        return 0x40;
-    if(c == '_')
-        return 0x08;
-    if(c == '}')
-        return 0x70;
-    if(c == '{')
-        return 0x46;
-    return 0x00;
-}
diff --git a/src/tm1637/tm1637.hpp b/src/tm1637/tm1637.hpp
deleted file mode 100644
index b56cd43..0000000
--- a/src/tm1637/tm1637.hpp
+++ /dev/null
@@ -1,143 +0,0 @@
-/*
- * Author: Mihai Tudor Panu <mihai.tudor.panu@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <unistd.h>
-#include <stdint.h>
-#include <string>
-#include <iostream>
-
-#include <mraa/gpio.h>
-
-
-// TM1637-specific register addresses for writing all digits at a time
-#define TM1637_ADDR    0x40
-#define TM1637_REG     0xC0
-#define TM1637_CMD     0x88
-
-// Display-specific values
-#define M_DISPLAY_DIGITS  4
-
-namespace upm
-{
-
-/**
- * @brief TM1637 7-Segment Display
- * @defgroup tm1637 libupm-tm1637
- * @ingroup seeed gpio display
- */
-
-/**
- * @library tm1637
- * @sensor tm1637
- * @comname 7-segment Display
- * @altname Grove 4-Digit Display
- * @type display
- * @man seeed
- * @web http://wiki.seeed.cc/Grove-4-Digit_Display/
- * @con gpio
- *
- * @brief API for the TM1637 7-Segment Display
- *
- * TM1637 is a display controller for LED-based 7-segment displays.
- * It can be used to address and write data to multiple display digits. This
- * driver is based on the Grove version of the TM1637 display that uses 4
- * digits, thus making it ideal for clock displays, timers, counters, or even
- * score displays in a two-player arcade game.
- *
- * @image html tm1637.jpeg
- * @snippet tm1637.cxx Interesting
- */
-
-  class TM1637
-  {
-  public:
-      /**
-       * TM1637 constructor
-       *
-       * @param clk_pin Clock pin the sensor is connected to
-       * @param dio_pin Data pin the sensor is connected to
-       * @param bright Initial brightness, from 0 (dark) to 7 (bright) (default is 3)
-       */
-      TM1637(int clk_pin, int dio_pin, int bright = 3);
-      /**
-       * TM1637 destructor
-       */
-      ~TM1637();
-      /**
-       * Writes digits to the display in a 7-segment encoding
-       *
-       * @param digits Array of digits to send to the display
-       * @return 0 if successful, error code otherwise
-       */
-      mraa_result_t write(uint8_t *digits);
-      /**
-       * Writes digits to the display in a 7-segment encoding
-       *
-       * @param d List of multiple arguments to send to the display
-       * @return 0 if successful, error code otherwise
-       */
-      mraa_result_t write(int d, ...);
-      /**
-       * Writes a symbol (digit or letter) to the display in a specified index
-       *
-       * @param index 0-based index of the digit to change from the left
-       * @param symbol Digit or letter to display
-       * @return 0 if successful, error code otherwise
-       */
-      mraa_result_t writeAt(int index, char symbol);
-      /**
-       * Writes all the digits or letters to the display as a string
-       *
-       * @param digits String of symbols to display
-       * @return 0 if successful, error code otherwise
-       */
-      mraa_result_t write(std::string digits);
-      /**
-       * Toggles the colon between digits on the display
-       *
-       * @param value True to turn the colon on, false to turn it off
-       */
-      void setColon(bool value);
-      /**
-       * Controls the brightness of the display
-       *
-       * @param value Brightness, from 0 (darkest) to 7 (brightest)
-       */
-      void setBrightness(int value);
-
-  private:
-      void i2c_start();
-      void i2c_stop();
-      void i2c_writeByte(uint8_t value);
-      void update();
-      uint8_t encode(char c);
-
-      mraa_gpio_context m_clk, m_dio;
-      std::string m_name;
-      uint8_t m_digits[4];
-      uint8_t m_brightness;
-  };
-}
diff --git a/src/tm1637/tm1637.i b/src/tm1637/tm1637.i
deleted file mode 100644
index c7a4142..0000000
--- a/src/tm1637/tm1637.i
+++ /dev/null
@@ -1,32 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_tm1637)
-#endif
-/* END Java syntax */
-
-/* BEGIN Javascript syntax  ------------------------------------------------- */
-#ifdef SWIGJAVASCRIPT
-%include "../carrays_uint8_t.i"
-#endif
-/* END Javascript syntax */
-
-/* BEGIN Python syntax  ----------------------------------------------------- */
-#ifdef SWIGPYTHON
-%include "../carrays_uint8_t.i"
-#endif
-/* END Python syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%rename("writeArray")  write(uint8_t *digits);
-%rename("writeString") write(std::string digits);
-
-%varargs(4, int digit = 0) write;
-%apply uint8_t *INPUT { uint8_t *digits }
-
-%{
-#include "tm1637.hpp"
-%}
-%include "tm1637.hpp"
-/* END Common SWIG syntax */
diff --git a/src/tm1637/tm1637.json b/src/tm1637/tm1637.json
deleted file mode 100644
index 10e0c92..0000000
--- a/src/tm1637/tm1637.json
+++ /dev/null
@@ -1,52 +0,0 @@
-{
-    "Library": "tm1637",
-    "Description": "Seeed TM1637 based 7-Segment Display Library",
-    "Sensor Class": {
-        "TM1637": {
-            "Name": "API for the Seeed TM1637 based 7-Segment Display",
-            "Description": "This is the UPM Module for the Seeed TM1637 based 7-Segment Display. It can be used to address and write data to multiple display digits. This driver is based on the Grove version of the TM1637 display that uses 4 digits, thus making it ideal for clock displays, timers, counters, or even score displays in a two-player arcade game.",
-            "Aliases": ["tm1637", "Grove - 4-Digit Display"],
-            "Categories": ["display"],
-            "Connections": ["gpio"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["Seeed", "Titan Micro Electronics"],
-            "Image": "tm1637.jpeg",
-            "Examples": {
-                "Java": ["TM1637_Example.java"],
-                "Python": ["tm1637.py"],
-                "Node.js": ["tm1637.js"],
-                "C++": ["tm1637.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.3,
-                    "max": 5.5
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "min" : 0.2,
-                    "max" : 80
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -40,
-                    "max": 85
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/grove-4digital-display-p-1198.html", "http://wiki.seeed.cc/Grove-4-Digit_Display/"],
-                "Datasheets": ["https://raw.githubusercontent.com/SeeedDocument/Grove-4-Digit_Display/master/res/TM1637_datasheet.pdf"],
-                "Schematics": ["https://raw.githubusercontent.com/SeeedDocument/Grove-4-Digit_Display/master/res/Grove_4-Digit_Display_V1.0.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/tmp006/CMakeLists.txt b/src/tmp006/CMakeLists.txt
deleted file mode 100644
index 7bb9221..0000000
--- a/src/tmp006/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "tmp006")
-set (libdescription "IR-Termopile Sensor")
-set (module_src ${libname}.cpp)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/tmp006/tmp006.cpp b/src/tmp006/tmp006.cpp
deleted file mode 100644
index bae9456..0000000
--- a/src/tmp006/tmp006.cpp
+++ /dev/null
@@ -1,278 +0,0 @@
-/*
- * Author: Norbert Wesp <nwesp@phytec.de>
- * Copyright (c) 2017 Phytec Messtechnik GmbH.
- *
- * based on: RIOT-driver tmp006 by Johann Fischer <j.fischer@phytec.de>
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include <unistd.h>
-#include <stdlib.h>
-#include <endian.h>
-
-#include "tmp006.hpp"
-
-using namespace upm;
-
-TMP006::TMP006(int bus, uint8_t conv_rate, int devAddr) : m_i2ControlCtx(bus) {
-    uint8_t reg[2];
-    uint16_t tmp;
-
-    m_temperature = 0;
-
-    m_name = TMP006_NAME;
-
-    m_controlAddr = devAddr;
-
-    sensorType = TMP006_SEN;
-    m_bus = bus;
-
-    if (conv_rate > TMP006_CONFIG_CR_AS16) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_conv_rate() failed");
-    }
-
-    mraa::Result ret = m_i2ControlCtx.address(m_controlAddr);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_address() failed");
-    }
-
-    if (checkID() != 0) {
-        /* sensor_id does not match! maybe wrong sensor chosen? */
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": checkID() failed");
-    }
-
-    tmp = m_i2ControlCtx.readWordReg(TMP006_CONFIGURATION);
-    reg[0] = (tmp >> 8);
-
-    tmp = TMP006_CONFIG_CR(conv_rate);
-    reg[1] = (tmp >> 8);
-
-    tmp = ((uint16_t)reg[1] << 8) | reg[0];
-
-    ret = m_i2ControlCtx.writeWordReg(TMP006_CONFIGURATION, tmp);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_word_data() failed");
-    }
-}
-
-int
-TMP006::checkID(void)
-{
-    uint8_t tmp[2];
-    uint16_t id;
-    int re = 0;
-    int ret = 0;
-
-    tmp[0] = 0;tmp[1] = 0;
-    // Checking if TMP006
-    re = m_i2ControlCtx.readBytesReg(TMP006_DEVICE_ID_REG, tmp, 2);
-    if (re != 2) {
-        /* not enough bytes were read! */
-        //return -1;
-        ret = -1;
-    }
-
-    id = ((uint16_t)tmp[0] << 8) | tmp[1];
-
-    if (id != TMP006_DEVICE_ID) {
-        //return -1;
-        ret = -1;
-    } else {
-        sensorType = TMP006_SEN;
-        return 0;
-    }
-
-    // Checking if TMP007
-    re = m_i2ControlCtx.readBytesReg(TMP007_DEVICE_ID_REG, tmp, 2);
-    if (re != 2) {
-        /* not enough bytes were read! */
-        //return -1;
-        ret = -1;
-    }
-
-    id = ((uint16_t)tmp[0] << 8) | tmp[1];
-
-    if (id != TMP007_DEVICE_ID) {
-        //return -1;
-        ret = -1;
-    } else {
-        sensorType = TMP007_SEN;
-        return 0;
-    }
-
-    return ret;
-}
-
-void
-TMP006::resetSensor(void)
-{
-    uint8_t reg[2];
-    uint16_t tmp = TMP006_RST_SOFT;
-    reg[0] = (tmp >> 8);
-    reg[1] = (tmp & 0x00ff);
-    tmp = ((uint16_t)reg[1] << 8) | reg[0];
-
-    mraa::Result ret = m_i2ControlCtx.writeWordReg(TMP006_CONFIGURATION, tmp);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_word_data() failed");
-    }
-}
-
-void
-TMP006::setActive(void)
-{
-    uint8_t reg[2];
-    uint16_t tmp;
-
-    tmp = m_i2ControlCtx.readWordReg(TMP006_CONFIGURATION);
-    reg[0] = (tmp >> 8);
-    reg[1] = (tmp & 0x00ff);
-    reg[1] |= (TMP006_CONFIG_MOD(TMP006_CONFIG_MOD_CC) >> 8);
-
-    tmp = ((uint16_t)reg[0] << 8) | reg[1];
-
-    mraa::Result ret = m_i2ControlCtx.writeWordReg(TMP006_CONFIGURATION, tmp);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_word_data() failed");
-    }
-}
-
-void
-TMP006::setStandby(void)
-{
-    uint8_t reg[2];
-    uint16_t tmp;
-
-    tmp = m_i2ControlCtx.readWordReg(TMP006_CONFIGURATION);
-    reg[0] = (tmp >> 8);
-    reg[1] = (tmp & 0x00ff);
-    reg[1] &= ~(TMP006_CONFIG_MOD(TMP006_CONFIG_MOD_CC) >> 8);
-
-    tmp = ((uint16_t)reg[0] << 8) | reg[1];
-
-    mraa::Result ret = m_i2ControlCtx.writeWordReg(TMP006_CONFIGURATION, tmp);
-    if (ret != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_write_word_data() failed");
-    }
-}
-
-int
-TMP006::sampleData(void)
-{
-    uint8_t buf[2];
-    uint16_t rawVolt;
-    uint16_t rawTemp;
-    float tamb[1];
-    float tobj[1];
-    uint16_t tmp;
-    uint8_t drdy[1];
-
-    tmp = m_i2ControlCtx.readWordReg(TMP006_CONFIGURATION);
-    buf[0] = (tmp >> 8);
-    buf[1] = (tmp & 0x00ff);
-
-    *drdy = buf[0] & (TMP006_DRDY_DATA_RDY);
-
-    if(sensorType == TMP006_SEN) {
-        if(! (*drdy)) {
-            /* conversation in progress */
-            return -1;
-        }
-    }
-
-    tmp = m_i2ControlCtx.readWordReg(TMP006_SENSOR_VOLTAGE);
-    buf[0] = (tmp >> 8);
-    buf[1] = (tmp & 0x00ff);
-    rawVolt = ((uint16_t)buf[1] << 8) | buf[0];
-
-    tmp = m_i2ControlCtx.readWordReg(TMP006_LOCAL_TEMPERATURE);
-    buf[0] = (tmp >> 8);
-    buf[1] = (tmp & 0x00ff);
-    rawTemp = ((uint16_t)buf[1] << 8) | buf[0];
-
-    convert_data(rawVolt, rawTemp, tamb, tobj);
-    m_temperature = (uint16_t)*tobj;
-
-    return 0;
-}
-
-void
-TMP006::convert_data(int16_t rawv,int16_t rawt, float *tamb, float *tobj)
-{
-    /* calculate die temperature */
-    *tamb = (double)rawt / 128.0;
-    /* die temperature in Kelvin */
-    double tdie_k = *tamb + 273.15;
-
-    /* calculate sensor voltage */
-    double sens_v = (double)rawv * TMP006_CCONST_LSB_SIZE;
-
-    double tdiff = tdie_k - TMP006_CCONST_TREF;
-    double tdiff_pow2 = pow(tdiff, 2);
-
-    double s = TMP006_CCONST_S0 * (1 + TMP006_CCONST_A1 * tdiff
-                                   + TMP006_CCONST_A2 * tdiff_pow2);
-
-    double v_os = TMP006_CCONST_B0 + TMP006_CCONST_B1 * tdiff
-                  + TMP006_CCONST_B2 * tdiff_pow2;
-
-    double f_obj = (sens_v-v_os) + TMP006_CCONST_C2 * pow((sens_v-v_os), 2);
-
-    double t = pow(pow(tdie_k, 4) + (f_obj / s), 0.25);
-    /* calculate object temperature in Celsius */
-    *tobj = (t - 273.15);
-}
-
-float
-TMP006::getTemperature(int bSampleData)
-{
-    if (bSampleData) {
-        if( (sampleData()) == -1) {
-            /* conversation in progress */
-            return (-273.2);
-        }
-    }
-    return (float) m_temperature;
-}
-
-uint16_t
-TMP006::getConfig(void)
-{
-    uint8_t buf[2];
-    uint16_t tmp;
-
-    tmp = m_i2ControlCtx.readWordReg(TMP006_CONFIGURATION);
-    buf[0] = (tmp >> 8);
-    buf[1] = (tmp & 0x00ff);
-
-    return ((uint16_t)buf[1] << 8) | buf[0];
-}
diff --git a/src/tmp006/tmp006.hpp b/src/tmp006/tmp006.hpp
deleted file mode 100644
index 2fff3eb..0000000
--- a/src/tmp006/tmp006.hpp
+++ /dev/null
@@ -1,214 +0,0 @@
-/*
- * Author: Norbert Wesp <nwesp@phytec.de>
- * Copyright (c) 2017 Phytec Messtechnik GmbH.
- *
- * based on: RIOT-driver tmp006 by Johann Fischer <j.fischer@phytec.de>
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <string>
-#include <mraa/i2c.hpp>
-#include <math.h>
-
-#define TMP006_NAME "TMP006"
-#define TMP006_I2C_ADDRESS     0x41
-#define TMP006_MANUFACTURER_ID 0x5449
-#define TMP006_DEVICE_ID       0x0067
-
-#define TMP007_I2C_ADDRESS     0x40
-// this should actually be split
-#define TMP007_DEVICE_ID       0x0078
-
-#ifndef TMP006_CONVERSION_TIME
-#define TMP006_CONVERSION_TIME 1E6 /**< Default Conversion Time in us */
-#endif
-
-/* TMP006 Register Map */
-#define TMP006_SENSOR_VOLTAGE      0x00   /* Sensor voltage register */
-#define TMP006_LOCAL_TEMPERATURE   0x01   /* Ambient temperature register */
-#define TMP006_CONFIGURATION       0x02
-#define TMP006_MANUFACTURER_ID_REG 0xFE
-#define TMP006_DEVICE_ID_REG       0xFF
-
-/* TMP007 Register Map */
-#define TMP007_DEVICE_ID_REG       0x1F
-
-/* TMP006 configuration register bitmap */
-#define TMP006_RST_SOFT         (1 << 15)
-
-#define TMP006_CONFIG_MOD_SHIFT 12
-#define TMP006_CONFIG_MOD_MASK  0x7000
-#define TMP006_CONFIG_MOD(x)    (((uint16_t)(((uint16_t)(x))<<\
-                                TMP006_CONFIG_MOD_SHIFT))\
-                                &TMP006_CONFIG_MOD_MASK)
-#define TMP006_CONFIG_MOD_CC    0x07
-#define TMP006_CONFIG_MOD_OFF   0x00
-
-#define TMP006_CONFIG_CR_SHIFT  9
-#define TMP006_CONFIG_CR_MASK   0x0E00
-#define TMP006_CONFIG_CR(x)     (((uint16_t)(((uint16_t)(x))<<\
-                                TMP006_CONFIG_CR_SHIFT))\
-                                &TMP006_CONFIG_CR_MASK)
-#define TMP006_CONFIG_CR_AS1  0x00 /* Conversion Time 0.25 s, AVG Samples: 1 */
-#define TMP006_CONFIG_CR_AS2  0x01 /* Conversion Time 0.5 s, AVG Samples: 2 */
-#define TMP006_CONFIG_CR_AS4  0x02 /* Conversion Time 1 s, AVG Samples: 4 */
-#define TMP006_CONFIG_CR_AS8  0x03 /* Conversion Time 2 s, AVG Samples: 8 */
-#define TMP006_CONFIG_CR_AS16 0x04 /* Conversion Time 4 s, AVG Samples: 16 */
-#define TMP006_CONFIG_CR_DEF  TMP006_CONFIG_CR_AS4 /**< Default for Testing */
-
-#define TMP006_DRDY_EN          (1 << 8)
-#define TMP006_DRDY_DATA_RDY    (1 << 7)
-
-/* constant values for data conversion */
-#ifndef TMP006_CCONST_S0
-#define TMP006_CCONST_S0       6.4E-14    /* Calibration Factor */
-#endif
-
-#define TMP006_CCONST_A1       1.75E-3   /* Constant \f$a_{\mathrm{1}}\f$ */
-#define TMP006_CCONST_A2       -1.678E-5 /* Constant \f$a_{\mathrm{2}}\f$ */
-#define TMP006_CCONST_TREF     298.15    /* Constant \f$T_{\mathrm{REF}}\f$ */
-#define TMP006_CCONST_B0       -2.94E-5  /* Constant \f$b_{\mathrm{0}}\f$ */
-#define TMP006_CCONST_B1       -5.7E-7   /* Constant \f$b_{\mathrm{1}}\f$ */
-#define TMP006_CCONST_B2       4.63E-9   /* Constant \f$b_{\mathrm{2}}\f$ */
-#define TMP006_CCONST_C2       13.4      /* Constant \f$c_{\mathrm{2}}\f$ */
-#define TMP006_CCONST_LSB_SIZE 156.25E-9 /* Sensor Voltage Register LSB Size */
-
-typedef enum {
-    TMP006_SEN,
-    TMP007_SEN } tmp_t;
-
-namespace upm {
-
-/**
- * @brief TMP006 Infrared-Thermopile Sensor
- * @defgroup tmp006 libupm-tmp006
- * @ingroup ti i2c temp
- */
-
-/**
- * @library tmp006
- * @sensor tmp006
- * @comname TMP006 IR-Thermopile Sensor
- * @type temp
- * @man ti
- * @web http://www.ti.com/product/TMP006/datasheet/abstract#SBOS5183423
- * @con i2c
- *
- * @brief API for the TMP006 IR-Thermopile Sensor
- *
- * Description in web-link above:
- * The TMP006 and TMP006B are fully integrated MEMs thermopile sensors that
- * measure the temperature of an object without having to be in direct contact.
- * The thermopile absorbs passive infrared energy from an object at wavelengths
- * between 4 um to 16 um within the end-user defined field of view.
- * The corresponding change in voltage across the thermopile is digitized and
- * reported with the on-chip die thermal sensor measurement through an I2C- and
- * SMBus-compatible interface. With this data, the target object temperature
- * can be calculated by an external processor.
- * The Infrared thermopile sensor is specified to operate from 
- * -40 to +125 [degC]. It is possible to measure an object temperature beyond
- * the device operating range as long as the device itself does not exceed the
- * operating temperature range (-40 to +125 [degC]).
- *
- * @snippet tmp006.cxx Interesting
- */
-class TMP006 {
-    public:
-        /**
-         *
-         * Instantiates an TMP006 object
-         *
-         * @param bus Number of the used bus
-         * @param conv_rate Conversation rate (allowed between 0 and 4)
-         * @param devAddr Address of the used I2C device
-         */
-        TMP006 (int bus, uint8_t conv_rate=TMP006_CONFIG_CR_DEF,
-                                  int devAddr=TMP006_I2C_ADDRESS);
-
-        /**
-         * Check device_id of sensor
-         *
-         * @return  0 on succes
-         *         -1 on error
-         */
-        int checkID(void);
-
-        /**
-         * Performs a soft reset of the TMP006 device to ensure
-         * it is in a known state.
-         */
-        void resetSensor(void);
-
-        /**
-         * Set active mode, this enables periodic measurements.
-         */
-        void setActive(void);
-
-        /**
-         * Set standby mode, this disables periodic measurements.
-         */
-        void setStandby(void);
-
-        /**
-         * Read out data of regs and call further function
-         * Also saves converted value to variable
-         */
-        int sampleData(void);
-
-        /**
-         * Convert raw sensor values to temperature.
-         *
-         * @param rawv Object voltage value
-         * @param rawt Raw die temperature value
-         * @param tamb Converted ambient temperature
-         * @param tobj Converted object temperature
-         */
-        void convert_data(int16_t rawv,int16_t rawt, float *tamb, float *tobj);
-
-        /**
-         * Get the calculated object temperature [degC]
-         *
-         * @param bSampleData Flag to read sensor
-         * @return The object temp in degC on success
-         *         and -273.2 on 'conversation in progress'
-         */
-        float getTemperature(int bSampleData = 0);
-
-        /**
-         * Get value of configuration reg
-         */
-        uint16_t getConfig(void);
-
-    private:
-
-        std::string m_name;
-
-        int m_controlAddr;
-        int m_bus;
-        mraa::I2c m_i2ControlCtx;
-        tmp_t sensorType;
-
-        int32_t m_temperature;
-};
-
-}
diff --git a/src/tmp006/tmp006.json b/src/tmp006/tmp006.json
deleted file mode 100644
index 7b8b856..0000000
--- a/src/tmp006/tmp006.json
+++ /dev/null
@@ -1,50 +0,0 @@
-{
-    "Library": "tmp006",
-    "Description": "Texas Instruments TMP006 Infrared-Thermopile Sensor Library",
-    "Sensor Class": {
-        "TMP006": {
-            "Name": "API for the Texas Instruments TMP006 IR-Thermopile Sensor",
-            "Description": "This is the UPM Module for the Texas Instruments TMP006 IR-Thermopile Sensor. The TMP006 and TMP006B are fully integrated MEMs thermopile sensors that measure the temperature of an object without having to be in direct contact. The thermopile absorbs passive infrared energy from an object at wavelengths between 4 um to 16 um within the end-user defined field of view. The corresponding change in voltage across the thermopile is digitized and reported with the on-chip die thermal sensor measurement through an I2C- and SMBus-compatible interface. With this data, the target object temperature can be calculated by an external processor.",
-            "Aliases": ["tmp006", "TMP006 Infrared Thermopile Contactless Temperature Sensor in WCSP Package"],
-            "Categories": ["temperature"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping", "industrial", "commercial"],
-            "Manufacturers": ["Texas Instruments"],
-            "Examples": {
-                "Python": ["tmp006.py"],
-                "C++": ["tmp006.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 2.5,
-                    "max": 5.5
-                },
-                "Supply Current": {
-                    "unit": "uA",
-                    "min" : 1.0,
-                    "max" : 325.0
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -40,
-                    "max": 125
-                },
-                "Effective Range": {
-                    "unit": "°C",
-                    "min" : 0,
-                    "max" : 60
-                },
-                "Accuracy": {
-                    "unit": "-/+ °C",
-                    "min" : 0.5,
-                    "max" : 1.0
-                }
-            },
-            "Urls": {
-                "Product Pages": ["http://www.ti.com/product/TMP006/datasheet/abstract#SBOS5183423"],
-                "Datasheets": ["http://www.ti.com/lit/ds/symlink/tmp006.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/tsl2561/CMakeLists.txt b/src/tsl2561/CMakeLists.txt
deleted file mode 100644
index 9fe0d99..0000000
--- a/src/tsl2561/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME tsl2561
-    DESCRIPTION "Digital Light Sensor"
-    C_HDR tsl2561.h
-    C_SRC tsl2561.c
-    CPP_HDR tsl2561.hpp
-    CPP_SRC tsl2561.cxx
-    FTI_SRC tsl2561_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/tsl2561/tsl2561.c b/src/tsl2561/tsl2561.c
deleted file mode 100644
index 0b67137..0000000
--- a/src/tsl2561/tsl2561.c
+++ /dev/null
@@ -1,245 +0,0 @@
-/*
- * Author: Nandkishor Sonar <Nandkishor.Sonar@intel.com>,
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * LIGHT-TO-DIGITAL CONVERTER [TAOS-TSL2561]
- *   Inspiration and lux calculation formulas from data sheet
- *   URL: http://www.adafruit.com/datasheets/TSL2561.pdf
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "tsl2561.h"
-#include "upm_utilities.h"
-
-// forward declaration
-upm_result_t tsl2561_compute_lux(const tsl2561_context dev, int *int_data);
-
-tsl2561_context tsl2561_init(int bus, uint8_t dev_address, uint8_t gain,
-                             uint8_t integration_time){
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        return NULL;
-    }
-
-    tsl2561_context dev =
-      (tsl2561_context)malloc(sizeof(struct _tsl2561_context));
-
-    if (!dev)
-        return NULL;
-
-    dev->bus = bus;
-    dev->address = dev_address;
-    dev->gain = gain;
-    dev->integration_time = integration_time;
-
-    dev->i2c = mraa_i2c_init(dev->bus);
-    if(dev->i2c == NULL){
-        free(dev);
-        return NULL;
-    }
-
-    if (mraa_i2c_address(dev->i2c, dev->address) != MRAA_SUCCESS)
-        {
-            mraa_i2c_stop(dev->i2c);
-            free(dev);
-            return NULL;
-        }
-
-    // POWER UP.
-    if(mraa_i2c_write_byte_data(dev->i2c, CONTROL_POWERON, REGISTER_Control) != MRAA_SUCCESS){
-        mraa_i2c_stop(dev->i2c);
-        free(dev);
-        return NULL;
-    }
-
-    // Power on Settling time
-    upm_delay_us(1000);
-
-    // Gain & Integration time.
-    if(mraa_i2c_write_byte_data(dev->i2c, (dev->gain | dev->integration_time), REGISTER_Timing) != MRAA_SUCCESS){
-        mraa_i2c_stop(dev->i2c);
-        free(dev);
-        return NULL;
-    }
-
-    // Set interrupt threshold to default.
-    if(mraa_i2c_write_byte_data(dev->i2c, 0x00, REGISTER_Interrupt) != MRAA_SUCCESS){
-        mraa_i2c_stop(dev->i2c);
-        free(dev);
-        return NULL;
-    }
-
-    return dev;
-}
-
-void tsl2561_close(tsl2561_context dev){
-    if (mraa_i2c_write_byte_data(dev->i2c, CONTROL_POWEROFF,
-                                 REGISTER_Control) != MRAA_SUCCESS){
-        printf("Unable turn off device\n");
-    }
-
-    mraa_i2c_stop(dev->i2c);
-    free(dev);
-}
-
-upm_result_t tsl2561_get_lux(const tsl2561_context dev, float* lux){
-    int lux_val=0;
-
-    tsl2561_compute_lux(dev, &lux_val);
-
-    *lux = (float) lux_val;
-    return UPM_SUCCESS;
-}
-
-upm_result_t tsl2561_i2c_write_reg(tsl2561_context dev, uint8_t reg,
-                                   uint8_t value){
-    // Write register to I2C
-    if(mraa_i2c_write_byte(dev->i2c, reg) != MRAA_SUCCESS){
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // Write value to I2C
-    if(mraa_i2c_write_byte(dev->i2c, value) != MRAA_SUCCESS){
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    upm_delay_ms(100);
-    return UPM_SUCCESS;
-}
-
-upm_result_t tsl2561_i2c_read_reg(tsl2561_context dev, uint8_t reg,
-                                  uint8_t* data){
-    // Send address of register to be read.
-    if(mraa_i2c_write_byte(dev->i2c, reg) != MRAA_SUCCESS){
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    // Read byte.
-    *data = mraa_i2c_read_byte(dev->i2c);
-
-    //upm_delay(1);
-    return UPM_SUCCESS;
-}
-
-upm_result_t tsl2561_compute_lux(const tsl2561_context dev, int *int_data) {
-    int lux;
-    uint16_t raw_lux_ch_0;
-    uint16_t raw_lux_ch_1;
-    uint8_t ch0_low, ch0_high, ch1_low, ch1_high;
-
-    if (tsl2561_i2c_read_reg(dev, REGISTER_Channal0L, &ch0_low) != UPM_SUCCESS){
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    if(tsl2561_i2c_read_reg(dev, REGISTER_Channal0H, &ch0_high) != UPM_SUCCESS){
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-    raw_lux_ch_0 = ch0_high*256 + ch0_low;
-
-    if(tsl2561_i2c_read_reg(dev, REGISTER_Channal1L, &ch1_low) != UPM_SUCCESS){
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    if(tsl2561_i2c_read_reg(dev, REGISTER_Channal1H, &ch1_high) != UPM_SUCCESS){
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-    raw_lux_ch_1 = ch1_high*256 + ch1_low;
-
-    uint64_t scale = 0;
-
-    switch(dev->integration_time){
-        case 0: // 13.7 msec
-            scale = LUX_CHSCALE_TINT0;
-            break;
-        case 1: // 101 msec
-            scale = LUX_CHSCALE_TINT1;
-            break;
-        case 2: // assume no scaling
-            scale = (1 << LUX_CHSCALE);
-            break;
-    }
-
-    // scale if gain is NOT 16X
-    if(!dev->gain)
-        scale = scale << 4;
-
-    uint64_t channel1 = 0;
-    uint64_t channel0 = 0;
-
-    // scale the channel values
-    channel0 = (raw_lux_ch_0 * scale) >> LUX_CHSCALE;
-    channel1 = (raw_lux_ch_1 * scale) >> LUX_CHSCALE;
-
-    // find the ratio of the channel values (Channel1/Channel0)
-    // protect against divide by zero
-    uint64_t ratio_1 = 0;
-    if (channel0 != 0)
-        ratio_1 = (channel1 << (LUX_RATIOSCALE+1)) / channel0;
-
-    // round the ratio value
-    int64_t ratio = (ratio_1 + 1) >> 1;
-    unsigned int b = 0, m = 0;
-
-    // CS package
-    // Check if ratio <= eachBreak ?
-    if ((ratio >= 0) && (ratio <= LUX_K1C)){
-        b=LUX_B1C; m=LUX_M1C;
-    }
-    else if (ratio <= LUX_K2C){
-        b=LUX_B2C; m=LUX_M2C;
-    }
-    else if (ratio <= LUX_K3C){
-        b=LUX_B3C; m=LUX_M3C;
-    }
-    else if (ratio <= LUX_K4C){
-        b=LUX_B4C; m=LUX_M4C;
-    }
-    else if (ratio <= LUX_K5C){
-        b=LUX_B5C; m=LUX_M5C;
-    }
-    else if (ratio <= LUX_K6C){
-        b=LUX_B6C; m=LUX_M6C;
-    }
-    else if (ratio <= LUX_K7C){
-        b=LUX_B7C; m=LUX_M7C;
-    }
-    else if (ratio > LUX_K8C){
-        b=LUX_B8C; m=LUX_M8C;
-    }
-    int64_t temp_lux = 0;
-    temp_lux = ((channel0 * b) - (channel1 * m));
-    // do not allow negative lux value
-    if (temp_lux < 0) temp_lux = 0;
-
-    // round lsb (2^(LUX_SCALE-1))
-    temp_lux += (1 << (LUX_SCALE-1));
-
-    // strip off fractional portion
-    lux = temp_lux >> LUX_SCALE;
-
-    *int_data = lux;
-
-    return UPM_SUCCESS;
-}
diff --git a/src/tsl2561/tsl2561.cxx b/src/tsl2561/tsl2561.cxx
deleted file mode 100644
index 0876a92..0000000
--- a/src/tsl2561/tsl2561.cxx
+++ /dev/null
@@ -1,235 +0,0 @@
-/*
- * Author: Nandkishor Sonar <Nandkishor.Sonar@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * LIGHT-TO-DIGITAL CONVERTER [TAOS-TSL2561]
- *   Inspiration and lux calculation formulas from data sheet
- *   URL: http://www.adafruit.com/datasheets/TSL2561.pdf
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-
-#include <string>
-#include <stdexcept>
-#include <unistd.h>
-#include "tsl2561.hpp"
-
-using namespace upm;
-
-
-TSL2561::TSL2561(int bus, uint8_t devAddr, uint8_t gain, uint8_t integrationTime)
-                                                : m_i2ControlCtx(bus)
-{
-    m_controlAddr = devAddr;
-    m_bus = bus;
-    m_gain = gain ;
-    m_integrationTime = integrationTime;
-
-    m_name = "TSL2561- Digital Light Sensor";
-
-    mraa::Result error = m_i2ControlCtx.address(m_controlAddr);
-    if (error != mraa::SUCCESS) {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_i2c_address() failed");
-        return;
-    }
-
-    // POWER UP.
-    error = m_i2ControlCtx.writeReg(REGISTER_Control, CONTROL_POWERON);
-    if (error != mraa::SUCCESS) {
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": Unable to power up TSL2561");
-        return;
-    }
-    // Power on Settling time
-    usleep(1000);
-
-    // Gain & Integration time .
-    error = m_i2ControlCtx.writeReg(REGISTER_Timing, m_gain | m_integrationTime);
-    if (error != mraa::SUCCESS) {
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": Unable to set gain/time");
-        return;
-    }
-
-    // Set interrupt threshold to default.
-    error = m_i2ControlCtx.writeReg(REGISTER_Interrupt, 0x00);
-    if (error != mraa::SUCCESS) {
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": Unable to set interrupt threshold");
-        return;
-    }
-}
-
-TSL2561::~TSL2561()
-{
-    // POWER DOWN
-    m_i2ControlCtx.writeReg(REGISTER_Control, CONTROL_POWEROFF);
-}
-
-int
-TSL2561::getLux()
-{
-    mraa::Result error = mraa::SUCCESS;
-    int lux;
-    uint16_t rawLuxCh0;
-    uint16_t rawLuxCh1;
-    uint8_t ch0_low, ch0_high, ch1_low, ch1_high;
-
-    error = i2cReadReg(REGISTER_Channal0L, ch0_low);
-    if (error != mraa::SUCCESS) {
-        fprintf(stderr, "Error: Unable to read channel0L in getRawLux()\n");
-        return error;
-    }
-
-    error = i2cReadReg(REGISTER_Channal0H, ch0_high);
-    if (error != mraa::SUCCESS) {
-        fprintf(stderr, "Error: Unable to read channel0H in getRawLux()\n");
-        return error;
-    }
-
-    rawLuxCh0 = ch0_high*256+ch0_low;
-
-    error= i2cReadReg(REGISTER_Channal1L, ch1_low);
-    if (error != mraa::SUCCESS) {
-        fprintf(stderr, "Error: Unable to read channel1L in getRawLux()\n");
-        return error;
-    }
-
-    error = i2cReadReg(REGISTER_Channal1H, ch1_high);
-    if (error != mraa::SUCCESS) {
-        fprintf(stderr, "Error: Unable to read channel1H in getRawLux()\n");
-        return error;
-    }
-
-    rawLuxCh1 = ch1_high*256+ch1_low;
-
-    uint64_t scale = 0;
-
-    switch (m_integrationTime)
-    {
-      case 0: // 13.7 msec
-         scale = LUX_CHSCALE_TINT0;
-      break;
-      case 1: // 101 msec
-         scale = LUX_CHSCALE_TINT1;
-      break;
-      default: // assume no scaling
-         scale = (1 << LUX_CHSCALE);
-      break;
-    }
-
-    // scale if gain is NOT 16X
-    if (!m_gain) scale = scale << 4;
-
-    uint64_t channel1 = 0;
-    uint64_t channel0 = 0;
-    // scale the channel values
-    channel0 = (rawLuxCh0 * scale) >> LUX_CHSCALE;
-    channel1 = (rawLuxCh1 * scale) >> LUX_CHSCALE;
-
-    // find the ratio of the channel values (Channel1/Channel0)
-    // protect against divide by zero
-    unsigned long ratio1 = 0;
-    if (channel0 != 0) ratio1 = (channel1 << (LUX_RATIOSCALE+1)) / channel0;
-
-    // round the ratio value
-    int64_t ratio = (ratio1 + 1) >> 1;
-
-    unsigned int b = 0, m = 0;
-
-    // CS package
-    // Check if ratio <= eachBreak ?
-    if ((ratio >= 0) && (ratio <= LUX_K1C))
-       {b=LUX_B1C; m=LUX_M1C;}
-    else if (ratio <= LUX_K2C)
-       {b=LUX_B2C; m=LUX_M2C;}
-    else if (ratio <= LUX_K3C)
-       {b=LUX_B3C; m=LUX_M3C;}
-    else if (ratio <= LUX_K4C)
-       {b=LUX_B4C; m=LUX_M4C;}
-    else if (ratio <= LUX_K5C)
-       {b=LUX_B5C; m=LUX_M5C;}
-    else if (ratio <= LUX_K6C)
-       {b=LUX_B6C; m=LUX_M6C;}
-    else if (ratio <= LUX_K7C)
-       {b=LUX_B7C; m=LUX_M7C;}
-    else if (ratio > LUX_K8C)
-       {b=LUX_B8C; m=LUX_M8C;}
-
-    int64_t tempLux = 0;
-    tempLux = ((channel0 * b) - (channel1 * m));
-    // do not allow negative lux value
-    if (tempLux < 0) tempLux = 0;
-
-    // round lsb (2^(LUX_SCALE-1))
-    tempLux += (1 << (LUX_SCALE-1));
-
-    // strip off fractional portion
-    lux = tempLux >> LUX_SCALE;
-
-    return lux;
-}
-
-
-mraa::Result
-TSL2561::i2cWriteReg (uint8_t reg, uint8_t value)
-{
-    mraa::Result error = mraa::SUCCESS;
-
-    // Write register to I2C
-    error = m_i2ControlCtx.writeByte (reg);
-    if (error != mraa::SUCCESS) {
-        fprintf(stderr, "Error: on i2c bus write reg in i2cWriteReg()\n");
-        return error;
-    }
-
-    // Write value to I2C
-    error = m_i2ControlCtx.writeByte (value);
-    if (error != mraa::SUCCESS) {
-        fprintf(stderr, "Error: on i2c bus write value in i2cWriteReg()\n");
-        return error;
-    }
-
-    usleep(100000);
-
-    return error;
-}
-
-mraa::Result
-TSL2561::i2cReadReg(uint8_t reg, uint8_t &data)
-{
-    mraa::Result error = mraa::SUCCESS;
-
-    // Send address of register to be read.
-    error = m_i2ControlCtx.writeByte(reg);
-    if (error != mraa::SUCCESS) {
-        fprintf(stderr, "Error: on i2c bus write in i2cReadReg()\n");
-        return error;
-    }
-
-    // Read byte.
-    data = m_i2ControlCtx.readByte();
-
-    usleep(10000);
-
-    return error;
-}
diff --git a/src/tsl2561/tsl2561.h b/src/tsl2561/tsl2561.h
deleted file mode 100644
index 856ac4b..0000000
--- a/src/tsl2561/tsl2561.h
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
- * Author: Nandkishor Sonar <Nandkishor.Sonar@intel.com>,
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * LIGHT-TO-DIGITAL CONVERTER [TAOS-TSL2561]
- *   Inspiration and lux calculation formulas from data sheet
- *   URL: http://www.adafruit.com/datasheets/TSL2561.pdf
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef TSL2561_H_
-#define TSL2561_H_
-
-#include <stdint.h>
-#include <upm.h>
-#include <mraa/i2c.h>
-
-#define TSL2561_Address          (0x29)  //Device address
-
-// Integration time
-#define  INTEGRATION_TIME0_13MS  (0x00)  // 13.7ms
-#define  INTEGRATION_TIME1_101MS (0x01)  // 101ms
-#define  INTEGRATION_TIME2_402MS (0x02)  // 402ms
-
-// Integration time
-#define  GAIN_0X  (0x00)                // No gain - Low
-#define  GAIN_16X (0x10)                // 16x gain - High
-
-// Power control bits
-#define CONTROL_POWERON   (0x03)        // ON
-#define CONTROL_POWEROFF  (0x00)        // OFF
-
-// TSL2561 registers
-#define  REGISTER_Control   (0x80)
-#define  REGISTER_Timing    (0x81)
-#define  REGISTER_Interrupt (0x86)
-#define  REGISTER_Channal0L (0x8C)
-#define  REGISTER_Channal0H (0x8D)
-#define  REGISTER_Channal1L (0x8E)
-#define  REGISTER_Channal1H (0x8F)
-
-// Lux calculations differ slightly for CS package
-#define LUX_SCALE         (14)      // Scale by 2^14
-#define LUX_RATIOSCALE    (9)       // Scale ratio by 2^9
-#define LUX_CHSCALE       (10)      // Scale channel values by 2^10
-#define LUX_CHSCALE_TINT0 (0x7517)  // 322/11 * 2^TSL2561_LUX_CHSCALE
-#define LUX_CHSCALE_TINT1 (0x0FE7)  // 322/81 * 2^TSL2561_LUX_CHSCALE
-
-// CS package Coefficients
-#define LUX_K1C           (0x0043)  // 0.130 * 2^RATIO_SCALE
-#define LUX_B1C           (0x0204)  // 0.0315 * 2^LUX_SCALE
-#define LUX_M1C           (0x01ad)  // 0.0262 * 2^LUX_SCALE
-#define LUX_K2C           (0x0085)  // 0.260 * 2^RATIO_SCALE
-#define LUX_B2C           (0x0228)  // 0.0337 * 2^LUX_SCALE
-#define LUX_M2C           (0x02c1)  // 0.0430 * 2^LUX_SCALE
-#define LUX_K3C           (0x00c8)  // 0.390 * 2^RATIO_SCALE
-#define LUX_B3C           (0x0253)  // 0.0363 * 2^LUX_SCALE
-#define LUX_M3C           (0x0363)  // 0.0529 * 2^LUX_SCALE
-#define LUX_K4C           (0x010a)  // 0.520 * 2^RATIO_SCALE
-#define LUX_B4C           (0x0282)  // 0.0392 * 2^LUX_SCALE
-#define LUX_M4C           (0x03df)  // 0.0605 * 2^LUX_SCALE
-#define LUX_K5C           (0x014d)  // 0.65 * 2^RATIO_SCALE
-#define LUX_B5C           (0x0177)  // 0.0229 * 2^LUX_SCALE
-#define LUX_M5C           (0x01dd)  // 0.0291 * 2^LUX_SCALE
-#define LUX_K6C           (0x019a)  // 0.80 * 2^RATIO_SCALE
-#define LUX_B6C           (0x0101)  // 0.0157 * 2^LUX_SCALE
-#define LUX_M6C           (0x0127)  // 0.0180 * 2^LUX_SCALE
-#define LUX_K7C           (0x029a)  // 1.3 * 2^RATIO_SCALE
-#define LUX_B7C           (0x0037)  // 0.00338 * 2^LUX_SCALE
-#define LUX_M7C           (0x002b)  // 0.00260 * 2^LUX_SCALE
-#define LUX_K8C           (0x029a)  // 1.3 * 2^RATIO_SCALE
-#define LUX_B8C           (0x0000)  // 0.000 * 2^LUX_SCALE
-#define LUX_M8C           (0x0000)  // 0.000 * 2^LUX_SCALE
-
-/**
- * @file tsl2561.h
- * @library tsl2561
- * @brief C API for the TSL2561 Digital Light Sensor
- *
- * @include tsl2561.c
- */
-
-/**
- * device context
- */
-typedef struct _tsl2561_context {
-    mraa_i2c_context    i2c;
-    int                 bus;
-    uint8_t             address;
-    uint8_t             gain;
-    uint8_t             integration_time;
-} *tsl2561_context;
-
-/**
- * Sensor Init Function
- *
- * @param bus I2C bus
- * @param dev_address I2C address
- * @param gain Gain associated with the driver
- * @param integration_time Time to keep the shutter open
- * @return void* pointer to the sensor struct
- */
-tsl2561_context tsl2561_init(int bus, uint8_t dev_address, uint8_t gain,
-                             uint8_t integration_time);
-
-/**
- * Closes the sensor module
- *
- * @param dev pointer to the sensor struct
- */
-void tsl2561_close(tsl2561_context dev);
-
-/**
- * Gets the Lux value
- *
- * @param dev pointer to the sensor struct
- * @param lux pointer to store the lux value
- * @return upm_result_t UPM success/error code
- */
-upm_result_t tsl2561_get_lux(const tsl2561_context, float* lux);
-
-/**
- * Write I2C register on the device
- *
- * @param dev pointer to the sensor struct
- * @param reg register to write value to
- * @param value the value to be written
- * @return upm_result_t UPM success/error code
- */
-upm_result_t tsl2561_i2c_write_reg(tsl2561_context dev, uint8_t reg,
-                                   uint8_t value);
-
-/**
- * Read from an I2C register from the device
- *
- * @param dev pointer to the sensor struct
- * @param reg register to write value to
- * @param data Data read in  from the register
- * @return upm_result_t UPM success/error code
- */
-upm_result_t tsl2561_i2c_read_reg(tsl2561_context dev, uint8_t reg,
-                                  uint8_t* data);
-
-
-#endif /* TSL2561_H_ */
diff --git a/src/tsl2561/tsl2561.hpp b/src/tsl2561/tsl2561.hpp
deleted file mode 100644
index 498d4f7..0000000
--- a/src/tsl2561/tsl2561.hpp
+++ /dev/null
@@ -1,171 +0,0 @@
-/*
- * Author: Nandkishor Sonar <Nandkishor.Sonar@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * LIGHT-TO-DIGITAL CONVERTER [TAOS-TSL2561]
- *   Inspiration and lux calculation formulas from data sheet
- *   URL: http://www.adafruit.com/datasheets/TSL2561.pdf
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <string>
-#include <mraa/i2c.hpp>
-#include <math.h>
-
-namespace upm {
-
-#define TSL2561_Address          (0x29)  //Device address
-
-// Integration time
-#define  INTEGRATION_TIME0_13MS  (0x00)  // 13.7ms
-#define  INTEGRATION_TIME1_101MS (0x01)  // 101ms
-#define  INTEGRATION_TIME2_402MS (0x02)  // 402ms
-
-// Integration time
-#define  GAIN_0X  (0x00)                // No gain - Low
-#define  GAIN_16X (0x10)                // 16x gain - High
-
-// Power control bits
-#define CONTROL_POWERON   (0x03)        // ON
-#define CONTROL_POWEROFF  (0x00)        // OFF
-
-// TSL2561 registers
-#define  REGISTER_Control   (0x80)
-#define  REGISTER_Timing    (0x81)
-#define  REGISTER_Interrupt (0x86)
-#define  REGISTER_Channal0L (0x8C)
-#define  REGISTER_Channal0H (0x8D)
-#define  REGISTER_Channal1L (0x8E)
-#define  REGISTER_Channal1H (0x8F)
-
-// Lux calculations differ slightly for CS package
-#define LUX_SCALE         (14)      // Scale by 2^14
-#define LUX_RATIOSCALE    (9)       // Scale ratio by 2^9
-#define LUX_CHSCALE       (10)      // Scale channel values by 2^10
-#define LUX_CHSCALE_TINT0 (0x7517)  // 322/11 * 2^TSL2561_LUX_CHSCALE
-#define LUX_CHSCALE_TINT1 (0x0FE7)  // 322/81 * 2^TSL2561_LUX_CHSCALE
-
-// CS package Coefficients
-#define LUX_K1C           (0x0043)  // 0.130 * 2^RATIO_SCALE
-#define LUX_B1C           (0x0204)  // 0.0315 * 2^LUX_SCALE
-#define LUX_M1C           (0x01ad)  // 0.0262 * 2^LUX_SCALE
-#define LUX_K2C           (0x0085)  // 0.260 * 2^RATIO_SCALE
-#define LUX_B2C           (0x0228)  // 0.0337 * 2^LUX_SCALE
-#define LUX_M2C           (0x02c1)  // 0.0430 * 2^LUX_SCALE
-#define LUX_K3C           (0x00c8)  // 0.390 * 2^RATIO_SCALE
-#define LUX_B3C           (0x0253)  // 0.0363 * 2^LUX_SCALE
-#define LUX_M3C           (0x0363)  // 0.0529 * 2^LUX_SCALE
-#define LUX_K4C           (0x010a)  // 0.520 * 2^RATIO_SCALE
-#define LUX_B4C           (0x0282)  // 0.0392 * 2^LUX_SCALE
-#define LUX_M4C           (0x03df)  // 0.0605 * 2^LUX_SCALE
-#define LUX_K5C           (0x014d)  // 0.65 * 2^RATIO_SCALE
-#define LUX_B5C           (0x0177)  // 0.0229 * 2^LUX_SCALE
-#define LUX_M5C           (0x01dd)  // 0.0291 * 2^LUX_SCALE
-#define LUX_K6C           (0x019a)  // 0.80 * 2^RATIO_SCALE
-#define LUX_B6C           (0x0101)  // 0.0157 * 2^LUX_SCALE
-#define LUX_M6C           (0x0127)  // 0.0180 * 2^LUX_SCALE
-#define LUX_K7C           (0x029a)  // 1.3 * 2^RATIO_SCALE
-#define LUX_B7C           (0x0037)  // 0.00338 * 2^LUX_SCALE
-#define LUX_M7C           (0x002b)  // 0.00260 * 2^LUX_SCALE
-#define LUX_K8C           (0x029a)  // 1.3 * 2^RATIO_SCALE
-#define LUX_B8C           (0x0000)  // 0.000 * 2^LUX_SCALE
-#define LUX_M8C           (0x0000)  // 0.000 * 2^LUX_SCALE
-
- /**
- * @brief TSL2561 Digital Light Sensor
- * @defgroup tsl2561 libupm-tsl2561
- * @ingroup seeed i2c light eak
- */
-/**
- * @library tsl2561
- * @sensor tsl2561
- * @comname Digital Light Sensor
- * @altname Grove Digital Light Sensor
- * @type light
- * @man seeed
- * @web http://www.seeedstudio.com/wiki/Grove_-_Digital_Light_Sensor
- * @con i2c
- * @kit eak
- *
- * @brief API for the TSL2561 Digital Light Sensor
- * 
- *   TSL2560 and TSL2561 are light-to-digital converters that transform
- *   light intensity to a digital signal output capable of a direct I2C (TSL2561) interface
- *
- * @image html tsl2561.jpg
- * @snippet tsl2561.cxx Interesting
- */
-class TSL2561{
-    public:
-       /**
-        * Instantiates a TSL2561 object
-        *
-        * @param bus Number of the used bus
-        * @param devAddr Address of the used I2C device
-        * @param gain Correct gain to use
-        * @param integrationTime Time to keep the shutter open
-        */
-        TSL2561(int bus=0, uint8_t devAddr=TSL2561_Address, uint8_t gain=GAIN_0X, uint8_t integrationTime=INTEGRATION_TIME1_101MS);
-
-       /**
-        * GY65 object destructor; powers down TSL2561 and closes the I2C connection.
-        */
-        ~TSL2561();
-
-       /**
-        * Gets the calculated lux reading from TSL2561
-        *
-        * @return Calculated lux value from the sensor
-        */
-        int getLux();
-
-    private:
-       /**
-        * Writes to a TSL2561 register
-        *
-        * @param reg Addess to write
-        * @param Value to write
-        * @return mraa::Result
-        */
-        mraa::Result i2cWriteReg(uint8_t reg, uint8_t value);
-
-       /**
-        * Reads from a TSL2561 register
-        *
-        * @param reg Addess to read
-        * @param data Byte read from the register
-        * @return mraa::Result
-        */
-        mraa::Result i2cReadReg(uint8_t reg, uint8_t &data);
-
-        int m_bus;
-        std::string m_name;
-        int m_controlAddr;
-        mraa::I2c m_i2ControlCtx;
-
-        uint8_t m_gain;
-        uint8_t m_integrationTime;
-};
-
-}
-
diff --git a/src/tsl2561/tsl2561.json b/src/tsl2561/tsl2561.json
deleted file mode 100644
index cb5d4cf..0000000
--- a/src/tsl2561/tsl2561.json
+++ /dev/null
@@ -1,64 +0,0 @@
-{
-    "Library": "tsl2561",
-    "Description": "TSL2561 Digital Light Sensor library",
-    "Sensor Class": {
-        "TSL2561": {
-            "Name": "API for the TSL2561 Digital Light Sensor",
-            "Description": "This is the UPM Module for the TSL2561 Digital Light Sensor. TSL2560 and TSL2561 are light-to-digital converters that transform light intensity to a digital signal output capable of a direct I2C (TSL2561) interface",
-            "Aliases": ["tsl2561", "Grove - Digital Light Sensor"],
-            "Categories": ["light"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["Seeed", "TAOS"],
-            "Kits": ["eak"],
-            "Image": "tsl2561.jpg",
-            "Examples": {
-                "Java": ["TSL2561_Example.java"],
-                "Python": ["tsl2561.py"],
-                "Node.js": ["tsl2561.js"],
-                "C++": ["tsl2561.cxx"],
-                "C": ["tsl2561.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.3,
-                    "max": 5.1
-                },
-                "Supply Current": {
-                    "unit": "uA",
-                    "min" : 240,
-                    "max" : 600
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -30,
-                    "max": 70
-                },
-                "Effective Range": {
-                    "unit": "Lux",
-                    "min" : 0.1,
-                    "max" : 40000
-                },
-                "Conversion Time": {
-                    "unit": "ms",
-                    "min" : 12,
-                    "max" : 400
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-Digital-Light-Sensor-p-1281.html", "http://wiki.seeed.cc/Grove-Digital_Light_Sensor/"],
-                "Datasheets": ["https://raw.githubusercontent.com/SeeedDocument/Grove-Digital_Light_Sensor/master/res/TSL2561T.pdf"],
-                "Schematics": ["https://github.com/SeeedDocument/Grove-Digital_Light_Sensor/raw/master/res/Digital%20light%20sensor%20v1.0%20Sch.pdf", "https://github.com/SeeedDocument/Grove-Digital_Light_Sensor/raw/master/res/Digital%20light%20sensor%20v1.0%20PCB.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/tsl2561/tsl2561_fti.c b/src/tsl2561/tsl2561_fti.c
deleted file mode 100644
index b3a6026..0000000
--- a/src/tsl2561/tsl2561_fti.c
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Author: Nandkishor Sonar <Nandkishor.Sonar@intel.com>,
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * LIGHT-TO-DIGITAL CONVERTER [TAOS-TSL2561]
- *   Inspiration and lux calculation formulas from data sheet
- *   URL: http://www.adafruit.com/datasheets/TSL2561.pdf
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "tsl2561.h"
-#include "upm_fti.h"
-
-/** 
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_tsl2561_name[] = "TSL2561";
-const char upm_tsl2561_description[] = "Grove Digital Light Sensor";
-const upm_protocol_t upm_tsl2561_protocol[] = {UPM_I2C};
-const upm_sensor_t upm_tsl2561_category[] = {UPM_LIGHT};
-
-// forward declarations
-const upm_sensor_descriptor_t upm_tsl2561_get_descriptor ();
-const void* upm_tsl2561_get_ft(upm_sensor_t sensor_type);
-void* upm_tsl2561_init_name();
-void upm_tsl2561_close(void* dev);
-upm_result_t upm_tsl2561_get_lux(const void* dev, float* lux);
-
-const upm_sensor_descriptor_t upm_tsl2561_get_descriptor (){
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_tsl2561_name;
-    usd.description = upm_tsl2561_description;
-    usd.protocol_size = 1;
-    usd.protocol = upm_tsl2561_protocol;
-    usd.category_size = 1;
-    usd.category = upm_tsl2561_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = &upm_tsl2561_init_name,
-    .upm_sensor_close = &upm_tsl2561_close,
-    .upm_sensor_get_descriptor = &upm_tsl2561_get_descriptor
-};
-
-static const upm_light_ft lft =
-{
-    .upm_light_get_value = &upm_tsl2561_get_lux
-};
-
-const void* upm_tsl2561_get_ft(upm_sensor_t sensor_type){
-    if(sensor_type == UPM_LIGHT){
-        return &lft;
-    }
-    else if(sensor_type == UPM_SENSOR){
-        return &ft;
-    }
-    return NULL;
-}
-
-void* upm_tsl2561_init_name(){
-    return NULL;
-}
-
-void upm_tsl2561_close(void* dev){
-    tsl2561_close((tsl2561_context)dev);
-}
-
-upm_result_t upm_tsl2561_get_lux(const void* dev, float* lux){
-    return tsl2561_get_lux((tsl2561_context)dev, lux);
-}
diff --git a/src/ttp223/CMakeLists.txt b/src/ttp223/CMakeLists.txt
deleted file mode 100644
index dc0450b..0000000
--- a/src/ttp223/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME ttp223
-    DESCRIPTION "Capacitive Touch Sensor"
-    C_HDR ttp223.h
-    C_SRC ttp223.c
-    CPP_HDR ttp223.hpp
-    CPP_SRC ttp223.cxx
-    FTI_SRC ttp223_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa)
diff --git a/src/ttp223/ttp223.c b/src/ttp223/ttp223.c
deleted file mode 100644
index 60761de..0000000
--- a/src/ttp223/ttp223.c
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Author: Sarah Knepper <sarah.knepper@intel.com>
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "ttp223.h"
-
-ttp223_context ttp223_init(int pin) {
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        return NULL;
-    }
-
-    ttp223_context dev = 
-      (ttp223_context) malloc(sizeof(struct _ttp223_context));
-
-    if (dev == NULL) {
-        printf("Unable to allocate space for the sensor struct\n");
-        return NULL;
-    }
-
-    dev->gpio = mraa_gpio_init(pin);
-    mraa_gpio_dir(dev->gpio, MRAA_GPIO_IN);
-    dev->isr_installed = false;
-
-    return dev;
-}
-
-void ttp223_close(ttp223_context dev){
-  mraa_gpio_close(dev->gpio);
-  free(dev);
-}
-
-upm_result_t ttp223_is_pressed(ttp223_context dev, bool* value) {
-    int ret = mraa_gpio_read(dev->gpio);
-
-    if (ret > 0)
-        *value = true;
-    else
-        *value = false;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t upm_ttp223_install_isr(ttp223_context dev,
-                                    mraa_gpio_edge_t edge_level,
-                                    void (*isr)(void *), void *arg){
-    ttp223_uninstall_isr(dev);
-
-    mraa_gpio_isr(dev->gpio, edge_level, isr, arg);
-    dev->isr_installed = true;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t ttp223_uninstall_isr(ttp223_context dev){
-    if (dev->isr_installed)
-        mraa_gpio_isr_exit(dev->gpio);
-
-    dev->isr_installed = false;
-
-    return UPM_SUCCESS;
-}
diff --git a/src/ttp223/ttp223.cxx b/src/ttp223/ttp223.cxx
deleted file mode 100644
index 94cef4e..0000000
--- a/src/ttp223/ttp223.cxx
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Author: Sarah Knepper <sarah.knepper@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string>
-#include <stdexcept>
-
-#include "ttp223.hpp"
-
-using namespace upm;
-
-TTP223::TTP223(unsigned int pin) {
-    // initialize gpio input
-    if ( !(m_gpio = mraa_gpio_init(pin)) )
-      {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_gpio_init() failed, invalid pin?");
-        return;
-      }
-    mraa_gpio_dir(m_gpio, MRAA_GPIO_IN);
-    m_name = "ttp223";
-    m_isrInstalled = false;
-}
-
-TTP223::~TTP223() {
-    // close gpio input
-    mraa_gpio_close(m_gpio);
-}
-
-std::string TTP223::name() {
-    return m_name;
-}
-
-int TTP223::value() {
-    return mraa_gpio_read(m_gpio);
-}
-
-bool TTP223::isPressed() {
-    return this->value() == 1;
-}
-
-
-void TTP223::installISR(mraa::Edge level, void (*isr)(void *), void *arg)
-{
-  if (m_isrInstalled)
-    uninstallISR();
-
-  // install our interrupt handler
-  mraa_gpio_isr(m_gpio, (mraa_gpio_edge_t) level, isr, arg);
-  m_isrInstalled = true;
-}
-
-void TTP223::uninstallISR()
-{
-  mraa_gpio_isr_exit(m_gpio);
-  m_isrInstalled = false;
-}
diff --git a/src/ttp223/ttp223.h b/src/ttp223/ttp223.h
deleted file mode 100644
index c82b0c8..0000000
--- a/src/ttp223/ttp223.h
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Author: Sarah Knepper <sarah.knepper@intel.com>
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef TTP223_H_
-#define TTP223_H_
-
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-
-#include "upm.h"
-#include "mraa/gpio.h"
-
-/**
- * @file ttp223.h
- * @library ttp223
- * @brief C API for the TTP223 Touch Detector Sensor
- *
- * @include ttp223.c
- */
-
-/**
- * device context
- */
-typedef struct _ttp223_context {
-    mraa_gpio_context       gpio;
-    bool                    isr_installed;
-} *ttp223_context;
-
-/**
- * Sensor Init function
- *
- * @param pin The pin number the sensor is attached to
- * @return void* pointer to the sensor struct
- */
-ttp223_context ttp223_init(int pin);
-
-/**
- * Sensor Module close function
- *
- * @param dev pointer to the sensor struct
- */
-void ttp223_close(ttp223_context dev);
-
-/**
- * Function to tell if the sensor is pressed
- *
- * @param dev pointer to the sensor struct
- * @param value pointer to store whether the sensor is pressed or not
- * @result upm_result_t UPM success/error code
- */
-upm_result_t ttp223_is_pressed(ttp223_context dev, bool* value);
-
-/**
- * Installs an interrupt service routine (ISR) to be called when
- * the button is activated or deactivated.
- *
- * @param dev pointer to the sensor struct
- * @param edge_level one of mraa_gpio_edge_t values
- * @param isr pointer to a function to be called on interrupt
- * @param arg pointer to an object to be supplied as an
- * argument to the ISR.
- * @result upm_result_t UPM success/error code
- */
-upm_result_t ttp223_install_isr(ttp223_context dev,
-                                mraa_gpio_edge_t edge_level,
-                                void (*isr)(void *), void *arg);
-
-/**
- * Uninstall a previously installed interrupt handler
- *
- * @param dev pointer to the sensor struct
- * @result upm_result_t UPM success/error code
- */
-upm_result_t ttp223_uninstall_isr(ttp223_context dev);
-
-#endif /* TTP223_H_ */
diff --git a/src/ttp223/ttp223.hpp b/src/ttp223/ttp223.hpp
deleted file mode 100644
index bae7766..0000000
--- a/src/ttp223/ttp223.hpp
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- * Author: Sarah Knepper <sarah.knepper@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/gpio.hpp>
-
-namespace upm {
-/**
- * @brief TTP223 Touch Detector Sensor
- * @defgroup ttp223 libupm-ttp223
- * @ingroup seeed gpio touch
- */
-/**
- * @library ttp223
- * @sensor ttp223
- * @comname Capacitive Touch Sensor
- * @altname Grove Touch Sensor
- * @type touch
- * @man seeed
- * @web http://www.seeedstudio.com/depot/Grove-Touch-Sensor-p-747.html
- * @con gpio
- *
- * @brief API for the TTP223 Touch Sensor
- *
- *   This touch sensor detects when a finger is near the metallic pad
- *   by the change in capacitance. It can replace a more traditional push
- *   button. The touch sensor can still function when placed under a
- *   non-metallic surface like glass or plastic.
- *
- * @image html ttp223.jpg
- * @snippet ttp223.cxx Interesting
- */
-class TTP223 {
-    public:
-        /**
-         * TTP223 constructor
-         *
-         * @param pin GPIO pin where the sensor is connected
-         */
-        TTP223(unsigned int pin);
-
-        /**
-         * TTP223 destructor
-         */
-        ~TTP223();
-
-        /**
-         * Returns the name of this sensor
-         *
-         * @return Name of this sensor
-         */
-        std::string name();
-
-        /**
-         * Gets the value from the GPIO pin
-         *
-         * @return Value from the GPIO pin
-         */
-        int value();
-
-        /**
-         * Determines whether the touch sensor is being touched
-         *
-         * @return True if touched, false otherwise
-         */
-        bool isPressed();
-
-        /**
-         * Installs an interrupt service routine (ISR) to be called when
-         * the button is activated or deactivated.
-         *
-         * @param isr Pointer to a function to be called on interrupt
-         * @param arg Pointer to an object to be supplied as an
-         * argument to the ISR.
-         */
-
-        void installISR(mraa::Edge level, void (*isr)(void *), void *arg);
-        /**
-         * Uninstalls the previously installed ISR
-         *
-         */
-        void uninstallISR();
-
-    protected:
-        std::string         m_name; //!< name of this sensor
-        mraa_gpio_context   m_gpio; //!< GPIO pin
-        bool                m_isrInstalled;
-};
-
-}
diff --git a/src/ttp223/ttp223.i b/src/ttp223/ttp223.i
deleted file mode 100644
index bba2a34..0000000
--- a/src/ttp223/ttp223.i
+++ /dev/null
@@ -1,20 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%module (docstring="TTP223 Touch Sensor") javaupm_ttp223
-
-%apply int {mraa::Edge}
-
-JAVA_ADD_INSTALLISR_EDGE(upm::TTP223)
-
-JAVA_JNI_LOADLIBRARY(javaupm_ttp223)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "ttp223.hpp"
-%}
-%include "ttp223.hpp"
-/* END Common SWIG syntax */
diff --git a/src/ttp223/ttp223.json b/src/ttp223/ttp223.json
deleted file mode 100644
index 6b89b8a..0000000
--- a/src/ttp223/ttp223.json
+++ /dev/null
@@ -1,58 +0,0 @@
-{
-    "Library": "ttp223",
-    "Description": "Seeed TTP223 Touch Detector Sensor library",
-    "Sensor Class": {
-        "TTP223": {
-            "Name": "API for the Seeed TTP223 Touch Sensor",
-            "Description": "This is the UPM Module for the Seeed TTP223 Touch Sensor. This touch sensor detects when a finger is near the metallic pad by the change in capacitance. It can replace a more traditional push button. The touch sensor can still function when placed under a  non-metallic surface like glass or plastic.",
-            "Aliases": ["ttp223", "Grove - Touch Sensor"],
-            "Categories": ["touch"],
-            "Connections": ["gpio"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["Seeed"],
-            "Image": "ttp223.jpg",
-            "Examples": {
-                "Java": ["TTP223_Example.java"],
-                "Python": ["ttp223.py"],
-                "Node.js": ["ttp223.js"],
-                "C++": ["ttp223.cxx"],
-                "C": ["ttp223.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 2.0,
-                    "max": 5.5
-                },
-                "Supply Current": {
-                    "unit": "uA",
-                    "min" : 1.5,
-                    "max" : 7.0
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -20,
-                    "max": 70
-                },
-                "Response Time": {
-                    "unit": "ms",
-                    "min" : 60,
-                    "max" : 220
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-Touch-Sensor-p-747.html", "http://wiki.seeed.cc/Grove-Touch_Sensor/"],
-                "Datasheets": ["https://raw.githubusercontent.com/SeeedDocument/Grove-Touch_Sensor/master/res/TTP223.pdf"],
-                "Schematics": ["https://raw.githubusercontent.com/SeeedDocument/Grove-Touch_Sensor/master/res/Touch_sensor_Eagle_File.zip"]
-            }
-        }
-    }
-}
diff --git a/src/ttp223/ttp223_fti.c b/src/ttp223/ttp223_fti.c
deleted file mode 100644
index fb7e7db..0000000
--- a/src/ttp223/ttp223_fti.c
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * Author: Sarah Knepper <sarah.knepper@intel.com>
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "ttp223.h"
-#include "upm_fti.h"
-
-/** 
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_ttp223_name[] = "TTP223";
-const char upm_ttp223_description[] = "TTP223 Touch Detector Sensor";
-const upm_protocol_t upm_ttp223_protocol[] = {UPM_GPIO};
-const upm_sensor_t upm_ttp223_category[] = {UPM_SWITCH};
-
-// forward declarations
-const upm_sensor_descriptor_t upm_ttp223_get_descriptor();
-const void* upm_ttp223_get_ft(upm_sensor_t sensor_type);
-void* upm_ttp223_init_name();
-void upm_ttp223_close(void* dev);
-upm_result_t upm_ttp223_is_pressed(void* dev, bool* value, int num);
-
-const upm_sensor_descriptor_t upm_ttp223_get_descriptor(){
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_ttp223_name;
-    usd.description = upm_ttp223_description;
-    usd.protocol_size = 1;
-    usd.protocol = upm_ttp223_protocol;
-    usd.category_size = 1;
-    usd.category = upm_ttp223_category;
-    return usd;
-}
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = &upm_ttp223_init_name,
-    .upm_sensor_close = &upm_ttp223_close,
-    .upm_sensor_get_descriptor = &upm_ttp223_get_descriptor
-};
-
-static const upm_switch_ft sft =
-{
-    .upm_switch_get_value = &upm_ttp223_is_pressed
-};
-
-const void* upm_ttp223_get_ft(upm_sensor_t sensor_type){
-    if(sensor_type == UPM_SWITCH){
-        return &sft;
-    }
-    else if(sensor_type == UPM_SENSOR){
-        return &ft;
-    }
-    return NULL;
-}
-
-void* upm_ttp223_init_name(){
-    return NULL;
-}
-
-void upm_ttp223_close(void* dev){
-    ttp223_close((ttp223_context)dev);
-}
-
-upm_result_t upm_ttp223_is_pressed(void* dev, bool* value, int num) {
-    if(num != 1){
-        printf("Sorry this sensor driver supports only one touch pad\n");
-        return UPM_ERROR_OUT_OF_RANGE;
-    }
-
-    return ttp223_is_pressed((ttp223_context)dev, value);
-}
\ No newline at end of file
diff --git a/src/uartat/CMakeLists.txt b/src/uartat/CMakeLists.txt
deleted file mode 100644
index 4bd5ed7..0000000
--- a/src/uartat/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-upm_mixed_module_init (NAME uartat
-    DESCRIPTION "Generic UART Driver for Serial AT Command Driven Devices"
-    C_HDR uartat.h uartat_defs.h
-    C_SRC uartat.c
-    CPP_HDR uartat.hpp
-    CPP_SRC uartat.cxx
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/uartat/uartat.c b/src/uartat/uartat.c
deleted file mode 100644
index f3ab052..0000000
--- a/src/uartat/uartat.c
+++ /dev/null
@@ -1,410 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string.h>
-#include <assert.h>
-
-#include "uartat.h"
-
-#include "upm_utilities.h"
-
-#define UARTAT_MAX_BUFFER (1024)
-
-// milliseconds
-#define UARTAT_MAX_WAIT   (1000)
-
-// milliseconds
-#define UARTAT_DEFAULT_RESP_DELAY   (250)
-
-static uartat_context _uartat_preinit()
-{
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        return NULL;
-    }
-
-    uartat_context dev =
-        (uartat_context)malloc(sizeof(struct _uartat_context));
-
-    if (!dev)
-        return NULL;
-
-    // zero out context
-    memset((void *)dev, 0, sizeof(struct _uartat_context));
-
-    dev->cmd_resp_wait_ms = UARTAT_DEFAULT_RESP_DELAY;
-
-    return dev;
-}
-
-static uartat_context _uartat_postinit(uartat_context dev,
-                                       unsigned int baudrate)
-{
-    assert(dev != NULL);
-
-    if (uartat_set_baudrate(dev, baudrate))
-    {
-        printf("%s: uartat_set_baudrate() failed.\n", __FUNCTION__);
-        uartat_close(dev);
-        return NULL;
-    }
-
-    if (uartat_set_flow_control(dev, UARTAT_FLOW_CONTROL_NONE))
-    {
-        printf("%s: uartat_set_flow_control() failed.\n", __FUNCTION__);
-        uartat_close(dev);
-        return NULL;
-    }
-
-    return dev;
-}
-
-// uart init
-uartat_context uartat_init(unsigned int uart, unsigned int baudrate)
-{
-    uartat_context dev;
-
-    if (!(dev = _uartat_preinit()))
-        return NULL;
-
-    // initialize the MRAA context
-
-    // uart, default should be 8N1
-    if (!(dev->uart = mraa_uart_init(uart)))
-    {
-        printf("%s: mraa_uart_init() failed.\n", __FUNCTION__);
-        uartat_close(dev);
-        return NULL;
-    }
-
-    return _uartat_postinit(dev, baudrate);
-}
-
-// uart tty init
-uartat_context uartat_init_tty(const char *uart_tty, unsigned int baudrate)
-{
-    uartat_context dev;
-
-    if (!(dev = _uartat_preinit()))
-        return NULL;
-
-    // initialize the MRAA context
-
-    // uart, default should be 8N1
-    if (!(dev->uart = mraa_uart_init_raw(uart_tty)))
-    {
-        printf("%s: mraa_uart_init_raw() failed.\n", __FUNCTION__);
-        uartat_close(dev);
-        return NULL;
-    }
-
-    return _uartat_postinit(dev, baudrate);
-}
-
-void uartat_close(uartat_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->uart)
-        mraa_uart_stop(dev->uart);
-
-    free(dev);
-}
-
-int uartat_read(const uartat_context dev, char *buffer, size_t len)
-{
-    assert(dev != NULL);
-
-    // uart
-    return mraa_uart_read(dev->uart, buffer, len);
-}
-
-int uartat_write(const uartat_context dev, const char *buffer, size_t len)
-{
-    assert(dev != NULL);
-
-    int rv = mraa_uart_write(dev->uart, buffer, len);
-    mraa_uart_flush(dev->uart);
-
-    return rv;
-}
-
-bool uartat_data_available(const uartat_context dev, unsigned int millis)
-{
-    assert(dev != NULL);
-
-    if (mraa_uart_data_available(dev->uart, millis))
-        return true;
-    else
-        return false;
-}
-
-upm_result_t uartat_set_baudrate(const uartat_context dev,
-                                 unsigned int baudrate)
-{
-    assert(dev != NULL);
-
-    if (mraa_uart_set_baudrate(dev->uart, baudrate))
-    {
-        printf("%s: mraa_uart_set_baudrate() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    return UPM_SUCCESS;
-}
-
-void uartat_set_response_wait_time(const uartat_context dev,
-                                   unsigned int wait_time)
-{
-    assert(dev != NULL);
-
-    dev->cmd_resp_wait_ms = wait_time;
-}
-
-bool uartat_command_mode(const uartat_context dev, const char *cmd_chars,
-                         unsigned int guard_ms)
-{
-    assert(dev != NULL);
-
-    uartat_drain(dev);
-
-    upm_delay_ms(guard_ms);
-
-    uartat_write(dev, cmd_chars, strlen(cmd_chars));
-
-    upm_delay_ms(guard_ms);
-
-    char resp[UARTAT_MAX_BUFFER];
-    if (uartat_data_available(dev, UARTAT_MAX_WAIT))
-    {
-        int rv = uartat_read(dev, resp, UARTAT_MAX_BUFFER);
-
-        if (rv > 0 && (strstr(resp, "OK") || strstr(resp, "0")))
-            return true;
-    }
-
-    return false;
-}
-
-bool uartat_in_command_mode(const uartat_context dev)
-{
-    assert(dev != NULL);
-
-    static int buflen = 32;
-    char buffer[buflen];
-
-    if (uartat_command_with_response(dev, "AT\r", buffer, buflen) <= 0)
-        return false;
-
-    // depending on verbosity, you may get "OK" or "0".  Try to catch both.
-    if (strstr(buffer, "OK") || strstr(buffer, "0"))
-        return true;
-    else
-        return false;
-}
-
-void uartat_drain(const uartat_context dev)
-{
-    assert(dev != NULL);
-
-    char resp[UARTAT_MAX_BUFFER];
-    int rv;
-    while (uartat_data_available(dev, 0))
-    {
-        rv = uartat_read(dev, resp, UARTAT_MAX_BUFFER);
-        if (rv < 0)
-        {
-            printf("%s: read failed\n", __FUNCTION__);
-            return;
-        }
-        // printf("%s: Tossed %d bytes\n", __FUNCTION__, rv);
-    }
-
-    return;
-}
-
-int uartat_command_with_response(const uartat_context dev,
-                                 const char *cmd,
-                                 char *resp, size_t resp_len)
-{
-    assert(dev != NULL);
-    assert(cmd != NULL);
-
-    uartat_drain(dev);
-    if (uartat_write(dev, cmd, strlen(cmd)) < 0)
-    {
-        printf("%s: uartat_write failed\n", __FUNCTION__);
-        return -1;
-    }
-
-    if (resp && resp_len > 1)
-    {
-        memset(resp, 0, resp_len);
-
-        upm_clock_t clock = upm_clock_init();
-
-        size_t idx = 0;
-
-        do
-        {
-            if (uartat_data_available(dev, 1))
-            {
-                int rv = uartat_read(dev, &resp[idx], 1);
-
-                if (rv < 0)
-                    return rv;
-
-                if (dev->filter_cr && resp[idx] == '\r')
-                    continue;
-
-                if (idx >= resp_len - 1)
-                    return idx;
-
-                idx++;
-            }
-        } while (upm_elapsed_ms(&clock) < dev->cmd_resp_wait_ms);
-
-        return idx;
-    }
-    else
-    {
-        upm_delay_ms(dev->cmd_resp_wait_ms);
-        uartat_drain(dev);
-    }
-
-    return 0;
-}
-
-bool uartat_command_waitfor(const uartat_context dev, const char *cmd,
-                            char *resp, size_t resp_len,
-                            const char *wait_string,
-                            unsigned int millis)
-{
-    assert(dev != NULL);
-    assert(cmd != NULL);
-    assert(resp != NULL);
-    assert(resp_len > 0);
-    assert(wait_string != NULL);
-
-    uartat_drain(dev);
-    if (uartat_write(dev, cmd, strlen(cmd)) < 0)
-    {
-        printf("%s: uartat_write failed\n", __FUNCTION__);
-        return -1;
-    }
-
-    memset(resp, 0, resp_len);
-
-    upm_clock_t clock = upm_clock_init();
-
-    size_t idx = 0;
-
-    do
-    {
-        if (uartat_data_available(dev, 1))
-        {
-            int rv = uartat_read(dev, &resp[idx], 1);
-
-            if (rv < 0)
-                return false;
-
-            if (dev->filter_cr && resp[idx] == '\r')
-                continue;
-
-            if (idx >= resp_len - 1)
-            {
-                // one last check
-                if (uartat_find(dev, resp, wait_string))
-                    return true;
-                else
-                    return false;
-            }
-            idx++;
-
-            // see if the string is present
-            if (uartat_find(dev, resp, wait_string))
-                return true;
-        }
-    } while (upm_elapsed_ms(&clock) < millis);
-
-    return false;
-}
-
-void uartat_command(const uartat_context dev, const char *cmd)
-{
-    assert(dev != NULL);
-    assert(cmd != NULL);
-
-    uartat_command_with_response(dev, cmd, NULL, 0);
-}
-
-upm_result_t uartat_set_flow_control(const uartat_context dev,
-                                     UARTAT_FLOW_CONTROL_T fc)
-{
-    assert(dev != NULL);
-
-    mraa_result_t rv = MRAA_SUCCESS;
-
-    switch(fc)
-    {
-    case UARTAT_FLOW_CONTROL_NONE:
-        rv = mraa_uart_set_flowcontrol(dev->uart, false, false);
-        break;
-
-    case UARTAT_FLOW_CONTROL_HARD:
-        rv = mraa_uart_set_flowcontrol(dev->uart, false, true);
-        break;
-
-    case UARTAT_FLOW_CONTROL_SOFT:
-        rv = mraa_uart_set_flowcontrol(dev->uart, true, false);
-        break;
-
-    default:
-        return UPM_ERROR_INVALID_PARAMETER;
-    }
-
-    if (rv == MRAA_SUCCESS)
-        return UPM_SUCCESS;
-    else
-        return UPM_ERROR_OPERATION_FAILED;
-}
-
-bool uartat_find(const uartat_context dev, const char *buffer, const char *str)
-{
-    assert(dev != NULL);
-    assert(buffer != NULL);
-    assert(str != NULL);
-
-    return ((strstr(buffer, str)) ? true : false);
-}
-
-void uartat_filter_cr(const uartat_context dev, bool enable)
-{
-    assert(dev != NULL);
-
-    dev->filter_cr = enable;
-}
diff --git a/src/uartat/uartat.cxx b/src/uartat/uartat.cxx
deleted file mode 100644
index 9d4d99c..0000000
--- a/src/uartat/uartat.cxx
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <stdexcept>
-#include <string.h>
-
-#include "uartat.hpp"
-
-using namespace upm;
-using namespace std;
-
-UARTAT::UARTAT(unsigned int uart, unsigned int baudrate) :
-    m_uartat(uartat_init(uart, baudrate))
-{
-    if (!m_uartat)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": uartat_init() failed");
-}
-
-UARTAT::UARTAT(string uart_path, unsigned int baudrate) :
-    m_uartat(uartat_init_tty(uart_path.c_str(), baudrate))
-{
-    if (!m_uartat)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": uartat_init_tty() failed");
-}
-
-UARTAT::~UARTAT()
-{
-    uartat_close(m_uartat);
-}
-
-std::string UARTAT::readStr(size_t size)
-{
-    char buffer[size];
-
-    int rv;
-
-    if ((rv = uartat_read(m_uartat, buffer, size)) < 0)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": uartat_read() failed");
-
-    return string(buffer, rv);
-}
-
-int UARTAT::writeStr(std::string buffer)
-{
-    int rv;
-
-    if ((rv = uartat_write(m_uartat, (char*)buffer.data(),
-                           buffer.size())) < 0)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": uartat_write() failed");
-
-    return rv;
-}
-
-void UARTAT::setBaudrate(unsigned int baudrate)
-{
-    if (uartat_set_baudrate(m_uartat, baudrate))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": uartat_baudrate() failed");
-}
-
-void UARTAT::setResponseWaitTime(unsigned int wait_time)
-{
-    uartat_set_response_wait_time(m_uartat, wait_time);
-}
-
-bool UARTAT::dataAvailable(unsigned int millis)
-{
-    return uartat_data_available(m_uartat, millis);
-}
-
-bool UARTAT::commandMode(std::string cmd_chars, unsigned int guard_ms)
-{
-    return uartat_command_mode(m_uartat, cmd_chars.c_str(), guard_ms);
-}
-
-bool UARTAT::inCommandMode()
-{
-    return uartat_in_command_mode(m_uartat);
-}
-
-void UARTAT::drain()
-{
-    uartat_drain(m_uartat);
-    return;
-}
-
-string UARTAT::commandWithResponse(const string cmd, size_t resp_len)
-{
-    char buffer[resp_len];
-
-    int rv;
-
-    if ((rv = uartat_command_with_response(m_uartat, cmd.c_str(), buffer,
-                                           resp_len)) < 0)
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": uartat_command_with_response() failed");
-
-    return string(buffer, rv);
-}
-
-string UARTAT::commandWaitFor(const std::string cmd, size_t resp_len,
-                              const std::string waitString,
-                              unsigned int millis)
-{
-    char buffer[resp_len];
-
-    if (uartat_command_waitfor(m_uartat, cmd.c_str(), buffer, resp_len,
-                               waitString.c_str(), millis))
-        return string(buffer, strlen(buffer));
-    else
-        return string("");
-}
-
-void UARTAT::command(const string cmd)
-{
-    uartat_command(m_uartat, cmd.c_str());
-
-    return;
-}
-
-string UARTAT::stringCR2LF(string str)
-{
-  for (size_t i=0; i<str.size(); i++)
-    if (str[i] == '\r')
-      str[i] = '\n';
-
-  return str;
-}
-
-void UARTAT::setFlowControl(UARTAT_FLOW_CONTROL_T fc)
-{
-    if (uartat_set_flow_control(m_uartat, fc))
-        throw std::runtime_error(string(__FUNCTION__)
-                                 + ": uartat_set_flow_control() failed");
-
-    return;
-}
-
-bool UARTAT::find(const std::string buffer, const std::string str)
-{
-    return uartat_find(m_uartat, buffer.c_str(), str.c_str());
-}
-
-void UARTAT::filterCR(bool enable)
-{
-    uartat_filter_cr(m_uartat, enable);
-}
diff --git a/src/uartat/uartat.h b/src/uartat/uartat.h
deleted file mode 100644
index 933814a..0000000
--- a/src/uartat/uartat.h
+++ /dev/null
@@ -1,282 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include <stdint.h>
-#include <stdlib.h>
-#include <unistd.h>
-
-#include <upm.h>
-#include <mraa/uart.h>
-
-#include "uartat_defs.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    /**
-     * @file uartat.h
-     * @library uartat
-     * @brief Generic API for AT command based UART devices
-     *
-     */
-
-    /**
-     * Device context
-     */
-    typedef struct _uartat_context {
-        mraa_uart_context        uart;
-
-        // wait time for reading results after sending a command.  The
-        // default is 250ms.
-        unsigned int cmd_resp_wait_ms;
-
-        // filter carriage returns (CR) out of responses?
-        bool filter_cr;
-    } *uartat_context;
-
-    /**
-     * UARTAT Initializer for generic UART operation using a UART index.
-     *
-     * @param uart Specify which uart to use.
-     * @param baudrate Specify the baudrate to use.
-     * @return an initialized device context on success, NULL on error.
-     */
-    uartat_context uartat_init(unsigned int uart, unsigned int baudrate);
-
-    /**
-     * UARTAT Initializer for generic UART operation using a filesystem
-     * tty path (eg. /dev/ttyUSB0).
-     *
-     * @param uart_tty character string representing a filesystem path to a
-     * serial tty device.
-     * @param baudrate Specify the baudrate to use.
-     * @return an initialized device context on success, NULL on error.
-     */
-    uartat_context uartat_init_tty(const char *uart_tty, unsigned int baudrate);
-
-    /**
-     * UARTAT sensor close function
-     *
-     * @param dev Device context
-     */
-    void uartat_close(uartat_context dev);
-
-    /**
-     * Read character data from the device.
-     *
-     * @param dev Device context
-     * @param buffer The character buffer to read data into.
-     * @param len The maximum size of the buffer
-     * @return The number of bytes successfully read, or -1 on error
-     */
-    int uartat_read(const uartat_context dev, char *buffer, size_t len);
-
-    /**
-     * Write character data to the device.
-     *
-     * @param dev Device context
-     * @param buffer The character buffer containing data to write.
-     * @param len The number of bytes to write.
-     * @return The number of bytes successfully written, or -1 on error.
-     */
-    int uartat_write(const uartat_context dev, const char *buffer, size_t len);
-
-    /**
-     * Set the baudrate of the device.
-     *
-     * @param dev Device context
-     * @param baudrate The baud rate to set for the device.
-     * @return UPM result
-     */
-    upm_result_t uartat_set_baudrate(const uartat_context dev,
-                                     unsigned int baudrate);
-
-    /**
-     * Set the default time, in milliseconds, to wait for data to
-     * arrive after sending a command.
-     *
-     * @param dev Device context
-     * @param wait_ms The response delay to set, in milliseconds.
-     */
-    void uartat_set_response_wait_time(const uartat_context dev,
-                                       unsigned int wait_ms);
-
-    /**
-     * Determine whether there is data available to be read.  This
-     * function will wait up to "millis" milliseconds for data to
-     * become available.
-     *
-     * @param dev Device context
-     * @param millis The number of milliseconds to wait for data to
-     * become available.
-     * @return true if data is available to be read, false otherwise.
-     */
-    bool uartat_data_available(const uartat_context dev,
-                               unsigned int millis);
-
-    /**
-     * Place the device in AT command mode.  Many devices operate in a
-     * transparent mode and an AT command mode.  Command mode is
-     * required to issue AT based commands.  When in transparent mode,
-     * the device will usually listen for a special sequence of
-     * characters and delays, indicating that AT command mode should
-     * be entered.
-     *
-     * On most devices, the sequence is:
-     * <wait 1 second>+++<wait 1 second>
-     *
-     * For most devices, the wait time is 1 second (1000 ms) and the
-     * character sequence is "+++".  These options can often be
-     * configured on the device.
-     *
-     * This function will wait millis milliseconds, write the command
-     * characters (typically "+++"), then wait millis milliseconds again.
-     * At this time a read will be attempted, looking for the "OK"
-     * response indicating command mode was successfully entered.
-     *
-     * @param dev Device context
-     * @param cmd_chars The character sequence to write, typically "+++".
-     * @param guard_ms The number of milliseconds to delay before and
-     * after the cmd_chars are written.
-     * @return true if AT command mode ("OK" detected) was
-     * successfully entered, false otherwise.
-     */
-    bool uartat_command_mode(const uartat_context dev, const char *cmd_chars,
-                             unsigned int guard_ms);
-
-    /**
-     * Check to see if the device is in command mode.  This is
-     * accomplished by sending an "AT\r" command and seeing if "OK" or
-     * "0" is returned.
-     *
-     * @param dev Device context
-     * @return true if AT command mode was detected, false otherwise.
-     */
-    bool uartat_in_command_mode(const uartat_context dev);
-
-    /**
-     * Read and throw away any data currently available to be read.
-     * This is useful to avoid reading data that might have been the
-     * result of a previous command interfering with data you
-     * currently want to read.  This function is automatically called
-     * by uartat_command_with_response(), uartat_command(), and
-     * uartat_command_waitfor() prior to writing the requested command
-     * to the device.
-     *
-     * @param dev Device context
-     */
-    void uartat_drain(const uartat_context dev);
-
-    /**
-     * Send an AT command and optionally return a response.
-     *
-     * @param dev Device context
-     * @param cmd A character string containing the AT command to
-     * send, including the "AT" prefix and a terminating carriage
-     * return ("\r").
-     * @param resp A pointer to a buffer that will contain the
-     * response.  If NULL is specified, the response is ignored.  The
-     * returned string buffer will be 0 terminated like any ordinary C
-     * string.
-     * @param resp_len The length of the supplied response buffer.  If
-     * 0, then any response will be ignored.  No more than resp_len
-     * characters (including the trailing 0 byte) will be returned.
-     * @return The number of bytes read, or -1 on error.
-     */
-    int uartat_command_with_response(const uartat_context dev,
-                                     const char *cmd, char *resp,
-                                     size_t resp_len);
-
-    /**
-     * Send an AT command and ignore any response.  This is a
-     * shorthand version of uartat_command_with_response(), and is
-     * equivalent to calling uartat_command_with_response(dev, cmd,
-     * NULL, 0).
-     *
-     * @param dev Device context
-     * @param cmd The AT command to send, including the "AT" prefix
-     * and a terminating carriage return ("\r").
-     */
-    void uartat_command(const uartat_context dev, const char *cmd);
-
-    /**
-     * Read characters for up to millis milliseconds, returning
-     * as soon as the wait_string is found.
-     *
-     * @param dev Device context
-     * @param cmd The command to send
-     * @param resp The response character buffer
-     * @param resp_len The maximum size of the response buffer
-     * @param wait_string The string to search for
-     * @param millis The maximum number of milliseconds to look for
-     * the wait_string.
-     * @return true if the wait_string was found in the response,
-     * false otherwise.
-     */
-    bool uartat_command_waitfor(const uartat_context dev, const char *cmd,
-                                char *resp, size_t resp_len,
-                                const char *wait_string,
-                                unsigned int millis);
-
-    /**
-     * Set a flow control method for the UART.  By default, during
-     * initialization, flow control is disabled.
-     *
-     * @param dev Device context
-     * @param fc One of the UARTAT_FLOW_CONTROL_T values.
-     * @return the UPM result.
-     */
-    upm_result_t uartat_set_flow_control(const uartat_context dev,
-                                         UARTAT_FLOW_CONTROL_T fc);
-
-    /**
-     * Look for a string in a buffer.  This is a utility function that
-     * can be used to indicate if a given string is present in a
-     * supplied buffer.  The search is case sensitive.
-     *
-     * @param dev Device context
-     * @param buffer The 0 teminated buffer in which to search.
-     * @param str The 0 teminated string to search for.
-     * @return true if the string was found, false otherwise.
-     */
-    bool uartat_find(const uartat_context dev, const char *buffer,
-                     const char *str);
-
-    /**
-     * Filter out carriage returns (CR) from response buffers if
-     * enabled.  This operates only on the response buffers returned
-     * from uartat_command_with_response(), uartat_command(), and
-     * uartat_command_waitfor().
-     *
-     * @param dev Device context
-     * @param enable true to filter out CR's, false otherwise
-     */
-    void uartat_filter_cr(const uartat_context dev, bool enable);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/uartat/uartat.hpp b/src/uartat/uartat.hpp
deleted file mode 100644
index 5e8180d..0000000
--- a/src/uartat/uartat.hpp
+++ /dev/null
@@ -1,265 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <iostream>
-
-#include "uartat.h"
-
-namespace upm {
-    /**
-     * @brief Generic AT Command Based UART Modem Library
-     * @defgroup uartat libupm-uartat
-     * @ingroup uart
-     */
-
-    /**
-     * @library uartat
-     * @sensor uartat
-     * @comname Generic AT Command Based UART Device
-     * @type other
-     * @con uart
-     *
-     * @brief API for a Generic AT command based UART device
-     *
-     * This is a generic UART device driver for accessing UART based
-     * devices that utilize an "AT" command set.  Typically these
-     * devices are Radios, Modems, and similar devices that are
-     * configured and controlled by emitting "AT" commands.
-     *
-     * @snippet uartat-le910.cxx Interesting
-     */
-
-    class UARTAT {
-    public:
-
-        /**
-         * UARTAT object constructor for a UART specified by MRAA number.
-         *
-         * @param uart Specify which uart to use.
-         * @param baudrate Specify the baudrate to use.
-         */
-        UARTAT(unsigned int uart, unsigned int baudrate);
-
-        /**
-         * UARTAT object constructor for a UART specified by PATH (ex:
-         * /dev/ttyUSB0)
-         *
-         * @param uart_path Specify path of UART device.
-         * @param baudrate Specify the baudrate to use.
-         */
-        UARTAT(std::string uart_path, unsigned int baudrate);
-
-        /**
-         * UARTAT object destructor
-         */
-        ~UARTAT();
-
-        /**
-         * Read character data from the device.
-         *
-         * @param size The maximum number of characters to read.
-         * @return string containing the data read.
-         */
-        std::string readStr(size_t size);
-
-        /**
-         * Write character data to the device.
-         *
-         * @param buffer The string containing the data to write.
-         * @return The number of bytes written.
-         */
-        int writeStr(std::string buffer);
-
-        /**
-         * Set the baudrate of the device.
-         *
-         * @param baudrate The baud rate to set for the device.
-         */
-        void setBaudrate(unsigned int baudrate);
-
-        /**
-         * Set the default time, in milliseconds, to wait for data to
-         * arrive after sending a command.
-         *
-         * @param wait_time The response delay to set, in milliseconds.
-         */
-        void setResponseWaitTime(unsigned int wait_time);
-
-        /**
-         * Determine whether there is data available to be read.  In the
-         * case of a UART, this function will wait up to "millis"
-         * milliseconds for data to become available.  In the case of an I2C
-         * device, the millis argument is ignored and the function will
-         * return immediately, indicating whether data is available.
-         *
-         * @param millis The number of milliseconds to wait for data to
-         * become available.
-         * @return true if data is available to be read, false otherwise.
-         */
-        bool dataAvailable(unsigned int millis);
-
-        /**
-         * Place the device in AT command mode.  Many devices operate in a
-         * transparent mode and an AT command mode.  Command mode is
-         * required to issue AT based commands.  When in transparent mode,
-         * the device will usually listen for a special sequence of
-         * characters and delays, indicating that AT command mode should
-         * be entered.
-         *
-         * On most devices, the sequence is:
-         * <wait 1 second>+++<wait 1 second>
-         *
-         * For most devices, the wait time is 1 second (1000 ms) and the
-         * character sequence is "+++".  These options can often be
-         * configured on the device.
-         *
-         * This function will wait millis milliseconds, write the command
-         * characters (typically "+++"), then wait millis milliseconds again.
-         * At this time a read will be attempted, looking for the "OK"
-         * response indicating command mode was successfully entered.
-         *
-         * @param cmd_chars The character sequence to write, typically "+++".
-         * @param guard_ms The number of milliseconds to delay before and
-         * after the cmd_chars are written.
-         * @return true if AT command mode ("OK" detected) was
-         * successfully entered, false otherwise.
-         */
-        bool commandMode(const std::string cmd_chars, unsigned int guard_ms);
-
-        /**
-         * Check to see if the device is in command mode.  This is
-         * accomplished by sending an "AT\r" command and seeing if
-         * "OK" or "0" is returned.
-         *
-         * @return true if AT command mode was detected, false otherwise.
-         */
-        bool inCommandMode();
-
-        /**
-         * Read and throw away any data currently available to be
-         * read.  This is useful to avoid reading data that might have
-         * been the result of a previous command interfering with data
-         * you currently want to read.  This function is automatically
-         * called by commandWithResponse(), command(), and
-         * commandWaitfor() prior to writing the requested command to
-         * the device.
-         *
-         */
-        void drain();
-
-        /**
-         * Send an AT command and optionally return a response.
-         *
-         * @param cmd A character string containing the AT command to
-         * send, including the "AT" prefix and a terminating carriage
-         * return ("\r").
-         * @param resp_len The maximum number of characters to read from the
-         * device.
-         * @return The device response string, if any.
-         */
-        std::string commandWithResponse(const std::string cmd, size_t resp_len);
-
-        /**
-         * Send an AT command and return a response, while waiting for
-         * a specific string.  If the string isn't found the returned
-         * string will be empty.  If the string is found, the function
-         * will return immediately.
-         *
-         * @param cmd A character string containing the AT command to
-         * send, including the "AT" prefix and a terminating carriage
-         * return ("\r").
-         * @param resp_len The maximum number of characters to read from the
-         * device.
-         * @param waitString The string to look for.  If found, the
-         * response will be returned immediately regardless of the
-         * timeout setting.
-         * @param millis The maximum number of milliseconds to wait
-         * for the string.
-         * @return A string containing the response if the search
-         * string was found, otherwise and empty string is returned.
-         */
-        std::string commandWaitFor(const std::string cmd, size_t resp_len,
-                                   const std::string waitString,
-                                   unsigned int millis);
-
-        /**
-         * Send an AT command and ignore any response.
-         *
-         * @param cmd The AT command to send, including the "AT" prefix
-         * and a terminating carriage return ("\r").
-         */
-        void command(const std::string cmd);
-
-        /**
-         * This is a convenience method that converts each CR (\r) in a
-         * string to a LF (\n) and returns it.  This is useful for
-         * outputting the response to an AT command for instance, which is
-         * often CR terminated.
-         *
-         * @param str The string to convert
-         * @return The converted string
-         */
-        std::string stringCR2LF(std::string str);
-
-        /**
-         * Set a flow control method for the UART.  By default, during
-         * initialization, flow control is disabled.
-         *
-         * @param fc One of the UARTAT_FLOW_CONTROL_T values.
-         */
-        void setFlowControl(UARTAT_FLOW_CONTROL_T fc);
-
-        /**
-         * Look for a string in a buffer.  This is a utility function that
-         * can be used to indicate if a given string is present in a
-         * supplied buffer.  The search is case sensitive.
-         *
-         * @param buffer The string buffer in which to search.
-         * @param str The string to search for.
-         * @return true if the string was found, false otherwise.
-         */
-        bool find(const std::string buffer, const std::string str);
-
-        /**
-         * Filter out carriage returns (CR) from response buffers if
-         * enabled.  This operates only on the response buffers returned
-         * from commandWithResponse(), command(), and
-         * commandWaitfor().
-         *
-         * @param enable true to filter out CR's, false otherwise
-         */
-        void filterCR(bool enable);
-
-    protected:
-        // uartat device context
-        uartat_context m_uartat;
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        UARTAT(const UARTAT&) = delete;
-        UARTAT &operator=(const UARTAT&) = delete;
-    };
-}
diff --git a/src/uartat/uartat.i b/src/uartat/uartat.i
deleted file mode 100644
index 68eb424..0000000
--- a/src/uartat/uartat.i
+++ /dev/null
@@ -1,16 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_uartat)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "uartat_defs.h"
-#include "uartat.hpp"
-%}
-%include "uartat_defs.h"
-%include "uartat.hpp"
-/* END Common SWIG syntax */
diff --git a/src/uartat/uartat.json b/src/uartat/uartat.json
deleted file mode 100644
index 7483f50..0000000
--- a/src/uartat/uartat.json
+++ /dev/null
@@ -1,25 +0,0 @@
-{
-    "Library": "uartat",
-    "Description": "Generic AT Command Based UART Device Library",
-    "Sensor Class": {
-        "UARTAT": {
-            "Name": "API for a Generic AT command based UART device",
-            "Description": "This is the UPM Module for a Generic AT command based UART device. This is a generic UART device driver for accessing UART based devices that utilize an \"AT\" command set.  Typically these devices are Radios, Modems, and similar devices that are configured and controlled by emitting \"AT\" commands.",
-            "Aliases": ["uartat"],
-            "Categories": ["other"],
-            "Connections": ["uart"],
-            "Project Type": ["other"],
-            "Manufacturers": ["generic"],
-            "Examples": {
-                "Java": ["LE910_Example.java"],
-                "Python": ["le910.py"],
-                "Node.js": ["le910.js"],
-                "C++": ["uartat-le910.cxx"],
-                "C": ["uartat-le910.c"]
-            },
-            "Urls": {
-                "Product Pages": ["https://github.com/intel-iot-devkit/upm/tree/master/src/uartat"]
-            }
-        }
-    }
-}
diff --git a/src/uartat/uartat_defs.h b/src/uartat/uartat_defs.h
deleted file mode 100644
index 1d3932f..0000000
--- a/src/uartat/uartat_defs.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    // possible flow control methods
-    typedef enum {
-        UARTAT_FLOW_CONTROL_NONE           = 0,
-        UARTAT_FLOW_CONTROL_HARD,          // hardware flow control
-        UARTAT_FLOW_CONTROL_SOFT           // software flow control
-    } UARTAT_FLOW_CONTROL_T;
-
-
-    // Numeric response codes via ITU-T V25Ter recommendations
-    typedef enum {
-        UARTAT_RESPONSE_CODE_OK            = 0,
-        UARTAT_RESPONSE_CODE_CONNECT       = 1,
-        UARTAT_RESPONSE_CODE_RING          = 2,
-        UARTAT_RESPONSE_CODE_NO_CARRIER    = 3,
-        UARTAT_RESPONSE_CODE_ERROR         = 4,
-        // 5 unassigned
-        UARTAT_RESPONSE_CODE_NO_DIALTONE   = 6,
-        UARTAT_RESPONSE_CODE_BUSY          = 7,
-        UARTAT_RESPONSE_CODE_NO_ANSWER     = 8
-    } UARTAT_RESPONSE_CODE_T;
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/uln200xa/CMakeLists.txt b/src/uln200xa/CMakeLists.txt
deleted file mode 100644
index ca30d86..0000000
--- a/src/uln200xa/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-upm_mixed_module_init (NAME uln200xa
-    DESCRIPTION "Darlington Stepper Driver"
-    C_HDR uln200xa.h uln200xa_defs.h
-    C_SRC uln200xa.c
-    CPP_HDR uln200xa.hpp
-    CPP_SRC uln200xa.cxx
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/uln200xa/uln200xa.c b/src/uln200xa/uln200xa.c
deleted file mode 100644
index a2b56b6..0000000
--- a/src/uln200xa/uln200xa.c
+++ /dev/null
@@ -1,260 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-
-#include <assert.h>
-#include <upm_utilities.h>
-
-#include "uln200xa.h"
-
-static void uln200xa_stepper_step(const uln200xa_context dev);
-
-uln200xa_context uln200xa_init(int stepsPerRev, unsigned int i1,
-                               unsigned int i2, unsigned int i3,
-                               unsigned int i4)
-{
-    uln200xa_context dev =
-        (uln200xa_context)malloc(sizeof(struct _uln200xa_context));
-
-    if (!dev)
-        return NULL;
-
-    dev->stepI1 = NULL;
-    dev->stepI2 = NULL;
-    dev->stepI3 = NULL;
-    dev->stepI4 = NULL;
-
-    dev->stepsPerRev = stepsPerRev;
-    dev->currentStep = 0;
-    dev->stepDelay = 0;
-    dev->stepDirection = 1;          // default is forward
-
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        uln200xa_close(dev);
-        return NULL;
-    }
-
-    // MRAA contexts...
-    if ( !(dev->stepI1 = mraa_gpio_init(i1)) )
-    {
-        printf("%s: mraa_gpio_init(i1) failed\n",
-               __FUNCTION__);
-        uln200xa_close(dev);
-        return NULL;
-    }
-    mraa_gpio_dir(dev->stepI1, MRAA_GPIO_OUT);
-
-    if ( !(dev->stepI2 = mraa_gpio_init(i2)) )
-    {
-        printf("%s: mraa_gpio_init(i2) failed\n",
-               __FUNCTION__);
-        uln200xa_close(dev);
-        return NULL;
-    }
-    mraa_gpio_dir(dev->stepI2, MRAA_GPIO_OUT);
-
-    if ( !(dev->stepI3 = mraa_gpio_init(i3)) )
-    {
-        printf("%s: mraa_gpio_init(i3) failed\n",
-               __FUNCTION__);
-        uln200xa_close(dev);
-        return NULL;
-    }
-    mraa_gpio_dir(dev->stepI3, MRAA_GPIO_OUT);
-
-    if ( !(dev->stepI4 = mraa_gpio_init(i4)) )
-    {
-        printf("%s: mraa_gpio_init(i4) failed\n",
-               __FUNCTION__);
-        uln200xa_close(dev);
-        return NULL;
-    }
-    mraa_gpio_dir(dev->stepI4, MRAA_GPIO_OUT);
-
-    // set default speed to 1
-    uln200xa_set_speed(dev, 1);
-
-    return dev;
-}
-
-void uln200xa_close(uln200xa_context dev)
-{
-    assert(dev != NULL);
-
-    uln200xa_release(dev);
-    if (dev->stepI1)
-        mraa_gpio_close(dev->stepI1);
-    if (dev->stepI2)
-        mraa_gpio_close(dev->stepI2);
-    if (dev->stepI3)
-        mraa_gpio_close(dev->stepI3);
-    if (dev->stepI4)
-        mraa_gpio_close(dev->stepI4);
-
-    free(dev);
-}
-
-void uln200xa_set_speed(const uln200xa_context dev, unsigned int speed)
-{
-    assert(dev != NULL);
-
-    dev->stepDelay = 60 * 1000 / dev->stepsPerRev / speed;
-}
-
-void uln200xa_set_direction(const uln200xa_context dev,
-                            ULN200XA_DIRECTION_T dir)
-{
-    assert(dev != NULL);
-
-    switch (dir)
-    {
-    case ULN200XA_DIR_CW:
-        dev->stepDirection = 1;
-        break;
-    case ULN200XA_DIR_CCW:
-        dev->stepDirection = -1;
-        break;
-    }
-}
-
-static void uln200xa_stepper_step(const uln200xa_context dev)
-{
-    assert(dev != NULL);
-
-    int step = dev->currentStep % 8;
-
-    // This motor requires a different sequencing order in 8-steps than
-    // usual.
-
-    //   Step I0 I1 I2 I3
-    //     1  0  0  0  1
-    //     2  0  0  1  1
-    //     3  0  0  1  0
-    //     4  0  1  1  0
-    //     5  0  1  0  0
-    //     6  1  1  0  0
-    //     7  1  0  0  0
-    //     8  1  0  0  1
-
-    switch (step)
-    {
-    case 0:    // 0001
-        mraa_gpio_write(dev->stepI1, 0);
-        mraa_gpio_write(dev->stepI2, 0);
-        mraa_gpio_write(dev->stepI3, 0);
-        mraa_gpio_write(dev->stepI4, 1);
-        break;
-    case 1:    // 0011
-        mraa_gpio_write(dev->stepI1, 0);
-        mraa_gpio_write(dev->stepI2, 0);
-        mraa_gpio_write(dev->stepI3, 1);
-        mraa_gpio_write(dev->stepI4, 1);
-        break;
-    case 2:    // 0010
-        mraa_gpio_write(dev->stepI1, 0);
-        mraa_gpio_write(dev->stepI2, 0);
-        mraa_gpio_write(dev->stepI3, 1);
-        mraa_gpio_write(dev->stepI4, 0);
-        break;
-    case 3:    // 0110
-        mraa_gpio_write(dev->stepI1, 0);
-        mraa_gpio_write(dev->stepI2, 1);
-        mraa_gpio_write(dev->stepI3, 1);
-        mraa_gpio_write(dev->stepI4, 0);
-        break;
-    case 4:    // 0100
-        mraa_gpio_write(dev->stepI1, 0);
-        mraa_gpio_write(dev->stepI2, 1);
-        mraa_gpio_write(dev->stepI3, 0);
-        mraa_gpio_write(dev->stepI4, 0);
-        break;
-    case 5:    // 1100
-        mraa_gpio_write(dev->stepI1, 1);
-        mraa_gpio_write(dev->stepI2, 1);
-        mraa_gpio_write(dev->stepI3, 0);
-        mraa_gpio_write(dev->stepI4, 0);
-        break;
-    case 6:    // 1000
-        mraa_gpio_write(dev->stepI1, 1);
-        mraa_gpio_write(dev->stepI2, 0);
-        mraa_gpio_write(dev->stepI3, 0);
-        mraa_gpio_write(dev->stepI4, 0);
-        break;
-    case 7:    // 1001
-        mraa_gpio_write(dev->stepI1, 1);
-        mraa_gpio_write(dev->stepI2, 0);
-        mraa_gpio_write(dev->stepI3, 0);
-        mraa_gpio_write(dev->stepI4, 1);
-        break;
-    default:
-        // can't happen
-        break;
-    }
-}
-
-void uln200xa_stepper_steps(const uln200xa_context dev, unsigned int steps)
-{
-    assert(dev != NULL);
-
-    while (steps > 0)
-    {
-        upm_delay_ms(dev->stepDelay);
-        dev->currentStep += dev->stepDirection;
-
-        if (dev->stepDirection == 1)
-        {
-            if (dev->currentStep >= dev->stepsPerRev)
-                dev->currentStep = 0;
-        }
-        else
-        {
-            if (dev->currentStep <= 0)
-                dev->currentStep = dev->stepsPerRev;
-        }
-
-        steps--;
-        uln200xa_stepper_step(dev);
-    }
-}
-
-void uln200xa_release(const uln200xa_context dev)
-{
-    assert(dev !=NULL);
-
-    // we do these check since this is also called from
-    // uln200xa_close() and we can't be sure that all of the contexts
-    // have been created yet.
-    if (dev->stepI1)
-        mraa_gpio_write(dev->stepI1, 0);
-    if (dev->stepI2)
-        mraa_gpio_write(dev->stepI2, 0);
-    if (dev->stepI3)
-        mraa_gpio_write(dev->stepI3, 0);
-    if (dev->stepI4)
-        mraa_gpio_write(dev->stepI4, 0);
-}
diff --git a/src/uln200xa/uln200xa.cxx b/src/uln200xa/uln200xa.cxx
deleted file mode 100644
index 5fe6ebe..0000000
--- a/src/uln200xa/uln200xa.cxx
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015-2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "uln200xa.hpp"
-
-using namespace upm;
-using namespace std;
-
-ULN200XA::ULN200XA(int stepsPerRev, unsigned int i1, unsigned int i2,
-                   unsigned int i3, unsigned int i4) :
-    m_uln200xa(uln200xa_init(stepsPerRev, i1, i2, i3, i4))
-{
-    if (!m_uln200xa)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": uln200xa_init() failed");
-}
-
-ULN200XA::~ULN200XA()
-{
-    uln200xa_close(m_uln200xa);
-}
-
-void ULN200XA::setSpeed(unsigned int speed)
-{
-    uln200xa_set_speed(m_uln200xa, speed);
-}
-
-void ULN200XA::setDirection(ULN200XA_DIRECTION_T dir)
-{
-    uln200xa_set_direction(m_uln200xa, dir);
-}
-
-void ULN200XA::stepperSteps(unsigned int steps)
-{
-    uln200xa_stepper_steps(m_uln200xa, steps);
-}
-
-void ULN200XA::release()
-{
-    uln200xa_release(m_uln200xa);
-}
diff --git a/src/uln200xa/uln200xa.h b/src/uln200xa/uln200xa.h
deleted file mode 100644
index c0385fe..0000000
--- a/src/uln200xa/uln200xa.h
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <upm.h>
-
-#include <mraa/gpio.h>
-
-#include "uln200xa_defs.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-    /**
-     * @file uln200xa.h
-     * @library uln200xa
-     * @brief C API for the uln200xa driver
-     *
-     * @include uln200xa.c
-     */
-
-    /**
-     * Device context
-     */
-    typedef struct _uln200xa_context {
-        mraa_gpio_context stepI1; // In1
-        mraa_gpio_context stepI2;
-        mraa_gpio_context stepI3;
-        mraa_gpio_context stepI4;
-
-        int      stepsPerRev;
-        int      currentStep;
-        uint32_t stepDelay;
-        int      stepDirection;
-
-    } *uln200xa_context;
-
-    /**
-     * ULN200XA constructor
-     *
-     * @param stepsPerRev Number of steps per full revolution
-     * @param i1 Digital pin to use for stepper input 1
-     * @param i2 Digital pin to use for stepper input 2
-     * @param i3 Digital pin to use for stepper input 3
-     * @param i4 Digital pin to use for stepper input 4
-     * @return Device context
-     */
-    uln200xa_context uln200xa_init(int stepsPerRev, unsigned int i1,
-                                   unsigned int i2, unsigned int i3,
-                                   unsigned int i4);
-
-    /**
-     * ULN200XA destructor
-     */
-    void uln200xa_close(uln200xa_context dev);
-
-    /**
-     * Sets the speed of the stepper motor in revolutions per minute (RPM)
-     *
-     * @param dev Device context
-     * @param speed Speed to set the motor to, in RPM
-     */
-    void uln200xa_set_speed(const uln200xa_context dev, unsigned int speed);
-
-    /**
-     * Sets the direction of the motor, clockwise or counterclockwise
-     *
-     * @param dev Device context
-     * @param dir Direction to set the motor to
-     */
-    void uln200xa_set_direction(const uln200xa_context dev,
-                                ULN200XA_DIRECTION_T dir);
-
-    /**
-     * Steps the stepper motor a specified number of steps
-     *
-     * @param dev Device context
-     * @param steps Number of steps to move the stepper motor
-     */
-    void uln200xa_stepper_steps(const uln200xa_context dev, unsigned int steps);
-
-    /**
-     * Releases the stepper motor by removing power
-     *
-     * @param dev Device context
-     */
-    void uln200xa_release(const uln200xa_context dev);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/uln200xa/uln200xa.hpp b/src/uln200xa/uln200xa.hpp
deleted file mode 100644
index ec652a6..0000000
--- a/src/uln200xa/uln200xa.hpp
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015-2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <uln200xa.h>
-
-namespace upm {
-
-  /**
-   * @brief ULN200XA Stepper Driver
-   * @defgroup uln200xa libupm-uln200xa
-   * @ingroup seeed gpio motor
-   */
-
-  /**
-   * @library uln200xa
-   * @sensor uln200xa
-   * @comname Darlington Stepper Driver
-   * @altname ULN2001A ULN2002A ULN2003A ULN2004A
-   * @type motor
-   * @man seeed
-   * @web http://www.seeedstudio.com/depot/Gear-Stepper-Motor-with-Driver-p-1685.html?cPath=39_40
-   * @con gpio
-   *
-   * @brief UPM module for the ULN200XA Darlington Stepper Driver
-   *
-   * This module was developed on a ULN2003A Stepper Driver. It
-   * should also support the ULN2001A, ULN2002A, and ULN2004A devices, when
-   * using to drive the 28BYJ-48 unipolar stepper motor.
-   *
-   * Vcc goes to the 5V pin on your development board and the Vm pin should
-   * be connected to an external 5V supply.
-   *
-   * @image html uln200xa.jpg
-   * Example driving a stepper motor
-   * @snippet uln200xa.cxx Interesting
-   */
-
-
-  class ULN200XA {
-  public:
-
-    /**
-     * ULN200XA constructor
-     *
-     * @param stepsPerRev Number of steps per full revolution
-     * @param i1 Digital pin to use for stepper input 1
-     * @param i2 Digital pin to use for stepper input 2
-     * @param i3 Digital pin to use for stepper input 3
-     * @param i4 Digital pin to use for stepper input 4
-     */
-    ULN200XA(int stepsPerRev, unsigned int i1, unsigned int i2,
-             unsigned int i3, unsigned int i4);
-
-    /**
-     * ULN200XA destructor
-     */
-    ~ULN200XA();
-
-    /**
-     * Sets the speed of the stepper motor in revolutions per minute (RPM)
-     *
-     * @param speed Speed to set the motor to, in RPM
-     */
-    void setSpeed(unsigned int speed);
-
-    /**
-     * Sets the direction of the motor, clockwise or counterclockwise
-     *
-     * @param dir Direction to set the motor to
-     */
-    void setDirection(ULN200XA_DIRECTION_T dir);
-
-    /**
-     * Steps the stepper motor a specified number of steps
-     *
-     * @param steps Number of steps to move the stepper motor
-     */
-    void stepperSteps(unsigned int steps);
-
-    /**
-     * Releases the stepper motor by removing power
-     *
-     */
-    void release();
-
-  protected:
-    uln200xa_context m_uln200xa;
-
-  private:
-    /* Disable implicit copy and assignment operators */
-    ULN200XA(const ULN200XA&) = delete;
-    ULN200XA &operator=(const ULN200XA&) = delete;
-  };
-}
diff --git a/src/uln200xa/uln200xa.i b/src/uln200xa/uln200xa.i
deleted file mode 100644
index 4655373..0000000
--- a/src/uln200xa/uln200xa.i
+++ /dev/null
@@ -1,15 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_uln200xa)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "uln200xa.hpp"
-%}
-%include "uln200xa_defs.h"
-%include "uln200xa.hpp"
-/* END Common SWIG syntax */
diff --git a/src/uln200xa/uln200xa.json b/src/uln200xa/uln200xa.json
deleted file mode 100644
index 5ec3926..0000000
--- a/src/uln200xa/uln200xa.json
+++ /dev/null
@@ -1,53 +0,0 @@
-{
-    "Library": "uln200xa",
-    "Description": "ULN200XA Stepper Driver Library",
-    "Sensor Class": {
-        "ULN200XA": {
-            "Name": "UPM module for the ULN200XA Darlington Stepper Driver",
-            "Description": "This is the UPM Module for the ULN200XA Darlington Stepper Driver. This module was developed on a ULN2003A Stepper Driver. It should also support the ULN2001A, ULN2002A, and ULN2004A devices, when using to drive the 28BYJ-48 unipolar stepper motor.",
-            "Aliases": ["ULN200XA", "ULN2001A", "ULN2002A", "ULN2003A", "ULN2004A"],
-            "Categories": ["motor"],
-            "Connections": ["gpio"],
-            "Project Type": ["prototyping", "robotics"],
-            "Manufacturers": ["Seeed"],
-            "Image": "uln200xa.jpg",
-            "Examples": {
-                "Java": ["ULN200XA_Example.java"],
-                "Python": ["uln200xa.py"],
-                "Node.js": ["uln200xa.js"],
-                "C++": ["uln200xa.cxx"],
-                "C": ["uln200xa.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 2.4,
-                    "max": 13.0
-                },
-                "Supply Current": {
-                    "unit": "uA",
-                    "min" : 500,
-                    "max" : 1450
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -20,
-                    "max": 85
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Gear-Stepper-Motor-with-Driver-p-1685.html?cPath=39_40"],
-                "Datasheets": ["http://www.seeedstudio.com/document/pdf/Stepper%20Motor%20Datasheet.pdf", "http://www.seeedstudio.com/document/pdf/ULN2003%20Datasheet.pdf"],
-                "Schematics": ["http://www.seeedstudio.com/document/pdf/Driver%20Board%20Schematic.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/uln200xa/uln200xa_defs.h b/src/uln200xa/uln200xa_defs.h
deleted file mode 100644
index 4e9e210..0000000
--- a/src/uln200xa/uln200xa_defs.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    /**
-     * Enum to specify the direction of a motor
-     */
-    typedef enum {
-      ULN200XA_DIR_CW   = 0x01,
-      ULN200XA_DIR_CCW  = 0x02
-    } ULN200XA_DIRECTION_T;
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/ultrasonic/CMakeLists.txt b/src/ultrasonic/CMakeLists.txt
deleted file mode 100644
index a89fe56..0000000
--- a/src/ultrasonic/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "ultrasonic")
-set (libdescription "Ultrasonic Proximity Sensor")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/ultrasonic/ultrasonic.cxx b/src/ultrasonic/ultrasonic.cxx
deleted file mode 100644
index 51070e3..0000000
--- a/src/ultrasonic/ultrasonic.cxx
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * Author: Jun Kato <i@junkato.jp>
- * Copyright (c) 2015 Jun Kato.
- *
- * Thanks to Seeed Studio for a working arduino sketch
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <unistd.h>
-#include <stdlib.h>
-#include <functional>
-
-#include "ultrasonic.hpp"
-
-using namespace upm;
-
-UltraSonic::UltraSonic (int pin) {
-    m_name = "UltraSonic";
-
-    mraa_init();
-
-    // setup pin
-    m_pinCtx = mraa_gpio_init(pin);
-    if (m_pinCtx == NULL) {
-        fprintf (stderr, "Are you sure that pin%d you requested is valid on your platform?", pin);
-        exit (1);
-    }
-    mraa_gpio_isr (m_pinCtx, MRAA_GPIO_EDGE_BOTH,
-                   &signalISR, this);
-}
-
-UltraSonic::~UltraSonic () {
-
-    // close pin
-    mraa_gpio_isr_exit(m_pinCtx);
-    mraa_gpio_close (m_pinCtx);
-}
-
-int
-UltraSonic::getDistance () {
-
-    // output trigger signal
-    mraa_gpio_dir(m_pinCtx, MRAA_GPIO_OUT);
-    mraa_gpio_write(m_pinCtx, LOW);
-    usleep(2);
-    mraa_gpio_write(m_pinCtx, HIGH);
-    usleep(5);
-    mraa_gpio_write(m_pinCtx, LOW);
-
-    // wait for the pulse,
-    m_doWork = true;
-    m_InterruptCounter = 0;
-    mraa_gpio_dir(m_pinCtx, MRAA_GPIO_IN);
-
-    // though do not wait over 25 [ms].
-    int timer = 0;
-    while (m_doWork && timer++ < 5) {
-        // in 25 [ms], sound travels 25000 / 29 / 2 = 431 [cm],
-        // which is more than 400 [cm], the max distance measurable with this sensor.
-        usleep(5 * 1000); // 5 [ms]
-    }
-
-    // calc diff
-    long diff = m_FallingTimeStamp.tv_usec - m_RisingTimeStamp.tv_usec;
-    diff += (m_FallingTimeStamp.tv_sec - m_RisingTimeStamp.tv_sec) * 1000000;
-    return timer >= 5 ? 0 : diff;
-}
-
-void
-UltraSonic::signalISR(void *ctx) {
-    upm::UltraSonic *This = (upm::UltraSonic *)ctx;
-    This->ackEdgeDetected();
-}
-
-void
-UltraSonic::ackEdgeDetected () {
-    if (++m_InterruptCounter % 2 == 0) {
-        gettimeofday(&m_FallingTimeStamp, NULL);
-        m_doWork = false;
-    } else {
-        gettimeofday(&m_RisingTimeStamp, NULL);
-    }
-}
diff --git a/src/ultrasonic/ultrasonic.hpp b/src/ultrasonic/ultrasonic.hpp
deleted file mode 100644
index f30a37e..0000000
--- a/src/ultrasonic/ultrasonic.hpp
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * Author: Jun Kato <i@junkato.jp>
- * Copyright (c) 2015 Jun Kato.
- *
- * Thanks to Seeed Studio for a working arduino sketch
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <mraa/aio.h>
-#include <mraa/gpio.h>
-#include <sys/time.h>
-
-#define HIGH                   1
-#define LOW                    0
-
-namespace upm {
-
-/**
- * @brief Ultrasonic Sensor
- * @defgroup ultrasonic libupm-ultrasonic
- * @ingroup seeed gpio sound
- */
-
-/**
- * @library ultrasonic
- * @sensor ultrasonic
- * @comname Ultrasonic Proximity Sensor
- * @type sound
- * @man seeed
- * @web http://wiki.seeed.cc/Grove-Ultrasonic_Ranger/
- * @con gpio
- *
- * @brief API for Grove Ultrasonic Ranger
- *
- * This Grove Ultrasonic sensor is a non-contact distance measurement module
- * which is compatible with the Grove system. It is designed for easy modular
- * project usage with industrial performance. Detection ranges from 3 cm (1.2")
- * to 4 m (13'1.5") and works best when the object is within a 30 degree angle
- * relative to the sensor.
- *
- * @image html ultrasonic.jpg
- * @snippet ultrasonic.cxx Interesting
- */
-class UltraSonic {
-    public:
-        /**
-         * Instantiates a UltraSonic object
-         *
-         * @param pin pin for triggering the sensor for distance and for receiving pulse response
-         */
-        UltraSonic (int pin);
-
-        /**
-         * UltraSonic object destructor.
-         */
-        ~UltraSonic ();
-
-        /**
-         * Returns the echo's pulse width from the sensor in microseconds.
-         * Divide by 58 to convert distance to centimetres. 
-         * Divide by 148 to convert distance to inches.
-         */
-        int getDistance ();
-
-        /**
-         * Return name of the component
-         */
-        std::string name()
-        {
-            return m_name;
-        }
-
-        /**
-         * Returns true while the sensor is busy waiting for the echo pulse
-         */
-        bool working()
-        {
-            return m_doWork;
-        }
-
-    private:
-        bool m_doWork; /* Flag to control blocking function while waiting for falling edge interrupt */
-        mraa_gpio_context m_pinCtx;
-        uint8_t m_InterruptCounter;
-        struct timeval m_RisingTimeStamp;
-        struct timeval m_FallingTimeStamp;
-        std::string m_name;
-
-        /**
-         * ISR for the pulse signal
-         */
-        static void signalISR(void *ctx);
-
-        /**
-         * On each interrupt this function will detect if the interrupt
-         * was falling edge or rising.
-         * Should be called from the interrupt handler.
-         */
-        void ackEdgeDetected ();
-};
-
-}
diff --git a/src/ultrasonic/ultrasonic.i b/src/ultrasonic/ultrasonic.i
deleted file mode 100644
index 6a9de92..0000000
--- a/src/ultrasonic/ultrasonic.i
+++ /dev/null
@@ -1,16 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%ignore signalISR;
-
-JAVA_JNI_LOADLIBRARY(javaupm_ultrasonic)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "ultrasonic.hpp"
-%}
-%include "ultrasonic.hpp"
-/* END Common SWIG syntax */
diff --git a/src/ultrasonic/ultrasonic.json b/src/ultrasonic/ultrasonic.json
deleted file mode 100644
index eb98549..0000000
--- a/src/ultrasonic/ultrasonic.json
+++ /dev/null
@@ -1,61 +0,0 @@
-{
-    "Library": "ultrasonic",
-    "Description": "Grove ultrasonic sensor Library",
-    "Sensor Class": {
-        "UltraSonic": {
-            "Name": "API for the Grove Ultrasonic Ranger",
-            "Description": "This is the UPM Module for the Grove Ultrasonic Ranger. This Grove Ultrasonic sensor is a non-contact distance measurement module which is compatible with the Grove system. It is designed for easy modular project usage with industrial performance. Detection ranges from 3 cm (1.2\") to 4 m (13'1.5\") and works best when the object is within a 30 degree angle relative to the sensor.",
-            "Aliases": ["ultrasonic", "Grove - Ultrasonic Ranger"],
-            "Categories": ["sound"],
-            "Connections": ["gpio"],
-            "Project Type": ["prototyping", "robotics", "commercial"],
-            "Manufacturers": ["Seeed"],
-            "Image": "ultrasonic.jpg",
-            "Examples": {
-                "Node.js": ["ultrasonic.js"],
-                "C++": ["ultrasonic.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.2,
-                    "max": 5.2
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "typ" : 8
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Ultrasonic Frequency": {
-                    "unit": "kHz",
-                    "typ" : 40
-                },
-                "Effective Range": {
-                    "unit": "cm",
-                    "min" : 2,
-                    "max" : 350
-                },
-                "Resolution": {
-                    "unit": "cm",
-                    "min" : -1,
-                    "max" : 1
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-Ultrasonic-Ranger-p-960.html", "http://wiki.seeed.cc/Grove-Ultrasonic_Ranger/"]
-            }
-        }
-    }
-}
diff --git a/src/urm37/CMakeLists.txt b/src/urm37/CMakeLists.txt
deleted file mode 100644
index a73ad44..0000000
--- a/src/urm37/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME urm37
-    DESCRIPTION "Ultrasonic Range Finder"
-    C_HDR urm37.h
-    C_SRC urm37.c
-    CPP_HDR urm37.hpp
-    CPP_SRC urm37.cxx
-    FTI_SRC urm37_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/urm37/urm37.c b/src/urm37/urm37.c
deleted file mode 100644
index 1bd20b1..0000000
--- a/src/urm37/urm37.c
+++ /dev/null
@@ -1,393 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Thanks to Adafruit for supplying a google translated version of the
- * Chinese datasheet and some clues in their code.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string.h>
-
-#include "urm37.h"
-
-#include "upm_utilities.h"
-
-#define URM37_MAX_DATA_LEN      4
-#define URM37_WAIT_TIMEOUT      1000
-#define URM37_MAX_RETRIES       10
-
-urm37_context urm37_init(int a_pin, int reset_pin,
-                         int trigger_pin, float a_ref,
-                         int uart_bus, bool analog_mode)
-{
-  // make sure MRAA is initialized
-  int mraa_rv;
-  if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-  {
-      printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-      return NULL;
-  }
-
-  urm37_context dev = (urm37_context)malloc(sizeof(struct _urm37_context));
-
-  if (!dev)
-    return NULL;
-
-  // clear out context
-  memset((void *)dev, 0, sizeof(struct _urm37_context));
-  
-  // NULL out MRAA contexts for now (redundant with memset I know, but...)
-  dev->aio = NULL;
-  dev->gpio_reset = NULL;
-  dev->gpio_trigger = NULL;
-  dev->uart = NULL;
-
-  dev->a_res = 0;
-  dev->a_ref = a_ref;
-
-  // set the mode
-  dev->is_analog_mode = analog_mode;
-
-  // initialize the MRAA contexts (only what we need)
-
-  // analog only
-  if (dev->is_analog_mode)
-    {
-      if (!(dev->aio = mraa_aio_init(a_pin)))
-        {
-          printf("%s: mraa_aio_init() failed.\n", __FUNCTION__);
-          urm37_close(dev);
-          return NULL;
-        }
-
-      // ADC resolution
-      dev->a_res = (float)(1 << mraa_aio_get_bit(dev->aio)) - 1;
-
-      if (!(dev->gpio_trigger = mraa_gpio_init(trigger_pin)))
-        {
-          printf("%s: mraa_gpio_init(trigger) failed.\n", __FUNCTION__);
-          urm37_close(dev);
-          return NULL;
-        }
-
-      mraa_gpio_dir(dev->gpio_trigger, MRAA_GPIO_OUT);
-      mraa_gpio_write(dev->gpio_trigger, 1);
-    }
-  else
-    {
-      // UART only
-      if (!(dev->uart = mraa_uart_init(uart_bus)))
-        {
-          printf("%s: mraa_uart_init() failed.\n", __FUNCTION__);
-          urm37_close(dev);
-          return NULL;
-        }
-
-      mraa_uart_set_baudrate(dev->uart, 9600);
-      mraa_uart_set_non_blocking(dev->uart, false);
-    }
-
-  // reset - used by both analog and uart modes
-  if (!(dev->gpio_reset = mraa_gpio_init(reset_pin)))
-    {
-      printf("%s: mraa_gpio_init(reset) failed.\n", __FUNCTION__);
-      urm37_close(dev);
-      return NULL;
-    }
-
-  mraa_gpio_dir(dev->gpio_reset, MRAA_GPIO_OUT);
-
-  urm37_reset(dev);
-
-  return dev;
-}
-
-void urm37_close(urm37_context dev)
-{
-  if (dev->aio)
-    mraa_aio_close(dev->aio);
-  if (dev->gpio_reset)
-    mraa_gpio_close(dev->gpio_reset);
-  if (dev->gpio_trigger)
-    mraa_gpio_close(dev->gpio_trigger);
-  if (dev->uart)
-    mraa_uart_stop(dev->uart);
-
-  free(dev);
-}
-
-upm_result_t urm37_reset(urm37_context dev)
-{
-  mraa_gpio_write(dev->gpio_reset, 0);
-  upm_delay_us(100);
-  mraa_gpio_write(dev->gpio_reset, 1);
-
-  // wait for reset to complete
-  upm_delay(3);
-
-  return UPM_SUCCESS;
-}
-
-// private
-static bool urm37_data_available(urm37_context dev, uint32_t millis)
-{
-  if (mraa_uart_data_available(dev->uart, millis))
-    return true;
-  else
-    return false;
-}
-
-// private
-static int urm37_read_data(urm37_context dev, char* data)
-{
-  return mraa_uart_read(dev->uart, data, (size_t)URM37_MAX_DATA_LEN);
-}
-
-// private
-static int urm37_write_data(urm37_context dev, const char* data)
-{
-  mraa_uart_flush(dev->uart);
-  return mraa_uart_write(dev->uart, data, (size_t)URM37_MAX_DATA_LEN);
-}
-
-upm_result_t urm37_send_command(urm37_context dev, char* cmd, char* response)
-{
-  if (dev->is_analog_mode)
-    {
-      printf("%s: UART commands are not available in analog mode\n",
-             __FUNCTION__);
-      
-      return UPM_ERROR_NOT_SUPPORTED;
-    }
-
-  int tries = 0;
-
-  while (tries++ < URM37_MAX_RETRIES)
-    {
-      if (urm37_write_data(dev, cmd) < 0)
-        {
-          // A write error of some kind.  We don't try to continue
-          // after this.
-          printf("%s: write_data() failed\n", __FUNCTION__);
-
-          return UPM_ERROR_OPERATION_FAILED;
-        }
-
-      if (!urm37_data_available(dev, URM37_WAIT_TIMEOUT))
-        {
-          // timeout, retry...
-          continue;
-        }
-
-      int rv = urm37_read_data(dev, response);
-      if (rv < 0)
-        {
-          printf("%s: read_data() failed\n", __FUNCTION__);
-          return UPM_ERROR_OPERATION_FAILED;
-        }
-
-      if (rv != URM37_MAX_DATA_LEN)
-        {
-          // read wrong number of bytes...
-          printf("%s: read_data() returned %d bytes, expected %d, retrying\n",
-                 __FUNCTION__, rv, URM37_MAX_DATA_LEN);
-          continue;
-        }
-      else
-        {
-          // we have data, verify cksum, return the response if it's
-          // good, retry otherwise
-          uint8_t cksum = (uint8_t)(response[0] + response[1] + response[2]);
-
-          if ((uint8_t)response[3] != cksum)
-            {
-              printf("%s: checksum failure: got %d, expected %d, retrying\n",
-                     __FUNCTION__, (int)response[3], (int)cksum);
-              continue;
-            }
-
-          // all good
-          return UPM_SUCCESS;
-        }
-    }
-
-  // If we are here, we timed out and all retries were exhausted
-  return UPM_ERROR_TIMED_OUT;
-}
-
-upm_result_t urm37_get_distance(urm37_context dev, float *distance,
-                                int degrees)
-{
-  if (dev->is_analog_mode)
-    {
-      // analog mode
-      int val;
-
-      // send the trigger pulse and sample
-      mraa_gpio_write(dev->gpio_trigger, 0);
-      val = mraa_aio_read(dev->aio);
-      mraa_gpio_write(dev->gpio_trigger, 1);
-
-      // convert to mV
-      float volts = ((float)val * (dev->a_ref / dev->a_res)) * 1000.0;
-
-      // 6.8 mV/cm
-      *distance = volts/6.8;
-      return UPM_SUCCESS;
-    }
-
-  // UART mode
-
-  char cmd[URM37_MAX_DATA_LEN];
-  char resp[URM37_MAX_DATA_LEN];
-
-  // divide degrees by 6 - this is the encoding URM37 uses.
-  uint8_t deg = (uint8_t)(degrees / 6);
-  if (deg > 46)
-    {
-      printf("%s: Degrees out of range, must be between 0-270\n",
-             __FUNCTION__);
-      return UPM_ERROR_OUT_OF_RANGE;
-    }
-
-  uint8_t cksum = 0x22 + deg + 0x00;
-  cmd[0] = 0x22;
-  cmd[1] = deg;
-  cmd[2] = 0x00;
-  cmd[3] = cksum;
-
-  if (urm37_send_command(dev, cmd, resp) != UPM_SUCCESS)
-    {
-      printf("%s: urm37_send_command() failed\n", __FUNCTION__);
-      return UPM_ERROR_OPERATION_FAILED;
-    }
-
-  uint8_t h = (uint8_t) resp[1];
-  uint8_t l = (uint8_t) resp[2];
-
-  *distance = (float)((h << 8) | l);
-
-  return UPM_SUCCESS;
-}
-
-upm_result_t urm37_get_temperature(urm37_context dev, float* temperature)
-{
-  if (dev->is_analog_mode)
-    {
-      printf("%s: Temperature measurement is not available in analog mode\n",
-             __FUNCTION__);
-      return UPM_ERROR_NOT_SUPPORTED;
-    }
-
-  // UART mode
-  char cmd[URM37_MAX_DATA_LEN];
-
-  // get temperature sequence
-  cmd[0] = 0x11;
-  cmd[1] = 0x00;
-  cmd[2] = 0x00;
-  cmd[3] = 0x11; // cksum
-
-  char resp[URM37_MAX_DATA_LEN];
-  if (urm37_send_command(dev, cmd, resp) != UPM_SUCCESS)
-    {
-      printf("%s: urm37_send_command() failed\n", __FUNCTION__);
-      return UPM_ERROR_OPERATION_FAILED;
-    }
-
-  uint8_t h = (uint8_t) resp[1];
-  uint8_t l = (uint8_t) resp[2];
-
-  *temperature = (float)((h & 0x0f) * 256 + l) / 10.0;
-
-  if (h & 0xf0)
-    *temperature *= -1;
-
-  return UPM_SUCCESS;
-}
-
-upm_result_t urm37_read_eeprom(urm37_context dev, uint8_t addr, uint8_t* value)
-{
-  if (dev->is_analog_mode)
-    {
-      printf("%s: EEPROM is not available in analog mode\n",
-             __FUNCTION__);
-      return UPM_ERROR_NOT_SUPPORTED;
-    }
-
-  if (addr > 0x04)
-    {
-      printf("Address must be between 0x00-0x04");
-      return UPM_ERROR_OUT_OF_RANGE;
-    }
-
-  char cmd[URM37_MAX_DATA_LEN];
-  uint8_t cksum = 0x33 + addr + 0x00;
-  cmd[0] = 0x33;
-  cmd[1] = addr;
-  cmd[2] = 0x00;
-  cmd[3] = cksum;
-
-  char resp[URM37_MAX_DATA_LEN];
-
-  if (urm37_send_command(dev, cmd, resp) != UPM_SUCCESS)
-    {
-      printf("%s: urm37_send_command() failed\n", __FUNCTION__);
-      return UPM_ERROR_OPERATION_FAILED;
-    }
-
-  *value = resp[2];
-  return UPM_SUCCESS;
-}
-
-upm_result_t urm37_write_eeprom(urm37_context dev, uint8_t addr, uint8_t value)
-{
-  if (dev->is_analog_mode)
-    {
-      printf("%s: EEPROM is not available in analog mode\n",
-             __FUNCTION__);
-      return UPM_ERROR_NOT_SUPPORTED;
-    }
-
-  if (addr > 0x04)
-    {
-      printf("Address must be between 0x00-0x04");
-      return UPM_ERROR_OUT_OF_RANGE;
-    }
-
-  char cmd[URM37_MAX_DATA_LEN];
-  uint8_t cksum = 0x44 + addr + value;
-  cmd[0] = 0x44;
-  cmd[1] = addr;
-  cmd[2] = value;
-  cmd[3] = cksum;
-
-  char resp[URM37_MAX_DATA_LEN]; // throw away
-  if (urm37_send_command(dev, cmd, resp) != UPM_SUCCESS)
-    {
-      printf("%s: urm37_send_command() failed\n", __FUNCTION__);
-      return UPM_ERROR_OPERATION_FAILED;
-    }
-
-  return UPM_SUCCESS;
-}
diff --git a/src/urm37/urm37.cxx b/src/urm37/urm37.cxx
deleted file mode 100644
index 485668a..0000000
--- a/src/urm37/urm37.cxx
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <stdexcept>
-
-#include "urm37.hpp"
-
-using namespace upm;
-using namespace std;
-
-URM37::URM37(int aPin, int resetPin, int triggerPin, float aref) :
-  m_urm37(urm37_init(aPin, resetPin, triggerPin, aref, 0, true))
-{
-  if (!m_urm37)
-    throw std::runtime_error(string(__FUNCTION__) +
-                             ": urm37_init() failed");
-}
-
-URM37::URM37(int uart, int resetPin) :
-  m_urm37(urm37_init(0, resetPin, 0, 0, uart, false))
-{
-  if (!m_urm37)
-    throw std::runtime_error(string(__FUNCTION__) +
-                             ": urm37_init() failed");
-}
-
-URM37::~URM37()
-{
-  urm37_close(m_urm37);
-}
-
-void URM37::reset()
-{
-  urm37_reset(m_urm37);
-}
-
-float URM37::getDistance(int degrees)
-{
-  float distance;
-
-  if (urm37_get_distance(m_urm37, &distance, degrees) != UPM_SUCCESS)
-    throw std::runtime_error(string(__FUNCTION__) +
-                             ": urm37_get_distance() failed");
-
-  return (distance);
-}
-
-float URM37::getTemperature()
-{
-  float temperature;
-
-  if (urm37_get_temperature(m_urm37, &temperature) != UPM_SUCCESS)
-    throw std::runtime_error(string(__FUNCTION__) +
-                             ": urm37_get_temperature() failed");
-
-  return temperature;
-}
-
-uint8_t URM37::readEEPROM(uint8_t addr)
-{
-  uint8_t value;
-
-  if (urm37_read_eeprom(m_urm37, addr, &value) != UPM_SUCCESS)
-    throw std::runtime_error(string(__FUNCTION__) +
-                             ": urm37_read_eeprom() failed");
-
-  return value;
-}
-
-void URM37::writeEEPROM(uint8_t addr, uint8_t value)
-{
-  if (urm37_write_eeprom(m_urm37, addr, value) != UPM_SUCCESS)
-    throw std::runtime_error(string(__FUNCTION__) +
-                             ": urm37_write_eeprom() failed");
-}
-
diff --git a/src/urm37/urm37.h b/src/urm37/urm37.h
deleted file mode 100644
index 18cca3e..0000000
--- a/src/urm37/urm37.h
+++ /dev/null
@@ -1,159 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Thanks to Adafruit for supplying a google translated version of the
- * Chinese datasheet and some clues in their code.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef URM37_H_
-#define URM37_H_
-
-#include <stdint.h>
-#include "upm.h"
-#include "mraa/aio.h"
-#include "mraa/gpio.h"
-#include "mraa/uart.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @file urm37.h
- * @library urm37
- * @brief C API for the URM37 Ultrasonic Ranger
- *
- * An example using analog mode
- * @include urm37.c Interesting
- * An example using UART mode
- * @include urm37-uart.c Interesting
- */
-
-/**
- * device context
- */
-typedef struct _urm37_context {
-  mraa_aio_context    aio;
-  mraa_gpio_context   gpio_reset;
-  mraa_gpio_context   gpio_trigger;
-  mraa_uart_context   uart;
-
-  bool                is_analog_mode;
-
-  float               a_ref;
-  float               a_res;
-} *urm37_context;
-
-/**
- * URM37 Initializer
- *
- * @param a_pin Analog pin to use. Ignored in UART mode.
- * @param reset_pin GPIO pin to use for reset
- * @param trigger_pin GPIO pin to use for triggering a distance
- * measurement. Ignored in UART mode.
- * @param a_ref The analog reference voltage. Ignored in UART mode.
- * @param uart Default UART to use (0 or 1). Ignored in analog mode.
- * @param mode true for analog mode, false otherwise.
- */
-urm37_context urm37_init(int a_pin, int reset_pin,
-                         int trigger_pin, float a_ref, 
-                         int uart, bool analog_mode);
-
-/**
- * URM37 sensor close function
- */
-void urm37_close(urm37_context dev);
-
-/**
- * Reset the device.  This will take approximately 3 seconds to
- * complete.
- *
- * @param dev sensor context
- */
-upm_result_t urm37_reset(urm37_context dev);
-
-/**
- * Get the distance measurement.  A return value of 65535.0
- * in UART mode indicates an invalid measurement.
- *
- * @param dev sensor context
- * @param distance A pointer to a float that will contain the distance
- * in CM if the measurement is successful.
- * @param degrees In UART mode, this specifies the degrees to turn an
- * attached PWM servo connected to the MOTO output on the URM37.
- * Valid values are 0-270.  This option is ignored in analog mode.  If
- * you are not using this functionality, just pass 0.
- * @return UPM status code
- */
-upm_result_t urm37_get_distance(urm37_context dev, float *distance,
-                                int degrees);
-
-/**
- * Get the temperature measurement.  This is only valid in UART mode.
- *
- * @param dev sensor context
- * @param temperature A float pointer containing the measured
- * temperature in degrees C
- * @return UPM status code
- *
- */
-upm_result_t urm37_get_temperature(urm37_context dev, float* temperature);
-
-/**
- * In UART mode only, read a value from the EEPROM and return it.
- *
- * @param dev sensor context
- * @param addr The address in the EEPROM to read.  Valid values
- * are between 0x00-0x04.
- * @param value A pointer containing the returned value.
- * @return UPM status code
- */
-upm_result_t urm37_read_eeprom(urm37_context dev, uint8_t addr, uint8_t* value);
-
-/**
- * In UART mode only, write a value into an address on the EEPROM.
- *
- * @param dev sensor context
- * @param addr The address in the EEPROM to write.  Valid values
- * are between 0x00-0x04.
- * @param value The value to write
- * @return UPM status code
- */
-upm_result_t urm37_write_eeprom(urm37_context dev, uint8_t addr, uint8_t value);
-
-/**
- * In UART mode only, send a 4-byte command, and return a 4-byte response.
- *
- * @param dev sensor context
- * @param cmd A 4-byte command to transmit
- * @param response The 4-byte response
- * @return UPM response code (success, failure, or timeout)
- */
-upm_result_t urm37_send_command(urm37_context dev, char* cmd, char* response);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* URM37_H_ */
diff --git a/src/urm37/urm37.hpp b/src/urm37/urm37.hpp
deleted file mode 100644
index 0fe1844..0000000
--- a/src/urm37/urm37.hpp
+++ /dev/null
@@ -1,159 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015-2016 Intel Corporation.
- *
- * Thanks to Adafruit for supplying a google translated version of the
- * Chinese datasheet and some clues in their code.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <iostream>
-
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-
-#include "urm37.h"
-
-namespace upm {
-    /**
-     * @brief URM37 Ultrasonic Ranger
-     * @defgroup urm37 libupm-urm37
-     * @ingroup dfrobot uart gpio analog sound
-     */
-
-    /**
-     * @library urm37
-     * @sensor urm37
-     * @comname Ultrasonic Range Finder
-     * @type sound
-     * @man dfrobot
-     * @con uart analog gpio
-     * @web http://www.dfrobot.com/index.php?route=product/product&product_id=53
-     *
-     * @brief API for the DFRobot URM37 Ultrasonic Ranger
-     *
-     * This library was tested with the DFRobot URM37 Ultrasonic Ranger,
-     * V4.  It has a range of between 5 and 500 centimeters (cm).  It
-     * supports both analog distance measurement, and UART based
-     * temperature and distance measurements.  This driver does not
-     * support PWM measurement mode.
-     *
-     * For UART operation, the only supported baud rate is 9600.  In
-     * addition, you must ensure that the UART TX/RX pins are
-     * configured for TTL operation (the factory default) rather than
-     * RS232 operation, or permanent damage to your URM37 and/or MCU
-     * will result.  On power up, the LED indicator will blink one
-     * long pulse, followed by one short pulse to indicate TTL
-     * operation.  See the DFRobot wiki for more information:
-     *
-     * (https://www.dfrobot.com/wiki/index.php?title=URM37_V4.0_Ultrasonic_Sensor_%28SKU:SEN0001%29)
-     *
-     * @image html urm37.jpg
-     * An example using analog mode
-     * @snippet urm37.cxx Interesting
-     * An example using UART mode
-     * @snippet urm37-uart.cxx Interesting
-     */
-
-  class URM37 {
-  public:
-
-    /**
-     * URM37 object constructor (Analog mode)
-     *
-     * @param aPin Analog pin to use
-     * @param resetPin GPIO pin to use for reset
-     * @param triggerPin GPIO pin to use for triggering a distance measurement
-     * @param aref The analog reference voltage, default 5.0
-     */
-    URM37(int aPin, int resetPin, int triggerPin, float aref=5.0);
-
-    /**
-     * URM37 object constructor (UART mode)
-     *
-     * @param uart Default UART to use (0 or 1).
-     * @param resetPin GPIO pin to use for reset
-     */
-    URM37(int uart, int resetPin);
-
-    /**
-     * URM37 object destructor
-     */
-    ~URM37();
-
-    /**
-     * Reset the device.  This will take approximately 3 seconds to
-     * complete.
-     *
-     */
-    void reset();
-
-    /**
-     * Get the distance measurement.  A return value of 65535.0
-     * in UART mode indicates an invalid measurement.
-     *
-     * @param degrees in UART mode, this specifies the degrees to turn
-     * an attached PWM servo connected to the MOTO output on the
-     * URM37.  Default is 0.  Valid values are 0-270.  This option is
-     * ignored in analog mode.
-     * @return The measured distance in cm
-     */
-    float getDistance(int degrees=0);
-
-    /**
-     * Get the temperature measurement.  This is only valid in UART mode.
-     *
-     * @return The measured temperature in degrees C
-     */
-    float getTemperature();
-
-    /**
-     * In UART mode only, read a value from the EEPROM and return it.
-     *
-     * @param addr The address in the EEPROM to read.  Valid values
-     * are between 0x00-0x04.
-     * @return The EEPROM value at addr
-     */
-    uint8_t readEEPROM(uint8_t addr);
-
-    /**
-     * In UART mode only, write a value into an address on the EEPROM.
-     *
-     * @param addr The address in the EEPROM to write.  Valid values
-     * are between 0x00-0x04.
-     * @param value The value to write
-     * @return The EEPROM value at addr
-     */
-    void writeEEPROM(uint8_t addr, uint8_t value);
-
-  protected:
-    // urm37 device context
-    urm37_context m_urm37;
-
-  private:
-    /* Disable implicit copy and assignment operators */
-    URM37(const URM37&) = delete;
-    URM37 &operator=(const URM37&) = delete;
-  };
-}
diff --git a/src/urm37/urm37.i b/src/urm37/urm37.i
deleted file mode 100644
index 16cd9fc..0000000
--- a/src/urm37/urm37.i
+++ /dev/null
@@ -1,14 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_urm37)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "urm37.hpp"
-%}
-%include "urm37.hpp"
-/* END Common SWIG syntax */
diff --git a/src/urm37/urm37.json b/src/urm37/urm37.json
deleted file mode 100644
index d5daeeb..0000000
--- a/src/urm37/urm37.json
+++ /dev/null
@@ -1,50 +0,0 @@
-{
-    "Library": "urm37",
-    "Description": "DFRobot URM37 Ultrasonic Ranger Library",
-    "Sensor Class": {
-        "URM37": {
-            "Name": "API for the DFRobot URM37 Ultrasonic Ranger",
-            "Description": "This is the UPM Module for the DFRobot URM37 Ultrasonic Ranger. This library was tested with the DFRobot URM37 Ultrasonic Ranger, V4.  It has a range of between 5 and 500 centimeters (cm).  It supports both analog distance measurement, and UART based temperature and distance measurements.  This driver does not support PWM measurement mode. For UART operation, the only supported baud rate is 9600.  In addition, you must ensure that the UART TX/RX pins are configured for TTL operation (the factory default) rather than RS232 operation, or permanent damage to your URM37 and/or MCU will result.  On power up, the LED indicator will blink one long pulse, followed by one short pulse to indicate TTL operation.",
-            "Aliases": ["urm37", "URM37 V4.0 Ultrasonic Sensor"],
-            "Categories": ["sound"],
-            "Connections": ["uart", "ainput", "gpio"],
-            "Project Type": ["prototyping", "robotics", "commercial"],
-            "Manufacturers": ["DFRobot"],
-            "Image": "urm37.jpg",
-            "Examples": {
-                "Python": ["urm37-uart.py", "urm37.py"],
-                "Node.js": ["urm37-uart.js", "urm37.js"],
-                "C++": ["urm37-uart.cxx", "urm37.cxx"],
-                "C": ["urm37-uart.c", "urm37.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.3,
-                    "max": 5.0
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "typ" : "<20"
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -10,
-                    "max": 70
-                },
-                "Effective Range": {
-                    "unit": "cm",
-                    "min" : 5,
-                    "max" : 500
-                },
-                "Resolution": {
-                    "unit": "cm",
-                    "resolution": 1
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.dfrobot.com/product-53.html", "https://www.dfrobot.com/wiki/index.php/URM37_V4.0_Ultrasonic_Sensor_(SKU:SEN0001)"]
-            }
-        }
-    }
-}
diff --git a/src/urm37/urm37_fti.c b/src/urm37/urm37_fti.c
deleted file mode 100644
index 653a75b..0000000
--- a/src/urm37/urm37_fti.c
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- *         Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Thanks to Adafruit for supplying a google translated version of the
- * Chinese datasheet and some clues in their code.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "urm37.h"
-#include "upm_fti.h"
-
-/** 
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_light_name[] = "URM37";
-const char upm_light_description[] = "Ultrasonic Ranger";
-// problem here is it's an either/or analog vs. uart.  So we will just
-// only support analog for now
-// 1st gpio is reset, 2nd is trigger
-const upm_protocol_t upm_light_protocol[] = {UPM_ANALOG, UPM_GPIO, UPM_GPIO};
-const upm_sensor_t upm_light_category[] = {UPM_DISTANCE};
-
-// forward declarations
-const void* upm_urm37_get_ft(upm_sensor_t sensor_type);
-void* upm_urm37_init_name();
-void upm_urm37_close(void* dev);
-upm_result_t upm_urm37_get_distance(void* dev, float* distance,
-                                    upm_distance_u unit);
-
-static const upm_sensor_ft ft =
-{
-    .upm_sensor_init_name = &upm_urm37_init_name,
-    .upm_sensor_close = &upm_urm37_close,
-};
-
-static const upm_distance_ft dft =
-{
-    .upm_distance_get_value = &upm_urm37_get_distance
-};
-
-const void* upm_urm37_get_ft(upm_sensor_t sensor_type)
-{
-  switch(sensor_type)
-    {
-    case UPM_SENSOR:
-      return &ft;
-      
-    case UPM_DISTANCE:
-      return &dft;
-      
-    default:
-      return NULL;
-    }
-}
-
-void* upm_urm37_init_name()
-{
-    return NULL;
-}
-
-
-void upm_urm37_close(void* dev)
-{
-    urm37_close((urm37_context)dev);
-}
-
-upm_result_t upm_urm37_get_distance(void* dev, float* distance,
-                                    upm_distance_u unit)
-{
-  // only cm returned by sensor
-  float dist;
-  urm37_get_distance((urm37_context)dev, &dist, 0);
-
-  switch(unit)
-    {
-    case CENTIMETER:
-      *distance = dist;
-      return UPM_SUCCESS;
-
-    case INCH:
-      *distance = dist / 2.54;
-      return UPM_SUCCESS;
-
-    default:
-      return UPM_ERROR_INVALID_PARAMETER;
-    }
-}
-
diff --git a/src/vcap/CMakeLists.txt b/src/vcap/CMakeLists.txt
deleted file mode 100644
index 83964db..0000000
--- a/src/vcap/CMakeLists.txt
+++ /dev/null
@@ -1,10 +0,0 @@
-set (libname "vcap")
-set (libdescription "Video Frame Capture and Image Save Utility")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-
-if (JPEG_FOUND)
-    set (reqlibname "jpeg")
-    upm_module_init()
-    target_link_libraries(${libname} jpeg)
-endif()
diff --git a/src/vcap/vcap.cxx b/src/vcap/vcap.cxx
deleted file mode 100644
index 9318271..0000000
--- a/src/vcap/vcap.cxx
+++ /dev/null
@@ -1,524 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <stdexcept>
-#include <unistd.h>
-#include <stdio.h>
-#include <math.h>
-#include <string.h>
-
-#include "vcap.hpp"
-
-using namespace upm;
-using namespace std;
-
-#define CLAMP(_val, _min, _max) \
-  (((_val) < (_min)) ? (_min) : (((_val) > (_max)) ? (_max) : (_val)))
-
-VCAP::VCAP(string videoDev) :
-    m_fd(-1), m_buffer(0)
-{
-  memset(&m_caps, 0, sizeof(struct v4l2_capability));
-  memset(&m_format, 0, sizeof(struct v4l2_format));
-  
-  m_debugging = false;
-  m_bufferLen = 0;
-  m_videoDevice = videoDev;
-  setJPGQuality(VCAP_DEFAULT_JPEG_QUALITY);
-
-  // try to open the video device, and set a default format.
-  if (!initVideoDevice())
-    throw std::runtime_error(std::string(__FUNCTION__) +
-                             ": initVideoDevice() failed");
-
-  m_height = 0;
-  m_width = 0;
-  m_imageCaptured = false;
-}
-
-VCAP::~VCAP()
-{
-  releaseBuffer();
-
-  if (m_fd >= 0)
-    close(m_fd);
-
-  m_fd = -1;
-}
-
-bool VCAP::initVideoDevice()
-{
-  if (m_videoDevice.empty())
-    return false;
-
-  if ((m_fd = open(m_videoDevice.c_str(), O_RDWR)) < 0)
-    {
-      cerr << __FUNCTION__ << ": open failed: " << strerror(errno) << endl;
-      return false;
-    }
-  
-  if (!checkCapabilities())
-    {
-      close(m_fd);
-      m_fd = -1;
-      return false;
-    }
-
-  return true;
-}
-
-// This seems... odd, but appears to be necessary.
-// Ignore error and retry if the ioctl fails due to EINTR
-int VCAP::xioctl(int fd, int request, void* argp)
-{
-  int r;
-  
-  do {
-    r = ioctl(fd, request, argp);
-  }
-  while (r == -1 && errno == EINTR);
-  
-  return r;
-}
-
-bool VCAP::checkCapabilities()
-{
-  if (xioctl(m_fd, VIDIOC_QUERYCAP, &m_caps) < 0)
-    {
-      cerr << __FUNCTION__ << ": ioctl(VIDIOC_QUERYCAP) failed: "
-           << strerror(errno) << endl;
-      return false;
-    }
-  
-  if (m_debugging)
-    {
-      cerr << "Driver: " << m_caps.driver << endl;
-      cerr << "Device: "  << m_caps.card << endl;
-      cerr << "Caps  : 0x" << std::hex << m_caps.capabilities << std::dec
-           << endl;
-    }
-
-  // see if capturing is supported
-  if (!(m_caps.capabilities & V4L2_CAP_VIDEO_CAPTURE))
-    {
-      cerr << __FUNCTION__ << ": Device does not support video capture"
-           << endl;
-      return false;
-    }
-
-  if (!(m_caps.capabilities & V4L2_CAP_STREAMING))
-    {
-      cerr << __FUNCTION__ << ": Device does not support streaming I/O"
-           << endl;
-      return false;
-    }
-
-  return true;
-}
-
-bool VCAP::setResolution(int width, int height)
-{
-  // in case we already created one
-  releaseBuffer();
-
-  m_width = width;
-  m_height = height;
-
-  m_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-  // initialize with the current format
-  if (xioctl(m_fd, VIDIOC_G_FMT, &m_format) < 0)
-    {
-      cerr << __FUNCTION__ << ": ioctl(VIDIOC_G_FMT) failed: "
-           << strerror(errno) << endl;
-      return false;
-    }
-
-  // make our changes...
-  m_format.fmt.pix.width = m_width;
-  m_format.fmt.pix.height = m_height;
-  m_format.fmt.pix.pixelformat = V4L2_PIX_FMT_YUYV;
-  m_format.fmt.pix.field = V4L2_FIELD_ANY;
-        
-  if (xioctl(m_fd, VIDIOC_S_FMT, &m_format) < 0)
-    {
-      cerr << __FUNCTION__ << ": ioctl(VIDIOC_S_FMT) failed: "
-           << strerror(errno) << endl;
-
-      // If it's just busy, then this still might work, so don't fail here
-      if (errno != EBUSY)
-        return false;
-    }
-
-  // Now retrieve the driver's selected format and check it -
-  // specifically, the width and height might change, causing
-  // coredumps if we don't adjust them accordingly.
-
-  if (xioctl(m_fd, VIDIOC_G_FMT, &m_format) < 0)
-    {
-      cerr << __FUNCTION__ << ": ioctl(VIDIOC_G_FMT) failed: "
-           << strerror(errno) << endl;
-      return false;
-    }
-
-  // G_FMT will have adjusted these if neccessary, so verify
-  if (static_cast<int>(m_format.fmt.pix.width) != m_width)
-    {
-      if (m_debugging)
-        cerr << __FUNCTION__ << ": Warning: Selected width "
-             << std::to_string(m_width)
-             << " adjusted by driver to "
-             << std::to_string(m_format.fmt.pix.width)
-             << endl;
-
-      m_width = m_format.fmt.pix.width;
-    }
-  
-  if (static_cast<int>(m_format.fmt.pix.height) != m_height)
-    {
-      if (m_debugging)
-        cerr << __FUNCTION__ << ": Warning: Selected height "
-             << std::to_string(m_height)
-             << " adjusted by driver to "
-             << std::to_string(m_format.fmt.pix.height)
-             << endl;
-
-      m_height = m_format.fmt.pix.height;
-    }
-
-  // now alloc the buffers here
-  if (!allocBuffer())
-    return false;
-
-  return true;
-}
- 
-bool VCAP::allocBuffer()
-{
-  struct v4l2_requestbuffers rb;
-  memset(&rb, 0, sizeof(rb));
-
-  // we just want one buffer, and we only support mmap().
-  rb.count = 1;
-  rb.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-  rb.memory = V4L2_MEMORY_MMAP;
- 
-  if (xioctl(m_fd, VIDIOC_REQBUFS, &rb) < 0)
-    {
-      if (errno == EINVAL)
-        {
-          cerr << __FUNCTION__ << ": Capture device does not support mmapped "
-               << "buffers"
-               << endl;
-        }
-      cerr << __FUNCTION__ << ": ioctl(VIDIOC_REQBUFS) failed: "
-           << strerror(errno) << endl;
-      
-      return false;
-    }
- 
-  // get the buffer and mmap it
-  struct v4l2_buffer mbuf;
-  memset(&mbuf, 0, sizeof(mbuf));
-
-  mbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-  mbuf.memory = V4L2_MEMORY_MMAP;
-  mbuf.index = 0;
-
-  if (xioctl(m_fd, VIDIOC_QUERYBUF, &mbuf) < 0)
-    {
-      cerr << __FUNCTION__ << ": ioctl(VIDIOC_QUERYBUF) failed: "
-           << strerror(errno) << endl;
-      return false;
-    }
- 
-  // map it
-  m_buffer = (unsigned char *)mmap(NULL, mbuf.length, 
-                                   PROT_READ | PROT_WRITE, MAP_SHARED, 
-                                   m_fd, mbuf.m.offset);
-
-  if (m_buffer == MAP_FAILED)
-    {
-      cerr << __FUNCTION__ << ": mmap() failed: "
-           << strerror(errno) << endl;
-      return false;
-    }
-
-  // we'll need this when unmapping
-  m_bufferLen = mbuf.length;
-  
-  return true;
-}
-
-void VCAP::releaseBuffer()
-{
-  // first unmap any buffers
-  if (m_buffer)
-    munmap(m_buffer, m_bufferLen);
-
-  m_buffer = 0;
-  m_bufferLen = 0;
-
-  // then, tell the kernel driver to free any allocated buffer(s)...
-  struct v4l2_requestbuffers rb;
-  memset(&rb, 0, sizeof(rb));
-
-  rb.count = 0;
-  rb.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-  rb.memory = V4L2_MEMORY_MMAP;
- 
-  if (xioctl(m_fd, VIDIOC_REQBUFS, &rb) < 0)
-    {
-      cerr << __FUNCTION__ << ": ioctl(VIDIOC_REQBUFS) failed while freeing: "
-           << strerror(errno) << endl;
-    }
-
-  // reset captured flag
-  m_imageCaptured = false;
-}
-
-
-bool VCAP::YUYV2JPEG(FILE *file)
-{
-  struct jpeg_compress_struct jpgInfo;
-  struct jpeg_error_mgr jerr;
-  JSAMPROW row_pointer[1];
-  unsigned char *row_buffer = NULL;
-  unsigned char *yuyv = NULL;
-  int z;
-
-  row_buffer = (unsigned char *)calloc(m_width * 3, 1);
-  if (!row_buffer)
-    {
-      cerr << __FUNCTION__ << ": allocation of line buffer failed."
-           << endl;
-      return false;
-    }
-
-  yuyv = m_buffer;
-
-  jpgInfo.err = jpeg_std_error(&jerr);
-  jpeg_create_compress(&jpgInfo);
-  jpeg_stdio_dest(&jpgInfo, file);
-
-  jpgInfo.image_width = m_width;
-  jpgInfo.image_height = m_height;
-
-  // components R, G, B
-  jpgInfo.input_components = 3;
-  jpgInfo.in_color_space = JCS_RGB;
-
-  jpeg_set_defaults(&jpgInfo);
-  jpeg_set_quality(&jpgInfo, m_jpgQuality, TRUE);
-
-  jpeg_start_compress(&jpgInfo, TRUE);
-
-  z = 0;
-
-  while (jpgInfo.next_scanline < jpgInfo.image_height)
-    {
-      int x;
-      unsigned char *ptr = row_buffer;
-      
-      for (x = 0; x < m_width; x++)
-        {
-          int r, g, b;
-          int y, u, v;
-          
-          if (!z)
-            y = yuyv[0] << 8;
-          else
-            y = yuyv[2] << 8;
-          u = yuyv[1] - 128;
-          v = yuyv[3] - 128;
-          
-          r = (y + (359 * v)) >> 8;
-          g = (y - (88 * u) - (183 * v)) >> 8;
-          b = (y + (454 * u)) >> 8;
-          
-          *(ptr++) = CLAMP(r, 0, 255);
-          *(ptr++) = CLAMP(g, 0, 255);
-          *(ptr++) = CLAMP(b, 0, 255);
-          
-          if (z++)
-            {
-              z = 0;
-              yuyv += 4;
-            }
-        }
-      
-      row_pointer[0] = row_buffer;
-      jpeg_write_scanlines(&jpgInfo, row_pointer, 1);
-    }
-
-  jpeg_finish_compress(&jpgInfo);
-  jpeg_destroy_compress(&jpgInfo);
-
-  free(row_buffer);
-
-  return true;
-}
-
-bool VCAP::saveImage(string filename)
-{
-  // check m_buffer to make sure we have an actual buffer... If not,
-  // we throw here.
-  if (!m_buffer)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": no buffer.  Call setResolution() first");
-    }
-
-  // if we haven't done at least one capture yet...
-  if (!m_imageCaptured)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": No data, call captureImage() first");
-    }
-
-  FILE *file;
-  if ((file = fopen(filename.c_str(), "wb")) == NULL)
-    {
-      cerr << __FUNCTION__ << ": fopen() failed: "
-           << strerror(errno) << endl;
-      return false;
-    }
-  
-  YUYV2JPEG(file);
-  fclose(file);
-
-  if (m_debugging)
-    cerr << __FUNCTION__ << ": Saved image to " << filename << endl;
-
-  return true;
-}
-
-bool VCAP::captureImage()
-{
-  // first, make sure a resolution was specified.  If not, set the
-  // default
-  if (m_width == 0 || m_height == 0)
-    {
-      if (!setResolution(VCAP_DEFAULT_WIDTH, VCAP_DEFAULT_HEIGHT))
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": setResolution() failed");
-    }
-
-  // we basically just call doCaptureImage() twice - once to grab and
-  // discard the first frame (which is usually a remnent of a previous
-  // capture), and another to grab the real frame we are interesed in.
-
-  if (!doCaptureImage())
-    {
-      cerr << __FUNCTION__ << ": capture of first frame failed"
-           << endl;
-    }
-
-  return doCaptureImage();
-}
-
-
-// the real workhorse
-bool VCAP::doCaptureImage()
-{
-  struct v4l2_buffer buf = {0};
-  buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-  buf.memory = V4L2_MEMORY_MMAP;
-  buf.index = 0;
-
-  // queue our buffer
-  if (xioctl(m_fd, VIDIOC_QBUF, &buf) < 0)
-    {
-      cerr << __FUNCTION__ << ": ioctl(VIDIOC_QBUF) failed: "
-           << strerror(errno) << endl;
-
-      return false;
-    }
-  
-  // enable streaming
-  if (xioctl(m_fd, VIDIOC_STREAMON, &buf.type) < 0)
-    {
-      cerr << __FUNCTION__ << ": ioctl(VIDIOC_STREAMON) failed: "
-           << strerror(errno) << endl;
-
-      return false;
-    }
-
-  // use select to wait for a complete frame.
-  fd_set fds;
-
-  FD_ZERO(&fds);
-  FD_SET(m_fd, &fds);
-
-  struct timeval tv;
-  memset(&tv, 0, sizeof(tv));
-
-  // 5 seconds should be more than enough
-  tv.tv_sec = 5;
-
-  int rv;
-  if ((rv = select(m_fd + 1, &fds, NULL, NULL, &tv)) < 0)
-    {
-      cerr << __FUNCTION__ << ": select() failed: "
-           << strerror(errno) << endl;
-      return false;
-    }
-
-  if (!rv)
-    {
-      // timed out
-      cerr << __FUNCTION__ << ": select() timed out waiting for frame"
-           << endl;
-
-      return false;
-    }
-
-  // de-queue the buffer, we're now free to access it via the mmapped
-  // ptr (m_buffer)
-  if (xioctl(m_fd, VIDIOC_DQBUF, &buf) < 0)
-    {
-      cerr << __FUNCTION__ << ": ioctl(VIDIOC_DQBUF) failed: "
-           << strerror(errno) << endl;
-
-      return false;
-    }
-
-  // turn off streaming
-  if (xioctl(m_fd, VIDIOC_STREAMOFF, &buf.type) < 0)
-    {
-      cerr << __FUNCTION__ << ": ioctl(VIDIOC_STREAMOFF) failed: "
-           << strerror(errno) << endl;
-
-      return false;
-    }
-    
-  m_imageCaptured = true;
-
-  return true;
-}
-
- void VCAP::setJPGQuality(unsigned int qual)
- {
-   m_jpgQuality = CLAMP(qual, 0, 100);
- }
diff --git a/src/vcap/vcap.hpp b/src/vcap/vcap.hpp
deleted file mode 100644
index 482b22b..0000000
--- a/src/vcap/vcap.hpp
+++ /dev/null
@@ -1,215 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <iostream>
-
-#include <errno.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <jpeglib.h>
-#include <linux/videodev2.h>
-
-#define VCAP_DEFAULT_VIDEODEV "/dev/video0"
-#define VCAP_DEFAULT_OUTPUTFILE "vcap.jpg"
-#define VCAP_DEFAULT_WIDTH 640
-#define VCAP_DEFAULT_HEIGHT 480
-#define VCAP_DEFAULT_JPEG_QUALITY 99
-
-namespace upm {
-    /**
-     * @brief Video Frame Capture and JPEG Image Save Library
-     *
-     * Take a snapshot from a USB video camera and save as a JPEG
-     *
-     * @defgroup vcap libupm-vcap
-     * @ingroup video
-     */
-
-    /**
-     * @library vcap
-     * @sensor vcap
-     * @comname Video Frame Capture and Image Save Utility
-     * @type video
-     *
-     * @brief API for the Video Capture driver
-     *
-     * This UPM module captures a still frame from a Linux V4L device,
-     * such as a USB webcam, and and then allows you to save it as a
-     * JPEG image into a file.
-     *
-     * The camera and driver in use must support streaming, mmap-able
-     * buffers and must provide data in YUYV format.  This should
-     * encompass most video cameras out there.  It has been tested
-     * with a few off the shelf cameras without any problems.
-     *
-     * @snippet vcap.cxx Interesting
-     */
-
-  class VCAP {
-  public:
-
-    /**
-     * VCAP object constructor
-     *
-     * @param videoDev The path to the video device, default is /dev/video0.
-     */
-    VCAP(std::string videoDev=VCAP_DEFAULT_VIDEODEV);
-
-    /**
-     * VCAP object destructor
-     */
-    ~VCAP();
-
-    /**
-     * Set the desired resolution of the output image.  Note, this is
-     * a hint to the underlying video driver.  The video driver is
-     * free to lower the specified resolution if the hardware cannot
-     * support it.  You can use getHeight() and getWidth() after
-     * calling this method to see what the video driver chose.
-     *
-     * @param width The desired width of the image.
-     * @param width The desired height of the image.
-     * @return true if the operation succeeded, false otherwise.
-     */
-    bool setResolution(int width, int height);
-
-    /**
-     * Capture an image from the camera.
-     *
-     * @return true if the operation succeeded, false otherwise.
-     */
-    bool captureImage();
-
-    /**
-     * Save the captured image (created with captureImage()) to a file
-     * in JPEG format.  The file will be overwritten if it already
-     * exists.
-     *
-     * @param filename The name of the file in which to store the image.
-     * @return true if the operation succeeded, false otherwise.
-     */
-    bool saveImage(std::string filename=VCAP_DEFAULT_OUTPUTFILE);
-
-    /**
-     * Return the current width of the image.  You can use this method
-     * to determine if the video driver downgraded it after a call to
-     * setResolution().
-     *
-     * @return true Current width of capture.
-     */
-    int getWidth() const
-    {
-      return m_width;
-    };
-
-    /**
-     * Return the current height of the image.  You can use this method
-     * to determine if the video driver downgraded it after a call to
-     * setResolution().
-     *
-     * @return true Current height of capture.
-     */
-    int getHeight() const
-    {
-      return m_height;
-    };
-
-    /**
-     * Set the JPEG quality.
-     *
-     * @param quality A number between 0-100, with higher numbers
-     * meaning higher quality. Numbers less than 0 will be clamped to
-     * 0, numbers higher than 100 will be clamped to 100.
-     */
-    void setJPGQuality(unsigned int quality);
-
-    /**
-     * Get the current JPEG quality setting.
-     *
-     * @return the current JPEG quality setting.
-     */
-    int getJPGQuality() const
-    {
-      return m_jpgQuality;
-    };
-
-    /**
-     * Enable or disable debugging output.
-     *
-     * @param enable true to enable debugging, false otherwise
-     */
-    void setDebug(bool enable)
-    {
-      m_debugging = enable;
-    };
-
-  protected:
-    // open the device and check that it meats minimum requirements
-    bool initVideoDevice();
-
-    // make sure device is streamable, supports mmap and capture
-    bool checkCapabilities();
-
-    // read the mmapped buffer in YUYV format and create a jpeg image
-    bool YUYV2JPEG(FILE *file);
-
-    // buffer management
-    bool allocBuffer();
-    void releaseBuffer();
-
-    // does the actual capture
-    bool doCaptureImage();
-
-  private:
-    // internal ioctl
-    int xioctl(int fd, int request, void* argp);
-
-    std::string m_videoDevice;
-
-    // our file descriptor to the video device
-    int m_fd;
-
-    // v4l info
-    struct v4l2_capability m_caps;
-    struct v4l2_format m_format;
-
-    // our mmaped buffer
-    unsigned char *m_buffer;
-    size_t m_bufferLen;
-
-    // the resolution and quality
-    int m_width;
-    int m_height;
-    int m_jpgQuality;
-
-    // at least one image captured with current settings?
-    bool m_imageCaptured;
-
-    // are we debugging?
-    bool m_debugging;
-  };
-}
diff --git a/src/vcap/vcap.i b/src/vcap/vcap.i
deleted file mode 100644
index f7f5bff..0000000
--- a/src/vcap/vcap.i
+++ /dev/null
@@ -1,14 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_vcap)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "vcap.hpp"
-%}
-%include "vcap.hpp"
-/* END Common SWIG syntax */
diff --git a/src/vcap/vcap.json b/src/vcap/vcap.json
deleted file mode 100644
index c190bdc..0000000
--- a/src/vcap/vcap.json
+++ /dev/null
@@ -1,24 +0,0 @@
-{
-    "Library": "vcap",
-    "Description": "Take a snapshot from a video camera and save as a JPEG",
-    "Sensor Class": {
-        "VCAP": {
-            "Name": "API for the Video Capture driver",
-            "Description": "This is the UPM Module for the Video Capture driver. This UPM module captures a still frame from a Linux V4L device, such as a USB webcam, and and then allows you to save it as a JPEG image into a file. The camera and driver in use must support streaming, mmap-able buffers and must provide data in YUYV format.  This should encompass most video cameras out there.  It has been tested with a few off the shelf cameras without any problems.",
-            "Aliases": ["vcap"],
-            "Categories": ["video"],
-            "Connections": ["other"],
-            "Project Type": ["medical", "industrial", "commercial", "prototyping"],
-            "Manufacturers": ["other"],
-            "Examples": {
-                "Java": ["VCAP_Example.java"],
-                "Python": ["vcap.py"],
-                "Node.js": ["vcap.js"],
-                "C++": ["vcap.cxx"]
-            },
-            "Urls": {
-                "Product Pages": ["https://github.com/intel-iot-devkit/upm/tree/master/src/vcap"]
-            }
-        }
-    }
-}
diff --git a/src/vdiv/CMakeLists.txt b/src/vdiv/CMakeLists.txt
deleted file mode 100644
index cd83146..0000000
--- a/src/vdiv/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-upm_mixed_module_init (NAME vdiv
-    DESCRIPTION "Analog Voltage Divider Sensor"
-    C_HDR vdiv.h
-    C_SRC vdiv.c
-    CPP_HDR vdiv.hpp
-    CPP_SRC vdiv.cxx
-    FTI_SRC vdiv_fti.c
-    REQUIRES mraa)
diff --git a/src/vdiv/vdiv.c b/src/vdiv/vdiv.c
deleted file mode 100644
index c929eaf..0000000
--- a/src/vdiv/vdiv.c
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * Author: Noel Eck <noel.eck@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string.h>
-#include <stdlib.h>
-
-#include "vdiv.h"
-
-vdiv_context vdiv_init(int16_t pin, float voltage_ref)
-{
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        return NULL;
-    }
-
-    vdiv_context dev = (vdiv_context)malloc(sizeof(struct _vdiv_context));
-
-    if (dev == NULL) return NULL;
-
-    /* Init aio pin */
-    dev->aio = mraa_aio_init(pin);
-
-    if (dev->aio == NULL) {
-        free(dev);
-        return NULL;
-    }
-
-    /* Set defaults */
-    dev->m_aRef = 5.0;
-    dev->m_scale = 1.0;
-    dev->m_offset = 0.0;
-    dev->m_vdiv_sw = 3;
-
-    return dev;
-}
-
-void vdiv_close(vdiv_context dev)
-{
-    mraa_aio_close(dev->aio);
-    free(dev);
-}
-
-upm_result_t vdiv_set_scale(const vdiv_context dev, float scale)
-{
-    dev->m_scale = scale;
-    return UPM_SUCCESS;
-}
-
-upm_result_t vdiv_set_offset(const vdiv_context dev, float offset)
-{
-    dev->m_offset = offset;
-    return UPM_SUCCESS;
-}
-
-float vdiv_get_scale(const vdiv_context dev)
-{
-    return dev->m_scale;
-}
-
-float vdiv_get_offset(const vdiv_context dev)
-{
-    return dev->m_offset;
-}
-
-upm_result_t vdiv_set_divsw(const vdiv_context dev, int vdiv_sw)
-{
-    dev->m_vdiv_sw = vdiv_sw;
-    return UPM_SUCCESS;
-}
-
-int vdiv_get_divsw(const vdiv_context dev)
-{
-    return dev->m_vdiv_sw;
-}
-
-upm_result_t vdiv_get_raw_volts(const vdiv_context dev, float *value)
-{
-    *value = mraa_aio_read_float(dev->aio);
-    if (*value < 0)
-        return UPM_ERROR_OPERATION_FAILED;
-
-    /* Scale by the ADC reference voltage */
-    *value *= dev->m_aRef;
-
-    return UPM_SUCCESS;
-}
-
-upm_result_t vdiv_get_computed_volts(const vdiv_context dev, float *value)
-{
-    // JET - this is wrong.
-
-    *value = mraa_aio_read_float(dev->aio);
-    if (*value < 0)
-        return UPM_ERROR_OPERATION_FAILED;
-
-     /* Apply raw scale */
-    *value *= dev->m_scale;
-
-    /* Scale to the ADC referecen then to vdiv gain */
-    *value *= dev->m_aRef * dev->m_vdiv_sw;
-
-    /* Apply the offset in volts */
-    *value += dev->m_offset;
-
-    return UPM_SUCCESS;
-}
diff --git a/src/vdiv/vdiv.cxx b/src/vdiv/vdiv.cxx
deleted file mode 100644
index 867cf66..0000000
--- a/src/vdiv/vdiv.cxx
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "vdiv.hpp"
-
-using namespace upm;
-using namespace std;
-
-VDiv::VDiv(int pin)
-{
-  if ( !(m_aio = mraa_aio_init(pin)) )
-    {
-      throw std::invalid_argument(std::string(__FUNCTION__) +
-                                  ": mraa_aio_init() failed, invalid pin?");
-      return;
-    }
-}
-
-VDiv::~VDiv()
-{
-  mraa_aio_close(m_aio);
-}
-
-unsigned int VDiv::value(unsigned int samples)
-{
-  int sum = 0;
-
-  for (unsigned int i=0; i<samples; i++)
-    {
-      sum += mraa_aio_read(m_aio);
-      if (sum == -1) return 0;
-      usleep(2000);
-    }
-        
-  return (sum / samples);
-}
-
-float VDiv::computedValue(uint8_t gain, unsigned int val, int vref, int res)
-{
-  return ((float(gain) * float(val) * float(vref) / float(res)) / 1000.0);
-
-}
-
diff --git a/src/vdiv/vdiv.h b/src/vdiv/vdiv.h
deleted file mode 100644
index 2607884..0000000
--- a/src/vdiv/vdiv.h
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
- * Author: Noel Eck <noel.eck@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include "upm.h"
-#include "mraa/aio.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @file vdiv.h
- * @library vdiv
- * @brief C API for Voltage Dividers
- *
- * @include vdiv.c
- */
-
-/**
- * device context
- */
-typedef struct _vdiv_context {
-    /* mraa aio pin context */
-    mraa_aio_context aio;
-    /* ADC voltage reference */
-    float m_aRef;
-    /* Scale */
-    float m_scale;
-    /* Offset in sensor units */
-    float m_offset;
-    /* Offset in sensor units */
-    int m_vdiv_sw;
-} *vdiv_context;
-
-
-/**
- * Initialize analog sensor
- * @param pin is Analog pin
- * @return sensor context as void pointer
- */
-vdiv_context vdiv_init(int16_t pin, float voltage_ref);
-
-/**
- * Analog sensor destructor
- * @param sensor context pointer deallocate memory
- */
-void vdiv_close(vdiv_context dev);
-
-/**
- * Set sensor scale.  This scale is applied to the return value:
- *     counts = counts * scale
- * @param dev sensor context pointer
- * @param scale count scale value used
- * @return Function result code
- */
-upm_result_t vdiv_set_scale(const vdiv_context dev, float scale);
-
-/**
- * Set sensor offset.  This offset is applied to the return value:
- *     counts = counts + offset
- * @param dev sensor context pointer
- * @param offset count offset value used
- * @return Function result code
- */
-upm_result_t vdiv_set_offset(const vdiv_context dev, float offset);
-
-/**
- * Get sensor scale
- * @param dev sensor context pointer
- * @return Sensor scale
- */
-float vdiv_get_scale(const vdiv_context dev);
-
-/**
- * Get sensor offset
- * @param dev sensor context pointer
- * @return Sensor offset
- */
-float vdiv_get_offset(const vdiv_context dev);
-
-/**
- * Set sensor divide switch value
- * @param dev sensor context pointer
- * @param vdiv_sw Divide switch value
- * @return Function result code
- */
-upm_result_t vdiv_set_divsw(const vdiv_context dev, int vdiv_sw);
-
-/**
- * Get divide switch value
- * @param dev sensor context pointer
- * @return Sensor divide switch value
- */
-int vdiv_get_divsw(const vdiv_context dev);
-
-/**
- * Read raw voltage from the sensor
- * @param dev sensor context pointer
- * @param *value Raw sensor voltage
- * @return Function result code
- */
-upm_result_t vdiv_get_raw_volts(const vdiv_context dev, float *value);
-
-/**
- * Gets the true voltage value from the sensor.  Voltage divides by 3 or 10,
- * depending on the toggle switch on the board.  The dynamic range of the
- * vdiv sensor is listed below.
- * 
- *  ADC Ref  SW   max VOL in
- *  ------- ---   ----------
- *    3.3v    3       8.5v
- *    3.3v   10      28.4v
- *    5.0v    3      12.9v
- *    5.0v   10      43.0v
- *
- * @param dev sensor context pointer
- * @param *value Voltage (v)
- * @return Function result code
- */
-upm_result_t vdiv_get_computed_volts(const vdiv_context dev, float *value);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/vdiv/vdiv.hpp b/src/vdiv/vdiv.hpp
deleted file mode 100644
index f04b7f3..0000000
--- a/src/vdiv/vdiv.hpp
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <iostream>
-#include <stdint.h>
-#include <mraa/aio.h>
-
-// reference voltage in millivolts
-#define VDIV_VREF  4980
-
-// default ADC resolution
-#define VDIV_ADC_RES 1024
-
-namespace upm {
-  /**
-   * @brief Voltage Divider Sensor
-   * @defgroup vdiv libupm-vdiv
-   * @ingroup seeed analog electric robok
-   */
-
-  /**
-   * @library vdiv
-   * @sensor vdiv
-   * @comname Analog Voltage Divider Sensor
-   * @altname Grove Voltage Divider
-   * @type electric
-   * @man seeed
-   * @con analog
-   * @kit robok
-   *
-   * @brief API for the Voltage Divider Sensor
-   *
-   * UPM module for the Voltage Divider sensor
-   *
-   * @image html vdiv.jpg
-   * @snippet vdiv.cxx Interesting
-   */
-  class VDiv {
-  public:
-    /**
-     * Voltage Divider sensor constructor
-     *
-     * @param pin Analog pin to use
-     */
-    VDiv(int pin);
-
-    /**
-     * Voltage Divider destructor
-     */
-    ~VDiv();
-
-    /**
-     * Gets the conversion value from the sensor
-     *
-     * @param samples Specifies how many samples to average over
-     * @return Average ADC conversion value
-     */
-    unsigned int value(unsigned int samples);
-
-    /**
-     * Computes the measured voltage
-     *
-     * @param gain Gain switch, example: either 3 or 10 grove vdiv
-     * @param val Measured voltage (from value())
-     * @param vref Reference voltage in millivolts
-     * @param res ADC resolution
-     *
-     * @return Measured voltage
-     */
-    float computedValue(uint8_t gain, unsigned int val, int vref=VDIV_VREF,
-                        int res=VDIV_ADC_RES);
-
-  private:
-    mraa_aio_context m_aio;
-  };
-}
diff --git a/src/vdiv/vdiv.json b/src/vdiv/vdiv.json
deleted file mode 100644
index 945e0c5..0000000
--- a/src/vdiv/vdiv.json
+++ /dev/null
@@ -1,70 +0,0 @@
-{
-    "Library": "vdiv",
-    "Description": "Grove Voltage Divider Sensor Library",
-    "Sensor Class": {
-        "vdiv": {
-            "Name": "API for the Grove Voltage Divider Sensor",
-            "Description": "This is the UPM Module for the Grove Voltage Divider Sensor. The Grove – Voltage Divider provides an interface for measuring extern voltage, eliminating the need to connect a resistance to input interface. Besides, The voltage gain can select by dial switch.They are easy to use.",
-            "Aliases": ["vdiv", "Grove - Voltage Divider", "LMV3xx"],
-            "Categories": ["electric"],
-            "Connections": ["analog"],
-            "Project Type": ["prototyping"],
-            "Manufacturers": ["Seeed", "Texas Instruments"],
-            "Kits": ["robok"],
-            "Image": "vdiv.jpg",
-            "Examples": {
-                "Java": ["VDiv_Example.java"],
-                "Python": ["vdiv.py"],
-                "Node.js": ["vdiv.js"],
-                "C++": ["vdiv.cxx"],
-                "C": ["vdiv.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 4.7,
-                    "max": 5.3
-                },
-                "Supply Current": {
-                    "unit": "uA",
-                    "min" : 130,
-                    "max" : 410
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -40,
-                    "max": 125
-                },
-                "Accuracy": {
-                    "unit": "%",
-                    "typ": "<=1"
-                },
-                "External Voltage Range": {
-                    "Gain 3": {
-                        "unit": "V",
-                        "min" : 0.3,
-                        "max" : 12.9
-                    },
-                    "Gain 10": {
-                        "unit": "V",
-                        "min" : 1,
-                        "max" : 43
-                    }
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-Voltage-Divider-p-1472.html", "http://wiki.seeed.cc/Grove-Voltage_Divider/"],
-                "Datasheets": ["https://github.com/SeeedDocument/Grove-Voltage_Divider/raw/master/res/LMV358ID_Datasheet.pdf"],
-                "Schematics": ["https://github.com/SeeedDocument/Grove-Voltage_Divider/raw/master/res/Grove-Voltage_Divider_Eagle_File.zip"]
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/vdiv/vdiv_fti.c b/src/vdiv/vdiv_fti.c
deleted file mode 100644
index 1138461..0000000
--- a/src/vdiv/vdiv_fti.c
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Author: Noel Eck <noel.eck@intel.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string.h>
-#include <stdlib.h>
-
-#include "vdiv.h"
-#include "fti/upm_sensor.h"
-#include "fti/upm_voltage.h"
-
-/** 
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_vdiv_name[] = "VDIV";
-const char upm_vdiv_description[] = "Analog voltage divider sensor";
-const upm_protocol_t upm_vdiv_protocol[] = {UPM_ANALOG};
-const upm_sensor_t upm_vdiv_category[] = {UPM_VOLTAGE};
-
-// forward declarations
-const void* upm_vdiv_get_ft(upm_sensor_t sensor_type);
-void* upm_vdiv_init_str(const char* protocol, const char* params);
-void upm_vdiv_close(void* dev);
-const upm_sensor_descriptor_t upm_vdiv_get_descriptor();
-upm_result_t upm_vdiv_set_offset(const void* dev, float offset);
-upm_result_t upm_vdiv_set_scale(const void* dev, float scale);
-upm_result_t upm_vdiv_get_value(const void* dev, float *value);
-
-/* This sensor implementes 2 function tables */
-/* 1. Generic base function table */
-static const upm_sensor_ft ft_gen =
-{
-    .upm_sensor_init_name = &upm_vdiv_init_str,
-    .upm_sensor_close = &upm_vdiv_close,
-    .upm_sensor_get_descriptor = &upm_vdiv_get_descriptor
-};
-
-/* 2. VOLTAGE function table */
-static const upm_voltage_ft ft_voltage =
-{
-    .upm_voltage_set_offset = &upm_vdiv_set_offset,
-    .upm_voltage_set_scale = &upm_vdiv_set_scale,
-    .upm_voltage_get_value = &upm_vdiv_get_value
-};
-
-const void* upm_vdiv_get_ft(upm_sensor_t sensor_type)
-{
-    switch(sensor_type)
-    {
-        case UPM_SENSOR:
-            return &ft_gen;
-        case UPM_VOLTAGE:
-            return &ft_voltage;
-        default:
-            return NULL;
-    }
-}
-
-void* upm_vdiv_init_str(const char* protocol, const char* params)
-{
-    fprintf(stderr, "String initialization - not implemented, using ain0: %s\n", __FILENAME__);
-    return vdiv_init(0, 5.0);
-}
-
-void upm_vdiv_close(void* dev)
-{
-    vdiv_close((vdiv_context)dev);
-}
-
-const upm_sensor_descriptor_t upm_vdiv_get_descriptor()
-{
-    /* Fill in the descriptor */
-    upm_sensor_descriptor_t usd;
-    usd.name = upm_vdiv_name;
-    usd.description = upm_vdiv_description;
-    usd.protocol_size = 1;
-    usd.protocol = upm_vdiv_protocol;
-    usd.category_size = 1;
-    usd.category = upm_vdiv_category;
-
-    return usd;
-}
-
-upm_result_t upm_vdiv_set_offset(const void* dev, float offset)
-{
-    return vdiv_set_offset((vdiv_context)dev, offset);
-}
-
-upm_result_t upm_vdiv_set_scale(const void* dev, float scale)
-{
-    return vdiv_set_scale((vdiv_context)dev, scale);
-}
-
-upm_result_t upm_vdiv_get_value(const void* dev, float *value)
-{
-    return vdiv_get_computed_volts((vdiv_context)dev, value);
-}
diff --git a/src/veml6070/CMakeLists.txt b/src/veml6070/CMakeLists.txt
deleted file mode 100644
index 9ed32a9..0000000
--- a/src/veml6070/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-upm_mixed_module_init (NAME veml6070
-    DESCRIPTION "Vishay UV Sensor"
-    C_HDR veml6070.h
-    C_SRC veml6070.c
-    CPP_HDR veml6070.hpp
-    CPP_SRC veml6070.cxx
-    CPP_WRAPS_C
-    REQUIRES mraa)
diff --git a/src/veml6070/veml6070.c b/src/veml6070/veml6070.c
deleted file mode 100644
index 6687814..0000000
--- a/src/veml6070/veml6070.c
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Author: Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#include "veml6070.h"
-
-veml6070_context veml6070_init(int bus) {
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        return NULL;
-    }
-
-    veml6070_context dev =
-      (veml6070_context) malloc(sizeof(struct _veml6070_context));
-
-    if (!dev)
-    {
-        return NULL;
-    }
-
-    dev->i2c_bus_number = bus;
-    // Setting up 2 contexts for the 2 addresses
-    dev->address_seq1 = VEML6070_SEQ1_DATA_BUF_REG;
-    dev->address_seq2 = VEML6070_SEQ2_DATA_BUF_REG;
-
-    dev->i2c_seq1 = mraa_i2c_init(dev->i2c_bus_number);
-    if (dev->i2c_seq1 == NULL){
-        free(dev);
-        return NULL;
-    }
-
-    dev->i2c_seq2 = mraa_i2c_init(dev->i2c_bus_number);
-    if (dev->i2c_seq2 == NULL){
-        free(dev);
-        return NULL;
-    }
-
-    if (mraa_i2c_address(dev->i2c_seq1, dev->address_seq1) != MRAA_SUCCESS)
-    {
-        mraa_i2c_stop(dev->i2c_seq1);
-        free(dev);
-        return NULL;
-    }
-
-    if (mraa_i2c_address(dev->i2c_seq2, dev->address_seq2) != MRAA_SUCCESS)
-    {
-        mraa_i2c_stop(dev->i2c_seq2);
-        free(dev);
-        return NULL;
-    }
-    // reset the sensor here
-
-    return dev;
-}
-
-void veml6070_close(veml6070_context dev) {
-    free(dev);
-}
-
-int16_t veml6070_get_uv_intensity(veml6070_context dev) {
-    int8_t seq_1, seq_2;
-    int16_t intensity;
-
-    // reading seq1
-    seq_1 = mraa_i2c_read_byte(dev->i2c_seq1);
-    if(seq_1 == -1)
-        return -1;
-
-    // reading seq2
-    seq_2 = mraa_i2c_read_byte(dev->i2c_seq2);
-    if (seq_2 == -1)
-        return -1;
-
-    intensity = (seq_1<<8)|seq_2;
-
-    return intensity;
-}
-
-upm_result_t veml6070_set_integration_time(veml6070_context dev, veml6070_integration_time_t time) {
-    uint8_t integrationTime = ((time<<2)|0x02);
-    if(mraa_i2c_write(dev->i2c_seq2, &integrationTime, 1) != MRAA_SUCCESS) {
-        return UPM_ERROR_UNSPECIFIED;
-    }
-
-    return UPM_SUCCESS;
-}
diff --git a/src/veml6070/veml6070.cxx b/src/veml6070/veml6070.cxx
deleted file mode 100644
index 3d46d45..0000000
--- a/src/veml6070/veml6070.cxx
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Author: Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "veml6070.hpp"
-
-using namespace upm;
-
-VEML6070::VEML6070(int bus) :
-    m_veml6070(veml6070_init(bus))
-{
-    if(!m_veml6070)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                ": veml6070_init failed");
-}
-
-VEML6070::~VEML6070()
-{
-    veml6070_close(m_veml6070);
-}
-
-int VEML6070::getUVIntensity()
-{
-    return veml6070_get_uv_intensity(m_veml6070);
-}
-
-void VEML6070::setIntegrationTime(veml6070_integration_time_t time)
-{
-    if(veml6070_set_integration_time(m_veml6070, time) != UPM_SUCCESS)
-        std::cout << "VEML6070 sensor unable to update integration time" << std::endl;
-}
diff --git a/src/veml6070/veml6070.h b/src/veml6070/veml6070.h
deleted file mode 100644
index 6cb0816..0000000
--- a/src/veml6070/veml6070.h
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Author: Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <stdlib.h>
-#include <unistd.h>
-#include <stdio.h>
-#include <string.h>
-
-#include "upm.h"
-#include "mraa/i2c.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define VEML6070_CTRL_REG             0x38    // write only
-#define VEML6070_SEQ1_DATA_BUF_REG    0x39    // read only
-#define VEML6070_SEQ2_DATA_BUF_REG    0x38    // read only
-
-typedef enum {
-    HALF_T = 0,
-    ONE_T,
-    TWO_T,
-    FOUR_T } veml6070_integration_time_t;
-
-/**
- * @file veml6070.h
- * @library veml6070
- * @brief C API for the VEML6070 Vishay UV Sensor
- *
- * @include veml6070.c
- */
-
-typedef struct _veml6070_context {
-    mraa_i2c_context       i2c_seq1;
-    mraa_i2c_context       i2c_seq2;
-    uint8_t                address_seq1;
-    uint8_t                address_seq2;
-    int                    i2c_bus_number;
-} *veml6070_context;
-
-/**
- * VEML6070 Initialization function
- *
- * @param bus I2C bus to use
- * @param address I2C address to use
- *
- * @return device context pointer
- */
-veml6070_context veml6070_init(int bus);
-
-/**
- * VEML6070 Close function
- *
- * @param dev veml6070_context pointer
- */
-void veml6070_close(veml6070_context dev);
-
-/**
- * Function to get the UV values
- *
- * @param dev veml6070_context pointer
- * @return int16_t UV value
- */
-int16_t veml6070_get_uv_intensity(veml6070_context dev);
-
-/**
- * Function to set the integration time of the sensor
- *
- * @param dev veml6070_context pointer
- * @param time veml6070_integration_time_t
- *
- * @return upm_result_t
- */
-upm_result_t veml6070_set_integration_time(veml6070_context dev, veml6070_integration_time_t time);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/veml6070/veml6070.hpp b/src/veml6070/veml6070.hpp
deleted file mode 100644
index 0483117..0000000
--- a/src/veml6070/veml6070.hpp
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- * Author: Abhishek Malik <abhishek.malik@intel.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
- 
-#pragma once
-
-#include "veml6070.h"
-
-namespace upm {
-/**
- * @brief VEML6070 UV Sensor
- * @defgroup veml6070 libupm-veml6070
- * @ingroup vishay i2c light
- */
-
-/**
- * @library veml6070
- * @sensor veml6070
- * @comname Vishay VEML6070 UV Sensor
- * @type other
- * @man Vishay
- * @web http://www.vishay.com/docs/84277/veml6070.pdf
- * @con i2c
- * @kit other
- *
- * @brief API for the Vishay VEML6070 UV Sensor
- *
- * VEML6070 is an advanced ultraviolet (UV) light sensor with
- * I2C protocol interface and designed by the CMOS process.
- * It is easily operated via a simple I2C command. The active
- * acknowledge (ACK) feature with threshold windows setting
- * allows the UV sensor to send out a UVI alert message.
- * Under a strong solar UVI condition, the smart ACK signal
- * can be easily implemented by the software programming.
- * VEML6070 incorporates a photodiode, amplifiers, and
- * analog / digital circuits into a single chip. VEML6070's
- * adoption of FiltronTM UV technology provides the best
- * spectral sensitivity to cover UV spectrum sensing. It has an
- * excellent temperature compensation and a robust refresh
- * rate setting that does not use an external RC low pass filter.
- * VEML6070 has linear sensitivity to solar UV light and is
- * easily adjusted by an external resistor. Software shutdown
- * mode is provided, which reduces power consumption to be
- * less than 1 uA. VEML6070's operating voltage ranges from
- * 2.7 V to 5.5 V.
- *
- * @image html veml6070.jpg
- * @snippet veml6070.cxx Interesting
- */
-    class VEML6070 {
-
-    public:
-        /**
-         * VEML6070 constructor
-         *
-         * @param bus i2c bus to be used
-         * @param devAddress i2c address of the sensor
-         */
-        VEML6070(int bus);
-        /**
-         * VEML6070 destructor
-         */
-        ~VEML6070();
-
-        /**
-         * Function to get the UV value.
-         *
-         * @return int16_t UV value
-         */
-        int getUVIntensity();
-
-        /**
-         * Function to allow the user to set the intergration time
-         * for the sensor.
-         * Integration time:
-         * Bit Setting   |  Description  |           RSet
-         *  IT1   IT0    |               | 300 k-ohms | 600 k-ohms
-         *   0     0     |      1/2T     |   62.5 ms  |   125 ms
-         *   0     1     |       1T      |   125 ms   |   250 ms
-         *   1     0     |       2T      |   250 ms   |   500 ms
-         *   1     1     |       4T      |   500 ms   |  1000 ms
-         *
-         * @param time veml6070_integration_time_t
-         */
-        void setIntegrationTime(veml6070_integration_time_t time);
-
-    private:
-        veml6070_context m_veml6070;
-        VEML6070(const VEML6070& src) { /* do not create copied constructor */}
-        VEML6070& operator=(const VEML6070&) {return *this;}
-    };
-}
diff --git a/src/veml6070/veml6070.i b/src/veml6070/veml6070.i
deleted file mode 100644
index a6990fa..0000000
--- a/src/veml6070/veml6070.i
+++ /dev/null
@@ -1,14 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_veml6070)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "veml6070.hpp"
-%}
-%include "veml6070.hpp"
-/* END Common SWIG syntax */
diff --git a/src/veml6070/veml6070.json b/src/veml6070/veml6070.json
deleted file mode 100644
index 24fc770..0000000
--- a/src/veml6070/veml6070.json
+++ /dev/null
@@ -1,55 +0,0 @@
-{
-    "Library": "veml6070",
-    "Description": "Vishay VEML6070 UV Sensor Library",
-    "Sensor Class": {
-        "VEML6070": {
-            "Name": "API for the Vishay VEML6070 UV Sensor",
-            "Description": "This is the UPM Module for the Vishay VEML6070 UV Sensor. VEML6070 is an advanced ultraviolet (UV) light sensor with I2C protocol interface and designed by the CMOS process. It is easily operated via a simple I2C command. The active acknowledge (ACK) feature with threshold windows setting allows the UV sensor to send out a UVI alert message. Under a strong solar UVI condition, the smart ACK signal can be easily implemented by the software programming. VEML6070 incorporates a photodiode, amplifiers, and analog / digital circuits into a single chip. VEML6070's adoption of FiltronTM UV technology provides the best spectral sensitivity to cover UV spectrum sensing. It has an excellent temperature compensation and a robust refresh rate setting that does not use an external RC low pass filter. VEML6070 has linear sensitivity to solar UV light and is easily adjusted by an external resistor.",
-            "Aliases": ["veml6070"],
-            "Categories": ["light"],
-            "Connections": ["i2c"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["Vishay", "Adafruit"],
-            "Examples": {
-                "Java": ["VEML6070_Example.java"],
-                "Python": ["veml6070.py"],
-                "Node.js": ["veml6070.js"],
-                "C++": ["veml6070.cxx"],
-                "C": ["veml6070.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 2.7,
-                    "max": 5.5
-                },
-                "Supply Current": {
-                    "unit": "uA",
-                    "min" : 100,
-                    "max" : 250
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Maximum UVA Sensativity": {
-                    "unit": "mW/cm2",
-                    "typ" : 328
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": []
-                },
-                "Intel Edison": {
-                    "Notes": []
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.adafruit.com/product/2899", "https://learn.adafruit.com/adafruit-veml6070-uv-light-sensor-breakout/overview?gclid=Cj0KCQjwn6DMBRC0ARIsAHZtCeOQb5G3DDYxFmW9TmWxzijBIP1Gm_gNAo4PZ00Kwz3CGimYd1dBdu4aAo6IEALw_wcB"],
-                "Datasheets": ["https://www.vishay.com/docs/84277/veml6070.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/water/CMakeLists.txt b/src/water/CMakeLists.txt
deleted file mode 100644
index dd661dc..0000000
--- a/src/water/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME water
-    DESCRIPTION "Water Detection Sensor"
-    C_HDR water.h
-    C_SRC water.c
-    CPP_HDR water.hpp
-    CPP_SRC water.cxx
-    FTI_SRC water_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa)
diff --git a/src/water/water.c b/src/water/water.c
deleted file mode 100644
index b16d8cf..0000000
--- a/src/water/water.c
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014-2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <assert.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include "water.h"
-
-water_context water_init(unsigned int pin)
-{
-  water_context dev =
-    (water_context)malloc(sizeof(struct _water_context));
-
-  if (!dev)
-    return NULL;
-
-  dev->gpio = NULL;
-
-  // make sure MRAA is initialized
-  int mraa_rv;
-  if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-  {
-      printf("mraa_init() failed (%d).\n", mraa_rv);
-      water_close(dev);
-      return NULL;
-  }
-
-  // initialize the MRAA context
-
-  if (!(dev->gpio = mraa_gpio_init(pin)))
-    {
-      printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
-      water_close(dev);
-      return NULL;
-    }
-
-  mraa_gpio_dir(dev->gpio, MRAA_GPIO_IN);
-
-  return dev;
-}
-
-void water_close(const water_context dev)
-{
-  assert(dev != NULL);
-
-  if (dev->gpio)
-    mraa_gpio_close(dev->gpio);
-
-  free(dev);
-}
-
-bool water_is_wet(const water_context dev)
-{
-  assert(dev != NULL);
-
-  // gpio is low when wet
-  return (mraa_gpio_read(dev->gpio) ? false : true);
-}
diff --git a/src/water/water.cxx b/src/water/water.cxx
deleted file mode 100644
index cf7d8e9..0000000
--- a/src/water/water.cxx
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "water.hpp"
-
-using namespace upm;
-using namespace std;
-
-Water::Water(unsigned int pin) :
-  m_water(water_init(pin))
-{
-  if (!m_water )
-    throw std::runtime_error(std::string(__FUNCTION__) +
-                             ": water_init() failed");
-}
-
-Water::~Water()
-{
-  water_close(m_water);
-}
-
-bool Water::isWet()
-{
-  return water_is_wet(m_water);
-}
diff --git a/src/water/water.h b/src/water/water.h
deleted file mode 100644
index 7f9a40a..0000000
--- a/src/water/water.h
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014-2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include "upm.h"
-#include "mraa/gpio.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-  /**
-   * @file water.h
-   * @library water
-   * @brief C API for the Water Sensor
-   *
-   * @include water.c
-   */
-
-  /**
-   * Device context
-   */
-  typedef struct _water_context {
-    mraa_gpio_context        gpio;
-  } *water_context;
-
-  /**
-   * Water initializer
-   *
-   * @param pin Digital pin to use
-   * @return an initialized device context on success, NULL on error.
-   */
-  water_context water_init(unsigned int pin);
-
-  /**
-   * Water close function
-   */
-  void water_close(water_context dev);
-
-  /**
-   * Gets the water (wet/not wet) value from the sensor.
-   *
-   * @return true if the sensor is wet, false otherwise
-   */
-  bool water_is_wet(const water_context dev);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/water/water.hpp b/src/water/water.hpp
deleted file mode 100644
index 86849fe..0000000
--- a/src/water/water.hpp
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014-2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include "water.h"
-
-namespace upm {
-  /**
-   * @brief Water Sensor
-   * @defgroup water libupm-water
-   * @ingroup seeed gpio liquid eak
-   */
-
-  /**
-   * @library water
-   * @sensor water
-   * @comname Water Detection Sensor
-   * @type liquid
-   * @man seeed
-   * @con gpio
-   * @kit eak
-   *
-   * @brief API for the Water Sensor
-   *
-   * UPM module for the Water sensor
-   *
-   * @image html water.jpg
-   * @snippet water.cxx Interesting
-   */
-  class Water {
-  public:
-    /**
-     * digital water sensor constructor
-     *
-     * @param pin Digital pin to use
-     */
-    Water(unsigned int pin);
-    /**
-     * Water destructor
-     */
-    ~Water();
-    /**
-     * Gets the water (wet/not wet) value from the sensor
-     *
-     * @return True if the sensor is wet, false otherwise
-     */
-    bool isWet();
-
-  private:
-    /* Disable implicit copy and assignment operators */
-    Water(const Water&) = delete;
-    Water &operator=(const Water&) = delete;
-
-    water_context m_water;
-  };
-}
diff --git a/src/water/water.json b/src/water/water.json
deleted file mode 100644
index 2827ce4..0000000
--- a/src/water/water.json
+++ /dev/null
@@ -1,57 +0,0 @@
-{
-    "Library": "water",
-    "Description": "Grove Water Sensor Library",
-    "Sensor Class": {
-        "Water": {
-            "Name": "API for the Grove Water Sensor",
-            "Description": "This is the UPM Module for the Grove Water Sensor. This sensor detects the presence of water using exposed PCB traces. The sensor is made up of interlaced traces of Ground and Sensor signals. The sensor traces are weakly pulled up using 1 MΩ resistor. The resistor will pull the sensor trace value high until a drop of water shorts the sensor trace to the ground trace. This circuit will work with digital I/O pins of Arduino or you can use it with the analog pins to detect the amount of water induced contact between the grounded and sensor traces.",
-            "Aliases": ["water", "Grove - Water Sensor"],
-            "Categories": ["liquid"],
-            "Connections": ["gpio"],
-            "Project Type": ["prototyping"],
-            "Manufacturers": ["Seeed"],
-            "Kits": ["eak"],
-            "Image": "water.jpg",
-            "Examples": {
-                "Java": ["Water_Example.java"],
-                "Python": ["water.py"],
-                "Node.js": ["water.js"],
-                "C++": ["water.cxx"],
-                "C": ["water.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 4.75,
-                    "max": 5.25
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "typ" : "<20"
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": 10,
-                    "max": 30
-                },
-                "Operating Humidity": {
-                    "unit": "%RH",
-                    "min" : 10,
-                    "max" : 90
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-Water-Sensor-p-748.html?gclid=Cj0KCQjwn6DMBRC0ARIsAHZtCeM6_FaKXMn5-4xpQYuyJgydq_exuH2PqkKAKnKsTha_iJzXneoWL7EaAohrEALw_wcB", "http://wiki.seeed.cc/Grove-Water_Sensor/"],
-                "Schematics": ["https://raw.githubusercontent.com/SeeedDocument/Grove-Water_Sensor/master/res/Water_sensor.zip"]
-            }
-        }
-    }
-}
diff --git a/src/water/water_fti.c b/src/water/water_fti.c
deleted file mode 100644
index 8eb26f9..0000000
--- a/src/water/water_fti.c
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "water.h"
-#include "upm_fti.h"
-
-/**
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_water_name[] = "water";
-const char upm_water_description[] = "Water presence sensor";
-const upm_protocol_t upm_water_protocol[] = {UPM_GPIO};
-const upm_sensor_t upm_water_category[] = {UPM_BINARY};
-
-// forward declarations
-const void* upm_water_get_ft(upm_sensor_t sensor_type);
-void* upm_water_init_name();
-void upm_water_close(void *dev);
-upm_result_t upm_water_is_wet(void *dev, bool *value);
-
-static const upm_sensor_ft ft =
-{
-  .upm_sensor_init_name = upm_water_init_name,
-  .upm_sensor_close = upm_water_close,
-};
-
-static const upm_binary_ft bft =
-{
-  .upm_binary_get_value = upm_water_is_wet,
-};
-
-const void* upm_water_get_ft(upm_sensor_t sensor_type)
-{
-  switch(sensor_type)
-    {
-    case UPM_SENSOR:
-      return &ft;
-    case UPM_BINARY:
-      return &bft;
-    default:
-      return NULL;
-    }
-}
-
-void *upm_water_init_name()
-{
-  return NULL;
-}
-
-void upm_water_close(void *dev)
-{
-  water_close((water_context)dev);
-}
-
-upm_result_t upm_water_is_wet(void *dev, bool *value)
-{
-  *value = water_is_wet((water_context)dev);
-
-  return UPM_SUCCESS;
-}
diff --git a/src/waterlevel/CMakeLists.txt b/src/waterlevel/CMakeLists.txt
deleted file mode 100644
index 06f63bd..0000000
--- a/src/waterlevel/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "waterlevel")
-set (libdescription "Water Level Sensor")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/waterlevel/waterlevel.cxx b/src/waterlevel/waterlevel.cxx
deleted file mode 100644
index 02db04f..0000000
--- a/src/waterlevel/waterlevel.cxx
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Author: Zion Orent <sorent@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <string>
-#include <stdexcept>
-#include "waterlevel.hpp"
-
-using namespace upm;
-
-WaterLevel::WaterLevel(int pin)
-{
-    if ( !(m_gpio = mraa_gpio_init(pin)) ) 
-      {
-        throw std::invalid_argument(std::string(__FUNCTION__) +
-                                    ": mraa_gpio_init() failed, invalid pin?");
-        return;
-      }
-    mraa_gpio_dir(m_gpio, MRAA_GPIO_IN);
-}
-
-WaterLevel::~WaterLevel()
-{
-    mraa_gpio_close(m_gpio);
-}
-
-bool WaterLevel::isSubmerged()
-{
-	// Submerged causes 0; being above water is 1
-	return (!(bool)mraa_gpio_read(m_gpio));
-}
diff --git a/src/waterlevel/waterlevel.hpp b/src/waterlevel/waterlevel.hpp
deleted file mode 100644
index 077398c..0000000
--- a/src/waterlevel/waterlevel.hpp
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Author: Zion Orent <sorent@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <mraa/gpio.h>
-
-namespace upm {
-  /**
-   * @brief Water Level Switch
-   * @defgroup waterlevel libupm-waterlevel
-   * @ingroup seeed gpio liquid
-   */
-  /**
-   * @library waterlevel
-   * @sensor waterlevel
-   * @comname Water Level Sensor
-   * @type liquid
-   * @man seeed
-   * @con gpio
-   * 
-   * @brief UPM module for the Grove Water Level Switch
-   *
-   * This switch is a device used to sense the level of liquid within a tank,
-   * it may actuate a pump, an indicator, an alarm, or other devices.
-   *
-   * @image html waterlevel.jpg 
-   * @snippet waterlevel.cxx Interesting
-   */
-  class WaterLevel {
-  public:
-    /**
-     * WaterLevel constructor
-     *
-     * @param pin Digital pin to use
-     */
-    WaterLevel(int pin);
-    /**
-     * WaterLevel destructor
-     */
-    ~WaterLevel();
-    /**
-     * @return bool Determines whether liquid has risen above the sensor
-     */
-     bool isSubmerged();
-
-  private:
-        mraa_gpio_context m_gpio;
-	};
-}
diff --git a/src/waterlevel/waterlevel.json b/src/waterlevel/waterlevel.json
deleted file mode 100644
index 6c84d33..0000000
--- a/src/waterlevel/waterlevel.json
+++ /dev/null
@@ -1,41 +0,0 @@
-{
-    "Library": "waterlevel",
-    "Description": "Grove Water Level Switch Library",
-    "Sensor Class": {
-        "waterlevel": {
-            "Name": "API for the Grove Water Level Switch",
-            "Description": "This is the UPM Module for the Grove Water Level Switch. This switch is a device used to sense the level of liquid within a tank, it may actuate a pump, an indicator, an alarm, or other devices. When the float ball rises or falls with the liquid to the level of the switch, The magnetic force of magnet which inside of the float ball will cause the reed switch to turn ON. When the float ball move away from the reed switch, the reed switch will turn OFF.",
-            "Aliases": ["waterlevel", "Water level switch"],
-            "Categories": ["liquid"],
-            "Connections": ["gpio"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["Seeed"],
-            "Image": "waterlevel.jpg",
-            "Examples": {
-                "Java": ["WaterLevelSensor_Example.java"],
-                "Python": ["waterlevel.py"],
-                "Node.js": ["waterlevel.js"],
-                "C++": ["waterlevel.cxx"]
-            },
-            "Specifications": {
-                "Switching Voltage": {
-                    "unit": "V",
-                    "min" : 3.3,
-                    "max" : 100
-                },
-                "Switching Current": {
-                    "unit": "A",
-                    "max": 0.5
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -10,
-                    "max": 80
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Water-level-switch-p-565.html"]
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/wfs/CMakeLists.txt b/src/wfs/CMakeLists.txt
deleted file mode 100644
index 897e004..0000000
--- a/src/wfs/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-upm_mixed_module_init (NAME wfs
-    C_HDR wfs.h
-    C_SRC wfs.c
-    DESCRIPTION "WFS (Water Flow Sensor)"
-    CPP_HDR wfs.hpp
-    CPP_SRC wfs.cxx
-    CPP_WRAPS_C
-    REQUIRES mraa utilities-c)
diff --git a/src/wfs/wfs.c b/src/wfs/wfs.c
deleted file mode 100644
index fe51865..0000000
--- a/src/wfs/wfs.c
+++ /dev/null
@@ -1,152 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <stdio.h>
-#include <string.h>
-#include <assert.h>
-
-#include "wfs.h"
-
-// interrupt handler
-static void wfs_flow_isr(void *ctx)
-{
-    assert(ctx != NULL);
-
-    wfs_context dev = (wfs_context)ctx;
-
-    dev->flowCounter++;
-}
-
-wfs_context wfs_init(int pin)
-{
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        return NULL;
-    }
-
-    wfs_context dev =
-        (wfs_context)malloc(sizeof(struct _wfs_context));
-
-    if (!dev)
-        return NULL;
-
-    // zero out context
-    memset((void *)dev, 0, sizeof(struct _wfs_context));
-
-    if ( !(dev->gpio = mraa_gpio_init(pin)) )
-    {
-        printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
-        wfs_close(dev);
-        return NULL;
-    }
-
-    mraa_gpio_dir(dev->gpio, MRAA_GPIO_IN);
-
-    wfs_init_clock(dev);
-
-    return dev;
-}
-
-void wfs_close(wfs_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->isrInstalled)
-        wfs_stop_flow_counter(dev);
-
-    if (dev->gpio)
-        mraa_gpio_close(dev->gpio);
-
-    free(dev);
-}
-
-void wfs_init_clock(const wfs_context dev)
-{
-    assert(dev != NULL);
-
-    dev->clock = upm_clock_init();
-}
-
-uint32_t wfs_get_millis(const wfs_context dev)
-{
-    assert(dev != NULL);
-
-    return upm_elapsed_ms(&dev->clock);
-}
-
-void wfs_clear_flow_counter(const wfs_context dev)
-{
-    assert(dev != NULL);
-
-    dev->flowCounter = 0;
-}
-
-upm_result_t wfs_start_flow_counter(const wfs_context dev)
-{
-    assert(dev != NULL);
-
-    wfs_init_clock(dev);
-
-    // install our interrupt handler
-    if (mraa_gpio_isr(dev->gpio, MRAA_GPIO_EDGE_RISING,
-                      &wfs_flow_isr, dev))
-    {
-        printf("%s: mraa_gpio_isr() failed.\n", __FUNCTION__);
-        return UPM_ERROR_OPERATION_FAILED;
-    }
-
-    dev->isrInstalled = true;
-    return UPM_SUCCESS;
-}
-
-void wfs_stop_flow_counter(const wfs_context dev)
-{
-    assert(dev != NULL);
-
-    // remove the interrupt handler
-    mraa_gpio_isr_exit(dev->gpio);
-
-    dev->isrInstalled = false;
-}
-
-uint32_t wfs_flow_counter(const wfs_context dev)
-{
-    assert(dev != NULL);
-
-    return dev->flowCounter;
-}
-
-float wfs_flow_rate(const wfs_context dev)
-{
-    assert(dev != NULL);
-
-    uint32_t millis = wfs_get_millis(dev);
-    uint32_t flow = wfs_flow_counter(dev);
-
-    // 7.5 comes from the seeedstudio page, see the confusing datasheet :)
-    return ((float)flow * 7.5) / ( ((float)millis / 1000.0) * 60.0);
-}
diff --git a/src/wfs/wfs.cxx b/src/wfs/wfs.cxx
deleted file mode 100644
index ba59980..0000000
--- a/src/wfs/wfs.cxx
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015-2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "wfs.hpp"
-
-using namespace upm;
-using namespace std;
-
-WFS::WFS(int pin) :
-    m_wfs(wfs_init(pin))
-{
-    if (!m_wfs)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": wfs_init() failed");
-}
-
-WFS::~WFS()
-{
-    wfs_close(m_wfs);
-}
-
-void WFS::initClock()
-{
-    wfs_init_clock(m_wfs);
-}
-
-uint32_t WFS::getMillis()
-{
-    return wfs_get_millis(m_wfs);
-}
-
-void WFS::startFlowCounter()
-{
-    if (wfs_start_flow_counter(m_wfs))
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": wfs_start_flow_counter() failed");
-}
-
-void WFS::stopFlowCounter()
-{
-    wfs_stop_flow_counter(m_wfs);
-}
-
-float WFS::flowRate()
-{
-    return wfs_flow_rate(m_wfs);
-}
diff --git a/src/wfs/wfs.h b/src/wfs/wfs.h
deleted file mode 100644
index f1820e6..0000000
--- a/src/wfs/wfs.h
+++ /dev/null
@@ -1,134 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-
-#include <stdint.h>
-#include <stdlib.h>
-#include <unistd.h>
-
-#include <upm.h>
-#include <upm_utilities.h>
-#include <mraa/gpio.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    /**
-     * @file wfs.h
-     * @library wfs
-     * @brief WFS (Water Flow Sensor)
-     *
-     */
-
-    /**
-     * Device context
-     */
-    typedef struct _wfs_context {
-        mraa_gpio_context gpio;
-
-        volatile uint32_t flowCounter;
-        upm_clock_t       clock;
-        bool              isrInstalled;
-    } *wfs_context;
-
-    /**
-     * Initialize a WFS device
-     *
-     * @param pin GPIO pin to use.  This must be an interrupt capable
-     * pin.
-     * @return Device context, or NULL on error
-     */
-    wfs_context wfs_init(int pin);
-
-    /**
-     * WFS close function
-     *
-     * @param dev Device context
-     */
-    void wfs_close(wfs_context dev);
-
-    /**
-     * Returns the number of milliseconds elapsed since wfs_init_clock()
-     * was last called.
-     *
-     * @param dev Device context
-     * @return Elapsed milliseconds
-     */
-    uint32_t wfs_get_millis(const wfs_context dev);
-
-    /**
-     * Resets the clock
-     *
-     * @param dev Device context
-     */
-    void wfs_init_clock(const wfs_context dev);
-
-    /**
-     * Resets the flow counter to 0. The flow counter should be
-     * stopped via stopFlowCounter() prior to calling this function.
-     *
-     * @param dev Device context
-     */
-    void wfs_clear_flow_counter(const wfs_context dev);
-
-    /**
-     * Starts the flow counter
-     *
-     * @param dev Device context
-     * @return UPM result
-     */
-    upm_result_t wfs_start_flow_counter(const wfs_context dev);
-
-    /**
-     * Stops the flow counter
-     *
-     * @param dev Device context
-     */
-    void wfs_stop_flow_counter(const wfs_context dev);
-
-    /**
-     * Gets the flow counter
-     *
-     * @param dev Device context
-     * @return Flow counter
-     */
-    uint32_t wfs_flow_counter(const wfs_context dev);
-
-    /**
-     * Computes the flow rate in liters per minute (LPM).  Note, this
-     * is for the Grove WFS.  If you are using some other WFS, you
-     * should compute the flow rate on your own based on the data for
-     * your sensor.
-     *
-     * @param dev Device context
-     * @return Computed flow rate in liters per minute
-     */
-    float wfs_flow_rate(const wfs_context dev);
-
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/wfs/wfs.hpp b/src/wfs/wfs.hpp
deleted file mode 100644
index a95dcf6..0000000
--- a/src/wfs/wfs.hpp
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015-2017 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include "wfs.h"
-
-namespace upm {
-
-/**
- * @brief Water Flow Sensor
- * @defgroup wfs libupm-wfs
- * @ingroup seeed gpio liquid eak
- */
-
-/**
- * @library wfs
- * @sensor wfs
- * @comname Water Flow Sensor
- * @altname Grove Water Flow Sensor
- * @type liquid
- * @man seeed
- * @web http://wiki.seeedstudio.com/wiki/G1/2_Water_Flow_sensor
- * @con gpio
- * @kit eak
-
- * @brief API for the Water Flow Sensor
- *
- * This sensor is used to measure water flow in liters per
- * minute (LPM). It incorporates a Hall Effect sensor. The UPM module
- * defines an interrupt routine to be triggered on each low pulse,
- * keeping count. This device requires a 10K pull-up resistor for
- * the signal line (yellow wire). There is a schematic diagram on
- * the SeeedStudio site (3/2015):
- * http://www.seeedstudio.com/wiki/index.php?title=G1/2_Water_Flow_sensor
- *
- * However, be careful when wiring this up - the schematic appears to
- * have a bug in it: the lower left connection of the signal line
- * (yellow) to Vcc (red) should not be there. The sensor can work
- * with this connection, but probably not for very long.
- *
- * @image html wfs.jpg
- * @snippet wfs.cxx Interesting
- */
-class WFS {
-    public:
-        /**
-         * Water Flow Sensor constructor
-         *
-         * @param pin Digital pin to use
-         */
-        WFS(int pin);
-        /**
-         * WFS destructor
-         */
-        ~WFS();
-
-        /**
-         * Returns the number of milliseconds elapsed since initClock()
-         * was last called.
-         *
-         * @return Elapsed milliseconds
-         */
-        uint32_t getMillis();
-
-        /**
-         * Resets the clock
-         *
-         */
-        void initClock();
-
-        /**
-         * Resets the flow counter to 0. The flow counter should be
-         * stopped via stopFlowCounter() prior to calling this function.
-         *
-         */
-        void clearFlowCounter() { wfs_clear_flow_counter(m_wfs); };
-
-        /**
-         * Starts the flow counter
-         *
-         */
-        void startFlowCounter();
-
-        /**
-         * Stops the flow counter
-         *
-         */
-        void stopFlowCounter();
-
-        /**
-         * Gets the flow counter
-         *
-         * @return Flow counter
-         */
-        uint32_t flowCounter() { return wfs_flow_counter(m_wfs); };
-
-        /**
-         * Computes the flow rate in liters per minute (LPM).  Note, this
-         * is for the Grove WFS.  If you are using some other WFS, you
-         * should compute the flow rate on your own based on the data for
-         * your sensor.
-         *
-         * @return Computed flow rate
-         */
-        float flowRate();
-
-    protected:
-        wfs_context m_wfs;
-
-    private:
-        /* Disable implicit copy and assignment operators */
-        WFS(const WFS&) = delete;
-        WFS &operator=(const WFS&) = delete;
-};
-}
diff --git a/src/wfs/wfs.i b/src/wfs/wfs.i
deleted file mode 100644
index c9634cd..0000000
--- a/src/wfs/wfs.i
+++ /dev/null
@@ -1,16 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%ignore flowISR;
-
-JAVA_JNI_LOADLIBRARY(javaupm_wfs)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%{
-#include "wfs.hpp"
-%}
-%include "wfs.hpp"
-/* END Common SWIG syntax */
diff --git a/src/wfs/wfs.json b/src/wfs/wfs.json
deleted file mode 100644
index 8100696..0000000
--- a/src/wfs/wfs.json
+++ /dev/null
@@ -1,75 +0,0 @@
-{
-    "Library": "wfs",
-    "Description": "Grove Water Flow Sensor Library",
-    "Sensor Class": {
-        "WFS": {
-            "Name": "API for the Grove Water Flow Sensor",
-            "Description": "This is the UPM Module for the Grove Water Flow Sensor. This sensor is used to measure water flow in liters per minute (LPM). It incorporates a Hall Effect sensor. The UPM module defines an interrupt routine to be triggered on each low pulse, keeping count. This device requires a 10K pull-up resistor for the signal line (yellow wire). However, be careful when wiring this up - the schematic appears to have a bug in it: the lower left connection of the signal line (yellow) to Vcc (red) should not be there. The sensor can work with this connection, but probably not for very long.",
-            "Aliases": ["wfs", "G1/2 Water Flow sensor"],
-            "Categories": ["liquid"],
-            "Connections": ["gpio"],
-            "Project Type": ["mprototyping", "commercial"],
-            "Manufacturers": ["Seeed"],
-            "Kits": ["eak"],
-            "Image": "wfs.jpg",
-            "Examples": {
-                "Java": ["WFS_Example.java"],
-                "Python": ["wfs.py"],
-                "Node.js": ["wfs.js"],
-                "C++": ["wfs.cxx"],
-                "C": ["wfs.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 5,
-                    "max": 24
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "max" : 15
-                },
-                "Operating Temperature": {
-                    "Air": {
-                        "unit": "°C",
-                        "min": -10,
-                        "max": 80
-                    },
-                    "Liquid": {
-                        "unit": "°C",
-                        "min" : 0,
-                        "max" : 120
-                    }
-                },
-                "Operating Humidity": {
-                    "unit": "%RH",
-                    "min" : 35,
-                    "max" : 90
-                },
-                "Flow Rate": {
-                    "unit": "L/min",
-                    "min" : 1,
-                    "max" : 30
-                },
-                "Water Pressyre": {
-                    "unit": "MPa",
-                    "max" : 2.0
-                }
-            },
-            "Platforms": {
-                "Intel Joule Module": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Intel Edison": {
-                    "Notes": ["Might need pull up resistors"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need pull up resistors"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["http://wiki.seeedstudio.com/wiki/G1/2_Water_Flow_sensor"]
-            }
-        }
-    }
-}
diff --git a/src/wheelencoder/CMakeLists.txt b/src/wheelencoder/CMakeLists.txt
deleted file mode 100644
index ec4f02b..0000000
--- a/src/wheelencoder/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "wheelencoder")
-set (libdescription "Wheel Encoder")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/wheelencoder/wheelencoder.cxx b/src/wheelencoder/wheelencoder.cxx
deleted file mode 100644
index 627ba1a..0000000
--- a/src/wheelencoder/wheelencoder.cxx
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-
-#include "wheelencoder.hpp"
-
-using namespace upm;
-using namespace std;
-
-WheelEncoder::WheelEncoder(int pin) :
-  m_gpio(pin)
-{
-  m_gpio.dir(mraa::DIR_IN);
-
-  initClock();
-  m_counter = 0;
-  m_isrInstalled = false;
-}
-
-WheelEncoder::~WheelEncoder()
-{
-  stopCounter();
-}
-
-void WheelEncoder::initClock()
-{
-  gettimeofday(&m_startTime, NULL);
-}
-
-uint32_t WheelEncoder::getMillis()
-{
-  struct timeval elapsed, now;
-  uint32_t elapse;
-
-  // get current time
-  gettimeofday(&now, NULL);
-
-  // compute the delta since m_startTime
-  if( (elapsed.tv_usec = now.tv_usec - m_startTime.tv_usec) < 0 ) 
-    {
-      elapsed.tv_usec += 1000000;
-      elapsed.tv_sec = now.tv_sec - m_startTime.tv_sec - 1;
-    } 
-  else 
-    {
-      elapsed.tv_sec = now.tv_sec - m_startTime.tv_sec;
-    }
-
-  elapse = (uint32_t)((elapsed.tv_sec * 1000) + (elapsed.tv_usec / 1000));
-
-  // never return 0
-  if (elapse == 0)
-    elapse = 1;
-
-  return elapse;
-}
-
-void WheelEncoder::startCounter()
-{
-  initClock();
-  m_counter = 0;
-
-  // install our interrupt handler
-  if (!m_isrInstalled)
-    m_gpio.isr(mraa::EDGE_RISING, &wheelISR, this);
-
-  m_isrInstalled = true;
-}
-
-void WheelEncoder::stopCounter()
-{
-  // remove the interrupt handler
-  if (m_isrInstalled)
-    m_gpio.isrExit();
-
-  m_isrInstalled = false;
-}
-
-void WheelEncoder::wheelISR(void *ctx)
-{
-  upm::WheelEncoder *This = (upm::WheelEncoder *)ctx;
-  This->m_counter++;
-}
-
diff --git a/src/wheelencoder/wheelencoder.hpp b/src/wheelencoder/wheelencoder.hpp
deleted file mode 100644
index 608e890..0000000
--- a/src/wheelencoder/wheelencoder.hpp
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <stdint.h>
-#include <sys/time.h>
-#include <mraa/gpio.hpp>
-
-namespace upm {
-
-  /**
-   * @brief Wheel Encoder
-   * @defgroup wheelencoder libupm-wheelencoder
-   * @ingroup dfrobot gpio other
-   */
-
-  /**
-   * @library wheelencoder
-   * @sensor wheelencoder
-   * @comname Wheel Encoder
-   * @type other
-   * @man dfrobot
-   * @web http://www.dfrobot.com/index.php?route=product/product&product_id=98
-   * @con gpio
-
-   * @brief API for the DFRobot Wheel Encoder
-   *
-   * This sensor was developed for the DFRobot Wheel Encoder, though
-   * it could be used for any counting time-based task.
-   * 
-   * When you instantiate a class of this type, the gpio pin specified
-   * is connected to an interrupt.  Whenever a low to high transition
-   * occurs on the gpio pin, the internal counter is incremented by
-   * one.
-   *
-   * This class also includes a millisecond counter, so that you can
-   * correlate the number of counts to a time period for calculating
-   * an RPM or other value as needed.
-   *
-   * @image html wheelencoder.jpg
-   * @snippet wheelencoder.cxx Interesting
-   */
-  class WheelEncoder {
-  public:
-
-    /**
-     * DFRobot Wheel Encoder sensor constructor
-     *
-     * @param pin Digital pin to use
-     */
-    WheelEncoder(int pin);
-
-    /**
-     * WheelEncoder destructor
-     */
-    ~WheelEncoder();
-
-    /**
-     * Returns the number of milliseconds elapsed since initClock()
-     * was last called.
-     *
-     * @return Elapsed milliseconds
-     */
-    uint32_t getMillis();
-
-    /**
-     * Resets the clock
-     *
-     */
-    void initClock();
-
-    /**
-     * Resets the counter to 0. The counter should be
-     * stopped via stopCounter() prior to calling this function.
-     *
-     */
-    void clearCounter() { m_counter = 0; };
-
-    /**
-     * Starts the counter.  This function will also clear the current
-     * count and reset the clock.
-     *
-     */
-    void startCounter();
-
-    /**
-     * Stops the counter
-     *
-     */
-    void stopCounter();
-
-    /**
-     * Gets the current counter value
-     *
-     * @return counter value
-     */
-    uint32_t counter() { return m_counter; };
-
-  protected:
-    mraa::Gpio m_gpio;
-    static void wheelISR(void *ctx);
-
-  private:
-    volatile uint32_t m_counter;
-    struct timeval m_startTime;
-    bool m_isrInstalled;
-  };
-}
-
-
diff --git a/src/wheelencoder/wheelencoder.json b/src/wheelencoder/wheelencoder.json
deleted file mode 100644
index 6a887f1..0000000
--- a/src/wheelencoder/wheelencoder.json
+++ /dev/null
@@ -1,53 +0,0 @@
-{
-    "Library": "wheelencoder",
-    "Description": "FRobot Wheel Encoder Library",
-    "Sensor Class": {
-        "WheelEncoder": {
-            "Name": "API for the DFRobot Wheel Encoder",
-            "Description": "This is the UPM Module for the DFRobot Wheel Encoder. This sensor was developed for the DFRobot Wheel Encoder, though it could be used for any counting time-based task.  When you instantiate a class of this type, the gpio pin specified is connected to an interrupt.  Whenever a low to high transition occurs on the gpio pin, the internal counter is incremented by one. This class also includes a millisecond counter, so that you can correlate the number of counts to a time period for calculating an RPM or other value as needed.",
-            "Aliases": ["wheelencoder", "Gravity:TT Motor Encoders Kit"],
-            "Categories": ["other"],
-            "Connections": ["gpio"],
-            "Project Type": ["prototyping", "robotics"],
-            "Manufacturers": ["DFRobot"],
-            "Image": "wheelencoder.jpg",
-            "Examples": {
-                "Python": ["wheelencoder.py"],
-                "Node.js": ["wheelencoder.js"],
-                "C++": ["wheelencoder.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "max": 5.0
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "max" : 20
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Resolution": {
-                    "unit": "PPR",
-                    "resolution": 20
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need the Gravity: IO Expansion Shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need the Gravity: IO Expansion Shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.dfrobot.com/product-98.html"],
-                "Datasheets": ["https://www.dfrobot.com/wiki/index.php/Wheel_Encoders_for_DFRobot_3PA_and_4WD_Rovers_(SKU:SEN0038)"],
-                "Schematics": ["http://www.dfrobot.com/wiki/images/b/b9/FIT0029_Encoder_Schematics.png"]
-            }
-        }
-    }
-}
diff --git a/src/wt5001/CMakeLists.txt b/src/wt5001/CMakeLists.txt
deleted file mode 100644
index f7f74f3..0000000
--- a/src/wt5001/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "wt5001")
-set (libdescription "Serial MP3 Module")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/wt5001/wt5001.cxx b/src/wt5001/wt5001.cxx
deleted file mode 100644
index 4e50a23..0000000
--- a/src/wt5001/wt5001.cxx
+++ /dev/null
@@ -1,632 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <sstream>
-#include <string>
-#include <stdexcept>
-
-#include "wt5001.hpp"
-
-using namespace upm;
-using namespace std;
-
-static const int defaultDelay = 100;     // max wait time for read
-
-WT5001::WT5001(int uart)
-{
-  m_ttyFd = -1;
-
-  if ( !(m_uart = mraa_uart_init(uart)) )
-    {
-      throw std::invalid_argument(std::string(__FUNCTION__) +
-                                  ": mraa_uart_init() failed");
-      return;
-    }
-
-  // This requires a recent MRAA (1/2015)
-  const char *devPath = mraa_uart_get_dev_path(m_uart);
-
-  if (!devPath)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": mraa_uart_get_dev_path() failed");
-      return;
-    }
-
-  // now open the tty
-  if ( (m_ttyFd = open(devPath, O_RDWR)) == -1)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": open of " + 
-                               string(devPath) + " failed: " +
-                               string(strerror(errno)));
-      return;
-    }
-}
-
-WT5001::~WT5001()
-{
-  if (m_ttyFd != -1)
-    close(m_ttyFd);
-
-  mraa_deinit();
-}
-
-bool WT5001::dataAvailable(unsigned int millis)
-{
-  if (m_ttyFd == -1)
-    return false;
-
-  struct timeval timeout;
-
-  // no waiting
-  timeout.tv_sec = 0;
-  timeout.tv_usec = millis * 1000;
-
-  fd_set readfds;
-
-  FD_ZERO(&readfds);
-
-  FD_SET(m_ttyFd, &readfds);
-  
-  if (select(m_ttyFd + 1, &readfds, NULL, NULL, &timeout) > 0)
-    return true;                // data is ready
-  else
-    return false;
-}
-
-int WT5001::readData(char *buffer, int len)
-{
-  if (m_ttyFd == -1)
-    return(-1);
-
-  if (!dataAvailable(defaultDelay))
-    return 0;               // timed out
-
-  int rv = read(m_ttyFd, buffer, len);
-
-  if (rv < 0)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": read() failed: " +
-                               string(strerror(errno)));
-      return rv;
-    }
-
-  return rv;
-}
-
-int WT5001::writeData(char *buffer, int len)
-{
-  if (m_ttyFd == -1)
-    return(-1);
-
-  // first, flush any pending but unread input
-  tcflush(m_ttyFd, TCIFLUSH);
-
-  int rv = write(m_ttyFd, buffer, len);
-
-  if (rv < 0)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": write() failed: " +
-                               string(strerror(errno)));
-      return rv;
-    }
-
-  tcdrain(m_ttyFd);
-
-  return rv;
-}
-
-bool WT5001::setupTty(speed_t baud)
-{
-  if (m_ttyFd == -1)
-    return(false);
-  
-  struct termios termio;
-
-  // get current modes
-  tcgetattr(m_ttyFd, &termio);
-
-  // setup for a 'raw' mode.  81N, no echo or special character
-  // handling, such as flow control.
-  cfmakeraw(&termio);
-
-  // set our baud rates
-  cfsetispeed(&termio, baud);
-  cfsetospeed(&termio, baud);
-
-  // make it so
-  if (tcsetattr(m_ttyFd, TCSAFLUSH, &termio) < 0)
-    {
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": tcsetattr() failed: " +
-                               string(strerror(errno)));
-      return false;
-    }
-
-  return true;
-}
-
-bool WT5001::checkResponse(WT5001_OPCODE_T opcode)
-{
-  char resp;
-  char fopcode = (char)opcode;
-
-  int rv = readData(&resp, 1);
-
-  // check for wrong response byte, or timeout
-  if ((resp != fopcode) || rv == 0 )
-    return false;
-
-  return true;
-}
-
-bool WT5001::play(WT5001_PLAYSOURCE_T psrc, uint16_t index)
-{
-  char pkt[6];
-  WT5001_OPCODE_T opcode = PLAY_SD;
-
-  pkt[0] = WT5001_START;
-  pkt[1] = 0x04;                // length
-
-  switch (psrc)                 // src
-    {
-    case SD:
-      opcode = PLAY_SD;
-      break;
-
-    case SPI:
-      opcode = PLAY_SPI;
-      break;
-
-    case UDISK:
-      opcode = PLAY_UDISK;
-      break;
-    }      
-
-  pkt[2] = opcode;
-  pkt[3] = (index >> 8) & 0xff; // index hi
-  pkt[4] = index & 0xff;        // index lo
-  pkt[5] = WT5001_END;
-
-  writeData(pkt, 6);
-
-  return checkResponse(opcode);
-}
-
-bool WT5001::stop()
-{
-  char pkt[4];
-  WT5001_OPCODE_T opcode = STOP;
-
-  pkt[0] = WT5001_START;
-  pkt[1] = 0x02;                // length
-  pkt[2] = opcode;
-  pkt[3] = WT5001_END;
-
-  writeData(pkt, 4);
-
-  return checkResponse(opcode);
-}
-
-bool WT5001::next()
-{
-  char pkt[4];
-  WT5001_OPCODE_T opcode = NEXT;
-
-  pkt[0] = WT5001_START;
-  pkt[1] = 0x02;                // length
-  pkt[2] = opcode;
-  pkt[3] = WT5001_END;
-
-  writeData(pkt, 4);
-
-  return checkResponse(opcode);
-}
-
-bool WT5001::previous()
-{
-  char pkt[4];
-  WT5001_OPCODE_T opcode = PREVIOUS;
-
-  pkt[0] = WT5001_START;
-  pkt[1] = 0x02;                // length
-  pkt[2] = opcode;
-  pkt[3] = WT5001_END;
-
-  writeData(pkt, 4);
-
-  return checkResponse(opcode);
-}
-
-bool WT5001::pause()
-{
-  char pkt[4];
-  WT5001_OPCODE_T opcode = PAUSE;
-
-  pkt[0] = WT5001_START;
-  pkt[1] = 0x02;                // length
-  pkt[2] = opcode;
-  pkt[3] = WT5001_END;
-
-  writeData(pkt, 4);
-
-  return checkResponse(opcode);
-}
-
-bool WT5001::setVolume(uint8_t vol)
-{
-  if (vol > WT5001_MAX_VOLUME)
-    {
-      // C++11 std::to_string() would be nice, but...
-      std::ostringstream str;
-      str << WT5001_MAX_VOLUME;
-
-      throw std::out_of_range(std::string(__FUNCTION__) +
-                              ": angle must be between 0 and " +
-                              str.str());
-      return false;
-    }
-  
-  char pkt[5];
-  WT5001_OPCODE_T opcode = SET_VOLUME;
-
-  pkt[0] = WT5001_START;
-  pkt[1] = 0x03;                // length
-  pkt[2] = opcode;
-  pkt[3] = vol;
-  pkt[4] = WT5001_END;
-
-  writeData(pkt, 5);
-
-  return checkResponse(opcode);
-}
-
-bool WT5001::queue(uint16_t index)
-{
-  char pkt[6];
-  WT5001_OPCODE_T opcode = QUEUE;
-
-  pkt[0] = WT5001_START;
-  pkt[1] = 0x04;                // length
-  pkt[2] = opcode;
-  pkt[3] = (index >> 8) & 0xff; // index hi
-  pkt[4] = index & 0xff;        // index lo
-  pkt[5] = WT5001_END;
-
-  writeData(pkt, 6);
-
-  return checkResponse(opcode);
-}
-
-bool WT5001::setPlayMode(WT5001_PLAYMODE_T pm)
-{
-  char pkt[5];
-  WT5001_OPCODE_T opcode = PLAY_MODE;
-
-  pkt[0] = WT5001_START;
-  pkt[1] = 0x03;                // length
-  pkt[2] = opcode;
-  pkt[3] = pm;
-  pkt[4] = WT5001_END;
-
-  writeData(pkt, 5);
-
-  return checkResponse(opcode);
-}
-
-bool WT5001::insert(uint16_t index)
-{
-  char pkt[6];
-  WT5001_OPCODE_T opcode = INSERT_SONG;
-
-  pkt[0] = WT5001_START;
-  pkt[1] = 0x04;                // length
-  pkt[2] = opcode;
-  pkt[3] = (index >> 8) & 0xff; // index hi
-  pkt[4] = index & 0xff;        // index lo
-  pkt[5] = WT5001_END;
-
-  writeData(pkt, 6);
-
-  return checkResponse(opcode);
-}
-
-bool WT5001::setDate(uint16_t year, uint8_t month, uint8_t day)
-{
-  char pkt[8];
-  WT5001_OPCODE_T opcode = SET_DATE;
-
-  pkt[0] = WT5001_START;
-  pkt[1] = 0x06;                // length
-  pkt[2] = opcode;
-  pkt[3] = (year >> 8) & 0xff;  // year hi
-  pkt[4] = year & 0xff;         // year lo
-  pkt[5] = month;               // month
-  pkt[6] = day;                 // day
-  pkt[7] = WT5001_END;
-
-  writeData(pkt, 8);
-
-  return checkResponse(opcode);
-}
-
-bool WT5001::setTime(uint8_t hour, uint8_t minute, uint8_t second)
-{
-  char pkt[7];
-  WT5001_OPCODE_T opcode = SET_TIME;
-
-  pkt[0] = WT5001_START;
-  pkt[1] = 0x05;                // length
-  pkt[2] = opcode;
-  pkt[3] = hour;                // hour
-  pkt[4] = minute;              // minute
-  pkt[5] = second;              // second
-  pkt[6] = WT5001_END;
-
-  writeData(pkt, 7);
-
-  return checkResponse(opcode);
-}
-
-bool WT5001::setAlarm(uint8_t hour, uint8_t minute, uint8_t second)
-{
-  char pkt[7];
-  WT5001_OPCODE_T opcode = SET_ALARM;
-
-  pkt[0] = WT5001_START;
-  pkt[1] = 0x05;                // length
-  pkt[2] = opcode;
-  pkt[3] = hour;                // hour
-  pkt[4] = minute;              // minute
-  pkt[5] = second;              // second
-  pkt[6] = WT5001_END;
-
-  writeData(pkt, 7);
-
-  return checkResponse(opcode);
-}
-
-bool WT5001::clearAlarm()
-{
-  char pkt[4];
-  WT5001_OPCODE_T opcode = CLEAR_ALARM;
-
-  pkt[0] = WT5001_START;
-  pkt[1] = 0x02;                // length
-  pkt[2] = opcode;
-  pkt[3] = WT5001_END;
-
-  writeData(pkt, 4);
-
-  return checkResponse(opcode);
-}
-
-bool WT5001::getVolume(uint8_t *vol)
-{
-  char pkt[4];
-  WT5001_OPCODE_T opcode = READ_VOLUME;
-
-  pkt[0] = WT5001_START;
-  pkt[1] = 0x02;                // length
-  pkt[2] = opcode;
-  pkt[3] = WT5001_END;
-
-  writeData(pkt, 4);
-
-  if (!checkResponse(opcode))
-    return false;
-
-  // there should be a byte waiting for us, the volume
-  int rv = readData((char *)vol, 1);
-  if (rv != 1)
-    return false;
-
-  return true;
-}
-
-uint8_t WT5001::getVolume()
-{
-  uint8_t vol = 0;
-  if (!getVolume(&vol))
-    throw std::runtime_error(std::string(__PRETTY_FUNCTION__) +
-                                ": readData() failed");
-  return vol;
-}
-
-bool WT5001::getPlayState(uint8_t *ps)
-{
-  char pkt[4];
-  WT5001_OPCODE_T opcode = READ_PLAY_STATE;
-
-  pkt[0] = WT5001_START;
-  pkt[1] = 0x02;                // length
-  pkt[2] = opcode;
-  pkt[3] = WT5001_END;
-
-  writeData(pkt, 4);
-
-  if (!checkResponse(opcode))
-    return false;
-
-  // there should be a byte waiting for us, the play state
-  int rv = readData((char *)ps, 1);
-  if (rv != 1)
-    return false;
-
-  return true;
-}
-
-uint8_t WT5001::getPlayState()
-{
-  uint8_t ps = 0;
-  if (!getPlayState(&ps))
-    throw std::runtime_error(std::string(__PRETTY_FUNCTION__) +
-                                ": readData() failed");
-  return ps;
-}
-
-bool WT5001::getNumFiles(WT5001_PLAYSOURCE_T psrc, uint16_t *numf)
-{
-  char pkt[4];
-  WT5001_OPCODE_T opcode = NONE;
-
-  pkt[0] = WT5001_START;
-  pkt[1] = 0x02;                // length
-
-  switch (psrc)                 // src
-    {
-    case SD:
-      opcode = READ_SD_NUMF;
-      break;
-
-    case SPI:
-      opcode = READ_SPI_NUMF;
-      break;
-
-    case UDISK:
-      opcode = READ_UDISK_NUMF;
-      break;
-    }      
-
-  pkt[2] = opcode;
-  pkt[3] = WT5001_END;
-
-  writeData(pkt, 4);
-
-  if (!checkResponse(opcode))
-    return false;
-
-  // read the two byte response, and encode them
-  char buf[2];
-  int rv = readData(buf, 2);
-  if (rv != 2)
-    return false;
-
-  *numf = (buf[0] << 8) | buf[1];
-
-  return true;
-}
-
-uint16_t WT5001::getNumFiles(WT5001_PLAYSOURCE_T psrc)
-{
-  uint16_t numf = 0;
-  if (!getNumFiles(psrc, &numf))
-    throw std::runtime_error(std::string(__PRETTY_FUNCTION__) +
-                                ": readData() failed");
-  return numf;
-}
-
-bool WT5001::getCurrentFile(uint16_t *curf)
-{
-  char pkt[4];
-  WT5001_OPCODE_T opcode = READ_CUR_FNAME;
-
-  pkt[0] = WT5001_START;
-  pkt[1] = 0x02;                // length
-  pkt[2] = opcode;
-  pkt[3] = WT5001_END;
-
-  writeData(pkt, 4);
-
-  if (!checkResponse(opcode))
-    return false;
-
-  // read the two byte response, and encode them
-  char buf[2];
-  int rv = readData(buf, 2);
-  if (rv != 2)
-    return false;
-
-  *curf = (buf[0] << 8) | (buf[1] & 0xff);
-
-  return true;
-}
-
-uint16_t WT5001::getCurrentFile()
-{
-  uint16_t curf = 0;
-  if (!getCurrentFile(&curf))
-    throw std::runtime_error(std::string(__PRETTY_FUNCTION__) +
-                                ": readData() failed");
-  return curf;
-}
-
-bool WT5001::getDate(uint16_t *year, uint8_t *month, uint8_t *day)
-{
-  char pkt[4];
-  WT5001_OPCODE_T opcode = READ_DATE;
-
-  pkt[0] = WT5001_START;
-  pkt[1] = 0x02;                // length
-  pkt[2] = opcode;
-  pkt[3] = WT5001_END;
-
-  writeData(pkt, 4);
-
-  if (!checkResponse(opcode))
-    return false;
-
-  // read the 4 byte response
-  char buf[4];
-  int rv = readData(buf, 4);
-  if (rv != 4)
-    return false;
-
-  *year = (buf[0] << 8) | (buf[1] & 0xff);
-  *month = buf[2];
-  *day = buf[3];
-  return true;
-}
-
-bool WT5001::getTime(uint8_t *hour, uint8_t *minute, uint8_t *second)
-{
-  char pkt[4];
-  WT5001_OPCODE_T opcode = READ_TIME;
-
-  pkt[0] = WT5001_START;
-  pkt[1] = 0x02;                // length
-  pkt[2] = opcode;
-  pkt[3] = WT5001_END;
-
-  writeData(pkt, 4);
-
-  if (!checkResponse(opcode))
-    return false;
-
-  // read the 3 byte response
-  char buf[3];
-  int rv = readData(buf, 3);
-  if (rv != 3)
-    return false;
-
-  *hour = buf[0];
-  *minute = buf[1];
-  *second = buf[2];
-  return true;
-}
-
diff --git a/src/wt5001/wt5001.hpp b/src/wt5001/wt5001.hpp
deleted file mode 100644
index 57820a6..0000000
--- a/src/wt5001/wt5001.hpp
+++ /dev/null
@@ -1,383 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <iostream>
-
-#include <stdint.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-#include <fcntl.h>
-#include <errno.h>
-#include <termios.h>
-#include <sys/time.h>
-#include <sys/select.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-
-#include <mraa/uart.h>
-
-const int WT5001_DEFAULT_UART = 0;
-const int WT5001_MAX_VOLUME = 31;
-
-// protocol start and end codes
-const uint8_t WT5001_START = 0x7e;
-const uint8_t WT5001_END   = 0x7e;
-
-namespace upm {
-    /**
-     * @brief WT5001 Serial MP3 Module
-     * @defgroup wt5001 libupm-wt5001
-     * @ingroup seeed uart sound
-     */
-    /**
-     * @library wt5001
-     * @sensor wt5001
-     * @comname Serial MP3 Module
-     * @altname Grove Serial MP3 Player
-     * @type sound
-     * @man seeed
-     * @web http://www.seeedstudio.com/wiki/Grove_%E2%80%93_Serial_MP3_Player
-     * @con uart
-     *
-     * @brief API for the WT5001 Serial MP3 Module
-     *
-     *   UPM support for the WT5001 Serial MP3 module. This was tested
-     *   specifically with the Grove Serial MP3 module.
-     *
-     * @image html wt5001.jpg
-     * @snippet wt5001.cxx Interesting
-     */
-  class WT5001 {
-  public:
-
-    // WT5001 opcodes
-    typedef enum { NONE             = 0x00,
-                   PLAY_SD          = 0xa0,
-                   PLAY_SPI         = 0xa1,
-                   PLAY_UDISK       = 0xa2,
-                   PAUSE            = 0xa3,
-                   STOP             = 0xa4,
-                   NEXT             = 0xa5,
-                   PREVIOUS         = 0xa6,
-                   SET_VOLUME       = 0xa7,
-                   QUEUE            = 0xa8,
-                   PLAY_MODE        = 0xa9,
-                   COPY_SD2FLASH    = 0xaa, // not implemented
-                   COPY_UDISK2FLASH = 0xab, // not implemented
-                   INSERT_SONG      = 0xac,
-                   SET_DATE         = 0xb1,
-                   SET_TIME         = 0xb2,
-                   SET_ALARM        = 0xb3,
-                   SET_ALARM_DUR    = 0xb4, // not implemented
-                   CLEAR_ALARM      = 0xb5,
-                   CLEAR_ALARM_DUR  = 0xb6, // not implemented
-                   READ_VOLUME      = 0xc1,
-                   READ_PLAY_STATE  = 0xc2,
-                   READ_SPI_NUMF    = 0xc3,
-                   READ_SD_NUMF     = 0xc4,
-                   READ_UDISK_NUMF  = 0xc5,
-                   READ_CUR_FNAME   = 0xc6,
-                   READ_CF_CHAR     = 0xc7, // not implemented
-                   READ_DATE        = 0xd1,
-                   READ_TIME        = 0xd2
-    } WT5001_OPCODE_T;
-
-    // play modes
-    typedef enum { NORMAL           = 0x00,
-                   SINGLE_REPEAT    = 0x01,
-                   ALL_REPEAT       = 0x02,
-                   RANDOM           = 0x03
-    } WT5001_PLAYMODE_T;
-
-    // music source
-    typedef enum { SD,
-                   SPI,
-                   UDISK
-    } WT5001_PLAYSOURCE_T;
-
-    /**
-     * WT5001 constructor
-     *
-     * @param uart Default UART to use (0 or 1)
-     */
-    WT5001(int uart);
-
-    /**
-     * WT5001 destructor
-     */
-    ~WT5001();
-
-    /**
-     * Checks to see if there is data available for reading
-     *
-     * @param millis Number of milliseconds to wait; 0 means no waiting
-     * @return True if there is data available for reading
-     */
-    bool dataAvailable(unsigned int millis);
-
-    /**
-     * Reads any available data in a user-supplied buffer. Note: the
-     * call blocks until data is available to be read. Use
-     * dataAvailable() to determine whether there is data available
-     * beforehand, to avoid blocking.
-     *
-     * @param buffer Buffer to hold the data read
-     * @param len Length of the buffer
-     * @return Number of bytes read
-     */
-    int readData(char *buffer, int len);
-
-    /**
-     * Writes the data in the buffer to the device
-     *
-     * @param buffer Buffer to hold the data read
-     * @param len Length of the buffer
-     * @return Number of bytes written
-     */
-    int writeData(char *buffer, int len);
-
-    /**
-     * Sets up proper tty I/O modes and the baud rate. The default
-     * baud rate is 9,600 (B9600).
-     *
-     * @param baud Desired baud rate.
-     * @return True if successful
-     */
-    bool setupTty(speed_t baud=B9600);
-
-    /**
-     * Gets a command response and returns its validity
-     *
-     * @param opcode Opcode to verify
-     * @return True if successful
-     */
-    bool checkResponse(WT5001_OPCODE_T opcode);
-
-    /**
-     * Plays a file from a source
-     *
-     * @param psrc Play source (SD, UDISK, SPI)
-     * @param index File number to play
-     * @return True if successful
-     */
-    bool play(WT5001_PLAYSOURCE_T psrc, uint16_t index);
-
-    /**
-     * Stops playing
-     *
-     * @return True if successful
-     */
-    bool stop();
-
-    /**
-     * Pauses the playback or resumes it if already paused
-     *
-     * @return True if successful
-     */
-    bool pause();
-
-    /**
-     * Moves to the next track
-     *
-     * @return True if successful
-     */
-    bool next();
-
-    /**
-     * Moves to the previous track
-     *
-     * @return True if successful
-     */
-    bool previous();
-
-    /**
-     * Sets the volume. Valid range is 0-31. 0 means mute.
-     *
-     * @return True if successful
-     */
-    bool setVolume(uint8_t vol);
-
-    /**
-     * Queues a track to play next, when the current song is finished
-     *
-     * @param index File number to queue
-     * @return True if successful
-     */
-    bool queue(uint16_t index);
-
-    /**
-     * Sets the playback mode
-     *
-     * @param pm Play mode to enable
-     * @return True if successful
-     */
-    bool setPlayMode(WT5001_PLAYMODE_T pm);
-
-    /**
-     * Inserts a track to play immediately, interrupting the current
-     * track. When the inserted track is finished, the
-     * interrupted track resumes where it was interrupted.
-     *
-     * @param index File number to insert
-     * @return True if successful
-     */
-    bool insert(uint16_t index);
-
-    /**
-     * Sets the date of the internal clock
-     *
-     * @param year 4-digit year
-     * @param month Month
-     * @param day Day
-     * @return True if successful
-     */
-    bool setDate(uint16_t year, uint8_t month, uint8_t day);
-
-    /**
-     * Sets the time of the internal clock
-     *
-     * @param hour Hour
-     * @param minute Minute
-     * @param second Second
-     * @return True if successful
-     */
-    bool setTime(uint8_t hour, uint8_t minute, uint8_t second);
-
-    /**
-     * Sets the alarm
-     *
-     * @param hour Hour
-     * @param minute Minute
-     * @param second Second
-     * @return True if successful
-     */
-    bool setAlarm(uint8_t hour, uint8_t minute, uint8_t second);
-
-    /**
-     * Clears any alarm that has been set
-     *
-     * @return True if successful
-     */
-    bool clearAlarm();
-
-    /**
-     * Gets the current volume
-     *
-     * @param vol Volume
-     * @return True if successful
-     */
-    bool getVolume(uint8_t *vol);
-
-    /**
-     * Gets the current volume
-     *
-     * @return Volume
-     * @throws std::runtime_error if reading from the sensor failed
-     */
-    uint8_t getVolume();
-
-    /**
-     * Gets the current play state: 1 = playing, 2 = stopped, 3 = paused
-     *
-     * @param ps Play state
-     * @return True if successful
-     */
-    bool getPlayState(uint8_t *ps);
-
-    /**
-     * Gets the current play state: 1 = playing, 2 = stopped, 3 = paused
-     *
-     * @return Play state
-     * @throws std::runtime_error if reading from the sensor failed
-     */
-    uint8_t getPlayState();
-
-    /**
-     * Gets the number of files present on the source device
-     *
-     * @param psrc Storage source
-     * @param numf Number of files
-     * @return True if successful
-     */
-    bool getNumFiles(WT5001_PLAYSOURCE_T psrc, uint16_t *numf);
-
-    /**
-     * Gets the number of files present on the source device
-     *
-     * @param psrc Storage source
-     * @return Number of files
-     * @throws std::runtime_error if reading from the sensor failed
-     */
-    uint16_t getNumFiles(WT5001_PLAYSOURCE_T psrc);
-
-    /**
-     * Gets the index of the current file
-     *
-     * @param curf Index of the current file
-     * @return True if successful
-     */
-    bool getCurrentFile(uint16_t *curf);
-
-    /**
-     * Gets the index of the current file
-     *
-     * @return Index of the curretn file
-     * @throws std::runtime_error if reading from the sensor failed
-     */
-    uint16_t getCurrentFile();
-
-    /**
-     * Gets the device date
-     *
-     * @param year 4-digit year
-     * @param month Month
-     * @param day Day
-     * @return True if successful
-     */
-    bool getDate(uint16_t *year, uint8_t *month, uint8_t *day);
-
-    /**
-     * Gets the device time
-     *
-     * @param hour Hour
-     * @param minute Minute
-     * @param second Second
-     * @return True if successful
-     */
-    bool getTime(uint8_t *hour, uint8_t *minute, uint8_t *second);
-
-
-  protected:
-    int ttyFd() { return m_ttyFd; };
-
-  private:
-    mraa_uart_context m_uart;
-    int m_ttyFd;
-  };
-}
-
-
diff --git a/src/wt5001/wt5001.i b/src/wt5001/wt5001.i
deleted file mode 100644
index 55e074c..0000000
--- a/src/wt5001/wt5001.i
+++ /dev/null
@@ -1,58 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "../java_buffer.i"
-%include "../java_exceptions.i"
-
-%apply uint8_t *OUTPUT { uint8_t *vol };
-%apply uint8_t *OUTPUT { uint8_t *ps };
-%apply uint16_t *OUTPUT { uint16_t *numf };
-%apply uint16_t *OUTPUT { uint16_t *curf };
-%apply uint16_t *OUTPUT { uint16_t *year };
-%apply uint8_t *OUTPUT { uint8_t *month, uint8_t *day };
-%apply uint8_t *OUTPUT { uint8_t *hour, uint8_t *minute, uint8_t *second };
-
-%ignore getVolume(uint8_t *vol);
-READDATA_EXCEPTION(getVolume())
-
-%ignore getPlayState(uint8_t *ps);
-READDATA_EXCEPTION(getPlayState())
-
-%ignore getNumFiles(WT5001_PLAYSOURCE_T psrc, uint16_t *numf);
-READDATA_EXCEPTION(getNumFiles(WT5001_PLAYSOURCE_T psrc))
-
-%ignore getCurrentFile(uint16_t *curf);
-READDATA_EXCEPTION(getCurrentFile())
-
-JAVA_JNI_LOADLIBRARY(javaupm_wt5001)
-#endif
-/* END Java syntax */
-
-/* BEGIN Javascript syntax  ------------------------------------------------- */
-#ifdef SWIGJAVASCRIPT
-%include "../carrays_uint8_t.i"
-%include "../carrays_uint16_t.i"
-#endif
-/* END Javascript syntax */
-
-/* BEGIN Python syntax  ----------------------------------------------------- */
-#ifdef SWIGPYTHON
-%rename("getVolumeNoParam")  getVolume();
-%rename("getPlayStateNoParam") getPlayState();
-%rename("getNumFilesOneParam")  getNumFiles(WT5001_PLAYSOURCE_T psrc);
-%rename("getCurrentFileNoParam") getCurrentFile();
-#endif
-/* END Python syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%include "../carrays_uint8_t.i"
-%include "../carrays_uint16_t.i"
-
-%{
-#include "wt5001.hpp"
-speed_t int_B9600 = B9600;
-%}
-%include "wt5001.hpp"
-speed_t int_B9600 = B9600;
-/* END Common SWIG syntax */
diff --git a/src/wt5001/wt5001.json b/src/wt5001/wt5001.json
deleted file mode 100644
index 9e074d7..0000000
--- a/src/wt5001/wt5001.json
+++ /dev/null
@@ -1,51 +0,0 @@
-{
-    "Library": "wt5001",
-    "Description": "WT5001 Serial MP3 module Library",
-    "Sensor Class": {
-        "WT5001": {
-            "Name": "API for the WT5001 Serial MP3 Module",
-            "Description": "This is the UPM Module for the WT5001 Serial MP3 Module. Grove-Serial MP3 Player is a kind of simple MP3 player device whose design is based on a high-quality MP3 audio chip---WT5001. It can support 8KHZ~44.1KHZ sampling frequency MP3 and WAV file formats. This product has several peripheral ports: a standard UART Grove interface, a dual track headphone jack, an external interface and also a  micro SD card interface. You can control the MP3 playback state by sending commands to module via serial port tools, such as switch songs, change the volume and play mode and so on. It seems a simple module, but it owns such strong function. Want to know how the sound quality? Please come to experience it! NOTE: This product is retired, please consider the Grove - MP3 v2.0 as your alternative choice. This UPM module has not been tested with V2.0.",
-            "Aliases": ["wt5001", "Grove - Serial MP3 Player"],
-            "Categories": ["sound"],
-            "Connections": ["uart"],
-            "Project Type": ["prototyping"],
-            "Manufacturers": ["Seeed"],
-            "Image": "wt5001.jpg",
-            "Examples": {
-                "Java": ["WT5001_Example.java"],
-                "Python": ["wt5001.py"],
-                "Node.js": ["wt5001.js"],
-                "C++": ["wt5001.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.3,
-                    "max": 5.2
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "min" : 37.6,
-                    "max" : 52.0
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -40,
-                    "max": 85
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/grove-serial-mp3-player-p-1542.html", "http://wiki.seeedstudio.com/wiki/Grove_%E2%80%93_Serial_MP3_Player"],
-                "Datasheets": ["http://wiki.seeedstudio.com/images/2/26/WT5001_datasheet_V1.5.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/xbee/CMakeLists.txt b/src/xbee/CMakeLists.txt
deleted file mode 100644
index d41782d..0000000
--- a/src/xbee/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "xbee")
-set (libdescription "XBee Serial Module")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa)
diff --git a/src/xbee/xbee.cxx b/src/xbee/xbee.cxx
deleted file mode 100644
index ba7ae22..0000000
--- a/src/xbee/xbee.cxx
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <time.h>
-
-#include "xbee.hpp"
-
-using namespace upm;
-using namespace std;
-
-static const int maxBuffer = 1024;
-
-XBee::XBee(int uart) :
-  m_uart(uart)
-{
-}
-
-XBee::~XBee()
-{
-}
-
-bool XBee::dataAvailable(unsigned int millis)
-{
-  return m_uart.dataAvailable(millis);
-}
-
-int XBee::readData(char *buffer, unsigned int len)
-{
-  return m_uart.read(buffer, len);
-}
-
-std::string XBee::readDataStr(int len)
-{
-  return m_uart.readStr(len);
-}
-
-int XBee::writeData(char *buffer, unsigned int len)
-{
-  m_uart.flush();
-  return m_uart.write(buffer, len);
-}
-
-int XBee::writeDataStr(std::string data)
-{
-  m_uart.flush();
-  return m_uart.writeStr(data);
-}
-
-mraa::Result XBee::setBaudRate(int baud)
-{
-  return m_uart.setBaudRate(baud);
-}
-
-bool XBee::commandMode(std::string cmdChars, int guardTimeMS)
-{
-
-  usleep(guardTimeMS * 1000);
-
-  writeDataStr(cmdChars);
-
-  usleep(guardTimeMS * 1000);
-
-  string resp;
-  if (dataAvailable(1000))
-    resp = readDataStr(maxBuffer);
-
-  if (resp.find("OK"))
-    return true;
-  else
-    return false;
-}
-
-string XBee::stringCR2LF(string str)
-{
-  for (size_t i=0; i<str.size(); i++)
-    if (str[i] == '\r')
-      str[i] = '\n';
-  
-  return str;
-}
diff --git a/src/xbee/xbee.hpp b/src/xbee/xbee.hpp
deleted file mode 100644
index 4e33128..0000000
--- a/src/xbee/xbee.hpp
+++ /dev/null
@@ -1,193 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Thanks to Adafruit for supplying a google translated version of the
- * Chinese datasheet and some clues in their code.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <iostream>
-
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-
-#include <mraa/common.hpp>
-#include <mraa/uart.hpp>
-
-#define XBEE_DEFAULT_UART 0
-
-namespace upm {
-    /**
-     * @brief XBee Modules Library
-     * @defgroup xbee libupm-xbee
-     * @ingroup sparkfun uart wifi
-     */
-
-    /**
-     * @library xbee
-     * @sensor xbee
-     * @comname XBee Serial Module
-     * @type wifi
-     * @man sparkfun
-     * @con uart
-     * @web https://www.sparkfun.com/products/11215
-     *
-     * @brief API for the XBee modules
-     *
-     * This is a generic UART driver for use with Digi XBee modules.
-     * It was tested with the XBee S1 802.15.4 module and the XBee S6B
-     * WiFi module.
-     *
-     * It provides basic UART support for sending and receiving data
-     * to and from the device.  It is controlled by an AT or API
-     * command set.
-     *
-     * It is connected at 9600 baud by default.
-     *
-     * These devices are typically configured using Digi's X-CTU
-     * windows software, however it is possible of course to configure
-     * them manually using AT commands.  See the examples.
-     *
-     * @image html xbee.jpg
-     * <br><em>XBee Sensor image provided by SparkFun* under
-     * <a href=https://creativecommons.org/licenses/by/2.0/>
-     * CC BY 2.0</a>.</em>
-     *
-     * @snippet xbee.cxx Interesting
-     */
-
-  class XBee {
-  public:
-
-    /**
-     * XBee object constructor
-     *
-     * @param uart Default UART to use (0 or 1). Default is 0.
-     */
-    XBee(int uart=XBEE_DEFAULT_UART);
-
-    /**
-     * XBee object destructor
-     */
-    ~XBee();
-
-    /**
-     * Checks to see if there is data available for reading
-     *
-     * @param millis Number of milliseconds to wait; 0 means no waiting
-     * @return true if there is data available for reading
-     */
-    bool dataAvailable(unsigned int millis);
-
-    /**
-     * Reads any available data into a user-supplied buffer. Note: the
-     * call blocks until data is available for reading. Use
-     * dataAvailable() to determine whether there is data available
-     * beforehand, to avoid blocking.
-     *
-     * @param buffer Buffer to hold the data read
-     * @param len Length of the buffer
-     * @return Number of bytes read
-     */
-    int readData(char *buffer, unsigned int len);
-
-    /**
-     * Reads any available data and returns it in a std::string. Note:
-     * the call blocks until data is available for reading. Use
-     * dataAvailable() to determine whether there is data available
-     * beforehand, to avoid blocking.
-     *
-     * @param len Maximum length of the data to be returned
-     * @return string containing the data read
-     */
-    std::string readDataStr(int len);
-
-    /**
-     * Writes the data in the buffer to the device.  If you are
-     * writing an AT command, be sure to terminate it with a carriage
-     * return (\r)
-     *
-     * @param buffer Buffer to hold the data to write
-     * @param len Length of the buffer
-     * @return Number of bytes written
-     */
-    int writeData(char *buffer, unsigned len);
-
-    /**
-     * Writes the std:string data to the device.  If you are writing an
-     * AT command, be sure to terminate it with a carriage return (\r)
-     *
-     * @param data Buffer to write to the device
-     * @return Number of bytes written
-     */
-    int writeDataStr(std::string data);
-
-    /**
-     * Sets the baud rate for the device.  The default is 9600.
-     *
-     * @param baud Desired baud rate
-     * @return true if successful
-     */
-    mraa::Result setBaudRate(int baud=9600);
-
-    /**
-     * Attempts to enter AT Command Mode.  When Idle, data sent to the
-     * device (assuming it is not in API mode) is silently transmitted
-     * to the configured destination.  Running this command attempts
-     * to place the device into command mode, allowing you to send AT
-     * commands.  Note, after a configurable period of inactivity, the
-     * device will exit command mode automatically (default 10
-     * seconds).
-     *
-     * Both the cmdChars (+++) and the Guard Time can be configured
-     * on the device to different values using AT configuration
-     * commands.
-     *
-     * @param cmdChars The command mode characters, default "+++"
-     * @param guardTimeMS The number of milliseconds to wait before and
-     * after sending the command characters.  Default is 1000 (1 second).
-     * @return true if successful (received an "OK"), false otherwise
-     */
-    bool commandMode(std::string cmdChars="+++", int guardTimeMS=1000);
-
-    /**
-     * This is a convenience method that converts each CR (\r) in a
-     * string to a LF (\n) and returns it.  This is useful for
-     * outputting the response to an AT command for instance, which is
-     * typically CR terminated.
-     *
-     * @param str The string to convert
-     * @return The converted string
-     */
-    std::string stringCR2LF(std::string str);
-
-  protected:
-    mraa::Uart m_uart;
-
-  private:
-  };
-}
-
-
diff --git a/src/xbee/xbee.i b/src/xbee/xbee.i
deleted file mode 100644
index 840dbe4..0000000
--- a/src/xbee/xbee.i
+++ /dev/null
@@ -1,16 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-JAVA_JNI_LOADLIBRARY(javaupm_xbee)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%include "carrays.i"
-%{
-#include "xbee.hpp"
-%}
-%include "xbee.hpp"
-%array_class(char, charArray);
-/* END Common SWIG syntax */
diff --git a/src/xbee/xbee.json b/src/xbee/xbee.json
deleted file mode 100644
index 09dffd9..0000000
--- a/src/xbee/xbee.json
+++ /dev/null
@@ -1,61 +0,0 @@
-{
-    "Library": "xbee",
-    "Description": "XBee modules Library",
-    "Sensor Class": {
-        "XBee": {
-            "Name": "API for the XBee modules",
-            "Description": "This is the UPM Module for the XBee modules. This is a generic UART driver for use with Digi XBee modules. It was tested with the XBee S1 802.15.4 module and the XBee S6B WiFi module. It provides basic UART support for sending and receiving data to and from the device.  It is controlled by an AT or API command set. It is connected at 9600 baud by default.",
-            "Aliases": ["xbee", "XBee 1mW Trace Antenna - Series 1 (802.15.4)"],
-            "Categories": ["wifi"],
-            "Connections": ["uart"],
-            "Project Type": ["prototyping", "commercial"],
-            "Manufacturers": ["SparkFun"],
-            "Image": "xbee.jpg",
-            "Examples": {
-                "Python": ["xbee.py"],
-                "Node.js": ["xbee.js"],
-                "C++": ["xbee.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 2.8,
-                    "max": 3.4
-                },
-                "Supply Current": {
-                    "XBee": {
-                        "unit": "mA",
-                        "min" : 45,
-                        "max" : 50
-                    },
-                    "XBee PRO": {
-                        "min" : 55,
-                        "max" : 215
-                    }
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -40,
-                    "max": 85
-                },
-                "Band": {
-                    "unit": "GHz",
-                    "frequency": 2.4
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need XBee shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need XBee shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.sparkfun.com/products/11215"],
-                "Datasheets": ["https://www.sparkfun.com/datasheets/Wireless/Zigbee/XBee-Datasheet.pdf"],
-                "Schematics": ["https://www.sparkfun.com/datasheets/Wireless/Zigbee/XBee-Dimensional.pdf"]
-            }
-        }
-    }
-}
diff --git a/src/yg1006/CMakeLists.txt b/src/yg1006/CMakeLists.txt
deleted file mode 100644
index c73fe55..0000000
--- a/src/yg1006/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-upm_mixed_module_init (NAME yg1006
-    DESCRIPTION "Flame Sensor"
-    C_HDR yg1006.h
-    C_SRC yg1006.c
-    CPP_HDR yg1006.hpp
-    CPP_SRC yg1006.cxx
-    FTI_SRC yg1006_fti.c
-    CPP_WRAPS_C
-    REQUIRES mraa)
diff --git a/src/yg1006/yg1006.c b/src/yg1006/yg1006.c
deleted file mode 100644
index 4688d97..0000000
--- a/src/yg1006/yg1006.c
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <assert.h>
-#include "yg1006.h"
-
-yg1006_context yg1006_init(unsigned int pin)
-{
-    yg1006_context dev =
-        (yg1006_context)malloc(sizeof(struct _yg1006_context));
-
-    if (!dev)
-        return NULL;
-
-    dev->gpio = NULL;
-
-    // make sure MRAA is initialized
-    int mraa_rv;
-    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
-    {
-        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
-        yg1006_close(dev);
-        return NULL;
-    }
-
-    // initialize the MRAA context
-
-    if (!(dev->gpio = mraa_gpio_init(pin)))
-    {
-        printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
-        yg1006_close(dev);
-        return NULL;
-    }
-
-    mraa_gpio_dir(dev->gpio, MRAA_GPIO_IN);
-
-    return dev;
-}
-
-void yg1006_close(yg1006_context dev)
-{
-    assert(dev != NULL);
-
-    if (dev->gpio)
-        mraa_gpio_close(dev->gpio);
-
-    free(dev);
-}
-
-bool yg1006_flame_detected(const yg1006_context dev)
-{
-    assert(dev != NULL);
-
-    // gpio is low when a flame is detected
-    return (mraa_gpio_read(dev->gpio) ? false : true);
-}
diff --git a/src/yg1006/yg1006.cxx b/src/yg1006/yg1006.cxx
deleted file mode 100644
index 0f89b29..0000000
--- a/src/yg1006/yg1006.cxx
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014-2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "yg1006.hpp"
-
-using namespace upm;
-using namespace std;
-
-YG1006::YG1006(unsigned int pin) :
-    m_yg1006(yg1006_init(pin))
-{
-    if (!m_yg1006)
-        throw std::runtime_error(std::string(__FUNCTION__) +
-                                 ": water_init() failed");
-}
-
-YG1006::~YG1006()
-{
-    yg1006_close(m_yg1006);
-}
-
-bool YG1006::flameDetected()
-{
-    return yg1006_flame_detected(m_yg1006);
-}
diff --git a/src/yg1006/yg1006.h b/src/yg1006/yg1006.h
deleted file mode 100644
index fe73fc0..0000000
--- a/src/yg1006/yg1006.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <upm.h>
-#include <mraa/gpio.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    /**
-     * @file yg1006.h
-     * @library yg1006
-     * @brief C API for the YG1006 Flame Sensor
-     *
-     * @include yg1006.c
-     */
-
-    /**
-     * Device context
-     */
-    typedef struct _yg1006_context {
-        mraa_gpio_context        gpio;
-    } *yg1006_context;
-
-    /**
-     * YG1006 initializer
-     *
-     * @param pin Digital pin to use
-     * @return an initialized device context on success, NULL on error.
-     */
-    yg1006_context yg1006_init(unsigned int pin);
-
-    /**
-     * YG1006 close function
-     */
-    void yg1006_close(yg1006_context dev);
-
-    /**
-     * Determines whether a flame has been detected
-     *
-     * @return true if a flame or another comparable light source has
-     * been detected
-     */
-    bool yg1006_flame_detected(const yg1006_context dev);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/yg1006/yg1006.hpp b/src/yg1006/yg1006.hpp
deleted file mode 100644
index 05aebeb..0000000
--- a/src/yg1006/yg1006.hpp
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2014-2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include "yg1006.h"
-
-namespace upm {
-    /**
-     * @brief YG1006 Flame Sensor
-     * @defgroup yg1006 libupm-yg1006
-     * @ingroup seeed gpio light hak
-     */
-
-    /**
-     * @library yg1006
-     * @sensor yg1006
-     * @comname Flame Sensor
-     * @altname Grove Flame Sensor
-     * @type light
-     * @man seeed
-     * @web http://www.seeedstudio.com/wiki/Grove_-_Flame_Sensor
-     * @con gpio
-     * @kit hak
-     *
-     * @brief API for the YG1006 Flame Sensor
-     *
-     *   UPM module for the YG1006 flame sensor. It detects a flame or any
-     *   other light source in the 760-1,100 nm wavelength range.
-     *
-     * @image html yg1006.jpg
-     * @snippet yg1006.cxx Interesting
-     */
-  class YG1006 {
-  public:
-
-    /**
-     * YG1006 constructor
-     *
-     * @param pin Digital pin to use
-     */
-    YG1006(unsigned int pin);
-
-    /**
-     * YG1006 destructor
-     */
-    ~YG1006();
-
-    /**
-     * Determines whether a flame has been detected
-     *
-     * @return true if a flame or another comparable light source has
-     * been detected
-     */
-    bool flameDetected();
-
-  private:
-    /* Disable implicit copy and assignment operators */
-    YG1006(const YG1006&) = delete;
-    YG1006 &operator=(const YG1006&) = delete;
-
-    yg1006_context m_yg1006;
-  };
-}
-
-
diff --git a/src/yg1006/yg1006.json b/src/yg1006/yg1006.json
deleted file mode 100644
index 1248734..0000000
--- a/src/yg1006/yg1006.json
+++ /dev/null
@@ -1,67 +0,0 @@
-{
-    "Library": "yg1006",
-    "Description": "YG1006 Flame Sensor Library",
-    "Sensor Class": {
-        "YG1006": {
-            "Name": "API for the YG1006 Flame Sensor",
-            "Description": "This is the UPM Module for the YG1006 Flame Sensor. The Grove - Flame Sensor can be used to detect fire source or other light sources of the wavelength in the range of 760nm - 1100 nm. It is based on the YG1006 sensor which is a high speed and high sensitive NPN silicon phototransistor. Due to its black epoxy, the sensor is sensitive to infrared radiation. In fire fighting robot game, The sensor plays a very important role, it can be used as a robot eyes to find the fire source.",
-            "Aliases": ["yg1006", "Grove - Flame Sensor"],
-            "Categories": ["light"],
-            "Connections": ["gpio"],
-            "Project Type": ["prototyping", "industrial", "robotics"],
-            "Manufacturers": ["Seeed", "Texas Instruments"],
-            "Kits": ["hak"],
-            "Image": "yg1006.jpg",
-            "Examples": {
-                "Java": ["YG1006_Example.java"],
-                "Python": ["yg1006.py"],
-                "Node.js": ["yg1006.js"],
-                "C++": ["yg1006.cxx"],
-                "C": ["yg1006.c"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 4.75,
-                    "max": 5.30
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "typ" : 20
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -25,
-                    "max": 85
-                },
-                "Response Time": {
-                    "unit": "us",
-                    "time": 15
-                },
-                "Light Range": {
-                    "unit": "nm",
-                    "min" : 760,
-                    "max" : 1100
-                },
-                "Effective Range": {
-                    "unit": "m",
-                    "min" : 0,
-                    "max" : 1
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-Flame-Sensor-p-1450.html", "http://wiki.seeed.cc/Grove-Flame_Sensor/"],
-                "Datasheets": ["https://raw.githubusercontent.com/SeeedDocument/Grove-Flame_Sensor/master/res/LM293D.pdf"],
-                "Schematics": ["https://raw.githubusercontent.com/SeeedDocument/Grove-Flame_Sensor/master/res/Grove-Directional_Light_Sensor_Eagle_File.zip"]
-            }
-        }
-    }
-}
diff --git a/src/yg1006/yg1006_fti.c b/src/yg1006/yg1006_fti.c
deleted file mode 100644
index 275a94c..0000000
--- a/src/yg1006/yg1006_fti.c
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2016 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include "yg1006.h"
-#include <upm_fti.h>
-
-/**
- * This file implements the Function Table Interface (FTI) for this sensor
- */
-
-const char upm_yg1006_name[] = "YG1006";
-const char upm_yg1006_description[] = "Flame sensor";
-const upm_protocol_t upm_yg1006_protocol[] = {UPM_GPIO};
-const upm_sensor_t upm_yg1006_category[] = {UPM_BINARY};
-
-// forward declarations
-const void* upm_yg1006_get_ft(upm_sensor_t sensor_type);
-void* upm_yg1006_init_name();
-void upm_yg1006_close(void *dev);
-upm_result_t upm_yg1006_flame_detected(void *dev, bool *value);
-
-static const upm_sensor_ft ft =
-{
-  .upm_sensor_init_name = upm_yg1006_init_name,
-  .upm_sensor_close = upm_yg1006_close,
-};
-
-static const upm_binary_ft bft =
-{
-  .upm_binary_get_value = upm_yg1006_flame_detected,
-};
-
-const void* upm_yg1006_get_ft(upm_sensor_t sensor_type)
-{
-  switch(sensor_type)
-    {
-    case UPM_SENSOR:
-      return &ft;
-    case UPM_BINARY:
-      return &bft;
-    default:
-      return NULL;
-    }
-}
-
-void *upm_yg1006_init_name()
-{
-  return NULL;
-}
-
-void upm_yg1006_close(void *dev)
-{
-  yg1006_close((yg1006_context)dev);
-}
-
-upm_result_t upm_yg1006_flame_detected(void *dev, bool *value)
-{
-  *value = yg1006_flame_detected((yg1006_context)dev);
-
-  return UPM_SUCCESS;
-}
diff --git a/src/zfm20/CMakeLists.txt b/src/zfm20/CMakeLists.txt
deleted file mode 100644
index bc49e1a..0000000
--- a/src/zfm20/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set (libname "zfm20")
-set (libdescription "Fingerprint Sensor Module")
-set (module_src ${libname}.cxx)
-set (module_hpp ${libname}.hpp)
-upm_module_init(mraa utilities-c)
diff --git a/src/zfm20/zfm20.cxx b/src/zfm20/zfm20.cxx
deleted file mode 100644
index 888685e..0000000
--- a/src/zfm20/zfm20.cxx
+++ /dev/null
@@ -1,458 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#include "zfm20.hpp"
-
-using namespace upm;
-using namespace std;
-
-static const int defaultDelay = 100;     // max wait time for read
-
-ZFM20::ZFM20(int uart, int baud): m_uart(uart)
-{
-  // Set the default password and address
-  setPassword(ZFM20_DEFAULT_PASSWORD);
-  setAddress(ZFM20_DEFAULT_ADDRESS);
-
-  initClock();
-
-  if (!setupTty(baud))
-    throw std::runtime_error(std::string(__FUNCTION__) +
-            ": failed to set baud rate to " + std::to_string(baud));
-}
-
-
-ZFM20::ZFM20(std::string uart_raw, int baud) : m_uart(uart_raw)
-{
-  // Set the default password and address
-  setPassword(ZFM20_DEFAULT_PASSWORD);
-  setAddress(ZFM20_DEFAULT_ADDRESS);
-
-  initClock();
-
-  if (!setupTty(baud))
-    throw std::runtime_error(std::string(__FUNCTION__) +
-            ": failed to set baud rate to " + std::to_string(baud));
-}
-
-int ZFM20::readData(char *buffer, int len)
-{
-  if (!m_uart.dataAvailable(defaultDelay))
-    return 0;               // timed out
-
-  int rv = m_uart.read(buffer, len);
-
-  if (rv < 0)
-    throw std::runtime_error(std::string(__FUNCTION__) +
-            ": Uart::read() failed: " + string(strerror(errno)));
-
-  return rv;
-}
-
-int ZFM20::writeData(char *buffer, int len)
-{
-  int rv = m_uart.write(buffer, len);
-
-  if (rv < 0)
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": Uart::write() failed: " +
-                               string(strerror(errno)));
-
-  if (rv == 0)
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": Uart::write() failed, no bytes written");
-
-  return rv;
-}
-
-bool ZFM20::setupTty(uint32_t baud)
-{
-    return m_uart.setBaudRate(baud) == mraa::SUCCESS;
-}
-
-int ZFM20::writeCmdPacket(uint8_t *pkt, int len)
-{
-  uint8_t rPkt[ZFM20_MAX_PKT_LEN];
-
-  rPkt[0] = ZFM20_START1;             // header bytes
-  rPkt[1] = ZFM20_START2;
-
-  rPkt[2] = (m_address >> 24) & 0xff; // address
-  rPkt[3] = (m_address >> 16) & 0xff;
-  rPkt[4] = (m_address >> 8) & 0xff;
-  rPkt[5] = m_address & 0xff;
-
-  rPkt[6] = PKT_COMMAND;
-
-  rPkt[7] = ((len + 2) >> 8) & 0xff;  // length (+ len bytes)
-  rPkt[8] = (len + 2) & 0xff;
-
-  // compute the starting checksum
-  uint16_t cksum = rPkt[7] + rPkt[8] + PKT_COMMAND;
-
-  int j = 9;
-  for (int i=0; i<len; i++)
-    {
-      rPkt[j] = pkt[i];
-      cksum += rPkt[j];
-      j++;
-    }
-
-  rPkt[j++] = (cksum >> 8) & 0xff;    // store the cksum
-  rPkt[j++] = cksum & 0xff;
-
-  return writeData((char *)rPkt, j);
-}
-
-void ZFM20::initClock()
-{
-  m_clock = upm_clock_init();
-}
-
-uint32_t ZFM20::getMillis()
-{
-  return upm_elapsed_ms(&m_clock);
-}
-
-bool ZFM20::verifyPacket(uint8_t *pkt, int len)
-{
-  // verify packet header
-  if (pkt[0] != ZFM20_START1 || pkt[1] != ZFM20_START2)
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": Invalid packet header");
-
-  // check the ack byte
-  if (pkt[6] != PKT_ACK)
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": Invalid ACK code");
-
-  return true;
-}
-
-bool ZFM20::getResponse(uint8_t *pkt, int len)
-{
-  char buf[ZFM20_MAX_PKT_LEN];
-
-  initClock();
-
-  int idx = 0;
-  int timer = 0;
-  int rv;
-
-  while (idx < len)
-    {
-      // wait for some data
-      if (!m_uart.dataAvailable(100))
-        {
-          timer += getMillis();
-          if (timer > ZFM20_TIMEOUT)
-              throw std::runtime_error(std::string(__FUNCTION__) +
-                                       ": Timed out waiting for packet");
-
-          continue;
-        }
-
-      if ((rv = readData(buf, ZFM20_MAX_PKT_LEN)) == 0)
-          throw std::runtime_error(std::string(__FUNCTION__) +
-                                   ": readData() failed, no data returned");
-
-      // copy it into the user supplied buffer
-      for (int i=0; i<rv; i++)
-        {
-          pkt[idx++] = buf[i];
-          if (idx >= len)
-            break;
-        }
-    }
-
-  // now verify it.
-  return verifyPacket(pkt, len);
-}
-
-bool ZFM20::verifyPassword()
-{
-  const int pktLen = 5;
-  uint8_t pkt[pktLen] = {CMD_VERIFY_PASSWORD,
-                         static_cast<uint8_t>((m_password >> 24) & 0xff),
-                         static_cast<uint8_t>((m_password >> 16) & 0xff),
-                         static_cast<uint8_t>((m_password >> 8) & 0xff),
-                         static_cast<uint8_t>(m_password & 0xff) };
-
-  writeCmdPacket(pkt, pktLen);
-
-  // now read a response
-  const int rPktLen = 12;
-  uint8_t rPkt[rPktLen];
-
-  getResponse(rPkt, rPktLen);
-
-
-  return true;
-}
-
-int ZFM20::getNumTemplates()
-{
-  const int pktLen = 1;
-  uint8_t pkt[pktLen] = {CMD_GET_TMPL_COUNT};
-
-  writeCmdPacket(pkt, pktLen);
-
-  // now read a response
-  const int rPktLen = 14;
-  uint8_t rPkt[rPktLen];
-
-  getResponse(rPkt, rPktLen);
-
-  // check confirmation code
-  if (rPkt[9] != 0x00)
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": Invalid confirmation code");
-  return ((rPkt[10] << 8) | rPkt[11]);
-}
-
-bool ZFM20::setNewPassword(uint32_t pwd)
-{
-  const int pktLen = 5;
-  uint8_t pkt[pktLen] = {CMD_SET_PASSWORD,
-                         static_cast<uint8_t>((pwd >> 24) & 0xff),
-                         static_cast<uint8_t>((pwd >> 16) & 0xff),
-                         static_cast<uint8_t>((pwd >> 8) & 0xff),
-                         static_cast<uint8_t>(pwd & 0xff) };
-
-  writeCmdPacket(pkt, pktLen);
-
-  // now read a response
-  const int rPktLen = 12;
-  uint8_t rPkt[rPktLen];
-
-  getResponse(rPkt, rPktLen);
-
-  // check confirmation code
-  if (rPkt[9] != 0x00)
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": Invalid confirmation code");
-
-  m_password = pwd;
-
-  return true;
-}
-
-bool ZFM20::setNewAddress(uint32_t addr)
-{
-  const int pktLen = 5;
-  uint8_t pkt[pktLen] = {CMD_SET_ADDRESS,
-                         static_cast<uint8_t>((addr >> 24) & 0xff),
-                         static_cast<uint8_t>((addr >> 16) & 0xff),
-                         static_cast<uint8_t>((addr >> 8) & 0xff),
-                         static_cast<uint8_t>(addr & 0xff) };
-
-  writeCmdPacket(pkt, pktLen);
-
-  // now read a response
-  const int rPktLen = 12;
-  uint8_t rPkt[rPktLen];
-
-  getResponse(rPkt, rPktLen);
-
-  // check confirmation code
-  if (rPkt[9] != 0x00)
-      throw std::runtime_error(std::string(__FUNCTION__) +
-                               ": Invalid confirmation code");
-
-  m_address = addr;
-
-  return true;
-}
-
-uint8_t ZFM20::generateImage()
-{
-  const int pktLen = 1;
-  uint8_t pkt[pktLen] = {CMD_GEN_IMAGE};
-
-  writeCmdPacket(pkt, pktLen);
-
-  // now read a response
-  const int rPktLen = 12;
-  uint8_t rPkt[rPktLen];
-
-  getResponse(rPkt, rPktLen);
-
-  return rPkt[9];
-}
-
-uint8_t ZFM20::image2Tz(int slot)
-{
-  if (slot != 1 && slot != 2)
-      throw std::out_of_range(std::string(__FUNCTION__) +
-                              ": slot must be 1 or 2");
-
-  const int pktLen = 2;
-  uint8_t pkt[pktLen] = {CMD_IMG2TZ,
-                         static_cast<uint8_t>(slot & 0xff)};
-
-  writeCmdPacket(pkt, pktLen);
-
-  // now read a response
-  const int rPktLen = 12;
-  uint8_t rPkt[rPktLen];
-
-  getResponse(rPkt, rPktLen);
-
-  return rPkt[9];
-}
-
-uint8_t ZFM20::createModel()
-{
-  const int pktLen = 1;
-  uint8_t pkt[pktLen] = {CMD_REGMODEL};
-
-  writeCmdPacket(pkt, pktLen);
-
-  // now read a response
-  const int rPktLen = 12;
-  uint8_t rPkt[rPktLen];
-
-  getResponse(rPkt, rPktLen);
-
-  return rPkt[9];
-}
-
-uint8_t ZFM20::storeModel(int slot, uint16_t id)
-{
-  if (slot != 1 && slot != 2)
-      throw std::out_of_range(std::string(__FUNCTION__) +
-                              ": slot must be 1 or 2");
-
-  const int pktLen = 4;
-  uint8_t pkt[pktLen] = {CMD_STORE,
-                         static_cast<uint8_t>(slot & 0xff),
-                         static_cast<uint8_t>((id >> 8) & 0xff),
-                         static_cast<uint8_t>(id & 0xff)};
-
-  writeCmdPacket(pkt, pktLen);
-
-  // now read a response
-  const int rPktLen = 12;
-  uint8_t rPkt[rPktLen];
-
-  getResponse(rPkt, rPktLen);
-
-  return rPkt[9];
-}
-
-uint8_t ZFM20::deleteModel(uint16_t id)
-{
-  const int pktLen = 5;
-  uint8_t pkt[pktLen] = {CMD_DELETE_TMPL,
-                         static_cast<uint8_t>((id >> 8) & 0xff),
-                         static_cast<uint8_t>(id & 0xff),
-                         0x00,
-                         0x01};
-
-  writeCmdPacket(pkt, pktLen);
-
-  // now read a response
-  const int rPktLen = 12;
-  uint8_t rPkt[rPktLen];
-
-  getResponse(rPkt, rPktLen);
-
-  return rPkt[9];
-}
-
-uint8_t ZFM20::deleteDB()
-{
-  const int pktLen = 1;
-  uint8_t pkt[pktLen] = {CMD_EMPTYDB};
-
-  writeCmdPacket(pkt, pktLen);
-
-  // now read a response
-  const int rPktLen = 12;
-  uint8_t rPkt[rPktLen];
-
-  getResponse(rPkt, rPktLen);
-
-  return rPkt[9];
-}
-
-uint8_t ZFM20::search(int slot, uint16_t &id, uint16_t &score)
-{
-  id = 0;
-  score = 0;
-
-  if (slot != 1 && slot != 2)
-      throw std::out_of_range(std::string(__FUNCTION__) +
-                              ": slot must be 1 or 2");
-
-  // search from page 0x0000 to page 0x00a3
-  const int pktLen = 6;
-  uint8_t pkt[pktLen] = {CMD_SEARCH,
-                         static_cast<uint8_t>(slot & 0xff),
-                         0x00,
-                         0x00,
-                         0x00,
-                         0xa3};
-
-  writeCmdPacket(pkt, pktLen);
-
-  // now read a response
-  const int rPktLen = 16;
-  uint8_t rPkt[rPktLen];
-
-  getResponse(rPkt, rPktLen);
-
-  // if it was found, extract the location and the score
-  if (rPkt[9] == ERR_OK)
-    {
-      id = ((rPkt[10] << 8) & 0xff) | (rPkt[11] & 0xff);
-      score = ((rPkt[12] << 8) & 0xff) | (rPkt[13] & 0xff);
-    }
-
-  return rPkt[9];
-}
-
-uint8_t ZFM20::match(uint16_t &score)
-{
-  score = 0;
-
-  const int pktLen = 1;
-  uint8_t pkt[pktLen] = {CMD_MATCH};
-
-  writeCmdPacket(pkt, pktLen);
-
-  // now read a response
-  const int rPktLen = 14;
-  uint8_t rPkt[rPktLen];
-
-  getResponse(rPkt, rPktLen);
-
-  score = ((rPkt[10] << 8) & 0xff) | (rPkt[11] & 0xff);
-
-  return rPkt[9];
-}
diff --git a/src/zfm20/zfm20.hpp b/src/zfm20/zfm20.hpp
deleted file mode 100644
index 8d32833..0000000
--- a/src/zfm20/zfm20.hpp
+++ /dev/null
@@ -1,373 +0,0 @@
-/*
- * Author: Jon Trulson <jtrulson@ics.com>
- * Copyright (c) 2015 Intel Corporation.
- *
- * Thanks to Adafruit for supplying a google translated version of the
- * Chinese datasheet and some clues in their code.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-#pragma once
-
-#include <string>
-#include <iostream>
-
-#include <stdint.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-#include <fcntl.h>
-#include <errno.h>
-#include <sys/select.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-
-#include "mraa.hpp"
-#include "upm_utilities.h"
-
-#define ZFM20_DEFAULT_UART 0
-
-// protocol start codes
-#define ZFM20_START1 0xef
-#define ZFM20_START2 0x01
-
-#define ZFM20_MAX_PKT_LEN 256
-
-#define ZFM20_TIMEOUT 5000 // in ms
-
-#define ZFM20_DEFAULT_PASSWORD 0x00000000
-#define ZFM20_DEFAULT_ADDRESS  0xffffffff
-
-
-namespace upm {
-    /**
-     * @brief ZFM-20 Fingerprint Sensor Module
-     * @defgroup zfm20 libupm-zfm20
-     * @ingroup seeed uart touch
-     */
-
-    /**
-     * @library zfm20
-     * @sensor zfm20
-     * @comname Fingerprint Sensor Module
-     * @altname Grove Fingerprint Sensor
-     * @type touch
-     * @man seeed
-     * @web http://wiki.seeed.cc/Grove-Fingerprint_Sensor/
-     * @con uart
-     *
-     * @brief API for the ZFM-20 Fingerprint Sensor Module
-     *
-     * This class was tested on the Grove Fingerprint Sensor
-     * Module. It can store up to 163 fingerprints.
-     *
-     * It is connected via a UART at 57,600 baud.
-     *
-     * @image html zfm20.jpg
-     * This example demonstrates how to register and store a new fingerprint
-     * @snippet zfm20-register.cxx Interesting
-     * This example demonstrates reading a fingerprint and locating it in the DB
-     * @snippet zfm20.cxx Interesting
-     */
-  class ZFM20 {
-  public:
-
-    // commands
-    typedef enum {
-      CMD_GEN_IMAGE                     = 0x01,
-      CMD_IMG2TZ                        = 0x02,
-      CMD_MATCH                         = 0x03,
-      CMD_SEARCH                        = 0x04,
-      CMD_REGMODEL                      = 0x05,
-      CMD_STORE                         = 0x06,
-      CMD_LOAD_TMPL                     = 0x07,
-      CMD_UPLOAD_TMPL                   = 0x08,
-      CMD_DOWNLOAD_TMPL                 = 0x09,
-      CMD_UPLOAD_IMAGE                  = 0x0a,
-      CMD_DOWNLOAD_IMAGE                = 0x0b,
-      CMD_DELETE_TMPL                   = 0x0c,
-      CMD_EMPTYDB                       = 0x0d,
-      CMD_SET_SYSPARAMS                 = 0x0e,
-      CMD_GET_SYSPARAMS                 = 0x0f,
-      CMD_SET_PASSWORD                  = 0x12,
-      CMD_VERIFY_PASSWORD               = 0x13,
-      CMD_GET_RANDOM_NUMBER             = 0x14,
-      CMD_SET_ADDRESS                   = 0x15,
-      CMD_GET_TMPL_COUNT                = 0x1d,
-      CMD_GET_INDEX_TABLE               = 0x1f
-    } ZFM20_COMMAND_T;
-
-    // Error response codes
-    typedef enum {
-      ERR_OK                            = 0x00,
-      ERR_PACKET_RX_ERROR               = 0x01,
-      ERR_NO_FINGER                     = 0x02,
-      ERR_FP_IMAGE_FAILED               = 0x03,
-      ERR_FP_TOO_MESSY                  = 0x06,
-      ERR_FP_IMAGE_FEW_FEATURES         = 0x07,
-      ERR_FP_NOMATCH                    = 0x08,
-      ERR_FP_NOTFOUND                   = 0x09,
-      ERR_FP_ENROLLMISMATCH             = 0x0a,
-      ERR_BAD_LOCATION                  = 0x0b,
-      ERR_DB_ERROR                      = 0x0c,
-      ERR_UPLOAD_FEAT_FAILED            = 0x0d,
-      ERR_NO_MORE_PACKETS               = 0x0e,
-      ERR_UPLOAD_IMG_FAILED             = 0x0f,
-      ERR_RM_TMPL_FAILED                = 0x10,
-      ERR_EMPTY_DB_FAILED               = 0x11,
-      ERR_INVALID_PWD                   = 0x13,
-      ERR_INVALID_IMAGE                 = 0x15,
-      ERR_RW_FLASH_ERROR                = 0x18,
-      ERR_INVALID_REG                   = 0x1a,
-      ERR_INVALID_ADDR                  = 0x20,
-      ERR_NEEDS_PWD                     = 0x21,
-      // end of module-specific errors
-      ERR_INTERNAL_ERR                  = 0xff  // API internal error
-    } ZFM20_ERRORS_T;
-
-    typedef enum {
-      PKT_COMMAND                       = 0x01,
-      PKT_DATA                          = 0x02,
-      PKT_ACK                           = 0x07,
-      PKT_END_DATA                      = 0x08
-    } ZFM20_PKTCODES_T;
-
-    /**
-     * ZFM20 constructor
-     *
-     * @param uart Target mraa UART index to use (0 or 1)
-     * @param baud Desired baud rate
-     */
-    ZFM20(int uart, int baud = 57600);
-
-    /**
-     * ZFM20 constructor
-     *
-     * @param uart File path (/dev/ttyXXX to uart
-     * @param baud Desired baud rate
-     */
-    ZFM20(std::string uart_raw, int baud = 57600);
-
-    /**
-     * ZFM20 destructor
-     */
-    virtual ~ZFM20() {}
-
-    /**
-     * Reads any available data in a user-supplied buffer. Note: the
-     * call blocks until data is available to be read. Use
-     * dataAvailable() to determine whether there is data available
-     * beforehand, to avoid blocking.
-     *
-     * @param buffer Buffer to hold the data read
-     * @param len Length of the buffer
-     * @return Number of bytes read
-     */
-    int readData(char *buffer, int len);
-
-    /**
-     * Writes the data in the buffer to the device
-     *
-     * @param buffer Buffer to hold the data read
-     * @param len Length of the buffer
-     * @return Number of bytes written
-     */
-    int writeData(char *buffer, int len);
-
-    /**
-     * Sets up proper tty I/O modes and the baud rate. For this device,
-     * the default baud rate is 57,600.
-     *
-     * @param baud Desired baud rate.
-     * @return True if successful
-     */
-    bool setupTty(uint32_t baud = 57600);
-
-    /**
-     * Composes and writes a command packet
-     *
-     * @param pkt Packet
-     * @param len Length of packet
-     * @return Number of bytes written
-     */
-    int writeCmdPacket(uint8_t *pkt, int len);
-
-    /**
-     * Verifies the packet header and indicates its validity
-     *
-     * @param pkt Packet to check
-     * @param len Length of packet
-     * @return True if the packet is valid, false otherwise
-     */
-    bool verifyPacket(uint8_t *pkt, int len);
-
-    /**
-     * Returns the number of milliseconds elapsed since initClock()
-     * was last called
-     *
-     * @return Elapsed milliseconds
-     */
-    uint32_t getMillis();
-
-    /**
-     * Resets the clock
-     *
-     */
-    void initClock();
-
-    /**
-     * Sets the address that should be used to access the module
-     *
-     * @param addr Address to use
-     */
-    void setAddress(uint32_t addr) { m_address = addr; };
-
-    /**
-     * Sets the password that should be used to access the module
-     *
-     * @param pw Password to use
-     */
-    void setPassword(uint32_t pw) { m_password = pw; };
-
-    /**
-     * Gets the returned data from a request
-     *
-     * @param pkt Buffer to store the returned data
-     * @param len Expected response length; pkt should be at least this
-     * large
-     * @return True if successful
-     */
-    bool getResponse(uint8_t *pkt, int len);
-
-    /**
-     * Verifies and authenticates to the module. The password used is
-     * the last one set by setPassword().
-     *
-     * @return True if successful
-     */
-    bool verifyPassword();
-
-    /**
-     * Queries the module for the number of stored templates
-     * (fingerprints).
-     *
-     * @return Number of currently stored templates
-     */
-    int getNumTemplates();
-
-    /**
-     * Sets a new password for the module. This passowrd is
-     * stored in the module, and is required to access
-     * the module in the future.
-     *
-     * @param pwd New password to set on the module
-     * @return True if successful
-     */
-    bool setNewPassword(uint32_t pwd);
-
-    /**
-     * Sets a new address for the module. This address is
-     * stored in the module, and is required to access
-     * the module in the future.
-     *
-     * @param addr New address to set on the module
-     * @return True if successful
-     */
-    bool setNewAddress(uint32_t addr);
-
-    /**
-     * Generates a new fingerprint image (scans a fingerprint)
-     *
-     * @return One of the ZFM20_ERRORS_T values
-     */
-    uint8_t generateImage();
-
-    /**
-     * Converts the image in the image buffer (generated by
-     * generateImage()) and stores it in one of the two characteristics
-     * buffers, 1 or 2
-     *
-     * @param slot Characteristics buffer to use; must be 1 or 2
-     * @return One of the ZFM20_ERRORS_T values
-     */
-    uint8_t image2Tz(int slot);
-
-    /**
-     * Based on the two characteristics buffers (1 & 2), creates a
-     * fingerprint model. Once a model is successfully created,
-     * it can be stored in the module with storeModel().
-     *
-     * @return One of the ZFM20_ERRORS_T values
-     */
-    uint8_t createModel();
-
-    /**
-     * Once a fingerprint model is created, this method can be
-     * used to store it (via one of the characteristics buffers) in a
-     * given location.
-     *
-     * @param slot Characteristics buffer to store the model, 1 or 2
-     * @param id Location to store the model
-     * @return One of the ZFM20_ERRORS_T values
-     */
-    uint8_t storeModel(int slot, uint16_t id);
-
-    /**
-     * Deletes a stored model
-     *
-     * @param id Location containing the model to delete
-     * @return One of the ZFM20_ERRORS_T values
-     */
-    uint8_t deleteModel(uint16_t id);
-
-    /**
-     * Deletes the model database (DB)
-     *
-     * @return One of the ZFM20_ERRORS_T values
-     */
-    uint8_t deleteDB();
-
-    /**
-     * Searches the fingerprint DB and returns an ID and score, if found
-     *
-     *
-     * @param slot Slot containing a converted image to search for
-     * @param id ID if found, 0 otherwise
-     * @param score Score if found, 0 otherwise
-     * @return One of the ZFM20_ERRORS_T values
-     */
-    uint8_t search(int slot, uint16_t &id, uint16_t &score);
-
-    /**
-     * Compares the features in characteristics buffers 1 and 2 and
-     * returns a score if they match
-     *
-     * @param score Score
-     * @return One of the ZFM20_ERRORS_T values
-     */
-    uint8_t match(uint16_t &score);
-
-  private:
-    mraa::Uart m_uart;
-    uint32_t m_password;
-    uint32_t m_address;
-    upm_clock_t m_clock;
-  };
-}
diff --git a/src/zfm20/zfm20.i b/src/zfm20/zfm20.i
deleted file mode 100644
index e93aa2f..0000000
--- a/src/zfm20/zfm20.i
+++ /dev/null
@@ -1,24 +0,0 @@
-%include "../common_top.i"
-
-/* BEGIN Java syntax  ------------------------------------------------------- */
-#ifdef SWIGJAVA
-%include "arrays_java.i";
-%include "../java_buffer.i";
-
-JAVA_JNI_LOADLIBRARY(javaupm_zfm20)
-#endif
-/* END Java syntax */
-
-/* BEGIN Common SWIG syntax ------------------------------------------------- */
-%apply uint16_t &OUTPUT {uint16_t &id};
-%apply uint16_t &OUTPUT {uint16_t &score};
-%include "../carrays_uint8_t.i"
-%include "../carrays_uint16_t.i"
-%include "../carrays_uint32_t.i"
-%pointer_functions(int, intp);
-
-%{
-#include "zfm20.hpp"
-%}
-%include "zfm20.hpp"
-/* END Common SWIG syntax */
diff --git a/src/zfm20/zfm20.json b/src/zfm20/zfm20.json
deleted file mode 100644
index 6e02808..0000000
--- a/src/zfm20/zfm20.json
+++ /dev/null
@@ -1,66 +0,0 @@
-{
-    "Library": "zfm20",
-    "Description": "ZFM-20 Fingerprint Sensor Module",
-    "Sensor Class": {
-        "ZFM20": {
-            "Name": "API for the ZFM-20 Fingerprint Sensor Module",
-            "Description": "This is the UPM Module for the ZFM-20 Fingerprint Sensor Module. The Fingerprint Sensor is one optical fingerprint sensor which will make adding fingerprint detection and verification super simple.There's a high powered DSP chip AS601 that does the image rendering, calculation, feature-finding and searching. You can also enroll new fingers directly - up to 162 finger prints can be stored in the onboard FLASH memory. There's a red LED in the lens that lights up during a photo so you know its working.",
-            "Aliases": ["zfm20", "Grove - Fingerprint Sensor"],
-            "Categories": ["touch"],
-            "Connections": ["uart"],
-            "Project Type": ["medical", "prototyping"],
-            "Manufacturers": ["Seeed", "ZhianTec"],
-            "Image": "zfm20.jpg",
-            "Examples": {
-                "Java": ["ZFM20_Example.java"],
-                "Python": ["zfm20-register.py", "zfm20.py"],
-                "Node.js": ["zfm20-register.js", "zfm20.js"],
-                "C++": ["zfm20-register.cxx", "zfm20.cxx"]
-            },
-            "Specifications": {
-                "Vsource": {
-                    "unit": "V",
-                    "min": 3.6,
-                    "max": 6.0
-                },
-                "Supply Current": {
-                    "unit": "mA",
-                    "max" : 120
-                },
-                "Operating Temperature": {
-                    "unit": "°C",
-                    "min": -20,
-                    "max": 50
-                },
-                "Imaging Time": {
-                    "unit": "s",
-                    "typ" : 1
-                },
-                "False Acceptance Rate": {
-                    "unit": "%",
-                    "rate": 0.001
-                },
-                "False Reject Rate": {
-                    "unit": "%",
-                    "rate": 1.0
-                },
-                "Baud Rate": {
-                    "unit" : "bps",
-                    "default": 57600
-                }
-            },
-            "Platforms": {
-                "Intel Edison": {
-                    "Notes": ["Might need Grove base shield"]
-                },
-                "Arduino 101": {
-                    "Notes": ["Might need Grove base shield"]
-                }
-            },
-            "Urls": {
-                "Product Pages": ["https://www.seeedstudio.com/Grove-Fingerprint-Sensor-p-1424.html", "http://wiki.seeed.cc/Grove-Fingerprint_Sensor/"],
-                "Datasheets": ["https://raw.githubusercontent.com/SeeedDocument/Grove-Fingerprint_Sensor/master/res/ZFM206%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8CV2.1.pdf", "https://github.com/SeeedDocument/Grove-Fingerprint_Sensor/raw/master/res/ZFM-user-manualV15.pdf"]
-            }
-        }
-    }
-}
-- 
2.7.4

